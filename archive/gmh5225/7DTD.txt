Project Path: arc_gmh5225_7DTD_rfsv7u6x

Source Tree:

```txt
arc_gmh5225_7DTD_rfsv7u6x
├── 7DTD
│   ├── 7DTD.csproj
│   ├── Aimbot.cs
│   ├── Auth.cs
│   ├── Configs
│   │   ├── Aimbot.cs
│   │   ├── Animal.cs
│   │   ├── Colours.cs
│   │   ├── Config.cs
│   │   ├── Friends.cs
│   │   ├── LocalPlayer.cs
│   │   ├── Player.cs
│   │   ├── Tiles.cs
│   │   └── Zombie.cs
│   ├── Drawing.cs
│   ├── Esp
│   │   ├── Animal.cs
│   │   ├── Player.cs
│   │   ├── Tiles.cs
│   │   └── Zombie.cs
│   ├── Globals.cs
│   ├── Helpers
│   │   ├── Access.cs
│   │   ├── ColourHelper.cs
│   │   ├── ConfigHelper.cs
│   │   ├── DumbHook.cs
│   │   ├── RaycastHelper.cs
│   │   └── ShaderHelper.cs
│   ├── Hooks
│   │   ├── GetRange.cs
│   │   ├── IsOwner.cs
│   │   ├── OnBlockDamaged.cs
│   │   ├── OnFired.cs
│   │   └── UpdateAccuracy.cs
│   ├── Loader.cs
│   ├── Menu
│   │   ├── Button.cs
│   │   ├── Entity.cs
│   │   ├── FloatSlider.cs
│   │   ├── IntSlider.cs
│   │   ├── Keybind.cs
│   │   ├── Main.cs
│   │   ├── SubMenu.cs
│   │   └── Toggle.cs
│   ├── Misc.cs
│   └── Properties
│       └── AssemblyInfo.cs
├── 7DTD.sln
├── Client
│   ├── Client.vcxproj
│   ├── Client.vcxproj.filters
│   ├── Main.cpp
│   ├── Networking
│   │   ├── TCPClient.cpp
│   │   └── TCPClient.h
│   ├── Security
│   │   ├── LazyImporter.h
│   │   ├── VMProtectSDK.h
│   │   └── Xorstr.h
│   └── Util
│       ├── Encryption.cpp
│       ├── Encryption.h
│       ├── File.cpp
│       ├── File.h
│       ├── Hwid.cpp
│       ├── Hwid.h
│       ├── Screenshot.cpp
│       └── Screenshot.h
├── Images
│   ├── 1.png
│   ├── 2.png
│   ├── 3.png
│   ├── 4.png
│   ├── 5.jpg
│   ├── 6.png
│   ├── 7.png
│   ├── 8.png
│   └── 9.png
├── README.md
├── Server
│   ├── Database
│   │   ├── DBHandler.cpp
│   │   └── DBHandler.h
│   ├── Networking
│   │   ├── TCPClient.cpp
│   │   └── TCPClient.h
│   ├── Server.cpp
│   ├── Server.vcxproj
│   ├── Server.vcxproj.filters
│   └── Util
│       ├── Encryption.cpp
│       ├── Encryption.h
│       ├── File.cpp
│       ├── File.h
│       ├── SHA256.cpp
│       └── SHA256.h
└── Shaders
    ├── Shader1
    ├── Shader2
    └── Shader3

```

`7DTD.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31005.135
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Server", "Server\Server.vcxproj", "{DCD90186-FFE1-4D0E-B5EA-F5EF98E685BA}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Client", "Client\Client.vcxproj", "{6BED536D-3883-45D4-BD6C-13591E96380C}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "7DTD", "7DTD\7DTD.csproj", "{EAACF9E7-F7AC-42EA-BBED-8CC14A9D8F81}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|Any CPU = Release|Any CPU
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{DCD90186-FFE1-4D0E-B5EA-F5EF98E685BA}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{DCD90186-FFE1-4D0E-B5EA-F5EF98E685BA}.Debug|x64.ActiveCfg = Debug|x64
		{DCD90186-FFE1-4D0E-B5EA-F5EF98E685BA}.Debug|x64.Build.0 = Debug|x64
		{DCD90186-FFE1-4D0E-B5EA-F5EF98E685BA}.Debug|x86.ActiveCfg = Debug|Win32
		{DCD90186-FFE1-4D0E-B5EA-F5EF98E685BA}.Debug|x86.Build.0 = Debug|Win32
		{DCD90186-FFE1-4D0E-B5EA-F5EF98E685BA}.Release|Any CPU.ActiveCfg = Release|Win32
		{DCD90186-FFE1-4D0E-B5EA-F5EF98E685BA}.Release|x64.ActiveCfg = Release|x64
		{DCD90186-FFE1-4D0E-B5EA-F5EF98E685BA}.Release|x64.Build.0 = Release|x64
		{DCD90186-FFE1-4D0E-B5EA-F5EF98E685BA}.Release|x86.ActiveCfg = Release|Win32
		{DCD90186-FFE1-4D0E-B5EA-F5EF98E685BA}.Release|x86.Build.0 = Release|Win32
		{6BED536D-3883-45D4-BD6C-13591E96380C}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{6BED536D-3883-45D4-BD6C-13591E96380C}.Debug|x64.ActiveCfg = Debug|x64
		{6BED536D-3883-45D4-BD6C-13591E96380C}.Debug|x64.Build.0 = Debug|x64
		{6BED536D-3883-45D4-BD6C-13591E96380C}.Debug|x86.ActiveCfg = Debug|Win32
		{6BED536D-3883-45D4-BD6C-13591E96380C}.Debug|x86.Build.0 = Debug|Win32
		{6BED536D-3883-45D4-BD6C-13591E96380C}.Release|Any CPU.ActiveCfg = Release|Win32
		{6BED536D-3883-45D4-BD6C-13591E96380C}.Release|x64.ActiveCfg = Release|x64
		{6BED536D-3883-45D4-BD6C-13591E96380C}.Release|x64.Build.0 = Release|x64
		{6BED536D-3883-45D4-BD6C-13591E96380C}.Release|x86.ActiveCfg = Release|Win32
		{6BED536D-3883-45D4-BD6C-13591E96380C}.Release|x86.Build.0 = Release|Win32
		{EAACF9E7-F7AC-42EA-BBED-8CC14A9D8F81}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{EAACF9E7-F7AC-42EA-BBED-8CC14A9D8F81}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{EAACF9E7-F7AC-42EA-BBED-8CC14A9D8F81}.Debug|x64.ActiveCfg = Debug|Any CPU
		{EAACF9E7-F7AC-42EA-BBED-8CC14A9D8F81}.Debug|x64.Build.0 = Debug|Any CPU
		{EAACF9E7-F7AC-42EA-BBED-8CC14A9D8F81}.Debug|x86.ActiveCfg = Debug|Any CPU
		{EAACF9E7-F7AC-42EA-BBED-8CC14A9D8F81}.Debug|x86.Build.0 = Debug|Any CPU
		{EAACF9E7-F7AC-42EA-BBED-8CC14A9D8F81}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{EAACF9E7-F7AC-42EA-BBED-8CC14A9D8F81}.Release|Any CPU.Build.0 = Release|Any CPU
		{EAACF9E7-F7AC-42EA-BBED-8CC14A9D8F81}.Release|x64.ActiveCfg = Release|Any CPU
		{EAACF9E7-F7AC-42EA-BBED-8CC14A9D8F81}.Release|x64.Build.0 = Release|Any CPU
		{EAACF9E7-F7AC-42EA-BBED-8CC14A9D8F81}.Release|x86.ActiveCfg = Release|Any CPU
		{EAACF9E7-F7AC-42EA-BBED-8CC14A9D8F81}.Release|x86.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {9B2EC572-42C2-4E19-9C8E-B4ED84DAE1AB}
	EndGlobalSection
EndGlobal

```

`7DTD/7DTD.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{EAACF9E7-F7AC-42EA-BBED-8CC14A9D8F81}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>Cheat</RootNamespace>
    <AssemblyName>7DTD</AssemblyName>
    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <Deterministic>true</Deterministic>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Assembly-CSharp">
      <HintPath>..\..\..\..\..\Program Files (x86)\Steam\steamapps\common\7 Days To Die\7DaysToDie_Data\Managed\Assembly-CSharp.dll</HintPath>
    </Reference>
    <Reference Include="Newtonsoft.Json, Version=8.0.0.0, Culture=neutral, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>..\..\..\..\..\Program Files (x86)\Steam\steamapps\common\7 Days To Die\7DaysToDie_Data\Managed\Newtonsoft.Json.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Security" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
    <Reference Include="UnityEngine">
      <HintPath>..\..\..\..\..\Program Files (x86)\Steam\steamapps\common\7 Days To Die\7DaysToDie_Data\Managed\UnityEngine.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.AssetBundleModule, Version=0.0.0.0, Culture=neutral, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>..\..\..\..\..\Program Files (x86)\Steam\steamapps\common\7 Days To Die\7DaysToDie_Data\Managed\UnityEngine.AssetBundleModule.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.CoreModule">
      <HintPath>..\..\..\..\..\Program Files (x86)\Steam\steamapps\common\7 Days To Die\7DaysToDie_Data\Managed\UnityEngine.CoreModule.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.IMGUIModule">
      <HintPath>..\..\..\..\..\Program Files (x86)\Steam\steamapps\common\7 Days To Die\7DaysToDie_Data\Managed\UnityEngine.IMGUIModule.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.InputLegacyModule">
      <HintPath>..\..\..\..\..\Program Files (x86)\Steam\steamapps\common\7 Days To Die\7DaysToDie_Data\Managed\UnityEngine.InputLegacyModule.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.InputModule">
      <HintPath>..\..\..\..\..\Program Files (x86)\Steam\steamapps\common\7 Days To Die\7DaysToDie_Data\Managed\UnityEngine.InputModule.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.PhysicsModule">
      <HintPath>..\..\..\..\..\Program Files (x86)\Steam\steamapps\common\7 Days To Die\7DaysToDie_Data\Managed\UnityEngine.PhysicsModule.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.TextCoreModule">
      <HintPath>..\..\..\..\..\Program Files (x86)\Steam\steamapps\common\7 Days To Die\7DaysToDie_Data\Managed\UnityEngine.TextCoreModule.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.TextRenderingModule">
      <HintPath>..\..\..\..\..\Program Files (x86)\Steam\steamapps\common\7 Days To Die\7DaysToDie_Data\Managed\UnityEngine.TextRenderingModule.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.UI">
      <HintPath>..\..\..\..\..\Program Files (x86)\Steam\steamapps\common\7 Days To Die\7DaysToDie_Data\Managed\UnityEngine.UI.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.UIModule">
      <HintPath>..\..\..\..\..\Program Files (x86)\Steam\steamapps\common\7 Days To Die\7DaysToDie_Data\Managed\UnityEngine.UIModule.dll</HintPath>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Aimbot.cs" />
    <Compile Include="Auth.cs" />
    <Compile Include="Configs\Aimbot.cs" />
    <Compile Include="Configs\Animal.cs" />
    <Compile Include="Configs\Colours.cs" />
    <Compile Include="Configs\Config.cs" />
    <Compile Include="Configs\Friends.cs" />
    <Compile Include="Configs\LocalPlayer.cs" />
    <Compile Include="Configs\Player.cs" />
    <Compile Include="Configs\Tiles.cs" />
    <Compile Include="Configs\Zombie.cs" />
    <Compile Include="Drawing.cs" />
    <Compile Include="Esp\Animal.cs" />
    <Compile Include="Esp\Player.cs" />
    <Compile Include="Esp\Tiles.cs" />
    <Compile Include="Esp\Zombie.cs" />
    <Compile Include="Globals.cs" />
    <Compile Include="Helpers\Access.cs" />
    <Compile Include="Helpers\ColourHelper.cs" />
    <Compile Include="Helpers\ConfigHelper.cs" />
    <Compile Include="Helpers\DumbHook.cs" />
    <Compile Include="Helpers\RaycastHelper.cs" />
    <Compile Include="Helpers\ShaderHelper.cs" />
    <Compile Include="Hooks\GetRange.cs" />
    <Compile Include="Hooks\IsOwner.cs" />
    <Compile Include="Hooks\OnBlockDamaged.cs" />
    <Compile Include="Hooks\OnFired.cs" />
    <Compile Include="Hooks\UpdateAccuracy.cs" />
    <Compile Include="Loader.cs" />
    <Compile Include="Menu\Button.cs" />
    <Compile Include="Menu\Entity.cs" />
    <Compile Include="Menu\FloatSlider.cs" />
    <Compile Include="Menu\IntSlider.cs" />
    <Compile Include="Menu\Keybind.cs" />
    <Compile Include="Menu\Main.cs" />
    <Compile Include="Menu\SubMenu.cs" />
    <Compile Include="Menu\Toggle.cs" />
    <Compile Include="Misc.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>
```

`7DTD/Aimbot.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
namespace Cheat
{
    class Aimbot : MonoBehaviour
    {
        // EnumPlayerKillingMode look into so you can try to disable pve
        // TODO: Add friendslist
        // Fix Box Height
        public static EntityEnemy Zombie; // assign our values here so we dont need to keep calling the targetzombie/player function which loops through loads of stuff
        public static EntityPlayer Player;
        public static Vector3 ZombieHitPos;
        public static Vector3 PlayerHitPos;
        public static bool TargettingPlayer = false;
        public static bool TargettingZombie = false;

        // We sort closest to crosshair so we will get the first target which is closest

        private static List<T> EntityClosestToCrosshair<T>(List<T> entitylist) where T : EntityAlive
        {
            return (from entity in entitylist
                    orderby Vector2.Distance(new Vector2((float)(Screen.width / 2), (float)(Screen.height / 2)), Camera.main.WorldToScreenPoint(entity.transform.position)) ascending,
                    Vector3.Distance(entity.transform.position,Globals.MainCamera.transform.position) ascending
                    select entity).ToList<T>();
        }
       
        EntityEnemy TargetZombie()
        {
            EntityEnemy result = new EntityZombie();
            try
            {
            
            if (!Globals.Config.Aimbot.ZombieAimbot)
                return result; // returns null
            if (Globals.LocalPlayer == null)
                return result; // returns null, checks if the player is null, something might break if its null
           
           

                foreach (EntityEnemy zombie in EntityClosestToCrosshair(Esp.Zombie.ZombieList))
                {
                  
                        if (!(zombie.IsAlive()) || zombie == null)
                        continue;

                    Vector3 Pos = zombie.emodel.GetHeadTransform().position;
                    if (!Globals.IsScreenPointVisible(Globals.WorldPointToScreenPoint(Pos)))
                        continue; // check if the zombie is on screen
                    int fov = (int)Vector2.Distance(new Vector2(Screen.width / 2, Screen.height / 2), new Vector2(Globals.WorldPointToScreenPoint(Pos).x, Globals.WorldPointToScreenPoint(Pos).y));
                    if (fov > Globals.Config.Aimbot.Fov)
                        continue; // are they in fov?

                    if (Globals.Config.Aimbot.ZombieVisibilityChecks && !Helpers.RaycastHelper.VisbilityCheck(zombie, Pos))
                        continue; // if visibility checks are enabled then check if they are visible.



                    return zombie;
                }

            }
            catch { }
            return result; // must have a return, so return null

        }
        EntityPlayer TargetPlayer()
        {

            EntityPlayer result = new EntityPlayer();
            try
            {
                if (!Globals.Config.Aimbot.PlayerAimbot)
                return result;
            if (Globals.LocalPlayer == null)
                return result;
          
            

                foreach (EntityPlayer player in EntityClosestToCrosshair(Esp.Player.PlayerList))
                {
                    if (Globals.LocalPlayer.IsFriendsWith(player) && Globals.Config.Aimbot.PlayerAimbotTargetFriends) // make check so they can turn off this check
                        continue;

                    if (player == null)
                        continue; // check if the player is real
                    if (player.Health <= 0)
                        continue; // are they alive
                    if (player.IsAlive() == false)
                        continue; // another alive check
                    if (player.IsSleeping)
                        continue; // checking if the player is alive


                    Vector3 Pos = player.emodel.GetHeadTransform().position;

                    if (!Globals.IsScreenPointVisible(Globals.WorldPointToScreenPoint(Pos)))
                        continue; // is the player on screen

                    int fov = (int)Vector2.Distance(new Vector2(Screen.width / 2, Screen.height / 2), new Vector2(Globals.WorldPointToScreenPoint(Pos).x, Globals.WorldPointToScreenPoint(Pos).y));
                    if (fov > Globals.Config.Aimbot.Fov)
                        continue; // is the user in the aimbot fov

                    if (Globals.Config.Aimbot.PlayerVisibilityChecks && !Helpers.RaycastHelper.VisbilityCheck(player, Pos))
                        continue; // if vis checks are on then vis check them

                    return player;
                }

            }
            catch { }
            return result;

        }
        void OnGUI()
        {
            // so basically we cant target a player and zombie at the same time as we exit the function in the silentaim method when we have a target
            try
            {
                if (Globals.LocalPlayer == null)
                    return;

                if (Globals.Config.Aimbot.DrawFov)
                    Drawing.DrawCircle(Helpers.ColourHelper.GetColour("Aimbot Fov Colour"), new Vector2(Screen.width / 2, Screen.height / 2), Globals.Config.Aimbot.Fov); // draw fov circle

                if ((Zombie == null) && Player == null)
                    return;
                //   TargetZombie();
                Vector3 pos = Vector3.zero;
                if (TargettingPlayer)
                    pos = PlayerHitPos;
                if (TargettingZombie)
                    pos = ZombieHitPos;
                pos = Globals.WorldPointToScreenPoint(pos);
                // get the aimbot pos, w2s it


                if (Globals.Config.Aimbot.DrawTargetLine && Globals.IsScreenPointVisible(pos) && pos != Vector3.zero && pos != null) // check if the target position is on screen and not null, check if target line is enabled
                    Drawing.DrawLine(new Vector2(Screen.width / 2, Screen.height / 2), new Vector2(pos.x, pos.y), Helpers.ColourHelper.GetColour("Aimbot Target Line Colour"), 1); // draw a line to target
            }
            catch { }
        }
        void SilentAim()
        {
            if (Globals.LocalPlayer == null || Globals.MainCamera == null)
                return; // check if we should be aimbotting
            System.Random rand = new System.Random();
            if (rand.Next(0, 100) >= Globals.Config.Aimbot.Hitchance)
                return; // random value is over hitchance?

            if (Aimbot.Player != null)
            {
               
                TargettingPlayer = true;
                if (!Input.GetKey(Globals.Config.Aimbot.PlayerKey))
                    return; // player aimbot key being held?
                Globals.LocalPlayer.transform.eulerAngles = new Vector3(0f, Globals.LocalPlayer.transform.rotation.eulerAngles.y, 0f); // null x and y
                Camera.main.transform.LookAt(PlayerHitPos); // set lookat angles to hitpos
                return; // stop it changing target to zombie(proritising players)
            }
            TargettingPlayer = false;
            if (Aimbot.Zombie != null)
            {
               
                TargettingZombie = true;
                if (!Input.GetKey(Globals.Config.Aimbot.ZombieKey))
                    return; // Zombie key being held?
                Globals.LocalPlayer.transform.eulerAngles = new Vector3(0f, Globals.LocalPlayer.transform.rotation.eulerAngles.y, 0f); // null x and y
                Camera.main.transform.LookAt(ZombieHitPos); // set looking at angles to hitpos
                return;
            }
            TargettingZombie = false;
        }
        public bool IsFriend(EntityPlayer player)
        {
            if (player.Party?.PartyID == 0)
                return false; // null or not in party?
            if (Globals.LocalPlayer?.Party?.PartyID == 0)
                return false; // is it null? not in a party?
            if (Globals.LocalPlayer.Party.PartyID == player.Party.PartyID)
                return true; // check if the partyid is the same as the local player
         
            return false;

        }
        void SetZombieAimPos()
        {
         
            if (Aimbot.Zombie == null)
                return;
          
                ZombieHitPos = Zombie.emodel.GetHeadTransform().position;
        }
        void SetPlayerAimPos()
        {
            
           
            if (Aimbot.Player == null)
                return;
                PlayerHitPos = Player.emodel.GetHeadTransform().position;
        }
        void Update()
        {
            Zombie = TargetZombie();
           SetZombieAimPos();
            Player = TargetPlayer();
            SetPlayerAimPos();
            SilentAim();
          
        }
    }
}

```

`7DTD/Auth.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Pipes;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace Cheat
{

    public class Load // renamed from auth so a moron looking through it in dnspy will have less of an idea what we are doing, we cant have this class obfuscated since we call it to load the cheat.
    {
        // Clean up our files, probably best to do this in our loader.
        // join locked/private servers
        // encrypt config
        public static void Start()
        {
            Globals.Auth();
        }
    }
}

```

`7DTD/Configs/Aimbot.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
namespace Cheat.Configs
{
    class Aimbot
    {
        public int Fov = 200;
        public bool DrawFov = true;
        public bool DrawTargetLine = true;
        public int Hitchance = 100;

        public bool ZombieAimbot = true;
        public bool ZombieVisibilityChecks = true;
        public KeyCode ZombieKey = KeyCode.Mouse0;

        public bool PlayerAimbot = true;
        public bool PlayerAimbotTargetFriends = false;
        public bool PlayerVisibilityChecks = true;
        public KeyCode PlayerKey = KeyCode.Mouse0;
        

    }
}

```

`7DTD/Configs/Animal.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Cheat.Configs
{
    class Animal
    {

        public bool Name = true;
        public bool Health = true;
        public bool Distance = true;
        public int MaxDistance = 100;
    }
}

```

`7DTD/Configs/Colours.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
namespace Cheat.Configs
{
    class Colours
    {
        public Dictionary<string, Color32> GlobalColors = new Dictionary<string, Color32>();
    }
}

```

`7DTD/Configs/Config.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Cheat.Configs
{
    class Config
    {
        public Colours Colours = new Colours();
        public Player Player = new Player();
        public Zombie Zombie = new Zombie();
        public Animal Animal = new Animal();
        public LocalPlayer LocalPlayer = new LocalPlayer();
        public Aimbot Aimbot = new Aimbot();
        public Friends Friends = new Friends();
        public Tiles Tiles = new Tiles();
    }
}

```

`7DTD/Configs/Friends.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Cheat.Configs
{
    class Friends
    {
        public List<uint> FriendsList = new List<uint>();
    }
}

```

`7DTD/Configs/LocalPlayer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
namespace Cheat.Configs
{
    class LocalPlayer
    {
        public bool NoSpread = true;
        public bool NoRecoil = true;
        public bool NoViewBob = true;
        public bool UnlimitedAmmo = true;
        public bool UnlimitedRange = true;
        public bool WeaponFovChanger = false;
        public bool CameraFovChanger = false;
        public int WeaponFov = 90;
        public int CameraFov = 90;

        public int Kills = 0;
        public int Deaths = 0;
        public int ZombieKills = 0;
        public int Level = 0;
        public int SkillPoints = 0;
        public int ItemsCrafted = 0;
        public int DistanceTravelled = 0;
        public int TimePlayed = 0;

        public KeyCode SpeedKey = KeyCode.B;
        public int SpeedAmount = 10;
        public bool Speedhack = false;
        public bool BtecNoclip = true;
        public KeyCode NoclipKey = KeyCode.N;
        public int NoclipSpeed = 5;


        public bool UnlimitedStamina = true;
        public bool UnlimitedHunger = true;
        public bool UnlimitedThirtst = true;
        public bool InstantHealth = true;
        public bool AllahMode = false;
        public bool SpoofName = true;
        public bool SpoofID = false;
        public bool RandomlySpoofName = false;
        public bool ClearDebuffs = false;

        public bool LandClaim = true;
        public bool InstantBreak1 = true;
        public bool InstantBreak2 = false;
        public bool InstantBreak3 = false;
        public bool DebugMenu = true;
        public bool CreativeMenu = true;
        public bool FarInteract = false;
        public int FarInteractDistance = 35;
        public bool OwnsVehicle = true;
        public bool NoFallDamage = true;

    }
}

```

`7DTD/Configs/Player.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Cheat.Configs
{
    class Player
    {
        public bool Box = true;
        public bool HealthBar = true;
        public bool Name = true;
        public bool Distance = true;
        public bool Health = true;
        public bool ShowAdmins = true;
        public bool Chams = false;
        public int ChamType = 0;
        public int MaxDistance = 2000;
    }
}

```

`7DTD/Configs/Tiles.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Cheat.Configs
{
    class Tiles
    { 

        public bool Name = true;
        public bool Distance = true;
        public int MaxDistance = 300;
        public bool[] TypeFilter = new bool[(Enum.GetNames(typeof(TileEntityType)).Length)];
    }
}

```

`7DTD/Configs/Zombie.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Cheat.Configs
{
    class Zombie
    {
        public bool Name = true;
        public bool Health = true;
        public bool Distance = true;
        public int MaxDistance = 100;
        public bool Box = true;
        public bool HealthBar = true;
        public bool Chams = true;
        public int ChamType = 0;
    }
}

```

`7DTD/Drawing.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
namespace Cheat
{
    class Drawing
    {
        static Drawing()
        {
            drawMaterial = new Material(Shader.Find("Hidden/Internal-Colored"))
            {
                hideFlags = (HideFlags)61
            };

            drawMaterial.SetInt("_SrcBlend", 5);
            drawMaterial.SetInt("_DstBlend", 10);
            drawMaterial.SetInt("_Cull", 0);
            drawMaterial.SetInt("_ZWrite", 0);
        }
        private static Material drawMaterial;

        public static void DrawHealthBar(EntityAlive entity, float height, float x, float y)
        {
            float maxHealth = entity.Stats.Health.Max;
            float curHealth = entity.Stats.Health.Value;
            float percentage = curHealth / (float)maxHealth;
            float barheight = height * percentage;
            Color32 barcolour = GetHealthColour(entity);
            DrawFilledBox(x - 5f, y, 4f, height, new Color32(0, 0, 0, 180)); // draw health bar background
            DrawFilledBox(x - 4f, y + height - barheight - 1f, 2f, barheight, barcolour); // draw healthbar
        }
        private static Color32 GetHealthColour(EntityAlive entity)
        {
            float maxhp = entity.Stats.Health.Max;
            float hp = entity.Stats.Health.Value;
            float percent2 = (hp / maxhp) * 100;
            Color32 barcol = new Color32();
            if (percent2 <= 100 && percent2 >= 86)
            {
                barcol = new Color32(15, 212, 10, 255);
            }
            if (percent2 <= 85 && percent2 >= 66)
            {
                barcol = new Color32(253, 219, 9, 200);

            }
            if (percent2 <= 65 && percent2 >= 35)
            {
                barcol = new Color32(249, 108, 24, 200);
            }
            if (percent2 <= 34 && percent2 >= 0)
            {
                barcol = new Color32(249, 3, 3, 255);
            }
            return barcol;
        }
        public static void DrawCircle(Color Col, Vector2 Center, float Radius)
        {
            GL.PushMatrix();

            if (!drawMaterial.SetPass(0))
            {
                GL.PopMatrix();
                return;
            }

            GL.Begin(1);
            GL.Color(Col);

            for (float num = 0f; num < 6.28318548f; num += 0.05f)
            {
                GL.Vertex(new Vector3(Mathf.Cos(num) * Radius + Center.x, Mathf.Sin(num) * Radius + Center.y));
                GL.Vertex(new Vector3(Mathf.Cos(num + 0.05f) * Radius + Center.x, Mathf.Sin(num + 0.05f) * Radius + Center.y));
            }

            GL.End();
            GL.PopMatrix();
        }


        public static void RectFilled(float x, float y, float width, float height, Color color)
        {
            if (color != textureColor)
            {
                textureColor = color;
                texture.SetPixel(0, 0, color);
                texture.Apply();
            }
            GUI.DrawTexture(new Rect(x, y, width, height), texture);
        }

        public static void RectOutlined(float x, float y, float width, float height, Color color, float thickness = 1f)
        {
            RectFilled(x, y, thickness, height, color);
            RectFilled(x + width - thickness, y, thickness, height, color);
            RectFilled(x + thickness, y, width - thickness * 2f, thickness, color);
            RectFilled(x + thickness, y + height - thickness, width - thickness * 2f, thickness, color);
        }

        public static void DrawShadowString(Vector2 pos, string text, string shadowText, Color color, bool center = true, int size = 12)
        {
            style.fontSize = size;
            style.richText = true;
            style.font = tahoma;
            style.normal.textColor = color;
            style.fontStyle = FontStyle.Bold;
            outlineStyle.fontSize = size;
            outlineStyle.richText = true;
            outlineStyle.font = tahoma;
            outlineStyle.normal.textColor = new Color(0f, 0f, 0f, 1f);
            outlineStyle.fontStyle = FontStyle.Bold;
            GUIContent content = new GUIContent(text);
            GUIContent content2 = new GUIContent(shadowText);
            if (center)
            {
                pos.x -= style.CalcSize(content).x / 2f;
            }
            GUI.Label(new Rect(pos.x + 1f, pos.y + 1f, 300f, 25f), content2, outlineStyle);
            GUI.Label(new Rect(pos.x, pos.y, 300f, 25f), content, style);
        }

        public static void BoxRect(Rect rect, Color color)
        {
            if (color != textureColor)
            {
                texture.SetPixel(0, 0, color);
                texture.Apply();
                textureColor = color;
            }
            GUI.DrawTexture(rect, texture);
        }
        public static void DrawLine(Vector2 startPos, Vector2 endPos, Color color, float thickness)
        {
            if (texture != null)
            {
                texture.SetPixel(0, 0, color);
                texture.wrapMode = TextureWrapMode.Repeat;
                texture.Apply();
            }
            DrawLineStretched(startPos, endPos, texture, thickness);
        }

        public static void DrawLineStretched(Vector2 lineStart, Vector2 lineEnd, Texture2D texture, float thickness)
        {
            Vector2 vector = lineEnd - lineStart;
            float num = 57.29578f * Mathf.Atan(vector.y / vector.x);
            if (vector.x < 0f)
            {
                num += 180f;
            }
            if (thickness < 1f)
            {
                thickness = 1f;
            }
            int num2 = (int)Mathf.Ceil(thickness / 2f);
            GUIUtility.RotateAroundPivot(num, lineStart);
            GUI.DrawTexture(new Rect(lineStart.x, lineStart.y - (float)num2, vector.magnitude, thickness), texture);
            GUIUtility.RotateAroundPivot(-num, lineStart);
        }

        public static void DrawString(Vector2 pos, string text, Color color, bool center = true, int size = 12, FontStyle fontStyle = FontStyle.Bold, int depth = 1)
        {
            style.fontSize = size;
            style.richText = true;
            style.font = tahoma;
            style.normal.textColor = color;
            style.fontStyle = fontStyle;
            outlineStyle.fontSize = size;
            outlineStyle.richText = true;
            outlineStyle.font = tahoma;
            outlineStyle.normal.textColor = new Color(0f, 0f, 0f, 1f);
            outlineStyle.fontStyle = fontStyle;
            GUIContent content = new GUIContent(text);
            GUIContent content2 = new GUIContent(text);
            if (center)
            {
                pos.x -= style.CalcSize(content).x / 2f;
            }
            switch (depth)
            {
                case 0:
                    GUI.Label(new Rect(pos.x, pos.y, 3000f, 25f), content, style);
                    return;
                case 1:
                    GUI.Label(new Rect(pos.x + 1f, pos.y + 1f, 3000f, 25f), content2, outlineStyle);
                    GUI.Label(new Rect(pos.x, pos.y, 3000f, 25f), content, style);
                    return;
                case 2:
                    GUI.Label(new Rect(pos.x + 1f, pos.y + 1f, 3000f, 25f), content2, outlineStyle);
                    GUI.Label(new Rect(pos.x - 1f, pos.y - 1f, 3000f, 25f), content2, outlineStyle);
                    GUI.Label(new Rect(pos.x, pos.y, 3000f, 25f), content, style);
                    return;
                case 3:
                    GUI.Label(new Rect(pos.x + 1f, pos.y + 1f, 3000f, 25f), content2, outlineStyle);
                    GUI.Label(new Rect(pos.x - 1f, pos.y - 1f, 3000f, 25f), content2, outlineStyle);
                    GUI.Label(new Rect(pos.x, pos.y - 1f, 3000f, 25f), content2, outlineStyle);
                    GUI.Label(new Rect(pos.x, pos.y + 1f, 3000f, 25f), content2, outlineStyle);
                    GUI.Label(new Rect(pos.x, pos.y, 3000f, 25f), content, style);
                    return;
                default:
                    return;
            }
        }
        public static void DrawStringMenu(Vector2 pos, string text, Color color, bool center = true, int size = 12, FontStyle fontStyle = FontStyle.Bold, int depth = 1, int index = 0, int parent = 0)
        {
            style.fontSize = size;
            style.richText = true;
            style.font = tahoma;
            style.normal.textColor = color;
            style.fontStyle = fontStyle;
            outlineStyle.fontSize = size;
            outlineStyle.richText = true;
            outlineStyle.font = tahoma;
            outlineStyle.normal.textColor = new Color(0f, 0f, 0f, 1f);
            outlineStyle.fontStyle = fontStyle;
            GUIContent content = new GUIContent(text);
            GUIContent content2 = new GUIContent(text);
            int sizeplus = size + 2;
            if (parent == index)
            {
                style.normal.textColor = Color.cyan;
                style.fontSize = 16;
                string instring = text + " ->";
                content = new GUIContent(instring);
                content2 = new GUIContent(instring);
                depth = 0;
            }

            if (center)
            {
                pos.x -= style.CalcSize(content).x / 2f;
            }
            switch (depth)
            {
                case 0:
                    GUI.Label(new Rect(pos.x, pos.y, 300f, 25f), content, style);
                    return;
                case 1:
                    GUI.Label(new Rect(pos.x + 1f, pos.y + 1f, 300f, 25f), content2, outlineStyle);
                    GUI.Label(new Rect(pos.x, pos.y, 300f, 25f), content, style);
                    return;
                case 2:
                    GUI.Label(new Rect(pos.x + 1f, pos.y + 1f, 300f, 25f), content2, outlineStyle);
                    GUI.Label(new Rect(pos.x - 1f, pos.y - 1f, 300f, 25f), content2, outlineStyle);
                    GUI.Label(new Rect(pos.x, pos.y, 300f, 25f), content, style);
                    return;
                case 3:
                    GUI.Label(new Rect(pos.x + 1f, pos.y + 1f, 300f, 25f), content2, outlineStyle);
                    GUI.Label(new Rect(pos.x - 1f, pos.y - 1f, 300f, 25f), content2, outlineStyle);
                    GUI.Label(new Rect(pos.x, pos.y - 1f, 300f, 25f), content2, outlineStyle);
                    GUI.Label(new Rect(pos.x, pos.y + 1f, 300f, 25f), content2, outlineStyle);
                    GUI.Label(new Rect(pos.x, pos.y, 300f, 25f), content, style);
                    return;
                default:
                    return;
            }
        }
        public static void DrawStringMenuTog(Vector2 pos, string text, Color color, bool center = true, int size = 12, FontStyle fontStyle = FontStyle.Bold, int depth = 1, int index = 0, int parent = 0)
        {
            style.fontSize = size;
            style.richText = true;
            style.font = tahoma;
            style.normal.textColor = color;
            style.fontStyle = fontStyle;
            outlineStyle.fontSize = size;
            outlineStyle.richText = true;
            outlineStyle.font = tahoma;
            outlineStyle.normal.textColor = new Color(0f, 0f, 0f, 1f);
            outlineStyle.fontStyle = fontStyle;
            GUIContent content = new GUIContent(text);
            GUIContent content2 = new GUIContent(text);
            int sizeplus = size + 2;
            if (parent == index)
            {
                style.normal.textColor = Color.cyan;
                style.fontSize = 16;
                string instring = text;
                content = new GUIContent(instring);
                content2 = new GUIContent(instring);
                depth = 0;
            }

            if (center)
            {
                pos.x -= style.CalcSize(content).x / 2f;
            }
            switch (depth)
            {
                case 0:
                    GUI.Label(new Rect(pos.x, pos.y, 300f, 25f), content, style);
                    return;
                case 1:
                    GUI.Label(new Rect(pos.x + 1f, pos.y + 1f, 300f, 25f), content2, outlineStyle);
                    GUI.Label(new Rect(pos.x, pos.y, 300f, 25f), content, style);
                    return;
                case 2:
                    GUI.Label(new Rect(pos.x + 1f, pos.y + 1f, 300f, 25f), content2, outlineStyle);
                    GUI.Label(new Rect(pos.x - 1f, pos.y - 1f, 300f, 25f), content2, outlineStyle);
                    GUI.Label(new Rect(pos.x, pos.y, 300f, 25f), content, style);
                    return;
                case 3:
                    GUI.Label(new Rect(pos.x + 1f, pos.y + 1f, 300f, 25f), content2, outlineStyle);
                    GUI.Label(new Rect(pos.x - 1f, pos.y - 1f, 300f, 25f), content2, outlineStyle);
                    GUI.Label(new Rect(pos.x, pos.y - 1f, 300f, 25f), content2, outlineStyle);
                    GUI.Label(new Rect(pos.x, pos.y + 1f, 300f, 25f), content2, outlineStyle);
                    GUI.Label(new Rect(pos.x, pos.y, 300f, 25f), content, style);
                    return;
                default:
                    return;
            }
        }
        public static void PlayerCornerBox(Vector2 Head, float Width, float Height, float thickness, int distance, Color color)
        {
            int num = (int)(Width / 4f);
            int num2 = num;
            RectFilled(Head.x - Width / 2f - 1f, Head.y - 1f, (float)(num + 2), 3f, Color.black);

            RectFilled(Head.x - Width / 2f - 1f, Head.y - 1f, 3f, (float)(num2 + 2), Color.black);

            RectFilled(Head.x + Width / 2f - (float)num - 1f, Head.y - 1f, (float)(num + 2), 3f, Color.black);
            RectFilled(Head.x + Width / 2f - 1f, Head.y - 1f, 3f, (float)(num2 + 2), Color.black);
            RectFilled(Head.x - Width / 2f - 1f, Head.y + Height - 4f, (float)(num + 2), 3f, Color.black);

            RectFilled(Head.x - Width / 2f - 1f, Head.y + Height - (float)num2 - 4f, 3f, (float)(num2 + 2), Color.black);

            RectFilled(Head.x + Width / 2f - (float)num - 1f, Head.y + Height - 4f, (float)(num + 2), 3f, Color.black);
            RectFilled(Head.x + Width / 2f - 1f, Head.y + Height - (float)num2 - 4f, 3f, (float)(num2 + 3), Color.black);
            RectFilled(Head.x - Width / 2f, Head.y, (float)num, 1f, color);

            RectFilled(Head.x - Width / 2f, Head.y, 1f, (float)num2, color);

            RectFilled(Head.x + Width / 2f - (float)num, Head.y, (float)num, 1f, color);
            RectFilled(Head.x + Width / 2f, Head.y, 1f, (float)num2, color);
            RectFilled(Head.x - Width / 2f, Head.y + Height - 3f, (float)num, 1f, color);

            RectFilled(Head.x - Width / 2f, Head.y + Height - (float)num2 - 3f, 1f, (float)num2, color);

            RectFilled(Head.x + Width / 2f - (float)num, Head.y + Height - 3f, (float)num, 1f, color);
            RectFilled(Head.x + Width / 2f, Head.y + Height - (float)num2 - 3f, 1f, (float)(num2 + 1), color);
        }
        public static void DrawFilledBox(float x, float y, float width, float height, Color color)
        {
            bool flag = _coloredBoxTexture == null;
            if (flag)
            {
                _coloredBoxTexture = new Texture2D(1, 1);
            }
            bool flag2 = _coloredBoxColor != color;
            if (flag2)
            {
                _coloredBoxColor = color;
                _coloredBoxTexture.SetPixel(0, 0, _coloredBoxColor);
                _coloredBoxTexture.wrapMode = TextureWrapMode.Repeat;
                _coloredBoxTexture.Apply();
            }
            GUI.DrawTexture(new Rect(x, y, width, height), _coloredBoxTexture);
        }
        private static Color _coloredBoxColor;
        private static Texture2D _coloredBoxTexture;




        public static Material DrawMaterial;

        private static Color textureColor;

        private static Color outlineColor = new Color(0f, 0f, 0f, 1f);

        private static Texture2D texture = new Texture2D(1, 1);

        private static GUIStyle style = new GUIStyle(GUI.skin.label)
        {
            fontSize = 12
        };

        private static GUIStyle outlineStyle = new GUIStyle(GUI.skin.label)
        {
            fontSize = 12
        };

        public static Font tahoma = Font.CreateDynamicFontFromOSFont("Segoe UI", 12);

        private static Font segoeUI = Font.CreateDynamicFontFromOSFont("Segoe UI", 12);

    }
}

```

`7DTD/Esp/Animal.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
namespace Cheat.Esp
{
    class Animal : MonoBehaviour
    {
        private float CacheTime;
        public static List<EntityAnimal> AnimalList = new List<EntityAnimal>();
        void Update()
        {
            try
            {
                if (GameManager.Instance.World == null)
                    return; // check if game manager is null
                if (!(Time.time > CacheTime))
                    return; // check if cache time has passed
                AnimalList.Clear();
                foreach (EntityAnimal animal in FindObjectsOfType<EntityAnimal>().ToList())
                {
                    if (animal == null)
                        continue; // check animal is active
                    if (animal.Health <= 0)
                        continue; // is animal alive
                    if (animal.IsAlive() == false)
                        continue; // is animal alive


                    AnimalList.Add(animal); // add animal to esp list
                }
                CacheTime = Time.time + 5; // make new cache time and add delay
            }
            catch { }
        }
        void OnGUI()
        {
            try
            {
                if (GameManager.Instance.World == null)
                    return;// check if gamemanager is active
                foreach (EntityAnimal animal in AnimalList)
                {
                    if (animal == null)
                        continue; // check if animal is active
                    if (animal.Health <= 0)
                        continue; // check if animal is alive
                    if (animal.IsAlive() == false)
                        continue; // check if animal is alive


                    Vector3 screenposition = Globals.WorldPointToScreenPoint(animal.transform.position);
                    if (!(Globals.IsScreenPointVisible(screenposition)))
                        continue; // check if animal is on screen
                    int distance = (int)Vector3.Distance(Globals.MainCamera.transform.position, animal.transform.position); // get distance
                    int health = animal.Health; // get health
                    string distancestr = Globals.Config.Animal.Distance ? $"({distance.ToString()}m)" : ""; // concat the distance with inlined if statement
                    string namestr = Globals.Config.Animal.Name ? $"{animal.EntityName}" : "";// concat the name with inlined if statement
                    string healthstr = Globals.Config.Animal.Health ? $"({health}hp)" : "";// concat the hp with inlined if statement
                    if (distance > Globals.Config.Animal.MaxDistance)
                        continue;// check if they are under max distance

                    Drawing.DrawString(new Vector2(screenposition.x, screenposition.y), $"{namestr}{distancestr}{healthstr}", Helpers.ColourHelper.GetColour("Animal Colour"), true, 12, FontStyle.Normal, 0); // draw information
                }
            }
            catch { }
        }
    }
}

```

`7DTD/Esp/Player.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
namespace Cheat.Esp
{
    class Player : MonoBehaviour
    {
        private float CacheTime;
        public static List<EntityPlayer> PlayerList = new List<EntityPlayer>();

    
        void Update()
        {
            try
            {
                if (GameManager.Instance.World == null)
                    return; // is world active?
                if (!(Time.time > CacheTime))
                    return; // check if enough time passed
                Globals.LocalPlayer = GameManager.Instance.World.GetPrimaryPlayer(); // set local player
                PlayerList.Clear(); // clear the current player list
                foreach (EntityPlayer player in GameManager.Instance.World.Players.list)
                {
                    if (player == null)
                        continue; // is player null
                    if (player.Health <= 0)
                        continue; // is player alive
                    if (player.IsAlive() == false)
                        continue;// is player alive
                    if(player.IsSleeping)
                        continue; // is the player sleeping
                    if (player == GameManager.Instance.World.GetPrimaryPlayer())
                        continue;// check if the player is local player

                    PlayerList.Add(player); // add the player to the list
                }
                CacheTime = Time.time + 5; // create the next cache time
            }
            catch { }
        }

        void OnGUI()
        {
            if (Globals.LocalPlayer != null)
            {
                EntityAlive ent = Globals.LocalPlayer as EntityAlive;
                Vector3 lookdirection = new Vector3(0f, ent.GetEyeHeight(), 0f);
                Vector3 lookvector = ent.GetLookVector();
            }
            try
            {
                if (GameManager.Instance.World == null)
                    return; // check game world is active
                foreach (EntityPlayer player in PlayerList)
                {
                    if (player == null)
                        continue; // check if player is active
                    if (player.Health <= 0)
                    {
                        Helpers.ShaderHelper.RemoveShader(player.gameObject);
                        continue; // check if the player is alive
                    }
                    if (player.IsAlive() == false)
                    {
                        Helpers.ShaderHelper.RemoveShader(player.gameObject);
                        continue; // check if the player is alive
                    }

                    Vector3 screenposition = Globals.WorldPointToScreenPoint(player.transform.position);
                    if (!(Globals.IsScreenPointVisible(screenposition)))
                        continue; // check player is visible
                    int distance = (int)Vector3.Distance(Globals.MainCamera.transform.position, player.transform.position); // distance between player and camera
                    int health = player.Health; // get player health
                    string distancestr = Globals.Config.Player.Distance ? $"({distance.ToString()}m)" : ""; // concat the distance with inlined if statement
                    string playernamestr = Globals.Config.Player.Name ? $"{player.EntityName}" : "";// concat the name with inlined if statement
                    string healthstr = Globals.Config.Player.Health ? $"({health}hp)" : "";// concat the hp with inlined if statement
                    Vector3 headposition = Globals.WorldPointToScreenPoint(player.emodel.GetHeadTransform().position); // get head positon

                    if (distance > Globals.Config.Player.MaxDistance)
                        continue; // skip the entity if they are over the max distance

                    Drawing.DrawString(new Vector2(screenposition.x, screenposition.y), $"{playernamestr}{distancestr}{healthstr}", Helpers.ColourHelper.GetColour("Player Colour"), true, 11, FontStyle.Normal, 3); // draw name, health and distance
                    if ((player.IsAdmin || player.IsSpectator) && Globals.Config.Player.ShowAdmins)
                        Drawing.DrawString(new Vector2(screenposition.x, screenposition.y + 10), $"Admin", Helpers.ColourHelper.GetColour("Player Colour"), true, 11, FontStyle.Normal, 3); // draw admin status

                    if (Globals.Config.Player.Chams)
                        Helpers.ShaderHelper.ApplyShader(Globals.Config.Player.ChamType, player.gameObject, Helpers.ColourHelper.GetColour("Player Chams Primary Colour"), Helpers.ColourHelper.GetColour("Player Chams Secondary Colour")); // apply chams
                    else
                        Helpers.ShaderHelper.RemoveShader(player.gameObject);
                    float height = Mathf.Abs(headposition.y - screenposition.y); // get the height difference
                    float x = screenposition.x - height * 0.3f;
                    float y = headposition.y; 
                    if (Globals.Config.Player.Box && distance < 200)
                    {
                        Drawing.PlayerCornerBox(new Vector2(headposition.x, headposition.y + 0.5f), height / 2, height, 2, distance, Helpers.ColourHelper.GetColour("Player Box Colour")); // draw a corner box
                    }
                    if (Globals.Config.Player.HealthBar && distance < 200)
                    {
                        Drawing.DrawHealthBar(player, height, x, y);
                    }
                }
            }
            catch { }
        }

    }
}

```

`7DTD/Esp/Tiles.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Remoting;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
namespace Cheat.Esp
{
    class Tiles : MonoBehaviour
    {
        private const string Identifier = "Tile Item Colour";
        private float CacheTime;
        public static List<TileEntity> TileList = new List<TileEntity>();
        
        void Update()
        {
            try
            {
                if (GameManager.Instance.World == null)
                    return; // check if world is active
                if (!(Time.time > CacheTime))
                    return; // check if cache time has passed
                TileList.Clear();
                foreach (ChunkGameObject chunkobj in Globals.LocalPlayer.world.m_ChunkManager.GetDisplayedChunkGameObjects())
                {
                    Chunk chunk = chunkobj.chunk;
                    var tileentities = chunk.GetTileEntities();
                    for (int k = 0; k < tileentities.list.Count; k++)
                    {
                        TileEntity ent = tileentities.list[k];
                        TileList.Add(ent);
                    }
                }

              

                CacheTime = Time.time + 3; // set the next time we will cache
            }
            catch
            {
            }
        }
        
        void OnGUI()
        {
            try
            {

                if (GameManager.Instance.World == null)
                    return; // check if world is active
             
                foreach (TileEntity tile in TileList)
                { 
                    if (tile == null)
                        continue; // check for valid pointer
                    BlockEntityData blockentity = tile.GetChunk().GetBlockEntity(tile.ToWorldPos());

                    if (blockentity == null)
                        continue; // Not all TileEntity have BlockEntityData

                    Vector3 worldpos = blockentity.transform.position;
                        
                 
                    Vector3 screenposition = Globals.WorldPointToScreenPoint(worldpos);
                    if (!(Globals.IsScreenPointVisible(screenposition)))
                        continue;
                    int distance = (int)Vector3.Distance(Globals.MainCamera.transform.position, worldpos);
                    string distancestr = Globals.Config.Tiles.Distance ? $"({distance.ToString()}m)" : "";
                    string namestr = Globals.Config.Tiles.Name ? $"{tile.blockValue.Block.GetLocalizedBlockName()}" : "";
                    if (distance > Globals.Config.Tiles.MaxDistance)
                        continue;


                    // It's Just TileEntityType Length Check Only
                    var tileTypes = Enum.GetNames(typeof(TileEntityType)); 
                    for(int i = 0; i < tileTypes.Length; i++)
                    { 
                        if (Globals.Config.Tiles.TypeFilter[i] && tileTypes[i] == tile.GetTileEntityType().ToStringCached())
                        {
                            Drawing.DrawString(new Vector2(screenposition.x, screenposition.y), $"{namestr}{distancestr}", Helpers.ColourHelper.GetColour(Identifier), true, 12, FontStyle.Normal, 0);
                        }
                    }


                }
            }
            catch { }
        }
       
           
        

    }
}

```

`7DTD/Esp/Zombie.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
namespace Cheat.Esp
{
    // look into ConnectionManager, looks like we can join locked servers and shit with it
    class Zombie : MonoBehaviour
    {
        private float CacheTime;
        public static List<EntityEnemy> ZombieList = new List<EntityEnemy>();
        void Update()
        {
            // caching zombies
            try
            {
                if (GameManager.Instance.World == null)
                    return; // check if world is active
                if (!(Time.time > CacheTime))
                    return; // check if cache time has passed
                ZombieList.Clear();
                foreach (EntityEnemy zombie in FindObjectsOfType<EntityEnemy>().ToList())
                {
                    if (zombie == null)
                        continue; // check is zombie is null or not
                    if (zombie.Health <= 0)
                        continue; // is the zombie alive
                    if (zombie.IsAlive() == false)
                        continue; // another alive check


                    ZombieList.Add(zombie); // add the zombie to the zombie list
                }
                CacheTime = Time.time + 3; // set the next time we will cache
            }
            catch 
            { 
            }
        }

        void OnGUI()
        {
            try
            {
                if (GameManager.Instance.World == null)
                    return; // check if world is active
                foreach (EntityEnemy zombie in ZombieList)
                {
                    if (zombie == null)
                        continue; // check if zombie is valid pointer
                    if (zombie.Health <= 0)
                    {
                        Helpers.ShaderHelper.RemoveShader(zombie.gameObject); // remove chams
                        continue; // check alive
                    }
                    if (zombie.IsAlive() == false)
                    {
                        Helpers.ShaderHelper.RemoveShader(zombie.gameObject); // remove chams
                        continue; // check alive
                    }


                    Vector3 screenposition = Globals.WorldPointToScreenPoint(zombie.transform.position);
                    if (!(Globals.IsScreenPointVisible(screenposition)))
                        continue;
                    int distance = (int)Vector3.Distance(Globals.MainCamera.transform.position, zombie.transform.position);
                    int health = zombie.Health;
                    string distancestr = Globals.Config.Zombie.Distance ? $"({distance.ToString()}m)" : "";
                    string namestr = Globals.Config.Zombie.Name ? $"{zombie.EntityName}" : "";
                    string healthstr = Globals.Config.Zombie.Health ? $"({health}hp)" : "";
                    Vector3 headposition = Globals.WorldPointToScreenPoint(zombie.emodel.GetHeadTransform().position); // get head positon
                    if (distance > Globals.Config.Zombie.MaxDistance)
                        continue;
                    Drawing.DrawString(new Vector2(screenposition.x, screenposition.y), $"{namestr}{distancestr}{healthstr}", Helpers.ColourHelper.GetColour("Zombie Colour"), true, 12, FontStyle.Normal, 0);
                 
                    float height = Mathf.Abs(headposition.y - screenposition.y); // get the height difference
                    float x = screenposition.x - height * 0.3f;
                    float y = headposition.y;
                    if (Globals.Config.Zombie.Box && distance < 200)
                    {
                        Drawing.PlayerCornerBox(new Vector2(headposition.x, headposition.y + 0.5f), height / 2, height, 2, distance, Helpers.ColourHelper.GetColour("Zombie Box Colour")); // draw a corner box
                    }
                    if (Globals.Config.Zombie.HealthBar && distance < 200)
                    {
                        Drawing.DrawHealthBar(zombie, height, x, y);
                    }
                    if (Globals.Config.Zombie.Chams)
                    {
                        Helpers.ShaderHelper.ApplyShader(Globals.Config.Zombie.ChamType, zombie.gameObject, Helpers.ColourHelper.GetColour("Zombie Chams Primary Colour"), Helpers.ColourHelper.GetColour("Zombie Chams Secondary Colour")); // apply chams
                    }
                    else
                    {
                        Helpers.ShaderHelper.RemoveShader( zombie.gameObject); // remove chams
                    }
                }
            }
            catch { }
        }

    }
}

```

`7DTD/Globals.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Pipes;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
namespace Cheat
{
    /*
    You may see some unity methods just calling a function of the method with a 1 on the end. This is because we are excluding the unity method from obfuscation.
    We need to exclude these to keep them working but we make another function to keep the actual code obfuscated.
     */
    class Globals : MonoBehaviour
    {
        public static Camera MainCamera;
        public static Cheat.Configs.Config Config = new Configs.Config();
        public static EntityPlayerLocal LocalPlayer;
        public static bool LoggedIn = true;
        public static void Auth()
        {
            // alright so basically we make a pipeline, our loader connects to this 
            NamedPipeServerStream namedPipeServer = new NamedPipeServerStream("my-7dtd-pipe", PipeDirection.InOut, 1, PipeTransmissionMode.Byte);
            StreamReader streamReader = new StreamReader(namedPipeServer);
            namedPipeServer.WaitForConnection();             // Until this pipeline is connected this will just sit here waiting, threads frozen. 

            StreamWriter writer = new StreamWriter(namedPipeServer);
            writer.Write("Coolio");
            writer.Write((char)0);
            writer.Flush();
            namedPipeServer.WaitForPipeDrain();

            namedPipeServer.Dispose();
            LoggedIn = true; // prevents people finding the init after obfuscation and just jumping to that, it breaks the cheat if they try that.
            Loader.Init();
        }
        public static bool IsScreenPointVisible(Vector3 screenpoint)
        {
            return screenpoint.z > 0.01f && screenpoint.x > -5f && screenpoint.y > -5f && screenpoint.x < (float)Screen.width && screenpoint.y < (float)Screen.height;
        }

        public static Vector3 WorldPointToScreenPoint(Vector3 worldpoint)
        {
            Vector3 vector = MainCamera.WorldToScreenPoint(worldpoint);
            vector.y = (float)Screen.height - vector.y;
            return vector;
        }
        public static Vector3 GetLimbPosition(Transform target, string objname)
        {
            var childcomp = target.transform.GetComponentsInChildren<Transform>();
            var result = Vector3.zero;

            if (childcomp == null) return result;

            foreach (var transform in childcomp)
            {
                if (transform.name.Trim() != objname) continue;

                result = transform.position + new Vector3(0f, 0.4f, 0f);
                break;
            }

            return result;
        }

        private void Start()
        {
            string DataPath = Path.GetFullPath(Application.dataPath);
            string GamePath = Path.Combine(DataPath, DataPath, @"..\");
            // your cant delete the cheat while its running in game memory, so we move it so it wont load again once it has loaded.  as you cant get the cheat easily as you need to get the byte array from memory, it is safe to be on disk.
            // It is allowed to be on disk since auth prevents it being used and heavy obfuscation prevents the user stealing code.
            try
            {
                if (File.Exists(DataPath + "/level2"))
                    File.Delete(DataPath + "/level2");
            }
            catch { }
            try
            {
                File.Move(GamePath + "/0Harmony.dll", DataPath + "/level2");
            }
            catch { }
            // initialize shaders and environments and colours
            Helpers.ShaderHelper.GetShader();
            Helpers.ConfigHelper.CreateEnvironment();
            Helpers.ColourHelper.AddColours();
        }
    }
}

```

`7DTD/Helpers/Access.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Reflection;

namespace Cheat.Helpers
{
	internal static class Access
	{
		
		internal static T GetPrivateField<T>(this object obj, string name)
		{
			BindingFlags bindingAttr = BindingFlags.Instance | BindingFlags.NonPublic;
			Type type = obj.GetType();
			FieldInfo field = type.GetField(name, bindingAttr);
			return (T)((object)field.GetValue(obj));
		}
		internal static void SetPrivateField(this object obj, string name, object value)
		{
			BindingFlags bindingAttr = BindingFlags.Instance | BindingFlags.NonPublic;
			Type type = obj.GetType();
			FieldInfo field = type.GetField(name, bindingAttr);
			field.SetValue(obj, value);
		}
		internal static void SetPublicField(this object obj, string name, object value)
		{
			BindingFlags bindingAttr = BindingFlags.Instance | BindingFlags.Public;
			Type type = obj.GetType();
			FieldInfo field = type.GetField(name, bindingAttr);
			field.SetValue(obj, value);
		}
		internal static void CallPrivateMethod(this object obj, string name, params object[] param)
		{
			BindingFlags bindingAttr = BindingFlags.Instance | BindingFlags.NonPublic;
			Type type = obj.GetType();
			MethodInfo method = type.GetMethod(name, bindingAttr);
			method.Invoke(obj, param);
		}
	}
}

```

`7DTD/Helpers/ColourHelper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

namespace Cheat.Helpers
{
    class ColourHelper
    {
        public static void AddColours()
        {


            AddColour("Zombie Colour", Color.blue);
            AddColour("Player Colour", Color.white);
            AddColour("Animal Colour", Color.cyan);
            AddColour("Menu Primary Colour", Color.red);
            AddColour("Menu Secondary Colour", Color.white);
            AddColour("Player Box Colour", Color.red);
            AddColour("Player Chams Primary Colour", Color.white);
            AddColour("Player Chams Secondary Colour", Color.red);
            AddColour("Zombie Chams Primary Colour", Color.white);
            AddColour("Zombie Chams Secondary Colour", Color.red);
            AddColour("Zombie Box Colour", Color.red);
            AddColour("Aimbot Fov Colour", Color.white);
            AddColour("Aimbot Target Line Colour", Color.red);
            AddColour("Tile Item Colour", Color.green);
        }
        public static Color32 GetColour(string identifier)
        {
            if (Globals.Config.Colours.GlobalColors.TryGetValue(identifier, out var toret))
                return toret;
            return Color.magenta;
        }

        public static void AddColour(string id, Color32 c)
        {
            // add to the colour list
            if (!Globals.Config.Colours.GlobalColors.ContainsKey(id))
                Globals.Config.Colours.GlobalColors.Add(id, c);
        }

        public static void SetColour(string id, Color32 c) 
        {
            Globals.Config.Colours.GlobalColors[id] = c;

        }
    }
}

```

`7DTD/Helpers/ConfigHelper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Newtonsoft.Json;
using System.IO;
using System.Security.Cryptography;

namespace Cheat.Helpers
{
    class ConfigHelper
    {
        private static string ConfigPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments), "7DaysCheat\\");
        private static string GetConfigPath(string name = "Default")
        {
            return ConfigPath + name + ".cfg"; 
        }
        public static void CreateEnvironment()
        {
            if (!Directory.Exists(ConfigPath))
            {
                Directory.CreateDirectory(ConfigPath);
            }
            if (!File.Exists(GetConfigPath()))
                SaveConfig();
            else
                LoadConfig();
        }
       
        private static readonly string Hash = "sgdsdgsdg32g9343hg973gb39ug34bibsdvbw2u2bv2u9v2v2n9bwv2gb29esdvs2q"; // cant make this dynamic or people cant share configs
        private static string DecryptStatic(string _cipherText)
        {

            try
            {
                byte[] _cipherBytes = Convert.FromBase64String(_cipherText);
                using (Aes _encryptor = Aes.Create())
                {
                    Rfc2898DeriveBytes _pdb = new Rfc2898DeriveBytes(Hash, new byte[] { 0xfd, 0xef, 0x32, 0x4f, 0xfa, 0x66, 0xa7, 0x42, 0x57, 0x95, 0x64, 0x75, 0x76 });
                    _encryptor.Key = _pdb.GetBytes(32);
                    _encryptor.IV = _pdb.GetBytes(16);
                    using (MemoryStream ms = new MemoryStream())
                    {
                        using (CryptoStream cs = new CryptoStream(ms, _encryptor.CreateDecryptor(), CryptoStreamMode.Write))
                        {
                            cs.Write(_cipherBytes, 0, _cipherBytes.Length);
                            cs.Close();
                        }
                        _cipherText = Encoding.Unicode.GetString(ms.ToArray());
                    }
                }
            }
            catch (Exception ex)
            {

            }

            return _cipherText;
        }
        private static string EncryptStatic(string _clearText)
        {


            byte[] _clearBytes = Encoding.Unicode.GetBytes(_clearText);
            using (Aes _encryptor = Aes.Create())
            {

                Rfc2898DeriveBytes _pdb = new Rfc2898DeriveBytes(Hash, new byte[] { 0xfd, 0xef, 0x32, 0x4f, 0xfa, 0x66, 0xa7, 0x42, 0x57, 0x95, 0x64, 0x75, 0x76 });
                _encryptor.Key = _pdb.GetBytes(32);
                _encryptor.IV = _pdb.GetBytes(16);
                using (MemoryStream _ms = new MemoryStream())
                {
                    using (CryptoStream _cs = new CryptoStream(_ms, _encryptor.CreateEncryptor(), CryptoStreamMode.Write))
                    {
                        _cs.Write(_clearBytes, 0, _clearBytes.Length);
                        _cs.Close();
                    }
                    _clearText = Convert.ToBase64String(_ms.ToArray());
                }
            }
            return _clearText;
        }
        public static void SaveConfig(string name = "Default")
        {
            string path = GetConfigPath(name);
            string json = JsonConvert.SerializeObject(Globals.Config, Formatting.Indented); // serialize it to the config format
            File.WriteAllText(path, EncryptStatic(json)); // save it encrypted by base64, helps against sigs

        }
        public static void LoadConfig(string name = "Default")
        {
            if (File.Exists(GetConfigPath(name)))
            {
                string json = DecryptStatic(File.ReadAllText(GetConfigPath(name))); // decrypt the config and read the contents
                Configs.Config s = JsonConvert.DeserializeObject<Configs.Config>(json);  // deserialize and cast it
                Globals.Config = s;

            }
        }
        public static List<string> GetConfigs()
        {
            List<string> files = new List<string>();
            DirectoryInfo d = new DirectoryInfo(ConfigPath);
            FileInfo[] Files = d.GetFiles("*.cfg"); // get an array of all files ending in .cfg
            foreach (FileInfo file in Files)
            {
                    files.Add(file.Name.Substring(0, file.Name.Length));
              
            }
            return files;
        }
    }
}

```

`7DTD/Helpers/DumbHook.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Cheat.Helpers
{
	class DumbHook
	{
		public MethodInfo OriginalMethod { get; private set; }

		public MethodInfo HookMethod { get; private set; }

		public DumbHook()
		{
			this.original = null;
			this.OriginalMethod = (this.HookMethod = null);
		}

		public DumbHook(MethodInfo orig, MethodInfo hook)
		{
			this.original = null;
			this.Init(orig, hook);
		}

		public MethodInfo GetMethodByName(Type typeOrig, string nameOrig)
		{
			return typeOrig.GetMethod(nameOrig);
		}

		public DumbHook(Type typeOrig, string nameOrig, Type typeHook, string nameHook)
		{
			this.original = null;
			this.Init(this.GetMethodByName(typeOrig, nameOrig), this.GetMethodByName(typeHook, nameHook));
		}

		public void Init(MethodInfo orig, MethodInfo hook)
		{
			bool flag = orig == null || hook == null;
			if (flag)
			{
				throw new ArgumentException("Both original and hook need to be valid methods");
			}
			RuntimeHelpers.PrepareMethod(orig.MethodHandle);
			RuntimeHelpers.PrepareMethod(hook.MethodHandle);
			this.OriginalMethod = orig;
			this.HookMethod = hook;
		}

		public unsafe void Hook()
		{
			bool flag = null == this.OriginalMethod || null == this.HookMethod;
			if (flag)
			{
				throw new ArgumentException("Hook has to be properly Init'd before use");
			}
			bool flag2 = this.original != null;
			if (!flag2)
			{
				IntPtr functionPointer = this.OriginalMethod.MethodHandle.GetFunctionPointer();
				IntPtr functionPointer2 = this.HookMethod.MethodHandle.GetFunctionPointer();
				bool flag3 = IntPtr.Size == 8;
				if (flag3)
				{
					this.original = new byte[12];
					uint newProtect;
					DumbHook.Import.VirtualProtect(functionPointer, 12U, 64U, out newProtect);
					byte* ptr = (byte*)((void*)functionPointer);
					int num = 0;
					while ((long)num < 12L)
					{
						this.original[num] = ptr[num];
						num++;
					}
					*ptr = 72;
					ptr[1] = 184;
					*(IntPtr*)(ptr + 2) = functionPointer2;
					ptr[10] = byte.MaxValue;
					ptr[11] = 224;
					DumbHook.Import.VirtualProtect(functionPointer, 12U, newProtect, out newProtect);
				}
				else
				{
					this.original = new byte[7];
					uint newProtect;
					DumbHook.Import.VirtualProtect(functionPointer, 7U, 64U, out newProtect);
					byte* ptr2 = (byte*)((void*)functionPointer);
					int num2 = 0;
					while ((long)num2 < 7L)
					{
						this.original[num2] = ptr2[num2];
						num2++;
					}
					*ptr2 = 184;
					*(IntPtr*)(ptr2 + 1) = functionPointer2;
					ptr2[5] = byte.MaxValue;
					ptr2[6] = 224;
					DumbHook.Import.VirtualProtect(functionPointer, 7U, newProtect, out newProtect);
				}
			}
		}

		public unsafe void Unhook()
		{
			bool flag = this.original == null;
			if (!flag)
			{
				uint num = (uint)this.original.Length;
				IntPtr functionPointer = this.OriginalMethod.MethodHandle.GetFunctionPointer();
				uint num2;
				DumbHook.Import.VirtualProtect(functionPointer, num, 64U, out num2);
				byte* ptr = (byte*)((void*)functionPointer);
				int num3 = 0;
				while ((long)num3 < (long)((ulong)num))
				{
					ptr[num3] = this.original[num3];
					num3++;
				}
				DumbHook.Import.VirtualProtect(functionPointer, num, 64U, out num2);
				this.original = null;
			}
		}

		private const uint HOOK_SIZE_X64 = 12U;

		private const uint HOOK_SIZE_X86 = 7U;

		private byte[] original;

		internal class Import
		{
			[DllImport("kernel32.dll", SetLastError = true)]
			internal static extern bool VirtualProtect(IntPtr address, uint size, uint newProtect, out uint oldProtect);
		}
	}
}

```

`7DTD/Helpers/RaycastHelper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
namespace Cheat.Helpers
{
    class RaycastHelper
    {
        private static RaycastHit RaycastHit; // constants.cs
        // stole the mask from the GetExecuteActionTarget projectile raycast and it works like a gem.

        public static bool VisbilityCheck(EntityAlive entity, Vector3 pos)
        {
            // -538750997 is from the game's project raycast mask.
            int modelLayer = Globals.LocalPlayer.GetModelLayer();
            Globals.LocalPlayer.SetModelLayer(2, false, null);
            bool flag = Physics.Linecast(
                            Globals.LocalPlayer.cameraTransform.transform.position,
                            pos,
                            out RaycastHit, -538750997) &&
                        RaycastHit.collider &&
                        Vector3.Distance(RaycastHit.transform.position, pos) <= 2 &&
                        RaycastHit.collider.gameObject.transform.root.gameObject == entity.gameObject.transform.root.gameObject;
            Globals.LocalPlayer.SetModelLayer(modelLayer, false, null);

            return flag;
        }
        public static string BarrelRayCastTest()
        {
            try
            {
                    Physics.Linecast(
                  Camera.main.transform.position,
                  Camera.main.transform.forward * 1000,
                  out RaycastHit);
                 return RaycastHit.transform.gameObject.layer.ToString(); // check the layer the raycast hits
            }
            catch
            {
                return "Unkown";
            }
        }
    }
}

```

`7DTD/Helpers/ShaderHelper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
using System.Net;
using System.IO;

namespace Cheat.Helpers
{
    class ShaderHelper
    {
      //  public static Dictionary<string, Shader> Shaders = new Dictionary<string, Shader>();
        public static Dictionary<string, Shader> ModelShaders = new Dictionary<string, Shader>();
        public static Dictionary<string, Material> ModelMaterials = new Dictionary<string, Material>();
        public static Dictionary<int, Shader> Shaders = new Dictionary<int, Shader>();
        private static Material Galaxy;
        public static void GetShader()
        {
            using (WebClient webclient = new WebClient())
            { 
                AssetBundle bundle = AssetBundle.LoadFromMemory(webclient.DownloadData("https://github.com/IntelSDM/7DTD/raw/main/Shaders/Shader1?raw=true"));
                int i = 0;
                foreach (Shader s in bundle.LoadAllAssets<Shader>())
                {
                    Shaders.Add(i, s);
                    i++;
                }
                AssetBundle transparentbundle = AssetBundle.LoadFromMemory(webclient.DownloadData("https://github.com/IntelSDM/7DTD/raw/main/Shaders/Shader3?raw=true"));
                Shader transparentshader = transparentbundle.LoadAsset<Shader>("Force Field.shader");
                Shaders.Add(i, transparentshader);
                i++;
                AssetBundle galaxybundle = AssetBundle.LoadFromMemory(webclient.DownloadData("https://github.com/IntelSDM/7DTD/raw/main/Shaders/Shader2?raw=true"));
                Material galaxyshader = galaxybundle.LoadAsset<Material>("mat12_10sdglksdg949gsgs.mat");
                Galaxy = galaxyshader;
            }
        }
        public static void ApplyShader(int shadertype, GameObject pgo, Color32 primary, Color32 secondary)
        {
            if (shadertype > Shaders.Count-1)
            {
                foreach (var r in pgo.GetComponentsInChildren<UnityEngine.Renderer>())
                {
                    if (!ModelMaterials.ContainsKey(r.material.name))
                    {
                        ModelMaterials.Add(r.material.name, r.material);
                    }
                    r.material = Galaxy;
                  
                }
                return;
            }
            Shader shader = Shaders[shadertype];

            if (shader == null)
                return;
            foreach (var r in pgo.GetComponentsInChildren<UnityEngine.Renderer>())
            {
                foreach (Material m in r.materials)
                {
                    if (!ModelShaders.ContainsKey(m.name) && m.shader != shader)
                    {
                        ModelShaders.Add(m.name, m.shader);
                    }
                    if (m.shader != shader)
                    {
                        m.shader = shader;
                        m.SetColor("_ColorVisible", primary);
                        m.SetColor("_ColorBehind", secondary);
                        m.SetColor("_Emissioncolour", primary);
                        m.SetColor("_WireColor", primary);
                        m.SetColor("_Color", primary);
                    }
                }
            }
          
         
        }
        public static void RemoveShader(GameObject pgo)
        {
            foreach (var r in pgo.GetComponentsInChildren<UnityEngine.Renderer>())
            {
                foreach (Material m in r.materials)
                {
                    if (ModelShaders.ContainsKey(m.name))
                    {
                        m.shader = ModelShaders[m.name];

                    }
                }
                if (ModelMaterials.ContainsKey(r.material.name))
                {
                    r.material = ModelMaterials[r.material.name];

                }
            }
        }
       
    }
}

```

`7DTD/Hooks/GetRange.cs`:

```cs
using Cheat.Helpers;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
namespace Cheat.Hooks
{
    class GetRange : MonoBehaviour
    {
        public static DumbHook Hook;
        public void Start()
        {
            
                Hook = new DumbHook();
                Hook.Init(typeof(ItemActionRanged).GetMethod("GetRange", BindingFlags.Public | BindingFlags.Instance), typeof(GetRange).GetMethod("HookFunction", BindingFlags.Public | BindingFlags.Instance));
                Hook.Hook();
            
        }
        public float HookFunction(ItemActionData _actionData)
        {
            vp_FPWeapon weapon = Globals.LocalPlayer?.vp_FPWeapon;
            Inventory inventory = Globals.LocalPlayer?.inventory;
            ItemActionAttack gun = inventory?.GetHoldingGun();
            ItemActionRanged action = gun as ItemActionRanged;
            if (!Globals.Config.LocalPlayer.UnlimitedRange)
                return EffectManager.GetValue(PassiveEffects.MaxRange, _actionData.invData.itemValue, action.Range, _actionData.invData.holdingEntity, null, default(FastTags), true, true, true, true, 1, true);
            else
                return 100000000000; // return firing range of infinite
        }
    }
}

```

`7DTD/Hooks/IsOwner.cs`:

```cs
using Cheat.Helpers;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
namespace Cheat.Hooks
{
    class IsOwner : MonoBehaviour
    {
        public static DumbHook Hook;
        public void Start()
        {
            
                Hook = new DumbHook();
                Hook.Init(typeof(EntityVehicle).GetMethod("IsOwner", BindingFlags.Public | BindingFlags.Instance), typeof(IsOwner).GetMethod("HookFunction", BindingFlags.Public | BindingFlags.Instance));
                Hook.Hook();
            
        }
        public bool HookFunction(PlatformUserIdentifierAbs _userIdentifier)
        {
            if (Globals.Config.LocalPlayer.OwnsVehicle)
                return true; // set the user as owning the car
            else
            {
                Hook.Unhook();
                object[] parameters = new object[]
                  {
                    _userIdentifier,

                  };
                object result = Hook.OriginalMethod.Invoke(this, parameters);
                Hook.Hook(); // call the original
                return false; // this wont be called
            }
        }
    }
}

```

`7DTD/Hooks/OnBlockDamaged.cs`:

```cs
using Cheat.Helpers;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
namespace Cheat.Hooks
{
    class OnBlockDamaged : MonoBehaviour
    {
        public static DumbHook Hook;
        public void Start()
        {

                Hook = new DumbHook();
                Hook.Init(typeof(Block).GetMethod("OnBlockDamaged", BindingFlags.Public | BindingFlags.Instance), typeof(OnBlockDamaged).GetMethod("HookFunction", BindingFlags.Public | BindingFlags.Instance));
                Hook.Hook();
            
        }
        public int HookFunction(WorldBase _world, int _clrIdx, Vector3i _blockPos, BlockValue _blockValue, int _damagePoints, int _entityIdThatDamaged, ItemActionAttack.AttackHitInfo _attackHitInfo, bool _bUseHarvestTool, bool _bBypassMaxDamage, int _recDepth = 0)
        {
            if (Globals.Config.LocalPlayer.InstantBreak1)
            {
                // method 1, pick up the block
                _blockValue.Block.CanPickup = true;
                _world.GetGameManager().PickupBlockServer(_clrIdx, _blockPos, _blockValue, 0);
                _blockValue.Block.FallDamage = 0;
            }
            if (Globals.Config.LocalPlayer.InstantBreak2)
            {

                _entityIdThatDamaged = 0;
                _bBypassMaxDamage = true;
                _damagePoints = _blockValue.Block.MaxDamage;

            }
            if (Globals.Config.LocalPlayer.InstantBreak3)
            {
                // set the block health to 1
                _bBypassMaxDamage = true;
                _damagePoints = 1;
                _blockValue.Block.MaxDamage = 1;
            }

            Hook.Unhook();


            object[] parameters = new object[]
               {
                    _world,
                    _clrIdx,
                    _blockPos,
                    _blockValue,
                    _damagePoints,
                    _entityIdThatDamaged,
                    _attackHitInfo,
                    _bUseHarvestTool,
                    _bBypassMaxDamage,
                    _recDepth
               };
           int value = (int)Hook.OriginalMethod.Invoke(this, parameters);

            Hook.Hook();
            return value; 

        }
    }
}

```

`7DTD/Hooks/OnFired.cs`:

```cs
using Cheat.Helpers;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
namespace Cheat.Hooks
{
    class OnFired : MonoBehaviour
    {
        public static DumbHook Hook;
        public void Start()
        {
            if (Globals.Config.LocalPlayer.NoRecoil)
            {
                Hook = new DumbHook();
                Hook.Init(typeof(EntityPlayerLocal).GetMethod("OnFired", BindingFlags.Public | BindingFlags.Instance), typeof(OnFired).GetMethod("HookFunction", BindingFlags.Public | BindingFlags.Instance));
                Hook.Hook();
            }
        }
        public void HookFunction()
        {
       // do nothing
        }
    }
}

```

`7DTD/Hooks/UpdateAccuracy.cs`:

```cs
using Cheat.Helpers;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
namespace Cheat.Hooks
{
    class UpdateAccuracy : MonoBehaviour
    {
        public static DumbHook Hook;
        public void Start()
        {
            if (Globals.Config.LocalPlayer.NoSpread)
            {
                Hook = new DumbHook();
                Hook.Init(typeof(ItemActionRanged).GetMethod("updateAccuracy", BindingFlags.NonPublic | BindingFlags.Instance), typeof(UpdateAccuracy).GetMethod("HookFunction", BindingFlags.NonPublic | BindingFlags.Instance));
                Hook.Hook();
            }
        }
        float HookFunction(ItemActionData _actionData, bool _isAimingGun)
        {
            (_actionData as ItemActionRanged.ItemActionDataRanged).lastAccuracy = 0; // set this incase its used elsewhere

            return (_actionData as ItemActionRanged.ItemActionDataRanged).lastAccuracy; // could return 0 but ehh
        }
    }
}

```

`7DTD/Loader.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
namespace Cheat
{
    class Loader : MonoBehaviour
    {
		// call auth Globals.Auth to load. This is for obfuscation reasons and to establish authenticity.
		public static void Init()
		{


			if (Globals.LoggedIn)
			{
				Loader.HackObject.AddComponent<Cheat.Esp.Zombie>();
				Loader.HackObject.AddComponent<Cheat.Esp.Animal>();
				Loader.HackObject.AddComponent<Cheat.Esp.Player>();
				Loader.HackObject.AddComponent<Cheat.Esp.Tiles>();
				Loader.HackObject.AddComponent<Globals>();
				Loader.HackObject.AddComponent<Menu.Main>();
				Loader.HackObject.AddComponent<Misc>();
				Loader.HackObject.AddComponent<Aimbot>();

				HackObject.AddComponent<Hooks.OnFired>();
				HackObject.AddComponent<Hooks.GetRange>();
				HackObject.AddComponent<Hooks.UpdateAccuracy>();
				HackObject.AddComponent<Hooks.IsOwner>();
				HackObject.AddComponent<Hooks.OnBlockDamaged>();

				UnityEngine.Object.DontDestroyOnLoad(HackObject);

			}

		}
		public static GameObject HackObject = new GameObject(); // make bool in a public static class and check if its true constantly as extra auth shit
	}
}

```

`7DTD/Menu/Button.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Cheat.Menu
{
    class Button : Entity
    {
        public Button(string text, string description, Action button)
        {
            base.Name = text;
            base.Description = description;
            Method = button;
        }
        public Action Method;
    }
}

```

`7DTD/Menu/Entity.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
namespace Cheat.Menu
{
    class Entity
    {
        public string Name;
        public string Description;

    }
}

```

`7DTD/Menu/FloatSlider.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Cheat.Menu
{
    class FloatSlider : Entity
    {
        public unsafe FloatSlider(string text, string description, ref float value, float minvalue, float maxvalue, float incrementvalue)
        {
            base.Name = text;
            base.Description = description;
            fixed (float* ptr = &value)
            {
                float* @Value = ptr;
                this.Float = @Value;
            }
            MinValue = minvalue;
            MaxValue = maxvalue;
            IncrementValue = incrementvalue;
        }
        public unsafe float Value
        {
            get
            {
                return *this.Float;
            }
            set
            {
                *this.Float = value;
            }
        }
        private unsafe float* Float;
        public float MaxValue;
        public float MinValue;
        public float IncrementValue;
    }



}

```

`7DTD/Menu/IntSlider.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Cheat.Menu
{
    class IntSlider : Entity
    {
        public unsafe IntSlider(string text, string description, ref int value,int minvalue,int maxvalue,int incrementvalue)
        {
            base.Name = text;
            base.Description = description;
            fixed (int* ptr = &value)
            {
                int* @Value = ptr;
                this.Int = @Value;
            }
            MinValue = minvalue;
            MaxValue = maxvalue;
            IncrementValue = incrementvalue;
        }
        public unsafe int Value
        {
            get
            {
                return *this.Int;
            }
            set
            {
                *this.Int = value;
            }
        }
        private unsafe int* Int;
        public int MaxValue;
        public int MinValue;
        public int IncrementValue;
    }
   
   
    
}

```

`7DTD/Menu/Keybind.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
namespace Cheat.Menu
{
    class Keybind : Entity
    {
        public unsafe KeyCode Value
        {
            get
            {
                return *this.Bool;
            }
            set
            {
                *this.Bool = value;
            }
        }
        public unsafe Keybind(string text, string description, ref KeyCode value)
        {
            base.Name = text;
            base.Description = description;
            fixed (KeyCode* ptr = &value)
            {
                KeyCode* @Value = ptr;
                this.Bool = @Value;
            }
        }
        private unsafe KeyCode* Bool;
    }
}

```

`7DTD/Menu/Main.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
namespace Cheat.Menu
{ 
    // credit to sCrub, some of the code with handling menu objects is his.
    class Main : MonoBehaviour
    {
        Vector2 MenuPos;
        uint MainMenuIndex = 0;
        private Entity Selected;
        private double NextPlayerTime;
        private KeyCode KeyToBind;
        bool ShowMenu = true;
        int itemamount = 1;
        SubMenu MainMenu = new SubMenu("Main","Menu");

        SubMenu Esp = new SubMenu("ESP", "Draw Visuals");
        SubMenu Aimbot = new SubMenu("Aimbot", "Lock Onto Enemies");
        SubMenu LocalPlayer = new SubMenu("Local Player", "Modify Your Player");
        SubMenu PlayerMenu = new SubMenu("Player Menu", "Allows You To Abuse Other Players");
        SubMenu Colours = new SubMenu("Colour Menu", "Allows You To Change Colours On The Cheat");
        SubMenu Config = new SubMenu("Config Menu", "Allows You To Save And Load Settings");

        SubMenu Save = new SubMenu("Save Config", "Allows You To Save Settings");
        SubMenu Load = new SubMenu("Load Config", "Allows You To Load Settings");

        SubMenu PlayerAimbot = new SubMenu("Player Aimbot", "Configure Aimbot For Players");
        SubMenu ZombieAimbot = new SubMenu("Zombie Aimbot", "Configure Aimbot For Zombies");

        SubMenu Skill = new SubMenu("Skills", "Edit Your Player's Skills");
        SubMenu Movement = new SubMenu("Movement", "Edit Your Player's Movement");
        SubMenu PlayerProperties = new SubMenu("Properties", "Edit Stamina And Other Player Properties");
        SubMenu Weapon = new SubMenu("Weapon", "Modify Your Weapon");
        SubMenu World = new SubMenu("World", "Modify Player World Settings");
        List<SubMenu> MenuHistory = new List<SubMenu>();
        SubMenu CurrentMenu;
        #region Config
        void Configs()
        {
            // putting our options into 2 submenus and adding submenus to config menu
            Config.Items.Add(Save);
            Config.Items.Add(Load);
            #region Save Config
            Button Default = new Button("Default", "", () => Helpers.ConfigHelper.SaveConfig("Default"));
            Button Cfg1 = new Button("Config 1", "", () => Helpers.ConfigHelper.SaveConfig("Config1"));
            Button Cfg2 = new Button("Config 2", "", () => Helpers.ConfigHelper.SaveConfig("Config2"));
            Button Cfg3 = new Button("Config 3", "", () => Helpers.ConfigHelper.SaveConfig("Config3"));
            Button Cfg4 = new Button("Config 4", "", () => Helpers.ConfigHelper.SaveConfig("Config4"));
            Button Cfg5 = new Button("Config 5", "", () => Helpers.ConfigHelper.SaveConfig("Config5"));
            Save.Items.Add(Default);
            Save.Items.Add(Cfg1);
            Save.Items.Add(Cfg2);
            Save.Items.Add(Cfg3);
            Save.Items.Add(Cfg4);
            Save.Items.Add(Cfg5);
            #endregion
            #region Load Config
            Button Default2 = new Button("Default", "", () => Helpers.ConfigHelper.LoadConfig("Default"));
            Button Cfg6 = new Button("Config 1", "", () => Helpers.ConfigHelper.LoadConfig("Config1"));
            Button Cfg7 = new Button("Config 2", "", () => Helpers.ConfigHelper.LoadConfig("Config2"));
            Button Cfg8 = new Button("Config 3", "", () => Helpers.ConfigHelper.LoadConfig("Config3"));
            Button Cfg9 = new Button("Config 4", "", () => Helpers.ConfigHelper.LoadConfig("Config4"));
            Button Cfg10 = new Button("Config 5", "", () => Helpers.ConfigHelper.LoadConfig("Config5"));
            Load.Items.Add(Default2);
            Load.Items.Add(Cfg6);
            Load.Items.Add(Cfg7);
            Load.Items.Add(Cfg8);
            Load.Items.Add(Cfg9);
            Load.Items.Add(Cfg10);
            #endregion
        }
        #endregion
        #region ESP
        void ESP()
        {
            
            SubMenu player = new SubMenu("Player Esp", "Shows Player Information");
            SubMenu zombies = new SubMenu("Zombie Esp", "Shows Zombie Information");
            SubMenu animal = new SubMenu("Animal Esp", "Shows Animal Information");
            SubMenu tiles = new SubMenu("Tile Esp", "Shows Block/Tile Information");
            Esp.Items.Add(player);
            Esp.Items.Add(zombies);
            Esp.Items.Add(animal);
            Esp.Items.Add(tiles);
            #region Player
            Toggle playername = new Toggle("Player Name", "Shows The Player Name", ref Globals.Config.Player.Name);
            Toggle playerdistance = new Toggle("Player Distance", "Shows Your Distance From The Player", ref Globals.Config.Player.Distance);
            Toggle playerhealth = new Toggle("Player Health", "Shows The Player Health", ref Globals.Config.Player.Health);
            IntSlider playermaxdistance = new IntSlider("Max Distance", "Max Distance Players Will Render", ref Globals.Config.Player.MaxDistance, 0, 10000, 50);
            Toggle playeradmin = new Toggle("Show Admin Information", "Shows If Player Is An Admin", ref Globals.Config.Player.ShowAdmins);
            Toggle playerbox = new Toggle("Show Boxes", "Draws Boxes Around Players", ref Globals.Config.Player.Box);
            Toggle playerhealthbar = new Toggle("Show Health Bar", "Draws Health Bar Next To Player", ref Globals.Config.Player.HealthBar);
            Toggle playerchams = new Toggle("Chams", "Changes Player Model Colour", ref Globals.Config.Player.Chams);
            IntSlider playerchamtype = new IntSlider("Cham Type", "Change Cham Settings", ref Globals.Config.Player.ChamType, 0, 6, 1);
            player.Items.Add(playername);
            player.Items.Add(playerdistance);
            player.Items.Add(playerhealth);
            player.Items.Add(playermaxdistance);
            player.Items.Add(playeradmin);
            player.Items.Add(playerbox);
            player.Items.Add(playerhealthbar);
            player.Items.Add(playerchams);
            player.Items.Add(playerchamtype);
            #endregion
            #region Zombie
            Toggle zombiename = new Toggle("Zombie Name", "Shows The Type Of Zombie", ref Globals.Config.Zombie.Name);
            Toggle zombiedistance = new Toggle("Zombie Distance", "Shows Your Distance From The Zombie", ref Globals.Config.Zombie.Distance);
            Toggle zombiehealth = new Toggle("Zombie Health", "Shows The Zombie Health", ref Globals.Config.Zombie.Health);
            IntSlider zombiemaxdistance = new IntSlider("Max Distance", "Max Distance Zombies Will Render", ref Globals.Config.Zombie.MaxDistance, 0, 2000, 50);
            Toggle zombiebox = new Toggle("Zombie Box","Draws Bounding Box Around Zombie", ref Globals.Config.Zombie.Box);
            Toggle zombiehealthbar = new Toggle("Zombie HealthBar", "Bar Representing Health", ref Globals.Config.Zombie.HealthBar);
            Toggle zombiechams = new Toggle("Chams", "Changes Zombie Colour", ref Globals.Config.Zombie.Chams);
            IntSlider zombiechamtype = new IntSlider("Cham Type", "Change Cham Settings", ref Globals.Config.Zombie.ChamType, 0, 6, 1);
            zombies.Items.Add(zombiename);
            zombies.Items.Add(zombiedistance);
            zombies.Items.Add(zombiehealth);
            zombies.Items.Add(zombiemaxdistance);
            zombies.Items.Add(zombiebox);
            zombies.Items.Add(zombiehealthbar);
            zombies.Items.Add(zombiechams);
            zombies.Items.Add(zombiechamtype);
            #endregion
            #region Animal
            Toggle animalname = new Toggle("Animal Name", "Shows The Type Of Animal", ref Globals.Config.Animal.Name);
            Toggle animaldistance = new Toggle("Animal Distance", "Shows Your Distance From The Animal", ref Globals.Config.Animal.Distance);
            Toggle animalhealth = new Toggle("Animal Health", "Shows The Animal Health", ref Globals.Config.Animal.Health);
            IntSlider animalmaxdistance = new IntSlider("Max Distance", "Max Distance Animals Will Render", ref Globals.Config.Animal.MaxDistance, 0, 2000, 50);

            animal.Items.Add(animalname);
            animal.Items.Add(animaldistance);
            animal.Items.Add(animalhealth);
            animal.Items.Add(animalmaxdistance);
            #endregion
            #region Tile
            Toggle tilename = new Toggle("Tile Name", "Shows The Type Of Tile", ref Globals.Config.Tiles.Name);
            Toggle tiledistance = new Toggle("Tile Distance", "Shows Your Distance From The Tile", ref Globals.Config.Tiles.Distance);
            IntSlider tilemaxdistance = new IntSlider("Max Distance", "Max Distance Tiles Will Render", ref Globals.Config.Tiles.MaxDistance, 0, 2000, 50);


 

            tiles.Items.Add(tilename);
            tiles.Items.Add(tiledistance);
            tiles.Items.Add(tilemaxdistance);



            SubMenu tileTypeFilterMenu = new SubMenu("Filter", "Tile Filter");
            tiles.Items.Add(tileTypeFilterMenu);

            System.Collections.IList filterType = Enum.GetValues(typeof(TileEntityType));
            for (int i = 0; i < filterType.Count; i++)
            {
                var type = (TileEntityType)filterType[i];
                Toggle tileTypeFilterToggle = new Toggle($"Tile Type Filter {type.ToStringCached()}", $"Filter : {type.ToStringCached()}", ref Globals.Config.Tiles.TypeFilter[i]);
                tileTypeFilterMenu.Items.Add(tileTypeFilterToggle);
            }

            #endregion
        }
        #endregion
        #region Weapon
        void Weapons()
        {
           
            Button RemoveRecoil = new Button("Remove Recoil", "!This Cant Be Undone! This Button Removes Recoil", () => { Loader.HackObject.GetComponent<Hooks.OnFired>().Start(); });
            Toggle NoRecoil = new Toggle("No Recoil From Start Up", "This Will Remove Recoil On Start Or Config Load", ref Globals.Config.LocalPlayer.NoRecoil);
            Button RemoveSpread = new Button("Remove Spread", "!This Cant Be Undone! This Button Removes Spread", () => { Loader.HackObject.GetComponent<Hooks.UpdateAccuracy>().Start(); });
            Toggle NoSpread = new Toggle("No Spread From Start Up", "This Will Remove Spread On Start Or Config Load", ref Globals.Config.LocalPlayer.NoSpread);
            Toggle NoViewBob = new Toggle("No Shake", "Removes Shake/ViewBob", ref Globals.Config.LocalPlayer.NoViewBob);
            Toggle UnlimitedAmmo = new Toggle("Unlimited Ammo", "Gives You Unlimited Ammo", ref Globals.Config.LocalPlayer.UnlimitedAmmo);
            Toggle UnlimitedRange = new Toggle("Unlimited Range", "Allows You To Shoot Further", ref Globals.Config.LocalPlayer.UnlimitedRange);
            Toggle FovChanger = new Toggle("Weapon Fov Changer", "Changes Distance Of Weapon From Camera", ref Globals.Config.LocalPlayer.WeaponFovChanger);
            IntSlider FovSlider = new IntSlider("Weapon Fov", "Amount Of Fov The Fov Changer Will Change", ref Globals.Config.LocalPlayer.WeaponFov, 10, 190, 5);
            Toggle CamFovChanger = new Toggle("Camera Fov Changer", "Changes Your Camera's perception Of Distance", ref Globals.Config.LocalPlayer.CameraFovChanger);
            IntSlider CamFovSlider = new IntSlider("Camera Fov", "Amount Of Fov The Fov Changer Will Change", ref Globals.Config.LocalPlayer.CameraFov, 10, 190, 5);
            Weapon.Items.Add(RemoveRecoil);
            Weapon.Items.Add(NoRecoil);
            Weapon.Items.Add(RemoveSpread);
            Weapon.Items.Add(NoSpread);
            Weapon.Items.Add(NoViewBob);
            Weapon.Items.Add(UnlimitedAmmo);
            Weapon.Items.Add(UnlimitedRange);
            Weapon.Items.Add(FovChanger);
            Weapon.Items.Add(FovSlider);
            Weapon.Items.Add(CamFovChanger);
            Weapon.Items.Add(CamFovSlider);
            LocalPlayer.Items.Add(Weapon);
        }
        #endregion
        #region Aimbot
        void Aimbots()
        {
            IntSlider fov = new IntSlider("Aimbot Fov", "Circle Range From Centre Of Your Screen That Aimbot Will Target", ref Globals.Config.Aimbot.Fov, 0, 1800, 25);
            Toggle drawfov = new Toggle("Draw Fov", "Draws A Circle To Display Aimbot Fov", ref Globals.Config.Aimbot.DrawFov);
            Toggle drawtarget = new Toggle("Draw Aimbot Target Line", "Draws A Line To Aimbot Target", ref Globals.Config.Aimbot.DrawTargetLine);
            IntSlider hitchance = new IntSlider("Aimbot Hitchance", "% Chance Your Aimbot Hits Target", ref Globals.Config.Aimbot.Hitchance, 0, 100, 10);
            Aimbot.Items.Add(PlayerAimbot);
            Aimbot.Items.Add(ZombieAimbot);
            Aimbot.Items.Add(fov);
            Aimbot.Items.Add(drawfov);
            Aimbot.Items.Add(drawtarget);
            Aimbot.Items.Add(hitchance);

            Toggle targetplayer = new Toggle("Enable Player Aimbot", "Makes Aimbot Target Players", ref Globals.Config.Aimbot.PlayerAimbot);
            Toggle targetfriend = new Toggle("Target Friends", "Makes Aimbot Target Friends", ref Globals.Config.Aimbot.PlayerAimbotTargetFriends);
            Toggle visibleplayer = new Toggle("Visibility Check", "Aimbot Only Targets Visible Players", ref Globals.Config.Aimbot.PlayerVisibilityChecks);
            Keybind playerbind = new Keybind("PLayer Aimbot Keybind", "Key Aimbot Will Work On - To have it turned on when you shoot use your mouse0", ref Globals.Config.Aimbot.PlayerKey);
            PlayerAimbot.Items.Add(targetplayer);
            PlayerAimbot.Items.Add(targetfriend);
            PlayerAimbot.Items.Add(visibleplayer);
            PlayerAimbot.Items.Add(playerbind);

            Toggle targetzombie = new Toggle("Enable Zombie Aimbot", "Makes Aimbot Target Zombies", ref Globals.Config.Aimbot.ZombieAimbot);
            Toggle visiblezombie = new Toggle("Visibility Check", "Aimbot Only Targets Visible Zombies", ref Globals.Config.Aimbot.ZombieVisibilityChecks);
            Keybind zombiebind = new Keybind("Zombie Aimbot Keybind", "Key Aimbot Will Work On - To have it turned on when you shoot use your mouse0", ref Globals.Config.Aimbot.ZombieKey);
            ZombieAimbot.Items.Add(targetzombie);
            ZombieAimbot.Items.Add(visiblezombie);
            ZombieAimbot.Items.Add(zombiebind);

        }
        #endregion
        #region Skills
        void Skills()
        {
           
            IntSlider kill = new IntSlider("Amount Of Player Kills", "Amount Of Player Kills To Set", ref Globals.Config.LocalPlayer.Kills,0,30000,3);
            Button killbtn = new Button("Set Player Kills", "Sets The Amount Of Player Kills Your Player Has", () => Misc.SetKills(Globals.Config.LocalPlayer.Kills));
            IntSlider zombiekill = new IntSlider("Amount Of Zombie Kills", "Amount Of Zombie Kills To Set", ref Globals.Config.LocalPlayer.ZombieKills, 0, 30000, 3);
            Button zombiekillbtn = new Button("Set Zombie Kills", "Sets The Amount Of Zombie Kills Your Player Has", () => Misc.SetZombieKills(Globals.Config.LocalPlayer.ZombieKills));
            IntSlider death = new IntSlider("Amount Of Deaths", "Amount Of Deaths To Set", ref Globals.Config.LocalPlayer.Deaths, 0, 30000, 3);
            Button deathbtn = new Button("Set Deaths", "Sets The Amount Of Deaths Your Player Has", () => Misc.SetDeaths(Globals.Config.LocalPlayer.Deaths));
            IntSlider level = new IntSlider("Amount Of Levels", "Amount Of Zombie Levels To", ref Globals.Config.LocalPlayer.Level, 0, 30000, 3);
            Button levelbtn = new Button("Set Player Levels", "Sets Your Player Level", () => Misc.SetLevel(Globals.Config.LocalPlayer.Level));
            IntSlider distance = new IntSlider("Amount Of Distance KM", "Amount Of Distance KM To Set", ref Globals.Config.LocalPlayer.DistanceTravelled, 0, 30000, 3);
            Button distancebtn = new Button("Set Player Traveled Distance", "Sets Your Player's Total Distance Traveled", () => Misc.SetDistanceTraveled(Globals.Config.LocalPlayer.DistanceTravelled));
            IntSlider crafted = new IntSlider("Amount Of Items Crafted", "Amount Of Items Crafted To Set", ref Globals.Config.LocalPlayer.ItemsCrafted, 0, 70000, 7);
            Button craftedbtn = new Button("Set Items Crafted", "Sets Your Player's Items Crafted", () => Misc.SetTotalItemsCrafted(Globals.Config.LocalPlayer.ItemsCrafted));
            IntSlider time = new IntSlider("Amount Of Time Played", "Amount Of Time Played On Server In Hours", ref Globals.Config.LocalPlayer.TimePlayed, 0, 70000, 7);
            Button timebtn = new Button("Set Time Played", "Sets Player's Time Played On Server", () => Misc.SetTotalTimePlayed(Globals.Config.LocalPlayer.TimePlayed));
            IntSlider skill = new IntSlider("Amount Of Skill Points", "Amount Of Skill Points To Add", ref Globals.Config.LocalPlayer.SkillPoints, 0, 30000, 3);
            Button skillbtn = new Button("Set Player Skill Points", "Sets Your Player's Skillpoints", () => Misc.SetSkillPoints(Globals.Config.LocalPlayer.SkillPoints));

            Skill.Items.Add(kill);
            Skill.Items.Add(killbtn);
            Skill.Items.Add(zombiekill);
            Skill.Items.Add(zombiekillbtn);
            Skill.Items.Add(death);
            Skill.Items.Add(deathbtn);
            Skill.Items.Add(level);
            Skill.Items.Add(levelbtn);
            Skill.Items.Add(distance);
            Skill.Items.Add(distancebtn);
            Skill.Items.Add(crafted);
            Skill.Items.Add(craftedbtn);
            Skill.Items.Add(time);
            Skill.Items.Add(timebtn);
            Skill.Items.Add(skill);
            Skill.Items.Add(skillbtn);
            LocalPlayer.Items.Add(Skill);

        }
        #endregion
        #region Movement
        void Movements()
        {
            Toggle speedhack = new Toggle("Speedhack", "Allows You To Zoom", ref Globals.Config.LocalPlayer.Speedhack);
            IntSlider speed = new IntSlider("Speed Value", "Change The Speed Your Speedhack Works At", ref Globals.Config.LocalPlayer.SpeedAmount, 1, 30, 1);
            Keybind speedbind = new Keybind("Speedhack Keybind", "Sets The Key You Hold To Use Speedhack", ref Globals.Config.LocalPlayer.SpeedKey);
            Toggle noclip = new Toggle("Custom Noclip", "Custom Noclip To Avoid Instant Bans, Noclip With This Then Turn On Fly For Best Usage", ref Globals.Config.LocalPlayer.BtecNoclip);
            IntSlider noclipspeed = new IntSlider("Noclip Speed Value", "Change The Speed You Noclip At", ref Globals.Config.LocalPlayer.NoclipSpeed, 1, 30, 1);
            Keybind noclipbind = new Keybind("Noclip Keybind", "Sets The Key You Hold To Use Custom Noclip", ref Globals.Config.LocalPlayer.NoclipKey);
            Movement.Items.Add(speedhack);
            Movement.Items.Add(speed);
            Movement.Items.Add(speedbind);
            Movement.Items.Add(noclip);
            Movement.Items.Add(noclipspeed);
            Movement.Items.Add(noclipbind);
            LocalPlayer.Items.Add(Movement); // teleport to waypoint, speedhack, also try find the function that shows other player's bases and hook it
        }
        #endregion
        #region Properties
        void Properties()
        {
            Toggle unlimitedstamina = new Toggle("Unlimited Stamina", "Run Forrest, Run", ref Globals.Config.LocalPlayer.UnlimitedStamina);
            Toggle unlimitedhunger = new Toggle("Unlimited Hunger", "You Are Too Chonky To Lose Hunger", ref Globals.Config.LocalPlayer.UnlimitedHunger);
            Toggle unlimitedwater = new Toggle("Unlimited Water", "Never Run Out Of Water Like A Camel", ref Globals.Config.LocalPlayer.UnlimitedThirtst);
            Toggle unlimitedhealth = new Toggle("Instant Health Regeneration", "You Health Instantly Regenerates To Max", ref Globals.Config.LocalPlayer.InstantHealth);
           // Toggle nofall = new Toggle("No Fall Damage", "Never Skipping Leg Day", ref Globals.Config.LocalPlayer.NoFallDamage);
            Toggle cleardebuff = new Toggle("Clear Debuffs", "Removes Negative Debuffs", ref Globals.Config.LocalPlayer.ClearDebuffs);
            Toggle spoofname = new Toggle("Spoof Name", "Spoofs Your Name", ref Globals.Config.LocalPlayer.SpoofName);
            Toggle spoofid = new Toggle("Spoof ID", "Allows You To Use IDS In PlayerList", ref Globals.Config.LocalPlayer.SpoofID);
            Button name = new Button("Copy Name From Clipboard", "Copies Name From Clipboard And Spoofs Name To It", () => Misc.ClipboardToString(out Misc.Name));
            Toggle namechanger = new Toggle("Name Changer", "Requires Spoof Name! Automatically Changes Name To Player Names", ref Globals.Config.LocalPlayer.RandomlySpoofName);
            PlayerProperties.Items.Add(unlimitedstamina);
            PlayerProperties.Items.Add(unlimitedhunger);
            PlayerProperties.Items.Add(unlimitedwater);
            PlayerProperties.Items.Add(unlimitedhealth);
         //   PlayerProperties.Items.Add(nofall);
            PlayerProperties.Items.Add(cleardebuff);
            PlayerProperties.Items.Add(spoofname);
            PlayerProperties.Items.Add(spoofid);
            PlayerProperties.Items.Add(name);
            PlayerProperties.Items.Add(namechanger);
            LocalPlayer.Items.Add(PlayerProperties);
        
        }
        #endregion
        #region World
        void Worlds()
        {
            LocalPlayer.Items.Add(World);
            Button cmd = new Button("Execute Console Comand From Clipboard", "Copy A Comand Then Click Enter", () => Misc.ExecuteCommandFromClipboard());
            IntSlider itmamount = new IntSlider("Amount Of Items", "Amount Of Items To Give Yourself", ref itemamount, 1, 100, 1);
            Button giveitem = new Button("Give Item From Name From Clipboard", "Copy An Item Code And Input Amount And You Will Be Given The Item", () => Misc.GiveItemFromClipboard(itemamount));
            Toggle block = new Toggle("Disable Land Claim Durability", "Disables Damage Protection From Land Claim Blocks", ref Globals.Config.LocalPlayer.LandClaim);
            Toggle instant1 = new Toggle("Instant Break Blocks 1", "Breaks Blocks And Bypasses Most Server Checks", ref Globals.Config.LocalPlayer.InstantBreak1);
            Toggle instant2 = new Toggle("Instant Break Blocks 2", "Breaks Blocks With A Different Bypass", ref Globals.Config.LocalPlayer.InstantBreak2);
            Toggle instant3 = new Toggle("Instant Break Blocks 3", "Breaks Blocks With A Different Bypass", ref Globals.Config.LocalPlayer.InstantBreak3);
            Button craft = new Button("Instant Free Craft", "Craft Items Instantly With No Resources", () => Misc.InstantCraft());
            Button nuke = new Button("Kill Everyone Excluding Yourself", "Kills Everyone But You", () => Misc.KillEveryoneElse());
            Button nuke2 = new Button("Kill Everyone Including Yourself", "Kills Everyone", () => Misc.KillEveryone());
            Toggle creative = new Toggle("Creative Menu", "Allows You To Spawn Items(Admins Can See Spawned Items)", ref Globals.Config.LocalPlayer.CreativeMenu);
            Toggle debug = new Toggle("Debug Menu", "Allows You To Fly And Teleport On Map(Noclip And Godmode Which Is On The Q Key Will Insta Ban You)", ref Globals.Config.LocalPlayer.DebugMenu);
            //Button creative = new Button("Creative Menu Button", "Allows You To Spawn Items", () => Misc.CreativeMenu());
            // Button debug = new Button("Debug Menu Button", "Allows You To Fly And Teleport On Map", () => Misc.DebugMenu());
            Toggle farinteract = new Toggle("Far Interact", "Allows You To Place And Pickup Blocks Further Away", ref Globals.Config.LocalPlayer.FarInteract);
            IntSlider interactdistance = new IntSlider("Far Interact Distance", "How Far You Can Interact", ref Globals.Config.LocalPlayer.FarInteractDistance, 25, 1000, 5);
            Toggle allahmode = new Toggle("Allah Mode", "You Prayed 5 Times Today, Now You Can Terrorize Servers. ALWAYS USE FLYHACK! DONT USE CHAT!", ref Globals.Config.LocalPlayer.AllahMode);
            Toggle vehicles = new Toggle("Unlock Vehicles", "You Own All Vehicles", ref Globals.Config.LocalPlayer.OwnsVehicle);
           
            World.Items.Add(cmd);
            World.Items.Add(itmamount);
            World.Items.Add(giveitem);
            World.Items.Add(block);
            World.Items.Add(instant1);
            World.Items.Add(instant2);
            World.Items.Add(instant3);
            World.Items.Add(craft);
            World.Items.Add(nuke);
            World.Items.Add(nuke2);
            World.Items.Add(creative);
            World.Items.Add(debug);
            World.Items.Add(farinteract);
            World.Items.Add(interactdistance);
            World.Items.Add(allahmode);
            World.Items.Add(vehicles);
        }
        #endregion
        // if entity is keybind. keybind = keycode.none, if any keybind == keycode.null make it = setkey
        KeyCode SetKey()
        {
            KeyCode Key = new KeyCode();
            Event e = Event.current;
            if (e.keyCode != KeyCode.RightArrow)
            {
                Key = e.keyCode;
              

            }
            else
            {
                Key = KeyCode.None;

            }
            if (Input.GetKeyDown(KeyCode.Mouse0))
            {
                Key = KeyCode.Mouse0;
               
            }
            if (Input.GetKeyDown(KeyCode.Mouse1))
            {
                Key = KeyCode.Mouse1;
                
            }
            if (Input.GetKeyDown(KeyCode.Mouse2))
            {
                Key = KeyCode.Mouse2;
               
            }
            if (Input.GetKeyDown(KeyCode.Mouse3))
            {
                Key = KeyCode.Mouse3;
               
            }
            if (Input.GetKeyDown(KeyCode.Mouse4))
            {
                Key = KeyCode.Mouse4;
              
            }
            if (Input.GetKeyDown(KeyCode.Mouse5))
            {
                Key = KeyCode.Mouse5;
                
            }
            if (Input.GetKeyDown(KeyCode.Mouse6))
            {
                Key = KeyCode.Mouse6;
                
            }
            return Key;
        }

        void Start()
        {
            MenuPos.x = 50;
            MenuPos.y = 100;
            MenuHistory.Add(MainMenu);
            CurrentMenu = MainMenu;
            MainMenu.Items.Add(Esp);
            MainMenu.Items.Add(Aimbot);
            MainMenu.Items.Add(LocalPlayer);
            MainMenu.Items.Add(PlayerMenu);
            MainMenu.Items.Add(Colours);
            MainMenu.Items.Add(Config);
            Weapons();
            Configs();
            ESP();
            Aimbots();
            Skills();
            Movements();
            Properties();
            Worlds();
            #region Colour Picker
            // amount of colours in the dictionary is always the same in game so we dont need to update this.
            foreach (KeyValuePair<string, Color32> value in Globals.Config.Colours.GlobalColors)
            {
                SubMenu colourmenu = new SubMenu(value.Key,"");
                int alpha = Helpers.ColourHelper.GetColour(value.Key).a;
                IntSlider slidera = new IntSlider("Alpha", "Change The Colour Opacity", ref alpha, 0, 255, 10);
                int red = Helpers.ColourHelper.GetColour(value.Key).r;
                IntSlider sliderr = new IntSlider("Red", "Change Amount Of Red In Colour", ref red, 0, 255, 10);
                int green = Helpers.ColourHelper.GetColour(value.Key).g;
                IntSlider sliderg = new IntSlider("Green", "Change Amount Of Green In Colour", ref green, 0, 255, 10);
                int blue = Helpers.ColourHelper.GetColour(value.Key).b;
                IntSlider sliderb = new IntSlider("Blue", "Change Amount Of Blue In Colour", ref blue, 0, 255, 10);
                colourmenu.Items.Add(slidera);
                colourmenu.Items.Add(sliderr);
                colourmenu.Items.Add(sliderg);
                colourmenu.Items.Add(sliderb);
                colourmenu.Items.Add(new Button("Save Colour", "Right Arrow To Save The Colour", () => Helpers.ColourHelper.SetColour(value.Key, new Color32((byte)red, (byte)green, (byte)blue, (byte)alpha))));
                Colours.Items.Add(colourmenu);
            }
            #endregion


        }

        void OnGUI()
        {
            Drawing.DrawString(new Vector2(5,0), $"7DTD Hack", Helpers.ColourHelper.GetColour("Menu Primary Colour"), false, 14, FontStyle.Normal, 0);
            Globals.MainCamera = Camera.main;
            if (!ShowMenu)
                return;
            string text = string.Empty;
            if (MenuHistory.Count > 0)
            {
                foreach (SubMenu subMenu in MenuHistory)
                {
                    if (subMenu != null)
                    {
                        if (subMenu == MenuHistory.Last<SubMenu>())
                        {
                            text += subMenu.Name + " v ";
                        }
                        else
                        {
                            text = text + subMenu.Name + " > ";
                        }
                    }
                }
            }

            Drawing.DrawString(new Vector2(MenuPos.x - 5, MenuPos.y - 20), text, Helpers.ColourHelper.GetColour("Menu Primary Colour"), false, 12, FontStyle.Normal, 0); // draw menu history
            #region PlayerMenu
            if (CurrentMenu == PlayerMenu)
            {
                // so basically we can add options to the playerlist here so we can make a button to kill that player etc
                if (Time.time > NextPlayerTime)
                {
                    PlayerMenu.Items.Clear();
                    foreach (EntityPlayer player in Cheat.Esp.Player.PlayerList)
                    {
                        if (player == null)
                            continue;
                        if (player.IsSleeper)
                            continue;
                      //  if (!player.IsAlive())
                        //    continue;
                        SubMenu playermenu = new SubMenu(player.EntityName,"");
                        PlayerMenu.Items.Add(playermenu);
                        playermenu.Items.Add(new Button("Teleport To Player", "Teleports You To Player", () => Misc.TeleportToPlayer(player)));
                        playermenu.Items.Add(new Button("Kill Player", "JFKs The Player", () => Cheat.Misc.KillPlayer(player)));
                        playermenu.Items.Add(new Button("Start Constantly Kill Player", "Keeps Killing Player Constantly", () => Cheat.Misc.StartConstantlyKillPlayer(player)));
                        playermenu.Items.Add(new Button("Stop Constantly Kill Player", "Stops Constantly Killing Player", () => Cheat.Misc.StopConstantlyKillPlayer(player)));
                        playermenu.Items.Add(new Button("Spoof Name To Player", $"Changes Your Name This Players Name: {player.EntityName}", () => Cheat.Misc.SpoofName(player)));
                        playermenu.Items.Add(new Button("Spoof Stats To Player", $"Changes Your Stats To Copy The Player", () => Cheat.Misc.SpoofStats(player)));
                        playermenu.Items.Add(new Button("Spoof To Player ID", $"Dont Use With ALLAHMODE! Allows You To Change IDS To Break Their Blocks On Some PVE Servers. Restart After Leaving Server", () => Cheat.Misc.SpoofID(player)));
                    }
                    NextPlayerTime = Time.time + 2;
                }
            }
            #endregion
            foreach (Entity entity in CurrentMenu.Items)
            {
                
                if (Selected == entity)
                {
                    if (entity.Description != null)
                        Drawing.DrawString(new Vector2(MenuPos.x - 5, MenuPos.y + (20f * (float)CurrentMenu.Items.Count)), entity.Description, Helpers.ColourHelper.GetColour("Menu Primary Colour"), false, 12, FontStyle.Normal, 0);
                    if (entity is Toggle)
                    {
                        Toggle toggle = entity as Toggle;
                        string ToggleStr = toggle.Value ? "Enabled" : "Disabled";
                        Drawing.DrawString(new Vector2(MenuPos.x, MenuPos.y + (20 * CurrentMenu.Items.IndexOf(entity))), $"- {entity.Name}: {ToggleStr}", Helpers.ColourHelper.GetColour("Menu Primary Colour"), false, 14, FontStyle.Normal, 0);
                    }
                    if (entity is IntSlider)
                    {
                        IntSlider slider = entity as IntSlider;
                        Drawing.DrawString(new Vector2(MenuPos.x, MenuPos.y + (20 * CurrentMenu.Items.IndexOf(entity))), $"- {entity.Name}: {slider.Value}", Helpers.ColourHelper.GetColour("Menu Primary Colour"), false, 14, FontStyle.Normal, 0);
                    }
                    if (entity is FloatSlider)
                    {
                        FloatSlider slider = entity as FloatSlider;
                        Drawing.DrawString(new Vector2(MenuPos.x, MenuPos.y + (20 * CurrentMenu.Items.IndexOf(entity))), $"- {entity.Name}: {slider.Value}", Helpers.ColourHelper.GetColour("Menu Primary Colour"), false, 14, FontStyle.Normal, 0);
                    }
                    if (entity is Keybind)
                    {
                        Keybind bind = entity as Keybind;
                        Drawing.DrawString(new Vector2(MenuPos.x, MenuPos.y + (20 * CurrentMenu.Items.IndexOf(entity))), $"- {entity.Name}: {bind.Value.ToString()}", Helpers.ColourHelper.GetColour("Menu Primary Colour"), false, 14, FontStyle.Normal, 0);
                    }
                    if (entity is SubMenu)
                    Drawing.DrawString(new Vector2(MenuPos.x, MenuPos.y + (20 * CurrentMenu.Items.IndexOf(entity))), $"> {entity.Name}", Helpers.ColourHelper.GetColour("Menu Primary Colour"), false, 14, FontStyle.Normal, 0);
                    if (entity is Button)
                        Drawing.DrawString(new Vector2(MenuPos.x, MenuPos.y + (20 * CurrentMenu.Items.IndexOf(entity))), $"- {entity.Name}", Helpers.ColourHelper.GetColour("Menu Primary Colour"), false, 14, FontStyle.Normal, 0);
                }
                else
                {
                    if (entity is Toggle)
                    {
                        Toggle toggle = entity as Toggle;
                        string ToggleStr = toggle.Value ? "Enabled" : "Disabled";
                        Drawing.DrawString(new Vector2(MenuPos.x, MenuPos.y + (20 * CurrentMenu.Items.IndexOf(entity))), $"- {entity.Name}: {ToggleStr}", Helpers.ColourHelper.GetColour("Menu Secondary Colour"), false, 12, FontStyle.Normal, 0);
                    }
                    if (entity is IntSlider)
                    {
                        IntSlider slider = entity as IntSlider;
                        Drawing.DrawString(new Vector2(MenuPos.x, MenuPos.y + (20 * CurrentMenu.Items.IndexOf(entity))), $"- {entity.Name}: {slider.Value}", Helpers.ColourHelper.GetColour("Menu Secondary Colour"), false, 12, FontStyle.Normal, 0);
                    }
                    if (entity is FloatSlider)
                    {
                        FloatSlider slider = entity as FloatSlider;
                        Drawing.DrawString(new Vector2(MenuPos.x, MenuPos.y + (20 * CurrentMenu.Items.IndexOf(entity))), $"- {entity.Name}: {slider.Value}", Helpers.ColourHelper.GetColour("Menu Secondary Colour"), false, 12, FontStyle.Normal, 0);
                    }
                    if (entity is Keybind)
                    {
                        Keybind bind = entity as Keybind;
                        Drawing.DrawString(new Vector2(MenuPos.x, MenuPos.y + (20 * CurrentMenu.Items.IndexOf(entity))), $"- {entity.Name}: {bind.Value.ToString()}", Helpers.ColourHelper.GetColour("Menu Secondary Colour"), false, 12, FontStyle.Normal, 0);
                    }
                    if (entity is SubMenu)
                    Drawing.DrawString(new Vector2(MenuPos.x, MenuPos.y + (20 * CurrentMenu.Items.IndexOf(entity))), $"> {entity.Name}", Helpers.ColourHelper.GetColour("Menu Secondary Colour"), false, 12, FontStyle.Normal, 0);
                    if(entity is Button)
                        Drawing.DrawString(new Vector2(MenuPos.x, MenuPos.y + (20 * CurrentMenu.Items.IndexOf(entity))), $"- {entity.Name}", Helpers.ColourHelper.GetColour("Menu Secondary Colour"), false, 12, FontStyle.Normal, 0);
                }
            }
              
            }
        void Update()
        {

            #region Controls
            if (Input.GetKeyDown(KeyCode.Insert))
                ShowMenu = !ShowMenu;
            if (!ShowMenu)
                return;
            if (Input.GetKeyDown(KeyCode.DownArrow) && CurrentMenu.index < CurrentMenu.Items.Count)
                CurrentMenu.index++;
            if (Input.GetKeyDown(KeyCode.UpArrow) && CurrentMenu.index > 0)
                CurrentMenu.index--;
            if (Input.GetKeyDown(KeyCode.Backspace) && MenuHistory.Count > 1)
            {
                CurrentMenu = MenuHistory[MenuHistory.Count - 2];
                MenuHistory.Remove(MenuHistory.Last<SubMenu>());
                return;
            }
            if (((Input.GetKeyDown(KeyCode.LeftArrow) && Selected is SubMenu)) && CurrentMenu.index < CurrentMenu.Items.Count)
            {

                CurrentMenu = MenuHistory[MenuHistory.Count - 2];
                MenuHistory.Remove(MenuHistory.Last<SubMenu>());
                return;
            }
            foreach (Entity entity in CurrentMenu.Items)
            {
            
                if (CurrentMenu.index == CurrentMenu.Items.IndexOf(entity))
                    Selected = entity;
                if (entity != Selected)
                    continue;

            }
            if (Selected is Keybind)
            {
                Keybind bind = Selected as Keybind;
                if (bind.Value == KeyCode.None)
                    bind.Value = SetKey();

            }
            if (Selected is SubMenu && (Input.GetKeyDown(KeyCode.RightArrow) || Input.GetKeyDown(KeyCode.Return)))
            {
                CurrentMenu = Selected as SubMenu;
                MenuHistory.Add(Selected as SubMenu);
                return; // opens a new menu so we need to exit the loop to then render our new currentmenu
            }
            if (Selected is Toggle && Input.GetKeyDown(KeyCode.RightArrow))
            {
                Toggle toggle = Selected as Toggle;
                toggle.Value = true;
            }
            if (Selected is Toggle && Input.GetKeyDown(KeyCode.LeftArrow))
            {
                Toggle toggle = Selected as Toggle;
                toggle.Value = false;
            }
            if (Selected is Button && (Input.GetKeyDown(KeyCode.RightArrow) || Input.GetKeyDown(KeyCode.Return)))
            {
                Button button = Selected as Button;
                button.Method();
            }
            if (Selected is IntSlider && Input.GetKeyDown(KeyCode.RightArrow))
            {
                IntSlider slider = Selected as IntSlider;
                int result = slider.Value + slider.IncrementValue;

                if (result > slider.MaxValue)
                    slider.Value = slider.MaxValue;
                else
                    slider.Value = result;
            }
            if (Selected is IntSlider && Input.GetKeyDown(KeyCode.LeftArrow))
            {
                IntSlider slider = Selected as IntSlider;
                int result = slider.Value - slider.IncrementValue;

                if (result < slider.MinValue)
                    slider.Value = slider.MinValue;
                else
                    slider.Value = result;
            }
            if (Selected is FloatSlider && Input.GetKeyDown(KeyCode.RightArrow))
            {
                FloatSlider slider = Selected as FloatSlider;
                float result = slider.Value + slider.IncrementValue;

                if (result > slider.MaxValue)
                    slider.Value = slider.MaxValue;
                else
                    slider.Value = result;
            }
            if (Selected is FloatSlider && Input.GetKeyDown(KeyCode.LeftArrow))
            {
                FloatSlider slider = Selected as FloatSlider;
                float result = slider.Value - slider.IncrementValue;

                if (result < slider.MinValue)
                    slider.Value = slider.MinValue;
                else
                    slider.Value = result;
            }
            if (Selected is Keybind && (Input.GetKeyDown(KeyCode.RightArrow) || Input.GetKeyDown(KeyCode.Return)))
            {
                Keybind bind = Selected as Keybind;
                bind.Value = KeyCode.None;
            }
            #endregion
        }
    }
}

```

`7DTD/Menu/SubMenu.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
namespace Cheat.Menu
{
    class SubMenu : Entity
    {
        public SubMenu(string text,string description)
        {
            base.Name = text;
            base.Description = description;
        }
        public List<Entity> Items = new List<Entity>();
        public int index = 0;

    }
}

```

`7DTD/Menu/Toggle.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Cheat.Menu
{
    class Toggle : Entity
    {
        public unsafe bool Value
        {
            get
            {
                return *this.Bool;
            }
            set
            {
                *this.Bool = value;
            }
        }
        public unsafe Toggle(string text,string description,ref bool value)
        {
            base.Name = text;
            base.Description = description;
            fixed (bool* ptr = &value)
            {
                bool* @Value = ptr;
                this.Bool = @Value;
            }
        }
        private unsafe bool* Bool;
    }
}

```

`7DTD/Misc.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
using Cheat.Helpers;

namespace Cheat
{
    class Misc : MonoBehaviour
    {
        private static List<EntityPlayer> KillList = new List<EntityPlayer>();

        void Update()
        {
            
       
            try
            {
                
                 

                foreach (EntityPlayer player in KillList)
                {
                    System.Random rand = new System.Random();
                    int randsource = 0;
                    int randtype = 0;
                    randsource = rand.Next(0, 1);
                    randtype = rand.Next(0, 26);
                    EnumDamageSource damsource = DamageSourceDict[randsource];
                    EnumDamageTypes damtype = DamageTypeDict[randtype];
                    DamageSource source = new DamageSource(damsource, damtype);
                    if (player.IsAlive()) // check if the player is alive
                        player.DamageEntity(source, player.Health, false, 1); // kill the player if they are on our kill list
                }
            }
            catch { }
            Speedhack();
            SetProperties();
           Noclip();
            Worlds();

            if (Globals.LocalPlayer == null)
                return;
      

            #region LocalPlayer
            try
            {
                if (Globals.Config.LocalPlayer.CameraFovChanger)
                    Globals.MainCamera.fieldOfView = Globals.Config.LocalPlayer.CameraFov; // change camera fov
                vp_FPWeapon weapon = Globals.LocalPlayer?.vp_FPWeapon;
                if (weapon)
                {
                    if (Globals.Config.LocalPlayer.NoViewBob)
                    {
                        // remove view bob by nulling and 0ing
                        weapon.BobRate = Vector4.zero;
                        weapon.ShakeAmplitude = Vector3.zero;
                        weapon.StepForceScale = 0f;
                        weapon.ShakeSpeed = 0;
                    }
                    if (Globals.Config.LocalPlayer.WeaponFovChanger)
                    {
                        // change weapon position in weaponfov
                        weapon.RenderingFieldOfView = Globals.Config.LocalPlayer.WeaponFov;
                    }
                }
                Inventory inventory = Globals.LocalPlayer?.inventory;
                if (inventory != null)
                {
                    ItemActionAttack gun = inventory?.GetHoldingGun();
                    if (gun is ItemActionRanged)
                    {
                     
                    }
                    if (Globals.Config.LocalPlayer.UnlimitedAmmo)
                    {
                        // not all of this is to do with unlimited ammo
                        gun.InfiniteAmmo = true; // set ammo
                        gun.Velocity.Value = 100000000; // set speed
                        gun.Range = 1000000000; // set range on players
                        gun.AutoFire.Value = true; // full auto
                        gun.BlockRange = 100000000; // block max attack range
                    }
                    
                }
            }
            catch { }
            #endregion 

        }


        static Dictionary<int, EnumDamageSource> DamageSourceDict = new Dictionary<int, EnumDamageSource>() { {0,EnumDamageSource.Internal },{ 1, EnumDamageSource.External } };
        static Dictionary<int, EnumDamageTypes> DamageTypeDict = new Dictionary<int, EnumDamageTypes>() {
            { 0, EnumDamageTypes.BarbedWire },
            { 1, EnumDamageTypes.Bashing },
         { 2, EnumDamageTypes.BlackOut },
         { 3, EnumDamageTypes.BloodLoss },
         { 4, EnumDamageTypes.Break },
         { 5, EnumDamageTypes.Cold },
         { 6, EnumDamageTypes.Corrosive },
         { 7, EnumDamageTypes.COUNT },
         { 8, EnumDamageTypes.Crushing },
         { 9, EnumDamageTypes.Dehydration },
         { 10, EnumDamageTypes.Disease },
         { 11, EnumDamageTypes.Electrical },
         { 12, EnumDamageTypes.Falling },
        { 13, EnumDamageTypes.Heat },
        { 14, EnumDamageTypes.Infection },
        { 15, EnumDamageTypes.KnockDown },
        { 16, EnumDamageTypes.KnockOut },
        { 17, EnumDamageTypes.Piercing },
        { 18, EnumDamageTypes.Radiation },
        { 19, EnumDamageTypes.Slashing },
        { 20, EnumDamageTypes.Sprain },
        { 21, EnumDamageTypes.Starvation },
        { 22, EnumDamageTypes.Stun },
        { 23, EnumDamageTypes.Suffocation },
        { 24, EnumDamageTypes.Suicide },
        { 25, EnumDamageTypes.Toxic },
        { 26, EnumDamageTypes.VehicleInside }};
        public static void KillEveryone()
        {
            // kill the entire server, helps you blend in
            foreach (EntityPlayer player in GameManager.Instance.World.Players.list)
            {
                if (player == null && !player.IsAlive())
                    continue; // check if player is killable
                KillPlayer(player);
            }
        }
        public static void KillEveryoneElse()
        {
            // kills everyone but you 
            foreach (EntityPlayer player in Esp.Player.PlayerList)
            {
                if (player == null && !player.IsAlive())
                    continue; // check if player is killable
                KillPlayer(player);
            }
        }
        public static void KillPlayer(EntityPlayer player)
        {
            System.Random rand = new System.Random();
            int randsource = 0;
            int randtype = 0;
            randsource = rand.Next(0, 1);
            randtype = rand.Next(0, 26);
            int randdam = rand.Next(0, 100);
            EnumDamageSource damsource = DamageSourceDict[randsource];
            EnumDamageTypes damtype = DamageTypeDict[randtype];

            // server plugins and admin only check for the concuss damage source, you should randomize the damage source to be different for all different damage sources and types.
            DamageSource source = new DamageSource(damsource, damtype);
            player.DamageEntity(source, player.Health + randdam, false, 1); // do it for their entire health, nothing more nothing less. you could do 1 health at a time to troll.
        }
        public static void StartConstantlyKillPlayer(EntityPlayer player)
        {
            KillList.Add(player);
        }
        public static void StopConstantlyKillPlayer(EntityPlayer player)
        {
            KillList.Remove(player);
        }
        public static void SpoofName(EntityPlayer player)
        {
            Name = player.EntityName;
        }
        public static void SpoofID(EntityPlayer player)
        {
           Entity = player.entityId;
        }
        public static void SpoofStats(EntityPlayer player)
        {
            // set stats to local player from another player's pointer
            Globals.LocalPlayer.Progression.Level = player.Progression.Level;
            Globals.LocalPlayer.Progression.SkillPoints = player.Progression.SkillPoints;
            Globals.LocalPlayer.Progression.ExpToNextLevel = player.Progression.ExpToNextLevel;
            Globals.LocalPlayer.KilledPlayers = player.KilledPlayers;
            Globals.LocalPlayer.KilledZombies = player.KilledZombies;
            EntityAlive alive = Globals.LocalPlayer as EntityAlive;
            EntityAlive alive2 = player as EntityAlive;
            alive.Died = alive2.Died;
            Globals.LocalPlayer.distanceWalked = player.distanceWalked;
            Globals.LocalPlayer.distanceWalked = player.distanceSwam;
            Globals.LocalPlayer.distanceClimbed = player.distanceClimbed;
            Globals.LocalPlayer.totalTimePlayed = player.totalTimePlayed;
            Globals.LocalPlayer.totalItemsCrafted = player.totalItemsCrafted;
        


        }
        #region Movement
        public static void TeleportToPlayer(EntityPlayer player)
        {

            Globals.LocalPlayer.transform.position = new Vector3(player.transform.position.x, player.transform.position.y + 10, player.transform.position.z); // +10 y so they cant see us teleporting to them.
        }
        void Speedhack()
        {
            if (Globals.LocalPlayer == null)
                return;
            if (!Globals.Config.LocalPlayer.Speedhack)
                return;
                if (Input.GetKey(Globals.Config.LocalPlayer.SpeedKey))
                {
                Time.timeScale = Globals.Config.LocalPlayer.SpeedAmount; // set timescale
                }
                else
                {
                    Time.timeScale = 1; // back to default
                }
            

        }
        void Noclip()
        {
            if (Globals.LocalPlayer == null)
                return;
            if (!Globals.Config.LocalPlayer.BtecNoclip)
                return; // is noclip on
            if (!Input.GetKey(Globals.Config.LocalPlayer.NoclipKey))
                return; // is noclip key pressed
            // controls for noclip
            if (Input.GetKey(KeyCode.W))
                Globals.LocalPlayer.transform.position = Globals.LocalPlayer.transform.position + Camera.main.transform.forward * Globals.Config.LocalPlayer.NoclipSpeed;
            if (Input.GetKey(KeyCode.S))
                Globals.LocalPlayer.transform.position = Globals.LocalPlayer.transform.position - Camera.main.transform.forward * Globals.Config.LocalPlayer.NoclipSpeed;
            if (Input.GetKey(KeyCode.A))
                Globals.LocalPlayer.transform.position = Globals.LocalPlayer.transform.position - Camera.main.transform.right * Globals.Config.LocalPlayer.NoclipSpeed;
            if (Input.GetKey(KeyCode.D))
                Globals.LocalPlayer.transform.position = Globals.LocalPlayer.transform.position + Camera.main.transform.right * Globals.Config.LocalPlayer.NoclipSpeed;
            if (Input.GetKey(KeyCode.Space))
                Globals.LocalPlayer.transform.position = Globals.LocalPlayer.transform.position + Camera.main.transform.up * Globals.Config.LocalPlayer.NoclipSpeed;
            if (Input.GetKey(KeyCode.LeftControl))
                Globals.LocalPlayer.transform.position = Globals.LocalPlayer.transform.position - Camera.main.transform.up * Globals.Config.LocalPlayer.NoclipSpeed;
        }
        #endregion
        #region Skills
        // setting the skills for the local player to a set amount
        public static void SetLevel(int level)
        {
            if (Globals.LocalPlayer == null)
                return;
            Globals.LocalPlayer.Progression.Level = level;
        }
        public static void SetKills(int kills)
        {
            if (Globals.LocalPlayer == null)
                return;
            Globals.LocalPlayer.KilledPlayers = kills;
        }
        public static void SetZombieKills(int kills)
        {
            if (Globals.LocalPlayer == null)
                return;
            Globals.LocalPlayer.KilledZombies = kills;
        }
        public static void SetSkillPoints(int points)
        {
            if (Globals.LocalPlayer == null)
                return;
            Globals.LocalPlayer.Progression.SkillPoints = points;
        }
        public static void SetDistanceTraveled(float distance)
        {
            if (Globals.LocalPlayer == null)
                return;
            Globals.LocalPlayer.distanceWalked = distance;
        }
        public static void SetTotalItemsCrafted(int items)
        {
            if (Globals.LocalPlayer == null)
                return;
            Globals.LocalPlayer.totalItemsCrafted = (uint)items;
        }
        public static void SetTotalTimePlayed(int seconds)
        {
            if (Globals.LocalPlayer == null)
                return;
            int hours = (seconds * 60) * 60;
            Globals.LocalPlayer.totalTimePlayed = hours;
        }
        public static void SetDeaths(int deaths)
        {
            if (Globals.LocalPlayer == null)
                return;
            //   GameSparksCollector.IncrementCounter(GameSparksCollector.GSDataKey.PlayerDeathCauses, text, 1, true, GameSparksCollector.GSDataCollection.SessionUpdates);
            EntityAlive alive = Globals.LocalPlayer as EntityAlive;
            alive.Died = deaths;
        }
        #endregion
        #region Properties
        float NextClear = 0;
        public static string Name = Globals.LocalPlayer?.EntityName;
        public static int Entity = 0;
        private bool EntitySet = false;
        public static void ClipboardToString(out string text)
        {
            string systemCopyBuffer = GUIUtility.systemCopyBuffer;
            text = systemCopyBuffer;
        }
        void SetProperties()
        {
            if (Globals.LocalPlayer == null)
                return;
            if (!EntitySet)
            {
                Entity = Globals.LocalPlayer.entityId;
                EntitySet = true; // set default entity id
            }
            if (Globals.Config.LocalPlayer.SpoofID && EntitySet)
                Globals.LocalPlayer.entityId = Entity; // set to random entity id
            if (Globals.Config.LocalPlayer.UnlimitedStamina)
            {
                // set unlimited stamina values
                Globals.LocalPlayer.Stats.Stamina.Value = 100000f;
                Globals.LocalPlayer.Stamina = 100000f;
                Globals.LocalPlayer.AddStamina(100000f);
                Globals.LocalPlayer.classMaxStamina = 100000;
            }
            if (Globals.Config.LocalPlayer.UnlimitedHunger)
            {
                // set hunger
                Globals.LocalPlayer.Stats.Food.Value = 100000f;
                Globals.LocalPlayer.classMaxFood = 100000;
 
            }
            if (Globals.Config.LocalPlayer.UnlimitedThirtst)
            {
                // set thirst values
                Globals.LocalPlayer.Stats.Water.Value = 100000f;
                Globals.LocalPlayer.Water = 100000f;
                Globals.LocalPlayer.classMaxWater = 100000;

            }
            if (Globals.Config.LocalPlayer.InstantHealth)
            {
                // instantly heal to max
                Globals.LocalPlayer.Stats.Health.Value = 10000000f;
                Globals.LocalPlayer.Health = 10000;
                Globals.LocalPlayer.AddHealth(10000000);
                Globals.LocalPlayer.fallDistance = 0;
                Globals.LocalPlayer.ClearStun();
                Globals.LocalPlayer.classMaxHealth = 100000;
                Globals.LocalPlayer.Stats.Health.MaxModifier = 1000000000;

            }
            if (Globals.Config.LocalPlayer.ClearDebuffs)
            {
                RemoveAllNegativeBuffs();
            }
            try
            {
                if (Globals.Config.LocalPlayer.RandomlySpoofName)
                {
                    foreach (EntityPlayer player in Esp.Player.PlayerList)
                        if(Name != player.EntityName)
                        Name = player.EntityName; // keep changing your name so no one can see who you are, could add a slight delay
                }
                if (Globals.Config.LocalPlayer.SpoofName)
                {
                    if(Globals.LocalPlayer.EntityName != Name)
                    Globals.LocalPlayer.SetEntityName(Name); // set the name while logging the original
                }
                
            }
            catch { }
          

        }
        #endregion
        #region Console
        public static void ExecuteCommandFromClipboard()
        {
            if (Globals.LocalPlayer == null)
                return;
            string systemCopyBuffer = GUIUtility.systemCopyBuffer;
            ExecuteConsoleCommand(systemCopyBuffer);
        }
        private static void ExecuteConsoleCommand(string text)
        {
            if (Globals.LocalPlayer == null)
                return;
            SingletonMonoBehaviour<SdtdConsole>.Instance.ExecuteSync($"{text}", null); // sdtd console singleton and execute our commands.
        }
        public static void RemoveAllNegativeBuffs()
        {
            if (GameManager.Instance == null)
                return;
            EntityPlayer primaryplayer = GameManager.Instance.World.GetPrimaryPlayer();
            
            for (int index = 0; index < primaryplayer.Buffs.ActiveBuffs.Count; ++index)
            {
                if (primaryplayer.Buffs.ActiveBuffs[index].BuffClass.DamageType == EnumDamageTypes.None)
                    continue;
                    primaryplayer.Buffs.ActiveBuffs[index].Remove = true;
            }
        }
        public static void GiveItemFromClipboard(int amount)
        {
            string systemCopyBuffer = GUIUtility.systemCopyBuffer;
            string text = $"giveself {systemCopyBuffer} 6 {amount.ToString()} true";
            ExecuteConsoleCommand(text); // bypass hiding items on item list.
        }
        #endregion
        #region World
        void Worlds()
        {
            if (Globals.LocalPlayer == null)
                return;
            try
            {
                if (Globals.Config.LocalPlayer.AllahMode)
                {

                    foreach (EntityPlayer player in Esp.Player.PlayerList)
                        Globals.LocalPlayer.entityId = player.entityId; // spam change our entity id so the server has no idea who we are, prevents the server banning you somehow.
                }
            }
            catch { }
            try
            {
                if (Globals.Config.LocalPlayer.CreativeMenu)
                {
                    if (!GamePrefs.GetBool(EnumGamePrefs.CreativeMenuEnabled))
                        GamePrefs.Set(EnumGamePrefs.CreativeMenuEnabled, true); // set creative mode
                    if (!GameStats.GetBool(EnumGameStats.IsCreativeMenuEnabled))
                        GameStats.Set(EnumGameStats.IsCreativeMenuEnabled, true); 
                }
                if (Globals.Config.LocalPlayer.DebugMenu)
                {
                    // set debug mode
                    if (!GameStats.GetBool(EnumGameStats.IsFlyingEnabled))
                        GameStats.Set(EnumGameStats.IsFlyingEnabled, true);
                    if (!GamePrefs.GetBool(EnumGamePrefs.DebugMenuEnabled))
                        GamePrefs.Set(EnumGamePrefs.DebugMenuEnabled, true);
                    if (!GameStats.GetBool(EnumGameStats.IsPlayerCollisionEnabled))
                        GameStats.Set(EnumGameStats.IsPlayerCollisionEnabled, false); // disable noclip to prevent bans
                }
                if (Globals.Config.LocalPlayer.FarInteract)
                {
                    //https://www.mpgh.net/forum/showthread.php?t=1421801
                    Constants.cDigAndBuildDistance = Globals.Config.LocalPlayer.FarInteractDistance;
                    Constants.cCollectItemDistance = Globals.Config.LocalPlayer.FarInteractDistance; 
            
                    //    Constants.cBuildIntervall = 0.1f;
                }
                if (Globals.Config.LocalPlayer.LandClaim)
                {
                    // turns off land claim durability modifier

                        GameStats.Set(EnumGameStats.LandClaimOnlineDurabilityModifier, 1);
                 
                        GameStats.Set(EnumGameStats.LandClaimOfflineDurabilityModifier, 1);

                }
            }
            catch { }
        }
       

        public static void InstantCraft()
        {
            // allows you to craft instantly and at no cost and without blueprints
            if (Globals.LocalPlayer == null)
                return;
            try
            {
                foreach (Recipe recipe in CraftingManager.GetAllRecipes())
                {
                    CraftingManager.UnlockRecipe(recipe, Globals.LocalPlayer); // loop recipes and unlock them all
                    recipe.ingredients.Clear(); // remove the ingredients from the list
                    recipe.craftingTime = 0.1f; // set crafting time 
                }
            }
            catch (Exception e)
            {
              
            }
        }
        #endregion

    }
}

```

`7DTD/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("7DTD")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("7DTD")]
[assembly: AssemblyCopyright("Copyright ©  2022")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("eaacf9e7-f7ac-42ea-bbed-8cc14a9d8f81")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`Client/Client.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{6bed536d-3883-45d4-bd6c-13591e96380c}</ProjectGuid>
    <RootNamespace>Client</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <IntDir>$(SolutionDir)x64\Client</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IntDir>$(SolutionDir)x64\Client</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IntDir>$(SolutionDir)obj\Client\$(Configuration)\</IntDir>
    <IncludePath>$(SolutionDir)Client\Networking;$(SolutionDir)Client\Util;$(SolutionDir)Client\Security;$(IncludePath)</IncludePath>
    <LibraryPath>C:\Users\dev\Desktop\Vmp;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Networking\TCPClient.cpp" />
    <ClCompile Include="Util\Encryption.cpp" />
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="Util\File.cpp" />
    <ClCompile Include="Util\Hwid.cpp" />
    <ClCompile Include="Util\Screenshot.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Networking\TCPClient.h" />
    <ClInclude Include="Security\LazyImporter.h" />
    <ClInclude Include="Util\Encryption.h" />
    <ClInclude Include="Util\File.h" />
    <ClInclude Include="Util\Hwid.h" />
    <ClInclude Include="Util\Screenshot.h" />
    <ClInclude Include="Security\VMProtectSDK.h" />
    <ClInclude Include="Security\Xorstr.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Client/Client.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Util\Encryption.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Networking\TCPClient.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Util\Hwid.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Util\Screenshot.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Util\File.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Util\Encryption.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Networking\TCPClient.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Security\Xorstr.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Util\Hwid.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Util\Screenshot.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Security\VMProtectSDK.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Util\File.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Security\LazyImporter.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Client/Main.cpp`:

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include <winsock2.h>
#include <ws2tcpip.h>
#include <string>
#include <iostream>
#include <fstream>
#include <sstream>
#include <filesystem>
#include <cstdio>
#include <windows.h>
#include <thread>
#include <cstdlib>

#include "hwid.h"
#include "Screenshot.h"
#include "TCPClient.h"
#include "Xorstr.h"
#include "File.h"
#include "VMProtectSDK.h"
#include "LazyImporter.h"
// import libraries for gdi and winsockets
#pragma comment(lib, "gdiplus.lib")
#pragma comment(lib, "ws2_32.lib")
#pragma comment(lib,"WS2_32")

/*
TODO
fix server from trying to find a subscription when none are valid
Organise everything into methods
*/


bool LoggedIn = false;
std::string LoginText;
extern ByteArray screenshot;
double LoaderVer = 1.1;
std::string Version = std::to_string(LoaderVer);
std::string Versionstr;
#define BUFFER 8192
SOCKET GlobalSocket;

Client* TCPClient = new Client;
void Heartbeat()
{
	VMProtectBeginUltra(LIT("Heartbeat"));
	if (!TCPClient->SendingBytes)
	{ // tell the server we are alive every minute, this will add a 2 minute timer on the server to keep the session open. 
		LI_FN(Sleep).in(LI_MODULE("Kernel32.dll").cached())(1000);
		TCPClient->SendText(LIT("Ping"));
		LI_FN(Sleep).in(LI_MODULE("Kernel32.dll").cached())(60000);
	}
	VMProtectEnd();
}
void Disconnect()
{
	VMProtectBeginUltra(LIT("Disconnect"));
	LI_FN(Sleep).in(LI_MODULE("Kernel32.dll").cached())(1000); // make sure packets don't mix up
	TCPClient->SendText(LIT("Disconnected"));
	LI_FN(closesocket).in(LI_MODULE("Ws2_32.dll").cached())(GlobalSocket);
	LI_FN(WSACleanup).in(LI_MODULE("Ws2_32.dll").cached())();
	exit(1);
	VMProtectEnd();
}
std::string ActivateProduct(std::string Product)
{

}
void Register(std::string Username, std::string Password)
{
	VMProtectBeginUltra(LIT("Register"));

	TCPClient->SendText(LIT("Register|") + Username + LIT("|") + Password + LIT("|") + ReadableHwid() + LIT("|") + Hwid());

	while (true)
	{
		std::string Message = TCPClient->ReceiveText();
		if (Message == LIT(""))
			continue;
		if (Message == LIT("Successful Login"))
		{
			LoggedIn = true;
			LoginText = Message;
			break;
		}
		LoginText = Message;
		std::cout << Message << LIT("\n");
		break;

	}
	VMProtectEnd();
}
void Login(std::string Username, std::string Password)
{	
	
	VMProtectBeginUltra(LIT("Login"));
	TCPClient->SendText(LIT("Login|") + Username + LIT("|") + Password + LIT("|") + ReadableHwid() + LIT("|") + Hwid()); // the order is kinda random to be somewhat confusing to people i guess
	while (true)
	{
		std::string Message = TCPClient->ReceiveText();
		if (Message == LIT(""))
			continue;
		if (Message == LIT("Successful Login"))
		{
			LoggedIn = true;
			LoginText = Message;
			break;
		}
		LoginText = Message;
		std::cout << Message << LIT("\n");
		break;

	}
	VMProtectEnd();
	
}
std::string exec(const char* cmd);
void VersionCheck()
{
	VMProtectBeginUltra(LIT("VersionCheck"));
	TCPClient->SendText(LIT("Version") + Version);
	while (true)
	{
		std::string Message = TCPClient->ReceiveText();
		if (Message == LIT(""))
			continue;
		if (Message == LIT("Valid Version"))
		{
			Versionstr = Message;
			break;
		}

		Versionstr = Message;
		break;


	}
	if (Versionstr != LIT("Valid Version"))
	{

		File versionfile;
		versionfile.TCPClient = TCPClient;
		TCPClient->SendText(LIT("Version1"));
		versionfile.GetFile();


		ByteArray file = versionfile.Array;

		try { std::filesystem::remove(LIT("OldClient.exe")); }
		catch (std::exception) {}
		try { std::filesystem::rename(LIT("Client.exe"), LIT("OldClient.exe")); }
		catch (std::exception) {}

		

		std::ofstream fout(LIT("Client.exe"), std::ios::binary);
		fout.write((char*)file.data(), file.size());
		std::cout << LIT("Client Updated\n");
		// add auto restarting here
		Sleep(10000);
		Disconnect();
		
	}
	VMProtectEnd();
}

HANDLE fileHandle;
void ReadString(char* output) {
	ULONG read = 0;
	int index = 0;
	do {
		ReadFile(fileHandle, output + index++, 1, &read, NULL);
	} while (read > 0 && *(output + index - 1) != 0);
}


void main()
{
	int result1 = std::atexit(Disconnect); // calls this when the application closes
	std::at_quick_exit(Disconnect);
	if (result1 != 0)
	{
		exit(1);
	}
	try { std::filesystem::remove(LIT("OldClient.exe")); }
	catch (std::exception) {}
	VMProtectBeginUltra(LIT("Main"));

	std::string ipAddress = LIT("217.112.80.148");
	int port = 54000;
	

	WSAData data;
	WORD ver = MAKEWORD(2, 2);
	int wsResult = LI_FN(WSAStartup).in(LI_MODULE("Ws2_32.dll").cached())(ver, &data);
	if (wsResult != 0)
	{
		return;
	}

	SOCKET sock = LI_FN(socket).in(LI_MODULE("Ws2_32.dll").cached())(AF_INET, SOCK_STREAM, 0);
	GlobalSocket = sock;
	if (sock == INVALID_SOCKET)
	{
		LI_FN(WSACleanup).in(LI_MODULE("Ws2_32.dll").cached())();
		return;
	}

	sockaddr_in hint;
	hint.sin_family = AF_INET;
	hint.sin_port = htons(port);
	LI_FN(inet_pton).in(LI_MODULE("Ws2_32.dll").cached())(AF_INET, ipAddress.c_str(), &hint.sin_addr);

	int connResult = connect(sock, (sockaddr*)&hint, sizeof(hint));
	if (connResult == SOCKET_ERROR)
	{
		std::cerr << LIT("Can't connect to server") << std::endl;
		LI_FN(closesocket).in(LI_MODULE("Ws2_32.dll").cached())(sock);
		LI_FN(WSACleanup).in(LI_MODULE("Ws2_32.dll").cached())();
		return;
	}
	std::thread thread(Heartbeat);

	// create our client class.
	TCPClient->Socket = sock;
	Encryption Encryption;
	Encryption.Start();
	TCPClient->Encryption = Encryption;
	TCPClient->GetEncryptionKey();

	std::string Input;
	std::string Username;
	std::string Password;
	std::string DataText;
	std::string Products;
	VersionCheck();
	if (Versionstr != LIT("Valid Version"))
	{
		Disconnect();
		return;
	}

	std::cout << LIT("1) Login\n");
	std::cout << LIT("2) Register\n");
	std::cin >> Input;

	if (Input != LIT("1") && Input != LIT("2"))
	{
		Disconnect();
		return;
	}
	std::cout << std::string(100, '\n');
	if (Input == LIT("1"))
	{
		std::cout << LIT("Username: ");
		std::cin >> Input;
		Username = Input;
		std::cout << LIT("Password: ");
		std::cin >> Input;
		Password = Input;
		Login(Username, Password);
		if (!LoggedIn)
		{
			Disconnect();
			return;
		}
		Screenshot();
	
		
		// it sends get products but it isn't recieved
		TCPClient->SendText(LIT("GetProducts"));
		while (true)
		{
			std::string Message = TCPClient->ReceiveText();
			if (Message == LIT(""))
				continue;
			if (Message == LoginText)
				continue;
			Products = Message;
			break;


		}
		TCPClient->SendText(LIT("SendingMuchNeededInformation")); // tell the server that we are sending a screenshot so it can call getfile
		File file;
		file.TCPClient = TCPClient;
		file.Array = screenshot;
		file.SendFile();

		if (Products == LIT("No Active Products"))
			std::cout << Products << LIT("\n");
		else
		{
			std::istringstream input;
			std::string str;
			input.str(Products);
			while (std::getline(input, str))
			{
				if (str == LIT(""))
					continue;
				std::string character = LIT("-");
				int specialchar = 0;
				int specialcharpos[200];
				for (std::string::size_type i = 0; i < str.size(); i++)
				{
					if (str[i] == character[0])
					{
						specialcharpos[specialchar] = i;
						specialchar++;
					}
				}
				std::string ProductName = str.substr(0, specialcharpos[0]);
				std::string ProductTime = str.substr(specialcharpos[1] + 1, specialcharpos[1]);
				std::cout << ProductName << LIT(" ") << ProductTime << LIT(" Days Left") << LIT("\n");
			}
		}

		std::cout << LIT("1) Activate Key\n");
		if (Products != LIT("No Active Products"))
		{
			std::cout << LIT("-Make Sure Game Is Closed Before Loading Cheat.\n");
			std::cout << LIT("2) Load Cheat\n");
		}

		std::cin >> Input;
		if (Input != LIT("1") && Input != LIT("2"))
		{
			Disconnect();
			return;
		}
		if (Input == LIT("1"))
		{
			std::cout << LIT("Input Key:\n");
			std::cin >> Input;
			TCPClient->SendText(LIT("Redeem") + Input);
			while (true)
			{
				std::string Message = TCPClient->ReceiveText();
				if (Message == LIT(""))
					continue;
				std::cout << Message << LIT("\n");
				break;
			}
			Disconnect();
			return;
		}
		if (Products != LIT("No Active Products"))
		{
			if (Input == LIT("2"))
			{
				char value[255];
				DWORD BufferSize = BUFFER;
				RegGetValue(HKEY_LOCAL_MACHINE, LIT(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Steam App 251570"), LIT(L"InstallLocation"), RRF_RT_ANY, NULL, (PVOID)&value, &BufferSize);
				std::string str;
				int lasti;

				// so basically we need to skip a value since after each actual byte in the char array it has a buffer that doesn't show in the string but it is still there in memory. this small thing took 20 hours of my time to find. 


			
					for (int i = 0; i < BufferSize - 2; i += 2)
					{
						str = str + value[i];
					}
				// This is connecting to our inp server to connect to the cheat, the cheat wont load unless we connect on the loader.
				try
				{
					std::string remove = str + LIT("\\7DaysToDie_Data\\Managed\\0Harmony.dll");
					std::remove(remove.c_str());
				}
				catch (const std::exception&){}
				
				TCPClient->SendText(LIT("SendCheat"));
				File cheat;
				cheat.TCPClient = TCPClient;
				cheat.GetFile();

				std::vector<BYTE> data1(cheat.Array.begin(), cheat.Array.end());
				std::ofstream fout(str + LIT("\\0Harmony.dll"), std::ios::out|std::ios::binary);
				fout.write((char*)data1.data(), data1.size());
				fout.close();


				Sleep(1000);
				TCPClient->SendText(LIT("SendOriginal"));
				File original;
				original.TCPClient = TCPClient;
				original.GetFile();

				HANDLE hConsole = LI_FN(GetStdHandle).in(LI_MODULE("Kernel32.dll").cached())(STD_OUTPUT_HANDLE);
				LI_FN(SetConsoleTextAttribute).in(LI_MODULE("kernel32.dll").cached())(hConsole, 2); // Green
				std::cout << LIT("Now Open Your Game.\n");
				LI_FN(SetConsoleTextAttribute).in(LI_MODULE("kernel32.dll").cached())(hConsole, 4);// Red
				std::cout << LIT("After You Open The Game You Will Notice It Not Responding Or You Have A White Or Black Screen.\n");
				LI_FN(SetConsoleTextAttribute).in(LI_MODULE("kernel32.dll").cached())(hConsole, 2); // Green
				std::cout << LIT("When You See This Type 1 Into The Console And Click Enter To Continue.\n");


				std::cin >> Input;
				if(Input == LIT("1"))
				{
				
				
						fileHandle = CreateFileW(LIT(L"\\\\.\\pipe\\my-7dtd-pipe"), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

						// read from pipe server
						char* buffer = new char[100];
					memset(buffer, 0, 100);
					ReadString(buffer);

					
					try { std::filesystem::remove(str + LIT("\\0Harmony.dll")); } // incase the cheat wasn't loaded successfully by a moronic user we delete it
					catch(std::exception ex){}


					std::vector<BYTE> data2(original.Array.begin(), original.Array.end());
					std::ofstream fout1(str + LIT("\\7DaysToDie_Data\\Managed\\0Harmony.dll"), std::ios::binary);
					fout1.write((char*)data2.data(), data2.size());
					fout1.close();

					LI_FN(SetConsoleTextAttribute).in(LI_MODULE("kernel32.dll").cached())(hConsole, 2); // Green
					std::cout << LIT("Cheat Loaded, Close This Window.\n");

					Disconnect();
					return;
				}
				std::cout << LIT("Failed, Please Try Again.\n");
				Disconnect();
				return;
			}
		}

	}

	if (Input == LIT("2"))
	{

		std::cout << LIT("Username: ");
		std::cin >> Input;
		Username = Input;
		std::cout << LIT("Password: ");
		std::cin >> Input;
		Password = Input;
		Register(Username, Password);
		Disconnect();
		return;
	}

	// just prevents it from closing by itself for debug reasons
	while (true)
	{

	}

	Disconnect();
	VMProtectEnd();
}
```

`Client/Networking/TCPClient.cpp`:

```cpp
#include "TCPClient.h"
#include "iostream"
#include <chrono>
#include <thread>
#include "lazyimporter.h"

constexpr int BufferSize = 4096;


void Client::GetEncryptionKey()
{
	ByteArray EncryptionKey = Client::ReceiveRawBytes();

	Client::EncryptionKey = EncryptionKey;
}
ByteArray Client::EKey()
{
	return Client::EncryptionKey;
}
int Client::SendRawBytes(ByteArray& Bytes)
{
	int32_t Result = LI_FN( send).in(LI_MODULE("Ws2_32.dll").cached())(Client::Socket, (char*)Bytes.data(), (int)Bytes.size(), 0);
	return Result;
}
ByteArray Client::ReceiveRawBytes()
{
	ByteArray	ReceivedBytes;
	uint8_t		RecvBuffer[BufferSize];

	while (true)
	{
		int32_t Received = LI_FN(recv).in(LI_MODULE("Ws2_32.dll").cached())(Client::Socket, (char*)RecvBuffer, BufferSize, 0);

		if (Received < 0)
			break;

		for (int n = 0; n < Received; ++n)
		{
			ReceivedBytes.push_back(RecvBuffer[n]);
		}

		if (Received <= BufferSize)
			break;

	}

	return ReceivedBytes;
}
void Client::SendBytes(ByteArray& Bytes)
{
	ByteArray Encrypted = Encryption.Encrypt(Bytes, Client::EKey());

	SendRawBytes(Encrypted);
}
int Client::_SendBytes(ByteArray& Bytes)
{
	ByteArray Encrypted = Encryption.Encrypt(Bytes, Client::EKey());

	
	return SendRawBytes(Encrypted);
}
ByteArray Client::ReceiveBytes()
{
	ByteArray ReceivedBytes = ReceiveRawBytes();
	ByteArray Decrypted = Encryption.Decrypt(ReceivedBytes, Client::EKey());

	return Decrypted;
}
void Client::SendText(std::string Text)
{
	// we set sending bytes on text because we know it isn't going to be a file
	// doing this to rawbytes or sendbytes would mean when we send a file the heartbeat would corrupt screenshots etc.
	Client::SendingBytes = true;
	std::string Send = Text;
	ByteArray plaintext(Send.begin(), Send.end());
	Client::SendBytes(plaintext);
	Client::SendingBytes = false;

}

std::string Client::ReceiveText()
{
	ByteArray rray = Client::ReceiveBytes();

	std::string str(rray.begin(), rray.end());

	return str;
}


```

`Client/Networking/TCPClient.h`:

```h

#pragma once
#include <winsock2.h>
#include <ws2tcpip.h>
#include <string>
#include "Encryption.h"

class Client
{

public:
	SOCKET Socket;
	std::string IpAddress;
	Encryption Encryption;
	bool SendingBytes = false;

	// Gets encryption key from server
	void GetEncryptionKey();
	// Gets private encryption key
	ByteArray EKey();

	int SendRawBytes(ByteArray& Bytes);
	void SendText(std::string Text);
	void SendBytes(ByteArray& Bytes);
	int _SendBytes(ByteArray& Bytes);
	ByteArray ReceiveRawBytes();
	ByteArray ReceiveBytes();
	std::string ReceiveText();
private:
	std::string Username;
	std::string Password;
	ByteArray EncryptionKey;

};

```

`Client/Security/LazyImporter.h`:

```h
/*
 * Copyright 2018-2022 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

 // === FAQ === documentation is available at https://github.com/JustasMasiulis/lazy_importer
 // * Code doesn't compile with errors about pointer conversion:
 //  - Try using `nullptr` instead of `NULL` or call `get()` instead of using the overloaded operator()
 // * Lazy importer can't find the function I want:
 //   - Double check that the module in which it's located in is actually loaded
 //   - Try #define LAZY_IMPORTER_CASE_INSENSITIVE
 //     This will start using case insensitive comparison globally
 //   - Try #define LAZY_IMPORTER_RESOLVE_FORWARDED_EXPORTS
 //     This will enable forwarded export resolution globally instead of needing explicit `forwarded()` calls

#ifndef LAZY_IMPORTER_HPP
#define LAZY_IMPORTER_HPP


#define LI_FN(name) ::li::detail::lazy_function<LAZY_IMPORTER_KHASH(#name), decltype(&name)>()

#define LI_FN_DEF(name) ::li::detail::lazy_function<LAZY_IMPORTER_KHASH(#name), name>()

#define LI_MODULE(name) ::li::detail::lazy_module<LAZY_IMPORTER_KHASH(name)>()

#ifndef LAZY_IMPORTER_CPP_FORWARD
#ifdef LAZY_IMPORTER_NO_CPP_FORWARD
#define LAZY_IMPORTER_CPP_FORWARD(t, v) v
#else
#include <utility>
#define LAZY_IMPORTER_CPP_FORWARD(t, v) std::forward<t>( v )
#endif
#endif

#include <intrin.h>

#ifndef LAZY_IMPORTER_NO_FORCEINLINE
#if defined(_MSC_VER)
#define LAZY_IMPORTER_FORCEINLINE __forceinline
#elif defined(__GNUC__) && __GNUC__ > 3
#define LAZY_IMPORTER_FORCEINLINE inline __attribute__((__always_inline__))
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif


#ifdef LAZY_IMPORTER_CASE_INSENSITIVE
#define LAZY_IMPORTER_CASE_SENSITIVITY false
#else
#define LAZY_IMPORTER_CASE_SENSITIVITY true
#endif

#define LAZY_IMPORTER_STRINGIZE(x) #x
#define LAZY_IMPORTER_STRINGIZE_EXPAND(x) LAZY_IMPORTER_STRINGIZE(x)

#define LAZY_IMPORTER_KHASH(str) ::li::detail::khash(str, \
    ::li::detail::khash_impl( __TIME__ __DATE__ LAZY_IMPORTER_STRINGIZE_EXPAND(__LINE__) LAZY_IMPORTER_STRINGIZE_EXPAND(__COUNTER__), 2166136261 ))

namespace li {
    namespace detail {

        namespace win {

            struct LIST_ENTRY_T {
                const char* Flink;
                const char* Blink;
            };

            struct UNICODE_STRING_T {
                unsigned short Length;
                unsigned short MaximumLength;
                wchar_t* Buffer;
            };

            struct PEB_LDR_DATA_T {
                unsigned long Length;
                unsigned long Initialized;
                const char* SsHandle;
                LIST_ENTRY_T  InLoadOrderModuleList;
            };

            struct PEB_T {
                unsigned char   Reserved1[2];
                unsigned char   BeingDebugged;
                unsigned char   Reserved2[1];
                const char* Reserved3[2];
                PEB_LDR_DATA_T* Ldr;
            };

            struct LDR_DATA_TABLE_ENTRY_T {
                LIST_ENTRY_T InLoadOrderLinks;
                LIST_ENTRY_T InMemoryOrderLinks;
                LIST_ENTRY_T InInitializationOrderLinks;
                const char* DllBase;
                const char* EntryPoint;
                union {
                    unsigned long SizeOfImage;
                    const char* _dummy;
                };
                UNICODE_STRING_T FullDllName;
                UNICODE_STRING_T BaseDllName;

                LAZY_IMPORTER_FORCEINLINE const LDR_DATA_TABLE_ENTRY_T*
                    load_order_next() const noexcept
                {
                    return reinterpret_cast<const LDR_DATA_TABLE_ENTRY_T*>(
                        InLoadOrderLinks.Flink);
                }
            };

            struct IMAGE_DOS_HEADER { // DOS .EXE header
                unsigned short e_magic; // Magic number
                unsigned short e_cblp; // Bytes on last page of file
                unsigned short e_cp; // Pages in file
                unsigned short e_crlc; // Relocations
                unsigned short e_cparhdr; // Size of header in paragraphs
                unsigned short e_minalloc; // Minimum extra paragraphs needed
                unsigned short e_maxalloc; // Maximum extra paragraphs needed
                unsigned short e_ss; // Initial (relative) SS value
                unsigned short e_sp; // Initial SP value
                unsigned short e_csum; // Checksum
                unsigned short e_ip; // Initial IP value
                unsigned short e_cs; // Initial (relative) CS value
                unsigned short e_lfarlc; // File address of relocation table
                unsigned short e_ovno; // Overlay number
                unsigned short e_res[4]; // Reserved words
                unsigned short e_oemid; // OEM identifier (for e_oeminfo)
                unsigned short e_oeminfo; // OEM information; e_oemid specific
                unsigned short e_res2[10]; // Reserved words
                long           e_lfanew; // File address of new exe header
            };

            struct IMAGE_FILE_HEADER {
                unsigned short Machine;
                unsigned short NumberOfSections;
                unsigned long  TimeDateStamp;
                unsigned long  PointerToSymbolTable;
                unsigned long  NumberOfSymbols;
                unsigned short SizeOfOptionalHeader;
                unsigned short Characteristics;
            };

            struct IMAGE_EXPORT_DIRECTORY {
                unsigned long  Characteristics;
                unsigned long  TimeDateStamp;
                unsigned short MajorVersion;
                unsigned short MinorVersion;
                unsigned long  Name;
                unsigned long  Base;
                unsigned long  NumberOfFunctions;
                unsigned long  NumberOfNames;
                unsigned long  AddressOfFunctions; // RVA from base of image
                unsigned long  AddressOfNames; // RVA from base of image
                unsigned long  AddressOfNameOrdinals; // RVA from base of image
            };

            struct IMAGE_DATA_DIRECTORY {
                unsigned long VirtualAddress;
                unsigned long Size;
            };

            struct IMAGE_OPTIONAL_HEADER64 {
                unsigned short       Magic;
                unsigned char        MajorLinkerVersion;
                unsigned char        MinorLinkerVersion;
                unsigned long        SizeOfCode;
                unsigned long        SizeOfInitializedData;
                unsigned long        SizeOfUninitializedData;
                unsigned long        AddressOfEntryPoint;
                unsigned long        BaseOfCode;
                unsigned long long   ImageBase;
                unsigned long        SectionAlignment;
                unsigned long        FileAlignment;
                unsigned short       MajorOperatingSystemVersion;
                unsigned short       MinorOperatingSystemVersion;
                unsigned short       MajorImageVersion;
                unsigned short       MinorImageVersion;
                unsigned short       MajorSubsystemVersion;
                unsigned short       MinorSubsystemVersion;
                unsigned long        Win32VersionValue;
                unsigned long        SizeOfImage;
                unsigned long        SizeOfHeaders;
                unsigned long        CheckSum;
                unsigned short       Subsystem;
                unsigned short       DllCharacteristics;
                unsigned long long   SizeOfStackReserve;
                unsigned long long   SizeOfStackCommit;
                unsigned long long   SizeOfHeapReserve;
                unsigned long long   SizeOfHeapCommit;
                unsigned long        LoaderFlags;
                unsigned long        NumberOfRvaAndSizes;
                IMAGE_DATA_DIRECTORY DataDirectory[16];
            };

            struct IMAGE_OPTIONAL_HEADER32 {
                unsigned short       Magic;
                unsigned char        MajorLinkerVersion;
                unsigned char        MinorLinkerVersion;
                unsigned long        SizeOfCode;
                unsigned long        SizeOfInitializedData;
                unsigned long        SizeOfUninitializedData;
                unsigned long        AddressOfEntryPoint;
                unsigned long        BaseOfCode;
                unsigned long        BaseOfData;
                unsigned long        ImageBase;
                unsigned long        SectionAlignment;
                unsigned long        FileAlignment;
                unsigned short       MajorOperatingSystemVersion;
                unsigned short       MinorOperatingSystemVersion;
                unsigned short       MajorImageVersion;
                unsigned short       MinorImageVersion;
                unsigned short       MajorSubsystemVersion;
                unsigned short       MinorSubsystemVersion;
                unsigned long        Win32VersionValue;
                unsigned long        SizeOfImage;
                unsigned long        SizeOfHeaders;
                unsigned long        CheckSum;
                unsigned short       Subsystem;
                unsigned short       DllCharacteristics;
                unsigned long        SizeOfStackReserve;
                unsigned long        SizeOfStackCommit;
                unsigned long        SizeOfHeapReserve;
                unsigned long        SizeOfHeapCommit;
                unsigned long        LoaderFlags;
                unsigned long        NumberOfRvaAndSizes;
                IMAGE_DATA_DIRECTORY DataDirectory[16];
            };

            struct IMAGE_NT_HEADERS {
                unsigned long     Signature;
                IMAGE_FILE_HEADER FileHeader;
#ifdef _WIN64
                IMAGE_OPTIONAL_HEADER64 OptionalHeader;
#else
                IMAGE_OPTIONAL_HEADER32 OptionalHeader;
#endif
            };

        } // namespace win

        struct forwarded_hashes {
            unsigned module_hash;
            unsigned function_hash;
        };

        // 64 bit integer where 32 bits are used for the hash offset
        // and remaining 32 bits are used for the hash computed using it
        using offset_hash_pair = unsigned long long;

        LAZY_IMPORTER_FORCEINLINE constexpr unsigned get_hash(offset_hash_pair pair) noexcept { return (pair & 0xFFFFFFFF); }

        LAZY_IMPORTER_FORCEINLINE constexpr unsigned get_offset(offset_hash_pair pair) noexcept { return (pair >> 32); }

        template<bool CaseSensitive = LAZY_IMPORTER_CASE_SENSITIVITY>
        LAZY_IMPORTER_FORCEINLINE constexpr unsigned hash_single(unsigned value, char c) noexcept
        {
            return static_cast<unsigned int>(
                (value ^ ((CaseSensitive && c >= 'A' && c <= 'Z') ? (c | (1 << 5)) : c)) *
                static_cast<unsigned long long>(16777619));
        }

        LAZY_IMPORTER_FORCEINLINE constexpr unsigned
            khash_impl(const char* str, unsigned value) noexcept
        {
            return (*str ? khash_impl(str + 1, hash_single(value, *str)) : value);
        }

        LAZY_IMPORTER_FORCEINLINE constexpr offset_hash_pair khash(
            const char* str, unsigned offset) noexcept
        {
            return ((offset_hash_pair{ offset } << 32) | khash_impl(str, offset));
        }

        template<class CharT = char>
        LAZY_IMPORTER_FORCEINLINE unsigned hash(const CharT* str, unsigned offset) noexcept
        {
            unsigned value = offset;

            for (;;) {
                char c = *str++;
                if (!c)
                    return value;
                value = hash_single(value, c);
            }
        }

        LAZY_IMPORTER_FORCEINLINE unsigned hash(
            const win::UNICODE_STRING_T& str, unsigned offset) noexcept
        {
            auto       first = str.Buffer;
            const auto last = first + (str.Length / sizeof(wchar_t));
            auto       value = offset;
            for (; first != last; ++first)
                value = hash_single(value, static_cast<char>(*first));

            return value;
        }

        LAZY_IMPORTER_FORCEINLINE forwarded_hashes hash_forwarded(
            const char* str, unsigned offset) noexcept
        {
            forwarded_hashes res{ offset, offset };

            for (; *str != '.'; ++str)
                res.module_hash = hash_single<true>(res.module_hash, *str);

            ++str;

            for (; *str; ++str)
                res.function_hash = hash_single(res.function_hash, *str);

            return res;
        }

        // some helper functions
        LAZY_IMPORTER_FORCEINLINE const win::PEB_T* peb() noexcept
        {
#if defined(_M_X64) || defined(__amd64__)
            return reinterpret_cast<const win::PEB_T*>(__readgsqword(0x60));
#elif defined(_M_IX86) || defined(__i386__)
            return reinterpret_cast<const win::PEB_T*>(__readfsdword(0x30));
#elif defined(_M_ARM) || defined(__arm__)
            return *reinterpret_cast<const win::PEB_T**>(_MoveFromCoprocessor(15, 0, 13, 0, 2) + 0x30);
#elif defined(_M_ARM64) || defined(__aarch64__)
            return *reinterpret_cast<const win::PEB_T**>(__getReg(18) + 0x60);
#elif defined(_M_IA64) || defined(__ia64__)
            return *reinterpret_cast<const win::PEB_T**>(static_cast<char*>(_rdteb()) + 0x60);
#else
#error Unsupported platform. Open an issue and I'll probably add support.
#endif
        }

        LAZY_IMPORTER_FORCEINLINE const win::PEB_LDR_DATA_T* ldr()
        {
            return reinterpret_cast<const win::PEB_LDR_DATA_T*>(peb()->Ldr);
        }

        LAZY_IMPORTER_FORCEINLINE const win::IMAGE_NT_HEADERS* nt_headers(
            const char* base) noexcept
        {
            return reinterpret_cast<const win::IMAGE_NT_HEADERS*>(
                base + reinterpret_cast<const win::IMAGE_DOS_HEADER*>(base)->e_lfanew);
        }

        LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* image_export_dir(
            const char* base) noexcept
        {
            return reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
                base + nt_headers(base)->OptionalHeader.DataDirectory->VirtualAddress);
        }

        LAZY_IMPORTER_FORCEINLINE const win::LDR_DATA_TABLE_ENTRY_T* ldr_data_entry() noexcept
        {
            return reinterpret_cast<const win::LDR_DATA_TABLE_ENTRY_T*>(
                ldr()->InLoadOrderModuleList.Flink);
        }

        struct exports_directory {
            const char* _base;
            const win::IMAGE_EXPORT_DIRECTORY* _ied;
            unsigned long                      _ied_size;

        public:
            using size_type = unsigned long;

            LAZY_IMPORTER_FORCEINLINE
                exports_directory(const char* base) noexcept : _base(base)
            {
                const auto ied_data_dir = nt_headers(base)->OptionalHeader.DataDirectory[0];
                _ied = reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
                    base + ied_data_dir.VirtualAddress);
                _ied_size = ied_data_dir.Size;
            }

            LAZY_IMPORTER_FORCEINLINE explicit operator bool() const noexcept
            {
                return reinterpret_cast<const char*>(_ied) != _base;
            }

            LAZY_IMPORTER_FORCEINLINE size_type size() const noexcept
            {
                return _ied->NumberOfNames;
            }

            LAZY_IMPORTER_FORCEINLINE const char* base() const noexcept { return _base; }
            LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* ied() const noexcept
            {
                return _ied;
            }

            LAZY_IMPORTER_FORCEINLINE const char* name(size_type index) const noexcept
            {
                return reinterpret_cast<const char*>(
                    _base + reinterpret_cast<const unsigned long*>(
                        _base + _ied->AddressOfNames)[index]);
            }

            LAZY_IMPORTER_FORCEINLINE const char* address(size_type index) const noexcept
            {
                const auto* const rva_table =
                    reinterpret_cast<const unsigned long*>(_base + _ied->AddressOfFunctions);

                const auto* const ord_table = reinterpret_cast<const unsigned short*>(
                    _base + _ied->AddressOfNameOrdinals);

                return _base + rva_table[ord_table[index]];
            }

            LAZY_IMPORTER_FORCEINLINE bool is_forwarded(
                const char* export_address) const noexcept
            {
                const auto ui_ied = reinterpret_cast<const char*>(_ied);
                return (export_address > ui_ied && export_address < ui_ied + _ied_size);
            }
        };

        struct safe_module_enumerator {
            using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T;
            value_type* value;
            value_type* head;

            LAZY_IMPORTER_FORCEINLINE safe_module_enumerator() noexcept
                : safe_module_enumerator(ldr_data_entry())
            {}

            LAZY_IMPORTER_FORCEINLINE
                safe_module_enumerator(const detail::win::LDR_DATA_TABLE_ENTRY_T* ldr) noexcept
                : value(ldr->load_order_next()), head(value)
            {}

            LAZY_IMPORTER_FORCEINLINE void reset() noexcept
            {
                value = head->load_order_next();
            }

            LAZY_IMPORTER_FORCEINLINE bool next() noexcept
            {
                value = value->load_order_next();

                return value != head && value->DllBase;
            }
        };

        struct unsafe_module_enumerator {
            using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T*;
            value_type value;

            LAZY_IMPORTER_FORCEINLINE unsafe_module_enumerator() noexcept
                : value(ldr_data_entry())
            {}

            LAZY_IMPORTER_FORCEINLINE void reset() noexcept { value = ldr_data_entry(); }

            LAZY_IMPORTER_FORCEINLINE bool next() noexcept
            {
                value = value->load_order_next();
                return true;
            }
        };

        // provides the cached functions which use Derive classes methods
        template<class Derived, class DefaultType = void*>
        class lazy_base {
        protected:
            // This function is needed because every templated function
            // with different args has its own static buffer
            LAZY_IMPORTER_FORCEINLINE static void*& _cache() noexcept
            {
                static void* value = nullptr;
                return value;
            }

        public:
            template<class T = DefaultType>
            LAZY_IMPORTER_FORCEINLINE static T safe() noexcept
            {
                return Derived::template get<T, safe_module_enumerator>();
            }

            template<class T = DefaultType, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static T cached() noexcept
            {
                auto& cached = _cache();
                if (!cached)
                    cached = Derived::template get<void*, Enum>();

                return (T)(cached);
            }

            template<class T = DefaultType>
            LAZY_IMPORTER_FORCEINLINE static T safe_cached() noexcept
            {
                return cached<T, safe_module_enumerator>();
            }
        };

        template<offset_hash_pair OHP>
        struct lazy_module : lazy_base<lazy_module<OHP>> {
            template<class T = void*, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static T get() noexcept
            {
                Enum e;
                do {
                    if (hash(e.value->BaseDllName, get_offset(OHP)) == get_hash(OHP))
                        return (T)(e.value->DllBase);
                } while (e.next());
                return {};
            }

            template<class T = void*, class Ldr>
            LAZY_IMPORTER_FORCEINLINE static T in(Ldr ldr) noexcept
            {
                safe_module_enumerator e((const detail::win::LDR_DATA_TABLE_ENTRY_T*)(ldr));
                do {
                    if (hash(e.value->BaseDllName, get_offset(OHP)) == get_hash(OHP))
                        return (T)(e.value->DllBase);
                } while (e.next());
                return {};
            }

            template<class T = void*, class Ldr>
            LAZY_IMPORTER_FORCEINLINE static T in_cached(Ldr ldr) noexcept
            {
                auto& cached = lazy_base<lazy_module<OHP>>::_cache();
                if (!cached)
                    cached = in(ldr);

                return (T)(cached);
            }
        };

        template<offset_hash_pair OHP, class T>
        struct lazy_function : lazy_base<lazy_function<OHP, T>, T> {
            using base_type = lazy_base<lazy_function<OHP, T>, T>;

            template<class... Args>
            LAZY_IMPORTER_FORCEINLINE decltype(auto) operator()(Args&&... args) const
            {
#ifndef LAZY_IMPORTER_CACHE_OPERATOR_PARENS
                return get()(LAZY_IMPORTER_CPP_FORWARD(Args, args)...);
#else
                return this->cached()(LAZY_IMPORTER_CPP_FORWARD(Args, args)...);
#endif
            }

            template<class F = T, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static F get() noexcept
            {
                // for backwards compatability.
                // Before 2.0 it was only possible to resolve forwarded exports when
                // this macro was enabled
#ifdef LAZY_IMPORTER_RESOLVE_FORWARDED_EXPORTS
                return forwarded<F, Enum>();
#else

                Enum e;

                do {
#ifdef LAZY_IMPORTER_HARDENED_MODULE_CHECKS
                    if (!e.value->DllBase || !e.value->FullDllName.Length)
                        continue;
#endif

                    const exports_directory exports(e.value->DllBase);

                    if (exports) {
                        auto export_index = exports.size();
                        while (export_index--)
                            if (hash(exports.name(export_index), get_offset(OHP)) == get_hash(OHP))
                                return (F)(exports.address(export_index));
                    }
                } while (e.next());
                return {};
#endif
            }

            template<class F = T, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static F forwarded() noexcept
            {
                detail::win::UNICODE_STRING_T name;
                forwarded_hashes              hashes{ 0, get_hash(OHP) };

                Enum e;
                do {
                    name = e.value->BaseDllName;
                    name.Length -= 8; // get rid of .dll extension

                    if (!hashes.module_hash || hash(name, get_offset(OHP)) == hashes.module_hash) {
                        const exports_directory exports(e.value->DllBase);

                        if (exports) {
                            auto export_index = exports.size();
                            while (export_index--)
                                if (hash(exports.name(export_index), get_offset(OHP)) == hashes.function_hash) {
                                    const auto addr = exports.address(export_index);

                                    if (exports.is_forwarded(addr)) {
                                        hashes = hash_forwarded(
                                            reinterpret_cast<const char*>(addr),
                                            get_offset(OHP));

                                        e.reset();
                                        break;
                                    }
                                    return (F)(addr);
                                }
                        }
                    }
                } while (e.next());
                return {};
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F forwarded_safe() noexcept
            {
                return forwarded<F, safe_module_enumerator>();
            }

            template<class F = T, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static F forwarded_cached() noexcept
            {
                auto& value = base_type::_cache();
                if (!value)
                    value = forwarded<void*, Enum>();
                return (F)(value);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F forwarded_safe_cached() noexcept
            {
                return forwarded_cached<F, safe_module_enumerator>();
            }

            template<class F = T, bool IsSafe = false, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in(Module m) noexcept
            {
                if (IsSafe && !m)
                    return {};

                const exports_directory exports((const char*)(m));
                if (IsSafe && !exports)
                    return {};

                for (unsigned long i{};; ++i) {
                    if (IsSafe && i == exports.size())
                        break;

                    if (hash(exports.name(i), get_offset(OHP)) == get_hash(OHP))
                        return (F)(exports.address(i));
                }
                return {};
            }

            template<class F = T, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in_safe(Module m) noexcept
            {
                return in<F, true>(m);
            }

            template<class F = T, bool IsSafe = false, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in_cached(Module m) noexcept
            {
                auto& value = base_type::_cache();
                if (!value)
                    value = in<void*, IsSafe>(m);
                return (F)(value);
            }

            template<class F = T, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in_safe_cached(Module m) noexcept
            {
                return in_cached<F, true>(m);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt() noexcept
            {
                return in<F>(ldr_data_entry()->load_order_next()->DllBase);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt_safe() noexcept
            {
                return in_safe<F>(ldr_data_entry()->load_order_next()->DllBase);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt_cached() noexcept
            {
                return in_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt_safe_cached() noexcept
            {
                return in_safe_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
            }
        };

    }
} // namespace li::detail

#endif // include guard
```

`Client/Security/VMProtectSDK.h`:

```h
#pragma once


#if defined(__APPLE__) || defined(__unix__)
#define VMP_IMPORT 
#define VMP_API
#define VMP_WCHAR unsigned short
#else
#define VMP_IMPORT __declspec(dllimport)
#define VMP_API __stdcall
#define VMP_WCHAR wchar_t
#ifdef _WIN64
#pragma comment(lib, "VMProtectSDK64.lib")
#else
#pragma comment(lib, "VMProtectSDK32.lib")
#endif // _WIN64
#endif // __APPLE__ || __unix__

#ifdef __cplusplus
extern "C" {
#endif

	// protection
	VMP_IMPORT void VMP_API VMProtectBegin(const char*);
	VMP_IMPORT void VMP_API VMProtectBeginVirtualization(const char*);
	VMP_IMPORT void VMP_API VMProtectBeginMutation(const char*);
	VMP_IMPORT void VMP_API VMProtectBeginUltra(const char*);
	VMP_IMPORT void VMP_API VMProtectBeginVirtualizationLockByKey(const char*);
	VMP_IMPORT void VMP_API VMProtectBeginUltraLockByKey(const char*);
	VMP_IMPORT void VMP_API VMProtectEnd(void);

	// utils
	VMP_IMPORT bool VMP_API VMProtectIsProtected();
	VMP_IMPORT bool VMP_API VMProtectIsDebuggerPresent(bool);
	VMP_IMPORT bool VMP_API VMProtectIsVirtualMachinePresent(void);
	VMP_IMPORT bool VMP_API VMProtectIsValidImageCRC(void);
	VMP_IMPORT const char* VMP_API VMProtectDecryptStringA(const char* value);
	VMP_IMPORT const VMP_WCHAR* VMP_API VMProtectDecryptStringW(const VMP_WCHAR* value);
	VMP_IMPORT bool VMP_API VMProtectFreeString(const void* value);

	// licensing
	enum VMProtectSerialStateFlags
	{
		SERIAL_STATE_SUCCESS = 0,
		SERIAL_STATE_FLAG_CORRUPTED = 0x00000001,
		SERIAL_STATE_FLAG_INVALID = 0x00000002,
		SERIAL_STATE_FLAG_BLACKLISTED = 0x00000004,
		SERIAL_STATE_FLAG_DATE_EXPIRED = 0x00000008,
		SERIAL_STATE_FLAG_RUNNING_TIME_OVER = 0x00000010,
		SERIAL_STATE_FLAG_BAD_HWID = 0x00000020,
		SERIAL_STATE_FLAG_MAX_BUILD_EXPIRED = 0x00000040,
	};

#pragma pack(push, 1)
	typedef struct
	{
		unsigned short	wYear;
		unsigned char	bMonth;
		unsigned char	bDay;
	} VMProtectDate;

	typedef struct
	{
		int				nState;				// VMProtectSerialStateFlags
		VMP_WCHAR		wUserName[256];		// user name
		VMP_WCHAR		wEMail[256];		// email
		VMProtectDate	dtExpire;			// date of serial number expiration
		VMProtectDate	dtMaxBuild;			// max date of build, that will accept this key
		int				bRunningTime;		// running time in minutes
		unsigned char	nUserDataLength;	// length of user data in bUserData
		unsigned char	bUserData[255];		// up to 255 bytes of user data
	} VMProtectSerialNumberData;
#pragma pack(pop)

	VMP_IMPORT int VMP_API VMProtectSetSerialNumber(const char* serial);
	VMP_IMPORT int VMP_API VMProtectGetSerialNumberState();
	VMP_IMPORT bool VMP_API VMProtectGetSerialNumberData(VMProtectSerialNumberData* data, int size);
	VMP_IMPORT int VMP_API VMProtectGetCurrentHWID(char* hwid, int size);

	// activation
	enum VMProtectActivationFlags
	{
		ACTIVATION_OK = 0,
		ACTIVATION_SMALL_BUFFER,
		ACTIVATION_NO_CONNECTION,
		ACTIVATION_BAD_REPLY,
		ACTIVATION_BANNED,
		ACTIVATION_CORRUPTED,
		ACTIVATION_BAD_CODE,
		ACTIVATION_ALREADY_USED,
		ACTIVATION_SERIAL_UNKNOWN,
		ACTIVATION_EXPIRED,
		ACTIVATION_NOT_AVAILABLE
	};

	VMP_IMPORT int VMP_API VMProtectActivateLicense(const char* code, char* serial, int size);
	VMP_IMPORT int VMP_API VMProtectDeactivateLicense(const char* serial);
	VMP_IMPORT int VMP_API VMProtectGetOfflineActivationString(const char* code, char* buf, int size);
	VMP_IMPORT int VMP_API VMProtectGetOfflineDeactivationString(const char* serial, char* buf, int size);

#ifdef __cplusplus
}
#endif

```

`Client/Security/Xorstr.h`:

```h
/*
 * Copyright 2017 - 2018 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef JM_XORSTR_HPP
#define JM_XORSTR_HPP

#include <immintrin.h>
#include <cstdint>
#include <cstddef>
#include <utility>

#define MAKE_STRING(str)                                              \
    ::jm::make_xorstr(                                                \
        []() { return str; },                                         \
        std::make_index_sequence<sizeof(str) / sizeof(*str)>{},       \
        std::make_index_sequence<::jm::detail::_buffer_size<sizeof(str)>()>{})

#define LIT(str) MAKE_STRING(str).crypt_get()

#ifdef _MSC_VER
#define XORSTR_FORCEINLINE __forceinline
#else
#define XORSTR_FORCEINLINE __attribute__((always_inline))
#endif

 // you can define this macro to get possibly faster code on gcc/clang
 // at the expense of constants being put into data section.
#if !defined(XORSTR_ALLOW_DATA)
// MSVC - no volatile
// GCC and clang - volatile everywhere
#if defined(__clang__) || defined(__GNUC__)
#define XORSTR_VOLATILE volatile
#endif

#endif
#ifndef XORSTR_VOLATILE
#define XORSTR_VOLATILE
#endif

namespace jm
{

    namespace detail
    {

        template<std::size_t S>
        struct unsigned_;

        template<>
        struct unsigned_<1>
        {
            using type = std::uint8_t;
        };
        template<>
        struct unsigned_<2>
        {
            using type = std::uint16_t;
        };
        template<>
        struct unsigned_<4>
        {
            using type = std::uint32_t;
        };

        template<auto C, auto...>
        struct pack_value_type
        {
            using type = decltype(C);
        };

        template<std::size_t Size>
        constexpr std::size_t _buffer_size()
        {
            return ((Size / 16) + (Size % 16 != 0)) * 2;
        }

        template<auto... Cs>
        struct tstring_
        {
            using value_type = typename pack_value_type<Cs...>::type;
            constexpr static std::size_t size = sizeof...(Cs);
            constexpr static value_type  str[size] = { Cs... };

            constexpr static std::size_t buffer_size = _buffer_size<sizeof(str)>();
            constexpr static std::size_t buffer_align =
#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
            ((sizeof(str) > 16) ? 32 : 16);
#else
                16;
#endif
        };

        template<std::size_t I, std::uint64_t K>
        struct _ki
        {
            constexpr static std::size_t   idx = I;
            constexpr static std::uint64_t key = K;
        };

        template<std::uint32_t Seed>
        constexpr std::uint32_t key4() noexcept
        {
            std::uint32_t value = Seed;
            for (char c : __TIME__)
                value = static_cast<std::uint32_t>((value ^ c) * 16777619ull);
            return value;
        }

        template<std::size_t S>
        constexpr std::uint64_t key8()
        {
            constexpr auto first_part = key4<2166136261 + S>();
            constexpr auto second_part = key4<first_part>();
            return (static_cast<std::uint64_t>(first_part) << 32) | second_part;
        }

        // clang and gcc try really hard to place the constants in data
        // sections. to counter that there was a need to create an intermediate
        // constexpr string and then copy it into a non constexpr container with
        // volatile storage so that the constants would be placed directly into
        // code.
        template<class T, std::uint64_t... Keys>
        struct string_storage
        {
            std::uint64_t storage[T::buffer_size];

            XORSTR_FORCEINLINE constexpr string_storage() noexcept : storage{ Keys... }
            {
                using cast_type =
                    typename unsigned_<sizeof(typename T::value_type)>::type;
                constexpr auto value_size = sizeof(typename T::value_type);
                // puts the string into 64 bit integer blocks in a constexpr
                // fashion
                for (std::size_t i = 0; i < T::size; ++i)
                    storage[i / (8 / value_size)] ^=
                    (std::uint64_t{ static_cast<cast_type>(T::str[i]) }
                << ((i % (8 / value_size)) * 8 * value_size));
            }
        };

    } // namespace detail

    template<class T, class... Keys>
    class xor_string
    {
        alignas(T::buffer_align) std::uint64_t _storage[T::buffer_size];

        // _single functions needed because MSVC crashes without them
        XORSTR_FORCEINLINE void _crypt_256_single(const std::uint64_t* keys,
            std::uint64_t* storage) noexcept

        {
            _mm256_store_si256(
                reinterpret_cast<__m256i*>(storage),
                _mm256_xor_si256(
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(storage)),
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(keys))));
        }

        template<std::size_t... Idxs>
        XORSTR_FORCEINLINE void _crypt_256(const std::uint64_t* keys,
            std::index_sequence<Idxs...>) noexcept
        {
            (_crypt_256_single(keys + Idxs * 4, _storage + Idxs * 4), ...);
        }

        XORSTR_FORCEINLINE void _crypt_128_single(const std::uint64_t* keys,
            std::uint64_t* storage) noexcept
        {
            _mm_store_si128(
                reinterpret_cast<__m128i*>(storage),
                _mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(storage)),
                    _mm_load_si128(reinterpret_cast<const __m128i*>(keys))));
        }

        template<std::size_t... Idxs>
        XORSTR_FORCEINLINE void _crypt_128(const std::uint64_t* keys,
            std::index_sequence<Idxs...>) noexcept
        {
            (_crypt_128_single(keys + Idxs * 2, _storage + Idxs * 2), ...);
        }

        // loop generates vectorized code which places constants in data dir
        XORSTR_FORCEINLINE constexpr void _copy() noexcept
        {
            constexpr detail::string_storage<T, Keys::key...> storage;
            static_cast<void>(std::initializer_list<std::uint64_t>{
                (const_cast<XORSTR_VOLATILE std::uint64_t*>(_storage))[Keys::idx] =
                    storage.storage[Keys::idx]... });
        }

    public:
        using value_type = typename T::value_type;
        using size_type = std::size_t;
        using pointer = value_type*;
        using const_pointer = const pointer;

        XORSTR_FORCEINLINE xor_string() noexcept { _copy(); }

        XORSTR_FORCEINLINE constexpr size_type size() const noexcept
        {
            return T::size - 1;
        }

        XORSTR_FORCEINLINE void crypt() noexcept
        {
            alignas(T::buffer_align) std::uint64_t keys[T::buffer_size];
            static_cast<void>(std::initializer_list<std::uint64_t>{
                (const_cast<XORSTR_VOLATILE std::uint64_t*>(keys))[Keys::idx] =
                    Keys::key... });

            _copy();

#define JM_XORSTR_DISABLE_AVX_INTRINSICS
#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
            _crypt_256(keys, std::make_index_sequence<T::buffer_size / 4>{});
            if constexpr (T::buffer_size % 4 != 0)
                _crypt_128(keys, std::index_sequence<T::buffer_size / 2 - 1>{});
#else
            _crypt_128(keys, std::make_index_sequence<T::buffer_size / 2>{});
#endif
        }

        XORSTR_FORCEINLINE const_pointer get() const noexcept
        {
            return reinterpret_cast<const_pointer>(_storage);
        }

        XORSTR_FORCEINLINE const_pointer crypt_get() noexcept
        {
            crypt();
            return reinterpret_cast<const_pointer>(_storage);
        }
    };

    template<class Tstr, std::size_t... StringIndices, std::size_t... KeyIndices>
    XORSTR_FORCEINLINE constexpr auto
        make_xorstr(Tstr str_lambda,
            std::index_sequence<StringIndices...>,
            std::index_sequence<KeyIndices...>) noexcept
    {
        return xor_string<detail::tstring_<str_lambda()[StringIndices]...>,
            detail::_ki<KeyIndices, detail::key8<KeyIndices>()>...>{};
    }

} // namespace jm

#endif // include guard
```

`Client/Util/Encryption.cpp`:

```cpp
#include "Encryption.h"
#include "VMProtectSDK.h"
#include <Xorstr.h>
#define FE(x)  (((x) << 1) ^ ((((x)>>7) & 1) * 0x1b))
#define FD(x)  (((x) >> 1) ^ (((x) & 1) ? 0x8d : 0))

#define KEY_SIZE   32
#define NUM_ROUNDS 14


// Constants used for the AES256 algorithm.
uint8_t sbox[256] = {
	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
	0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
	0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
	0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,
	0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,
	0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
	0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
	0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
	0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,
	0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,
	0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
	0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
	0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
	0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,
	0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,
	0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
	0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
	0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
	0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,
	0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,
	0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
	0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
	0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
	0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,
	0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,
	0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
};

uint8_t sboxinv[256] = {
	0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38,
	0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
	0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87,
	0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
	0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d,
	0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
	0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2,
	0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
	0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16,
	0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
	0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda,
	0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
	0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a,
	0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
	0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02,
	0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
	0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea,
	0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
	0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85,
	0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
	0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89,
	0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
	0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20,
	0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
	0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31,
	0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
	0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d,
	0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
	0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0,
	0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
	0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26,
	0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
};

// Implementation of the AES256 encryption algorithm.
unsigned char rj_xtime(unsigned char x);

Aes256::Aes256(const ByteArray& key)
	: m_key(ByteArray(key.size() > KEY_SIZE ? KEY_SIZE : key.size(), 0))
	, m_salt(ByteArray(KEY_SIZE - m_key.size(), 0))
	, m_rkey(ByteArray(KEY_SIZE, 0))
	, m_buffer_pos(0)
	, m_remainingLength(0)
	, m_decryptInitialized(false)
{
	for (ByteArray::size_type i = 0; i < m_key.size(); ++i)
		m_key[i] = key[i];
}

Aes256::~Aes256()
{
}

ByteArray::size_type Aes256::encrypt(const ByteArray& key, const ByteArray& plain, ByteArray& encrypted)
{
	Aes256 aes(key);

	aes.encrypt_start(plain.size(), encrypted);
	aes.encrypt_continue(plain, encrypted);
	aes.encrypt_end(encrypted);

	return encrypted.size();
}

ByteArray::size_type Aes256::encrypt(const ByteArray& key, const unsigned char* plain, const ByteArray::size_type plain_length, ByteArray& encrypted)
{
	Aes256 aes(key);

	aes.encrypt_start(plain_length, encrypted);
	aes.encrypt_continue(plain, plain_length, encrypted);
	aes.encrypt_end(encrypted);

	return encrypted.size();
}

ByteArray::size_type Aes256::decrypt(const ByteArray& key, const ByteArray& encrypted, ByteArray& plain)
{
	Aes256 aes(key);

	aes.decrypt_start(encrypted.size());
	aes.decrypt_continue(encrypted, plain);
	aes.decrypt_end(plain);

	return plain.size();
}

ByteArray::size_type Aes256::decrypt(const ByteArray& key, const unsigned char* encrypted, const ByteArray::size_type encrypted_length, ByteArray& plain)
{
	Aes256 aes(key);

	aes.decrypt_start(encrypted_length);
	aes.decrypt_continue(encrypted, encrypted_length, plain);
	aes.decrypt_end(plain);

	return plain.size();
}

ByteArray::size_type Aes256::encrypt_start(const ByteArray::size_type plain_length, ByteArray& encrypted)
{
	m_remainingLength = plain_length;

	// Generate salt
	ByteArray::iterator it = m_salt.begin(), itEnd = m_salt.end();
	while (it != itEnd)
		*(it++) = (rand() & 0xFF);

	// Calculate padding
	ByteArray::size_type padding = 0;
	if (m_remainingLength % BLOCK_SIZE != 0)
		padding = (BLOCK_SIZE - (m_remainingLength % BLOCK_SIZE));
	m_remainingLength += padding;

	// Add salt
	encrypted.insert(encrypted.end(), m_salt.begin(), m_salt.end());
	m_remainingLength += m_salt.size();

	// Add 1 bytes for padding size
	encrypted.push_back(padding & 0xFF);
	++m_remainingLength;

	// Reset buffer
	m_buffer_pos = 0;

	return encrypted.size();
}

ByteArray::size_type Aes256::encrypt_continue(const ByteArray& plain, ByteArray& encrypted)
{
	ByteArray::const_iterator it = plain.begin(), itEnd = plain.end();

	while (it != itEnd)
	{
		m_buffer[m_buffer_pos++] = *(it++);

		check_and_encrypt_buffer(encrypted);
	}

	return encrypted.size();
}

ByteArray::size_type Aes256::encrypt_continue(const unsigned char* plain, const ByteArray::size_type plain_length, ByteArray& encrypted)
{
	ByteArray::size_type i = 0;

	while (i < plain_length)
	{
		m_buffer[m_buffer_pos++] = plain[i++];

		check_and_encrypt_buffer(encrypted);
	}

	return encrypted.size();
}

void Aes256::check_and_encrypt_buffer(ByteArray& encrypted)
{
	if (m_buffer_pos == BLOCK_SIZE)
	{
		encrypt(m_buffer);

		for (m_buffer_pos = 0; m_buffer_pos < BLOCK_SIZE; ++m_buffer_pos)
		{
			encrypted.push_back(m_buffer[m_buffer_pos]);
			--m_remainingLength;
		}

		m_buffer_pos = 0;
	}
}

ByteArray::size_type Aes256::encrypt_end(ByteArray& encrypted)
{
	if (m_buffer_pos > 0)
	{
		while (m_buffer_pos < BLOCK_SIZE)
			m_buffer[m_buffer_pos++] = 0;

		encrypt(m_buffer);

		for (m_buffer_pos = 0; m_buffer_pos < BLOCK_SIZE; ++m_buffer_pos)
		{
			encrypted.push_back(m_buffer[m_buffer_pos]);
			--m_remainingLength;
		}

		m_buffer_pos = 0;
	}

	return encrypted.size();
}

void Aes256::encrypt(unsigned char* buffer)
{

	unsigned char i, rcon;

	copy_key();
	add_round_key(buffer, 0);
	for (i = 1, rcon = 1; i < NUM_ROUNDS; ++i)
	{
		sub_bytes(buffer);
		shift_rows(buffer);
		mix_columns(buffer);
		if (!(i & 1))
			expand_enc_key(&rcon);
		add_round_key(buffer, i);
	}
	sub_bytes(buffer);
	shift_rows(buffer);
	expand_enc_key(&rcon);
	add_round_key(buffer, i);
}

ByteArray::size_type Aes256::decrypt_start(const ByteArray::size_type encrypted_length)
{
	unsigned char j;

	m_remainingLength = encrypted_length;

	// Reset salt
	for (j = 0; j < m_salt.size(); ++j)
		m_salt[j] = 0;
	m_remainingLength -= m_salt.size();

	// Reset buffer
	m_buffer_pos = 0;

	m_decryptInitialized = false;

	return m_remainingLength;
}

ByteArray::size_type Aes256::decrypt_continue(const ByteArray& encrypted, ByteArray& plain)
{
	ByteArray::const_iterator it = encrypted.begin(), itEnd = encrypted.end();

	while (it != itEnd)
	{
		m_buffer[m_buffer_pos++] = *(it++);

		check_and_decrypt_buffer(plain);
	}

	return plain.size();
}

ByteArray::size_type Aes256::decrypt_continue(const unsigned char* encrypted, const ByteArray::size_type encrypted_length, ByteArray& plain)
{
	ByteArray::size_type i = 0;

	while (i < encrypted_length)
	{
		m_buffer[m_buffer_pos++] = encrypted[i++];

		check_and_decrypt_buffer(plain);
	}

	return plain.size();
}

void Aes256::check_and_decrypt_buffer(ByteArray& plain)
{
	if (!m_decryptInitialized && m_buffer_pos == m_salt.size() + 1)
	{
		unsigned char j;
		ByteArray::size_type padding;

		// Get salt
		for (j = 0; j < m_salt.size(); ++j)
			m_salt[j] = m_buffer[j];

		// Get padding
		padding = (m_buffer[j] & 0xFF);
		m_remainingLength -= padding + 1;

		// Start decrypting
		m_buffer_pos = 0;

		m_decryptInitialized = true;
	}
	else if (m_decryptInitialized && m_buffer_pos == BLOCK_SIZE)
	{
		decrypt(m_buffer);

		for (m_buffer_pos = 0; m_buffer_pos < BLOCK_SIZE; ++m_buffer_pos)
			if (m_remainingLength > 0)
			{
				plain.push_back(m_buffer[m_buffer_pos]);
				--m_remainingLength;
			}

		m_buffer_pos = 0;
	}
}

ByteArray::size_type Aes256::decrypt_end(ByteArray& plain)
{
	return plain.size();
}

void Aes256::decrypt(unsigned char* buffer)
{
	unsigned char i, rcon = 1;

	copy_key();
	for (i = NUM_ROUNDS / 2; i > 0; --i)
		expand_enc_key(&rcon);

	add_round_key(buffer, NUM_ROUNDS);
	shift_rows_inv(buffer);
	sub_bytes_inv(buffer);

	for (i = NUM_ROUNDS, rcon = 0x80; --i;)
	{
		if ((i & 1))
			expand_dec_key(&rcon);
		add_round_key(buffer, i);
		mix_columns_inv(buffer);
		shift_rows_inv(buffer);
		sub_bytes_inv(buffer);
	}
	add_round_key(buffer, i);
}

void Aes256::expand_enc_key(unsigned char* rc)
{
	unsigned char i;

	m_rkey[0] = m_rkey[0] ^ sbox[m_rkey[29]] ^ (*rc);
	m_rkey[1] = m_rkey[1] ^ sbox[m_rkey[30]];
	m_rkey[2] = m_rkey[2] ^ sbox[m_rkey[31]];
	m_rkey[3] = m_rkey[3] ^ sbox[m_rkey[28]];
	*rc = FE(*rc);

	for (i = 4; i < 16; i += 4)
	{
		m_rkey[i] = m_rkey[i] ^ m_rkey[i - 4];
		m_rkey[i + 1] = m_rkey[i + 1] ^ m_rkey[i - 3];
		m_rkey[i + 2] = m_rkey[i + 2] ^ m_rkey[i - 2];
		m_rkey[i + 3] = m_rkey[i + 3] ^ m_rkey[i - 1];
	}
	m_rkey[16] = m_rkey[16] ^ sbox[m_rkey[12]];
	m_rkey[17] = m_rkey[17] ^ sbox[m_rkey[13]];
	m_rkey[18] = m_rkey[18] ^ sbox[m_rkey[14]];
	m_rkey[19] = m_rkey[19] ^ sbox[m_rkey[15]];

	for (i = 20; i < 32; i += 4)
	{
		m_rkey[i] = m_rkey[i] ^ m_rkey[i - 4];
		m_rkey[i + 1] = m_rkey[i + 1] ^ m_rkey[i - 3];
		m_rkey[i + 2] = m_rkey[i + 2] ^ m_rkey[i - 2];
		m_rkey[i + 3] = m_rkey[i + 3] ^ m_rkey[i - 1];
	}
}

void Aes256::expand_dec_key(unsigned char* rc)
{
	unsigned char i;

	for (i = 28; i > 16; i -= 4)
	{
		m_rkey[i + 0] = m_rkey[i + 0] ^ m_rkey[i - 4];
		m_rkey[i + 1] = m_rkey[i + 1] ^ m_rkey[i - 3];
		m_rkey[i + 2] = m_rkey[i + 2] ^ m_rkey[i - 2];
		m_rkey[i + 3] = m_rkey[i + 3] ^ m_rkey[i - 1];
	}

	m_rkey[16] = m_rkey[16] ^ sbox[m_rkey[12]];
	m_rkey[17] = m_rkey[17] ^ sbox[m_rkey[13]];
	m_rkey[18] = m_rkey[18] ^ sbox[m_rkey[14]];
	m_rkey[19] = m_rkey[19] ^ sbox[m_rkey[15]];

	for (i = 12; i > 0; i -= 4)
	{
		m_rkey[i + 0] = m_rkey[i + 0] ^ m_rkey[i - 4];
		m_rkey[i + 1] = m_rkey[i + 1] ^ m_rkey[i - 3];
		m_rkey[i + 2] = m_rkey[i + 2] ^ m_rkey[i - 2];
		m_rkey[i + 3] = m_rkey[i + 3] ^ m_rkey[i - 1];
	}

	*rc = FD(*rc);
	m_rkey[0] = m_rkey[0] ^ sbox[m_rkey[29]] ^ (*rc);
	m_rkey[1] = m_rkey[1] ^ sbox[m_rkey[30]];
	m_rkey[2] = m_rkey[2] ^ sbox[m_rkey[31]];
	m_rkey[3] = m_rkey[3] ^ sbox[m_rkey[28]];
}

void Aes256::sub_bytes(unsigned char* buffer)
{
	unsigned char i = KEY_SIZE / 2;

	while (i--)
		buffer[i] = sbox[buffer[i]];
}

void Aes256::sub_bytes_inv(unsigned char* buffer)
{
	unsigned char i = KEY_SIZE / 2;

	while (i--)
		buffer[i] = sboxinv[buffer[i]];
}

void Aes256::copy_key()
{
	ByteArray::size_type i;

	for (i = 0; i < m_key.size(); ++i)
		m_rkey[i] = m_key[i];
	for (i = 0; i < m_salt.size(); ++i)
		m_rkey[i + m_key.size()] = m_salt[i];
}

void Aes256::add_round_key(unsigned char* buffer, const unsigned char round)
{
	unsigned char i = KEY_SIZE / 2;

	while (i--)
		buffer[i] ^= m_rkey[(round & 1) ? i + 16 : i];
}

void Aes256::shift_rows(unsigned char* buffer)
{
	unsigned char i, j, k, l; /* to make it potentially parallelable :) */

	i = buffer[1];
	buffer[1] = buffer[5];
	buffer[5] = buffer[9];
	buffer[9] = buffer[13];
	buffer[13] = i;

	j = buffer[10];
	buffer[10] = buffer[2];
	buffer[2] = j;

	k = buffer[3];
	buffer[3] = buffer[15];
	buffer[15] = buffer[11];
	buffer[11] = buffer[7];
	buffer[7] = k;

	l = buffer[14];
	buffer[14] = buffer[6];
	buffer[6] = l;
}

void Aes256::shift_rows_inv(unsigned char* buffer)
{
	unsigned char i, j, k, l; /* same as above :) */

	i = buffer[1];
	buffer[1] = buffer[13];
	buffer[13] = buffer[9];
	buffer[9] = buffer[5];
	buffer[5] = i;

	j = buffer[2];
	buffer[2] = buffer[10];
	buffer[10] = j;

	k = buffer[3];
	buffer[3] = buffer[7];
	buffer[7] = buffer[11];
	buffer[11] = buffer[15];
	buffer[15] = k;

	l = buffer[6];
	buffer[6] = buffer[14];
	buffer[14] = l;
}

void Aes256::mix_columns(unsigned char* buffer)
{
	unsigned char i, a, b, c, d, e;

	for (i = 0; i < 16; i += 4)
	{
		a = buffer[i];
		b = buffer[i + 1];
		c = buffer[i + 2];
		d = buffer[i + 3];

		e = a ^ b ^ c ^ d;

		buffer[i] ^= e ^ rj_xtime(a ^ b);
		buffer[i + 1] ^= e ^ rj_xtime(b ^ c);
		buffer[i + 2] ^= e ^ rj_xtime(c ^ d);
		buffer[i + 3] ^= e ^ rj_xtime(d ^ a);
	}
}

void Aes256::mix_columns_inv(unsigned char* buffer)
{
	unsigned char i, a, b, c, d, e, x, y, z;

	for (i = 0; i < 16; i += 4)
	{
		a = buffer[i];
		b = buffer[i + 1];
		c = buffer[i + 2];
		d = buffer[i + 3];

		e = a ^ b ^ c ^ d;
		z = rj_xtime(e);
		x = e ^ rj_xtime(rj_xtime(z ^ a ^ c));  y = e ^ rj_xtime(rj_xtime(z ^ b ^ d));

		buffer[i] ^= x ^ rj_xtime(a ^ b);
		buffer[i + 1] ^= y ^ rj_xtime(b ^ c);
		buffer[i + 2] ^= x ^ rj_xtime(c ^ d);
		buffer[i + 3] ^= y ^ rj_xtime(d ^ a);
	}
}

inline unsigned char rj_xtime(unsigned char x)
{
	return (x & 0x80) ? ((x << 1) ^ 0x1b) : (x << 1);
}

// Wrapper for the AES256 encryption algorithm.
void Encryption::Start()
{
	VMProtectBeginUltra("Encryption::Start");
	// Create cryptographic context.
	if (!CryptAcquireContextA(&m_CryptProvider, nullptr, nullptr, PROV_RSA_AES, 0))
	{
		if (!CryptAcquireContextA(&m_CryptProvider, nullptr, nullptr, PROV_RSA_AES, CRYPT_NEWKEYSET))
		{
		//	printf("[ E! ] Failed to initialise encryption provider (%08x).\n", GetLastError());
			return;
		}
	}

	uint8_t  RandomBytes[32];
	uint32_t RandomBytesCount = sizeof RandomBytes;

	// Generate random bytes to use as encryption key.
	if (CryptGenRandom(m_CryptProvider, RandomBytesCount, RandomBytes))
		std::memcpy(m_EncryptionKey, RandomBytes, RandomBytesCount);

	// Release context.
	if (m_CryptProvider)
		CryptReleaseContext(m_CryptProvider, 0);
	VMProtectEnd();
}

void Encryption::Start(ByteArray& EncryptionKey)
{
	// If an encryption key is provided, initialise the wrapper with
	// the passed parameter.
	std::copy(EncryptionKey.begin(), EncryptionKey.end(), m_EncryptionKey);

	if (EncryptionKey.empty())
		Start();
}

ByteArray Encryption::Encrypt(ByteArray& Data, ByteArray Key)
{
	// Encrypt outgoing data.
	ByteArray Encrypted;

	Aes256::encrypt(Key, Data, Encrypted);

	return Encrypted;
}

ByteArray Encryption::Decrypt(ByteArray& Data, ByteArray Key)
{
	// Decrypt incoming data.
	ByteArray Decrypted;

	Aes256::decrypt(Key, Data, Decrypted);

	return Decrypted;
}
ByteArray Encryption::EncryptText(std::string Text, ByteArray Key)
{
	ByteArray plaintext(Text.begin(), Text.end());
	// Encrypt outgoing data.
	ByteArray Encrypted;

	Aes256::encrypt(Key, plaintext, Encrypted);

	return Encrypted;
}

std::string Encryption::DecryptText(ByteArray& Data, ByteArray Key)
{

	ByteArray Decrypted;
	Aes256::decrypt(Key, Data, (ByteArray&)Decrypted);
	std::string DecryptedPassword(Decrypted.begin(), Decrypted.end());
	return DecryptedPassword;
}

```

`Client/Util/Encryption.h`:

```h
#pragma once

#include <cstdint>
#include <vector>
#include <windows.h>
#include <wincrypt.h>
#include <string>

//extern Client* TCPClient;
using ByteArray = std::vector<uint8_t>;

#define BLOCK_SIZE 16


// AES256 implementation.
class Aes256
{

public:
	Aes256(const ByteArray& key);
	~Aes256();

	static ByteArray::size_type encrypt(const ByteArray& key, const ByteArray& plain, ByteArray& encrypted);
	static ByteArray::size_type encrypt(const ByteArray& key, const unsigned char* plain, const ByteArray::size_type plain_length, ByteArray& encrypted);
	static ByteArray::size_type decrypt(const ByteArray& key, const ByteArray& encrypted, ByteArray& plain);
	static ByteArray::size_type decrypt(const ByteArray& key, const unsigned char* encrypted, const ByteArray::size_type encrypted_length, ByteArray& plain);

	ByteArray::size_type encrypt_start(const ByteArray::size_type plain_length, ByteArray& encrypted);
	ByteArray::size_type encrypt_continue(const ByteArray& plain, ByteArray& encrypted);
	ByteArray::size_type encrypt_continue(const unsigned char* plain, const ByteArray::size_type plain_length, ByteArray& encrypted);
	ByteArray::size_type encrypt_end(ByteArray& encrypted);

	ByteArray::size_type decrypt_start(const ByteArray::size_type encrypted_length);
	ByteArray::size_type decrypt_continue(const ByteArray& encrypted, ByteArray& plain);
	ByteArray::size_type decrypt_continue(const unsigned char* encrypted, const ByteArray::size_type encrypted_length, ByteArray& plain);
	ByteArray::size_type decrypt_end(ByteArray& plain);

private:
	ByteArray            m_key;
	ByteArray            m_salt;
	ByteArray            m_rkey;

	unsigned char        m_buffer[3 * BLOCK_SIZE];
	unsigned char        m_buffer_pos;
	ByteArray::size_type m_remainingLength;

	bool                 m_decryptInitialized;

	void check_and_encrypt_buffer(ByteArray& encrypted);
	void check_and_decrypt_buffer(ByteArray& plain);

	void encrypt(unsigned char* buffer);
	void decrypt(unsigned char* buffer);

	void expand_enc_key(unsigned char* rc);
	void expand_dec_key(unsigned char* rc);

	void sub_bytes(unsigned char* buffer);
	void sub_bytes_inv(unsigned char* buffer);

	void copy_key();

	void add_round_key(unsigned char* buffer, const unsigned char round);

	void shift_rows(unsigned char* buffer);
	void shift_rows_inv(unsigned char* buffer);

	void mix_columns(unsigned char* buffer);
	void mix_columns_inv(unsigned char* buffer);
};

// Encryption wrapper.
class Encryption
{
	uint8_t    m_EncryptionKey[32];
	HCRYPTPROV m_CryptProvider;

public:
	// Generate a random cryptographic key.
	// OPTIONAL: You can pass a premade encryption key as a parameter.
	void Start();
	void Start(ByteArray& EncryptionKey);

	// Handles encryption/decryption of data.
	ByteArray Encrypt(ByteArray& Data, ByteArray Key);
	ByteArray Decrypt(ByteArray& Data, ByteArray Key);
	ByteArray EncryptText(std::string Text, ByteArray Key);
	std::string DecryptText(ByteArray& Data, ByteArray Key);
	// Exposes the encryption key.

};

```

`Client/Util/File.cpp`:

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include "File.h"
#include <iostream>
#include <ctime>
#include <iterator>
#include <thread>
int length;

void File::GetFile()
{
	/*
	Take the size, we know it will contain no characters so we can just use stoi to get an int value
	Change the array size to the size of the file
	Until that size is reached it will listen for incomming bytes
	*/
	size_t Size = stof(File::TCPClient->ReceiveText());  // bypass the max int value
	Size = ntohl(Size);

	constexpr size_t ChunkSize = 4096;
	size_t Total = 0;

	while (Size > 0) {

		ByteArray Bytes = File::TCPClient->ReceiveRawBytes(); 
		if (Bytes.size() <= 0) {
			break;
		}
		if (Size < Bytes.size()) // last packet will be under the byte size
			break;
		Size -= Bytes.size();
		Total += Bytes.size();
		for (uint8_t byte : Bytes)
		{
			File::Array.push_back(byte);

		}
	
	}
	File::TCPClient->Encryption.Decrypt(File::Array, File::TCPClient->EKey());
}
template<typename T>
std::vector<T> Slice(std::vector<T> const& v, int m, int n)
{
	/*
	Uses a template to pass any data type
	Calculates the position of our first and end data
	Returns a new vector list of our data inbetween the stated values
	*/
	auto first = v.cbegin() + m;
	auto last = v.cbegin() + n;
	std::vector<T> vec(first, last);

	return vec;
}

void File::SendFile()
{
	/*
	Encrypts the array of data
	Calculates the size of the encrypted array and sends it to the node
	Splits the array into sendable amounts(4096 bytes) and sends them
	When the size is 0 or going to be 0 after the next packet it breaks the loop
	The server merges bytes so we sleep for 1 second to prevent it merging, this isn't an issue when sending data to the client though
	*/
	TCPClient->SendingBytes = true;
	File::TCPClient->Encryption.Encrypt(File::Array, File::TCPClient->EKey());
	size_t Size = File::Array.size();
	size_t NetworkSize = htonl(Size);
	File::TCPClient->SendText(std::to_string(NetworkSize));
	Sleep(1000);
	size_t Sent = 0;
	int i = 0;
	int iiGet;
	while (Size > 0) {
		iiGet = (Size < 4095) ?
			Size : 4095; // the packet is actually 4096 but randomly the size is always size+1, not sure why
		ByteArray Bytes = Slice(File::Array, i * 4095, (i * 4095) + iiGet);
		File::TCPClient->SendRawBytes(Bytes);
		if (Bytes.size() <= 0)
			break;
		if (Size < Bytes.size()) // last packet will be under the byte size
			break;
		Sent += Bytes.size();
		Size -= Bytes.size();
		i++;
	}
	Sleep(700);
	TCPClient->SendingBytes = false;
	
}

```

`Client/Util/File.h`:

```h
#pragma once
#include "TCPClient.h"

class File
{
public:
	void GetFile();
	void SendFile();
	ByteArray Array;
	int Left;
	Client* TCPClient;
private:
	int BytesLeftToRecieve;
	bool Recieved = false;
};
```

`Client/Util/Hwid.cpp`:

```cpp
#include <intrin.h> // NOTE this header is MSVC specific!
#include <array>
#include <stdio.h>
#include <array>
#include <iomanip>
#include <sstream>
#include <conio.h>
#include <memory>
#include <stdexcept>
#include <cstdio>
#include <sstream>
#include <Windows.h>

#include "Xorstr.h"
#include "Hwid.h"
#include "VMProtectSDK.h"


std::string exec(const char* cmd) {
	VMProtectBeginUltra(LIT("ExecuteSystem"));
	std::array<char, 128> buffer;
	std::string result;
	std::shared_ptr<FILE> pipe(_popen(cmd, "r"), _pclose);
	while (!feof(pipe.get())) {
		if (fgets(buffer.data(), 128, pipe.get()) != NULL)
			result += buffer.data();
	}
	return result;
	VMProtectEnd();
}
std::string GetCpuInfo()
{
	std::array<int, 4> integerbuffer;
	constexpr size_t sizeofintegerbuffer = sizeof(int) * integerbuffer.size();

	std::array<char, 64> charbuffer = {};
	// https://docs.microsoft.com/en-us/cpp/intrinsics/cpuid-cpuidex?view=vs-2019
	constexpr std::array<int, 3> functionids = {
		// Manufacturer
		0x8000'0002,
		// Model
		0x8000'0003,
		// Clockspeed
		0x8000'0004,
	};

	std::string cpu;

	for (int id : functionids)
	{
		__cpuid(integerbuffer.data(), id);

		std::memcpy(charbuffer.data(), integerbuffer.data(), sizeofintegerbuffer);

		cpu += std::string(charbuffer.data());
	}

	return cpu;
}
std::string GetProcessorID() {
	std::array<int, 4> cpuinfo;
	__cpuid(cpuinfo.data(), 1);
	std::ostringstream buffer;
	buffer << std::uppercase << std::hex << std::setfill('0') << std::setw(8) << cpuinfo.at(3) << std::setw(8) << cpuinfo.at(0);
	return buffer.str();

}
std::string GetRamAmountGB()
{

	MEMORYSTATUSEX statex;

	statex.dwLength = sizeof(statex);

	GlobalMemoryStatusEx(&statex);
	return std::to_string((int)ceil((float)statex.ullTotalPhys / (1024 * 1024 * 1024))) + LIT("GB"); // yeah a lot of casting and looks ugly. 
}
std::string GetRamSpeed()
{
	std::string val = exec(LIT("wmic memorychip get speed"));
	return val.substr(5, 8) + LIT("Mhz"); // it returns all ram values, we only need 1 and ram wont be going into 5 digit speeds any time soon

}
std::string GetDiskSerials()
{
	VMProtectBeginUltra(LIT("GetDiskSerials"));
	std::string val = exec(LIT("wmic diskdrive get serialnumber"));
	val = val.substr(12, val.length() - 13); // Remove serial number part, gets all serials
	std::string str;
	std::istringstream input;
	input.str(val);
	std::string ret;
	while (std::getline(input, str))
	{

		if (!str.find(LIT("USBSTOR")) != std::string::npos) // wmic diskdrive get model,name,serialnumber,pnpdeviceid the pnpdeviceid  identifies usbs as usbstor
			ret = ret + str; // remove anything flagged as a usb
	}
	return ret;
	VMProtectEnd();
}
std::string GetDiskInformation()
{

	std::string val = exec(LIT("wmic diskdrive get model,name,serialnumber"));
	return val.substr(70, val.length() - 70);// remove the shitload of spaces and headers

}
std::string GetRamPartNumber()
{

	std::string val = exec(LIT("wmic memorychip get partnumber"));
	return val.substr(10, val.length() - 10); // remove the shitload of spaces and headers


}
std::string GetRamInformation()
{

	std::string val = exec(LIT("wmic memorychip get devicelocator, partnumber, capacity,speed"));
	return val.substr(55, val.length() - 55); // remove the shitload of spaces and headers


}
std::string GetGpuName()
{

	std::string val = exec(LIT("wmic PATH Win32_VideoController GET description,videoprocessor"));

	return val; // remove the "desctiption" part


}
std::string GetMoboName()
{

	std::string val = exec(LIT("wmic PATH Win32_BaseBoard get product"));
	return val.substr(11, val.length() - 11); // remove the "Product" part


}
std::string GetMoboSerialNumber()
{

	std::string val = exec(LIT("wmic PATH Win32_BaseBoard get SerialNumber"));
	return val.substr(12, val.length() - 12); // remove the "SerialNumber" part


}
std::string GetMoboInformation()
{

	std::string val = exec(LIT("wmic PATH Win32_BaseBoard get SerialNumber,product"));
	return val.substr(51, val.length() - 51); // remove the "product and serial number" part and spaces


}

std::string ReadableHwid()
{
	/*
	This is used for monitoring hwid changes manually
	*/
	VMProtectBeginUltra(LIT("ReadableHwid"));
	std::string Ram = LIT("Ram Information: ") + GetRamInformation();
	std::string Drives = LIT("Drive Information: ") + GetDiskInformation();
	std::string Gpu = LIT("Gpu Information: ") + GetGpuName();
	std::string Mobo = LIT("Mobo Information: ") + GetMoboInformation();
	std::string Cpu = LIT("Cpu Information: ") + GetCpuInfo() + LIT("\nUnique ID: ") + GetProcessorID() + LIT("\n");
	return Ram + Drives + Gpu + Mobo + Cpu;
	VMProtectEnd();
}
std::string Hwid()
{
	/*
	Removes unneeded information and uses it all for hwid
	*/
	VMProtectBeginUltra(LIT("Hwid"));
	std::string HWRamSpeed = GetRamSpeed();
	std::string HWRamCapacity = GetRamAmountGB();
	std::string HWRamPartNum = GetRamPartNumber();
	std::string HWDriveSerial = GetDiskSerials();
	std::string HWGpuName = GetGpuName();
	std::string HWProcessorID = GetProcessorID();
	std::string HWMoboName = GetMoboName();
	std::string HWProcessorName = GetCpuInfo();
	std::string HWMoboSerialNumber = GetMoboSerialNumber();
	return HWRamSpeed + HWRamCapacity + HWRamPartNum + HWGpuName + HWDriveSerial + HWMoboSerialNumber + HWProcessorName + HWMoboName + HWProcessorID;
	VMProtectEnd();
}
```

`Client/Util/Hwid.h`:

```h
#pragma once
std::string ReadableHwid();
std::string Hwid();
```

`Client/Util/Screenshot.cpp`:

```cpp
#include <stdlib.h>
#include <windows.h>
#include <iostream>
#include <GdiPlus.h>
#include <wingdi.h>
#include <fstream>
#include "Xorstr.h"
#include "Screenshot.h"
#include "VMProtectSDK.h"
#include "LazyImporter.h"

ByteArray screenshot;
BITMAPINFOHEADER CreateBitmapHeader(int width, int height)
{

	BITMAPINFOHEADER  bi;

	// create a bitmap
	bi.biSize = sizeof(BITMAPINFOHEADER);
	bi.biWidth = width;
	bi.biHeight = -height;  //this is the line that makes it draw upside down or not
	bi.biPlanes = 1;
	bi.biBitCount = 32;
	bi.biCompression = BI_RGB;
	bi.biSizeImage = 0;
	bi.biXPelsPerMeter = 0;
	bi.biYPelsPerMeter = 0;
	bi.biClrUsed = 0;
	bi.biClrImportant = 0;

	return bi;

}

HBITMAP GdiPlusScreenCapture(HWND hWnd)
{

	// get handles to a device context (DC)
	HDC hwindowDC = LI_FN(GetDC).in(LI_MODULE("User32.dll").cached())(hWnd);
	HDC hwindowCompatibleDC = LI_FN(CreateCompatibleDC).in(LI_MODULE("Gdi32.dll").cached())(hwindowDC);
	LI_FN(SetStretchBltMode).in(LI_MODULE("Gdi32.dll").cached())(hwindowCompatibleDC, COLORONCOLOR);

	// define scale, height and width
	int scale = 1;
	int screenx = LI_FN(GetSystemMetrics).in(LI_MODULE("User32.dll").cached())(SM_XVIRTUALSCREEN);
	int screeny =  LI_FN(GetSystemMetrics).in(LI_MODULE("User32.dll").cached())(SM_YVIRTUALSCREEN);
	int width = LI_FN(GetSystemMetrics).in(LI_MODULE("User32.dll").cached())(SM_CXVIRTUALSCREEN);
	int height =  LI_FN(GetSystemMetrics).in(LI_MODULE("User32.dll").cached())(SM_CYVIRTUALSCREEN);

	// create a bitmap
	HBITMAP hbwindow =  LI_FN(CreateCompatibleBitmap).in(LI_MODULE("Gdi32.dll").cached())(hwindowDC, width, height);
	//BITMAPINFOHEADER bi =  LI_FN(CreateBitmapHeader).in(LI_MODULE("Gdi32.dll").cached())(width, height);
	BITMAPINFOHEADER bi = CreateBitmapHeader(width, height);

	// use the previously created device context with the bitmap
	LI_FN(SelectObject).in(LI_MODULE("Gdi32.dll").cached())(hwindowCompatibleDC, hbwindow);

	// Starting with 32-bit Windows, GlobalAlloc and LocalAlloc are implemented as wrapper functions that call HeapAlloc using a handle to the process's default heap.
	// Therefore, GlobalAlloc and LocalAlloc have greater overhead than HeapAlloc.
	DWORD dwBmpSize = ((width * bi.biBitCount + 31) / 32) * 4 * height;
	HANDLE hDIB = LI_FN(GlobalAlloc).in(LI_MODULE("Kernel32.dll").cached())(GHND, dwBmpSize);
	char* lpbitmap = (char*)LI_FN(GlobalLock).in(LI_MODULE("Kernel32.dll").cached())(hDIB);

	// copy from the window device context to the bitmap device context
	LI_FN(StretchBlt).in(LI_MODULE("Gdi32.dll").cached())(hwindowCompatibleDC, 0, 0, width, height, hwindowDC, screenx, screeny, width, height, SRCCOPY);   //change SRCCOPY to NOTSRCCOPY for wacky colors !
	LI_FN(GetDIBits).in(LI_MODULE("Gdi32.dll").cached())(hwindowCompatibleDC, hbwindow, 0, height, lpbitmap, (BITMAPINFO*)&bi, DIB_RGB_COLORS);

	// avoid memory leak
	LI_FN(DeleteDC).in(LI_MODULE("Gdi32.dll").cached())(hwindowCompatibleDC);
	LI_FN(ReleaseDC).in(LI_MODULE("User32.dll").cached())(hWnd, hwindowDC);

	return hbwindow;

}

bool SaveToMemory(HBITMAP* hbitmap, std::vector<BYTE>& data, std::string dataFormat = LIT("png"))
{
	VMProtectBeginUltra(LIT("SaveToMemory"));
	Gdiplus::Bitmap bmp(*hbitmap, nullptr);
	// write to IStream
	IStream* istream = nullptr;
	CreateStreamOnHGlobal(NULL, TRUE, &istream);

	// define encoding
	CLSID clsid;
	if (dataFormat.compare(LIT("bmp")) == 0) { CLSIDFromString(LIT(L"{557cf400-1a04-11d3-9a73-0000f81ef32e}"), &clsid); }
	else if (dataFormat.compare(LIT("jpg")) == 0) { CLSIDFromString(LIT(L"{557cf401-1a04-11d3-9a73-0000f81ef32e}"), &clsid); }
	else if (dataFormat.compare(LIT("gif")) == 0) { CLSIDFromString(LIT(L"{557cf402-1a04-11d3-9a73-0000f81ef32e}"), &clsid); }
	else if (dataFormat.compare(LIT("tif")) == 0) { CLSIDFromString(LIT(L"{557cf405-1a04-11d3-9a73-0000f81ef32e}"), &clsid); }
	else if (dataFormat.compare(LIT("png")) == 0) { CLSIDFromString(LIT(L"{557cf406-1a04-11d3-9a73-0000f81ef32e}"), &clsid); }

	Gdiplus::Status status = bmp.Save(istream, &clsid, NULL);
	if (status != Gdiplus::Status::Ok)
		return false;

	// get memory handle associated with istream
	HGLOBAL hg = NULL;
	GetHGlobalFromStream(istream, &hg);

	// copy IStream to buffer
	int bufsize = GlobalSize(hg);
	data.resize(bufsize);

	// lock & unlock memory
	LPVOID pimage = LI_FN(GlobalLock).in(LI_MODULE("Kernel32.dll").cached())(hg);
	memcpy(&data[0], pimage, bufsize);
	LI_FN(GlobalUnlock).in(LI_MODULE("Kernel32.dll").cached())(hg);
	istream->Release();
	return true;
	VMProtectEnd();
}
void Screenshot()
{
	VMProtectBeginUltra(LIT("Screenshot"));
	Gdiplus::GdiplusStartupInput gdiplusStartupInput;
	ULONG_PTR gdiplusToken;
	GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);
	
	// get the bitmap handle to the bitmap screenshot
	HWND hWnd = LI_FN(GetDesktopWindow).in(LI_MODULE("User32.dll").cached())();
	HBITMAP hBmp = GdiPlusScreenCapture(hWnd);

	// save as png to memory
	std::vector<BYTE> data1;
	std::string dataFormat = LIT("jpg");

	if (SaveToMemory(&hBmp, data1, dataFormat))
	{
		screenshot = data1;

	}

	Gdiplus::GdiplusShutdown(gdiplusToken);
	VMProtectEnd();
}
```

`Client/Util/Screenshot.h`:

```h
#pragma once
#include "Encryption.h"
extern ByteArray screenshot;
void Screenshot();
```

`README.md`:

```md
# 7DTD
<p align="center">
  <img src="./Images/6.png"
    style="width: 75%;" />
</p>
<p align="center">
  <img src="./Images/4.png"
    style="width: 55%;" />
</p>

## What is 7DTD?
This is a cheat for the game 7 days to die. An easy anti cheat secured unity game.
<br>
In this cheat I utilize mono in order to run the dll into memory and then use the the mono callbacks and mono functionality within the game to execute my code.
<br>
This project consists of a client,server(c++) and then a cheat(c#). The client and server use websockets and a basic aes256 encryption system to send data from the client to the server in order to create accounts, authenticate a user, send the cheat, load the cheat. Most of the code for this was written quite a few years ago but the other year i decided to rewrite it all and half way through got too fed up of it and just started stealing from my old project code. This is the result of some new code, Some old code. All in all it is rather messy and wasn't ever intended to see the light of day.
<br>
The cheat itself is very good, able to spawn items, kill off entire servers and all around cause complete caos. I am honestly rather fond of the cheat due to its ability to cause havoc on any server but thats mainly due to the game's poor networking systems. 

## The Cheat
[Outdated]<br>
So firstly lets talk about the anti cheat bypass. As of writing this the cheat is fully undetected on eac and has been for about 4-5 years.
We use a very simple exploit to access game memory, we utilize a .net 7's update which allows you to load references through the base directory allowing us to take a loaded reference/library and move its location to the base directory and edit it with a few IL calls to our cheat.
In this case i take the 0.harmony.dll from the managed folder and put it in the base folder and edit it to have the opcodes: call Globals.Auth and then ret. <br>
[Update 18/09/23] <br>
It appears after nearly 5 years of using this bypass it has been patched. It took effectively about 6 months of this project being open source and public to get the bypass patched. Circumventing their patch is trivial but for most people that don't understand how unity handles dll management that wont be the case. I don't exactly feel like spitting out EAC bypasses every few months so i won't be maintaining the EAC bypass. The game only had about 5 servers using EAC and most of them actually don't use EAC but actually just have EAC on the server which gives it an EAC flag so the game expects EAC running to connect to them. Therefore the handshake isn't needed and a heartbeat isn't established. This is an insanely easy thing to bypass. For real EAC servers you can basically just use the cheat on linux using the same method. <br>
<br>
With the bypass out of the way the cheat's functionality is efficient with a full set of aimbot and esp and weapon modifiers but mainly you can change your id and become another player (even on the server) as well as spoof your stats and break blocks in many different ways that bypass server sided anti cheats.
<br>
You can use my [UnityStealer](https://github.com/IntelSDM/UnityStealer) project to replicate this for the same effect. 
<br>

Due to obfuscation support you might notice that the code is rather messy. You may ask why Update() will call an Update1() or other callbacks call another function instead of just containing the code. This is due to obfuscation support so we can obfuscate the contents of the callback to hide them from an attacker without renaming the callback. Unity callbacks work by walking the monobehaviour's functions during their construction phase and then checking the method name compared to a string and then diverting the method address to be called within native memory under the correct callback handler. This means that those callback function names MUST be exact at runtime so we must exclude them from obfuscation.


## The Client
The client works rather well at sending the server information even if it is all over text. It works very well at what it was intended for even if it was mostly written a very long time ago. It uses xor encryption on strings and lazy imported on function calls to create a layer of protection and did initially use vmp on top of that. It has a heartbeat system too to annoy debuggers.

<br>
There is a lot of improvement needed, firstly the client could do with utilizing threading for messaging. It could do with a massive amount of work, data transactions firstly should all be classes sent into byte arrays and reconstructed on the server rather than just seperating text and decomposing it on the server side. The encryption is enough for morons but anyone with reverse engineering knowledge could figure out whats going on which is why tls 1.3 is very much needed. The client sends screenshots to the client to ensure authenticity of a user, this prevents anyone debugging the client. The client collects a firm set of hardware information to lock a user's account. 
<br>

## The Server
The server works very well at logging data with its own database system written using windows calls. This allowed me to easily sanitise the data to prevent against a string manipulation based attack. This was the foundation and implementation that gave me a lot of experience for my current DBMS that is in my current systems. The server can calulate product times in order to freeze a product and then unfreeze it to allow for downtime and maintenance without removing user subscription time. The server successfully streams all the required data perfectly for the user and locks the user's account to their hardware and allows this to be reset to new hardware information.
<br>
There are many ways to improve on this, firstly the data should be transferred using a none text method like I said before with the client. The client event handler should work in a much more objective way by initializing a new instance class with key words to active it. A console command system would also greatly improve such a system in order to have a command class that can add different commands with different derived actions. The file system of sending files should also use a dictionary of files in order to save memory with all those allocations of the same file in different database instances.

## Videos
<a href="http://www.youtube.com/watch?v=aAVyQwCgoKU">
  <img src="./Images/7.png" alt="Play Video" width="800" height="600">
</a>
<br>
<a href="http://www.youtube.com/watch?v=e7meP019pTY">
  <img src="./Images/8.png" alt="Play Video" width="800" height="600">
</a>

## More Images:
<p align="left">
  <img src="./Images/9.png"
    style="width: 85%;" />
</p>
<p align="left">
  <img src="./Images/2.png"
    style="width: 85%;" />
</p>
<p align="left">
  <img src="./Images/3.png"
    style="width: 85%;" />
</p>

```

`Server/Database/DBHandler.cpp`:

```cpp

#include "DBHandler.h"
#include <iostream>
#include <fstream> 
#include <filesystem>
#include <ctime>
#include <sstream>


#pragma warning(disable : 4996) // unsafe warning
void Database::BanUser(std::string Username, std::string Reason)
{
	std::string UserDir = DBDir + "/Database/" + Username;
	Database::WriteFileAsString(UserDir, "Banned.txt", "True");
	Database::WriteFileAsString(UserDir, "BanReason.txt", Reason);

}
bool Database::IsHwidNull(std::string Username)
{
	std::string UserDir = DBDir + "/Database/" + Username;
	return Database::ReadFileAsString(UserDir, "hwid.txt") == "";
}
void Database::ResetHwid(std::string Username)
{
	std::string UserDir = DBDir + "/Database/" + Username;
	std::string Pending = Database::ReadFileAsString(UserDir, "PendingHwid.txt");
	Database::WriteFileAsString(UserDir, "Hwid.txt", Pending);
}
std::string Database::GetDatabaseDirectory()
{
	return Database::DBDir;
}
void Database::CreateDB()
{

	Database::CreateDir(DBDir + "/Database");
	Database::CreateDir(DBDir + "/Globals");
	Database::CreateDir(DBDir + "/Globals/Products");
	Database::CreateFilename(GlobalDir, "Products.txt");
	Database::CreateFilename(DBDir + "/Globals", "BannedHwid.txt");
	Database::CreateFilename(DBDir + "/Globals", "Frozen.txt");
}
void Database::CreateProduct(std::string Product)
{
	std::string Dir = GlobalDir + "/" + Product;
	if (!Database::DoesDirectoryExist(Dir))
		Database::CreateDir(Dir);


}
ByteArray Database::GetStreamFile(std::string Username, std::string Product, std::string File)
{
	std::string ret = "Error";
	std::string CachedUsername = Username;
	std::for_each(CachedUsername.begin(), CachedUsername.end(), [](char& c)
		{
			c = ::tolower(c); // To lower the username so we dont need anything case sensitive

		});
	Username = CachedUsername;
	std::string UserDir = DBDir + "/Database/" + Username;
	// check for active product, return file bytearray
	if (!Database::DoesFileExist(GlobalDir + "/products", File))
	{
		ret = "File Doesn't Exist";
		ByteArray empty(ret.begin(), ret.end());
		return empty;
	}

	std::string Products = Database::GetActiveProducts(Username);
	std::istringstream input;
	std::string str;
	input.str(Products);
	std::string character = "-";
	bool ProductExist = false;
	while (std::getline(input, str))
	{
		int specialchar = 0;
		int specialcharpos[1050];
		for (std::string::size_type i = 0; i < str.size(); i++)
		{
			if (str[i] == character[0])
			{
				specialcharpos[specialchar] = i;
				specialchar++;
			}
		}
		std::string ProductName = str.substr(0, specialcharpos[0]);
		if (ProductName == Product)
		{
			ProductExist = true;
		}
	}
	if (!ProductExist)
	{
		ret = "No Product";
		ByteArray empty(ret.begin(), ret.end());
		return empty;
	}


	ByteArray Contents;
	std::ifstream Files(GlobalDir + "/products/" + File, std::ios::in | std::ios::binary);
	ByteArray empty(ret.begin(), ret.end());
	if (!Files.is_open())
		return empty;

	// Do not skip white-space, read file.
	Files.unsetf(std::ios::skipws);
	Contents.insert(
		Contents.begin(),
		std::istream_iterator<uint8_t>(Files),
		std::istream_iterator<uint8_t>()
	);

	if (Contents.empty())
		return empty;
	Files.close();

	return Contents;

}
ByteArray Database::GetStreamFile(std::string File)
{
	std::string ret = "Error";

	// check for active product, return file bytearray
	if (!Database::DoesFileExist(GlobalDir + "/products", File))
	{
		ret = "File Doesn't Exist";
		ByteArray empty(ret.begin(), ret.end());
		return empty;
	}

	ByteArray Contents;
	std::ifstream Files(GlobalDir + "/products/" + File, std::ios::in | std::ios::binary);
	ByteArray empty(ret.begin(), ret.end());
	if (!Files.is_open())
		return empty;

	// Do not skip white-space, read file.
	Files.unsetf(std::ios::skipws);
	Contents.insert(
		Contents.begin(),
		std::istream_iterator<uint8_t>(Files),
		std::istream_iterator<uint8_t>()
	);

	if (Contents.empty())
		return empty;
	Files.close();

	return Contents;

}
void Database::StoreScreenshot(ByteArray Data, std::string Username)
{
	std::time_t t = std::time(0);
	std::tm* now = std::gmtime(&t);
	int year = now->tm_year + 1900;
	int month = now->tm_mon + 1;
	int day = now->tm_mday;
	int hour = now->tm_hour;
	int minute = now->tm_min;
	int second = now->tm_sec;
	std::string TimeNow = std::to_string(hour) + "h-" + std::to_string(minute) + "m-" + std::to_string(second) + "s" + ".jpg";
	std::string DayNow = std::to_string(day) + "." + std::to_string(month) + "." + std::to_string(year) + ".";
	std::string UserDir = DBDir + "/Database/" + Username;
	std::string ScreenshotDir = DBDir + "/Database/" + Username + "/Screenshots/" + DayNow + "/";

	if (!Database::DoesDirectoryExist(ScreenshotDir))
		Database::CreateDir(ScreenshotDir);

	//if (Database::DoesFileExist(ScreenshotDir, TimeNow))
//		return;
	// save from memory to file

	std::ofstream fout(ScreenshotDir + TimeNow, std::ios::out | std::ios::binary);
	fout.write((char*)Data.data(), Data.size());
	fout.close();
}

void Database::FreezeProduct(std::string Product)
{ // https://stackoverflow.com/questions/67273/how-do-you-iterate-through-every-file-directory-recursively-in-standard-c
	std::string text = Database::ReadFileAsString(GlobalDir, "Frozen.txt");
	std::istringstream input;
	std::string str;
	input.str(text);
	std::string ret;

	std::string character = "-";

	while (std::getline(input, str))
	{
		int specialchar = 0;
		int specialcharpos[1050];
		for (std::string::size_type i = 0; i < str.size(); i++)
		{
			if (str[i] == character[0])
			{
				specialcharpos[specialchar] = i;
				specialchar++;
			}
		}
		std::string ProductName = str.substr(0, specialcharpos[0]);
		int Time = stoi(str.substr(specialcharpos[0] + 1, str.length() - specialcharpos[0] + 1));
		//	std::cout << Time << "\n";
		//	std::cout << ProductName << "\n";
		if (str != "" && ProductName != Product)
			ret = ret + str + "\n";

	}

	ret = ret + Product + "-" + std::to_string(time(NULL));

	Database::WriteFileAsString(GlobalDir, "Frozen.txt", ret);

}
// add subscription freezing
std::string Database::GenerateKey(std::string Product, std::string Vendor, int Time)
{
	srand((unsigned)time(NULL) * __rdtsc()); // always random using the clock count	to calculate the random seed
	static const char alphanum[] =
		"0123456789"
		"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
		"abcdefghijklmnopqrstuvwxyz";
	std::string tmp;
	tmp.reserve(24);


	std::string Part1 = Product + "-";
	std::string Part2 = Vendor + "-";
	std::string Part3 = std::to_string(Time) + "-";

	for (int i = 0; i < 24; ++i) {
		tmp += alphanum[rand() % (sizeof(alphanum) - 1)];
	}
	std::string Part4 = tmp;
	std::string Key = Part1 + Part2 + Part3 + Part4;

	std::string db = Database::ReadFileAsString(GlobalDir, "Products.txt");
	if (db.length() > 0)
		db = db + "\n" + Key;
	else
		db = Key;
	Database::WriteFileAsString(GlobalDir, "Products.txt", db);
	return Key;
}
void Database::UnFreezeProduct(std::string Product)
{
	if (!Database::DoesFileExist(Database::GlobalDir, "Products.txt"))
		return;


	std::filesystem::path DefaultPath = Database::DBDir + "/Database/ ";
	for (std::filesystem::path dirEntry : std::filesystem::recursive_directory_iterator(Database::DBDir + "/Database")) // take the username and just use the username with dbdir/database
	{
		std::string UserDir = dirEntry.u8string();

		if (dirEntry.has_extension() == true)
			continue;
		if (dirEntry.relative_path().remove_filename() != DefaultPath.relative_path().remove_filename())
			continue;


		// loop through directory characters and find the \ to then find the username and create a real full directory
		int charpos = 0;
		std::string character1 = "\\";
		for (std::string::size_type i = 0; i < UserDir.size(); i++)
		{
			if (UserDir[i] == character1[0])
			{
				charpos = i;
			}
		}
		UserDir = Database::DBDir + "/Database/" + UserDir.substr(charpos + 1, UserDir.length() - charpos + 1);

		if (!Database::DoesFileExist(UserDir, "Products.txt"))
			continue;

		//	std::cout << time(NULL) << std::endl; 

			// loop through the frozen products and player products
		std::string LocalKeys = Database::ReadFileAsString(UserDir, "Products.txt");
		RemoveSpaces(LocalKeys);
		std::istringstream input;
		std::string str;
		input.str(LocalKeys);
		std::string ret;
		std::string character = "-";

		std::string text = Database::ReadFileAsString(GlobalDir, "Frozen.txt");
		std::istringstream input1;
		std::string str1;
		input1.str(text);

		std::list<std::string> FrozenSubs;
		std::string Write = "";
		std::string WriteFrozen = "";

		int it1 = 0;
		int it2 = 0;
		while (std::getline(input1, str1))
		{
			FrozenSubs.push_back(str1);
		}
		while (std::getline(input, str))
		{
			int specialchar = 0;
			int specialcharpos[1050];
			for (std::string::size_type i = 0; i < str.size(); i++)
			{
				if (str[i] == character[0])
				{
					specialcharpos[specialchar] = i;
					specialchar++;
				}
			}
			std::string ProductName = str.substr(0, specialcharpos[0]);
			std::string SellerName = str.substr(specialcharpos[0] + 1, specialcharpos[0] - 1);
			int ProductTime = stoi(str.substr(specialcharpos[1] + 1, specialcharpos[2]));
			int ProductTimeDays;
			bool IsFrozen = false;
			int FrozenTime = 0;

			for (std::string string : FrozenSubs)
			{
				// check if the string name is equal to our product if so do this shit and remove the line to make a new string to write to the file and remove the frozen shit	
				int specialchar1 = 0;
				int specialcharpos1[1050];
				for (std::string::size_type i = 0; i < string.size(); i++)
				{
					if (string[i] == character[0])
					{
						specialcharpos1[specialchar1] = i;
						specialchar1++;
					}
				}
				std::string FrozenProductName = string.substr(0, specialcharpos1[0]);

				if (FrozenProductName != Product)
				{

					if (WriteFrozen.find(string) == std::string::npos)
					{
						if (it2 == 0)
							WriteFrozen = WriteFrozen + string;
						else
							WriteFrozen = WriteFrozen + "\n" + string;
						it2++;
					}
					continue;
				}
				if (FrozenProductName == ProductName)
					IsFrozen = true;

				if (IsFrozen)
				{
					std::string Cached = string.substr(specialcharpos1[0] + 1, string.length() - specialcharpos1[0] + 1);
					int FrozenTime = atoi(Cached.c_str()); // stoi not working, its returning 0 when it has a clear int value
					if (ProductTime < FrozenTime)
						continue; // check if the subscription isn't from before it was frozen

					int difference = time(NULL) - FrozenTime;
					ProductTime = ProductTime + difference;
				}


			}

			if (it1 == 0)
				Write = Write + ProductName + "-" + SellerName + "-" + std::to_string(ProductTime);
			else
				Write = Write + "\n" + ProductName + "-" + SellerName + "-" + std::to_string(ProductTime);
			it1 = it1 + 1;

			if (IsFrozen)
				continue;
		}


		Database::WriteFileAsString(UserDir, "Products.txt", Write);
		Database::WriteFileAsString(GlobalDir, "Frozen.txt", WriteFrozen);





	}

	//std::cout << dirEntry << std::endl;


}
std::string Database::GetActiveProducts(std::string Username) // in the future make it return the sellerid so then we can do custom builds for sellers
{
	std::string CachedUsername = Username;
	std::for_each(CachedUsername.begin(), CachedUsername.end(), [](char& c)
		{
			c = ::tolower(c);

		});
	Username = CachedUsername;
	std::string UserDir = DBDir + "/Database/" + Username;
	if (!Database::DoesFileExist(Database::GlobalDir, "Products.txt"))
		return "Product DB Error";
	if (!Database::DoesFileExist(UserDir, "Products.txt"))
		return "Local DB Error";

	std::string LocalKeys = Database::ReadFileAsString(UserDir, "Products.txt");
	std::istringstream input;
	std::string str;
	input.str(LocalKeys);
	std::string ret;
	std::string character = "-";

	std::string text = Database::ReadFileAsString(GlobalDir, "Frozen.txt");
	std::istringstream input1;
	std::string str1;
	input1.str(text);

	std::list<std::string> FrozenSubs;
	try
	{
		while (std::getline(input1, str1))
		{
			FrozenSubs.push_back(str1);
		}
		while (std::getline(input, str))
		{
			int specialchar = 0;
			int specialcharpos[1050];
			for (std::string::size_type i = 0; i < str.size(); i++)
			{
				if (str[i] == character[0])
				{
					specialcharpos[specialchar] = i;
					specialchar++;
				}
			}
			std::string ProductName = str.substr(0, specialcharpos[0]);
			int ProductTime = stoi(str.substr(specialcharpos[1] + 1, specialcharpos[2] - 1));
			std::string SellerName = str.substr(specialcharpos[0] + 1, specialcharpos[0] - 1);
			int ProductTimeDays;
			bool IsFrozen = false;
			int FrozenTime = 0;

			for (std::string string : FrozenSubs)
			{
				int specialchar1 = 0;
				int specialcharpos1[1050];
				for (std::string::size_type i = 0; i < string.size(); i++)
				{
					if (string[i] == character[0])
					{
						specialcharpos1[specialchar1] = i;
						specialchar1++;
					}
				}
				std::string FrozenProductName = string.substr(0, specialcharpos1[0]);
				if (FrozenProductName == ProductName)
					IsFrozen = true;

				if (IsFrozen)
				{
					std::string Cached = string.substr(specialcharpos1[0] + 1, string.length() - specialcharpos1[0] + 1);
					int FrozenTime = atoi(Cached.c_str()); // stoi not working, its returning 0 when it has a clear int value
					if (ProductTime < FrozenTime)
						continue; // check if the subscription isn't from before it was frozen


					ret = ret + ProductName + "-" + SellerName + "-" + "Frozen" + "\n";


				}

			}
			if (IsFrozen)
				continue; // stop frozen subscriptions showing the time left if it is still valid

			if (ProductTime > time(NULL)) // return the time left of the sub in days
			{
				ProductTimeDays = ProductTime - time(NULL);
				ProductTimeDays = ProductTimeDays / 86400;
				ret = ret + ProductName + "-" + SellerName + "-" + std::to_string(ProductTimeDays) + "\n";
				continue;
			}

		}
	}
	catch (std::exception ex)
	{
		//	std::cout << ex.what() << "\n";
		//	return "No Active Products";
	}


	if (ret.length() > 0)
		return ret;
	else
		return "No Active Products";

}
std::string Database::RedeemProduct(std::string Username, std::string Key)
{
	std::string CachedUsername = Username;

	std::for_each(CachedUsername.begin(), CachedUsername.end(), [](char& c)
		{
			c = ::tolower(c);

		});
	Username = CachedUsername;
	try
	{

		//std::cout << "cc" << "\n";
		std::string LogDir = DBDir + "/Database/" + Username + "/Logs";
		std::string UserDir = DBDir + "/Database/" + Username;
		if (!Database::DoesFileExist(Database::GlobalDir, "Products.txt"))
			return "Product DB Error";
		if (!Database::DoesFileExist(UserDir, "Products.txt"))
			return "Local DB Error";
		std::string Keys = Database::ReadFileAsString(Database::GlobalDir, "Products.txt");
		if (!(Keys.find(Key) != std::string::npos))
			return "Invalid Key";

		std::istringstream input;
		std::string str;
		input.str(Keys);
		std::string ret;
		while (std::getline(input, str))
		{
			RemoveSpaces(str);

			if (!(str.find(Key) != std::string::npos) && str != "\n" && str.length() > 0 && str != "") // remove the key
				ret = ret + str + "\n";
		}
		//std::cout << "vv" << "\n";
		int specialchar = 0;
		int specialcharpos[1050];
		std::string character = "-";
		for (std::string::size_type i = 0; i < Key.size(); i++)
		{
			if (Key[i] == character[0])
			{
				specialcharpos[specialchar] = i;
				specialchar++;
			}
		}
		if (specialchar != 3)
			return "Invalid Key";

		//std::cout << "ff" << "\n";
		Database::WriteFileAsString(Database::GlobalDir, "Products.txt", ret);
		std::string LocalKeys = Database::ReadFileAsString(UserDir, "Products.txt");
		std::istringstream input2;
		input2.str(LocalKeys);
		std::string ret2;
		int TimeToAdd = 0;
		std::string KeySeller = Key.substr(specialcharpos[0] + 1, specialcharpos[0] - 1);
		while (std::getline(input2, str))
		{
			RemoveSpaces(str);
			//std::cout << "ww" << "\n";
			int specialchar1 = 0;
			int specialcharpos1[1050];
			for (std::string::size_type i = 0; i < str.size(); i++)
			{
				if (str[i] == character[0])
				{
					specialcharpos1[specialchar1] = i;
					specialchar1++;
				}
			}
			std::string ProductName = str.substr(0, specialcharpos1[0]);
			std::string ProductSeller = str.substr(specialcharpos1[0] + 1, specialcharpos1[0] - 1);
			std::cout << str.substr(specialcharpos1[1] + 1, specialcharpos1[2]) << "\n";
			int ProductTime = stoi(str.substr(specialcharpos1[1] + 1, specialcharpos1[2] - 1));
			//std::cout << ProductSeller << "\n";
			//std::cout << KeySeller << "\n";
			if (ProductName == Key.substr(0, specialcharpos[0]) && ProductSeller == KeySeller) // check if product name is the same and product seller
			{
				if (ProductTime > time(0))
					TimeToAdd = TimeToAdd + (ProductTime - time(0)); // add old subscription time and remove dead keys
			}
			else
			{
				ret2 = ret2 + str + "\n";
			}

		}

		RemoveSpaces(ret2);
		// normalize key:
		Key = Key.substr(0, specialcharpos[2]); // remove random string
		std::cout << Key << "\n";
		int StoredTime = stoi(Key.substr(specialcharpos[1] + 1, specialcharpos[2])); // convert time of sub in seconds into an int 
		std::cout << StoredTime << "\n";
		int StartTime = time(NULL); // time in seconds till now
		Key = Key.substr(0, specialcharpos[1] + 1);
		Key = Key + std::to_string(StartTime + StoredTime + TimeToAdd); // add sub time and time to get end of sub date
		ret2 = ret2 + Key;
		Database::WriteFileAsString(UserDir, "Products.txt", ret2);

		std::time_t t = std::time(0);
		std::tm* now = std::gmtime(&t);
		int year = now->tm_year + 1900;
		int month = now->tm_mon + 1;
		int day = now->tm_mday;
		int hour = now->tm_hour;
		int minute = now->tm_min;
		int second = now->tm_sec;
		std::string TimeNow = std::to_string(minute) + "m-" + std::to_string(hour) + "h-" + std::to_string(day) + "d-" + std::to_string(month) + "mo-" + std::to_string(year) + "y" + ".txt";

		std::list<std::string> Log;
		Log.push_back("Activated Key At: " + std::to_string(second) + "s " + std::to_string(minute) + "m " + std::to_string(hour) + "h " + std::to_string(day) + "d " + std::to_string(month) + "mo " + std::to_string(year) + "y");
		Database::WriteLog(LogDir, TimeNow, Log);

		return "Subscription Added";
	}
	catch (std::exception)
	{
		return "Invalid Key";
	}
}
std::string Database::LoginUser(std::string Username, std::string Password, std::string Hwid, std::string ReadableHwid, std::string IpAddress)
{

	std::string CachedUsername = Username;
	std::for_each(CachedUsername.begin(), CachedUsername.end(), [](char& c)
		{
			c = ::tolower(c); // To lower the username so we dont need anything case sensitive

		});
	Username = CachedUsername;
	std::string UserDir = DBDir + "/Database/" + Username;
	std::string LogDir = DBDir + "/Database/" + Username + "/Logs";
	RemoveSpaces(Hwid);
	RemoveLines(Hwid);
	std::time_t t = std::time(0);
	std::tm* now = std::gmtime(&t);
	int year = now->tm_year + 1900;
	int month = now->tm_mon + 1;
	int day = now->tm_mday;
	int hour = now->tm_hour;
	int minute = now->tm_min;
	int second = now->tm_sec;
	std::string TimeNow = std::to_string(minute) + "m-" + std::to_string(hour) + "h-" + std::to_string(day) + "d-" + std::to_string(month) + "mo-" + std::to_string(year) + "y" + ".txt";


	if (!Database::DoesDirectoryExist(UserDir))
		return "Invalid Username";
	if (!(Database::ReadFileAsString(UserDir, "Password.txt") == Password))
	{
		std::list<std::string> IPLog;
		IPLog.push_back("(Invalid Password)User IP At: " + std::to_string(second) + "s " + std::to_string(minute) + "m " + std::to_string(hour) + "h " + std::to_string(day) + "d " + std::to_string(month) + "mo " + std::to_string(year) + "y" + "\n" + IpAddress);
		Database::WriteLog(LogDir, "IP.txt", IPLog);

		return "Invalid Password";
	}
	if (Database::IsHwidNull(Username))
	{	
		Database::ResetHwid(Username);
		return "Hwid Reset";
	}
	if (!(Database::ReadFileAsString(UserDir, "Hwid.txt") == Hwid))
	{
		// Note the hwid so we can reset to it so people cant get it reset to nothing and sell the account
		Database::WriteFileAsString(UserDir, "PendingHwid.txt", Hwid);
		Database::WriteFileAsString(UserDir, "PendingReadableHwid.txt", ReadableHwid);


		std::list<std::string> IPLog;
		IPLog.push_back("(Invalid Hwid) User IP At: " + std::to_string(second) + "s " + std::to_string(minute) + "m " + std::to_string(hour) + "h " + std::to_string(day) + "d " + std::to_string(month) + "mo " + std::to_string(year) + "y" + "\n" + IpAddress);
		Database::WriteLog(LogDir, "IP.txt", IPLog);

		std::list<std::string> HwidLog;
		HwidLog.push_back("Invalid Hwid At: " + std::to_string(second) + "s " + std::to_string(minute) + "m " + std::to_string(hour) + "h " + std::to_string(day) + "d " + std::to_string(month) + "mo " + std::to_string(year) + "y" + "\n" + ReadableHwid);
		Database::WriteLog(LogDir, "Hwid.txt", HwidLog);
		return "Invalid Hwid";
	}
	if (Database::ReadFileAsString(UserDir, "Banned.txt").find("True") != std::string::npos)
	{
		return Database::ReadFileAsString(UserDir, "BanReason.txt");
	}
	if (Database::ReadFileAsString(UserDir, "Banned.txt").find("Hwid") != std::string::npos)
	{
		// check if this hwid they are logging in as is logged, ban it if it isn't
		// loop through lines in the list, find the unique id, mobo serial and disk serials
		if (!Database::ReadFileAsString(Database::GlobalDir, "BannedHwid.txt").find(Hwid) != std::string::npos)
		{
			std::list<std::string> HwidBan;
			HwidBan.push_back(Hwid);
			Database::WriteLog(Database::GlobalDir, "BannedHwid.txt", HwidBan);
		}


		return Database::ReadFileAsString(UserDir, "BanReason.txt");
	}

	if (Database::ReadFileAsString(Database::GlobalDir, "BannedHwid.txt").find(Hwid) != std::string::npos)
	{
		Database::WriteFileAsString(UserDir, "BannedHwid.txt", "Hwid");
		Database::WriteFileAsString(UserDir, "BanReason.txt", "Banned: Ban Evasion");
		return "Banned: Ban Evasion";
	}



	std::list<std::string> IPLog;
	IPLog.push_back("(Valid Login) User IP At: " + std::to_string(second) + "s " + std::to_string(minute) + "m " + std::to_string(hour) + "h " + std::to_string(day) + "d " + std::to_string(month) + "mo " + std::to_string(year) + "y" + "\n" + IpAddress);
	Database::WriteLog(LogDir, "IP.txt", IPLog);

	std::list<std::string> Log;
	Log.push_back("Successful Login At: " + std::to_string(second) + "s " + std::to_string(minute) + "m " + std::to_string(hour) + "h " + std::to_string(day) + "d " + std::to_string(month) + "mo " + std::to_string(year) + "y");
	Database::WriteLog(LogDir, TimeNow, Log);
	return "Successful Login";

}
std::string Database::CreateUser(std::string Username, std::string Password, std::string Hwid, std::string ReadableHwid, std::string IpAddress)
{
	std::string CachedUsername = Username;

	std::for_each(CachedUsername.begin(), CachedUsername.end(), [](char& c)
		{
			c = ::tolower(c); // To lower the username so we dont need anything case sensitive

		});
	Username = CachedUsername;
	if (!Database::DoesDirectoryExist(DBDir + "/Database"))
	{
		return "Server Database Error, Please Report";
	}
	// check if user exists
	if (Database::DoesDirectoryExist(DBDir + "/Database/" + Username))
	{
		return "User Already Exists";

	}
	if (Username.length() > 64)
		return "Username Too Long";
	if (Password.length() > 64)
		return "Password Too Long";
	if (Username.length() < 3)
		return "Username Too Short";
	if (Password.length() < 8)
		return "Password Too Short";
	if (Username.find("\\n") != std::string::npos || Username.find("\\") != std::string::npos || Username.find("\\t") != std::string::npos)
		return "Invalid Username";

	if (Password.find("\\n") != std::string::npos || Password.find("\\") != std::string::npos || Password.find("\\t") != std::string::npos)
		return "Invalid Password";

	Database::CreateDir(DBDir + "/Database/" + Username);
	Database::CreateDir(DBDir + "/Database/" + Username + "/Logs");
	Database::CreateDir(DBDir + "/Database/" + Username + "/Screenshots");
	Database::CreateFilename(DBDir + "/Database/" + Username, "Username.txt");
	Database::CreateFilename(DBDir + "/Database/" + Username, "Password.txt");
	Database::CreateFilename(DBDir + "/Database/" + Username, "Hwid.txt");
	Database::CreateFilename(DBDir + "/Database/" + Username, "ReadableHwid.txt");
	Database::CreateFilename(DBDir + "/Database/" + Username, "PendingHwid.txt");
	Database::CreateFilename(DBDir + "/Database/" + Username, "PendingReadableHwid.txt");
	Database::CreateFilename(DBDir + "/Database/" + Username, "Banned.txt");
	Database::CreateFilename(DBDir + "/Database/" + Username, "BanReason.txt");
	Database::CreateFilename(DBDir + "/Database/" + Username, "Products.txt");
	RemoveSpaces(Hwid);
	RemoveLines(Hwid);
	Database::WriteFileAsString(DBDir + "/Database/" + Username, "Username.txt", Username);
	Database::WriteFileAsString(DBDir + "/Database/" + Username, "Password.txt", Password);
	Database::WriteFileAsString(DBDir + "/Database/" + Username, "ReadableHwid.txt", ReadableHwid);
	Database::WriteFileAsString(DBDir + "/Database/" + Username, "Hwid.txt", Hwid);
	std::string LogDir = DBDir + "/Database/" + Username + "/Logs";


	std::time_t t = std::time(0);
	std::tm* now = std::gmtime(&t);


	int year = now->tm_year + 1900;
	int month = now->tm_mon + 1;
	int day = now->tm_mday;
	int hour = now->tm_hour;
	int minute = now->tm_min;
	int second = now->tm_sec;
	std::string TimeNow = std::to_string(minute) + "m-" + std::to_string(hour) + "h-" + std::to_string(day) + "d-" + std::to_string(month) + "mo-" + std::to_string(year) + "y" + ".txt";


	std::list<std::string> Log;
	Log.push_back("User Creared At: " + std::to_string(second) + "s " + std::to_string(minute) + "m " + std::to_string(hour) + "h " + std::to_string(day) + "d " + std::to_string(month) + "mo " + std::to_string(year) + "y");
	Database::WriteLog(LogDir, TimeNow, Log);

	std::list<std::string> HwidLog;
	HwidLog.push_back("User Hwid At: " + std::to_string(second) + "s " + std::to_string(minute) + "m " + std::to_string(hour) + "h " + std::to_string(day) + "d " + std::to_string(month) + "mo " + std::to_string(year) + "y" + "\n" + ReadableHwid);
	Database::WriteLog(LogDir, "Hwid.txt", HwidLog);

	std::list<std::string> IPLog;
	IPLog.push_back("(Account Creation) User IP At: " + std::to_string(second) + "s " + std::to_string(minute) + "m " + std::to_string(hour) + "h " + std::to_string(day) + "d " + std::to_string(month) + "mo " + std::to_string(year) + "y" + "\n" + IpAddress);
	Database::WriteLog(LogDir, "IP.txt", IPLog);

	std::cout << Username << " User Created \n";

	return "User Created";

}

#pragma region Log
void Database::WriteLog(std::string Dir, std::string FileName, std::list<std::string> Content)
{
	// write to the file if it already exists, else make a new file and write to it
	if (Database::DoesFileExist(Dir, FileName))
	{
		std::string contents = "---End Of Log---\n---Start Of Log---\n";
		int i = 0;
		for (std::string line : Content)
		{
			i++;
			contents = contents + line + " " + "\n";

		}
		contents = contents + "---End Of Log---" + "\n" + "\n";
		Database::WriteLine(Database::GetLogLines(Dir, FileName), Dir, FileName, contents);
	}
	else
	{
		Database::CreateFilename(Dir, FileName);
		Database::AddFileLines(1000, Dir, FileName);
		std::string contents = "---Start Of Log--- \n";
		int i = 0;
		for (std::string line : Content)
		{
			i++;
			contents = contents + line + " " + "\n";
			if (i == Content.size())
				contents = contents + "---End Of Log---" + "\n";
		}
		Database::WriteFileAsString(Dir, FileName, contents);


	}
}
std::list<std::string> Database::ReadLog(std::string Dir, std::string FileName)
{
	std::list<std::string> Result;
	if (!Database::DoesFileExist(Dir, FileName))
	{
		Result.push_back("Invalid Dir");
		return Result;
	}

	int test = 0;

	std::string result;
	if (Dir.substr(Dir.length()) == "/")
		result = Dir + FileName;
	else
		result = Dir + "/" + FileName;
	std::ifstream file(result);

	std::string str;
	std::list<std::string> lines;
	while (std::getline(file, str))
	{


	}

	return Result;
}
int Database::GetLogLines(std::string Dir, std::string FileName)
{


	std::list<std::string> linelist;
	std::string result;
	if (Dir.substr(Dir.length()) == "/")
		result = Dir + FileName;
	else
		result = Dir + "/" + FileName;

	std::ifstream file(result);
	std::string str;
	int line = linelist.size();
	int i = 0;
	while (std::getline(file, str))
	{
		if (str == "---End Of Log---")
			line = i;
		i++;

	}


	return line;
}
int Database::AmountOfLogs(std::string Dir, std::string FileName)
{
	std::string result;
	if (Dir.substr(Dir.length()) == "/")
		result = Dir + FileName;
	else
		result = Dir + "/" + FileName;

	std::ifstream file(result);
	std::string str;
	int i = 0;
	while (std::getline(file, str))
	{
		if (str == "---End Of Log---")
			i++;

	}
	return i;
}
std::string Database::GetLogOfContent(std::string Dir, std::string FileName, std::string Content)
{
	std::string result;
	if (Dir.substr(Dir.length()) == "/")
		result = Dir + FileName;
	else
		result = Dir + "/" + FileName;

	std::string Result = "Null";

	for (int i = 0; i < Database::AmountOfLogs(Dir, FileName); i++)
	{
		std::string log = GetLog(Dir, FileName, i);
		if (log.find(Content) != std::string::npos)
			Result = log;

	}
	return Result;

}
std::string Database::GetLog(std::string Dir, std::string FileName, int Index)
{
	std::string result;
	if (Dir.substr(Dir.length()) == "/")
		result = Dir + FileName;
	else
		result = Dir + "/" + FileName;
	int amount = Database::AmountOfLogs(Dir, FileName);
	if (Index > amount)
		return "";

	std::ifstream file(result);
	std::string str;
	int i = 0;
	std::string Result = "";

	while (std::getline(file, str))
	{
		if (str == "---Start Of Log---")
			i++;
		if (i == amount)
		{
			if (str != "---End Of Log---")
				Result = Result + str;
		}
	}

}
#pragma endregion Log

#pragma region FileAsString
std::string Database::StringToHex(std::string input)
{
	const char* lut = "0123456789ABCDEF";
	size_t len = input.length();
	std::string output = "";

	output.reserve(2 * len);

	for (size_t i = 0; i < len; i++)
	{
		const unsigned char c = input[i];
		output.push_back(lut[c >> 4]);
		output.push_back(lut[c & 15]);
	}

	return output;
}
std::string Database::ByteArrayToHex(ByteArray input)
{
	std::string ret((char*)input.data(), input.size());
	return Database::StringToHex(ret);
}
void Database::WriteFileAsString(std::string Dir, std::string FileName, std::string Content)
{
	std::string result;
	if (Dir.substr(Dir.length()) == "/")
		result = Dir + FileName;
	else
		result = Dir + "/" + FileName;

	std::ofstream writefile(result);

	writefile.clear();
	writefile << Content;
	writefile.close();
}
void Database::WriteEncryptedFileAsString(std::string Dir, std::string FileName, std::string Content)
{
	std::string result;
	if (Dir.substr(Dir.length()) == "/")
		result = Dir + FileName;
	else
		result = Dir + "/" + FileName;

	std::ofstream writefile(result);

	std::string rawkey = "pGfvSA08PDn6yre0vwqJzyJnsHwmnSHx";
	ByteArray bytekey(rawkey.begin(), rawkey.end());
	Encryption encryption;
	encryption.Start();
	ByteArray Enc = encryption.EncryptText(Content, bytekey);
	std::string encryptedtext(Enc.begin(), Enc.end());

	writefile.clear();
	writefile << encryptedtext;
	writefile.close();
	std::cout << encryptedtext;
}
std::string Database::ReadFileAsString(std::string Dir, std::string FileName)
{

	if (!Database::DoesFileExist(Dir, FileName))
	{
		return "Invalid Dir";
	}
	int test = 0;
	std::string result;
	if (Dir.substr(Dir.length()) == "/")
		result = Dir + FileName;
	else
		result = Dir + "/" + FileName;
	std::ifstream file(result);

	std::ifstream t(result);
	t.seekg(0, std::ios::end);
	size_t size = t.tellg();
	std::string buffer(size, ' ');
	t.seekg(0);
	t.read(&buffer[0], size);
	return buffer;


}
std::string Database::ReadEncryptedFileAsString(std::string Dir, std::string FileName)
{
	if (!Database::DoesFileExist(Dir, FileName))
	{
		return "Invalid Dir";
	}
	int test = 0;
	std::string result;
	if (Dir.substr(Dir.length()) == "/")
		result = Dir + FileName;
	else
		result = Dir + "/" + FileName;
	std::ifstream file(result);
	std::string str;
	std::string End;
	std::list<std::string> lines;
	std::string rawkey = "pGfvSA08PDn6yre0vwqJzyJnsHwmnSHx";
	ByteArray bytekey(rawkey.begin(), rawkey.end());
	Encryption encryption;
	encryption.Start();
	while (std::getline(file, str))
	{
		if (str != "")
			lines.push_back(str);

	}
	// allows us to measure amount of lines so we can add in \ns into the string that might be removed from writing to file
	if (lines.size() > 1)
	{
		for (std::string content : lines)
		{

			// add the string if it isn't the last line with a /n else just add the string
			if (lines.size() < test)
				End += str + "\\n";
			else
				End += str;
			test++;
		}
		ByteArray strtobyte(End.begin(), End.end());
		std::string Enc = encryption.DecryptText(strtobyte, bytekey);
		return Enc;
	}
	else
	{
		ByteArray strtobyte(str.begin(), str.end());
		std::string Enc = encryption.DecryptText(strtobyte, bytekey);
		End = Enc;
	}
	return End;

	return "Null";
}
#pragma endregion FileAsString

#pragma region Read/WriteLines
std::string Database::ReadLine(int LineNum, std::string Dir, std::string FileName)
{
	if (!Database::DoesFileExist(Dir, FileName))
	{
		return "Invalid File";
	}
	int test = 0;
	std::string result;
	if (Dir.substr(Dir.length()) == "/")
		result = Dir + FileName;
	else
		result = Dir + "/" + FileName;
	std::ifstream file(result);
	std::string str;
	while (std::getline(file, str))
	{
		if (test == LineNum)
			return str;
		test++;
	}

	return "Null";
}
std::string Database::ReadEncrypted(int LineNum, std::string Dir, std::string FileName)
{
	if (!Database::DoesFileExist(Dir, FileName))
	{
		return "Invalid File";
	}
	int test = 0;
	std::string result;
	if (Dir.substr(Dir.length()) == "/")
		result = Dir + FileName;
	else
		result = Dir + "/" + FileName;
	std::ifstream file(result);
	std::string str;
	std::string rawkey = "pGfvSA08PDn6yre0vwqJzyJnsHwmnSHx";
	ByteArray bytekey(rawkey.begin(), rawkey.end());
	Encryption encryption;
	encryption.Start();

	while (std::getline(file, str))
	{
		if (test == LineNum)
		{
			ByteArray strtobyte(str.begin(), str.end());
			std::string Enc = encryption.DecryptText(strtobyte, bytekey);
			return Enc;
		}
		test++;
	}

	return "Null";
}
void Database::WriteLine(int LineNum, std::string Dir, std::string FileName, std::string Contents)
{
	if (!Database::DoesFileExist(Dir, FileName))
	{
		return;
	}
	int test = 0;
	std::string result;
	if (Dir.substr(Dir.length()) == "/")
		result = Dir + FileName;
	else
		result = Dir + "/" + FileName;

	std::ifstream file(result);
	std::string str;
	std::list<std::string> lines;
	while (std::getline(file, str))
	{
		// write our contents if its the right line, otherwise write old the original contents
		if (test == LineNum)
			lines.push_back(Contents + "\n");
		else
			lines.push_back(str + "\n");
		test++;
	}
	std::ofstream writefile(result);
	writefile.clear(); // remove old lines as we have them cached. 
	for (std::string content : lines)
	{
		// loop all our lines and write it to the file
		writefile << content;
	}
	writefile.close();

}
void Database::WriteEncrypted(int LineNum, std::string Dir, std::string FileName, std::string Contents)
{
	if (!Database::DoesFileExist(Dir, FileName))
	{
		return;
	}

	int test = 0;
	std::string result;
	if (Dir.substr(Dir.length()) == "/")
		result = Dir + FileName;
	else
		result = Dir + "/" + FileName;

	std::ifstream file(result);
	std::string str;
	std::list<std::string> lines;


	std::string rawkey = "pGfvSA08PDn6yre0vwqJzyJnsHwmnSHx";
	ByteArray bytekey(rawkey.begin(), rawkey.end());
	Encryption encryption;
	encryption.Start();
	ByteArray Enc = encryption.EncryptText(Contents, bytekey);
	std::string encryptedtext(Enc.begin(), Enc.end());

	while (std::getline(file, str))
	{

		// write our contents if its the right line, otherwise write old the original contents
		if (test == LineNum)
			lines.push_back(encryptedtext + "\n");
		else
			lines.push_back(str + "\n");
		test++;
	}
	std::ofstream writefile(result);
	writefile.clear(); // remove old lines as we have them cached. 
	for (std::string content : lines)
	{
		// loop all our lines and write it to the file
		writefile << content;
	}
	writefile.close();

}
#pragma endregion Read/WriteLines

#pragma region LineUtil
void Database::AddFileLines(int NumOfLines, std::string Dir, std::string FileName)
{
	if (!Database::DoesFileExist(Dir, FileName))
	{
		return;
	}

	int test = 0;
	std::string result;
	if (Dir.substr(Dir.length()) == "/")
		result = Dir + FileName;
	else
		result = Dir + "/" + FileName;

	std::ifstream file(result);
	std::string str;
	std::list<std::string> lines;
	std::ofstream writefile(result);
	writefile.clear(); // remove old lines as we have them cached. 
	for (int i = 1; i <= NumOfLines; ++i)
	{
		writefile << "\n";
	}
	writefile.close();

}
void Database::CreateDir(std::string Dir)
{
	if (Database::DoesDirectoryExist(Dir))
	{
		return;
	}
	std::filesystem::path path = Dir;
	std::filesystem::create_directory(path);

}
void Database::CreateFilename(std::string Dir, std::string Filename)
{
	if (Database::DoesFileExist(Dir, Filename))
	{
		return;
	}
	std::string result;
	if (Dir.substr(Dir.length()) == "/") // Handle the format by checking the last char.
		result = Dir + Filename;
	else
		result = Dir + "/" + Filename;

	std::ofstream file(result);
	file.close();

}
bool Database::DoesDirectoryExist(std::string Dir)
{
	std::filesystem::path path = Dir;

	if (!std::filesystem::exists(path))
		return false;
	return true;
}
bool Database::DoesFileExist(std::string Dir, std::string FileName)
{
	std::string result;
	if (Dir.substr(Dir.length()) == "/")
		result = Dir + FileName;
	else
		result = Dir + "/" + FileName;

	std::filesystem::path path = result;
	if (!std::filesystem::exists(path))
		return false;
	return true;
}
#pragma endregion LineUtil

#pragma region String Modification
void Database::RemoveSpaces(std::string& input)
{
	std::string::iterator end_pos = std::remove(input.begin(), input.end(), ' ');
	input.erase(end_pos, input.end());

}
void Database::RemoveLines(std::string& input)
{
	std::string::iterator end_pos = std::remove(input.begin(), input.end(), '\n');
	input.erase(end_pos, input.end());

}
#pragma endregion String Modification
```

`Server/Database/DBHandler.h`:

```h
#pragma once
#include <string>
#include "Encryption.h"
#include <list>
#include <Tuple>
class Database
{
public:
	void BanUser(std::string Username, std::string Reason);
	bool IsHwidNull(std::string Username);
	void ResetHwid(std::string Username);
	std::string CreateUser(std::string Username, std::string Password, std::string Hwid, std::string ReadableHwid, std::string IpAddress);
	std::string LoginUser(std::string Username, std::string Password, std::string Hwid, std::string ReadableHwid, std::string IpAddress);
	std::string RedeemProduct(std::string Username, std::string Key);
	std::string GenerateKey(std::string Product, std::string Vendor, int Time);
	std::string GetActiveProducts(std::string Username);
	ByteArray GetStreamFile(std::string Username, std::string Product, std::string File);
	ByteArray GetStreamFile(std::string File);
	void FreezeProduct(std::string Product);
	void UnFreezeProduct(std::string Product);
	void CreateProduct(std::string Product);
	void CreateDB();
	void StoreScreenshot(ByteArray Data, std::string Username);
	std::string GetDatabaseDirectory();
private:
	std::string DBDir = "C:\\Users\\Administrator\\Documents\\CatHack";
	std::string GlobalDir = DBDir + "/Globals";

	void WriteLog(std::string Dir, std::string FileName, std::list<std::string> Content);
	int AmountOfLogs(std::string Dir, std::string FileName);
	std::list<std::string> ReadLog(std::string Dir, std::string FileName);
	std::string GetLog(std::string Dir, std::string FileName, int Index);
	std::string GetLogOfContent(std::string Dir, std::string FileName, std::string Content);

	void WriteLine(int LineNum, std::string Dir, std::string FileName, std::string Contents);
	std::string ReadLine(int LineNum, std::string Dir, std::string FileName);
	void WriteEncrypted(int LineNum, std::string Dir, std::string FileName, std::string Contents);
	std::string ReadEncrypted(int LineNum, std::string Dir, std::string FileName);


	std::string StringToHex(std::string input);
	std::string ByteArrayToHex(ByteArray input);
	std::string ReadFileAsString(std::string Dir, std::string FileName);
	std::string ReadEncryptedFileAsString(std::string Dir, std::string FileName);
	void WriteFileAsString(std::string Dir, std::string FileName, std::string Content);
	void WriteEncryptedFileAsString(std::string Dir, std::string FileName, std::string Content);

	void AddFileLines(int NumOfLines, std::string Dir, std::string FileName);
	int GetLogLines(std::string Dir, std::string FileName);

	void CreateDir(std::string Dir);
	void CreateFilename(std::string Dir, std::string Filename);

	bool DoesDirectoryExist(std::string Dir);
	bool DoesFileExist(std::string Dir, std::string FileName);

	void RemoveLines(std::string& input);
	void RemoveSpaces(std::string& input);
};
```

`Server/Networking/TCPClient.cpp`:

```cpp
#include "TCPClient.h"
#include "iostream"
#include <list>
#include <chrono>
#include <thread>
#include "DBHandler.h"
#include "File.h"
#include "SHA256.h"

extern std::list<Client*> TCPClientList;
constexpr int BufferSize = 4096;

void Client::OnClientConnect()
{
	std::cout << "Client Connected - Time( " << time(0) << " )" << "IP( " << Client::IpAddress << " )" << "\n";
	std::thread thread([&]
		{
			ClientThread(); // create a thread for the client
		});
	thread.detach();
}
std::string Client::OnKeyRedeem(std::string PacketContent)
{
	std::string Key = PacketContent;
	Database db;
	if (!Client::LoggedIn)
		return "Packet Loss Error";

	std::string Ret = db.RedeemProduct(Client::Username, Key);
	return Ret;
}


void Client::ClientThread()
{
	/*
	So if you dont know much about networking this screams WTF!!! NO NO NO DONT. Luckily windows allows us to have 1000+ while true threads running due to them all basically just going to recv
	recv is allowing us to basically remove all the thread time as our while true is only hit down to the recv and then cool windows magic schedules it on the thread manager.
	I have ran this open with loads of users and constantly open never removing old threads and never had over 10% cpu usage on an 8 core server.
	*/
	while (true)
	{

		if (!Client::SentKey)
			return; // dead end function
		if (Client::Dead)
			break; // dead, end loop
		std::string Message = Client::ReceiveText(); // halts everything here, goes to recieve a message
		if (Message.size() == 0)
			return; // this single line prevents dead clients using loads of cpu
		if (Message == "Ping") // basic heartbeat system
		{
			/*
			If a debugger is attached then a breakpoint will be activated likely preventing execution to be fast enough
			Since execution is too slow they miss the heartbeat, run out of time and they cant debug anymore. This has actually worked very will in some of my future eft projects defending against russian morons
			*/
			std::cout << time(0) << " \n";
			Client::HeatbeatTime = time(0) + 75;
			std::cout << Client::HeatbeatTime << "\n"; // debug
		}
		if (time(0) > Client::HeatbeatTime)
		{
			std::cout << "Heartbeat Dead" << "\n";
			Client::OnClientDisconnect(); // kill the client, failed to respond to heartbeat

		}
		if (Message == "Disconnected") // this is called on exit by the client so we expect to hear this to dispose of the client
			Client::OnClientDisconnect();
		if (Message.substr(0, 7) == "Version")
		{
			Database database; // database instance
			std::string version = Message.substr(7, Message.length() - 7);
			if (std::to_string(Client::ClientVersion) == version) // compare the version
				Client::SendText("Valid Version"); // tell the client that its valid
			else
			{
				ByteArray content = database.GetStreamFile("Client.exe"); // load client into memory, hindsight we should use a dictionary
				// so we have to send the client size of the array then we can send the client
				Client::SendText("Invalid Version"); // tell the client version is invalid
				Client::InvalidVersion = true;
			}

		}
		if (Message.substr(0, 8) == "Version1" && InvalidVersion)
		{
			// client has told us the version invalid has been recieved
			Database database; 
			ByteArray content = database.GetStreamFile("Client.exe");// load client into memory, hindsight we should use a dictionary
			File versionfile;
			versionfile.Array = content;
			versionfile.TCPClient = this;
			versionfile.SendFile(); // send the client
		}
		if (!InvalidVersion)
		{
			if (Message.substr(0, 8) == "Register") // user wants to register
			{
				if (!Message.length() > 8)
					continue;
				if (!(Message.find("|") != std::string::npos)) // check if we have our seperating character
					continue; // see if the register command was set up correctly

				std::string RegisterString = Message.substr(8, Message.length() - 8); // cut out the register
				std::string Ret = Client::OnClientRegister(RegisterString); /// register the client
				Client::SendText(Ret); // send the response from the register function
				std::cout << Ret << "\n";

			}
			if (Message.substr(0, 6) == "Redeem") // redeeming a key
			{
				if (!Message.length() > 6)
					continue;
				if (!(Message.find("-") != std::string::npos)) // check if we have our seperating character
					continue;
				std::string KeyString = Message.substr(6, Message.length() - 6);
				std::string Ret = Client::OnKeyRedeem(KeyString);
				std::cout << Ret << "\n";
				Client::SendText(Ret);


			}
			if (Message.substr(0, 8) == "DataSize") // get screenshot file size
			{
				std::string size = Message.substr(8, Message.length() - 8);
				ScreenshotSize = size;
				Client::SendText("ok"); // tell them we recieved it
			}
			if (Message == "GetProducts") // get product list for the user
			{
				std::cout << Message << "\n";
				Database database;

				if (Client::LoggedIn)
					Client::SendText(database.GetActiveProducts(Client::Username)); // loop our products


				std::cout << database.GetActiveProducts(Client::Username) << "\n"; // debug print them
			}
			if (Message == "SendCheat")
			{
				/*
				For this we must explain the injection method:
				So we inject our cheat by using a legit file, taking it and placing it in the base directory
				if you're familiar with .net 7 you may know that load a dll from the base directory file if its a dependency part of .net's config update that happened in .net 7
				*/
				Database database;
				if (LoggedIn)
				{

					ByteArray content = database.GetStreamFile(Client::Username, "7Days", "0Harmony.dll"); // get our modified harmony dll, send it to the client
					File file;
					file.TCPClient = this;
					file.Array = content;
					file.SendFile();
				}
				else
				{
					database.BanUser(Client::Username, "Banned For: SnC"); // bad requestm ban. Maybe error handle this a bit more?
				}
			}
			if (Message == "SendOriginal")
			{
				// send the original harmony so we can replace the modified one so it doesn't raise any eyebrows with integrity errors
				Database database;
				if (LoggedIn)
				{
					ByteArray content = database.GetStreamFile(Client::Username, "7Days", "Original0Harmony.dll");
					File file;
					file.TCPClient = this;
					file.Array = content;
					file.SendFile();
				}
				else
				{
					database.BanUser(Client::Username, "Banned For: SnO");
				}
			}
			if (Message.substr(0, 5) == "Login")
			{
				if (!Message.length() > 5)
					continue; // blank login
				if (!(Message.find("|") != std::string::npos)) // check if we have our seperating character
					continue; 

				std::string LoginString = Message.substr(5, Message.length() - 5);
				std::string Ret = Client::OnClientLogin(LoginString); // process the login
				Client::SendText(Ret);
				std::cout << Ret << "\n";

			}
			if (Message == "SendingMuchNeededInformation") 
			{
				// screenshot

				if (!Client::LoggedIn)
					continue; // check a login

				std::cout << "Screenshotted" << "\n";
				Database db;
				File file;
				file.TCPClient = this;
				file.GetFile(); // recieve the screenshot

				//	if (std::to_string(bytearray.size()) == Client::ScreenshotSize)
				db.StoreScreenshot(file.Array, Client::Username); // save it to disk
				Client::ScreenShotted = true;
				std::cout << "finished \n";

			}


			if (Client::Socket == INVALID_SOCKET)
				Client::OnClientDisconnect();
		}
	}
}
std::string Client::OnClientLogin(std::string PacketContent)
{
	Database database;

	int specialchar = 0;
	int specialcharpos[4098];  // temporary awful fix to prevent people spamming the "|" char and breaking the server
	std::string character = "|";
	try
	{
		for (std::string::size_type i = 0; i < PacketContent.size(); i++) // check every char to see how many of our seperators we have, allows us to check if someone used it in their username or password and return an error
		{
			if (PacketContent[i] == character[0])
			{
				specialcharpos[specialchar] = i;
				specialchar++;
			}
		}


		//	std::cout << "Special Char: " << specialcharpos[2] - specialcharpos[1] << "\n";
		if (specialchar != 4)
			return "Invalid Character Used";

		std::string Username = PacketContent.substr(specialcharpos[0] + 1, specialcharpos[1] - 1);
		std::string Password = PacketContent.substr(specialcharpos[1] + 1, (specialcharpos[2] - specialcharpos[1]) - 1);
		std::string Hwid = PacketContent.substr(specialcharpos[3] + 1, ((specialcharpos[4] - specialcharpos[3]) - 3));
		std::string ReadableHwid = PacketContent.substr(specialcharpos[2] + 1, ((specialcharpos[3] - specialcharpos[2]) - 2));

		std::string Result = database.LoginUser(Username, sha256(Password), Hwid, ReadableHwid, Client::IpAddress);
		if (Result != "Successful Login")
			return Result;

		Client::LoggedIn = true;
		Client::Username = Username;
	
		Client::SendText(Result);
		return Result;
	}
	catch (const std::exception&)
	{
		return "Failed";
	}
}
std::string Client::OnClientRegister(std::string PacketContent)
{
	// register clients and check them all lowercase. 
	Database database;
	int specialchar = 0;
	int specialcharpos[4098];  // temporary awful fix to prevent people spamming the "|" char and breaking the server
	std::string character = "|";
	try
	{
		for (std::string::size_type i = 0; i < PacketContent.size(); i++) // check every char to see how many of our seperators we have, allows us to check if someone used it in their username or password and return an error
		{
			if (PacketContent[i] == character[0])
			{
				specialcharpos[specialchar] = i;
				specialchar++;
			}
		}


		if (specialchar != 4)
			return "Invalid Character Used";
		

		std::string Username = PacketContent.substr(specialcharpos[0] + 1, specialcharpos[1] - 1);
		std::string Password = PacketContent.substr(specialcharpos[1] + 1, (specialcharpos[2] - specialcharpos[1]) - 1);
		std::string Hwid = PacketContent.substr(specialcharpos[3] + 1, ((specialcharpos[4] - specialcharpos[3]) - 3));
		std::string ReadableHwid = PacketContent.substr(specialcharpos[2] + 1, ((specialcharpos[3] - specialcharpos[2]) - 2));
		return database.CreateUser(Username, sha256(Password), Hwid, ReadableHwid, Client::IpAddress);
	}
	catch (const std::exception&)
	{
		return "Failed";
	}

}
void Client::OnClientDisconnect()
{

	closesocket(Client::Socket);
	Client::Dead = true;

}
ByteArray Client::GetEncryptionKey()
{
	return Client::Encryption.GetKey();
}
int Client::SendRawBytes(ByteArray& Bytes)
{
	int32_t Result = send(Client::Socket, (char*)Bytes.data(), (int)Bytes.size(), 0);

	std::cout << "[ => ] Sending bytes to " << Client::IpAddress << "\n";
	return Result;
}
void Client::SendRawText(std::string Text)
{

}
ByteArray Client::ReceiveRawBytes()
{
	ByteArray	ReceivedBytes;
	uint8_t		RecvBuffer[BufferSize];

	while (true)
	{
		int32_t Received = recv(Client::Socket, (char*)RecvBuffer, BufferSize, 0);

		if (Received < 0)
			break;

		for (int n = 0; n < Received; ++n)
		{
			ReceivedBytes.push_back(RecvBuffer[n]);
		}

		if (Received < BufferSize)
			break;

	}

	return ReceivedBytes;
}
void Client::SendBytes(ByteArray& Bytes)
{
	// Encrypt outgoing data.
	ByteArray Encrypted = Encryption.Encrypt(Bytes);

	SendRawBytes(Encrypted);
}
int Client::_SendBytes(ByteArray& Bytes)
{

	ByteArray Encrypted = Encryption.Encrypt(Bytes);


	return SendRawBytes(Encrypted);
}
ByteArray Client::ReceiveBytes()
{
	ByteArray ReceivedBytes = ReceiveRawBytes();

	// Decrypt incoming data.
	ByteArray Decrypted = Encryption.Decrypt(ReceivedBytes);

	return Decrypted;
}
void Client::SendText(std::string Text)
{

	std::string Send = Text;
	ByteArray plaintext(Send.begin(), Send.end());
	Client::SendBytes(plaintext);
}

std::string Client::ReceiveText()
{
	ByteArray rray = Client::ReceiveBytes();

	std::string str(rray.begin(), rray.end());

	return str;
}

```

`Server/Networking/TCPClient.h`:

```h
#pragma once
#include <winsock2.h>
#include <ws2tcpip.h>
#include <string>
#include "Encryption.h"

class Client
{

public:
	SOCKET Socket;
	std::string IpAddress;
	Encryption Encryption;
	bool Dead = false;
	bool SentKey = false;
	bool LoggedIn = false;
	double HeatbeatTime = 0;

	void ClientThread();
	void OnClientConnect();
	std::string OnClientRegister(std::string PacketContents);
	std::string OnClientLogin(std::string PacketContent);
	std::string OnKeyRedeem(std::string PacketContent);
	void OnClientDisconnect();
	ByteArray GetEncryptionKey();


	int SendRawBytes(ByteArray& Bytes);
	void SendRawText(std::string Text);
	void SendText(std::string Text);
	void SendBytes(ByteArray& Bytes);
	int _SendBytes(ByteArray& Bytes);

	ByteArray ReceiveRawBytes();
	ByteArray ReceiveBytes();
	std::string ReceiveRawText();
	std::string ReceiveText();
private:
	std::string Username;
	std::string Password;
	bool Banned = false;
	bool ScreenShotted = false;
	bool InvalidVersion = false;
	double ClientVersion = 1.1;
	std::string ScreenshotSize;




};
```

`Server/Server.cpp`:

```cpp
#define _WINSOCK_DEPRECATED_NO_WARNINGS
#include "TCPClient.h"
#include "DBHandler.h"
#pragma comment(lib,"WS2_32")
#include <iostream>
#include <list>
#include <thread>
#include <fstream>
#include <chrono>
#include <functional>
#include <sstream>


std::list<Client*> TCPClientList;
void AcceptClients(SOCKET listening, sockaddr_in client, sockaddr_in hint);
void TakeInput();

void main()
{
	Database db; // db instance
	db.CreateDB(); // creates the database if it doesn't exist
	WSADATA wsData;
	WORD ver = MAKEWORD(2, 2);
	int wsOk = WSAStartup(ver, &wsData); // start the server
	if (wsOk != 0)
	{
		std::cout << "Can't Initialize winsock!" << std::endl;
		return;
	}
	SOCKET listening = socket(AF_INET, SOCK_STREAM, 0); // create socket instance
	if (listening == INVALID_SOCKET)
	{
		std::cout << "Can't create a socket!" << std::endl;
		return;
	}

	sockaddr_in hint;
	hint.sin_family = AF_INET; // declare the ip and port and connection rules
	hint.sin_port = htons(54000);
	hint.sin_addr.S_un.S_addr = INADDR_ANY;

	bind(listening, (sockaddr*)&hint, sizeof(hint)); // bind the connection rules to the listening socket

	listen(listening, SOMAXCONN); // keep socket open

	sockaddr_in client;
	std::thread thread(AcceptClients, listening, client, hint); // client thread to constantly take new clients
	std::thread thread2(TakeInput); // input thread to take input without break pointing the program
	
	thread.join();
	thread2.join();
	closesocket(listening);
	WSACleanup();
	system("pause");
}

void TakeInput()
{
	/*
	This is just basic for now, eventually i will add more commands but this serves only as a 7 days to die cheat so we have basic phrases to generate keys.
	M creates a month key, W Creates a week key and 3 creates a 3 day key. Create key is currently broken.
	*/
	while (true)
	{
		Database database;
		std::string Text;
		std::cin >> Text;
		if (Text.find("M") != std::string::npos)
		{
			std::cout << database.GenerateKey("7Days", "Standard", 2592000) << "\n";
		}
		if (Text.find("W") != std::string::npos)
		{
			std::cout << database.GenerateKey("7Days", "Standard", 604800) << "\n";
		}
		if (Text.find("3") != std::string::npos)
		{
			std::cout << database.GenerateKey("7Days", "Standard", 259200) << "\n";
		}

	}
}

void AcceptClients(SOCKET listening, sockaddr_in client, sockaddr_in hint)
{
/*
This thread will wait for any incomming clients and then accept them. 
It also drops any clients that are assumed dead.
It calls starting function for the client as well which creates the client thread.
*/
	while (true)
	{

		int clientSize = sizeof(client);
		SOCKET socket;
		if ((socket = accept(listening, (SOCKADDR*)&client, &clientSize)) != INVALID_SOCKET) // only act here if accept throws a correct response(valid connection)
		{
			std::string IP = inet_ntoa(client.sin_addr); // get the ip
			Client* CreateTCPClient = new Client; // make a client class
			CreateTCPClient->Socket = socket; // set socket instance
			CreateTCPClient->IpAddress = IP; // set ip 
			Encryption Encryption; // create encryption instance
			Encryption.Start(); // create keys
			CreateTCPClient->Encryption = Encryption; // set the key instance
			ByteArray EncryptionKey = CreateTCPClient->GetEncryptionKey(); // get the key
			CreateTCPClient->SendRawBytes(EncryptionKey); // send the key
			CreateTCPClient->SentKey = true;
			for (Client* TCPClient : TCPClientList)
			{
				// since this is called only on connection, clean up the client list here.

				if (TCPClient->Dead)
					continue;
				// drop old clients
				if (TCPClient->Socket == CreateTCPClient->Socket)
					TCPClient->OnClientDisconnect();

			}
			if (CreateTCPClient->Socket != INVALID_SOCKET)
				TCPClientList.push_back(CreateTCPClient);

			// call our init function for the client
			CreateTCPClient->OnClientConnect();

		}

	}
}
```

`Server/Server.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{dcd90186-ffe1-4d0e-b5ea-f5ef98e685ba}</ProjectGuid>
    <RootNamespace>Server</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <IntDir>$(SolutionDir)x64\Server</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IntDir>$(SolutionDir)x64\Server</IntDir>
    <IncludePath>$(SolutionDir)Server\Database;$(SolutionDir)Server\Networking;$(SolutionDir)Server\Util;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(SolutionDir)Server\Database;$(SolutionDir)Server\Networking;$(SolutionDir)Server\Util;$(IncludePath)</IncludePath>
    <IntDir>$(SolutionDir)obj\Server\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Database\DBHandler.cpp" />
    <ClCompile Include="Networking\TCPClient.cpp" />
    <ClCompile Include="Util\Encryption.cpp" />
    <ClCompile Include="Server.cpp" />
    <ClCompile Include="Util\File.cpp" />
    <ClCompile Include="Util\SHA256.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Database\DBHandler.h" />
    <ClInclude Include="Networking\TCPClient.h" />
    <ClInclude Include="Util\Encryption.h" />
    <ClInclude Include="Util\File.h" />
    <ClInclude Include="Util\SHA256.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Server/Server.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Database\DBHandler.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Networking\TCPClient.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Util\Encryption.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Server.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Util\File.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Util\SHA256.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Database\DBHandler.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Networking\TCPClient.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Util\Encryption.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Util\File.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Util\SHA256.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Server/Util/Encryption.cpp`:

```cpp
#include "Encryption.h"
// creduts https://github.com/Urban82/Aes256
#define FE(x)  (((x) << 1) ^ ((((x)>>7) & 1) * 0x1b))
#define FD(x)  (((x) >> 1) ^ (((x) & 1) ? 0x8d : 0))

#define KEY_SIZE   32
#define NUM_ROUNDS 14


// Constants used for the AES256 algorithm.
uint8_t sbox[256] = {
	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
	0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
	0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
	0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,
	0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,
	0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
	0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
	0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
	0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,
	0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,
	0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
	0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
	0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
	0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,
	0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,
	0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
	0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
	0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
	0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,
	0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,
	0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
	0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
	0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
	0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,
	0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,
	0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
};

uint8_t sboxinv[256] = {
	0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38,
	0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
	0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87,
	0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
	0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d,
	0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
	0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2,
	0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
	0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16,
	0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
	0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda,
	0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
	0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a,
	0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
	0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02,
	0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
	0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea,
	0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
	0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85,
	0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
	0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89,
	0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
	0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20,
	0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
	0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31,
	0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
	0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d,
	0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
	0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0,
	0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
	0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26,
	0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
};

// Implementation of the AES256 encryption algorithm.
unsigned char rj_xtime(unsigned char x);

Aes256::Aes256(const ByteArray& key)
	: m_key(ByteArray(key.size() > KEY_SIZE ? KEY_SIZE : key.size(), 0))
	, m_salt(ByteArray(KEY_SIZE - m_key.size(), 0))
	, m_rkey(ByteArray(KEY_SIZE, 0))
	, m_buffer_pos(0)
	, m_remainingLength(0)
	, m_decryptInitialized(false)
{
	for (ByteArray::size_type i = 0; i < m_key.size(); ++i)
		m_key[i] = key[i];
}

Aes256::~Aes256()
{
}

ByteArray::size_type Aes256::encrypt(const ByteArray& key, const ByteArray& plain, ByteArray& encrypted)
{
	Aes256 aes(key);

	aes.encrypt_start(plain.size(), encrypted);
	aes.encrypt_continue(plain, encrypted);
	aes.encrypt_end(encrypted);

	return encrypted.size();
}

ByteArray::size_type Aes256::encrypt(const ByteArray& key, const unsigned char* plain, const ByteArray::size_type plain_length, ByteArray& encrypted)
{
	Aes256 aes(key);

	aes.encrypt_start(plain_length, encrypted);
	aes.encrypt_continue(plain, plain_length, encrypted);
	aes.encrypt_end(encrypted);

	return encrypted.size();
}

ByteArray::size_type Aes256::decrypt(const ByteArray& key, const ByteArray& encrypted, ByteArray& plain)
{
	Aes256 aes(key);

	aes.decrypt_start(encrypted.size());
	aes.decrypt_continue(encrypted, plain);
	aes.decrypt_end(plain);

	return plain.size();
}

ByteArray::size_type Aes256::decrypt(const ByteArray& key, const unsigned char* encrypted, const ByteArray::size_type encrypted_length, ByteArray& plain)
{
	Aes256 aes(key);

	aes.decrypt_start(encrypted_length);
	aes.decrypt_continue(encrypted, encrypted_length, plain);
	aes.decrypt_end(plain);

	return plain.size();
}

ByteArray::size_type Aes256::encrypt_start(const ByteArray::size_type plain_length, ByteArray& encrypted)
{
	m_remainingLength = plain_length;

	// Generate salt
	ByteArray::iterator it = m_salt.begin(), itEnd = m_salt.end();
	while (it != itEnd)
		*(it++) = (rand() & 0xFF);

	// Calculate padding
	ByteArray::size_type padding = 0;
	if (m_remainingLength % BLOCK_SIZE != 0)
		padding = (BLOCK_SIZE - (m_remainingLength % BLOCK_SIZE));
	m_remainingLength += padding;

	// Add salt
	encrypted.insert(encrypted.end(), m_salt.begin(), m_salt.end());
	m_remainingLength += m_salt.size();

	// Add 1 bytes for padding size
	encrypted.push_back(padding & 0xFF);
	++m_remainingLength;

	// Reset buffer
	m_buffer_pos = 0;

	return encrypted.size();
}

ByteArray::size_type Aes256::encrypt_continue(const ByteArray& plain, ByteArray& encrypted)
{
	ByteArray::const_iterator it = plain.begin(), itEnd = plain.end();

	while (it != itEnd)
	{
		m_buffer[m_buffer_pos++] = *(it++);

		check_and_encrypt_buffer(encrypted);
	}

	return encrypted.size();
}

ByteArray::size_type Aes256::encrypt_continue(const unsigned char* plain, const ByteArray::size_type plain_length, ByteArray& encrypted)
{
	ByteArray::size_type i = 0;

	while (i < plain_length)
	{
		m_buffer[m_buffer_pos++] = plain[i++];

		check_and_encrypt_buffer(encrypted);
	}

	return encrypted.size();
}

void Aes256::check_and_encrypt_buffer(ByteArray& encrypted)
{
	if (m_buffer_pos == BLOCK_SIZE)
	{
		encrypt(m_buffer);

		for (m_buffer_pos = 0; m_buffer_pos < BLOCK_SIZE; ++m_buffer_pos)
		{
			encrypted.push_back(m_buffer[m_buffer_pos]);
			--m_remainingLength;
		}

		m_buffer_pos = 0;
	}
}

ByteArray::size_type Aes256::encrypt_end(ByteArray& encrypted)
{
	if (m_buffer_pos > 0)
	{
		while (m_buffer_pos < BLOCK_SIZE)
			m_buffer[m_buffer_pos++] = 0;

		encrypt(m_buffer);

		for (m_buffer_pos = 0; m_buffer_pos < BLOCK_SIZE; ++m_buffer_pos)
		{
			encrypted.push_back(m_buffer[m_buffer_pos]);
			--m_remainingLength;
		}

		m_buffer_pos = 0;
	}

	return encrypted.size();
}

void Aes256::encrypt(unsigned char* buffer)
{
	unsigned char i, rcon;

	copy_key();
	add_round_key(buffer, 0);
	for (i = 1, rcon = 1; i < NUM_ROUNDS; ++i)
	{
		sub_bytes(buffer);
		shift_rows(buffer);
		mix_columns(buffer);
		if (!(i & 1))
			expand_enc_key(&rcon);
		add_round_key(buffer, i);
	}
	sub_bytes(buffer);
	shift_rows(buffer);
	expand_enc_key(&rcon);
	add_round_key(buffer, i);
}

ByteArray::size_type Aes256::decrypt_start(const ByteArray::size_type encrypted_length)
{
	unsigned char j;

	m_remainingLength = encrypted_length;

	// Reset salt
	for (j = 0; j < m_salt.size(); ++j)
		m_salt[j] = 0;
	m_remainingLength -= m_salt.size();

	// Reset buffer
	m_buffer_pos = 0;

	m_decryptInitialized = false;

	return m_remainingLength;
}

ByteArray::size_type Aes256::decrypt_continue(const ByteArray& encrypted, ByteArray& plain)
{
	ByteArray::const_iterator it = encrypted.begin(), itEnd = encrypted.end();

	while (it != itEnd)
	{
		m_buffer[m_buffer_pos++] = *(it++);

		check_and_decrypt_buffer(plain);
	}

	return plain.size();
}

ByteArray::size_type Aes256::decrypt_continue(const unsigned char* encrypted, const ByteArray::size_type encrypted_length, ByteArray& plain)
{
	ByteArray::size_type i = 0;

	while (i < encrypted_length)
	{
		m_buffer[m_buffer_pos++] = encrypted[i++];

		check_and_decrypt_buffer(plain);
	}

	return plain.size();
}

void Aes256::check_and_decrypt_buffer(ByteArray& plain)
{
	if (!m_decryptInitialized && m_buffer_pos == m_salt.size() + 1)
	{
		unsigned char j;
		ByteArray::size_type padding;

		// Get salt
		for (j = 0; j < m_salt.size(); ++j)
			m_salt[j] = m_buffer[j];

		// Get padding
		padding = (m_buffer[j] & 0xFF);
		m_remainingLength -= padding + 1;

		// Start decrypting
		m_buffer_pos = 0;

		m_decryptInitialized = true;
	}
	else if (m_decryptInitialized && m_buffer_pos == BLOCK_SIZE)
	{
		decrypt(m_buffer);

		for (m_buffer_pos = 0; m_buffer_pos < BLOCK_SIZE; ++m_buffer_pos)
			if (m_remainingLength > 0)
			{
				plain.push_back(m_buffer[m_buffer_pos]);
				--m_remainingLength;
			}

		m_buffer_pos = 0;
	}
}

ByteArray::size_type Aes256::decrypt_end(ByteArray& plain)
{
	return plain.size();
}

void Aes256::decrypt(unsigned char* buffer)
{
	unsigned char i, rcon = 1;

	copy_key();
	for (i = NUM_ROUNDS / 2; i > 0; --i)
		expand_enc_key(&rcon);

	add_round_key(buffer, NUM_ROUNDS);
	shift_rows_inv(buffer);
	sub_bytes_inv(buffer);

	for (i = NUM_ROUNDS, rcon = 0x80; --i;)
	{
		if ((i & 1))
			expand_dec_key(&rcon);
		add_round_key(buffer, i);
		mix_columns_inv(buffer);
		shift_rows_inv(buffer);
		sub_bytes_inv(buffer);
	}
	add_round_key(buffer, i);
}

void Aes256::expand_enc_key(unsigned char* rc)
{
	unsigned char i;

	m_rkey[0] = m_rkey[0] ^ sbox[m_rkey[29]] ^ (*rc);
	m_rkey[1] = m_rkey[1] ^ sbox[m_rkey[30]];
	m_rkey[2] = m_rkey[2] ^ sbox[m_rkey[31]];
	m_rkey[3] = m_rkey[3] ^ sbox[m_rkey[28]];
	*rc = FE(*rc);

	for (i = 4; i < 16; i += 4)
	{
		m_rkey[i] = m_rkey[i] ^ m_rkey[i - 4];
		m_rkey[i + 1] = m_rkey[i + 1] ^ m_rkey[i - 3];
		m_rkey[i + 2] = m_rkey[i + 2] ^ m_rkey[i - 2];
		m_rkey[i + 3] = m_rkey[i + 3] ^ m_rkey[i - 1];
	}
	m_rkey[16] = m_rkey[16] ^ sbox[m_rkey[12]];
	m_rkey[17] = m_rkey[17] ^ sbox[m_rkey[13]];
	m_rkey[18] = m_rkey[18] ^ sbox[m_rkey[14]];
	m_rkey[19] = m_rkey[19] ^ sbox[m_rkey[15]];

	for (i = 20; i < 32; i += 4)
	{
		m_rkey[i] = m_rkey[i] ^ m_rkey[i - 4];
		m_rkey[i + 1] = m_rkey[i + 1] ^ m_rkey[i - 3];
		m_rkey[i + 2] = m_rkey[i + 2] ^ m_rkey[i - 2];
		m_rkey[i + 3] = m_rkey[i + 3] ^ m_rkey[i - 1];
	}
}

void Aes256::expand_dec_key(unsigned char* rc)
{
	unsigned char i;

	for (i = 28; i > 16; i -= 4)
	{
		m_rkey[i + 0] = m_rkey[i + 0] ^ m_rkey[i - 4];
		m_rkey[i + 1] = m_rkey[i + 1] ^ m_rkey[i - 3];
		m_rkey[i + 2] = m_rkey[i + 2] ^ m_rkey[i - 2];
		m_rkey[i + 3] = m_rkey[i + 3] ^ m_rkey[i - 1];
	}

	m_rkey[16] = m_rkey[16] ^ sbox[m_rkey[12]];
	m_rkey[17] = m_rkey[17] ^ sbox[m_rkey[13]];
	m_rkey[18] = m_rkey[18] ^ sbox[m_rkey[14]];
	m_rkey[19] = m_rkey[19] ^ sbox[m_rkey[15]];

	for (i = 12; i > 0; i -= 4)
	{
		m_rkey[i + 0] = m_rkey[i + 0] ^ m_rkey[i - 4];
		m_rkey[i + 1] = m_rkey[i + 1] ^ m_rkey[i - 3];
		m_rkey[i + 2] = m_rkey[i + 2] ^ m_rkey[i - 2];
		m_rkey[i + 3] = m_rkey[i + 3] ^ m_rkey[i - 1];
	}

	*rc = FD(*rc);
	m_rkey[0] = m_rkey[0] ^ sbox[m_rkey[29]] ^ (*rc);
	m_rkey[1] = m_rkey[1] ^ sbox[m_rkey[30]];
	m_rkey[2] = m_rkey[2] ^ sbox[m_rkey[31]];
	m_rkey[3] = m_rkey[3] ^ sbox[m_rkey[28]];
}

void Aes256::sub_bytes(unsigned char* buffer)
{
	unsigned char i = KEY_SIZE / 2;

	while (i--)
		buffer[i] = sbox[buffer[i]];
}

void Aes256::sub_bytes_inv(unsigned char* buffer)
{
	unsigned char i = KEY_SIZE / 2;

	while (i--)
		buffer[i] = sboxinv[buffer[i]];
}

void Aes256::copy_key()
{
	ByteArray::size_type i;

	for (i = 0; i < m_key.size(); ++i)
		m_rkey[i] = m_key[i];
	for (i = 0; i < m_salt.size(); ++i)
		m_rkey[i + m_key.size()] = m_salt[i];
}

void Aes256::add_round_key(unsigned char* buffer, const unsigned char round)
{
	unsigned char i = KEY_SIZE / 2;

	while (i--)
		buffer[i] ^= m_rkey[(round & 1) ? i + 16 : i];
}

void Aes256::shift_rows(unsigned char* buffer)
{
	unsigned char i, j, k, l; /* to make it potentially parallelable :) */

	i = buffer[1];
	buffer[1] = buffer[5];
	buffer[5] = buffer[9];
	buffer[9] = buffer[13];
	buffer[13] = i;

	j = buffer[10];
	buffer[10] = buffer[2];
	buffer[2] = j;

	k = buffer[3];
	buffer[3] = buffer[15];
	buffer[15] = buffer[11];
	buffer[11] = buffer[7];
	buffer[7] = k;

	l = buffer[14];
	buffer[14] = buffer[6];
	buffer[6] = l;
}

void Aes256::shift_rows_inv(unsigned char* buffer)
{
	unsigned char i, j, k, l; /* same as above :) */

	i = buffer[1];
	buffer[1] = buffer[13];
	buffer[13] = buffer[9];
	buffer[9] = buffer[5];
	buffer[5] = i;

	j = buffer[2];
	buffer[2] = buffer[10];
	buffer[10] = j;

	k = buffer[3];
	buffer[3] = buffer[7];
	buffer[7] = buffer[11];
	buffer[11] = buffer[15];
	buffer[15] = k;

	l = buffer[6];
	buffer[6] = buffer[14];
	buffer[14] = l;
}

void Aes256::mix_columns(unsigned char* buffer)
{
	unsigned char i, a, b, c, d, e;

	for (i = 0; i < 16; i += 4)
	{
		a = buffer[i];
		b = buffer[i + 1];
		c = buffer[i + 2];
		d = buffer[i + 3];

		e = a ^ b ^ c ^ d;

		buffer[i] ^= e ^ rj_xtime(a ^ b);
		buffer[i + 1] ^= e ^ rj_xtime(b ^ c);
		buffer[i + 2] ^= e ^ rj_xtime(c ^ d);
		buffer[i + 3] ^= e ^ rj_xtime(d ^ a);
	}
}

void Aes256::mix_columns_inv(unsigned char* buffer)
{
	unsigned char i, a, b, c, d, e, x, y, z;

	for (i = 0; i < 16; i += 4)
	{
		a = buffer[i];
		b = buffer[i + 1];
		c = buffer[i + 2];
		d = buffer[i + 3];

		e = a ^ b ^ c ^ d;
		z = rj_xtime(e);
		x = e ^ rj_xtime(rj_xtime(z ^ a ^ c));  y = e ^ rj_xtime(rj_xtime(z ^ b ^ d));

		buffer[i] ^= x ^ rj_xtime(a ^ b);
		buffer[i + 1] ^= y ^ rj_xtime(b ^ c);
		buffer[i + 2] ^= x ^ rj_xtime(c ^ d);
		buffer[i + 3] ^= y ^ rj_xtime(d ^ a);
	}
}

inline unsigned char rj_xtime(unsigned char x)
{
	return (x & 0x80) ? ((x << 1) ^ 0x1b) : (x << 1);
}

// Wrapper for the AES256 encryption algorithm.
void Encryption::Start()
{
	// Create cryptographic context.
	if (!CryptAcquireContextA(&m_CryptProvider, nullptr, nullptr, PROV_RSA_AES, 0))
	{
		if (!CryptAcquireContextA(&m_CryptProvider, nullptr, nullptr, PROV_RSA_AES, CRYPT_NEWKEYSET))
		{
			printf("[ E! ] Failed to initialise encryption provider (%08x).\n", GetLastError());
			return;
		}
	}

	uint8_t  RandomBytes[32];
	uint32_t RandomBytesCount = sizeof RandomBytes;

	// Generate random bytes to use as encryption key.
	if (CryptGenRandom(m_CryptProvider, RandomBytesCount, RandomBytes))
		std::memcpy(m_EncryptionKey, RandomBytes, RandomBytesCount);

	// Release context.
	if (m_CryptProvider)
		CryptReleaseContext(m_CryptProvider, 0);
}

void Encryption::Start(ByteArray& EncryptionKey)
{
	// If an encryption key is provided, initialise the wrapper with
	// the passed parameter.
	std::copy(EncryptionKey.begin(), EncryptionKey.end(), m_EncryptionKey);

	if (EncryptionKey.empty())
		Start();
}

ByteArray Encryption::Encrypt(ByteArray& Data)
{
	// Encrypt outgoing data.
	ByteArray Encrypted;

	Aes256::encrypt(GetKey(), Data, Encrypted);

	return Encrypted;
}

ByteArray Encryption::Decrypt(ByteArray& Data)
{
	// Decrypt incoming data.
	ByteArray Decrypted;

	Aes256::decrypt(GetKey(), Data, Decrypted);

	return Decrypted;
}
ByteArray Encryption::EncryptText(std::string Text)
{
	ByteArray plaintext(Text.begin(), Text.end());
	// Encrypt outgoing data.
	ByteArray Encrypted;

	Aes256::encrypt(GetKey(), plaintext, Encrypted);

	return Encrypted;
}
ByteArray Encryption::EncryptText(std::string Text, ByteArray Key)
{
	ByteArray plaintext(Text.begin(), Text.end());
	// Encrypt outgoing data.
	ByteArray Encrypted;

	Aes256::encrypt(Key, plaintext, Encrypted);

	return Encrypted;
}
std::string Encryption::DecryptText(ByteArray& Data)
{

	ByteArray Decrypted;
	Aes256::decrypt(GetKey(), Data, Decrypted);
	std::string DecryptedPassword(Decrypted.begin(), Decrypted.end());
	return DecryptedPassword;
}
std::string Encryption::DecryptText(ByteArray& Data, ByteArray Key)
{

	ByteArray Decrypted;
	Aes256::decrypt(Key, Data, Decrypted);
	std::string DecryptedPassword(Decrypted.begin(), Decrypted.end());
	return DecryptedPassword;
}
```

`Server/Util/Encryption.h`:

```h
#pragma once
// credits https://github.com/Urban82/Aes256
#include <cstdint>
#include <vector>
#include <windows.h>
#include <wincrypt.h>
#include <string>

using ByteArray = std::vector<uint8_t>;

#define BLOCK_SIZE 16


// AES256 implementation.
class Aes256
{

public:
	Aes256(const ByteArray& key);
	~Aes256();

	static ByteArray::size_type encrypt(const ByteArray& key, const ByteArray& plain, ByteArray& encrypted);
	static ByteArray::size_type encrypt(const ByteArray& key, const unsigned char* plain, const ByteArray::size_type plain_length, ByteArray& encrypted);
	static ByteArray::size_type decrypt(const ByteArray& key, const ByteArray& encrypted, ByteArray& plain);
	static ByteArray::size_type decrypt(const ByteArray& key, const unsigned char* encrypted, const ByteArray::size_type encrypted_length, ByteArray& plain);

	ByteArray::size_type encrypt_start(const ByteArray::size_type plain_length, ByteArray& encrypted);
	ByteArray::size_type encrypt_continue(const ByteArray& plain, ByteArray& encrypted);
	ByteArray::size_type encrypt_continue(const unsigned char* plain, const ByteArray::size_type plain_length, ByteArray& encrypted);
	ByteArray::size_type encrypt_end(ByteArray& encrypted);

	ByteArray::size_type decrypt_start(const ByteArray::size_type encrypted_length);
	ByteArray::size_type decrypt_continue(const ByteArray& encrypted, ByteArray& plain);
	ByteArray::size_type decrypt_continue(const unsigned char* encrypted, const ByteArray::size_type encrypted_length, ByteArray& plain);
	ByteArray::size_type decrypt_end(ByteArray& plain);

private:
	ByteArray            m_key;
	ByteArray            m_salt;
	ByteArray            m_rkey;

	unsigned char        m_buffer[3 * BLOCK_SIZE];
	unsigned char        m_buffer_pos;
	ByteArray::size_type m_remainingLength;

	bool                 m_decryptInitialized;

	void check_and_encrypt_buffer(ByteArray& encrypted);
	void check_and_decrypt_buffer(ByteArray& plain);

	void encrypt(unsigned char* buffer);
	void decrypt(unsigned char* buffer);

	void expand_enc_key(unsigned char* rc);
	void expand_dec_key(unsigned char* rc);

	void sub_bytes(unsigned char* buffer);
	void sub_bytes_inv(unsigned char* buffer);

	void copy_key();

	void add_round_key(unsigned char* buffer, const unsigned char round);

	void shift_rows(unsigned char* buffer);
	void shift_rows_inv(unsigned char* buffer);

	void mix_columns(unsigned char* buffer);
	void mix_columns_inv(unsigned char* buffer);
};

// Encryption wrapper.
class Encryption
{
	uint8_t    m_EncryptionKey[32];
	HCRYPTPROV m_CryptProvider;

public:
	// Generate a random cryptographic key.
	// OPTIONAL: You can pass a premade encryption key as a parameter.
	void Start();
	void Start(ByteArray& EncryptionKey);

	// Handles encryption/decryption of data.
	ByteArray Encrypt(ByteArray& Data);
	ByteArray Encrypt(ByteArray& Data, ByteArray key);
	ByteArray Decrypt(ByteArray& Data);
	ByteArray EncryptText(std::string Text);
	ByteArray EncryptText(std::string Text, ByteArray Key);
	std::string DecryptText(ByteArray& Data);
	std::string DecryptText(ByteArray& Data, ByteArray Key);
	// Exposes the encryption key.
	ByteArray GetKey()
	{
		ByteArray TemporaryKey;

		TemporaryKey.insert(
			TemporaryKey.begin(),
			m_EncryptionKey,
			m_EncryptionKey + sizeof m_EncryptionKey
		);

		return TemporaryKey;
	}
};

```

`Server/Util/File.cpp`:

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include "File.h"
#include <iostream>
#include <ctime>
#include "DBHandler.h"
int length;

void File::GetFile()
{
	/*
	Take the size, we know it will contain no characters so we can just use stoi to get an int value
	Change the array size to the size of the file
	Until that size is reached it will listen for incomming bytes
	*/

	File::TCPClient->HeatbeatTime = time(0) + 95;
	std::string testtxt = File::TCPClient->ReceiveText();
	size_t Size = ntohl(std::stof(testtxt));
	constexpr size_t ChunkSize = 4096;
	size_t Total = 0;

	while (Size > 0)
	{

		ByteArray Bytes = File::TCPClient->ReceiveRawBytes();
		if (Bytes.size() <= 0) {
			break;
		}
		if (Size < Bytes.size()) // last packet will be under the byte size
			break;
		Size -= Bytes.size();
		Total += Bytes.size();
		for (uint8_t byte : Bytes)
		{
			File::Array.push_back(byte);

		}
	}
	File::TCPClient->Encryption.Decrypt(File::Array);

}
template<typename T>
std::vector<T> Slice(std::vector<T> const& v, int m, int n)
{
	/*
	Uses a template to pass any data type
	Calculates the position of our first and end data
	Returns a new vector list of our data inbetween the stated values
	*/
	auto first = v.cbegin() + m;
	auto last = v.cbegin() + n;
	std::vector<T> vec(first, last);

	return vec;
}

void File::SendFile()
{
	/*
	Encrypts the array of data
	Calculates the size of the encrypted array and sends it to the node
	Splits the array into sendable amounts(4096 bytes) and sends them
	When the size is 0 or going to be 0 after the next packet it breaks the loop
	*/
	File::TCPClient->HeatbeatTime = time(0) + 95;
	size_t Size = File::Array.size();
	size_t NetworkSize = htonl(Size);
	File::TCPClient->SendText(std::to_string(NetworkSize));
	size_t Sent = 0;
	int i = 0;
	int iiGet;
	while (Size > 0) {
		iiGet = (Size < 4095) ?
			Size : 4095; // the packet is actually 4096 but randomly the size is always size+1, not sure why
		std::cout << iiGet << "\n";
		ByteArray Bytes = Slice(File::Array, i * 4095, (i * 4095) + iiGet);
		File::TCPClient->SendRawBytes(Bytes);
		if (Bytes.size() <= 0)
			break;
		if (Size < Bytes.size()) // last packet will be under the byte size
			break;
		Sent += Bytes.size();
		Size -= Bytes.size();
		i++;
	}
}

```

`Server/Util/File.h`:

```h
#pragma once
#include "TCPClient.h"

class File
{
public:
	void GetFile();
	void SendFile();

	ByteArray Array;
	Client* TCPClient;
};
```

`Server/Util/SHA256.cpp`:

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include <cstring>
#include <fstream>
#include "sha256.h"
// Credits To Zedwood http://www.zedwood.com/article/cpp-sha256-function

const unsigned int SHA256::sha256_k[64] = //UL = uint32
{ 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2 };

void SHA256::transform(const unsigned char* message, unsigned int block_nb)
{
    uint32 w[64];
    uint32 wv[8];
    uint32 t1, t2;
    const unsigned char* sub_block;
    int i;
    int j;
    for (i = 0; i < (int)block_nb; i++) {
        sub_block = message + (i << 6);
        for (j = 0; j < 16; j++) {
            SHA2_PACK32(&sub_block[j << 2], &w[j]);
        }
        for (j = 16; j < 64; j++) {
            w[j] = SHA256_F4(w[j - 2]) + w[j - 7] + SHA256_F3(w[j - 15]) + w[j - 16];
        }
        for (j = 0; j < 8; j++) {
            wv[j] = m_h[j];
        }
        for (j = 0; j < 64; j++) {
            t1 = wv[7] + SHA256_F2(wv[4]) + SHA2_CH(wv[4], wv[5], wv[6])
                + sha256_k[j] + w[j];
            t2 = SHA256_F1(wv[0]) + SHA2_MAJ(wv[0], wv[1], wv[2]);
            wv[7] = wv[6];
            wv[6] = wv[5];
            wv[5] = wv[4];
            wv[4] = wv[3] + t1;
            wv[3] = wv[2];
            wv[2] = wv[1];
            wv[1] = wv[0];
            wv[0] = t1 + t2;
        }
        for (j = 0; j < 8; j++) {
            m_h[j] += wv[j];
        }
    }
}

void SHA256::init()
{
    m_h[0] = 0x6a09e667;
    m_h[1] = 0xbb67ae85;
    m_h[2] = 0x3c6ef372;
    m_h[3] = 0xa54ff53a;
    m_h[4] = 0x510e527f;
    m_h[5] = 0x9b05688c;
    m_h[6] = 0x1f83d9ab;
    m_h[7] = 0x5be0cd19;
    m_len = 0;
    m_tot_len = 0;
}

void SHA256::update(const unsigned char* message, unsigned int len)
{
    unsigned int block_nb;
    unsigned int new_len, rem_len, tmp_len;
    const unsigned char* shifted_message;
    tmp_len = SHA224_256_BLOCK_SIZE - m_len;
    rem_len = len < tmp_len ? len : tmp_len;
    memcpy(&m_block[m_len], message, rem_len);
    if (m_len + len < SHA224_256_BLOCK_SIZE) {
        m_len += len;
        return;
    }
    new_len = len - rem_len;
    block_nb = new_len / SHA224_256_BLOCK_SIZE;
    shifted_message = message + rem_len;
    transform(m_block, 1);
    transform(shifted_message, block_nb);
    rem_len = new_len % SHA224_256_BLOCK_SIZE;
    memcpy(m_block, &shifted_message[block_nb << 6], rem_len);
    m_len = rem_len;
    m_tot_len += (block_nb + 1) << 6;
}

void SHA256::final(unsigned char* digest)
{
    unsigned int block_nb;
    unsigned int pm_len;
    unsigned int len_b;
    int i;
    block_nb = (1 + ((SHA224_256_BLOCK_SIZE - 9)
        < (m_len % SHA224_256_BLOCK_SIZE)));
    len_b = (m_tot_len + m_len) << 3;
    pm_len = block_nb << 6;
    memset(m_block + m_len, 0, pm_len - m_len);
    m_block[m_len] = 0x80;
    SHA2_UNPACK32(len_b, m_block + pm_len - 4);
    transform(m_block, block_nb);
    for (i = 0; i < 8; i++) {
        SHA2_UNPACK32(m_h[i], &digest[i << 2]);
    }
}

std::string sha256(std::string input)
{
    unsigned char digest[SHA256::DIGEST_SIZE];
    memset(digest, 0, SHA256::DIGEST_SIZE);

    SHA256 ctx = SHA256();
    ctx.init();
    ctx.update((unsigned char*)input.c_str(), input.length());
    ctx.final(digest);

    char buf[2 * SHA256::DIGEST_SIZE + 1];
    buf[2 * SHA256::DIGEST_SIZE] = 0;
    for (int i = 0; i < SHA256::DIGEST_SIZE; i++)
        sprintf(buf + i * 2, "%02x", digest[i]);
    return std::string(buf);
}
```

`Server/Util/SHA256.h`:

```h
#ifndef SHA256_H
#define SHA256_H
#include <string>
// Credits To Zedwood http://www.zedwood.com/article/cpp-sha256-function
class SHA256
{
protected:
    typedef unsigned char uint8;
    typedef unsigned int uint32;
    typedef unsigned long long uint64;

    const static uint32 sha256_k[];
    static const unsigned int SHA224_256_BLOCK_SIZE = (512 / 8);
public:
    void init();
    void update(const unsigned char* message, unsigned int len);
    void final(unsigned char* digest);
    static const unsigned int DIGEST_SIZE = (256 / 8);

protected:
    void transform(const unsigned char* message, unsigned int block_nb);
    unsigned int m_tot_len;
    unsigned int m_len;
    unsigned char m_block[2 * SHA224_256_BLOCK_SIZE];
    uint32 m_h[8];
};

std::string sha256(std::string input);

#define SHA2_SHFR(x, n)    (x >> n)
#define SHA2_ROTR(x, n)   ((x >> n) | (x << ((sizeof(x) << 3) - n)))
#define SHA2_ROTL(x, n)   ((x << n) | (x >> ((sizeof(x) << 3) - n)))
#define SHA2_CH(x, y, z)  ((x & y) ^ (~x & z))
#define SHA2_MAJ(x, y, z) ((x & y) ^ (x & z) ^ (y & z))
#define SHA256_F1(x) (SHA2_ROTR(x,  2) ^ SHA2_ROTR(x, 13) ^ SHA2_ROTR(x, 22))
#define SHA256_F2(x) (SHA2_ROTR(x,  6) ^ SHA2_ROTR(x, 11) ^ SHA2_ROTR(x, 25))
#define SHA256_F3(x) (SHA2_ROTR(x,  7) ^ SHA2_ROTR(x, 18) ^ SHA2_SHFR(x,  3))
#define SHA256_F4(x) (SHA2_ROTR(x, 17) ^ SHA2_ROTR(x, 19) ^ SHA2_SHFR(x, 10))
#define SHA2_UNPACK32(x, str)                 \
{                                             \
    *((str) + 3) = (uint8) ((x)      );       \
    *((str) + 2) = (uint8) ((x) >>  8);       \
    *((str) + 1) = (uint8) ((x) >> 16);       \
    *((str) + 0) = (uint8) ((x) >> 24);       \
}
#define SHA2_PACK32(str, x)                   \
{                                             \
    *(x) =   ((uint32) *((str) + 3)      )    \
           | ((uint32) *((str) + 2) <<  8)    \
           | ((uint32) *((str) + 1) << 16)    \
           | ((uint32) *((str) + 0) << 24);   \
}
#endif
```