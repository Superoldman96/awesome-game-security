Project Path: arc_gmh5225_csgo_g797aqvc

Source Tree:

```txt
arc_gmh5225_csgo_g797aqvc
├── LICENSE
├── README.md
├── csgo-legit.sln
├── csgo-legit.vcxproj
├── hack
│   ├── SDK
│   │   ├── CCSGO_HudRadar.hpp
│   │   ├── CClientEffectRegistration.hpp
│   │   ├── CEffectData.hpp
│   │   ├── CEngineSoundClient.hpp
│   │   ├── CFlashlightEffect.hpp
│   │   ├── CGameMovement.hpp
│   │   ├── CGameRules.hpp
│   │   ├── CGlobalVars.hpp
│   │   ├── CGlowManager.hpp
│   │   ├── CHudChat.hpp
│   │   ├── CParticelCollection.hpp
│   │   ├── CPlayerResource.hpp
│   │   ├── CPredictionCopy.cpp
│   │   ├── CPredictionCopy.hpp
│   │   ├── CStudioHdr.hpp
│   │   ├── CTeslaInfo.hpp
│   │   ├── CUserCmd.hpp
│   │   ├── CUtlReference.hpp
│   │   ├── CUtlString.hpp
│   │   ├── CUtlVector.hpp
│   │   ├── CViewSetup.hpp
│   │   ├── ClientClass.hpp
│   │   ├── ClientMode.hpp
│   │   ├── ConVar.hpp
│   │   ├── EHandle.hpp
│   │   ├── Enums.hpp
│   │   ├── IBaseClientDll.hpp
│   │   ├── IClientEntityList.hpp
│   │   ├── IClientState.hpp
│   │   ├── ICollideable.hpp
│   │   ├── ICvar.hpp
│   │   ├── IEffects.hpp
│   │   ├── IEngineTrace.hpp
│   │   ├── IGameEvent.hpp
│   │   ├── ILocalize.hpp
│   │   ├── IMDLCache.hpp
│   │   ├── IMatRenderContext.hpp
│   │   ├── IMaterialSystem.hpp
│   │   ├── IMemAlloc.hpp
│   │   ├── IPanel.hpp
│   │   ├── IPrediction.cpp
│   │   ├── IPrediction.hpp
│   │   ├── ISurface.hpp
│   │   ├── ITexture.hpp
│   │   ├── IVDebugOverlay.hpp
│   │   ├── IVEffects.hpp
│   │   ├── IVEngineClient.hpp
│   │   ├── IVModelInfo.hpp
│   │   ├── IVModelRender.hpp
│   │   ├── IVRenderView.hpp
│   │   ├── IVStudioRender.hpp
│   │   ├── IViewRender.hpp
│   │   ├── IViewRenderBeams.hpp
│   │   ├── IWeapon.hpp
│   │   ├── Input.hpp
│   │   ├── InputSystem.hpp
│   │   ├── KeyValues.cpp
│   │   ├── KeyValues.hpp
│   │   ├── KeyValuesSys.hpp
│   │   ├── MapStruct.hpp
│   │   ├── Recv.hpp
│   │   ├── animations.hpp
│   │   ├── checksum_crc.cpp
│   │   ├── checksum_crc.hpp
│   │   ├── clientHitVerify.hpp
│   │   ├── datamap.hpp
│   │   ├── helpers
│   │   │   ├── netvars.cpp
│   │   │   ├── netvars.hpp
│   │   │   ├── pad.hpp
│   │   │   └── vfunc.hpp
│   │   ├── interfaceNode.hpp
│   │   ├── interfaces
│   │   │   ├── ifc.hpp
│   │   │   ├── interfaces.cpp
│   │   │   └── interfaces.hpp
│   │   ├── material.hpp
│   │   ├── math
│   │   │   ├── AABB.hpp
│   │   │   ├── Vector.hpp
│   │   │   ├── VectorAligned.hpp
│   │   │   └── matrix.hpp
│   │   ├── structs
│   │   │   ├── Entity.cpp
│   │   │   ├── Entity.hpp
│   │   │   └── indexes.hpp
│   │   ├── varMapping.hpp
│   │   └── vars.hpp
│   ├── cheats
│   │   ├── classes
│   │   │   ├── CM.cpp
│   │   │   ├── DM.cpp
│   │   │   ├── DPSE.cpp
│   │   │   ├── OV.cpp
│   │   │   ├── README.md
│   │   │   ├── VR.cpp
│   │   │   ├── base.cpp
│   │   │   ├── base.hpp
│   │   │   ├── createMove.hpp
│   │   │   ├── doPostScreen.hpp
│   │   │   ├── drawModel.hpp
│   │   │   ├── frameStage.cpp
│   │   │   ├── frameStage.hpp
│   │   │   ├── onlyInit.hpp
│   │   │   ├── overViewMap.cpp
│   │   │   ├── overViewMap.hpp
│   │   │   ├── overrideView.hpp
│   │   │   ├── renderableToPresent.cpp
│   │   │   ├── renderableToPresent.hpp
│   │   │   ├── renderableToSurface.cpp
│   │   │   ├── renderableToSurface.hpp
│   │   │   ├── screen2dEffects.cpp
│   │   │   ├── screen2dEffects.hpp
│   │   │   └── viewRender.hpp
│   │   ├── features
│   │   │   ├── RCS
│   │   │   │   ├── RCS.cpp
│   │   │   │   └── RCS.hpp
│   │   │   ├── aimbot
│   │   │   │   ├── aimbot.cpp
│   │   │   │   ├── aimbot.hpp
│   │   │   │   ├── aimbotDraw.cpp
│   │   │   │   └── aimbotDraw.hpp
│   │   │   ├── backtrack
│   │   │   │   ├── backteack.cpp
│   │   │   │   └── backtrack.hpp
│   │   │   ├── blacklist
│   │   │   │   ├── blacklist.cpp
│   │   │   │   └── blacklist.hpp
│   │   │   ├── cache
│   │   │   │   ├── cache.cpp
│   │   │   │   └── cache.hpp
│   │   │   ├── callbacks
│   │   │   │   ├── callbacks.cpp
│   │   │   │   └── callbacks.hpp
│   │   │   ├── discord
│   │   │   │   ├── discord.cpp
│   │   │   │   └── discord.hpp
│   │   │   ├── events
│   │   │   │   ├── events.cpp
│   │   │   │   └── events.hpp
│   │   │   ├── fakelatency
│   │   │   │   ├── fakelatency.cpp
│   │   │   │   └── fakelatency.hpp
│   │   │   ├── logger
│   │   │   │   ├── logger.cpp
│   │   │   │   └── logger.hpp
│   │   │   ├── misc
│   │   │   │   ├── cameras
│   │   │   │   │   ├── freeCam.cpp
│   │   │   │   │   ├── freeCam.hpp
│   │   │   │   │   ├── freeLook.cpp
│   │   │   │   │   └── freeLook.hpp
│   │   │   │   ├── disable
│   │   │   │   │   ├── interpolate.cpp
│   │   │   │   │   └── interpolate.hpp
│   │   │   │   ├── flashlight
│   │   │   │   │   ├── flashlight.cpp
│   │   │   │   │   └── flashlight.hpp
│   │   │   │   ├── movement
│   │   │   │   │   ├── movement.cpp
│   │   │   │   │   └── movement.hpp
│   │   │   │   └── thirdperson
│   │   │   │       ├── thirdperson.cpp
│   │   │   │       └── thirdperson.hpp
│   │   │   ├── particle
│   │   │   │   ├── particle.cpp
│   │   │   │   └── particle.hpp
│   │   │   ├── prediction
│   │   │   │   ├── prediction.cpp
│   │   │   │   └── prediction.hpp
│   │   │   ├── triggerbot
│   │   │   │   ├── triggerbot.cpp
│   │   │   │   └── triggerbot.hpp
│   │   │   └── visuals
│   │   │       ├── chams
│   │   │       │   ├── chams.cpp
│   │   │       │   ├── chams.hpp
│   │   │       │   ├── editor.cpp
│   │   │       │   ├── editor.hpp
│   │   │       │   └── mat.hpp
│   │   │       ├── glow
│   │   │       │   ├── glow.cpp
│   │   │       │   └── glow.hpp
│   │   │       ├── hitmarker
│   │   │       │   ├── hitmark.cpp
│   │   │       │   └── hitmark.hpp
│   │   │       ├── list
│   │   │       │   ├── playerlist.cpp
│   │   │       │   └── playerlist.hpp
│   │   │       ├── mirrorcam
│   │   │       │   ├── mirrorCam.cpp
│   │   │       │   └── mirrorCam.hpp
│   │   │       ├── misc
│   │   │       │   ├── crosshair.cpp
│   │   │       │   ├── crosshair.hpp
│   │   │       │   ├── drawInfo.hpp
│   │   │       │   ├── drawinfo.cpp
│   │   │       │   ├── hat.cpp
│   │   │       │   ├── hat.hpp
│   │   │       │   ├── motionblur.cpp
│   │   │       │   ├── motionblur.hpp
│   │   │       │   ├── noscope.cpp
│   │   │       │   ├── noscope.hpp
│   │   │       │   ├── screenEffects.cpp
│   │   │       │   ├── screenEffects.hpp
│   │   │       │   ├── trails.cpp
│   │   │       │   └── trails.hpp
│   │   │       ├── player
│   │   │       │   ├── boxes.cpp
│   │   │       │   ├── boxes.hpp
│   │   │       │   ├── dormacy.hpp
│   │   │       │   ├── enemyWarn.cpp
│   │   │       │   ├── enemyWarn.hpp
│   │   │       │   ├── player.cpp
│   │   │       │   ├── player.hpp
│   │   │       │   ├── sounds.cpp
│   │   │       │   └── sounds.hpp
│   │   │       ├── plots
│   │   │       │   ├── plots.cpp
│   │   │       │   └── plots.hpp
│   │   │       ├── radar
│   │   │       │   ├── radar.cpp
│   │   │       │   └── radar.hpp
│   │   │       ├── tracer
│   │   │       │   ├── tracer.cpp
│   │   │       │   └── tracer.hpp
│   │   │       └── world
│   │   │           ├── ambient.cpp
│   │   │           ├── ambient.hpp
│   │   │           ├── bomb.cpp
│   │   │           ├── bomb.hpp
│   │   │           ├── dropped.cpp
│   │   │           ├── dropped.hpp
│   │   │           ├── fog.cpp
│   │   │           ├── fog.hpp
│   │   │           ├── impacts.cpp
│   │   │           ├── impacts.hpp
│   │   │           ├── modulateColors.cpp
│   │   │           ├── modulateColors.hpp
│   │   │           ├── molotov.cpp
│   │   │           ├── molotov.hpp
│   │   │           ├── nadepred.cpp
│   │   │           ├── nadepred.hpp
│   │   │           ├── nadewarn.cpp
│   │   │           ├── nadewarn.hpp
│   │   │           ├── projectiles.cpp
│   │   │           ├── projectiles.hpp
│   │   │           ├── removeSky.cpp
│   │   │           ├── removeSky.hpp
│   │   │           ├── skybox.cpp
│   │   │           ├── skybox.hpp
│   │   │           ├── smoke.cpp
│   │   │           ├── smoke.hpp
│   │   │           ├── tone.cpp
│   │   │           ├── tone.hpp
│   │   │           ├── weather.cpp
│   │   │           ├── weather.hpp
│   │   │           ├── zeus.cpp
│   │   │           └── zeus.hpp
│   │   ├── game
│   │   │   ├── game.cpp
│   │   │   ├── game.hpp
│   │   │   └── globals.hpp
│   │   └── hooks
│   │       ├── addEntity.cpp
│   │       ├── buildTransformations.cpp
│   │       ├── createEvent.cpp
│   │       ├── createMove.cpp
│   │       ├── doPostScreenEffects.cpp
│   │       ├── drawIndexPrimitive.cpp
│   │       ├── drawModel.cpp
│   │       ├── emitSound.cpp
│   │       ├── eraseEntity.cpp
│   │       ├── fireIntern.cpp
│   │       ├── frameStageNotify.cpp
│   │       ├── fxBlood.cpp
│   │       ├── getColorModulation.cpp
│   │       ├── helpers
│   │       │   └── helper.hpp
│   │       ├── hooks.cpp
│   │       ├── hooks.hpp
│   │       ├── isDepth.cpp
│   │       ├── isFollowingEntity.cpp
│   │       ├── isHltv.cpp
│   │       ├── levelInitPostEntity.cpp
│   │       ├── levelInitPreEntity.cpp
│   │       ├── levelShutdown.cpp
│   │       ├── lockCursor.cpp
│   │       ├── overrideView.cpp
│   │       ├── paintTraverse.cpp
│   │       ├── particlesSimulation.cpp
│   │       ├── playStepSound.cpp
│   │       ├── preRoundRestart.cpp
│   │       ├── present.cpp
│   │       ├── processSpottedEntityUpdate.cpp
│   │       ├── renderView.cpp
│   │       ├── reset.cpp
│   │       ├── runCommand.cpp
│   │       ├── screen2deffect.cpp
│   │       ├── sendDatagram.cpp
│   │       ├── unknownFIleSys.cpp
│   │       ├── unknownOverviewMap.cpp
│   │       ├── validAddrChecks.cpp
│   │       ├── viewRenderSceneEnd.cpp
│   │       ├── wndproc.cpp
│   │       └── wndproc.hpp
│   ├── config
│   │   ├── cfgBeam.hpp
│   │   ├── cfgWeapon.cpp
│   │   ├── cfgWeapon.hpp
│   │   ├── cfgcolor.cpp
│   │   ├── cfgcolor.hpp
│   │   ├── config.cpp
│   │   ├── config.hpp
│   │   ├── enums.hpp
│   │   ├── jsonExtended.cpp
│   │   ├── jsonExtended.hpp
│   │   ├── key.cpp
│   │   ├── key.hpp
│   │   └── vars.hpp
│   ├── deps
│   │   ├── ImGui
│   │   │   ├── TextEditor.cpp
│   │   │   ├── TextEditor.hpp
│   │   │   ├── extraDraw.cpp
│   │   │   └── extraDraw.hpp
│   │   ├── README.md
│   │   ├── images
│   │   │   └── fatchad.png
│   │   └── magic_enum
│   │       └── prettyNames.hpp
│   ├── gamememory
│   │   ├── memory.cpp
│   │   ├── memory.hpp
│   │   ├── modules.hpp
│   │   ├── pattern.hpp
│   │   └── sigs.hpp
│   ├── menu
│   │   ├── GUI-ImGui
│   │   │   ├── animations.cpp
│   │   │   ├── animations.hpp
│   │   │   ├── background.cpp
│   │   │   ├── background.hpp
│   │   │   ├── imguiaddons.cpp
│   │   │   ├── imguiaddons.hpp
│   │   │   ├── menu.cpp
│   │   │   ├── menu.hpp
│   │   │   ├── selections.hpp
│   │   │   └── tabrender.hpp
│   │   └── x88Menu
│   │       ├── x88menu.cpp
│   │       ├── x88menu.hpp
│   │       └── x88types.hpp
│   ├── render
│   │   ├── BBox.cpp
│   │   ├── BBox.hpp
│   │   ├── Color.cpp
│   │   ├── Color.hpp
│   │   ├── iconfont.hpp
│   │   ├── render.cpp
│   │   ├── render.hpp
│   │   ├── structures.cpp
│   │   └── structures.hpp
│   ├── resources
│   │   ├── csgo-legit.rc
│   │   └── resource.h
│   ├── setup
│   │   ├── SEHcatch.cpp
│   │   ├── SEHcatch.hpp
│   │   ├── setup.cpp
│   │   └── setup.hpp
│   └── utilities
│       ├── console
│       │   ├── console.cpp
│       │   ├── console.hpp
│       │   ├── consoleDraw.cpp
│       │   ├── consoleDraw.hpp
│       │   └── consoleUtils.hpp
│       ├── inputSystem.cpp
│       ├── inputSystem.hpp
│       ├── math
│       │   ├── math.cpp
│       │   └── math.hpp
│       ├── rand.hpp
│       ├── res.cpp
│       ├── res.hpp
│       ├── simpleTimer.hpp
│       ├── tools
│       │   ├── tools.cpp
│       │   ├── tools.hpp
│       │   └── wrappers.hpp
│       ├── utilities.cpp
│       └── utilities.hpp
├── pch.cpp
├── pch.h
├── source.cpp
└── vcpkg.json

```

`LICENSE`:

```
MIT License

Copyright (c) 2021-2022 Bartis

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`README.md`:

```md
# Csgo
Source aimed for visual aspects of the game.

![Bartis internal CSGO](https://user-images.githubusercontent.com/69613796/179428634-adf44410-4002-4e5d-9ac5-b794dcb1c35f.png)

# Instalation
**BEFORE anything, make sure you have it installed**: [c++ redistributables](https://docs.microsoft.com/en-us/cpp/windows/latest-supported-vc-redist?view=msvc-170) [directX](https://www.microsoft.com/en-us/download/details.aspx?id=35) [vcpkg](https://vcpkg.io/en/index.html)
<br />

Dependencies folder IS NOT for dependencies themselves, if they are on vcpkg, do not include them manually! Otherwise add those.

# Information
Features marked ``(rebuild needed)`` need recode or better version.
<br />
This is a trianing software. No further actions taken by people are heeded.
<br />
<br />
As you know or not, this is not going to ensure your safety in 100%. To do that, use any good vac module dumper, and debug outputed files.
<br />
Good start is to: use any valid vac modules dumper (that will decode inputs), and understand all [this](https://github.com/danielkrupinski/VAC)

# Features list: 
<details>

 * Aimbot - smooth, delay, types, (rebuild needed - make it more like aim-assist rather than aim)
 * RCS - control the recoil spray. Possible to smooth it.
 * Triggerbot - delay in ms.
 * Backtrack - manipulate ticks.
 * Fake latency - manipulate sequences in ms.
 * Bunnyhop - with chance%
 * Autostrafe - with few methods.
 * Callbacks - not really used, good example how to use them.
 * Events - listen game events, needed for some features for info. (Should avoid this if possible)
 * Thirdperson - 3rd person on key. Included with tracing, pretty much exactly what originally game does.
 * Crosshairs - custom crosshairs, 5 types.
 * Local info - ammo, pos etc... Bunch of local player informations.
 * Fps plot - collect fps and represent it in graphical resizable plot.
 * Velocity plot - collect local player speed and represent it in graphical resizable plot.
 * Hitmarker - ability to draw hitmarkers 2D/3D with dmg output.
 * No scope - removes scope black overlay.
 * Bullet tracer - draw bullets directions by line beams. Possible to also create own bullet tracer type.
 * Flashlight - use game effect flashlight.
 * Nade prediction - predicts endpoint of your nade throw. Also can predict incomming nades by same logic. Would need some rework for tracing specific things as water, glass, ents...
 * Engine prediction - useful to never skip tick and get correct server time.
 * Chams - uses engine's keyvalues to render it. 5 types and ability to draw backtrack records. Also possible to create your own (currently editor is not possible on initial 0 material, will fix pretty soon)
 * Glow - highlight player ents. (rebuild needed - think of removing this or creating glow texture on own (game provides such materials), client.dll checks it and it in general has performance issues)
 * Sound Esp - apex legends like sound esp from passive skill of bloodhound character.
 * Esp - name, flags, boxes, health, armor, ammo, skeleton. 2D/3D.
 * DLight - highlights player by dlight. (Can't shortly fix the optimazation for them, it's due to overcomplication in how dlights are generated)
 * Enemy aiming at you warn. (Note that enemies using fov-changer hacks will not always be marked as "see you", it's physically impossible to gather fov from other clients by client)
 * 2D radar - overlay showing where enemy is, with background of the map texture. Renders rotated triangles that can be clipped with ranges or not.
 * Custom skybox - listed from game or custom, custom skybox is i 1st hierarchy.
 * Remove sky - removes props by forcing cvar, (rebuild needed - don't force, check retaddr or find if any function could be hooked for this)
 * Edit world colors - props/walls/sky (rebuild needed - transparency should be done in different way)
 * Movement trails - collect line frame by frame and draw from container
 * Bullet impacts - where the bullet has hit. Does not use events, instead gets client information of bullets list.
 * Custom smoke/molotov - color/remove/timer
 * Draw dropped weapons - box/icon/name/ammo. Fading alpha with distance
 * Bomb overlay with info. - draws infomation about bomb, where, what dmg, who planted.
 * Mirrorcam - show what is behind you on extra window (contains fixing setupbones occlusion problems)
 * Freecam - view any place without moving your model (dormant ents won't render)
 * Freelook - a copy of how it looks like in PUBG
 * Blacklist - blacklist bots and players, forces aimbot to fucus blacklisted players.
 * Playerlist - a playerlist that will give information of every player on the server, in one window. Does provide information for dormant ents.
 * Cache - not a feature, just escapes using same loops for(int i; 64)... everywhere.
 * Logger - log anything to left corner, with animated move + alpha when text duration reaches end.
 * Ambient - ambient light (think if its possible to directly access rgba of that).
 * Fog - fog controller, color and intensity.
 * Weather - change weather, might cost a lot of performance drop, due to fact many particles will render.
 </details>

# Default keybinds
 - INSERT (Close/open menu)
 - DELETE (Panic key - shutdowns whole hack thread)
 - HOME (Console key - shows the console window rendered with ImGui)

# Log
<details>

* 1.0.0 - initial commit
* 1.0.1 - small fixes in code + rainbow chams
* 1.0.2 - improved a bit performance, changed render text function to modern wstring, aimbot big drops fixed, aimbot now uses ranged loop for hitboxes
* 1.0.3 - added PlayerResource class which contain kills deaths and ping. Improved some of the features again
* 1.0.4 - fixed typo for backtrack and added in comments ticks option to backtrack, I personally don't need it, hence why it's commented
* 1.0.5 - cleaned up the source in visuals and render. Added new player visuals. Fixed padding in one SDK class, added skeleton ESP. In utils there is a new conventer function which you can very easily use to get distance to enemy in meters (unit to meters)
* 1.0.6 - small update with removing fps drops while menu is opened
* 1.0.7 - big update for performance and cleanup in code, a lot of useless defines have been removed. Changed console::log function to take only one string and log type, string can be easily used with std::format
* 1.0.8 - small update with making menu usage more easier, items are now in map and features can be passed as name for vars::names map
* 1.0.9 - big update for performance, recode, and code style. All functions are camel case. I seperated visuals to be in few files since it's better to read and move in code. Added even more visuals once again. Fixed prediction, thanks: [kaposzta99](https://github.com/Bartis1313/csgo/issues/4)
* 1.1.0 - update came with fixes: triggerbot, backtrack records and SDK. Added Dlight and "nightmode" that just forces other skybox. Few very small addons to menu and code changes.
* 1.1.1 - small update with new planned feature and handling the error in case the directory can't be created.
* 1.1.2 - 2D plot added, for fps and velocity. From now if config fails to find file to save, it throws the error.
* 1.1.3 - Added hand/weapon chams, and rewrote chams code.
* 1.1.4 - Added global shots counter, which can result in getting valid accuracy per round, and hitmarker with sound got added.
* 1.1.5 - Added visibility check, in aimbot and triggerbot. Some visuals added.
* 1.1.6 - Changed aimbot, fixed visibility, aimbot now uses only one function to run. Added no scope overlay.
* 1.1.7 - fixed code, added more visuals. Added few more things to SDK.
* 1.1.8 - added image rendering, pretty simple as it does need only one argument. Console logging is a bit simplier now. Fixed the main thread call with handling critical errors correctly.
* 1.1.9 - very small update. Added check for paint hook, implemented idea of gui.
* 1.2.0 - update to gui and few fixes in random files. (broke the git again..., lol)
* 1.2.1 - GUI update with finishing ideas of everything, recode is still needed for automatic padding for GUI objects or add ideally add flags to choose.
* 1.2.2 - Big GUI update, it now can use auto padding, changed few comments to make it easier to understand in whole code. Still it needs few fixes.
* 1.2.3 - Almost GUI is finished, few things left.
* 1.2.4 - Update on new config system using type safe checks, menu is finally ready to work with variables and multiple configs. Fixed, removed bunch of functions. Deleted singleton as it's a very bad choice to work with single class objects. Reduced many calls. Made return address more easier.
* 1.2.5 - Made surface GUI example to be working correctly. Added ImGui + freetype libraries, as it's next goal to use this GUI framework as example + solid rendering. Fixed code in few places, and removed oftently changed files from precompilation, which could lead to errors.
* 1.2.6 - Added ImGui example, added ghetto fix for sendpacket, although it's not used. It's a temp fix. Made hooking even easier to use now.
* 1.2.7 - Added ImGuiRender class which has a rich amount of functions, arguments are almost everywhere same as in surface rendering. GUI made with surface has been deleted aswell as x88 menu, if you need to know how was it done, search old repo commits. Cleaned up whole sdk and code in few places.
* 1.2.8 - Fixed few rendering bugs. Added basic imgui menu, if you care for styling etc... go make a pull request so people can use it as some replacement. Keep in mind - any imgui addons that are not included in the lib should be made in imguiaddons.hpp at all. Color now has a different type, due to making it easier for floating points. You will still be able to use it as 0-255 range.
* 1.2.9 - Few fixes in some places, nothing really big. I will start making commits comments a bit better from now on, more detailed.
* 1.3.0 - Huge recode, cleaned up most of bloat header includes. Features are now not in namespace but class. Improved code quality almost everywhere. Fixed unloading the cheat not causing any errors. Plots are totally rewritten. Fixed couple of features, although chams are temporiarly not possible. I am thinking of clean solution for them. Added console from imgui demo which will show current loggings. Still a lot of code needs rewrite.
* 1.3.1 - Added option "load on start", which will load selected config on the start.
* 1.3.2 - The hitmarker is now finished. Nothing more in this version.
* 1.3.3 - Fixed "Enemy is aiming at you", aimbot, and many more. And added working chams, still small fixes are needed to them.
* 1.3.4 - Fixed stupid math calcAngle basing on src - dst logic, made it same as calcAngleRelative with how delta is achieved. Few rendering improvements such as rendering font. Use cached bones for calculating the pos. Added posibility to render icons from the game. Added lines to radar.
* 1.3.5 - Fixes in visuals and addons. Addons as nade timers, editing molotov color, flags done with distance scaling.
* 1.3.6 - Fixes new update crash and config based crashes. Added many effects and edited code in many places. Everything is detailed in the commit.
* 1.3.7 - Fake latency, and I hope last backtrack. Make sure prediction is updated when deltatick is any value, just like game does. Added bomb overlay, not perfect for resizing because the size is always the same.
* 1.3.8 - Key detection made properly. Using 2 classes to detect it, as first using messages coming from wndproc is running 24/7 and other only listens to given key from config. Why making own detection? ImGui has it, but then you will have to deal with flickering cursor problems if want to run it 24/7.
* 1.3.9 - Reback x88 menu, this time with better types detection and code. It also has ability to change config variables by operating on arrow keys.
* 1.4.0 - After some break, added the grenade warning, lacks of visuals and custom choices of colors etc... No more errors with std::format, small config issue fixed.
* 1.4.1 - Nade prediction should output given dmg by nade, or inform if inferno is in range. Fonts contain pixel size at the end now. Input system will now only work when: we are not in key hotkey, when vgui console is off, when chat window is off.
* 1.4.2 - Rainbow colors can be an option from picker, remade color picker + logic in config for color.
* 1.4.3 - Finish nade prediction at all, warning for tracers will be scaled with distance to the nade.
* 1.4.4 - Sound esp is done. Credits to the guy who had the idea with this. Scaling included for sound circles.
* 1.4.5 - Changes in code, mainly to render low levels things such as images by resources. Few slight changes into imgui: add ability to load up image by memory, ability to draw multicolors with poly. Discord rpc with updated information from client.
* 1.4.6 - Texture rendered in the radar, I run on some weird problems there and unfortunately because of the dds file format it's impossible to use Resource class. Cleaned the project settings. Instead of ignoring the error of unsafe function, getting time is threadsafe now. Game color edits are now run per each instead of applying whole list.
* 1.4.7 - Easy cfg load on start option, setting load cfg won't save current variables but only name to load.
* 1.4.8 - Added mirrorcam (rendering by ImGui), freecam, freelook, fixed SEH catching allocation for symbols. Console logging is now locked, it's better to run them in mutex.
* 1.4.9 - Flashlight fixed and added it as a feature. Recoded rendering to take ImVec2 instead of vector2D when using imgui. Fixed/recoded drawing 3d boxes completely. Init localplayer once (and this method probably fixes crashes). Gather prediction move data from stack. Pass std::span as normal copy, not cref.
* 1.5.0 - World screen effects added: fog, tone control, draw screen effects.
* 1.5.1 - Add weather effect.
* 1.5.2 - Added 1:1 motion blur from source leak. Controlling thirdperson should be quite better as now it traces the distance to any objects, just like game originally does. Added extra options to it as suggested in: [#41](https://github.com/Bartis1313/csgo/issues/41). Added comments for sigs, I can't shortly explain how to use RTTI info in 3 lines, so this is just very basic string ref info.
* 1.5.3 - HUGE recode, cleanup in way that features are inited and run. Also general cleanup/fixes in features. Now every change will be much easier to make, without calling some run() method manually, it all gets called by static object vec, code itself explains it very well. Each class has one task to do, or very limited to more.
* 1.5.4 - Simplified constructors in base classes. If possible they should be constexpr.
* 1.5.5 - Config update for weapons selection in aimbot. Fixed crash with weather on new map. Cleaned up menu a bit.
* 1.5.6 - Few checks added to aimbot, triggerbot, backtrack and player visuals.
* 1.5.7 - Visual update for fading, players and dropped weapons. Cleanup in Resource class.
* 1.5.8 - Cache for ents done, when drawing something ent based in present hook you should stick to normal classic loop, as commented in radar file.
* 1.5.9 - Memory cleanup, static offsets were always a problem due to short lag while gathering the offset. Now it run once at the start + adding it should be very easy. Handled exports, mostly needed for sig scan and CreateInterface.
* 1.6.0 - Include paths.
* 1.6.1 - Include paths v2.
* 1.6.2 - Source cleanup, generic vector & matrix.
* 1.6.3 - Once again better generic vector. Config is now stored in nice-looking json + accessing values is not painful. Cleanup is still needed. Better smoothing included in aimbot, still needs some extensions.  
* 1.6.4 - Config fix again, added magic_enum to not repat same names in the selections namespace.
* 1.6.5 - Bit of clean up with memory, interfaces and valid entity cache that will work for any frame. And maybe crash fixes?
* 1.6.6 - Cleanup, base classes for features are now more abstract. Fixed crash due to wrong allocation for vector. Rebuild hook structs to be defined with macros.
* 1.6.7 - Wip menu.
* 1.6.8 - Finished menu animations/movelikes.
* 1.6.9 - Playerlist added (blacklist not done yet), changed render to take unique ptr.
* 1.7.0 - Blacklist finished, including crash fixes.
* 1.7.1 - Refactor of code. Fixes, and some addons, especially hooks. Deatailed in commit.
* 1.7.2 - Cleanup for lerping animation.
* 1.7.3 - visuals health/armor bug fix, more "clear" hooked functions definitions, accurate info gathered directly from the game about shots, not using events to count them manually (awful!). Prediction last edits. SDK cleanup and addons. Sound is finally not using events, wip to remove other events. Editor still not finished, almost... Plots reworked to work for last rendering change. Fixes to radar, eg: MapStruct, triangle enemies.
* 2.0.0 - Made it as a new version since it does change a lot. Provided very simple instruction for people who want to use this at long end. Bunch of very few refactors/renames in functions. 2.0 is now having a friendly folder structure. Replaced render from utils to own folder. As well as other things which were "overnamed" to be in utils. Very soon to finally end that project.
</details>

# People who helped
* [KittenPopo](https://github.com/KittenPopo) - answering questions I have been confused how something works and for cs18 leak which made reversing even easier.
* [Pawel Gozdur](https://github.com/carlos-konewka) - helping me with math, especially plot logic.
* [UC Wiki](https://www.unknowncheats.me/wiki/UnKnoWnCheaTs_Game_Hacking_Wiki) - for very helpful sources.
* [rollraw/qo0](https://github.com/rollraw) - swapchain render + icon font.

```

`csgo-legit.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31729.503
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "csgo-legit", "csgo-legit.vcxproj", "{B4CD8A1A-12C3-50FB-725E-A1B089F416D3}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x86 = Debug|x86
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{B4CD8A1A-12C3-50FB-725E-A1B089F416D3}.Debug|x86.ActiveCfg = Debug|Win32
		{B4CD8A1A-12C3-50FB-725E-A1B089F416D3}.Debug|x86.Build.0 = Debug|Win32
		{B4CD8A1A-12C3-50FB-725E-A1B089F416D3}.Release|x86.ActiveCfg = Release|Win32
		{B4CD8A1A-12C3-50FB-725E-A1B089F416D3}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {4A5E3217-9F26-49BA-C89A-B76C6BCFEF5C}
	EndGlobalSection
EndGlobal

```

`csgo-legit.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{B4CD8A1A-12C3-50FB-725E-A1B089F416D3}</ProjectGuid>
    <RootNamespace>csgo-legit</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>csgo-legit</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <VcpkgEnableManifest>true</VcpkgEnableManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <VcpkgEnableManifest>true</VcpkgEnableManifest>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <IncludePath>$(SolutionDir)hack;$(DXSDK_DIR)Include;$(IncludePath)</IncludePath>
    <LibraryPath>$(DXSDK_DIR)Lib\x86;$(LibraryPath)</LibraryPath>
    <OutDir>.\build\debug\</OutDir>
    <TargetName>Debug_$(ProjectName)</TargetName>
    <SourcePath>$(SourcePath)</SourcePath>
    <IntDir>.\build\Intermediate\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>.\build\Release\</OutDir>
    <LibraryPath>$(DXSDK_DIR)Lib\x86;$(LibraryPath)</LibraryPath>
    <IncludePath>$(SolutionDir)hack;$(DXSDK_DIR)Include;$(IncludePath)</IncludePath>
    <TargetName>$(ProjectName)</TargetName>
    <SourcePath>$(SourcePath)</SourcePath>
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <IntDir>.\build\Intermediate\</IntDir>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
    <VcpkgUseMD>
    </VcpkgUseMD>
    <VcpkgTriplet>x86-windows-static</VcpkgTriplet>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
    <VcpkgTriplet>
    </VcpkgTriplet>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <PreprocessorDefinitions>WIN32_LEAN_AND_MEAN;NOMINMAX;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/std:c++latest %(AdditionalOptions)</AdditionalOptions>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <ForcedIncludeFiles>pch.h</ForcedIncludeFiles>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <BufferSecurityCheck>true</BufferSecurityCheck>
      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
      <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
      <TreatWarningAsError>true</TreatWarningAsError>
      <FloatingPointModel>Fast</FloatingPointModel>
    </ClCompile>
    <ProjectReference>
      <UseLibraryDependencyInputs>false</UseLibraryDependencyInputs>
    </ProjectReference>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <IgnoreSpecificDefaultLibraries>
      </IgnoreSpecificDefaultLibraries>
      <AdditionalDependencies>DbgHelp.lib;d3dx9.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <ConformanceMode>true</ConformanceMode>
      <PreprocessorDefinitions>WIN32_LEAN_AND_MEAN;NOMINMAX;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/std:c++latest /Gw %(AdditionalOptions)</AdditionalOptions>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <CreateHotpatchableImage>
      </CreateHotpatchableImage>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <ForcedIncludeFiles>pch.h</ForcedIncludeFiles>
      <EnforceTypeConversionRules>
      </EnforceTypeConversionRules>
      <RuntimeTypeInfo>
      </RuntimeTypeInfo>
      <LanguageStandard_C>Default</LanguageStandard_C>
      <UndefinePreprocessorDefinitions>
      </UndefinePreprocessorDefinitions>
      <DebugInformationFormat>None</DebugInformationFormat>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <StringPooling>true</StringPooling>
      <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
      <FloatingPointModel>Fast</FloatingPointModel>
      <ForcedUsingFiles>
      </ForcedUsingFiles>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <OmitFramePointers>false</OmitFramePointers>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <TreatWarningAsError>true</TreatWarningAsError>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <IgnoreSpecificDefaultLibraries>
      </IgnoreSpecificDefaultLibraries>
      <AdditionalDependencies>DbgHelp.lib;d3dx9.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <ImageHasSafeExceptionHandlers />
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="hack\cheats\game\game.cpp" />
    <ClCompile Include="hack\cheats\hooks\addEntity.cpp" />
    <ClCompile Include="hack\cheats\hooks\buildTransformations.cpp" />
    <ClCompile Include="hack\cheats\hooks\createEvent.cpp" />
    <ClCompile Include="hack\cheats\hooks\createMove.cpp" />
    <ClCompile Include="hack\cheats\hooks\doPostScreenEffects.cpp" />
    <ClCompile Include="hack\cheats\hooks\drawIndexPrimitive.cpp" />
    <ClCompile Include="hack\cheats\hooks\drawModel.cpp" />
    <ClCompile Include="hack\cheats\hooks\emitSound.cpp" />
    <ClCompile Include="hack\cheats\hooks\eraseEntity.cpp" />
    <ClCompile Include="hack\cheats\hooks\fireIntern.cpp" />
    <ClCompile Include="hack\cheats\hooks\frameStageNotify.cpp" />
    <ClCompile Include="hack\cheats\hooks\fxBlood.cpp" />
    <ClCompile Include="hack\cheats\hooks\getColorModulation.cpp" />
    <ClCompile Include="hack\cheats\hooks\hooks.cpp" />
    <ClCompile Include="hack\cheats\hooks\isDepth.cpp" />
    <ClCompile Include="hack\cheats\hooks\isFollowingEntity.cpp" />
    <ClCompile Include="hack\cheats\hooks\isHltv.cpp" />
    <ClCompile Include="hack\cheats\hooks\levelInitPostEntity.cpp" />
    <ClCompile Include="hack\cheats\hooks\levelInitPreEntity.cpp" />
    <ClCompile Include="hack\cheats\hooks\levelShutdown.cpp" />
    <ClCompile Include="hack\cheats\hooks\lockCursor.cpp" />
    <ClCompile Include="hack\cheats\hooks\overrideView.cpp" />
    <ClCompile Include="hack\cheats\hooks\paintTraverse.cpp" />
    <ClCompile Include="hack\cheats\hooks\particlesSimulation.cpp" />
    <ClCompile Include="hack\cheats\hooks\playStepSound.cpp" />
    <ClCompile Include="hack\cheats\hooks\preRoundRestart.cpp" />
    <ClCompile Include="hack\cheats\hooks\present.cpp" />
    <ClCompile Include="hack\cheats\hooks\processSpottedEntityUpdate.cpp" />
    <ClCompile Include="hack\cheats\hooks\renderView.cpp" />
    <ClCompile Include="hack\cheats\hooks\reset.cpp" />
    <ClCompile Include="hack\cheats\hooks\runCommand.cpp" />
    <ClCompile Include="hack\cheats\hooks\screen2deffect.cpp" />
    <ClCompile Include="hack\cheats\hooks\sendDatagram.cpp" />
    <ClCompile Include="hack\cheats\hooks\unknownFIleSys.cpp" />
    <ClCompile Include="hack\cheats\hooks\unknownOverviewMap.cpp" />
    <ClCompile Include="hack\cheats\hooks\validAddrChecks.cpp" />
    <ClCompile Include="hack\cheats\hooks\viewRenderSceneEnd.cpp" />
    <ClCompile Include="hack\cheats\hooks\wndproc.cpp" />
    <ClCompile Include="hack\cheats\features\prediction\prediction.cpp" />
    <ClCompile Include="hack\cheats\features\RCS\RCS.cpp" />
    <ClCompile Include="hack\cheats\features\triggerbot\triggerbot.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\chams\chams.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\chams\editor.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\glow\glow.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\hitmarker\hitmark.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\list\playerlist.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\mirrorcam\mirrorCam.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\misc\crosshair.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\misc\drawinfo.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\misc\hat.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\misc\motionblur.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\misc\noscope.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\misc\screenEffects.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\misc\trails.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\player\boxes.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\player\enemyWarn.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\player\player.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\player\sounds.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\plots\plots.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\radar\radar.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\tracer\tracer.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\ambient.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\bomb.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\dropped.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\fog.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\impacts.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\modulateColors.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\molotov.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\nadepred.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\nadewarn.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\projectiles.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\removeSky.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\skybox.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\smoke.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\tone.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\weather.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\zeus.cpp" />
    <ClCompile Include="hack\cheats\features\aimbot\aimbot.cpp" />
    <ClCompile Include="hack\cheats\features\aimbot\aimbotDraw.cpp" />
    <ClCompile Include="hack\cheats\features\backtrack\backteack.cpp" />
    <ClCompile Include="hack\cheats\features\blacklist\blacklist.cpp" />
    <ClCompile Include="hack\cheats\features\cache\cache.cpp" />
    <ClCompile Include="hack\cheats\features\callbacks\callbacks.cpp" />
    <ClCompile Include="hack\cheats\features\discord\discord.cpp" />
    <ClCompile Include="hack\cheats\features\events\events.cpp" />
    <ClCompile Include="hack\cheats\features\fakelatency\fakelatency.cpp" />
    <ClCompile Include="hack\cheats\features\logger\logger.cpp" />
    <ClCompile Include="hack\cheats\features\misc\cameras\freeCam.cpp" />
    <ClCompile Include="hack\cheats\features\misc\cameras\freeLook.cpp" />
    <ClCompile Include="hack\cheats\features\misc\disable\interpolate.cpp" />
    <ClCompile Include="hack\cheats\features\misc\flashlight\flashlight.cpp" />
    <ClCompile Include="hack\cheats\features\misc\movement\movement.cpp" />
    <ClCompile Include="hack\cheats\features\misc\thirdperson\thirdperson.cpp" />
    <ClCompile Include="hack\cheats\features\particle\particle.cpp" />
    <ClCompile Include="hack\cheats\classes\base.cpp" />
    <ClCompile Include="hack\cheats\classes\CM.cpp" />
    <ClCompile Include="hack\cheats\classes\DM.cpp" />
    <ClCompile Include="hack\cheats\classes\DPSE.cpp" />
    <ClCompile Include="hack\cheats\classes\frameStage.cpp" />
    <ClCompile Include="hack\cheats\classes\OV.cpp" />
    <ClCompile Include="hack\cheats\classes\overViewMap.cpp" />
    <ClCompile Include="hack\cheats\classes\renderableToPresent.cpp" />
    <ClCompile Include="hack\cheats\classes\renderableToSurface.cpp" />
    <ClCompile Include="hack\cheats\classes\screen2dEffects.cpp" />
    <ClCompile Include="hack\cheats\classes\VR.cpp" />
    <ClCompile Include="hack\utilities\tools\tools.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">pch.h</PrecompiledHeaderFile>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="hack\config\cfgcolor.cpp" />
    <ClCompile Include="hack\config\cfgWeapon.cpp" />
    <ClCompile Include="hack\config\config.cpp" />
    <ClCompile Include="hack\config\jsonExtended.cpp" />
    <ClCompile Include="hack\config\key.cpp" />
    <ClCompile Include="hack\deps\ImGui\extraDraw.cpp" />
    <ClCompile Include="hack\deps\ImGui\TextEditor.cpp" />
    <ClCompile Include="hack\gamememory\memory.cpp" />
    <ClCompile Include="hack\menu\GUI-ImGui\animations.cpp" />
    <ClCompile Include="hack\menu\GUI-ImGui\background.cpp" />
    <ClCompile Include="hack\menu\GUI-ImGui\imguiaddons.cpp" />
    <ClCompile Include="hack\menu\GUI-ImGui\menu.cpp" />
    <ClCompile Include="hack\menu\x88Menu\x88menu.cpp" />
    <ClCompile Include="hack\render\BBox.cpp" />
    <ClCompile Include="hack\render\Color.cpp" />
    <ClCompile Include="hack\render\render.cpp" />
    <ClCompile Include="hack\render\structures.cpp" />
    <ClCompile Include="hack\SDK\checksum_crc.cpp" />
    <ClCompile Include="hack\SDK\CPredictionCopy.cpp" />
    <ClCompile Include="hack\SDK\helpers\netvars.cpp" />
    <ClCompile Include="hack\SDK\interfaces\interfaces.cpp" />
    <ClCompile Include="hack\SDK\IPrediction.cpp" />
    <ClCompile Include="hack\SDK\KeyValues.cpp" />
    <ClCompile Include="hack\SDK\structs\Entity.cpp" />
    <ClCompile Include="hack\setup\SEHcatch.cpp" />
    <ClCompile Include="hack\setup\setup.cpp" />
    <ClCompile Include="hack\utilities\console\console.cpp" />
    <ClCompile Include="hack\utilities\console\consoleDraw.cpp" />
    <ClCompile Include="hack\utilities\inputSystem.cpp" />
    <ClCompile Include="hack\utilities\math\math.cpp" />
    <ClCompile Include="hack\utilities\res.cpp" />
    <ClCompile Include="hack\utilities\utilities.cpp" />
    <ClCompile Include="source.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">pch.h</PrecompiledHeaderFile>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="hack\cheats\classes\base.hpp" />
    <ClInclude Include="hack\cheats\classes\createMove.hpp" />
    <ClInclude Include="hack\cheats\classes\doPostScreen.hpp" />
    <ClInclude Include="hack\cheats\classes\drawModel.hpp" />
    <ClInclude Include="hack\cheats\classes\frameStage.hpp" />
    <ClInclude Include="hack\cheats\classes\onlyInit.hpp" />
    <ClInclude Include="hack\cheats\classes\overrideView.hpp" />
    <ClInclude Include="hack\cheats\classes\overViewMap.hpp" />
    <ClInclude Include="hack\cheats\classes\renderableToPresent.hpp" />
    <ClInclude Include="hack\cheats\classes\renderableToSurface.hpp" />
    <ClInclude Include="hack\cheats\classes\screen2dEffects.hpp" />
    <ClInclude Include="hack\cheats\classes\viewRender.hpp" />
    <ClInclude Include="hack\cheats\features\aimbot\aimbot.hpp" />
    <ClInclude Include="hack\cheats\features\aimbot\aimbotDraw.hpp" />
    <ClInclude Include="hack\cheats\features\backtrack\backtrack.hpp" />
    <ClInclude Include="hack\cheats\features\blacklist\blacklist.hpp" />
    <ClInclude Include="hack\cheats\features\cache\cache.hpp" />
    <ClInclude Include="hack\cheats\features\callbacks\callbacks.hpp" />
    <ClInclude Include="hack\cheats\features\discord\discord.hpp" />
    <ClInclude Include="hack\cheats\features\events\events.hpp" />
    <ClInclude Include="hack\cheats\features\fakelatency\fakelatency.hpp" />
    <ClInclude Include="hack\cheats\features\logger\logger.hpp" />
    <ClInclude Include="hack\cheats\features\misc\cameras\freeCam.hpp" />
    <ClInclude Include="hack\cheats\features\misc\cameras\freeLook.hpp" />
    <ClInclude Include="hack\cheats\features\misc\disable\interpolate.hpp" />
    <ClInclude Include="hack\cheats\features\misc\flashlight\flashlight.hpp" />
    <ClInclude Include="hack\cheats\features\misc\movement\movement.hpp" />
    <ClInclude Include="hack\cheats\features\misc\thirdperson\thirdperson.hpp" />
    <ClInclude Include="hack\cheats\features\particle\particle.hpp" />
    <ClInclude Include="hack\cheats\features\prediction\prediction.hpp" />
    <ClInclude Include="hack\cheats\features\RCS\RCS.hpp" />
    <ClInclude Include="hack\cheats\features\triggerbot\triggerbot.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\chams\chams.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\chams\editor.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\chams\mat.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\glow\glow.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\hitmarker\hitmark.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\list\playerlist.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\mirrorcam\mirrorCam.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\misc\crosshair.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\misc\drawInfo.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\misc\hat.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\misc\motionblur.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\misc\noscope.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\misc\screenEffects.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\misc\trails.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\player\boxes.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\player\dormacy.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\player\enemyWarn.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\player\player.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\player\sounds.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\plots\plots.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\radar\radar.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\tracer\tracer.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\ambient.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\bomb.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\dropped.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\fog.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\impacts.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\modulateColors.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\molotov.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\nadepred.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\nadewarn.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\projectiles.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\removeSky.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\skybox.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\smoke.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\tone.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\weather.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\zeus.hpp" />
    <ClInclude Include="hack\cheats\game\game.hpp" />
    <ClInclude Include="hack\cheats\game\globals.hpp" />
    <ClInclude Include="hack\cheats\hooks\helpers\helper.hpp" />
    <ClInclude Include="hack\cheats\hooks\hooks.hpp" />
    <ClInclude Include="hack\cheats\hooks\wndproc.hpp" />
    <ClInclude Include="hack\config\cfgBeam.hpp" />
    <ClInclude Include="hack\config\cfgcolor.hpp" />
    <ClInclude Include="hack\config\cfgWeapon.hpp" />
    <ClInclude Include="hack\config\config.hpp" />
    <ClInclude Include="hack\config\enums.hpp" />
    <ClInclude Include="hack\config\jsonExtended.hpp" />
    <ClInclude Include="hack\config\key.hpp" />
    <ClInclude Include="hack\config\vars.hpp" />
    <ClInclude Include="hack\deps\ImGui\extraDraw.hpp" />
    <ClInclude Include="hack\deps\ImGui\TextEditor.hpp" />
    <ClInclude Include="hack\deps\magic_enum\prettyNames.hpp" />
    <ClInclude Include="hack\gamememory\memory.hpp" />
    <ClInclude Include="hack\gamememory\modules.hpp" />
    <ClInclude Include="hack\gamememory\pattern.hpp" />
    <ClInclude Include="hack\gamememory\sigs.hpp" />
    <ClInclude Include="hack\menu\GUI-ImGui\animations.hpp" />
    <ClInclude Include="hack\menu\GUI-ImGui\background.hpp" />
    <ClInclude Include="hack\menu\GUI-ImGui\imguiaddons.hpp" />
    <ClInclude Include="hack\menu\GUI-ImGui\menu.hpp" />
    <ClInclude Include="hack\menu\GUI-ImGui\selections.hpp" />
    <ClInclude Include="hack\menu\GUI-ImGui\tabrender.hpp" />
    <ClInclude Include="hack\menu\x88Menu\x88menu.hpp" />
    <ClInclude Include="hack\menu\x88Menu\x88types.hpp" />
    <ClInclude Include="hack\render\BBox.hpp" />
    <ClInclude Include="hack\render\Color.hpp" />
    <ClInclude Include="hack\render\iconfont.hpp" />
    <ClInclude Include="hack\render\render.hpp" />
    <ClInclude Include="hack\render\structures.hpp" />
    <ClInclude Include="hack\resources\resource.h" />
    <ClInclude Include="hack\SDK\animations.hpp" />
    <ClInclude Include="hack\SDK\CClientEffectRegistration.hpp" />
    <ClInclude Include="hack\SDK\CCSGO_HudRadar.hpp" />
    <ClInclude Include="hack\SDK\CEffectData.hpp" />
    <ClInclude Include="hack\SDK\CEngineSoundClient.hpp" />
    <ClInclude Include="hack\SDK\CFlashlightEffect.hpp" />
    <ClInclude Include="hack\SDK\CGameMovement.hpp" />
    <ClInclude Include="hack\SDK\CGameRules.hpp" />
    <ClInclude Include="hack\SDK\CGlobalVars.hpp" />
    <ClInclude Include="hack\SDK\CGlowManager.hpp" />
    <ClInclude Include="hack\SDK\checksum_crc.hpp" />
    <ClInclude Include="hack\SDK\CHudChat.hpp" />
    <ClInclude Include="hack\SDK\ClientClass.hpp" />
    <ClInclude Include="hack\SDK\clientHitVerify.hpp" />
    <ClInclude Include="hack\SDK\ClientMode.hpp" />
    <ClInclude Include="hack\SDK\ConVar.hpp" />
    <ClInclude Include="hack\SDK\CParticelCollection.hpp" />
    <ClInclude Include="hack\SDK\CPlayerResource.hpp" />
    <ClInclude Include="hack\SDK\CPredictionCopy.hpp" />
    <ClInclude Include="hack\SDK\CStudioHdr.hpp" />
    <ClInclude Include="hack\SDK\CTeslaInfo.hpp" />
    <ClInclude Include="hack\SDK\CUserCmd.hpp" />
    <ClInclude Include="hack\SDK\CUtlReference.hpp" />
    <ClInclude Include="hack\SDK\CUtlString.hpp" />
    <ClInclude Include="hack\SDK\CUtlVector.hpp" />
    <ClInclude Include="hack\SDK\CViewSetup.hpp" />
    <ClInclude Include="hack\SDK\datamap.hpp" />
    <ClInclude Include="hack\SDK\EHandle.hpp" />
    <ClInclude Include="hack\SDK\Enums.hpp" />
    <ClInclude Include="hack\SDK\helpers\netvars.hpp" />
    <ClInclude Include="hack\SDK\helpers\pad.hpp" />
    <ClInclude Include="hack\SDK\helpers\vfunc.hpp" />
    <ClInclude Include="hack\SDK\IBaseClientDll.hpp" />
    <ClInclude Include="hack\SDK\IClientEntityList.hpp" />
    <ClInclude Include="hack\SDK\IClientState.hpp" />
    <ClInclude Include="hack\SDK\ICollideable.hpp" />
    <ClInclude Include="hack\SDK\ICvar.hpp" />
    <ClInclude Include="hack\SDK\IEffects.hpp" />
    <ClInclude Include="hack\SDK\IEngineTrace.hpp" />
    <ClInclude Include="hack\SDK\IGameEvent.hpp" />
    <ClInclude Include="hack\SDK\ILocalize.hpp" />
    <ClInclude Include="hack\SDK\IMaterialSystem.hpp" />
    <ClInclude Include="hack\SDK\IMatRenderContext.hpp" />
    <ClInclude Include="hack\SDK\IMDLCache.hpp" />
    <ClInclude Include="hack\SDK\IMemAlloc.hpp" />
    <ClInclude Include="hack\SDK\Input.hpp" />
    <ClInclude Include="hack\SDK\InputSystem.hpp" />
    <ClInclude Include="hack\SDK\interfaceNode.hpp" />
    <ClInclude Include="hack\SDK\interfaces\ifc.hpp" />
    <ClInclude Include="hack\SDK\interfaces\interfaces.hpp" />
    <ClInclude Include="hack\SDK\IPanel.hpp" />
    <ClInclude Include="hack\SDK\IPrediction.hpp" />
    <ClInclude Include="hack\SDK\ISurface.hpp" />
    <ClInclude Include="hack\SDK\ITexture.hpp" />
    <ClInclude Include="hack\SDK\IVDebugOverlay.hpp" />
    <ClInclude Include="hack\SDK\IVEffects.hpp" />
    <ClInclude Include="hack\SDK\IVEngineClient.hpp" />
    <ClInclude Include="hack\SDK\IViewRender.hpp" />
    <ClInclude Include="hack\SDK\IViewRenderBeams.hpp" />
    <ClInclude Include="hack\SDK\IVModelInfo.hpp" />
    <ClInclude Include="hack\SDK\IVModelRender.hpp" />
    <ClInclude Include="hack\SDK\IVRenderView.hpp" />
    <ClInclude Include="hack\SDK\IVStudioRender.hpp" />
    <ClInclude Include="hack\SDK\IWeapon.hpp" />
    <ClInclude Include="hack\SDK\KeyValues.hpp" />
    <ClInclude Include="hack\SDK\KeyValuesSys.hpp" />
    <ClInclude Include="hack\SDK\MapStruct.hpp" />
    <ClInclude Include="hack\SDK\material.hpp" />
    <ClInclude Include="hack\SDK\math\AABB.hpp" />
    <ClInclude Include="hack\SDK\math\matrix.hpp" />
    <ClInclude Include="hack\SDK\math\Vector.hpp" />
    <ClInclude Include="hack\SDK\math\VectorAligned.hpp" />
    <ClInclude Include="hack\SDK\Recv.hpp" />
    <ClInclude Include="hack\SDK\structs\Entity.hpp" />
    <ClInclude Include="hack\SDK\structs\indexes.hpp" />
    <ClInclude Include="hack\SDK\varMapping.hpp" />
    <ClInclude Include="hack\SDK\vars.hpp" />
    <ClInclude Include="hack\setup\SEHcatch.hpp" />
    <ClInclude Include="hack\setup\setup.hpp" />
    <ClInclude Include="hack\utilities\console\console.hpp" />
    <ClInclude Include="hack\utilities\console\consoleDraw.hpp" />
    <ClInclude Include="hack\utilities\console\consoleUtils.hpp" />
    <ClInclude Include="hack\utilities\inputSystem.hpp" />
    <ClInclude Include="hack\utilities\math\math.hpp" />
    <ClInclude Include="hack\utilities\rand.hpp" />
    <ClInclude Include="hack\utilities\res.hpp" />
    <ClInclude Include="hack\utilities\simpleTimer.hpp" />
    <ClInclude Include="hack\utilities\tools\tools.hpp" />
    <ClInclude Include="hack\utilities\tools\wrappers.hpp" />
    <ClInclude Include="hack\utilities\utilities.hpp" />
    <ClInclude Include="pch.h" />
    <ClInclude Include="dependencies\interfaces\ienginetrace.hpp" />
    <ClInclude Include="utilities\csgo.hpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="hack\cheats\classes\README.md" />
    <None Include="hack\deps\README.md" />
    <None Include="hack\resources\csgo-legit.aps" />
    <None Include="vcpkg.json" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="hack\resources\csgo-legit.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="hack\deps\images\fatchad.png" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCPKG_INSTALLATION_ROOT)\scripts\buildsystems\msbuild\vcpkg.targets" Condition="'$(VCPKG_INSTALLATION_ROOT)' != ''" />
  </ImportGroup>
</Project>
```

`hack/SDK/CCSGO_HudRadar.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"
#include "helpers/pad.hpp"

// client.dll 55 8B EC 83 E4 F8 83 EC 60 A1 ? ? ? ? 56 57 | client.dll 55 8B EC 83 EC 18 8B 45 08 53 56 57
// call in ProcessSpottedEntityUpdate as game originally do
// this is why the fields might give not always pure 1:1 results to frequently updated player related fields
struct RadarEntity
{
	Vec3 m_origin;
	Vec3 m_viewAngles;
	PAD(28);
	float m_spottedTime;
	PAD(16);
	int m_index;
	PAD(4);
	int m_health;
	char m_name[32];
	PAD(117);
	bool m_visible;
	PAD(138);
	/*void write() const
	{
		printf("origin iszero? %i index %i health %i name %s visible %i\n", m_origin.isZero(), m_index, m_health, m_name, m_visible);
	}*/
};
static_assert(sizeof(RadarEntity) == 372);

struct CSRadar
{
	PAD(332);
	RadarEntity m_players[65];
};

struct CCSGO_HudRadar
{
	PAD(12);
	int m_maybeSizeOfImageRadar;
	PAD(512);
	int m_sizeOfPlayers;
};
```

`hack/SDK/CClientEffectRegistration.hpp`:

```hpp
#pragma once

#include "CEffectData.hpp"

using clientEffectCallback = void(*)(const CEffectData& data); // cdecl

struct CClientEffectRegistration
{
	CClientEffectRegistration() = default;
	CClientEffectRegistration(const char* effectName, clientEffectCallback fn)
		: m_effectName{ effectName }, m_function{ fn }
	{}
	const char* m_effectName;
	clientEffectCallback m_function;
	CClientEffectRegistration* m_next;
};
```

`hack/SDK/CEffectData.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"

class CEffectData
{
public:
	Vec3 m_origin;
	Vec3 m_start;
	Vec3 m_normal;
	Vec3 m_angles;
	int m_flags;
	int m_entityIdx;
	float m_scale;
	float m_magnitude;
	float m_radius;
	int m_attachmentIndex;
	short m_surfaceProp;
	// Some TF2 specific things
	int m_material;
	int m_damageType;
	int m_hitBox;
	int m_otherEntIndex;
	unsigned char m_color;
	int getEffectNameIndex() { return m_iEffectName; }
private:
	int m_iEffectName;	// Entry in the EffectDispatch network string table. The is automatically handled by DispatchEffect().
};
```

`hack/SDK/CEngineSoundClient.hpp`:

```hpp
#pragma once

class CEngineSoundClient;
```

`hack/SDK/CFlashlightEffect.hpp`:

```hpp
#pragma once

#include <cstdint>

class CFlashlightEffect
{
public:
	bool m_isOn;
private:
	char someweirdbuf[3]; // could be bools
public:
	int m_entIndex;
	uint16_t m_flashlightHandle;
	bool m_bigMode; // dunno how to name it
	bool m_muzzleFlashEnabled;
	float m_muzzleFlashBrightness;
	float m_fov;
	float m_farZ;
	float m_LinearAtten;
	bool m_castsShadows;
private:
	char someweirdbuf2[3]; // could be bools
public:
	float m_currentPullBackDist;
	uint32_t m_muzzleFlashTexture;
	uint32_t m_flashLightTexture;
	char m_textureName[64];
};
```

`hack/SDK/CGameMovement.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"

class Player_t;
class CMoveData;

class CGameMovement
{
public:
	VFUNC(void, processMovement, 1, (Player_t* local, CMoveData* moveData), (this, local, moveData));
	VFUNC(void, reset, 2, (), (this));
	VFUNC(void, startTrackPredictionErrors, 3, (Player_t* local), (this, local));
	VFUNC(void, finishTrackPredictionErrors, 4, (Player_t* local), (this, local));
};
```

`hack/SDK/CGameRules.hpp`:

```hpp
#pragma once

#include "helpers/netvars.hpp"
#include "helpers/vfunc.hpp"
#include "math/Vector.hpp"

// Each mod defines these for itself.
class CViewVectors
{
public:
	CViewVectors() {}

	CViewVectors(
		Vec3 vView,
		Vec3 vHullMin,
		Vec3 vHullMax,
		Vec3 vDuckHullMin,
		Vec3 vDuckHullMax,
		Vec3 vDuckView,
		Vec3 vObsHullMin,
		Vec3 vObsHullMax,
		Vec3 vDeadViewHeight)
	{
		m_vView = vView;
		m_vHullMin = vHullMin;
		m_vHullMax = vHullMax;
		m_vDuckHullMin = vDuckHullMin;
		m_vDuckHullMax = vDuckHullMax;
		m_vDuckView = vDuckView;
		m_vObsHullMin = vObsHullMin;
		m_vObsHullMax = vObsHullMax;
		m_vDeadViewHeight = vDeadViewHeight;
	}

	// Height above entity position where the viewer's eye is.
	Vec3 m_vView;

	Vec3 m_vHullMin;
	Vec3 m_vHullMax;

	Vec3 m_vDuckHullMin;
	Vec3 m_vDuckHullMax;
	Vec3 m_vDuckView;

	Vec3 m_vObsHullMin;
	Vec3 m_vObsHullMax;

	Vec3 m_vDeadViewHeight;
};

class CGameRules
{
public:
	NETVAR(int, m_iRoundTime, "DT_CSGameRulesProxy", "m_iRoundTime");

	VFUNC(CViewVectors*, getViewVectors, 30, (), (this));
};
```

`hack/SDK/CGlobalVars.hpp`:

```hpp
#pragma once

class CGlobalVarsBase
{
public:
	float m_realtime;
	int m_frameCount;
	float m_absoluteframetime;
	float m_absoluteframestarttimestddev;
	float m_curtime;
	float m_frametime;
	int m_maxClients;
	int m_tickCount;
	float m_intervalPerTick;
	float m_interpolationAmount;
	int m_simTicksThisFrame;
	int m_networkProtocol;
	void* m_saveData;
	bool m_client;
	bool m_remoteClient;
	int m_networkingTimestamp;
	int m_networkingTimestampRandomize;
};
```

`hack/SDK/CGlowManager.hpp`:

```hpp
#pragma once

#include <render/Color.hpp>
#include "helpers/pad.hpp"

class CGlowObject_t
{
public:
	void set(const Color& color, bool occluded = true, bool unocculuded = false, bool fullBloom = false, float amount = 1.0f)
	{
		m_color = color;
		m_occluded = occluded;
		m_unoccluded = unocculuded;
		m_fullBloom = fullBloom;
		m_bloomAmount = amount;
	}
	bool unused()
	{
		return m_nextFree != -2;
	}

	int m_nextFree;
	void* m_entity;
	Color m_color;
	PAD(8);
	float m_bloomAmount;
	PAD(4);
	bool m_occluded;
	bool m_unoccluded;
	bool m_fullBloom;
	PAD(13);
};

class CGlowManager
{
public:
	CGlowObject_t* m_objects;
	PAD(8);
	int m_size;
};
```

`hack/SDK/CHudChat.hpp`:

```hpp
#pragma once

#include "helpers/pad.hpp"

class CHudChat
{
	PAD(84);
	int m_timesOpened;
	PAD(8);
	bool m_isOpen;
	PAD(1088);
};
```

`hack/SDK/CParticelCollection.hpp`:

```hpp
#pragma once

#include "CUtlReference.hpp"
#include "CUtlString.hpp"
#include "helpers/pad.hpp"

#include <render/Color.hpp>

#define PARTICLE_ATTRIBUTE_TINT_RGB 6
#define PARTICLE_ATTRIBUTE_ALPHA	7

#define MAX_PARTICLE_ATTRIBUTES 24

struct CParticleAttributeAddressTable
{
	float* m_pAttributes[MAX_PARTICLE_ATTRIBUTES];
	size_t m_nFloatStrides[MAX_PARTICLE_ATTRIBUTES];

	float* floatAttribute(int attribute, int particleNum) const
	{
		int blockofs = particleNum / 4;
		return m_pAttributes[attribute] +
			m_nFloatStrides[attribute] * blockofs +
			(particleNum & 3);
	}
	// custom
	void modulateColor(const Color& color, int num)
	{
		/*
		0 : 0.948685
		1 : 0.942262
		2 : 0.898302
		3 : 0.932009
		4 : 0.885635
		5 : 0.878489
		6 : 0.717303
		7 : 0.840896
		8 : 0.670859
		*/

		auto rgb = floatAttribute(PARTICLE_ATTRIBUTE_TINT_RGB, num);
		auto a = floatAttribute(PARTICLE_ATTRIBUTE_ALPHA, num);


		rgb[0] = color.r();
		rgb[4] = color.g();
		rgb[8] = color.b();

		*a = color.a();
	}
	void modulateAlpha(float alpha, int num)
	{
		auto a = floatAttribute(PARTICLE_ATTRIBUTE_ALPHA, num);
		*a = alpha;
	}
};

class CParticleSystemDefinition
{
	PAD(308);
	CUtlString m_name;
};

class CParticleCollection
{
	PAD(48);
	int m_activeParticles;
	PAD(12);
	CUtlReference<CParticleSystemDefinition> m_def;
	PAD(60);
	CParticleCollection* m_parent;
	PAD(84);
	CParticleAttributeAddressTable m_particleAttributes;
};
```

`hack/SDK/CPlayerResource.hpp`:

```hpp
#pragma once

#include <utility>

#include "helpers/netvars.hpp"

class PlayerResource
{
public:
	int getKills(int id)
	{
		const static auto addr = netvarMan.getNetvar(XOR("DT_PlayerResource"), XOR("m_iKills"));
		return *reinterpret_cast<int*>(uintptr_t(this) + addr + id * sizeof(int*));
	}
	int getDeaths(int id)
	{
		const static auto addr = netvarMan.getNetvar(XOR("DT_PlayerResource"), XOR("m_iDeaths"));
		return *reinterpret_cast<int*>(uintptr_t(this) + addr + id * sizeof(int*));
	}
	int getPing(int id)
	{
		const static auto addr = netvarMan.getNetvar(XOR("DT_PlayerResource"), XOR("m_iPing"));
		return *reinterpret_cast<int*>(uintptr_t(this) + addr + id * sizeof(int*));
	}
	std::string getRank(int id, bool useShortName = false)
	{
		const static auto addr = netvarMan.getNetvar(XOR("DT_CSPlayerResource"), XOR("m_iCompetitiveRanking"));

		const static std::pair<std::string, std::string> ranks[] =
		{
			{ "-", "-"},
			{"Silver I", "S1"},
			{"Silver II", "S2"},
			{"Silver III", "S3"},
			{"Silver IV", "S4"},
			{"Silver Elite", "SE"},
			{"Silver Elite Master", "SEM"},
			{"Gold Nova I", "G1"},
			{"Gold Nova II", "G2"},
			{"Gold Nova III", "G3"},
			{"Gold Nova Master", "GM"},
			{"Master Guardian I", "MG1"},
			{"Master Guardian II", "MG2"},
			{"Master Guardian Elite", "MGE"},
			{"Distinguished Master Guardian", "DMG"},
			{"Legendary Eagle", "LE"},
			{"Legendary Eagle Master", "LEM"},
			{"Supreme Master First Class", "SUPREME"},
			{"The Global Elite", "GLOBAL"}
		};
		static size_t size = sizeof(ranks) / sizeof(ranks[0]);
		int rank = *reinterpret_cast<int*>(uintptr_t(this) + addr + id * sizeof(int*));
		const auto& str = !useShortName ? ranks[rank].first : ranks[rank].second;

		return str;
	}

	int getWins(int id)
	{
		const static auto addr = netvarMan.getNetvar(XOR("DT_CSPlayerResource"), XOR("m_iCompetitiveWins"));
		return *reinterpret_cast<int*>(uintptr_t(this) + addr + id * sizeof(int*));
	}
};
```

`hack/SDK/CPredictionCopy.cpp`:

```cpp
#include "CPredictionCopy.hpp"

#include <gamememory/memory.hpp>

CPredictionCopy::CPredictionCopy(int type, byte* dest, bool dest_packed, const byte* src, bool src_packed, optype_t opType, FN_FIELD_COMPARE func)
{
	this->m_OpType = opType;
	this->m_type = type;
	this->m_dest = dest;
	this->m_src = src;
	m_destOffsetIndex = dest_packed ? TD_OFFSET_PACKED : TD_OFFSET_NORMAL;
	m_srcOffsetIndex = src_packed ? TD_OFFSET_PACKED : TD_OFFSET_NORMAL;

	m_errorCount = 0;
	m_entIndex = -1;

	m_watchField = NULL;
	m_fieldCompareFunc = func;
}

int CPredictionCopy::transferData(const char* operation, int entindex, DataMap_t* dmap)
{
	return memory::transferData()(this, operation, entindex, dmap);
}
```

`hack/SDK/CPredictionCopy.hpp`:

```hpp
#pragma once

#include "datamap.hpp"
#include <stack>

#define PC_DATA_PACKED true
#define PC_DATA_NORMAL false

typedef void (*FN_FIELD_COMPARE)(const char* classname, const char* fieldname, const char* fieldtype,
	bool networked, bool noterrorchecked, bool differs, bool withintolerance, const char* value);

enum
{
	SLOT_ORIGINALDATA = -1,
};

class CPredictionCopy
{
public:
	typedef enum
	{
		DIFFERS = 0,
		IDENTICAL,
		WITHINTOLERANCE,
	} difftype_t;

	typedef enum
	{
		TRANSFERDATA_COPYONLY = 0,  // Data copying only (uses runs)
		TRANSFERDATA_ERRORCHECK_NOSPEW, // Checks for errors, returns after first error found
		TRANSFERDATA_ERRORCHECK_SPEW,   // checks for errors, reports all errors to console
		TRANSFERDATA_ERRORCHECK_DESCRIBE, // used by hud_pdump, dumps values, etc, for all fields
	} optype_t;

	CPredictionCopy(int type, byte* dest, bool dest_packed, const byte* src, bool src_packed,
		optype_t opType, FN_FIELD_COMPARE func = NULL);

	int transferData(const char* operation, int entindex, DataMap_t* dmap);
private:
	optype_t m_OpType;
	int m_type;
	byte* m_dest;
	const byte* m_src;
	int m_destOffsetIndex;
	int	m_srcOffsetIndex;
	int	m_errorCount;
	int	m_entIndex;
	FN_FIELD_COMPARE m_fieldCompareFunc;
	const Typedescription_t* m_watchField;
	char const* m_operation;
	std::stack<const Typedescription_t*> m_fieldStack;
};

```

`hack/SDK/CStudioHdr.hpp`:

```hpp
#pragma once

#include "CUtlVector.hpp"
#include "IVModelInfo.hpp"

#include "helpers/pad.hpp"

struct Virtualmodel_t;

struct CStudioHdr
{
	const Studiohdr_t* m_studioHdr;
	Virtualmodel_t* m_vModel;
	/*const virtualmodel_t* ResetVModel(const virtualmodel_t* pVModel) const;
	const studiohdr_t* GroupStudioHdr(int group);*/
	CUtlVector<const Studiohdr_t*> m_studioHdrCache;
	int m_sizeframeUnlockCounter;
	int* m_frameUnlockCounter;
	/*CThreadFastMutex	m_FrameUnlockCounterMutex;*/
	PAD(8);
	CUtlVector<int> m_boneFlags;
	CUtlVector<int> m_boneParent;
};
```

`hack/SDK/CTeslaInfo.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"
#include <render/Color.hpp>

class CTeslaInfo
{
public:
	Vec3 m_pos;
	Vec3 m_angles;
	int m_entIndex;
	const char* m_spriteName;
	float m_beamWidth;
	int m_beams;
	Vec3 m_color;
	float m_timeVisible;
	float m_radius;

	void setColor(const Color& color)
	{
		m_color = Vec3{ color.r(), color.g(), color.b() };
	}
};

```

`hack/SDK/CUserCmd.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"
#include "checksum_crc.hpp"

#include "helpers/pad.hpp"

class CUserCmd
{
public:
	CRC32_t getChecksum(void) const
	{
		CRC32_t crc;

		CRC32_Init(&crc);
		CRC32_ProcessBuffer(&crc, &m_commandNumber, sizeof(m_commandNumber));
		CRC32_ProcessBuffer(&crc, &m_tickcount, sizeof(m_tickcount));
		CRC32_ProcessBuffer(&crc, &m_viewangles, sizeof(m_viewangles));
		CRC32_ProcessBuffer(&crc, &m_aimdirection, sizeof(m_aimdirection));
		CRC32_ProcessBuffer(&crc, &m_forwardmove, sizeof(m_forwardmove));
		CRC32_ProcessBuffer(&crc, &m_sidemove, sizeof(m_sidemove));
		CRC32_ProcessBuffer(&crc, &m_upmove, sizeof(m_upmove));
		CRC32_ProcessBuffer(&crc, &m_buttons, sizeof(m_buttons));
		CRC32_ProcessBuffer(&crc, &m_impulse, sizeof(m_impulse));
		CRC32_ProcessBuffer(&crc, &m_weaponSelect, sizeof(m_weaponSelect));
		CRC32_ProcessBuffer(&crc, &m_weaponSubtype, sizeof(m_weaponSubtype));
		CRC32_ProcessBuffer(&crc, &m_randomSeed, sizeof(m_randomSeed));
		CRC32_ProcessBuffer(&crc, &m_mousedx, sizeof(m_mousedx));
		CRC32_ProcessBuffer(&crc, &m_mousedy, sizeof(m_mousedy));
		CRC32_Final(&crc);

		return crc;
	}

	PAD(4);
	int m_commandNumber;
	int m_tickcount;
	Vec3 m_viewangles;
	Vec3 m_aimdirection;
	float m_forwardmove;
	float m_sidemove;
	float m_upmove;
	int m_buttons;
	char m_impulse;
	int m_weaponSelect;
	int m_weaponSubtype;
	int m_randomSeed;
	short m_mousedx;
	short m_mousedy;
	bool m_predicted;
	PAD(24);
};

class CVerifiedUserCmd
{
public:
	CUserCmd m_cmd;
	unsigned long m_crc;
};
```

`hack/SDK/CUtlReference.hpp`:

```hpp
#pragma once

template<typename T>
struct CUtlReference
{
	CUtlReference* m_next;
	CUtlReference* m_prev;
	T* m_obj;
};

```

`hack/SDK/CUtlString.hpp`:

```hpp
#pragma once

struct CUtlString
{
	char* m_buffer;
	int m_capacity;
	int m_growSize;
	int m_length;
};
```

`hack/SDK/CUtlVector.hpp`:

```hpp
#pragma once

template <typename T>
class CUtlVector
{
public:
	constexpr T& operator[](int i)
	{
		return m_memory[i];
	};

	T* m_memory;
	int m_sizeCount;
	int m_growSize;
	int m_size;
	T* m_elementsCount;
};
```

`hack/SDK/CViewSetup.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"

#include "helpers/pad.hpp"

class CViewSetup
{
public:
	int x;
	int xOld;
	int y;
	int yOld;
	int m_width;
	int m_widthOld;
	int m_height;
	int m_heightOld;
	PAD(144);
	float m_fov;
	float m_viewModelFov;
	Vec3 m_origin;
	Vec3 m_angles;
	float m_nearZ;
	float m_farZ;
	float m_nearViewModelZ;
	float m_farViewModelZ;
	float m_aspectRatio;
	float m_nearBlurDepth;
	float m_nearFocusDepth;
	float m_farFocusDepth;
	float m_farBlurDepth;
	float m_nearBlurRadius;
	float m_farBlurRadius;
	float m_doFQuality;
	int m_motionBlurMode;
	float m_shutterTime;
	Vec3 m_shutterOpenPosition;
	Vec3 m_shutterOpenAngles;
	Vec3 m_shutterClosePosition;
	Vec3 m_shutterCloseAngles;
	float m_offCenterTop;
	float m_offCenterBottom;
	float m_offCenterLeft;
	float m_offCenterRight;
	int m_edgeBlur;
};
```

`hack/SDK/ClientClass.hpp`:

```hpp
#pragma once

#include "Recv.hpp"

class ClientClass
{
private:
	using createfn = void* (__cdecl*)(int, int);
	using createeventfn = void* (__cdecl*)();
public:
	createfn m_createFn;
	createeventfn m_createEventFn;
	char* m_networkName;
	RecvTable* m_recvTable;
	ClientClass* m_next;
	int m_classID;
};
```

`hack/SDK/ClientMode.hpp`:

```hpp
#pragma once

class ClientMode;
```

`hack/SDK/ConVar.hpp`:

```hpp
#pragma once

#include "CUtlVector.hpp"
#include "helpers/pad.hpp"
#include "helpers/vfunc.hpp"

class IConVar
{
public:
	VFUNC(float, getFloat, 12, (), (this));
	VFUNC(int, getInt, 13, (), (this));
	VFUNC(void, setValue, 14, (const char* val), (this, val));
	VFUNC(void, setValue, 15, (float val), (this, val));
	VFUNC(void, setValue, 16, (int val), (this, val));
	VFUNC(void, setValue, 17, (bool val), (this, val));

	PAD(4);
	IConVar* m_next;
	int m_isRegistered;
	char* m_name;
	char* m_helper;
	int m_flags;
	PAD(4);
	IConVar* m_parent;
	char* m_defaultVal;
	char* m_string;
	int m_stringLenght;
	float m_floatVal;
	int m_numVal;
	int m_hasMIn;
	float m_min;
	int m_hasMax;
	float m_max;
	CUtlVector<void(__cdecl*)()> m_callbacks;
};
```

`hack/SDK/EHandle.hpp`:

```hpp
#pragma once

#include <cstdint>

struct EHandle_t
{
	uint32_t handle;
	constexpr bool operator!() const { return handle != -1; } // 0xFFFFFFFF
	// when cant use ! at beginning
	constexpr bool isValid() const { return handle != -1; } // 0xFFFFFFFF
};

```

`hack/SDK/Enums.hpp`:

```hpp
#pragma once

#pragma region beams
enum BeamEffects
{
	TE_BEAMPOINTS = 0x00,		// beam effect between two points
	TE_SPRITE = 0x01,	// additive sprite, plays 1 cycle
	TE_BEAMDISK = 0x02,	// disk that expands to max radius over lifetime
	TE_BEAMCYLINDER = 0x03,		// cylinder that expands to max radius over lifetime
	TE_BEAMFOLLOW = 0x04,		// create a line of decaying beam segments until entity stops moving
	TE_BEAMRING = 0x05,		// connect a beam ring to two entities
	TE_BEAMSPLINE = 0x06,
	TE_BEAMRINGPOINT = 0x07,
	TE_BEAMLASER = 0x08,		// Fades according to viewpoint
	TE_BEAMTESLA = 0x09,
};

enum BeamTypes
{
	FBEAM_STARTENTITY = 0x00000001,
	FBEAM_ENDENTITY = 0x00000002,
	FBEAM_FADEIN = 0x00000004,
	FBEAM_FADEOUT = 0x00000008,
	FBEAM_SINENOISE = 0x00000010,
	FBEAM_SOLID = 0x00000020,
	FBEAM_SHADEIN = 0x00000040,
	FBEAM_SHADEOUT = 0x00000080,
	FBEAM_ONLYNOISEONCE = 0x00000100,		// Only calculate our noise once
	FBEAM_NOTILE = 0x00000200,
	FBEAM_USE_HITBOXES = 0x00000400,		// Attachment indices represent hitbox indices instead when this is set.
	FBEAM_STARTVISIBLE = 0x00000800,		// Has this client actually seen this beam's start entity yet?
	FBEAM_ENDVISIBLE = 0x00001000,		// Has this client actually seen this beam's end entity yet?
	FBEAM_ISACTIVE = 0x00002000,
	FBEAM_FOREVER = 0x00004000,
	FBEAM_HALOBEAM = 0x00008000,		// When drawing a beam with a halo, don't ignore the segments and endwidth
	FBEAM_REVERSED = 0x00010000,
	NUM_BEAM_FLAGS = 17	// KEEP THIS UPDATED!
};
#pragma endregion

#pragma region all_classes_ids

/*
* to get this faster from dump, run this js script
* let str = ``; // dumped all classes, raw output from console
* let arr = str.split('\n');

for(let i = 0; i < arr.length; i++) {
	let s = arr[i];
	let endPos = s.indexOf('(');
	let resultString = arr[i].substring(0, endPos);
	console.log(resultString + ',');
}
*/

enum ClassID
{
	CAI_BaseNPC,
	CAK47,
	CBaseAnimating,
	CBaseAnimatingOverlay,
	CBaseAttributableItem,
	CBaseButton,
	CBaseCombatCharacter,
	CBaseCombatWeapon,
	CBaseCSGrenade,
	CBaseCSGrenadeProjectile,
	CBaseDoor,
	CBaseEntity,
	CBaseFlex,
	CBaseGrenade,
	CBaseParticleEntity,
	CBasePlayer,
	CBasePropDoor,
	CBaseTeamObjectiveResource,
	CBaseTempEntity,
	CBaseToggle,
	CBaseTrigger,
	CBaseViewModel,
	CBaseVPhysicsTrigger,
	CBaseWeaponWorldModel,
	CBeam,
	CBeamSpotlight,
	CBoneFollower,
	CBRC4Target,
	CBreachCharge,
	CBreachChargeProjectile,
	CBreakableProp,
	CBreakableSurface,
	CBumpMine,
	CBumpMineProjectile,
	CC4,
	CCascadeLight,
	CChicken,
	CColorCorrection,
	CColorCorrectionVolume,
	CCSGameRulesProxy,
	CCSPlayer,
	CCSPlayerResource,
	CCSRagdoll,
	CCSTeam,
	CDangerZone,
	CDangerZoneController,
	CDEagle,
	CDecoyGrenade,
	CDecoyProjectile,
	CDrone,
	CDronegun,
	CDynamicLight,
	CDynamicProp,
	CEconEntity,
	CEconWearable,
	CEmbers,
	CEntityDissolve,
	CEntityFlame,
	CEntityFreezing,
	CEntityParticleTrail,
	CEnvAmbientLight,
	CEnvDetailController,
	CEnvDOFController,
	CEnvGasCanister,
	CEnvParticleScript,
	CEnvProjectedTexture,
	CEnvQuadraticBeam,
	CEnvScreenEffect,
	CEnvScreenOverlay,
	CEnvTonemapController,
	CEnvWind,
	CFEPlayerDecal,
	CFireCrackerBlast,
	CFireSmoke,
	CFireTrail,
	CFish,
	CFists,
	CFlashbang,
	CFogController,
	CFootstepControl,
	CFunc_Dust,
	CFunc_LOD,
	CFuncAreaPortalWindow,
	CFuncBrush,
	CFuncConveyor,
	CFuncLadder,
	CFuncMonitor,
	CFuncMoveLinear,
	CFuncOccluder,
	CFuncReflectiveGlass,
	CFuncRotating,
	CFuncSmokeVolume,
	CFuncTrackTrain,
	CGameRulesProxy,
	CGrassBurn,
	CHandleTest,
	CHEGrenade,
	CHostage,
	CHostageCarriableProp,
	CIncendiaryGrenade,
	CInferno,
	CInfoLadderDismount,
	CInfoMapRegion,
	CInfoOverlayAccessor,
	CItem_Healthshot,
	CItemCash,
	CItemDogtags,
	CKnife,
	CKnifeGG,
	CLightGlow,
	CMapVetoPickController,
	CMaterialModifyControl,
	CMelee,
	CMolotovGrenade,
	CMolotovProjectile,
	CMovieDisplay,
	CParadropChopper,
	CParticleFire,
	CParticlePerformanceMonitor,
	CParticleSystem,
	CPhysBox,
	CPhysBoxMultiplayer,
	CPhysicsProp,
	CPhysicsPropMultiplayer,
	CPhysMagnet,
	CPhysPropAmmoBox,
	CPhysPropLootCrate,
	CPhysPropRadarJammer,
	CPhysPropWeaponUpgrade,
	CPlantedC4,
	CPlasma,
	CPlayerPing,
	CPlayerResource,
	CPointCamera,
	CPointCommentaryNode,
	CPointWorldText,
	CPoseController,
	CPostProcessController,
	CPrecipitation,
	CPrecipitationBlocker,
	CPredictedViewModel,
	CProp_Hallucination,
	CPropCounter,
	CPropDoorRotating,
	CPropJeep,
	CPropVehicleDriveable,
	CRagdollManager,
	CRagdollProp,
	CRagdollPropAttached,
	CRopeKeyframe,
	CSCAR17,
	CSceneEntity,
	CSensorGrenade,
	CSensorGrenadeProjectile,
	CShadowControl,
	CSlideshowDisplay,
	CSmokeGrenade,
	CSmokeGrenadeProjectile,
	CSmokeStack,
	CSnowball,
	CSnowballPile,
	CSnowballProjectile,
	CSpatialEntity,
	CSpotlightEnd,
	CSprite,
	CSpriteOriented,
	CSpriteTrail,
	CStatueProp,
	CSteamJet,
	CSun,
	CSunlightShadowControl,
	CSurvivalSpawnChopper,
	CTablet,
	CTeam,
	CTeamplayRoundBasedRulesProxy,
	CTEArmorRicochet,
	CTEBaseBeam,
	CTEBeamEntPoint,
	CTEBeamEnts,
	CTEBeamFollow,
	CTEBeamLaser,
	CTEBeamPoints,
	CTEBeamRing,
	CTEBeamRingPoint,
	CTEBeamSpline,
	CTEBloodSprite,
	CTEBloodStream,
	CTEBreakModel,
	CTEBSPDecal,
	CTEBubbles,
	CTEBubbleTrail,
	CTEClientProjectile,
	CTEDecal,
	CTEDust,
	CTEDynamicLight,
	CTEEffectDispatch,
	CTEEnergySplash,
	CTEExplosion,
	CTEFireBullets,
	CTEFizz,
	CTEFootprintDecal,
	CTEFoundryHelpers,
	CTEGaussExplosion,
	CTEGlowSprite,
	CTEImpact,
	CTEKillPlayerAttachments,
	CTELargeFunnel,
	CTEMetalSparks,
	CTEMuzzleFlash,
	CTEParticleSystem,
	CTEPhysicsProp,
	CTEPlantBomb,
	CTEPlayerAnimEvent,
	CTEPlayerDecal,
	CTEProjectedDecal,
	CTERadioIcon,
	CTEShatterSurface,
	CTEShowLine,
	CTesla,
	CTESmoke,
	CTESparks,
	CTESprite,
	CTESpriteSpray,
	CTest_ProxyToggle_Networkable,
	CTestTraceline,
	CTEWorldDecal,
	CTriggerPlayerMovement,
	CTriggerSoundOperator,
	CVGuiScreen,
	CVoteController,
	CWaterBullet,
	CWaterLODControl,
	CWeaponAug,
	CWeaponAWP,
	CWeaponBaseItem,
	CWeaponBizon,
	CWeaponCSBase,
	CWeaponCSBaseGun,
	CWeaponCycler,
	CWeaponElite,
	CWeaponFamas,
	CWeaponFiveSeven,
	CWeaponG3SG1,
	CWeaponGalil,
	CWeaponGalilAR,
	CWeaponGlock,
	CWeaponHKP2000,
	CWeaponM249,
	CWeaponM3,
	CWeaponM4A1,
	CWeaponMAC10,
	CWeaponMag7,
	CWeaponMP5Navy,
	CWeaponMP7,
	CWeaponMP9,
	CWeaponNegev,
	CWeaponNOVA,
	CWeaponP228,
	CWeaponP250,
	CWeaponP90,
	CWeaponSawedoff,
	CWeaponSCAR20,
	CWeaponScout,
	CWeaponSG550,
	CWeaponSG552,
	CWeaponSG556,
	CWeaponShield,
	CWeaponSSG08,
	CWeaponTaser,
	CWeaponTec9,
	CWeaponTMP,
	CWeaponUMP45,
	CWeaponUSP,
	CWeaponXM1014,
	CWeaponZoneRepulsor,
	CWorld,
	CWorldVguiText,
	DustTrail,
	MovieExplosion,
	ParticleSmokeGrenade,
	RocketTrail,
	SmokeTrail,
	SporeExplosion,
	SporeTrail,
};
#pragma endregion

#pragma region framestage
enum FrameStage
{
	FRAME_UNDEFINED = -1,
	FRAME_START,
	FRAME_NET_UPDATE_START,
	FRAME_NET_UPDATE_POSTDATAUPDATE_START,
	FRAME_NET_UPDATE_POSTDATAUPDATE_END,
	FRAME_NET_UPDATE_END,
	FRAME_RENDER_START,
	FRAME_RENDER_END
};
#pragma endregion

#pragma region weapons
enum WeaponType
{
	WEAPONTYPE_KNIFE = 0,
	WEAPONTYPE_PISTOL,
	WEAPONTYPE_SUBMACHINEGUN,
	WEAPONTYPE_RIFLE,
	WEAPONTYPE_SHOTGUN,
	WEAPONTYPE_SNIPER_RIFLE,
	WEAPONTYPE_MACHINEGUN,
	WEAPONTYPE_C4,
	WEAPONTYPE_PLACEHOLDER,
	WEAPONTYPE_GRENADE,
	WEAPONTYPE_UNKNOWN
};

enum WeaponIndex
{
	WEAPON_NONE,
	WEAPON_DEAGLE,
	WEAPON_ELITE,
	WEAPON_FIVESEVEN,
	WEAPON_GLOCK,
	WEAPON_AK47 = 7,
	WEAPON_AUG,
	WEAPON_AWP,
	WEAPON_FAMAS,
	WEAPON_G3SG1,
	WEAPON_GALILAR = 13,
	WEAPON_M249,
	WEAPON_M4A1 = 16,
	WEAPON_MAC10,
	WEAPON_P90 = 19,
	WEAPON_ZONE_REPULSOR,
	WEAPON_MP5SD = 23,
	WEAPON_UMP45,
	WEAPON_XM1014,
	WEAPON_BIZON,
	WEAPON_MAG7,
	WEAPON_NEGEV,
	WEAPON_SAWEDOFF,
	WEAPON_TEC9,
	WEAPON_TASER,
	WEAPON_HKP2000,
	WEAPON_MP7,
	WEAPON_MP9,
	WEAPON_NOVA,
	WEAPON_P250,
	WEAPON_SHIELD,
	WEAPON_SCAR20,
	WEAPON_SG553,
	WEAPON_SSG08,
	WEAPON_KNIFEGG,
	WEAPON_KNIFE,
	WEAPON_FLASHBANG,
	WEAPON_HEGRENADE,
	WEAPON_SMOKEGRENADE,
	WEAPON_MOLOTOV,
	WEAPON_DECOY,
	WEAPON_INCGRENADE,
	WEAPON_C4,
	WEAPON_HEALTHSHOT = 57,
	WEAPON_KNIFE_T = 59,
	WEAPON_M4A1_SILENCER,
	WEAPON_USP_SILENCER,
	WEAPON_CZ75A = 63,
	WEAPON_REVOLVER,
	WEAPON_TAGRENADE = 68,
	WEAPON_FISTS,
	WEAPON_BREACHCHARGE,
	WEAPON_TABLET = 72,
	WEAPON_MELEE = 74,
	WEAPON_AXE,
	WEAPON_HAMMER,
	WEAPON_SPANNER = 78,
	WEAPON_KNIFE_GHOST = 80,
	WEAPON_FIREBOMB,
	WEAPON_DIVERSION,
	WEAPON_FRAG_GRENADE,
	WEAPON_SNOWBALL,
	WEAPON_BUMPMINE,
	WEAPON_KNIFE_BAYONET = 500,
	WEAPON_KNIFE_CSS = 503,
	WEAPON_KNIFE_FLIP = 505,
	WEAPON_KNIFE_GUT,
	WEAPON_KNIFE_KARAMBIT,
	WEAPON_KNIFE_M9_BAYONET,
	WEAPON_KNIFE_TACTICAL,
	WEAPON_KNIFE_FALCHION = 512,
	WEAPON_KNIFE_SURVIVAL_BOWIE = 514,
	WEAPON_KNIFE_BUTTERFLY,
	WEAPON_KNIFE_PUSH,
	WEAPON_KNIFE_CORD,
	WEAPON_KNIFE_CANIS,
	WEAPON_KNIFE_URSUS,
	WEAPON_KNIFE_GYPSY_JACKKNIFE,
	WEAPON_KNIFE_OUTDOOR,
	WEAPON_KNIFE_STILETTO,
	WEAPON_KNIFE_WIDOWMAKER,
	WEAPON_KNIFE_SKELETON = 525,
	GLOVE_STUDDED_BLOODHOUND = 5027,
	GLOVE_T_SIDE,
	GLOVE_CT_SIDE,
	GLOVE_SPORTY,
	GLOVE_SLICK,
	GLOVE_LEATHER_WRAP,
	GLOVE_MOTORCYCLE,
	GLOVE_SPECIALIST,
	GLOVE_HYDRA,
};
#pragma endregion

#pragma region spec_stuff
enum ObserverTypes
{
	UNKNOWN_CAM,
	DEATH_CAM,
	FREEZE_CAM,
	FIXED_CAM,
	PERSPECTIVE_CAM,
	THIRD_PERSON_CAM,
	FREE_LOOK_CAM,
	UNDEFINED_CAM
};
#pragma endregion

#pragma region collisions
enum CollisionGroup_t : size_t
{
	COLLISION_GROUP_NONE = 0,
	COLLISION_GROUP_DEBRIS,			// Collides with nothing but world and static stuff
	COLLISION_GROUP_DEBRIS_TRIGGER, // Same as debris, but hits triggers
	COLLISION_GROUP_INTERACTIVE_DEBRIS,	// Collides with everything except other interactive debris or debris
	COLLISION_GROUP_INTERACTIVE,	// Collides with everything except interactive debris or debris
	COLLISION_GROUP_PLAYER,
	COLLISION_GROUP_BREAKABLE_GLASS,
	COLLISION_GROUP_VEHICLE,
	COLLISION_GROUP_PLAYER_MOVEMENT,  // For HL2, same as Collision_Group_Player, for // TF2, this filters out other players and CBaseObjects
	COLLISION_GROUP_NPC,			// Generic NPC group
	COLLISION_GROUP_IN_VEHICLE,		// for any entity inside a vehicle
	COLLISION_GROUP_WEAPON,			// for any weapons that need collision detection
	COLLISION_GROUP_VEHICLE_CLIP,	// vehicle clip brush to restrict vehicle movement
	COLLISION_GROUP_PROJECTILE,		// Projectiles!
	COLLISION_GROUP_DOOR_BLOCKER,	// Blocks entities not permitted to get near moving doors
	COLLISION_GROUP_PASSABLE_DOOR,	// Doors that the player shouldn't collide with
	COLLISION_GROUP_DISSOLVING,		// Things that are dissolving are in this group
	COLLISION_GROUP_PUSHAWAY,		// Nonsolid on client and server, pushaway in player code
	COLLISION_GROUP_NPC_ACTOR,		// Used so NPCs in scripts ignore the player.
	COLLISION_GROUP_NPC_SCRIPTED,	// USed for NPCs in scripts that should not collide with each other
	LAST_SHARED_COLLISION_GROUP
};
#pragma endregion

#pragma region hitboxes
enum Hitboxes
{
	HITBOX_HEAD,
	HITBOX_NECK,
	HITBOX_PELVIS,
	HITBOX_BELLY,
	HITBOX_THORAX,
	HITBOX_LOWER_CHEST,
	HITBOX_UPPER_CHEST,
	HITBOX_RIGHT_THIGH,
	HITBOX_LEFT_THIGH,
	HITBOX_RIGHT_CALF,
	HITBOX_LEFT_CALF,
	HITBOX_RIGHT_FOOT,
	HITBOX_LEFT_FOOT,
	HITBOX_RIGHT_HAND,
	HITBOX_LEFT_HAND,
	HITBOX_RIGHT_UPPER_ARM,
	HITBOX_RIGHT_FOREARM,
	HITBOX_LEFT_UPPER_ARM,
	HITBOX_LEFT_FOREARM,
	HITBOX_MAX
};
#pragma endregion

#pragma region hitgroups
enum Hitgroups
{
	HITGROUP_GENERIC,
	HITGROUP_HEAD,
	HITGROUP_CHEST,
	HITGROUP_STOMACH,
	HITGROUP_LEFTARM,
	HITGROUP_RIGHTARM,
	HITGROUP_LEFTLEG,
	HITGROUP_RIGHTLEG,
	HITGROUP_GEAR // alerts NPC, but doesn't do damage or bleed (1/100th damage)
};
#pragma endregion

#pragma region render_target
enum MaterialRenderTargetDepth_t
{
	MATERIAL_RT_DEPTH_SHARED = 0x0,
	MATERIAL_RT_DEPTH_SEPARATE = 0x1,
	MATERIAL_RT_DEPTH_NONE = 0x2,
	MATERIAL_RT_DEPTH_ONLY = 0x3,
};

enum RenderTargetSizeMode_t
{
	RT_SIZE_NO_CHANGE = 0,			// Only allowed for render targets that don't want a depth buffer
	// (because if they have a depth buffer, the render target must be less than or equal to the size of the framebuffer).
	RT_SIZE_DEFAULT = 1,				// Don't play with the specified width and height other than making sure it fits in the framebuffer.
	RT_SIZE_PICMIP = 2,				// Apply picmip to the render target's width and height.
	RT_SIZE_HDR = 3,					// frame_buffer_width / 4
	RT_SIZE_FULL_FRAME_BUFFER = 4,	// Same size as frame buffer, or next lower power of 2 if we can't do that.
	RT_SIZE_OFFSCREEN = 5,			// Target of specified size, don't mess with dimensions
	RT_SIZE_FULL_FRAME_BUFFER_ROUNDED_UP = 6 // Same size as the frame buffer, rounded up if necessary for systems that can't do non-power of two textures.
};
#pragma endregion

#pragma region image_format
enum ImageFormat
{
	IMAGE_FORMAT_UNKNOWN = -1,
	IMAGE_FORMAT_RGBA8888 = 0,
	IMAGE_FORMAT_ABGR8888,
	IMAGE_FORMAT_RGB888,
	IMAGE_FORMAT_BGR888,
	IMAGE_FORMAT_RGB565,
	IMAGE_FORMAT_I8,
	IMAGE_FORMAT_IA88,
	IMAGE_FORMAT_P8,
	IMAGE_FORMAT_A8,
	IMAGE_FORMAT_RGB888_BLUESCREEN,
	IMAGE_FORMAT_BGR888_BLUESCREEN,
	IMAGE_FORMAT_ARGB8888,
	IMAGE_FORMAT_BGRA8888,
	IMAGE_FORMAT_DXT1,
	IMAGE_FORMAT_DXT3,
	IMAGE_FORMAT_DXT5,
	IMAGE_FORMAT_BGRX8888,
	IMAGE_FORMAT_BGR565,
	IMAGE_FORMAT_BGRX5551,
	IMAGE_FORMAT_BGRA4444,
	IMAGE_FORMAT_DXT1_ONEBITALPHA,
	IMAGE_FORMAT_BGRA5551,
	IMAGE_FORMAT_UV88,
	IMAGE_FORMAT_UVWQ8888,
	IMAGE_FORMAT_RGBA16161616F,
	IMAGE_FORMAT_RGBA16161616,
	IMAGE_FORMAT_UVLX8888,
	IMAGE_FORMAT_R32F,			// Single-channel 32-bit floating point
	IMAGE_FORMAT_RGB323232F,
	IMAGE_FORMAT_RGBA32323232F,

	// Depth-stencil texture formats for shadow depth mapping
	IMAGE_FORMAT_NV_DST16,		//
	IMAGE_FORMAT_NV_DST24,		//
	IMAGE_FORMAT_NV_INTZ,		// Vendor-specific depth-stencil texture
	IMAGE_FORMAT_NV_RAWZ,		// formats for shadow depth mapping
	IMAGE_FORMAT_ATI_DST16,		//
	IMAGE_FORMAT_ATI_DST24,		//
	IMAGE_FORMAT_NV_NULL,		// Dummy format which takes no video memory

	// Compressed normal map formats
	IMAGE_FORMAT_ATI2N,			// One-surface ATI2N / DXN format
	IMAGE_FORMAT_ATI1N,			// Two-surface ATI1N format

	IMAGE_FORMAT_DXT1_RUNTIME,
	IMAGE_FORMAT_DXT5_RUNTIME,

	NUM_IMAGE_FORMATS
};
#pragma endregion

#pragma region texture_flags
enum CompiledVtfFlags
{
	// Flags from the *.txt config file
	TEXTUREFLAGS_POINTSAMPLE = 0x00000001,
	TEXTUREFLAGS_TRILINEAR = 0x00000002,
	TEXTUREFLAGS_CLAMPS = 0x00000004,
	TEXTUREFLAGS_CLAMPT = 0x00000008,
	TEXTUREFLAGS_ANISOTROPIC = 0x00000010,
	TEXTUREFLAGS_HINT_DXT5 = 0x00000020,
	TEXTUREFLAGS_PWL_CORRECTED = 0x00000040,
	TEXTUREFLAGS_NORMAL = 0x00000080,
	TEXTUREFLAGS_NOMIP = 0x00000100,
	TEXTUREFLAGS_NOLOD = 0x00000200,
	TEXTUREFLAGS_ALL_MIPS = 0x00000400,
	TEXTUREFLAGS_PROCEDURAL = 0x00000800,

	// These are automatically generated by vtex from the texture data.
	TEXTUREFLAGS_ONEBITALPHA = 0x00001000,
	TEXTUREFLAGS_EIGHTBITALPHA = 0x00002000,

	// Newer flags from the *.txt config file
	TEXTUREFLAGS_ENVMAP = 0x00004000,
	TEXTUREFLAGS_RENDERTARGET = 0x00008000,
	TEXTUREFLAGS_DEPTHRENDERTARGET = 0x00010000,
	TEXTUREFLAGS_NODEBUGOVERRIDE = 0x00020000,
	TEXTUREFLAGS_SINGLECOPY = 0x00040000,

	TEXTUREFLAGS_SRGB = 0x00080000, //SRGB correction has already been applied to this texture.

	TEXTUREFLAGS_DEFAULT_POOL = 0x00100000, // Nvidia Stereo Change: Water (Force a texture to the default pool)

	TEXTUREFLAGS_COMBINED = 0x00200000,

	TEXTUREFLAGS_ASYNC_DOWNLOAD = 0x00400000,

	TEXTUREFLAGS_NODEPTHBUFFER = 0x00800000,

	TEXTUREFLAGS_SKIP_INITIAL_DOWNLOAD = 0x01000000, // Skip initial download when creating a procedural texture

	TEXTUREFLAGS_CLAMPU = 0x02000000,
	TEXTUREFLAGS_VERTEXTEXTURE = 0x04000000,	// Usable as a vertex texture
	TEXTUREFLAGS_SSBUMP = 0x08000000,

	TEXTUREFLAGS_MOST_MIPS = 0x10000000, // Don't load the bottom few mips at runtime

	TEXTUREFLAGS_BORDER = 0x20000000,	// Clamp to border color on all texture coordinates

#if defined( _PS3 ) || defined SPU
	// PS3 extensions
	TEXTUREFLAGS_QUINCUNX = 0x40000000,
	TEXTUREFLAGS_QUINCUNX_ALT = 0x80000000,
#elif defined( _X360 )
	TEXTUREFLAGS_ALIAS_COLOR_AND_DEPTH_SURFACES = 0x40000000,
	TEXTUREFLAGS_UNUSED_80000000 = 0x80000000,
#else
	TEXTUREFLAGS_UNUSED_40000000 = 0x40000000,
	TEXTUREFLAGS_UNUSED_80000000 = 0x80000000,
#endif
};
#pragma endregion

#pragma region clear_flags
enum ClearFlags_t
{
	VIEW_CLEAR_COLOR = 0x1,
	VIEW_CLEAR_DEPTH = 0x2,
	VIEW_CLEAR_FULL_TARGET = 0x4,
	VIEW_NO_DRAW = 0x8,
	VIEW_CLEAR_OBEY_STENCIL = 0x10, // Draws a quad allowing stencil test to clear through portals
	VIEW_CLEAR_STENCIL = 0x20,
};
#pragma endregion

#pragma region particles
enum ParticleAttachment_t
{
	PATTACH_ABSORIGIN = 0,			// Create at absorigin, but don't follow
	PATTACH_ABSORIGIN_FOLLOW,		// Create at absorigin, and update to follow the entity
	PATTACH_CUSTOMORIGIN,			// Create at a custom origin, but don't follow
	PATTACH_CUSTOMORIGIN_FOLLOW,	// Create at a custom origin, follow relative position to specified entity
	PATTACH_POINT,					// Create on attachment point, but don't follow
	PATTACH_POINT_FOLLOW,			// Create on attachment point, and update to follow the entity
	PATTACH_EYES_FOLLOW,			// Create on eyes of the attached entity, and update to follow the entity
	PATTACH_OVERHEAD_FOLLOW,		// Create at the top of the entity's bbox
	PATTACH_WORLDORIGIN,			// Used for control points that don't attach to an entity
	PATTACH_ROOTBONE_FOLLOW,		// Create at the root bone of the entity, and update to follow

	MAX_PATTACH_TYPES,
};
#pragma endregion

#pragma region data_update_type
enum DataUpdateType_t
{
	DATA_UPDATE_CREATED = 0,	// indicates it was created +and+ entered the pvs
//	DATA_UPDATE_ENTERED_PVS,
	DATA_UPDATE_DATATABLE_CHANGED,
//	DATA_UPDATE_LEFT_PVS,
//	DATA_UPDATE_DESTROYED,		// FIXME: Could enable this, but it's a little worrying
								// since it changes a bunch of existing code
};
#pragma endregion

#pragma region preciptation
enum PrecipitationType_t
{
	PRECIPITATION_TYPE_RAIN = 0,
	PRECIPITATION_TYPE_SNOW,
	PRECIPITATION_TYPE_ASH,
	PRECIPITATION_TYPE_SNOWFALL,
	PRECIPITATION_TYPE_PARTICLERAIN,
	PRECIPITATION_TYPE_PARTICLEASH,
	PRECIPITATION_TYPE_PARTICLERAINSTORM,
	PRECIPITATION_TYPE_PARTICLESNOW,
	NUM_PRECIPITATION_TYPES
};
#pragma endregion

#pragma region team_ids
enum TeamID
{
	/*TEAM_UNASSIGNED,
	TEAM_SPECTATOR,
	TEAM_TERRORIST,
	TEAM_COUNTER_TERRORIST,*/
	None,
	Spectactor,
	Terrorist,
	Counter_Terrorist
};
#pragma endregion

#pragma region think_methods
enum thinkmethods_t
{
	THINK_FIRE_ALL_FUNCTIONS,
	THINK_FIRE_BASE_ONLY,
	THINK_FIRE_ALL_BUT_BASE,
};
#pragma endregion

#pragma region ent_flags
// entity flags, CBaseEntity::m_iEFlags
enum
{
	EFL_KILLME = (1 << 0),	// This entity is marked for death -- This allows the game to actually delete ents at a safe time
	EFL_DORMANT = (1 << 1),	// Entity is dormant, no updates to client
	EFL_NOCLIP_ACTIVE = (1 << 2),	// Lets us know when the noclip command is active.
	EFL_SETTING_UP_BONES = (1 << 3),	// Set while a model is setting up its bones.
	EFL_KEEP_ON_RECREATE_ENTITIES = (1 << 4), // This is a special entity that should not be deleted when we restart entities only

	EFL_DIRTY_SHADOWUPDATE = (1 << 5),	// Client only- need shadow manager to update the shadow...
	EFL_NOTIFY = (1 << 6),	// Another entity is watching events on this entity (used by teleport)

	// The default behavior in ShouldTransmit is to not send an entity if it doesn't
	// have a model. Certain entities want to be sent anyway because all the drawing logic
	// is in the client DLL. They can set this flag and the engine will transmit them even
	// if they don't have a model.
	EFL_FORCE_CHECK_TRANSMIT = (1 << 7),

	EFL_BOT_FROZEN = (1 << 8),	// This is set on bots that are frozen.
	EFL_SERVER_ONLY = (1 << 9),	// Non-networked entity.
	EFL_NO_AUTO_EDICT_ATTACH = (1 << 10), // Don't attach the edict; we're doing it explicitly

	// Some dirty bits with respect to abs computations
	EFL_DIRTY_ABSTRANSFORM = (1 << 11),
	EFL_DIRTY_ABSVELOCITY = (1 << 12),
	EFL_DIRTY_ABSANGVELOCITY = (1 << 13),
	EFL_DIRTY_SURROUNDING_COLLISION_BOUNDS = (1 << 14),
	EFL_DIRTY_SPATIAL_PARTITION = (1 << 15),
	EFL_HAS_PLAYER_CHILD = (1 << 16),	// One of the child entities is a player.

	EFL_IN_SKYBOX = (1 << 17),	// This is set if the entity detects that it's in the skybox.
	// This forces it to pass the "in PVS" for transmission.
	EFL_USE_PARTITION_WHEN_NOT_SOLID = (1 << 18),	// Entities with this flag set show up in the partition even when not solid
	EFL_TOUCHING_FLUID = (1 << 19),	// Used to determine if an entity is floating

	// FIXME: Not really sure where I should add this...
	EFL_IS_BEING_LIFTED_BY_BARNACLE = (1 << 20),
	EFL_NO_ROTORWASH_PUSH = (1 << 21),		// I shouldn't be pushed by the rotorwash
	EFL_NO_THINK_FUNCTION = (1 << 22),
	EFL_NO_GAME_PHYSICS_SIMULATION = (1 << 23),

	EFL_CHECK_UNTOUCH = (1 << 24),
	EFL_DONTBLOCKLOS = (1 << 25),		// I shouldn't block NPC line-of-sight
	EFL_DONTWALKON = (1 << 26),		// NPC;s should not walk on this entity
	EFL_NO_DISSOLVE = (1 << 27),		// These guys shouldn't dissolve
	EFL_NO_MEGAPHYSCANNON_RAGDOLL = (1 << 28),	// Mega physcannon can't ragdoll these guys.
	EFL_NO_WATER_VELOCITY_CHANGE = (1 << 29),	// Don't adjust this entity's velocity when transitioning into water
	EFL_NO_PHYSCANNON_INTERACTION = (1 << 30),	// Physcannon can't pick these up or punt them
	EFL_NO_DAMAGE_FORCES = (1 << 31),	// Doesn't accept forces from physics damage
};
#pragma endregion
```

`hack/SDK/IBaseClientDll.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"

class ClientClass;

class IBaseClientDLL
{
public:
	VFUNC(ClientClass*, getAllClasses, 8, (), (this));
	VFUNC(bool, dispatchUserMsg, 38, (int msgType, size_t arg1, size_t length, const void* data = nullptr), (this, msgType, arg1, length, data));
};
```

`hack/SDK/IClientEntityList.hpp`:

```hpp
#pragma once

#include "EHandle.hpp"
#include "helpers/vfunc.hpp"

class IClientEntityList
{
public:
	VFUNC(void*, getClientEntity, 3, (int index), (this, index));
	VFUNC(void*, getClientFromHandle, 4, (EHandle_t handle), (this, handle.handle));
	VFUNC(int, numberOfEntites, 5, (bool includeNonNetw), (this, includeNonNetw));
	VFUNC(int, getHighestIndex, 6, (), (this));
	VFUNC(void, setMaxEntites, 7, (int num), (this, num));
	VFUNC(int, getMaxEntities, 8, (), (this));
};
```

`hack/SDK/IClientState.hpp`:

```hpp
#pragma once

#include "helpers/pad.hpp"

class INetChannel;
class IClientState
{
	PAD(156);
	INetChannel* m_netChannel;
	PAD(212);
	int m_deltaTick;
	PAD(19380);
	int m_lastOutGoingCommand;
	int m_chockedCommands;
	int m_lastCommandAck;
	int m_commandAck;
};
```

`hack/SDK/ICollideable.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"
#include "math/matrix.hpp"

#include "helpers/vfunc.hpp"

class ICollideable
{
public:
	VFUNC(Vec3&, OBBMins, 1, (), (this));
	VFUNC(Vec3&, OBBMaxs, 2, (), (this));
	VFUNC(Vec3&, getCollisionAngles, 9, (), (this));
	VFUNC(Matrix3x4&, collisionToWorldTransform, 10, (), (this));
	VFUNC(int, getSolid, 11, (), (this));
	VFUNC(int, getSolidFlags, 12, (), (this));
};
```

`hack/SDK/ICvar.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"

class ConCommand;
class IConVar;
struct SDKColor;

class ICvar
{
public:
	VFUNC(IConVar*, findVar, 15, (const char* name), (this, name));
	VFUNC(ConCommand*, findCommand, 17, (const char* name), (this, name));
	template <typename... Args_t>
	void consoleColorPrintf(const SDKColor& clr, const char* fmt, Args_t... args)
	{
		return vfunc::callVPack<void, 25, const SDKColor&, const char*, Args_t...>(this, std::cref(clr), fmt, args...);
	}
	template<typename... Args_t>
	void consolePrintf(const char* fmt, Args_t... args)
	{
		return vfunc::callVPack<void, 26, const char*, Args_t...>(this, fmt, args...);
	}
};
```

`hack/SDK/IEffects.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"
#include "helpers/vfunc.hpp"

class IEffects
{
public:
	VFUNC(void, beam, 1,
		(const Vec3& start, const Vec3& end, int modelIndex,
			int haloIndex, unsigned char frameStart, unsigned char frameRate,
			float life, unsigned char width, unsigned char endWidth, unsigned char fadeLength,
			unsigned char noise, unsigned char red, unsigned char green,
			unsigned char blue, unsigned char brightness, unsigned char speed),
		(this, std::cref(start), std::cref(end), modelIndex, haloIndex, frameStart, frameRate, life, width, endWidth, fadeLength, noise, red, green, blue, brightness, speed)
	);

	//-----------------------------------------------------------------------------
	// Purpose: Emits smoke sprites.
	// Input  : origin - Where to emit the sprites.
	//			scale - Sprite scale * 10.
	//			framerate - Framerate at which to animate the smoke sprites.
	//-----------------------------------------------------------------------------
	VFUNC(void, smoke, 2, (const Vec3& origin, int modelIndex, float scale, float framerate), (this, std::cref(origin), modelIndex, scale, framerate));
	VFUNC(void, sparks, 3, (const Vec3& position, int magnitude = 1, int trialLength = 1, const Vec3* pvecDir = NULL), (this, std::cref(position), magnitude, trialLength, pvecDir));
	VFUNC(void, dust, 4, (const Vec3& pos, const Vec3& dir, float size, float speed), (this, std::cref(pos), std::cref(dir), size, size, speed));
	VFUNC(void, muzzleFlash, 5, (const Vec3& vecOrigin, const Vec3& vecAngles, float scale, int type), (this, std::cref(vecOrigin), std::cref(vecAngles), scale, type));
	// like ricochet, but no sound
	VFUNC(void, metalSparks, 6, (const Vec3& position, const Vec3& direction), (this, std::cref(position), std::cref(direction)));
	VFUNC(void, energySplash, 7, (const Vec3& position, const Vec3& direction, bool explosive = false), (this, std::cref(position), std::cref(direction), explosive));
	VFUNC(void, ricochet, 8, (const Vec3& position, const Vec3& direction), (this, std::cref(position), std::cref(direction)));

	// if you want to mess with effects abit then add dispatch, I will probably never need it
};
```

`hack/SDK/IEngineTrace.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"
#include "math/VectorAligned.hpp"
#include "math/matrix.hpp"
#include "math/AABB.hpp"
#include "Enums.hpp"
#include "helpers/pad.hpp"
#include "helpers/vfunc.hpp"

#pragma warning(disable: 26495)

class Player_t;

class Ray_t
{
public:
	VectorAligned m_start;
	VectorAligned m_delta;
	VectorAligned m_startOffset;
	VectorAligned m_extents;
	const Matrix3x4* m_mattrixWorldAxis;
	bool m_isRay{};
	bool m_isSwept{};

	Ray_t() = default;
	Ray_t(const Vec3& src, const Vec3& dest) :
		m_start{ src }, m_delta{ dest - src }, m_mattrixWorldAxis{ nullptr }, m_isRay{ true }
	{
		m_isSwept = m_delta.lengthSqrt();
	}
	Ray_t(const Vec3& src, const Vec3& dest, const Vec3& min, const Vec3& max)
	{
		m_delta = (dest - src);

		m_mattrixWorldAxis = nullptr;
		m_isSwept = m_delta.lengthSqrt();

		m_extents = max - min;
		m_extents *= 0.5f;
		m_isRay = m_extents.lengthSqrt() < 1e-6f;

		m_startOffset = min + max;
		m_startOffset *= 0.5f;
		m_start = src + m_startOffset;
		m_startOffset *= -1.0f;
	}
};

struct Csurface_t
{
	const char* m_name;
	short m_props;
	unsigned short m_flags;
};

struct Cplane_t
{
	Vec3 m_normal;
	float m_distance;
	char m_type;
	char m_signBits;
	PAD(2);
};

struct Trace_t
{
	Vec3 m_start;
	Vec3 m_end;
	Cplane_t m_plane;
	float m_fraction;
	int m_contents;
	unsigned short m_flags;
	bool m_allSolid;
	bool m_startSolid;
	float m_fractionLeftSolid;
	Csurface_t m_surface;
	int m_hitgroup;
	short m_physicsBone;
	Player_t* m_entity;
	int m_hitbox;

	bool didHit() const
	{
		return m_fraction < 1.0f || m_allSolid || m_startSolid;
	}
};

class TraceFilter
{
public:
	TraceFilter() = default;
	TraceFilter(void* entity) :
		m_skip{ entity }
	{}
	TraceFilter(void* entity, CollisionGroup_t group) :
		m_skip{ entity }, m_collisionGroup{ group }
	{}
	virtual bool shouldHitEntity(Player_t* ent, int) const
	{
		return ent != m_skip;
	}
	virtual int getTraceType() const
	{
		return m_collisionGroup;
	}
	void* m_skip;
	CollisionGroup_t m_collisionGroup = COLLISION_GROUP_NONE;
};

class IEngineTrace
{
public:
	VFUNC(int, getPointContents, 0, (const Vec3& absPosition, int contentsMask), (this, std::cref(absPosition), contentsMask, nullptr));
	VFUNC(void, traceRay, 5, (const Ray_t& ray, unsigned int mask, TraceFilter* filter, Trace_t* trace), (this, std::cref(ray), mask, filter, trace));
	VFUNC(bool, isFullyOccluded, 26, (int occlusionKey, const AABB_t& from, const AABB_t& to, const Vec3& shadow), (this, occlusionKey, std::cref(from), std::cref(to), std::cref(shadow)));
};
```

`hack/SDK/IGameEvent.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"

class IGameEvent
{
public:
    VFUNC(const char*, getName, 1, (), (this));
    VFUNC(int, getInt, 6, (const char* keyName, int defaultValue = 0), (this, keyName, defaultValue));
    VFUNC(float, getFloat, 8, (const char* keyName, float defaultValue = 0.0f), (this, keyName, defaultValue));
    VFUNC(const char*, getString, 9, (const char* keyName, const char* defaultValue = ""), (this, keyName, defaultValue));
    VFUNC(void, setInt, 13, (const char* keyName, int value), (this, keyName, value));
    VFUNC(void, setString, 16, (const char* keyName, const char* value), (this, keyName, value));
};

class IGameEventListener
{
public:
    virtual ~IGameEventListener() {}

    virtual void FireGameEvent(IGameEvent* event) = 0;
    virtual int GetEventDebugID(void) { return 42; };
};

class IGameEventManager
{
public:
    VFUNC(bool, addListener, 3, (IGameEventListener* listener, const char* name), (this, listener, name, false));
    VFUNC(void, removeListener, 5, (IGameEventListener* listener), (this, listener));
};

```

`hack/SDK/ILocalize.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"

class ILocalize
{
public:
	VFUNC(wchar_t*, findSafe, 12, (const char* name), (this, name));
	VFUNC(const char*, findAsUTF8, 47, (const char* tokenName), (this, tokenName));
};

```

`hack/SDK/IMDLCache.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"

class IMDLCache
{
public:
	VFUNC(void, beginLock, 33, (), (this));
	VFUNC(void, endLock, 34, (), (this));
};

class CMDLCacheCriticalSection
{
public:
	CMDLCacheCriticalSection(IMDLCache* cache)
		: cache{ cache }
	{
		this->cache->beginLock();
	}

	~CMDLCacheCriticalSection()
	{
		cache->endLock();
	}
private:
	IMDLCache* cache;
};

#define MDLCACHE_CRITICAL_SECTION(cache) CMDLCacheCriticalSection cacheCriticalSection(cache)
```

`hack/SDK/IMatRenderContext.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"

class ITexture;
class IMaterial;

class IMatRenderContext
{
public:
    VFUNC(int, release, 1, (), (this));
    VFUNC(void, setRenderTarget, 6, (ITexture* texture), (this, texture));
    VFUNC(void, pushRenderTargetAndViewport, 119, (), (this));
    VFUNC(void, popRenderTargetAndViewport, 120, (), (this));
    VFUNC(void, drawScreenSpaceRectangle, 114,
        (IMaterial* material,
        int destX, int destY, int width, int height,
        float srcTextureX0, float srcTextureY0, float srcTextureX1, float srcTextureY1,
        int srcTextureWidth, int srcTextureHeight,
        void* clientRenderable = nullptr, int nXDice = 1, int nYDice = 1
        ), (this, material, destX, destY, width, height,
            srcTextureX0, srcTextureY0, srcTextureX1, srcTextureY1,
            srcTextureWidth, srcTextureHeight, clientRenderable, nXDice, nYDice));
};
```

`hack/SDK/IMaterialSystem.hpp`:

```hpp
#pragma once

#include "material.hpp"
#include "Enums.hpp"
#include "vars.hpp"

#include "helpers/vfunc.hpp"
#include <gamememory/memory.hpp>

class IMaterial;
class KeyValues;
class IMatRenderContext;
class ITexture;

class IMaterialSystem
{
public:
	VFUNC(IMaterial*, createMaterial, 83, (const char* materialName, KeyValues* keyValues), (this, materialName, keyValues));
	VFUNC(IMaterial*, findMaterial, 84, (char const* name, const char* group, bool complain = true, const char* prefix = nullptr), (this, name, group, complain, prefix));
	VFUNC(short, firstMaterial, 86, (), (this));
	VFUNC(short, nextMaterial, 87, (int handle), (this, handle));
	VFUNC(short, invalidMaterialFromHandle, 88, (), (this));
	VFUNC(IMaterial*, getMaterial, 89, (short handle), (this, handle));
	VFUNC(int, getMaterialCount, 90, (), (this));
	VFUNC(ITexture*, findTexture, 91, (const char* name, const char* group, bool complain = true, int additionalFlags = 0),
		(this, name, group, complain, additionalFlags));
	VFUNC(IMatRenderContext*, getRenderContext, 115, (), (this));
	VFUNC(void, beginRenderTargetAllocation, 94, (), (this));
	VFUNC(void, endRenderTargetAllocation, 95, (), (this));
	VFUNC(ITexture*, createNamedRenderTargetTextureEx, 97,
		(const char* name, int w, int h, RenderTargetSizeMode_t sizeMode, ImageFormat format,
			MaterialRenderTargetDepth_t depth, unsigned int textureFlags, unsigned int renderTargetFlags),
		(this, name, w, h, sizeMode, format, depth, textureFlags, renderTargetFlags));

	ITexture* createFullFrameRenderTarget(const char* name)
	{
		return createNamedRenderTargetTextureEx(
			name, 1, 1, RT_SIZE_FULL_FRAME_BUFFER,
			IMAGE_FORMAT_RGB888, MATERIAL_RT_DEPTH_SHARED,
			TEXTUREFLAGS_CLAMPS | TEXTUREFLAGS_CLAMPT,
			CREATERENDERTARGETFLAGS_HDR);
	}

	// https://www.unknowncheats.me/forum/counterstrike-global-offensive/234226-mirrorcam-ported-window.html

	void forceBeginRenderTargetAllocation()
	{
		bool old = disableRenderTargetAllocationForever();
		disableRenderTargetAllocationForever() = false;
		beginRenderTargetAllocation();
		disableRenderTargetAllocationForever() = old;
	}

	void forceEndRenderTargetAllocation()
	{
		bool old = disableRenderTargetAllocationForever();
		disableRenderTargetAllocationForever() = false;
		endRenderTargetAllocation();
		disableRenderTargetAllocationForever() = old;
	}

	bool& disableRenderTargetAllocationForever()
	{
		const static auto disableTargetAlloc = memory::disableTargetAlloc();
		return *reinterpret_cast<bool*>(uintptr_t(this) + disableTargetAlloc);
	}
};

```

`hack/SDK/IMemAlloc.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"

class IMemAlloc
{
public:
	VFUNC(void*, _alloc, 1, (size_t size), (this, size));
};
```

`hack/SDK/IPanel.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"

class IPanel
{
public:
	VFUNC(const char*, getName, 36, (unsigned int panel), (this, panel));
	VFUNC(void, setMouseInputEnabled, 32, (unsigned int panel, bool state), (this, panel, state));
};
```

`hack/SDK/IPrediction.cpp`:

```cpp
#include "IPrediction.hpp"

#include <gamememory/memory.hpp>

void IPrediction::shutdownPredictables()
{
	memory::shutdownPredicatbles()();
}

int IPrediction::reinitPredictables()
{
	return memory::reinitPredicatbles()();
}
```

`hack/SDK/IPrediction.hpp`:

```hpp
#pragma once

#include "CUserCmd.hpp"
#include "math/Vector.hpp"

#include "helpers/pad.hpp"
#include "helpers/vfunc.hpp"

class Player_t;

class IMoveHelper
{
public:
	VFUNC(void, setHost, 1, (Player_t* host), (this, host));
	VFUNC(void, processImpacts, 4, (), (this));
};

class CMoveData
{
public:
	bool m_firstRunOfFunctions;
	bool m_gameCodeMovedPlayer;
	int m_playerHandle;
	int m_impulseCommand;
	Vec3 m_viewAngles;
	Vec3 m_absViewAngles;
	int m_buttons;
	int m_oldButtons;
	float m_forwardMove;
	float m_sideMove;
	float m_upMove;
	float m_maxSpeed;
	float m_clientMaxSpeed;
	Vec3 m_velocity;
	Vec3 m_angles;
	Vec3 m_oldAngles;
	float m_outStepHeight;
	Vec3 m_outWishVel;
	Vec3 m_outJumpVel;
	Vec3 m_constraintCenter;
	float m_constraintRadius;
	float m_constraintWidth;
	float m_constraintSpeedFactor;
	PAD(20);
	Vec3 m_absOrigin;
};

class IPrediction
{
public:
	VFUNC(void, update, 3, (int startframe, bool validframe, int incomingAcknowledged, int outgoingCommand),
		(this, startframe, validframe, incomingAcknowledged, outgoingCommand));
	VFUNC(void, setLocalViewangles, 13, (Vec3& angle), (this, std::ref(angle)));
	VFUNC(bool, inPrediction, 14, (), (this));
	VFUNC(bool, checkMovingGround, 18, (Player_t* player, double frameTime), (this, player, frameTime));
	VFUNC(void, setupMove, 20, (Player_t* localPlayer, CUserCmd* cmd, IMoveHelper* moveHelper, CMoveData* moveData), (this, localPlayer, cmd, moveHelper, moveData));
	VFUNC(void, finishMove, 21, (Player_t* localPlayer, CUserCmd* cmd, CMoveData* moveData), (this, localPlayer, cmd, moveData));
	void shutdownPredictables();
	int reinitPredictables();

	PAD(8);
	bool m_inPrediction;
	bool m_oldCLPredictValue;
	bool m_firstTimePredicted;
	bool m_enginePaused;
	PAD(13);
	int m_commandsPredicted;
	PAD(4);
	int m_previousAckHadErrors;
};

```

`hack/SDK/ISurface.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"
#include <render/Color.hpp>

#include "helpers/vfunc.hpp"

struct Vertex_t
{
	Vertex_t() = default;
	constexpr Vertex_t(const Vec2& pos, const Vec2& coord = Vec2{})
		: m_Position{ pos }, m_TexCoord{ coord }
	{}

	Vec2 m_Position;
	Vec2 m_TexCoord;
};

class ISurface
{
public:
	VFUNC(void, drawSetColor, 14, (SDKColor color), (this, color));
	VFUNC(void, setTextColor, 24, (SDKColor color), (this, color));
	VFUNC(void, drawTexturedPolygon, 106, (int n, Vertex_t* vertice, bool clip = true), (this, n, vertice, clip));
	VFUNC(void, drawFilledRectangle, 16, (int x, int y, int w, int h), (this, x, y, x + w, y + h));
	VFUNC(void, drawSetTexture, 38, (int id), (this, id));
	VFUNC(void, setTextureRGBA, 37, (int id, const unsigned char* rgba, int wide, int tall), (this, id, rgba, wide, tall));
	VFUNC(void, setTextureRGBA, 37, (int id, Color* rgba, int wide, int tall), (this, id, rgba, wide, tall));
	VFUNC(int, createNewTextureID, 43, (bool procedural = false), (this, procedural));
	VFUNC(bool, deleteTextureID, 39, (int id), (this, id));
	VFUNC(void, drawOutlinedRect, 18, (int x, int y, int w, int h), (this, x, y, x + w, y + h));
	VFUNC(void, drawLine, 19, (int x1, int y1, int x2, int y2), (this, x1, y1, x2, y2));
	VFUNC(void, drawPolyLine, 20, (int* px, int* py, int numPoints), (this, px, py, numPoints));
	VFUNC(void, drawTextFont, 23, (unsigned long font), (this, font));
	VFUNC(void, drawTextPos, 26, (int x, int y), (this, x, y));
	VFUNC(void, drawRenderText, 28, (const wchar_t* text, int textLen), (this, text, textLen, 0));
	VFUNC(unsigned long, fontCreate, 71, (), (this));
	VFUNC(void, setFontGlyph, 72, (unsigned long font, const char* windowsFontName, int tall, int weight, int blur, int scanlines, int flags),
		(this, font, windowsFontName, tall, weight, blur, scanlines, flags, 0, 0));
	VFUNC(void, getTextSize, 79, (unsigned long font, const wchar_t* text, int& wide, int& tall),
		(this, font, text, std::ref(wide), std::ref(tall)));
	VFUNC(void, unlockCursor, 66, (), (this));
	VFUNC(void, setClipRect, 147, (int x, int y, int w, int h), (this, x, y, w, h));
	VFUNC(void, drawFilledFadeRect, 123, (int x, int y, int w, int h, unsigned int alpha1, unsigned int alpha2, bool horizontal),
		(this, x, y, x + w, y + h, alpha1, alpha2, horizontal));
	VFUNC(void, drawColorText, 163, (unsigned long font, int x, int y, Color col, int alpha, const char* text),
		(this, font, x, y, col, alpha, text));
	VFUNC(void, getScreenSize, 44, (int& width, int& height),
		(this, std::ref(width), std::ref(height)));
	VFUNC(void, drawOutlinedCircle, 103, (int x, int y, int radius, int points), (this, x, y, radius, points));
	VFUNC(void, drawTextureFromName, 36, (int id, const char* name, int filter, bool reload = 0), (this, id, name, filter, reload));
	VFUNC(void, getCursor, 100, (int& x, int& y), (this, std::ref(x), std::ref(y)));
	VFUNC(void, drawTexturedRect, 41, (int x, int y, int width, int height), (this, x, y, width, height));
	VFUNC(void, playSound, 82, (const char* name), (this, name));
	VFUNC(bool, isTextureValid, 42, (int id), (this, id));
};
```

`hack/SDK/ITexture.hpp`:

```hpp
#pragma once

#include "helpers/pad.hpp"
#include "helpers/vfunc.hpp"

struct IDirect3DTexture9;

struct TextureHandle_t
{
	PAD(12);
	IDirect3DTexture9* m_texture;
};

class ITexture
{
public:
	VFUNC(int, getActualWidth, 3, (), (this));
	VFUNC(int, getActualHeight, 4, (), (this));
	PAD(80);
	TextureHandle_t** m_handle;
};
```

`hack/SDK/IVDebugOverlay.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"

#include "helpers/vfunc.hpp"

class IVDebugOverlay
{
public:
	VFUNC(bool, worldToScreen, 13, (const Vec3& in, Vec3& out), (this, std::cref(in), std::ref(out)));
};
```

`hack/SDK/IVEffects.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"
#include <render/Color.hpp>

#include "helpers/vfunc.hpp"

enum
{
	DLIGHT_NO_WORLD_ILLUMINATION = 0x1,
	DLIGHT_NO_MODEL_ILLUMINATION = 0x2,

	// NOTE: These two features are used to dynamically tweak the alpha on displacements
	// which is a special effect for selecting which texture to use. If 
	// we ever change how alpha is stored for displacements, we'll have to kill this feature
	DLIGHT_ADD_DISPLACEMENT_ALPHA = 0x4,
	DLIGHT_SUBTRACT_DISPLACEMENT_ALPHA = 0x8,
	DLIGHT_DISPLACEMENT_MASK = (DLIGHT_ADD_DISPLACEMENT_ALPHA | DLIGHT_SUBTRACT_DISPLACEMENT_ALPHA),
};

class DLight_t
{
private:
	struct DColor
	{
		DColor() = default;
		constexpr DColor(uint8_t _r, uint8_t _g, uint8_t _b)
			: r{ _r }, g{ _g }, b{ _b }
		{}
		constexpr DColor(const Color& clr)
			: r{ clr.rMultiplied() }, g{ clr.gMultiplied() }, b{ clr.bMultiplied() }
		{}

		uint8_t r, g, b;
	};
public:
	int m_flags;
	Vec3 m_origin;
	float m_radius;
	DColor m_color;
	char m_exponent;
	float m_die;
	float m_decay;
	float m_minlight;
	int m_key;
	int m_style;
	Vec3 m_direction;
	float m_innerAngle;
	float m_outerAngle;
};

class IVEfx
{
public:
	VFUNC(DLight_t*, clAllocDLight, 4, (int key), (this, key));
	VFUNC(DLight_t*, clAllocElight, 5, (int key), (this, key));
	VFUNC(DLight_t*, getElightByKey, 8, (int key), (this, key));
};
```

`hack/SDK/IVEngineClient.hpp`:

```hpp
#pragma once
#include <cstdint>

#include "math/matrix.hpp"
#include "math/Vector.hpp"

#include "helpers/pad.hpp"
#include "helpers/vfunc.hpp"

#define FLOW_OUTGOING	0
#define FLOW_INCOMING	1
#define MAX_FLOWS		2

class INetChannel
{
public:
	VFUNC(char*, getAddress, 1, (), (this));
	VFUNC(float, getTime, 2, (), (this));
	VFUNC(bool, isLoopBack, 6, (), (this));
	VFUNC(bool, isPlayBack, 8, (), (this));
	VFUNC(float, getLatency, 9, (int flow), (this, flow));
	PAD(24);
	int m_outSequenceNr;
	int m_inSequenceNr;
	int m_outSequenceNrAck;
	int m_outReliableState;
	int m_inReliableState;
	int m_chockedPackets;
};

struct PlayerInfo_t
{
	PAD(8);
	union
	{
		uint64_t m_steamID64;
		struct
		{
			int m_xuidlow;
			int m_xuidhigh;
		};
	};
	char m_name[128];
	int m_userID;
	char m_guid[33];
	uint32_t m_friendsID;
	char m_friendsName[128];
	bool m_fakePlayer;
	bool m_ishltv;
	size_t m_cutomFiles[4];
	uint8_t m_filesDownloaded;
};

class IVEngineClient
{
public:
	VFUNC(bool, isInGame, 26, (), (this));
	VFUNC(bool, isConnected, 27, (), (this));
	VFUNC(int, getLocalPlayer, 12, (), (this));
	VFUNC(int, getPlayerID, 9, (int id), (this, id));
	VFUNC(void, setViewAngles, 19, (const Vec3& angles), (this, std::cref(angles)));
	VFUNC(void, getViewAngles, 18, (Vec3& angles), (this, std::ref(angles)));
	VFUNC(int, getMaxClients, 20, (), (this));
	VFUNC(int, getPlayerInfo, 8, (int index, PlayerInfo_t* info), (this, index, info));
	VFUNC(void, getScreenSize, 5, (int& width, int& height), (this, std::ref(width), std::ref(height)));
	VFUNC(void, executeClientCMD, 114, (const char* cmd, char delay = 0), (this, cmd, delay));
	VFUNC(Matrix4x4&, worldToScreenMatrix, 37, (), (this));
	VFUNC(const char*, getLevelName, 53, (), (this));
	VFUNC(INetChannel*, getNameNetChannel, 78, (), (this));
	VFUNC(bool, isTakingScreenshot, 92, (), (this));
	VFUNC(bool, isConsoleVisible, 11, (), (this));
};

```

`hack/SDK/IVModelInfo.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"

#include "helpers/pad.hpp"
#include "helpers/vfunc.hpp"

struct Mstudiobone_t
{
	int m_nameIndex;
	int m_parent;
	PAD(152);
	int m_flags;
	PAD(52);
};

struct Mstudiobbox_t
{
	int m_bone;
	int m_group;
	Vec3 m_bbmin;
	Vec3 m_bbmax;
	int m_hitboxnameindex;
	PAD(12);
	float m_radius;
	PAD(16);

	const char* getName() const
	{
		return (!m_hitboxnameindex) ? nullptr : reinterpret_cast<const char*>((uint8_t*)this + m_hitboxnameindex);
	}
};

struct Mstudiohitboxset_t
{
	int m_nameIndex;
	int m_hitboxesCount;
	int m_hitboxesIndex;

	const char* getName() const
	{
		return (!m_nameIndex) ? nullptr : reinterpret_cast<const char*>((uint8_t*)this + m_hitboxesIndex);
	}

	Mstudiobbox_t* getHitbox(int i) const
	{
		return (i > m_hitboxesCount) ? nullptr : reinterpret_cast<Mstudiobbox_t*>((uint8_t*)this + m_hitboxesIndex) + i;
	}
};

struct Model_t
{
	void* m_handle;
	char m_name[260];
	int m_loadFlags;
	int m_serverCount;
	int m_type;
	int m_flags;
	Vec3 m_vecMins;
	Vec3 m_vecMaxs;
	float m_radius;
	PAD(28);
};

struct Studiohdr_t
{
	int m_id;
	int m_version;
	long m_checksum;
	char m_name[64];
	int m_length;
	Vec3 m_eyePos;
	Vec3 m_illiumPos;
	Vec3 m_hullMins;
	Vec3 m_hullMaxs;
	Vec3 m_mins;
	Vec3 m_maxs;
	int m_flags;
	int m_bonesCount;
	int m_boneIndex;
	int m_boneControllersCount;
	int m_boneControllerIndex;
	int m_hitboxSetsCount;
	int m_hitboxSetIndex;

	Mstudiohitboxset_t* getHitboxSet(int i) const
	{
		return (i > m_hitboxSetsCount) ? nullptr : reinterpret_cast<Mstudiohitboxset_t*>((uint8_t*)this + m_hitboxSetIndex) + i;
	}

	Mstudiobone_t* getBone(int i) const
	{
		return (i > m_bonesCount) ? nullptr : reinterpret_cast<Mstudiobone_t*>((uint8_t*)this + m_boneIndex) + i;
	}
};

class IVModelInfo
{
public:
	VFUNC(int, getModelIndex, 2, (const char* name), (this, name));
	VFUNC(Studiohdr_t*, getStudioModel, 32, (const Model_t* model), (this, model));
};
```

`hack/SDK/IVModelRender.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"
#include "math/matrix.hpp"

#include "helpers/pad.hpp"
#include "helpers/vfunc.hpp"

struct Model_t;
struct Studiohdr_t;
class IMaterial;

struct ModelRenderInfo_t
{
	Vec3 m_origin;
	Vec3 m_angles;
	PAD(4);
	void* m_renderable;
	const Model_t* m_model;
	const Matrix3x4* m_modelWorld;
	const Matrix3x4* m_lightOffset;
	const Vec3* m_lightOrigin;
	int m_flags;
	int m_entIndex;
	int m_skin;
	int m_body;
	int m_hitboxset;
	unsigned short m_instance;
	ModelRenderInfo_t()
	{
		m_modelWorld = NULL;
		m_lightOffset = NULL;
		m_lightOrigin = NULL;
	}
};

struct DrawModelState_t
{
	Studiohdr_t* m_studioHdr;
	void* m_studioHWData;
	void* m_renderable;
	const Matrix3x4* m_modelToWorld;
	void* m_decals;
	int m_drawFlags;
	int m_lod;
};


class IVModelRender
{
public:
	VFUNC(void, overrideMaterial, 1, (IMaterial* material, int x = 0, int y = 0), (this, material, x, y));
	VFUNC(bool, isForcedMaterial, 2, (), (this));
};

```

`hack/SDK/IVRenderView.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"

class IVRenderView
{
public:
	VFUNC(void, setBlend, 4, (float blend), (this, blend));
	VFUNC(float, getBlend, 5, (), (this));
	VFUNC(void, modulateColor, 6, (float const* blend), (this, blend));
	VFUNC(void, getcolor, 7, (float* blend), (this, blend));
};
```

`hack/SDK/IVStudioRender.hpp`:

```hpp
#pragma once

#include "material.hpp"

#include <utilities/tools/tools.hpp>
#include "helpers/pad.hpp"
#include "helpers/vfunc.hpp"

#include <string>

class IVStudioRender
{
    PAD(592);
private:
    IMaterial* m_material;
    PAD(12);
private:
    OverrideType_t m_type;
public:
    VFUNC(void, forcedMaterialOverride, 33, (IMaterial* mat, OverrideType_t type = OverrideType_t::OVERRIDE_NORMAL, int index = -1), (this, mat, type, index));
    bool isForced()
    {
        return (!m_material)
            ? m_type == OverrideType_t::OVERRIDE_DEPTH_WRITE || m_type == OverrideType_t::OVERRIDE_SSAO_DEPTH_WRITE
            : std::string_view(m_material->getName()).starts_with(XOR("dev/glow"))
            ;
    }
};
```

`hack/SDK/IViewRender.hpp`:

```hpp
#pragma once

class IViewRender;
```

`hack/SDK/IViewRenderBeams.hpp`:

```hpp
#pragma once

#include "IEngineTrace.hpp"
#include "IClientEntityList.hpp"
#include "Enums.hpp"
#include "math/Vector.hpp"

class Entity_t;

struct BeamInfo_t
{
	int m_type;
	Entity_t* m_startEnt;
	int m_startAttachment;
	Entity_t* m_endEnt;
	int m_EndAttachment;
	Vec3 m_vecStart;
	Vec3 m_vecEnd;
	int m_modelIndex;
	const char* m_modelName;
	int m_haloIndex;
	const char* m_haloName;
	float m_haloScale;
	float m_life;
	float m_width;
	float m_endWidth;
	float m_fadeLength;
	float m_amplitude;
	float m_brightness;
	float m_speed;
	int m_startFrame;
	float m_frameRate;
	float m_red;
	float m_green;
	float m_blue;
	bool m_renderable;
	int m_segments;
	int m_flags;
	Vec3 m_vecCenter;
	float m_startRadius;
	float m_endRadius;
};

class Beam_t;

class IViewRenderBeams
{
public:
	VFUNC(void, drawBeam, 4, (Beam_t* beam), (this, beam));
	VFUNC(Beam_t*, createBeamPoints, 12, (BeamInfo_t& beamInfo), (this, std::ref(beamInfo)));
	VFUNC(Beam_t*, createRingPoint, 16, (BeamInfo_t& beamInfo), (this, std::ref(beamInfo)));
};
```

`hack/SDK/IWeapon.hpp`:

```hpp
#pragma once

#include "helpers/pad.hpp"
#include "helpers/vfunc.hpp"

class WeaponInfo
{
public:
	PAD(20);
	int m_maxClip1;
	int m_maxClip2;
	PAD(8);
	int m_primaryMaxAmmo;
	int m_secondaryMaxAmmo;
	PAD(92);
	const char* m_WeaponName;
	PAD(60);
	int m_type;
	PAD(4);
	int m_price;
	int m_priceKKillAward;
	PAD(20);
	bool isFullAuto;
	PAD(3);
	int m_damage;
	float m_hsMultiplier;
	float m_armorRatio;
	int m_bullets;
	float m_penetration;
	PAD(8);
	float m_range;
	float m_rangeModyfier;
	float m_throwVelocity;
	PAD(12);
	bool isSilenced;
	PAD(123);
	//float m_recoil; not sure
};

class IWeapon
{
public:
	VFUNC(WeaponInfo*, getWpnData, 2, (unsigned int ItemDefinitionIndex), (this, ItemDefinitionIndex));
};
```

`hack/SDK/Input.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"
#include "CUserCmd.hpp"

#include "helpers/pad.hpp"
#include "helpers/vfunc.hpp"

class Input
{
public:
    PAD(169);
    bool m_cameraInThirdPerson;
    PAD(2);
    Vec3 m_cameraOffset;
    PAD(56);
    CUserCmd* m_commands;
    CVerifiedUserCmd* m_verifiedCommands;

    VFUNC(CUserCmd*, getUserCmd, 8, (int slot, int sequence), (this, slot, sequence));

    CVerifiedUserCmd* getVerifiedUserCmd(int sequence)
    {
        return &m_verifiedCommands[sequence % 150];
    }
};
```

`hack/SDK/InputSystem.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"

class InputSystem
{
public:
	VFUNC(void, enableInput, 11, (bool enable), (this, enable));
};
```

`hack/SDK/KeyValues.cpp`:

```cpp
#include "KeyValues.hpp"

#include "KeyValuesSys.hpp"
#include "interfaces/interfaces.hpp"

#include <gamememory/memory.hpp>

KeyValues::KeyValues(const char* key, const char* maybeSomePreValue, int caseSensitive)
{
	memory::keyValuesConstruct()(this, key, maybeSomePreValue, caseSensitive);
}

KeyValues::~KeyValues()
{
	// direct reference: [actual address in first opcode] E8 ? ? ? ? 8B 4B 14 5F 
	// probably casted sign or just int, from quick lookup seems 1 is default
	memory::keyValuesDestruct()(this, 1);
}

KeyValues* KeyValues::fromString(const char* name, const char* value)
{
	const static auto fromstring = memory::keyValuesFromString();
	KeyValues* res{};

	__asm
	{
		push 0
		mov edx, value
		mov ecx, name
		call fromstring
		add esp, 4
		mov res, eax
	}

	return res;
}

void KeyValues::fromBuffer(const char* name, const char* buffer, void* filesystem, const char* pathId, void* symbolProc, int unk)
{
	memory::loadFromBuffer()(this, name, buffer, filesystem, pathId, symbolProc, unk);
}

void* KeyValues::operator new(size_t size)
{
	return memory::interfaces::keyValuesSys->allocKeysMemory(size);
}
```

`hack/SDK/KeyValues.hpp`:

```hpp
#pragma once

#include "helpers/pad.hpp"

using getSymbolProc_t = bool(__cdecl*)(const char*);

class KeyValues
{
public:
	KeyValues(const char* key, const char* maybeSomePreValue = nullptr, int caseSensitive = 0);
	~KeyValues();
	static KeyValues* fromString(const char* name, const char* value = nullptr);
	void fromBuffer(const char* name, const char* buffer, void* filesystem = nullptr, const char* pathId = nullptr, void* symbolProc = nullptr, int unk = 0);
	void* operator new(size_t size);

	PAD(0x2C); // keep this updated to prevent calling size allocation yourself manually
};
static_assert(sizeof(KeyValues) == 0x2C);
```

`hack/SDK/KeyValuesSys.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"

class KeyValuesSys
{
public:
	VFUNC(void*, allocKeysMemory, 2, (size_t size), (this, size));
	VFUNC(void, freeKeysMemory, 3, (void* memory), (this, memory));
	VFUNC(int, getSymbolForString, 4, (const char* name, bool create = true), (this, name, create));
};
```

`hack/SDK/MapStruct.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"
#include "helpers/pad.hpp"

struct MapStruct
{
	PAD(276);
	Vec2 m_origin;
	PAD(12);
	float m_scale;
	PAD(200);
	int m_numberRadarPlayers;
};
```

`hack/SDK/Recv.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"

enum SendPropType
{
	DPT_INT = 0,
	DPT_FLOAT,
	DPT_VECTOR,
	DPT_VECTOR2D,
	DPT_STRING,
	DPT_ARRAY,
	DPT_DATATABLE,
	DPT_INT64,
	DPT_SENDPROPTYPEMAX
};

class DVariant
{
public:
	union
	{
		float m_float;
		long m_int;
		char* m_string;
		void* m_data;
		Vec3 m_vector;
		__int64 m_int64;
	};
	SendPropType  m_type;
};

class RecvTable;
class RecvProp;

class CRecvProxyData
{
public:
	const RecvProp* m_recvProp;
	DVariant m_value;
	int	m_element;
	int	m_objectID;
};

using RecvVarProxyFn = void(*)(CRecvProxyData&, void*, void*); // cdecl

class RecvProp
{
public:
	char* m_varName;
	SendPropType m_recvType;
	int m_flags;
	int m_stringBufferSize;
	int m_insideArray;
	const void* m_extraData;
	RecvProp* m_arrayProp;
	void* m_arrayLengthProxy;
	RecvVarProxyFn m_proxyFn;
	void* m_dataTableProxyFn;
	RecvTable* m_dataTable;
	int m_offset;
	int m_elementStride;
	int m_elements;
	const char* m_parentArrayPropName;
};

class RecvTable
{
public:
	RecvProp* m_props;
	int m_propsNum;
	void* m_decoder;
	char* m_netTableName;
	bool m_initialized;
	bool m_inMainList;
};

```

`hack/SDK/animations.hpp`:

```hpp
#pragma once

class AnimationLayer
{
public:
	float m_animationTime;
	float m_fadeOut;
	void* m_studio;
	int m_dispatchedSrc;
	int m_dispatchedDst;
	int m_order;
	size_t m_sequence;
	float m_prevCycle;
	float m_weight;
	float m_weightDeltaRate;
	float m_playbackRate;
	float m_cycle;
	void* m_entity;
	int m_invalidatePhysicsBits;
};
```

`hack/SDK/checksum_crc.cpp`:

```cpp
#include "checksum_crc.hpp"

#define CRC32_INIT_VALUE 0xFFFFFFFFUL
#define CRC32_XOR_VALUE  0xFFFFFFFFUL

#define NUM_BYTES 256
static const CRC32_t pulCRCTable[NUM_BYTES] =
{
    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba,
    0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
    0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
    0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
    0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,
    0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
    0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940,
    0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116,
    0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
    0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
    0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a,
    0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818,
    0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
    0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c,
    0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
    0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
    0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
    0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086,
    0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4,
    0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
    0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
    0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
    0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe,
    0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
    0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252,
    0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60,
    0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
    0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
    0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04,
    0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a,
    0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
    0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e,
    0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
    0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
    0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
    0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0,
    0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6,
    0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
    0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

void CRC32_Init(CRC32_t* pulCRC)
{
    *pulCRC = CRC32_INIT_VALUE;
}

void CRC32_Final(CRC32_t* pulCRC)
{
    *pulCRC ^= CRC32_XOR_VALUE;
}

CRC32_t	CRC32_GetTableEntry(unsigned int slot)
{
    return pulCRCTable[(unsigned char)slot];
}

void CRC32_ProcessBuffer(CRC32_t* pulCRC, const void* pBuffer, int nBuffer)
{
    CRC32_t ulCrc = *pulCRC;
    unsigned char* pb = (unsigned char*)pBuffer;
    unsigned int nFront;
    int nMain;

JustAfew:

    switch (nBuffer)
    {
    case 7:
        ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

    case 6:
        ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

    case 5:
        ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

    case 4:
        ulCrc ^= LittleLong(*(CRC32_t*)pb);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        *pulCRC = ulCrc;
        return;

    case 3:
        ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

    case 2:
        ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

    case 1:
        ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

    case 0:
        *pulCRC = ulCrc;
        return;
    }

    // We may need to do some alignment work up front, and at the end, so that
    // the main loop is aligned and only has to worry about 8 byte at a time.
    //
    // The low-order two bits of pb and nBuffer in total control the
    // upfront work.
    //
    nFront = ((unsigned int)pb) & 3;
    nBuffer -= nFront;
    switch (nFront)
    {
    case 3:
        ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);
    case 2:
        ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);
    case 1:
        ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);
    }

    nMain = nBuffer >> 3;
    while (nMain--)
    {
        ulCrc ^= LittleLong(*(CRC32_t*)pb);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        ulCrc ^= LittleLong(*(CRC32_t*)(pb + 4));
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        pb += 8;
    }

    nBuffer &= 7;
    goto JustAfew;
}
```

`hack/SDK/checksum_crc.hpp`:

```hpp
#pragma once

#define LittleLong( val )			( val )
using CRC32_t = unsigned int;

void CRC32_Init(CRC32_t* pulCRC);
void CRC32_ProcessBuffer(CRC32_t* pulCRC, const void* p, int len);
void CRC32_Final(CRC32_t* pulCRC);
CRC32_t	CRC32_GetTableEntry(unsigned int slot);

inline CRC32_t CRC32_ProcessSingleBuffer(const void* p, int len)
{
	CRC32_t crc;

	CRC32_Init(&crc);
	CRC32_ProcessBuffer(&crc, p, len);
	CRC32_Final(&crc);

	return crc;
}
```

`hack/SDK/clientHitVerify.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"

struct ClientHitVerify_t
{
	Vec3 m_pos;
	float m_time;
	float m_expire;
};
```

`hack/SDK/datamap.hpp`:

```hpp
#pragma once

#include "CUtlVector.hpp"
#include "helpers/pad.hpp"

#define ALIGN_VALUE( val, alignment ) ( ( val + alignment - 1 ) & ~( alignment - 1 ) )

enum fieldtype_t
{
	FIELD_VOID = 0,			// No type or value
	FIELD_FLOAT,			// Any floating point value
	FIELD_STRING,			// A string ID (return from ALLOC_STRING)
	FIELD_VECTOR,			// Any vector, QAngle, or AngularImpulse
	FIELD_QUATERNION,		// A quaternion
	FIELD_INTEGER,			// Any integer or enum
	FIELD_BOOLEAN,			// boolean, implemented as an int, I may use this as a hint for compression
	FIELD_SHORT,			// 2 byte integer
	FIELD_CHARACTER,		// a byte
	FIELD_COLOR32,			// 8-bit per channel r,g,b,a (32bit color)
	FIELD_EMBEDDED,			// an embedded object with a datadesc, recursively traverse and embedded class/structure based on an additional typedescription
	FIELD_CUSTOM,			// special type that contains function pointers to it's read/write/parse functions
	FIELD_CLASSPTR,			// CBaseEntity *
	FIELD_EHANDLE,			// Entity handle
	FIELD_EDICT,			// edict_t *
	FIELD_POSITION_VECTOR,	// A world coordinate (these are fixed up across level transitions automagically)
	FIELD_TIME,				// a floating point time (these are fixed up automatically too!)
	FIELD_TICK,				// an integer tick count( fixed up similarly to time)
	FIELD_MODELNAME,		// Engine string that is a model name (needs precache)
	FIELD_SOUNDNAME,		// Engine string that is a sound name (needs precache)
	FIELD_INPUT,			// a list of inputed data fields (all derived from CMultiInputVar)
	FIELD_FUNCTION,			// A class function pointer (Think, Use, etc)
	FIELD_VMATRIX,			// a vmatrix (output coords are NOT worldspace)
	FIELD_VMATRIX_WORLDSPACE,// A VMatrix that maps some local space to world space (translation is fixed up on level transitions)
	FIELD_MATRIX3X4_WORLDSPACE,	// matrix3x4_t that maps some local space to world space (translation is fixed up on level transitions)
	FIELD_INTERVAL,			// a start and range floating point interval ( e.g., 3.2->3.6 == 3.2 and 0.4 )
	FIELD_MODELINDEX,		// a model index
	FIELD_MATERIALINDEX,	// a material index (using the material precache string table)
	FIELD_VECTOR2D,			// 2 floats
	FIELD_TYPECOUNT,		// MUST BE LAST
};

#define FTYPEDESC_GLOBAL			0x0001		// This field is masked for global entity save/restore
#define FTYPEDESC_SAVE				0x0002		// This field is saved to disk
#define FTYPEDESC_KEY				0x0004		// This field can be requested and written to by string name at load time
#define FTYPEDESC_INPUT				0x0008		// This field can be written to by string name at run time, and a function called
#define FTYPEDESC_OUTPUT			0x0010		// This field propogates it's value to all targets whenever it changes
#define FTYPEDESC_FUNCTIONTABLE		0x0020		// This is a table entry for a member function pointer
#define FTYPEDESC_PTR				0x0040		// This field is a pointer, not an embedded object
#define FTYPEDESC_OVERRIDE			0x0080		// The field is an override for one in a base class (only used by prediction system for now)

// Flags used by other systems (e.g., prediction system)
#define FTYPEDESC_INSENDTABLE		0x0100		// This field is present in a network SendTable
#define FTYPEDESC_PRIVATE			0x0200		// The field is local to the client or server only (not referenced by prediction code and not replicated by networking)
#define FTYPEDESC_NOERRORCHECK		0x0400		// The field is part of the prediction typedescription, but doesn't get compared when checking for errors

#define FTYPEDESC_MODELINDEX		0x0800		// The field is a model index (used for debugging output)

#define FTYPEDESC_INDEX				0x1000		// The field is an index into file data, used for byteswapping. 

// These flags apply to C_BasePlayer derived objects only
#define FTYPEDESC_VIEW_OTHER_PLAYER		0x2000		// By default you can only view fields on the local player (yourself), 
													//   but if this is set, then we allow you to see fields on other players
#define FTYPEDESC_VIEW_OWN_TEAM			0x4000		// Only show this data if the player is on the same team as the local player
#define FTYPEDESC_VIEW_NEVER			0x8000		// Never show this field to anyone, even the local player (unusual)

#define TD_MSECTOLERANCE		0.001f		// This is a FIELD_FLOAT and should only be checked to be within 0.001 of the networked info

enum
{
	TD_OFFSET_NORMAL = 0,
	TD_OFFSET_PACKED = 1,
	TD_OFFSET_COUNT,
};

struct InputData;
using inputFn = void(*)(InputData&);
struct DataMap_t;

struct Typedescription_t
{
	fieldtype_t	m_type;
	const char* m_name;
	int m_offset[TD_OFFSET_COUNT];
	uint16_t m_size;
	int16_t	m_flags;
	PAD(12);
	DataMap_t* m_dataMap;
	int m_sizeInBytes;
	Typedescription_t* overrideField;
	int overrideCount;
	float fieldTolerance;
	PAD(8);
};

struct datarun_t
{
	datarun_t() : m_nStartFlatField(0), m_nEndFlatField(0), m_nLength(0)
	{
		for (int i = 0; i < TD_OFFSET_COUNT; ++i)
		{
			m_nStartOffset[i] = 0;
#ifdef _GAMECONSOLE
			// These are the offsets of the next run, for priming the L1 cache
			m_nPrefetchOffset[i] = 0;
#endif
		}
	}

	// Indices of start/end fields in the flattened typedescription_t list
	int m_nStartFlatField;
	int m_nEndFlatField;

	// Offsets for run in the packed/unpacked data (I think the run starts need to be properly aligned)
	int m_nStartOffset[TD_OFFSET_COUNT];
#ifdef _GAMECONSOLE
	// These are the offsets of the next run, for priming the L1 cache
	int m_nPrefetchOffset[TD_OFFSET_COUNT];
#endif
	int m_nLength;
};

struct datacopyruns_t
{
public:
	CUtlVector<datarun_t> m_vecRuns;
};

struct flattenedoffsets_t
{
	CUtlVector<Typedescription_t> m_Flattened;
	int	m_nPackedSize; // Contiguous memory to pack all of these together for TD_OFFSET_PACKED
	int	m_nPackedStartOffset;
};

struct datamapinfo_t
{
	// Flattened list, with FIELD_EMBEDDED, FTYPEDESC_PRIVATE, 
	//  and FTYPEDESC_OVERRIDE (overridden) fields removed
	flattenedoffsets_t m_Flat;
	datacopyruns_t m_CopyRuns;
};

enum
{
	PC_NON_NETWORKED_ONLY = 0,
	PC_NETWORKED_ONLY,

	PC_COPYTYPE_COUNT,
	PC_EVERYTHING = PC_COPYTYPE_COUNT,
};

struct optimized_datamap_t
{
	// Optimized info for PC_NON_NETWORKED and PC_NETWORKED data
	datamapinfo_t m_Info[PC_COPYTYPE_COUNT];
};

struct DataMap_t
{
	Typedescription_t* m_dataDescription;
	int m_dataFields;
	const char* m_dataClassName;
	DataMap_t* m_baseMap;
	bool m_chainsValidated;
	bool m_packedOffsetsComputed;
	int m_packedSize;
	optimized_datamap_t* m_optimizedDataMap;
};

```

`hack/SDK/helpers/netvars.cpp`:

```cpp
#include "netvars.hpp"

#include <SDK/Recv.hpp>
#include <SDK/IBaseClientDll.hpp>
#include <SDK/ClientClass.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <config/config.hpp>
#include <utilities/utilities.hpp>
#include <utilities/tools/wrappers.hpp>

#include <array>
#include <ranges>

void NetvarManager::init()
{
	m_Tables.clear();

	auto clientClass = memory::interfaces::client->getAllClasses();
	if (!clientClass)
		return;

	while (clientClass)
	{
		auto recvTable = clientClass->m_recvTable;
		m_Tables.emplace(recvTable->m_netTableName, recvTable);

		clientClass = clientClass->m_next;
	}

	dump();
}

uintptr_t NetvarManager::getNetvar(const std::string_view tableName, const std::string_view propName) const
{
	auto offset = getProp(tableName, propName);
	if (!offset)
		return 0;

	return offset;
}

uintptr_t NetvarManager::getProp(const std::string_view tableName, const std::string_view propName, RecvProp** prop) const
{
	auto recvTable = getTable(tableName);
	if (!recvTable)
		return 0;

	auto offset = getProp(recvTable, propName, prop);
	if (!offset)
		return 0;

	return offset;
}

uintptr_t NetvarManager::getProp(RecvTable* recvTable, const std::string_view propName, RecvProp** prop) const
{
	uintptr_t extraOffset = 0;

	for (auto i : std::views::iota(0, recvTable->m_propsNum))
	{
		auto recvProp = &recvTable->m_props[i];
		auto recvChild = recvProp->m_dataTable;

		if (recvChild && (recvChild->m_propsNum > 0))
		{
			auto temp = getProp(recvChild, propName, prop);

			if (temp)
				extraOffset += (recvProp->m_offset + temp);
		}

		if (std::string_view name = recvProp->m_varName; name != propName)
			continue;

		if (prop)
			*prop = recvProp;

		return (recvProp->m_offset + extraOffset);
	}

	return extraOffset;
}

RecvTable* NetvarManager::getTable(const std::string_view tableName) const
{
	if (m_Tables.empty())
		return nullptr;

	for(const auto& [name, recv] : m_Tables)
	{
		if (name == tableName)
			return recv;
	}

	return nullptr;
}

std::string NetvarManager::getType(RecvProp* recvTable) const
{
	static std::unordered_map<SendPropType, std::string> props =
	{
		{ SendPropType::DPT_INT, XOR("int")},
		{ SendPropType::DPT_FLOAT, XOR("float")},
		{ SendPropType::DPT_VECTOR, XOR("Vec3")},
		{ SendPropType::DPT_VECTOR2D, XOR("Vec2")},
		{ SendPropType::DPT_STRING, XOR("char")},
		{ SendPropType::DPT_ARRAY, XOR("array")},
		{ SendPropType::DPT_DATATABLE, XOR("datatable (void*)")},
		{ SendPropType::DPT_INT64, XOR("__int64")},
	};

	// buffers
	if (auto type = recvTable->m_recvType; type == DPT_STRING)
		return FORMAT(XOR("{}[{}]"), props.at(recvTable->m_recvType), recvTable->m_stringBufferSize);
	else if(type == DPT_ARRAY)
		return FORMAT(XOR("{}[{}]"), props.at(recvTable->m_recvType), recvTable->m_elements);

	return props.at(recvTable->m_recvType);
}

void NetvarManager::dump(RecvTable* recvTable)
{
	for (auto i : std::views::iota(0, recvTable->m_propsNum))
	{
		auto recvProp = &recvTable->m_props[i];

		if (!recvProp)
			continue;

		std::string_view recvName = recvProp->m_varName;

		if (recvName.find(XOR("baseclass")) != std::string::npos)
			continue;

		if (::isdigit(recvProp->m_varName[0]))
			continue;

		file << FORMAT(XOR("[{}::{}] -> 0x{:X} -> ({})"),
			recvTable->m_netTableName,
			recvName, recvProp->m_offset,
			getType(recvProp))
			<< '\n';

		if (recvProp->m_dataTable)
			dump(recvProp->m_dataTable);
	}
}

#include <SDK/datamap.hpp>

uintptr_t NetvarManager::getDataMap(DataMap_t* map, const std::string_view name) const
{
	while (map)
	{
		for (auto i : std::views::iota(0, map->m_dataFields))
		{
			const auto descriptor = map->m_dataDescription[i];

			if (map->m_dataDescription[i].m_name == nullptr)
				continue;

			// string_view as map->m_dataDescription[i].m_name sometimes crashes on this, UB
			if(std::strcmp(name.data(), map->m_dataDescription[i].m_name) == 0)
				return descriptor.m_offset[TD_OFFSET_NORMAL];

			if (descriptor.m_type == FIELD_EMBEDDED)
			{
				if (descriptor.m_dataMap)
				{
					if (const auto offset = getDataMap(descriptor.m_dataMap, name); offset)
						return offset;
				}
			}
		}
		map = map->m_baseMap;
	}

	return 0U;
}

#include <utilities/simpleTimer.hpp>

void NetvarManager::dump()
{
	file = std::ofstream{ config.getHackPath() / XOR("netvarsDump.txt") };
	file << FORMAT(XOR("Netvars from: {}"), utilities::getTime()) << "\n\n";

	TimeCount timer{};
	auto client = memory::interfaces::client->getAllClasses();
	do {
		const auto recvTable = client->m_recvTable;
		dump(recvTable);
		client = client->m_next;
	} while (client);
	timer.end();

	file << '\n' << FORMAT(XOR("Finished in {:.2f} secs"), timer.getTime());

	file.close();
}
```

`hack/SDK/helpers/netvars.hpp`:

```hpp
#pragma once

#include <utilities/tools/tools.hpp>

#include <fstream>
#include <unordered_map>
#include <type_traits>

// generate netvar address
// type - template type for return type
// name - name your function
// table - table name to search the netvar prop
// prop - prop name
#define NETVAR(type, name, table, prop) \
[[nodiscard]] std::add_lvalue_reference_t<type> name() { \
	static uintptr_t offset = netvarMan.getNetvar(XOR(table), XOR(prop)); \
	return *reinterpret_cast<std::add_pointer_t<type>>((uintptr_t)this + offset ); \
	}

// generate netvar, but address as the pointer
// type - template type for return type
// name - name your function
// table - table name to search the netvar prop
// prop - prop name
#define PTRNETVAR(type, name, table, prop) \
[[nodiscard]] std::add_pointer_t<type> name() { \
	static uintptr_t offset = netvarMan.getNetvar(XOR(table), XOR(prop)); \
	return reinterpret_cast<std::add_pointer_t<type>>((uintptr_t)this + offset); \
	}

// define literal offset
// type - template type for return type
// name - name your function
// offset - offset to add
#define OFFSET(type, name, offset) \
[[nodiscard]] std::add_lvalue_reference_t<type> name() { \
	return *reinterpret_cast<std::add_pointer_t<type>>((uintptr_t)this + offset); \
	}

// define literal offset as pointer
// type - template type for return type
// name - name your function
// offset - offset to add
#define PTROFFSET(type, name, offset) \
[[nodiscard]] std::add_pointer_t<type> name() { \
	return reinterpret_cast<std::add_pointer_t<type>>((uintptr_t)this + offset); \
	}

// use like normal netvar, with bytes to add as last argument
// type - template type for return type
// name - name your function
// table - table name to search the netvar prop
// prop - prop name
// addr - extra offset to add
#define NETVAR_ADDR(type, name, table, prop, addr) \
[[nodiscard]] std::add_lvalue_reference_t<type> name() { \
	static uintptr_t offset = netvarMan.getNetvar(XOR(table), XOR(prop)); \
	return *reinterpret_cast<std::add_pointer_t<type>>((uintptr_t)this + offset + addr); \
	}


#define PTRNETVAR_ADDR(type, name, table, prop, addr) \
[[nodiscard]] std::add_pointer_t<type> name() { \
	static uintptr_t offset = netvarMan.getNetvar(XOR(table), XOR(prop)); \
	return reinterpret_cast<std::add_pointer_t<type>>((uintptr_t)this + offset + addr); \
	}

#define DATAMAP_FIELD(type, name, map, prop) \
[[nodiscard]] std::add_lvalue_reference_t<type> name() { \
	static uintptr_t offset = netvarMan.getDataMap(map, XOR(prop)); \
	return *reinterpret_cast<std::add_pointer_t<type>>((uintptr_t)this + offset ); \
	}

#define PTRDATAMAP_FIELD(type, name, map, prop) \
[[nodiscard]] std::add_pointer_t<type> name() { \
	static uintptr_t offset = netvarMan.getDataMap(map, XOR(prop)); \
	return reinterpret_cast<std::add_pointer_t<type>>((uintptr_t)this + offset ); \
	}


class RecvTable;
class RecvProp;
struct DataMap_t;

class NetvarManager
{
public:
	void init();
	[[nodiscard]] uintptr_t getNetvar(const std::string_view tableName, const std::string_view propName) const;
	[[nodiscard]] uintptr_t getDataMap(DataMap_t* map, const std::string_view name) const;
	void dump();
private:
	std::unordered_map<std::string_view, RecvTable*> m_Tables;
	[[nodiscard]] uintptr_t getProp(const std::string_view tableName, const std::string_view propName, RecvProp** prop = nullptr) const;
	[[nodiscard]] uintptr_t getProp(RecvTable* recvTable, const std::string_view propName, RecvProp** prop = nullptr) const;
	[[nodiscard]] RecvTable* getTable(const std::string_view tableName) const;
	[[nodiscard]] std::string getType(RecvProp* recvTable) const;
	void dump(RecvTable* recvTable);
	std::ofstream file;
} inline netvarMan;
```

`hack/SDK/helpers/pad.hpp`:

```hpp
#pragma once

#include <cstddef>

#define CONCAT_IMPL(x, y) x##y
#define MACRO_CONCAT(x, y) CONCAT_IMPL(x, y)
#define PAD(SIZE) \
private: \
	std::byte MACRO_CONCAT(_pad, __COUNTER__)[SIZE]; \
public:
```

`hack/SDK/helpers/vfunc.hpp`:

```hpp
#pragma once

namespace vfunc
{
	inline constexpr void* getVFunc(void* thisptr, size_t index)
	{
		return (*static_cast<void***>(thisptr))[index];
	}

	// use for any function that does not represent packed args and can be thiscall
	template <typename T, size_t index, typename ... Args_t>
	inline constexpr T callVFunc(void* thisptr, Args_t... args)
	{
		using virtualFunction = T(__thiscall***)(void*, Args_t...);
		return (*reinterpret_cast<virtualFunction>(thisptr))[index](thisptr, args...);
	}

	// ONLY for packed arguments in base case !!!
	template<typename T, size_t index, typename... Args_t>
	inline constexpr T callVPack(void* thisptr, Args_t... args)
	{
		using packedVirtualFunction = T(__cdecl***)(void*, Args_t...);
		return (*reinterpret_cast<packedVirtualFunction>(thisptr))[index](thisptr, args...);
	}
}
// type - type of function
// name - function's name
// index - vtable index for this method
// args - args to pass eg: (int value)
// variables - variables from args, the starting will always be a pointer to class, eg: (this, value)
#define VFUNC(type, name, index, args, variables) \
type name args { \
	return vfunc::callVFunc<type, index>variables; \
}

```

`hack/SDK/interfaceNode.hpp`:

```hpp
#pragma once

#include <type_traits>

struct InterfacesNode
{
	std::add_pointer_t<void* ()> m_createFn;
	const char* m_name;
	InterfacesNode* m_next;
};
```

`hack/SDK/interfaces/ifc.hpp`:

```hpp
#pragma once

#include <string_view>
#include <gamememory/modules.hpp>

template<typename T>
struct Interface
{
	using value = T;

	T base{ };
	std::string_view module{ CLIENT_DLL };

	[[nodiscard]] constexpr T operator->() const
	{ 
		return base;
	}

	[[nodiscard]] constexpr T operator()() const
	{
		return base;
	}
};
```

`hack/SDK/interfaces/interfaces.cpp`:

```cpp
#include "interfaces.hpp"

#include "ifc.hpp"
#include "../interfaceNode.hpp"
#include <gamememory/modules.hpp>

#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <utilities/console/console.hpp>
#include <gamememory/memory.hpp>

#include <Windows.h>
#include <d3d9.h>
#include <string>
#include <optional>

template <typename T>
static std::optional<Interface<T>> getInterface(const std::string_view moduleName, const std::string_view interfaceName)
{
	using fun = void* (*)(const char*, int*);
	fun capture;
	EXPORT(capture, "CreateInterface"_hasher, moduleName);

	const auto addr = Memory::Address<InterfacesNode*>{ reinterpret_cast<uintptr_t>(capture) };
	const auto esi = addr.rel(0x5, 0x6).deRef(Memory::Dereference::TWICE);

	for (auto el = esi(); el; el = el->m_next)
	{
		if (std::string_view{ el->m_name }.starts_with(interfaceName))
		{
			return Interface<T>{ .base = static_cast<T>(el->m_createFn()), .module = moduleName };
		}
	}

	return std::nullopt;
}

// capture and log
// var - var you want to init
// type - type for template
// _module - module name from the game, eg: engine.dll
// _interface - interface' name
#define CAP(var, _module, _interface) \
	if(auto val = getInterface<decltype(var)::value>(_module, XOR(_interface)); val.has_value()) \
		var = val.value(); \
	else \
		throw std::runtime_error(FORMAT(XOR("Interface {} was nullptr"), _interface)); \
	LOG_INFO(XOR("found {} at addr: 0x{:X}"), _interface, reinterpret_cast<uintptr_t>(var.base));

void memory::interfaces::init()
{
	CAP(engine, ENGINE_DLL, "VEngineClient0");
	CAP(panel, VGUI_DLL, "VGUI_Panel0");
	CAP(surface, VGUIMAT_DLL, "VGUI_Surface0");
	CAP(client, CLIENT_DLL, "VClient0");
	CAP(entList, CLIENT_DLL, "VClientEntityList0");
	CAP(cvar, VSTD_DLL, "VEngineCvar0");
	CAP(trace, ENGINE_DLL, "EngineTraceClient0");
	CAP(renderView, ENGINE_DLL, "VEngineRenderView0");
	CAP(matSys, MATERIAL_DLL, "VMaterialSystem0");
	CAP(modelInfo, ENGINE_DLL, "VModelInfoClient0");
	CAP(prediction, CLIENT_DLL, "VClientPrediction0");
	CAP(gameMovement, CLIENT_DLL, "GameMovement0");
	CAP(debugOverlay, ENGINE_DLL, "VDebugOverlay0");
	CAP(localize, LOCALIZE_DLL, "Localize_0");
	CAP(modelRender, ENGINE_DLL, "VEngineModel0");
	CAP(studioRender, STUDIORENDER_DLL, "VStudioRender0");
	CAP(eventManager, ENGINE_DLL, "GAMEEVENTSMANAGER002");
	CAP(efx, ENGINE_DLL, "VEngineEffects0");
	CAP(iSystem, INPUTSYSTEM_DLL, "InputSystemVersion0");
	CAP(effects, CLIENT_DLL, "IEffects0");
	CAP(fileSystem, FILESYS_DLL, "VFileSystem0");
	CAP(sound, ENGINE_DLL, "IEngineSoundClient0");
	CAP(mdlCache, DATACACHE_DLL, "MDLCache0");

	LOG_INFO(XOR("interfaces success"));
}
```

`hack/SDK/interfaces/interfaces.hpp`:

```hpp
#pragma once

#include "ifc.hpp"

#pragma region declarations
class IPanel;
class ClientMode;
class ISurface;
class IVEngineClient;
class IBaseClientDLL;
class IWeapon;
class IClientEntityList;
class IClientMode;
class CClientState;
class Input;
class CGlobalVarsBase;
class IEngineTrace;
class IMaterialSystem;
class IVModelInfo;
class IVDebugOverlay;
class IGameEventManager;
class IViewRender;
class IVRenderView;
class CGlowManager;
class CGameMovement;
class IPrediction;
class IMoveHelper;
class ILocalize;
class ICvar;
class IConVar;
class IViewRenderBeams;
class IVModelRender;
class IVStudioRender;
class PlayerResource;
class IVEfx;
class InputSystem;
struct IDirect3DDevice9;
class IEffects;
class KeyValuesSys;
class IMemAlloc;
class CTeslaInfo;
class CEffectData;
class IClientState;
class Entity_t;
class IFileSystem;
class CGameRules;
class CEngineSoundClient;
class IMDLCache;
#pragma endregion

namespace memory::interfaces
{
	inline Interface<IVEngineClient*> engine;
	inline Interface<IPanel*> panel;
	inline Interface<ISurface*> surface;
	inline Interface<IBaseClientDLL*> client;
	inline Interface<IClientEntityList*> entList;
	inline Interface<ICvar*> cvar;
	inline Interface<IEngineTrace*> trace;
	inline Interface<IVRenderView*> renderView;
	inline Interface<IMaterialSystem*> matSys;
	inline Interface<IVModelInfo*> modelInfo;
	inline Interface<IPrediction*> prediction;
	inline Interface<CGameMovement*> gameMovement;
	inline Interface<IVDebugOverlay*> debugOverlay;
	inline Interface<ILocalize*> localize;
	inline Interface<IVModelRender*> modelRender;
	inline Interface<IVStudioRender*> studioRender;
	inline Interface<IGameEventManager*> eventManager;
	inline Interface<IVEfx*> efx;
	inline Interface<InputSystem*> iSystem;
	inline Interface<IEffects*> effects;
	inline Interface<IFileSystem*> fileSystem;
	inline Interface<CEngineSoundClient*> sound;
	inline Interface<IMDLCache*> mdlCache;

	void init();
}
```

`hack/SDK/material.hpp`:

```hpp
#pragma once

#include <render/Color.hpp>
#include "math/Vector.hpp"

#include "helpers/pad.hpp"
#include "helpers/vfunc.hpp"

enum OverrideType_t
{
    OVERRIDE_NORMAL = 0,
    OVERRIDE_BUILD_SHADOWS,
    OVERRIDE_DEPTH_WRITE,
    OVERRIDE_SELECTIVE,
    OVERRIDE_SSAO_DEPTH_WRITE,
};

enum MaterialVarFlags_t
{
    MATERIAL_VAR_DEBUG = (1 << 0),
    MATERIAL_VAR_NO_DEBUG_OVERRIDE = (1 << 1),
    MATERIAL_VAR_NO_DRAW = (1 << 2),
    MATERIAL_VAR_USE_IN_FILLRATE_MODE = (1 << 3),
    MATERIAL_VAR_VERTEXCOLOR = (1 << 4),
    MATERIAL_VAR_VERTEXALPHA = (1 << 5),
    MATERIAL_VAR_SELFILLUM = (1 << 6),
    MATERIAL_VAR_ADDITIVE = (1 << 7),
    MATERIAL_VAR_ALPHATEST = (1 << 8),
    //MATERIAL_VAR_UNUSED = (1 << 9),
    MATERIAL_VAR_ZNEARER = (1 << 10),
    MATERIAL_VAR_MODEL = (1 << 11),
    MATERIAL_VAR_FLAT = (1 << 12),
    MATERIAL_VAR_NOCULL = (1 << 13),
    MATERIAL_VAR_NOFOG = (1 << 14),
    MATERIAL_VAR_IGNOREZ = (1 << 15),
    MATERIAL_VAR_DECAL = (1 << 16),
    MATERIAL_VAR_ENVMAPSPHERE = (1 << 17), // OBSOLETE
    MATERIAL_VAR_UNUSED = (1 << 18), // UNUSED
    MATERIAL_VAR_ENVMAPCAMERASPACE = (1 << 19), // OBSOLETE
    MATERIAL_VAR_BASEALPHAENVMAPMASK = (1 << 20),
    MATERIAL_VAR_TRANSLUCENT = (1 << 21),
    MATERIAL_VAR_NORMALMAPALPHAENVMAPMASK = (1 << 22),
    MATERIAL_VAR_NEEDS_SOFTWARE_SKINNING = (1 << 23), // OBSOLETE
    MATERIAL_VAR_OPAQUETEXTURE = (1 << 24),
    MATERIAL_VAR_ENVMAPMODE = (1 << 25), // OBSOLETE
    MATERIAL_VAR_SUPPRESS_DECALS = (1 << 26),
    MATERIAL_VAR_HALFLAMBERT = (1 << 27),
    MATERIAL_VAR_WIREFRAME = (1 << 28),
    MATERIAL_VAR_ALLOWALPHATOCOVERAGE = (1 << 29),
    MATERIAL_VAR_ALPHA_MODIFIED_BY_PROXY = (1 << 30),
    MATERIAL_VAR_VERTEXFOG = (1 << 31),
};

class IMaterialVar;

class IMaterial
{
public:
    VFUNC(const char*, getName, 0, (), (this));
    VFUNC(const char*, getTextureGroupName, 1, (), (this));
    VFUNC(IMaterialVar*, findVar, 11, (const char* name, bool* found = nullptr, bool complain = true), (this, name, found, complain));
    VFUNC(void, alphaModulate, 27, (float alpha), (this, alpha));
    VFUNC(void, alphaModulate, 27, (const Color& color), (this, color.a()));
    VFUNC(void, colorModulate, 28, (float r, float g, float b), (this, r, g, b));
    VFUNC(void, colorModulate, 28, (const Color& color), (this, color.r(), color.g(), color.b()));
    VFUNC(void, setMaterialVarFlag, 29, (MaterialVarFlags_t flag, bool on), (this, flag, on));
    VFUNC(IMaterialVar**, getShaderParams, 41, (), (this));
    VFUNC(bool, isError, 42, (), (this));
    VFUNC(void, addRefCount, 10, (), (this));

    // goes for rgba
    void modulateAllColor(const Color& color)
    {
        this->colorModulate(color);
        this->alphaModulate(color);
    }
};


class IMaterialVar
{
public:
    VFUNC(void, setValue, 4, (float val), (this, val));
    VFUNC(void, setValue, 5, (int val), (this, val));
    VFUNC(void, setValue, 6, (const char* val), (this, val));
    VFUNC(void, setValues, 11, (const Vec3& val), (this, val[0], val[1], val[2]));
    VFUNC(void, setValues, 11, (const Color& val), (this, val.r(), val.g(), val.b()));
    VFUNC(void, setValues, 11, (float x, float y, float z), (this, x, y, z));
    VFUNC(void, setVectorComponent, 26, (float val, int component), (this, val, component));
};
```

`hack/SDK/math/AABB.hpp`:

```hpp
#pragma once

#include "Vector.hpp"

struct AABB_t
{
	Vec3 m_minBounds;
	Vec3 m_maxBounds;
};
```

`hack/SDK/math/Vector.hpp`:

```hpp
#pragma once

#include <array>
#include <type_traits>
#include <ranges>
#include <cmath>
#include <algorithm>

#include <utilities/tools/wrappers.hpp>
#include <imgui.h>

enum class Coord { X, Y, Z };

#define ASSERT_VEC3 static_assert(SIZE == 3, "Use for only v3");

template<typename T, size_t SIZE>
class Vector
{
protected:
	std::array<T, SIZE> m_arr{(T)0};
public:
	constexpr Vector()
	{
		for (auto& el : m_arr)
			el = static_cast<T>(0);
	}

	template<typename... Args_t>
	explicit constexpr Vector(const Args_t&... args)
		: m_arr{ args... }
	{
		static_assert(sizeof...(Args_t) == SIZE, "packed args mismatch");
	}

	explicit constexpr Vector(const std::array<T, SIZE>& arr)
		: m_arr{ arr }
	{}

	explicit constexpr Vector(const T* arr)
	{
		for (auto i : std::views::iota(0U, SIZE))
			m_arr[i] = arr[i];
	}

	constexpr static T MAX_ARG = static_cast<T>(0x7FFF);

	[[nodiscard]] constexpr auto get() const
	{
		return *this;
	}

	[[nodiscard]] constexpr auto begin()
	{
		return m_arr.begin();
	}

	[[nodiscard]] const constexpr auto begin() const
	{
		return m_arr.cbegin();
	}

	[[nodiscard]] constexpr auto end()
	{
		return m_arr.end();
	}

	[[nodiscard]] const constexpr auto end() const
	{
		return m_arr.cend();
	}

	[[nodiscard]] constexpr size_t size() const
	{
		return SIZE;
	}

	[[nodiscard]] constexpr bool isZero() const
	{
		bool res = std::all_of(m_arr.cbegin(), m_arr.cend(),
			[zero = static_cast<T>(0)](T el)
		{
			return el == zero;
		});

		return res;
	}

	[[nodiscard]] constexpr bool isValid() const
	{
		bool res = std::all_of(m_arr.cbegin(), m_arr.cend(),
			[](T el)
			{
				return std::isfinite(el);
			});

		return res;
	}

	constexpr auto& clamp()
	{
		ASSERT_VEC3;

		m_arr[0] = std::clamp(m_arr[0], (T)-89, (T)89);
		m_arr[1] = std::clamp(std::remainder(m_arr[1], (T)360), (T)-180, (T)180);
		m_arr[2] = std::clamp(m_arr[2], (T)-50, (T)50);

		return *this;
	}

	[[nodiscard]] T length() const
	{
		return std::sqrt(this->dotFields());
	}

	[[nodiscard]] constexpr T lengthSqrt() const
	{
		return this->dotFields();
	}

	[[nodiscard]] constexpr auto toVecPrev() const
	{
		return Vector<T, SIZE - 1U>{ getPack<SIZE - 1U>() };
	}

	constexpr const auto operator[](size_t i) const
	{
		return this->m_arr[i];
	}

	constexpr auto& operator[](size_t idx)
	{
		return this->m_arr[idx];
	}

	constexpr const auto operator[](Coord coord) const
	{
		return this->m_arr[E2T(coord)];
	}

	constexpr auto& operator[](Coord coord)
	{
		return this->m_arr[E2T(coord)];
	}

	constexpr auto& operator+=(const Vector& vec)
	{
		for (auto i : std::views::iota(0U, SIZE))
			m_arr[i] += vec[i];

		return *this;
	}

	constexpr auto& operator+=(T val)
	{
		for (auto& el : m_arr)
			el += val;

		return *this;
	}

	constexpr auto& operator-=(const Vector& vec)
	{
		for (auto i : std::views::iota(0U, SIZE))
			m_arr[i] -= vec[i];

		return *this;
	}

	constexpr auto& operator-=(T val)
	{
		for (auto& el : m_arr)
			el -= val;

		return *this;
	}

	constexpr auto& operator*=(const Vector& vec)
	{
		for (auto i : std::views::iota(0U, SIZE))
			m_arr[i] *= vec[i];

		return *this;
	}

	constexpr auto& operator*=(T val)
	{
		for (auto& el : m_arr)
			el *= val;

		return *this;
	}

	constexpr auto& operator/=(const Vector& vec)
	{
		for (auto i : std::views::iota(0U, SIZE))
			m_arr[i] /= vec[i];

		return *this;
	}

	constexpr auto& operator/=(T val)
	{
		for (auto i : std::views::iota(0U, SIZE))
			m_arr[i] /= val;

		return *this;
	}

	constexpr auto operator+(const Vector& vec) const
	{
		Vector res = {};
		for (auto i : std::views::iota(0U, SIZE))
			res[i] = this->m_arr[i] + vec[i];

		return res;
	}

	constexpr auto operator-(const Vector& vec) const
	{
		Vector res = {};
		for (auto i : std::views::iota(0U, SIZE))
			res[i] = this->m_arr[i] - vec[i];

		return res;
	}

	constexpr auto operator*(const Vector& vec) const
	{
		Vector res = {};
		for (auto i : std::views::iota(0U, SIZE))
			res[i] = this->m_arr[i] * vec[i];

		return res;
	}

	constexpr auto operator/(const Vector& vec) const
	{
		Vector res = {};
		for (auto i : std::views::iota(0U, SIZE))
			res[i] = this->m_arr[i] / vec[i];

		return res;
	}

	constexpr auto operator*(T val) const
	{
		Vector res = {};
		for (auto i : std::views::iota(0U, SIZE))
			res[i] = this->m_arr[i] * val;

		return res;
	}

	constexpr auto operator/(T val) const
	{
		Vector res = {};
		for (auto i : std::views::iota(0U, SIZE))
			res[i] = this->m_arr[i] / val;

		return res;
	}

	constexpr auto& normalize()
	{
		ASSERT_VEC3;

		m_arr[0] = std::isfinite(m_arr[0]) ? (T)std::remainder(m_arr[0], (T)360) : (T)0;
		m_arr[1] = std::isfinite(m_arr[1]) ? (T)std::remainder(m_arr[1], (T)360) : (T)0;
		m_arr[2] = (T)0;

		return *this;
	}

	[[nodiscard]] constexpr auto normalized() const
	{
		ASSERT_VEC3;

		Vector vec = this->get();
		vec.normalize();

		return vec;
	}

	[[nodiscard]] constexpr T dot(const Vector& vec) const
	{
		T res = {};
		for (auto i : std::views::iota(0U, SIZE))
			res += m_arr[i] * vec[i];

		return res;
	}

	[[nodiscard]] T distTo(const Vector& vec) const
	{
		return Vector{ *this - vec }.length();
	}

	[[nodiscard]] T distToMeters(const Vector& vec) const
	{
		return distTo(vec) * (T)0.0254f;
	}

	[[nodiscard]] constexpr ImVec2 toImVec() const
	{
		return ImVec2{ m_arr[0], m_arr[1] };
	}
private:
	[[nodiscard]] constexpr T dotFields(size_t times = SIZE) const
	{
		T temp = static_cast<T>(0);
		for (auto i : std::views::iota(0U, times))
			temp += m_arr[i] * m_arr[i];

		return temp;
	}

	template<size_t SIZ = SIZE, typename TT = T>
	[[nodiscard]] constexpr std::array<TT, SIZ> getPack() const
	{
		std::array<TT, SIZ> arr = {};
		for (auto i : std::views::iota(0U, SIZ))
			arr[i] = (TT)m_arr[i];

		return arr;
	}
public:

	static_assert(std::is_same_v<T, float> || std::is_same_v<T, int>, "Possible types are only: float, int");
	static_assert(SIZE >= 2 && SIZE <=4, "Sizes mismatch");
};

using Vec2 = Vector<float, 2U>;
using Vec3 = Vector<float, 3U>;
using Vec4 = Vector<float, 4U>;

#undef ASSERT_VEC3
```

`hack/SDK/math/VectorAligned.hpp`:

```hpp
#pragma once

#include "Vector.hpp"

#include <ranges>

class VectorAligned : public Vec3
{
public:
	constexpr VectorAligned() = default;

	constexpr VectorAligned(const Vec3& v) :
		Vec3{ v }, w{ 0.0f }
	{}

	constexpr VectorAligned& operator=(const Vec3& v)
	{
		for (auto i : std::views::iota(0U, v.size()))
			m_arr[i] = v[i];

		w = 0.0f;
		return *this;
	}

	float w = {};
};
```

`hack/SDK/math/matrix.hpp`:

```hpp
#pragma once

#include "Vector.hpp"

#include <array>

template<size_t ROWS = 3, size_t COLS = 4>
struct Matrix
{
	constexpr Matrix() = default;

	[[nodiscard]] constexpr auto origin() const
	{
		return Vec3{ m_matValues[0][3], m_matValues[1][3], m_matValues[2][3] };
	}

	constexpr const auto operator[](size_t i) const
	{
		return m_matValues[i];
	}

	constexpr auto operator[](size_t i)
	{
		return m_matValues[i];
	}
private:
	std::array<std::array<float, COLS>, ROWS> m_matValues;

	static_assert(ROWS >= 2 && ROWS >= 2, "Did you want to create a vector?");
};

using Matrix3x4 = Matrix<3, 4>;
using Matrix4x4 = Matrix<4, 4>;
```

`hack/SDK/structs/Entity.cpp`:

```cpp
#include "Entity.hpp"

#include "../IVModelInfo.hpp"
#include "../ClientClass.hpp"
#include "../Enums.hpp"
#include "../ICollideable.hpp"
#include "../IClientEntityList.hpp"
#include "../IVEngineClient.hpp"
#include "../CPlayerResource.hpp"
#include "../IEngineTrace.hpp"
#include "../IMDLCache.hpp"
#include "../IWeapon.hpp"
#include "../math/matrix.hpp"
#include "../math/Vector.hpp"
#include "../interfaces/interfaces.hpp"

#include <gamememory/memory.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/math/math.hpp>

#include <array>

////////////////////////////////////////////////////////////////////////

Vec3 Entity_t::getAimPunch()
{
	Vec3 vec = {};
	vfunc::callVFunc<void, PUNCH>(this, std::ref(vec));
	return vec;
}

AnimationLayer* Entity_t::getAnimOverlays()
{
	auto offset = memory::animOverlays();
	return *reinterpret_cast<AnimationLayer**>(uintptr_t(this) + offset);
}

size_t Entity_t::getSequenceActivity(size_t sequence)
{
	auto studio = memory::interfaces::modelInfo->getStudioModel(this->getModel());
	if (!studio)
		return 0;

	return memory::sequenceActivity()(this, studio, sequence);
}

bool Entity_t::isBreakable()
{
	if (!this)
		return false;

	if (!this->getIndex())
		return false;

	if (bool res = memory::isBreakable()(this); !res)
		return false;

	auto cl = this->clientClass();
	if (!cl)
		return false;

	auto id = cl->m_classID;

	constexpr std::array breakableIds = // for surface ids ONLY!
	{
		CBaseDoor,
		CBreakableSurface,
	};

	if (auto it = std::find(std::cbegin(breakableIds), std::cend(breakableIds), id); it != breakableIds.cend()) // if id was found from surface
		return true;

	// there we finally check actual entity
	if (id == CBaseEntity && this->collideable()->getSolid() == 1) // can mess with masks, but it's the same
		return true;

	return false;
}

bool Entity_t::setupBonesShort(Matrix3x4* _out, int maxBones, int mask, float time)
{
	__asm
	{
		mov edi, this
		mov eax, [edi + 0x4]
		lea ecx, [edi + 0x4]
		push time
		push mask
		push maxBones
		push _out
		call dword ptr[eax + 0x34]
	}
}

CUtlVector<Matrix3x4> Entity_t::m_CachedBoneData()
{
	auto offset = memory::cachedBones();
	return *reinterpret_cast<CUtlVector<Matrix3x4>*>(uintptr_t(this) + offset);
}

////////////////////////////////////////////////////////////////////////

std::string Weapon_t::getWpnName()
{
	switch (this->m_iItemDefinitionIndex())
	{
	case WEAPON_DEAGLE:					return "DEAGLE";
	case WEAPON_ELITE:					return "DUAL BERETTAS";
	case WEAPON_FIVESEVEN:				return "FIVE-SEVEN";
	case WEAPON_GLOCK:					return "GLOCK";
	case WEAPON_AK47:					return "AK-47";
	case WEAPON_AUG:					return "AUG";
	case WEAPON_AWP:					return "AWP";
	case WEAPON_FAMAS:					return "FAMAS";
	case WEAPON_G3SG1:					return "G3SG1";
	case WEAPON_GALILAR:				return "GAIL";
	case WEAPON_M249:					return "M249";
	case WEAPON_M4A1:					return "M4A1";
	case WEAPON_MAC10:					return "MAC-10";
	case WEAPON_P90:					return "P90";
	case WEAPON_ZONE_REPULSOR:			return "REPULSOR";
	case WEAPON_MP5SD:					return "MP5";
	case WEAPON_UMP45:					return "UMP-45";
	case WEAPON_XM1014:					return "XM1014";
	case WEAPON_BIZON:					return "PP-BIZON";
	case WEAPON_MAG7:					return "MAG-7";
	case WEAPON_NEGEV:					return "NEGEV";
	case WEAPON_SAWEDOFF:				return "SAWEDOFF";
	case WEAPON_TEC9:					return "TEC-9";
	case WEAPON_TASER:					return "TASER";
	case WEAPON_HKP2000:				return "P2000";
	case WEAPON_MP7:					return "MP7";
	case WEAPON_MP9:					return "MP9";
	case WEAPON_NOVA:					return "NOVA";
	case WEAPON_P250:					return "P250";
	case WEAPON_SHIELD:					return "SHIELD";
	case WEAPON_SCAR20:					return "SCAR-20";
	case WEAPON_SG553:					return "SG-553";
	case WEAPON_SSG08:					return "SCOUT";
	case WEAPON_FLASHBANG:				return "FLASHBANG";
	case WEAPON_HEGRENADE:				return "GRENADE";
	case WEAPON_SMOKEGRENADE:			return "SMOKE";
	case WEAPON_MOLOTOV:				return "MOLOTOV";
	case WEAPON_DECOY:					return "DECOY";
	case WEAPON_INCGRENADE:				return "INC NADE";
	case WEAPON_C4:						return "C4";
	case WEAPON_HEALTHSHOT:				return "HEALTHSHOT";
	case WEAPON_KNIFE_T:				return "KNIFE";
	case WEAPON_M4A1_SILENCER:			return "M4A1-S";
	case WEAPON_USP_SILENCER:			return "USP-S";
	case WEAPON_CZ75A:					return "CZ75-A";
	case WEAPON_REVOLVER:				return "REVOLVER";
	case WEAPON_TAGRENADE:				return "TA GRENADE";
	case WEAPON_FISTS:					return "FISTS";
	case WEAPON_BREACHCHARGE:			return "BREACH CHARGE";
	case WEAPON_TABLET:					return "TABLET";
	case WEAPON_MELEE:					return "KNIFE";
	case WEAPON_AXE:					return "AXE";
	case WEAPON_HAMMER:					return "HAMMER";
	case WEAPON_SPANNER:				return "SPANNER";
	case WEAPON_KNIFE_GHOST:			return "KNIFE";
	case WEAPON_FIREBOMB:				return "FIREBOMB";
	case WEAPON_DIVERSION:				return "DIVERSION";
	case WEAPON_FRAG_GRENADE:			return "FRAG NADE";
	case WEAPON_SNOWBALL:				return "SNOWBALL";
	case WEAPON_BUMPMINE:				return "BUMPMINE";
	case WEAPON_KNIFEGG:
	case WEAPON_KNIFE:
	case WEAPON_KNIFE_BAYONET:
	case WEAPON_KNIFE_CSS:
	case WEAPON_KNIFE_FLIP:
	case WEAPON_KNIFE_GUT:
	case WEAPON_KNIFE_KARAMBIT:
	case WEAPON_KNIFE_M9_BAYONET:
	case WEAPON_KNIFE_TACTICAL:
	case WEAPON_KNIFE_FALCHION:
	case WEAPON_KNIFE_SURVIVAL_BOWIE:
	case WEAPON_KNIFE_BUTTERFLY:
	case WEAPON_KNIFE_PUSH:
	case WEAPON_KNIFE_CORD:
	case WEAPON_KNIFE_CANIS:
	case WEAPON_KNIFE_URSUS:
	case WEAPON_KNIFE_GYPSY_JACKKNIFE:
	case WEAPON_KNIFE_OUTDOOR:
	case WEAPON_KNIFE_STILETTO:
	case WEAPON_KNIFE_WIDOWMAKER:
	case WEAPON_KNIFE_SKELETON:			return "KNIFE";
	default:
		return "Err";
	}
}

std::u8string Weapon_t::getIcon(int correctIndex)
{
	// 0xE000 - start = WEAPON_NONE

	switch (auto idx = correctIndex != -1 ? correctIndex : this->m_iItemDefinitionIndex(); idx)
	{
	case WEAPON_DEAGLE:					return u8"\uE001";
	case WEAPON_ELITE:					return u8"\uE002";
	case WEAPON_FIVESEVEN:				return u8"\uE003";
	case WEAPON_GLOCK:					return u8"\uE004";
	case WEAPON_AK47:					return u8"\uE007";
	case WEAPON_AUG:					return u8"\uE008";
	case WEAPON_AWP:					return u8"\uE009";
	case WEAPON_FAMAS:					return u8"\uE00A";
	case WEAPON_G3SG1:					return u8"\uE00B";
	case WEAPON_GALILAR:				return u8"\uE00D";
	case WEAPON_M249:					return u8"\uE00E";
	case WEAPON_M4A1:					return u8"\uE010";
	case WEAPON_MAC10:					return u8"\uE011";
	case WEAPON_P90:					return u8"\uE013";
	case WEAPON_ZONE_REPULSOR:			return u8"\uE014";
	case WEAPON_MP5SD:					return u8"\uE017";
	case WEAPON_UMP45:					return u8"\uE018";
	case WEAPON_XM1014:					return u8"\uE019";
	case WEAPON_BIZON:					return u8"\uE01A";
	case WEAPON_MAG7:					return u8"\uE01B";
	case WEAPON_NEGEV:					return u8"\uE01C";
	case WEAPON_SAWEDOFF:				return u8"\uE01D";
	case WEAPON_TEC9:					return u8"\uE01E";
	case WEAPON_TASER:					return u8"\uE01F";
	case WEAPON_HKP2000:				return u8"\uE020";
	case WEAPON_MP7:					return u8"\uE021";
	case WEAPON_MP9:					return u8"\uE022";
	case WEAPON_NOVA:					return u8"\uE023";
	case WEAPON_P250:					return u8"\uE024";
	case WEAPON_SHIELD:					return u8"\uE025";
	case WEAPON_SCAR20:					return u8"\uE026";
	case WEAPON_SG553:					return u8"\uE027";
	case WEAPON_SSG08:					return u8"\uE028";
	case WEAPON_KNIFEGG:				return u8"\uE029";
	case WEAPON_KNIFE:					return u8"\uE02A";
	case WEAPON_FLASHBANG:				return u8"\uE02B";
	case WEAPON_HEGRENADE:				return u8"\uE02C";
	case WEAPON_SMOKEGRENADE:			return u8"\uE02D";
	case WEAPON_MOLOTOV:				return u8"\uE02E";
	case WEAPON_DECOY:					return u8"\uE02F";
	case WEAPON_INCGRENADE:				return u8"\uE030";
	case WEAPON_C4:						return u8"\uE031";
	case WEAPON_HEALTHSHOT:				return u8"\uE039";
	case WEAPON_KNIFE_T:				return u8"\uE03B";
	case WEAPON_M4A1_SILENCER:			return u8"\uE03C";
	case WEAPON_USP_SILENCER:			return u8"\uE03D";
	case WEAPON_CZ75A:					return u8"\uE03F";
	case WEAPON_REVOLVER:				return u8"\uE040";
	case WEAPON_TAGRENADE:				return u8"\uE044";
	case WEAPON_FISTS:					return u8"\uE045";
	case WEAPON_BREACHCHARGE:			return u8"\uE046";
	case WEAPON_TABLET:					return u8"\uE048";
	case WEAPON_MELEE:					return u8"\uE04A";
	case WEAPON_AXE:					return u8"\uE04B";
	case WEAPON_HAMMER:					return u8"\uE04C";
	case WEAPON_SPANNER:				return u8"\uE04E";
	case WEAPON_KNIFE_GHOST:			return u8"\uE050";
	case WEAPON_FIREBOMB:				return u8"\uE051";
	case WEAPON_DIVERSION:				return u8"\uE052";
	case WEAPON_FRAG_GRENADE:			return u8"\uE053";
	case WEAPON_SNOWBALL:				return u8"\uE054";
	case WEAPON_BUMPMINE:				return u8"\uE055";
	case WEAPON_KNIFE_BAYONET:			return u8"\uE1F4";
	case WEAPON_KNIFE_CSS:				return u8"\uE1F7";
	case WEAPON_KNIFE_FLIP:				return u8"\uE1F9";
	case WEAPON_KNIFE_GUT:				return u8"\uE1FA";
	case WEAPON_KNIFE_KARAMBIT:			return u8"\uE1FB";
	case WEAPON_KNIFE_M9_BAYONET:		return u8"\uE1FC";
	case WEAPON_KNIFE_TACTICAL:			return u8"\uE1FD";
	case WEAPON_KNIFE_FALCHION:			return u8"\uE200";
	case WEAPON_KNIFE_SURVIVAL_BOWIE:	return u8"\uE202";
	case WEAPON_KNIFE_BUTTERFLY:		return u8"\uE203";
	case WEAPON_KNIFE_PUSH:				return u8"\uE204";
	case WEAPON_KNIFE_CORD:				return u8"\uE205";
	case WEAPON_KNIFE_CANIS:			return u8"\uE206";
	case WEAPON_KNIFE_URSUS:			return u8"\uE207";
	case WEAPON_KNIFE_GYPSY_JACKKNIFE:	return u8"\uE208";
	case WEAPON_KNIFE_OUTDOOR:			return u8"\uE209";
	case WEAPON_KNIFE_STILETTO:			return u8"\uE20A";
	case WEAPON_KNIFE_WIDOWMAKER:		return u8"\uE20B";
	case WEAPON_KNIFE_SKELETON:			return u8"\uE20D";
	default:
		return u8"\u0000";
	}
}

bool Weapon_t::isRifle()
{
	if (!this->getWpnInfo())
		return false;

	return this->getWpnInfo()->m_type == WEAPONTYPE_RIFLE;
}

bool Weapon_t::isSmg()
{
	if (!this->getWpnInfo())
		return false;

	return this->getWpnInfo()->m_type == WEAPONTYPE_SUBMACHINEGUN;
}

bool Weapon_t::isMachineGun()
{
	if (!this->getWpnInfo())
		return false;

	return this->getWpnInfo()->m_type == WEAPONTYPE_MACHINEGUN;
}

bool Weapon_t::isShotgun()
{
	if (!this->getWpnInfo())
		return false;

	return this->getWpnInfo()->m_type == WEAPONTYPE_SHOTGUN;
}

bool Weapon_t::isPistol()
{
	if (!this->getWpnInfo())
		return false;

	return this->getWpnInfo()->m_type == WEAPONTYPE_PISTOL;
}

bool Weapon_t::isSniper()
{
	if (!this->getWpnInfo())
		return false;

	return this->getWpnInfo()->m_type == WEAPONTYPE_SNIPER_RIFLE;
}

bool Weapon_t::isGrenade()
{
	if (!this->getWpnInfo())
		return false;

	return this->getWpnInfo()->m_type == WEAPONTYPE_GRENADE;
}

bool Weapon_t::isKnife()
{
	if (!this->getWpnInfo())
		return false;

	return this->getWpnInfo()->m_type == WEAPONTYPE_KNIFE;
}

bool Weapon_t::isNonAimable()
{
	const auto idx = m_iItemDefinitionIndex();

	if (idx == WEAPON_C4 || idx == WEAPON_HEALTHSHOT)
		return true;

	if (isKnife())
		return true;

	if (isGrenade())
		return true;

	return false;
}

size_t Weapon_t::getNadeRadius()
{
	switch (this->m_iItemDefinitionIndex())
	{
	case WEAPON_MOLOTOV:
	case WEAPON_INCGRENADE:
		return 180;
	case WEAPON_SMOKEGRENADE:
		return 144;
	case WEAPON_HEGRENADE:
		return 50;
	default:
		return 10; // because we need to somewhat render it, it's fake
	}
}

/////////////////////////////////////////////////////////////////////////////////

CUserCmd& Player_t::m_LastCmd()
{
	return *reinterpret_cast<CUserCmd*>((uintptr_t)this + memory::lastCommand());
}

void Player_t::runThink()
{
	checkHasThinkFunction();
	think();
}

// https://github.com/perilouswithadollarsign/cstrike15_src/blob/f82112a2388b841d72cb62ca48ab1846dfcc11c8/game/client/c_baseplayer.cpp#L2667
void Player_t::postThink()
{
//#if !defined( NO_ENTITY_PREDICTION )
	MDLCACHE_CRITICAL_SECTION(memory::interfaces::mdlCache());

	if (isAlive())
	{
		updateCollisionBounds();

		//if (!CommentaryModeShouldSwallowInput(this))
		//{
		//	// do weapon stuff
		//	ItemPostFrame();
		//}

		if (m_fFlags() & FL_ONGROUND)
		{
			m_flFallVelocity() = 0;
		}

		// Don't allow bogus sequence on player
		if (m_nSequence() == -1)
		{
			setSequence(0);
		}

		studioFrameAdvance();
		memory::postThinkPhysics()(this);
	}

	// Even if dead simulate entities
	memory::simulateEntities()(this);
//#endif
}

void Player_t::checkHasThinkFunction(bool isThinkingHint)
{
	memory::checkThinkFunction()(this, isThinkingHint);
}

//void Player_t::selectItem(const char* string, int subType)
//{
//	memory::selectItem()(this, string, subType);
//}

bool Player_t::usingStandardWeaponsInVehicle()
{
	return memory::usingStandardWeaponsVehicle()(this);
}

bool Player_t::physicsRunThink(thinkmethods_t think)
{
	return memory::physicsRunThink()(this, think);
}

void Player_t::setAbsOrigin(const Vec3& origin)
{
	memory::setAbsOrigin()(this, std::cref(origin));
}

Weapon_t* Player_t::getActiveWeapon()
{
	return reinterpret_cast<Weapon_t*>(memory::interfaces::entList->getClientFromHandle(this->m_hActiveWeapon()));
}

Vec3 Player_t::getHitboxPos(const int id)
{
	/*if (Matrix3x4 matBone[MAX_BONES]; setupBones(matBone, MAX_BONES, BONE_USED_BY_HITBOX, 0.0f))
	{
		if (auto modelStudio = interfaces::modelInfo->getStudioModel(this->getModel()); modelStudio != nullptr)
		{
			if (auto hitbox = modelStudio->getHitboxSet(0)->getHitbox(id); hitbox != nullptr)
			{
				Vector min = math::transformVector(hitbox->m_bbmin, matBone[hitbox->m_bone]);
				Vector max = math::transformVector(hitbox->m_bbmax, matBone[hitbox->m_bone]);

				return Vector{ min + max } * 0.5f;
			}
		}
	}*/

	if (auto modelStudio = memory::interfaces::modelInfo->getStudioModel(this->getModel()); modelStudio != nullptr)
	{
		if (auto hitbox = modelStudio->getHitboxSet(0)->getHitbox(id); hitbox != nullptr)
		{
			Vec3 min = math::transformVector(hitbox->m_bbmin, m_CachedBoneData().m_memory[hitbox->m_bone]);
			Vec3 max = math::transformVector(hitbox->m_bbmax, m_CachedBoneData().m_memory[hitbox->m_bone]);

			return Vec3{ min + max } *0.5f;
		}
	}

	return {};
}

Vec3 Player_t::getBonePos(const int id)
{
	return m_CachedBoneData().m_memory[id].origin();
}

Vec3 Player_t::getHitgroupPos(const int hitgroup)
{
	auto fixHitgroupIndex = [h = hitgroup]()
	{
		switch (h)
		{
		case HITGROUP_HEAD:
			return HITBOX_HEAD;
		case HITGROUP_CHEST:
			return HITBOX_LOWER_CHEST;
		case HITGROUP_STOMACH:
			return HITBOX_BELLY;
		case HITGROUP_LEFTARM:
			return HITBOX_LEFT_HAND;
		case HITGROUP_RIGHTARM:
			return HITBOX_RIGHT_HAND;
		case HITGROUP_LEFTLEG:
			return HITBOX_LEFT_CALF;
		case HITGROUP_RIGHTLEG:
			return HITBOX_RIGHT_CALF;
		default:
			return HITBOX_PELVIS;
		}
	};

	if (auto modelStudio = memory::interfaces::modelInfo->getStudioModel(this->getModel()); modelStudio != nullptr)
	{
		if (auto hitbox = modelStudio->getHitboxSet(this->m_nHitboxSet())->getHitbox(fixHitgroupIndex()); hitbox != nullptr)
		{
			Vec3 min = math::transformVector(hitbox->m_bbmin, m_CachedBoneData().m_memory[hitbox->m_bone]);
			Vec3 max = math::transformVector(hitbox->m_bbmax, m_CachedBoneData().m_memory[hitbox->m_bone]);
			return Vec3{ min + max } *0.5f;
		}
	}
	return {};
}

bool Player_t::isC4Owner()
{
	return memory::isC4Owner()(this);
}

std::string Player_t::getName()
{
	PlayerInfo_t info;
	memory::interfaces::engine->getPlayerInfo(this->getIndex(), &info);

	std::string name = info.m_name;

	if (name.length() > 20)
		name = name.substr(0, 20).append(XOR("..."));

	// use when surface
	/*std::for_each(name.begin(), name.end(), [](char& el)
		{
			if (el < 0 || el > 128)
				el = '?';
		});*/

	return name;
}

std::string_view Player_t::getRawName()
{
	PlayerInfo_t info;
	memory::interfaces::engine->getPlayerInfo(this->getIndex(), &info);

	return info.m_name;
}

int Player_t::getKills()
{
	return memory::interfaces::resourceInterface->getKills(this->getIndex());
}

int Player_t::getDeaths()
{
	return memory::interfaces::resourceInterface->getDeaths(this->getIndex());
}

int Player_t::getPing()
{
	return memory::interfaces::resourceInterface->getPing(this->getIndex());
}

std::string Player_t::getRank(bool useShortName)
{
	return memory::interfaces::resourceInterface->getRank(this->getIndex());
}

int Player_t::getWins()
{
	return memory::interfaces::resourceInterface->getWins(this->getIndex());
}

bool Player_t::isPossibleToSee(Player_t* player, const Vec3& pos)
{
	Trace_t tr;
	TraceFilter filter;
	filter.m_skip = this;
	memory::interfaces::trace->traceRay({ this->getEyePos(), pos }, MASK_PLAYER, &filter, &tr);

	return tr.m_entity == player || tr.m_fraction > 0.97f;
}

bool Player_t::isViewInSmoke(const Vec3& pos)
{
	return memory::throughSmoke()(this->getEyePos(), pos);
}

uintptr_t Player_t::getLiteralAddress()
{
	return *reinterpret_cast<uintptr_t*>(this);
}

CUtlVector<ClientHitVerify_t> Player_t::m_vecBulletVerifyListClient()
{
	return *reinterpret_cast<CUtlVector<ClientHitVerify_t>*>((uintptr_t)this + memory::vecClientImpacts());
}

AABB_t Player_t::getOcclusionBounds()
{
	auto col = this->collideable();
	const auto& mins = col->OBBMins();
	const auto& maxs = col->OBBMaxs();

	auto m_usSolidFlags = col->getSolidFlags();
	auto m_nSolidType = col->getSolid();

	auto isBoundsDefinedInEntitySpace = [=]()
	{
		return ((m_usSolidFlags & 0x40) == 0) &&
			(m_nSolidType != 2) && (m_nSolidType != 0);
	};

	if (!isBoundsDefinedInEntitySpace() || col->getCollisionAngles().isZero())
	{
		const auto& pos = this->absOrigin();
		return { pos + mins, pos + maxs };
	}
	else
	{
		Matrix3x4 mat = col->collisionToWorldTransform();
		auto [boundsMin, boundsMax] = math::transformAABB(mat, mins, maxs);
		return { boundsMin, boundsMax };
	}
}

#include "../ICvar.hpp"
#include "../ConVar.hpp"

AABB_t Player_t::getCameraBounds()
{
	const static auto occlusion_test_camera_margins = memory::interfaces::cvar->findVar(XOR("occlusion_test_camera_margins"));
	const static auto occlusion_test_jump_margin = memory::interfaces::cvar->findVar(XOR("occlusion_test_jump_margin"));

	const auto& pos = this->m_vecOrigin();
	float cameraMargins = occlusion_test_camera_margins->getFloat();
	float jumpMargin = occlusion_test_jump_margin->getFloat();

	return {
		pos + Vec3{ 0.0f, 0.0f, 46.0f } - Vec3{ cameraMargins, cameraMargins, 0.0f },
		pos + Vec3{ 0.0f, 0.0f, 64.0f } + Vec3{ cameraMargins, cameraMargins, jumpMargin }
	};
}

bool Player_t::isOtherTeam(Player_t* player)
{
	const static auto mp_teammates_are_enemies = memory::interfaces::cvar->findVar(XOR("mp_teammates_are_enemies"));
	bool isDM = false;
	if (mp_teammates_are_enemies && mp_teammates_are_enemies->getInt())
		isDM = true;

	if (isDM && this->m_iTeamNum() == player->m_iTeamNum())
		return true;

	if (this->m_iTeamNum() != player->m_iTeamNum())
		return true;

	return false;
}

////////////////////////////////////////////////////////////////

Vec3 Inferno_t::getInfernoPos(size_t indexFire)
{
	return Vec3{
		static_cast<float>(m_fireXDelta()[indexFire]),
		static_cast<float>(m_fireYDelta()[indexFire]),
		static_cast<float>(m_fireZDelta()[indexFire]) };
}
```

`hack/SDK/structs/Entity.hpp`:

```hpp
#pragma once

#include "../CUtlVector.hpp"
#include "../vars.hpp"
#include "../Enums.hpp"
#include "../math/Vector.hpp"
#include "../math/matrix.hpp"
#include "../math/AABB.hpp"
#include "../varMapping.hpp"
#include "../EHandle.hpp"
#include "indexes.hpp"

#include "../helpers/netvars.hpp"
#include "../helpers/vfunc.hpp"

class Weapon_t;
class Player_t;
class ClientClass;
class ICollideable;
class AnimationLayer;
struct Model_t;
class WeaponInfo;
struct DataMap_t;
class CUserCmd;
class CMoveData;
struct ClientHitVerify_t;

/*
* This file is so far probably the easiest when it comes to netvar usage
* You find the netvar - throw table and name, pretty easy
* in my source I accept only "raw" table names for netvars, it's more reliable for me
* Sometimes values need extra adress or are pointers
* Try to keep longer methods in cpp file
*/

////////////////////////////////////////////////////////////////////////////////////////////

#define RENDERABLE 0x4
#define NETWORKABLE 0x8

class Entity_t
{
public:
	NETVAR(int, m_iTeamNum, "DT_CSPlayer", "m_iTeamNum");
	NETVAR(Vec3, m_vecOrigin, "DT_BasePlayer", "m_vecOrigin");
	NETVAR(EHandle_t, m_hOwnerEntity, "DT_BaseEntity", "m_hOwnerEntity");
	NETVAR(EHandle_t, m_hVehicle, "DT_BaseEntity", "m_hVehicle");
	NETVAR(int, m_CollisionGroup, "DT_BasePlayer", "m_CollisionGroup");
	NETVAR(Vec3, m_ViewOffset, "DT_BasePlayer", "m_vecViewOffset[0]");
	NETVAR(bool, m_bSpotted, "DT_BaseEntity", "m_bSpotted");
	NETVAR(float, m_flSimulationTime, "DT_BasePlayer", "m_flSimulationTime");
	NETVAR(float, m_flMaxspeed, "DT_BasePlayer", "m_flMaxspeed");
	NETVAR_ADDR(int, m_nRenderMode, "DT_BasePlayer", "m_nRenderMode", 0x1);
	NETVAR(Vec3, m_vecMins, "DT_BaseEntity", "m_vecMins");
	NETVAR(Vec3, m_vecMaxs, "DT_BaseEntity", "m_vecMaxs");
	NETVAR(int, moveparent, "DT_BaseEntity", "moveparent");
	NETVAR(int, m_fEffects, "DT_BaseEntity", "m_fEffects");
	NETVAR(int, m_nModelIndex, "DT_BaseEntity", "m_nModelIndex");
	NETVAR(PrecipitationType_t, m_nPrecipType, "DT_Precipitation", "m_nPrecipType");
	PTRNETVAR(int, m_nNextThinkTick, "DT_BasePlayer", "m_nNextThinkTick");
	NETVAR_ADDR(int, m_nCreationTick, "DT_BaseEntity", "m_hEffectEntity", 0xC);

	VFUNC(Vec3&, absOrigin, ABS_ORIGIN, (), (this));
	VFUNC(Vec3&, absAngles, ABS_ANGLE, (), (this));
	VFUNC(ClientClass*, clientClass, CLIENT_CLASS, (), (this + NETWORKABLE));
	VFUNC(ICollideable*, collideable, COLLIDEABLE, (), (this));
	VFUNC(int, getIndex, GET_INDEX, (), (this + NETWORKABLE));
	VFUNC(void, getRenderBounds, RENDER_BOUNDS, (Vec3& mins, Vec3& maxs), (this + RENDERABLE, std::ref(mins), std::ref(maxs)));
	VFUNC(bool, isPlayer, ISPLAYER, (), (this));
	VFUNC(bool, isWeapon, ISWEAPON, (), (this));
	VFUNC(bool, setupBones, SETUP_BONES, (Matrix3x4* out, int maxBones, int mask, float time), (this + RENDERABLE, out, maxBones, mask, time));
	bool setupBonesShort(Matrix3x4* out, int maxBones, int mask, float time);
	VFUNC(Model_t*, getModel, GET_MODEL, (), (this + RENDERABLE));
	VFUNC(int, drawModel, DRAW_MODEL, (int flags, uint8_t alpha), (this + RENDERABLE, flags, alpha));
	VFUNC(bool, isDormant, IS_DORMANT, (), (this + NETWORKABLE));
	VFUNC(Matrix3x4&, renderableToWorldTransform, RENDERABLE_TO_WORLD, (), (this + RENDERABLE));
	VFUNC(void, release, RELEASE, (), (this + NETWORKABLE));
	VFUNC(void, onPreDataChanged, PRE_DATA_CHANGED, (DataUpdateType_t type), (this + NETWORKABLE, type));
	VFUNC(void, onDataChanged, DATA_CHANGED, (DataUpdateType_t type), (this + NETWORKABLE, type));
	VFUNC(void, preDataUpdate, PRE_DATA_UPDATE, (DataUpdateType_t type), (this + NETWORKABLE, type));
	VFUNC(void, postDataUpdate, POST_DATA_UPDATE, (DataUpdateType_t type), (this + NETWORKABLE, type));


	[[nodiscard]] CUtlVector<Matrix3x4> m_CachedBoneData();
	[[nodiscard]] Vec3 getAimPunch();
	[[nodiscard]] Vec3 getEyePos() { return m_vecOrigin() + m_ViewOffset(); }
	[[nodiscard]] AnimationLayer* getAnimOverlays();
	[[nodiscard]] size_t getSequenceActivity(size_t sequence);

	[[nodiscard]] bool isBreakable();
};

class Weapon_t : public Entity_t
{
public:
	NETVAR(float, m_flNextPrimaryAttack, "DT_BaseCombatWeapon", "m_flNextPrimaryAttack");
	NETVAR(float, m_flNextSecondaryAttack, "DT_BaseCombatWeapon", "m_flNextSecondaryAttack");
	NETVAR(short, m_iItemDefinitionIndex, "DT_BaseAttributableItem", "m_iItemDefinitionIndex");
	NETVAR(int, m_iClip1, "DT_BaseCombatWeapon", "m_iClip1");
	NETVAR(int, m_iClip2, "DT_BaseCombatWeapon", "m_iClip2");
	NETVAR(int, m_iPrimaryReserveAmmoCount, "DT_BaseCombatWeapon", "m_iPrimaryReserveAmmoCount");
	NETVAR(int, m_iEntityQuality, "DT_BaseCombatWeapon", "m_iEntityQuality");
	NETVAR(bool, m_bBurstMode, "DT_BaseCombatWeapon", "m_bBurstMode");
	NETVAR(int, m_iBurstShotsRemaining, "DT_BaseCombatWeapon", "m_iBurstShotsRemaining");
	NETVAR(int, m_zoomLevel, "DT_WeaponCSBaseGun", "m_zoomLevel");
	NETVAR(bool, m_bPinPulled, "DT_BaseCSGrenade", "m_bPinPulled");
	NETVAR(float, m_fThrowTime, "DT_BaseCSGrenade", "m_fThrowTime");
	NETVAR(float, m_flThrowStrength, "DT_BaseCSGrenade", "m_flThrowStrength");
	NETVAR(int, m_nExplodeEffectTickBegin, "DT_BaseCSGrenadeProjectile", "m_nExplodeEffectTickBegin");
	NETVAR(float, m_fAccuracyPenalty, "DT_WeaponCSBase", "m_fAccuracyPenalty");
	NETVAR(float, m_flRecoilIndex, "DT_WeaponCSBaseGun", "m_flRecoilIndex");

	VFUNC(float, getInaccuracy, INACCURACY, (), (this));
	VFUNC(float, getSpread, SPREAD, (), (this));
	VFUNC(WeaponInfo*, getWpnInfo, WEAPONINFO, (), (this));
	VFUNC(void, updateAccuracyPenalty, UPDATE_WEAPON_PENALTY, (), (this));

	[[nodiscard]] std::string getWpnName();
	[[nodiscard]] std::u8string getIcon(int correctIndex = -1);

	[[nodiscard]] bool isEmpty() { return m_iClip1() <= 0; }
	[[nodiscard]] bool isRifle();
	[[nodiscard]] bool isSmg();
	[[nodiscard]] bool isMachineGun();
	[[nodiscard]] bool isShotgun();
	[[nodiscard]] bool isPistol();
	[[nodiscard]] bool isSniper();
	[[nodiscard]] bool isGrenade();
	[[nodiscard]] bool isKnife();
	[[nodiscard]] bool isNonAimable();

	[[nodiscard]] size_t getNadeRadius();
};

////////////////////////////////////////////////////////////////////////////////////////////

class Inferno_t : public Entity_t
{
public:
	[[nodiscard]] static float expireTime() { return 7.0f; }
	OFFSET(float, spawnTime, 0x20);
	NETVAR(int, m_fireCount, "DT_Inferno", "m_fireCount");
	PTRNETVAR(int, m_fireXDelta, "DT_Inferno", "m_fireXDelta");
	PTRNETVAR(int, m_fireYDelta, "DT_Inferno", "m_fireYDelta");
	PTRNETVAR(int, m_fireZDelta, "DT_Inferno", "m_fireZDelta");
	[[nodiscard]] Vec3 getInfernoPos(size_t indexFire);
};

////////////////////////////////////////////////////////////////////////////////////////////

class Nade_t : public Entity_t
{
public:
	NETVAR_ADDR(float, m_flSpawnTime, "DT_BaseCSGrenadeProjectile", "m_vecExplodeEffectOrigin", 0xC);
	NETVAR(EHandle_t, m_hThrower, "DT_BaseCSGrenadeProjectile", "m_hThrower");
	NETVAR(int, m_nExplodeEffectTickBegin, "DT_BaseCSGrenadeProjectile", "m_nExplodeEffectTickBegin");
	NETVAR(Vec3, m_vecVelocity, "DT_BaseCSGrenadeProjectile", "m_vecVelocity");
	NETVAR(Vec3, m_vecOrigin, "DT_BaseCSGrenadeProjectile", "m_vecOrigin");
};

////////////////////////////////////////////////////////////////////////////////////////////

class Smoke_t : public Entity_t
{
public:
	[[nodiscard]] static float expireTime() { return 19.0f; }
	NETVAR(int, m_nSmokeEffectTickBegin, "DT_SmokeGrenadeProjectile", "m_nSmokeEffectTickBegin");
};

////////////////////////////////////////////////////////////////////////////////////////////

class Bomb_t : public Entity_t
{
public:
	NETVAR(float, m_flDefuseCountDown, "DT_PlantedC4", "m_flDefuseCountDown");
	NETVAR(EHandle_t, m_hBombDefuser, "DT_PlantedC4", "m_hBombDefuser");
	NETVAR(float, m_flC4Blow, "DT_PlantedC4", "m_flC4Blow");
	NETVAR(bool, m_bBombDefused, "DT_PlantedC4", "m_bBombDefused");
	NETVAR(bool, m_nBombSite, "DT_PlantedC4", "m_nBombSite");
	[[nodiscard]] char getBombSiteName() { return m_nBombSite() == 0 ? 'A' : 'B'; }
};

////////////////////////////////////////////////////////////////////////////////////////////

class Player_t : public Entity_t
{
public:
	NETVAR(Vec3, m_angEyeAngles, "DT_CSPlayer", "m_angEyeAngles");
	NETVAR(Vec3, m_viewPunchAngle, "DT_BasePlayer", "m_viewPunchAngle");
	NETVAR(Vec3, m_aimPunchAngle, "DT_BasePlayer", "m_aimPunchAngle");
	NETVAR(Vec3, m_vecVelocity, "DT_BasePlayer", "m_vecVelocity[0]");
	NETVAR(int, m_iHealth, "DT_CSPlayer", "m_iHealth");
	NETVAR(int, m_ArmorValue, "DT_CSPlayer", "m_ArmorValue");
	NETVAR(bool, m_bIsScoped, "DT_CSPlayer", "m_bIsScoped");
	NETVAR(bool, m_bHasHelmet, "DT_CSPlayer", "m_bHasHelmet");
	NETVAR(int, m_iShotsFired, "DT_CSPlayer", "m_iShotsFired");
	NETVAR(bool, m_bGunGameImmunity, "DT_CSPlayer", "m_bGunGameImmunity");
	NETVAR(float, m_flNextAttack, "DT_CSPlayer", "m_flNextAttack");
	NETVAR(bool, m_bHasDefuser, "DT_CSPlayer", "m_bHasDefuser");
	NETVAR(EHandle_t, m_hViewModel, "DT_BasePlayer", "m_hViewModel[0]");
	NETVAR(float, m_flLowerBodyYawTarget, "DT_CSPlayer", "m_flLowerBodyYawTarget");
	NETVAR(float, m_flFlashDuration, "DT_CSPlayer", "m_flFlashDuration");
	NETVAR_ADDR(float, m_flFlashBangTime, "DT_CSPlayer", "m_flFlashDuration", -0x10);
	NETVAR_ADDR(float, m_flNightVisionAlpha, "DT_CSPlayer", "m_flFlashDuration", -0x1C);
	NETVAR(int, m_lifeState, "DT_CSPlayer", "m_lifeState");
	NETVAR(int, m_fFlags, "DT_CSPlayer", "m_fFlags");
	NETVAR(int, m_nHitboxSet, "DT_CSPlayer", "m_nHitboxSet");
	NETVAR(int, m_nTickBase, "DT_CSPlayer", "m_nTickBase");
	NETVAR(float, m_flDuckSpeed, "DT_CSPlayer", "m_flDuckSpeed");
	NETVAR(float, m_flDuckAmount, "DT_CSPlayer", "m_flDuckAmount");
	NETVAR(bool, m_bDucked, "DT_CSPlayer", "m_bDucked");
	NETVAR(bool, m_bDucking, "DT_CSPlayer", "m_bDucking");
	NETVAR(float, m_flHealthShotBoostExpirationTime, "DT_CSPlayer", "m_flHealthShotBoostExpirationTime");
	NETVAR(EHandle_t, m_hObserverTarget, "DT_BasePlayer", "m_hObserverTarget");
	NETVAR(EHandle_t, m_hActiveWeapon, "DT_CSPlayer", "m_hActiveWeapon");
	NETVAR(int, m_iAccount, "DT_CSPlayer", "m_iAccount");
	PTRNETVAR(const char, m_szLastPlaceName, "DT_BasePlayer", "m_szLastPlaceName");
	NETVAR(float, m_flFallVelocity, "DT_BasePlayer", "m_flFallVelocity");
	NETVAR(int, m_nSequence, "DT_BaseAnimating", "m_nSequence");
	NETVAR(float, m_flVelocityModifier, "DT_CSPlayer", "m_flVelocityModifier");	
	NETVAR(int, m_iNumRoundKillsHeadshots, "DT_CSPlayer", "m_iNumRoundKillsHeadshots");
	NETVAR(int, m_totalHitsOnServer, "DT_CSPlayer", "m_totalHitsOnServer");
	PTROFFSET(VarMapping_t, getVarMap, 0x24);
	DATAMAP_FIELD(int, m_afButtonLast, getPredictionDataMap(), "m_afButtonLast");
	DATAMAP_FIELD(int, m_afButtonPressed, getPredictionDataMap(), "m_afButtonPressed");
	DATAMAP_FIELD(int, m_afButtonReleased, getPredictionDataMap(), "m_afButtonReleased");
	NETVAR_ADDR(int, m_afButtonForced, "DT_BasePlayer", "m_iDefaultFOV", 0x8);
	NETVAR_ADDR(int, m_afButtonDisabled, "DT_BasePlayer", "m_iDefaultFOV", 0x4);
	PTRNETVAR_ADDR(CUserCmd*, m_pCurrentCommand, "DT_BasePlayer", "m_iDefaultFOV", 0xC);
	NETVAR_ADDR(float, m_flSpawnTime, "DT_CSPlayer", "m_iAddonBits", -0x4);
	[[nodiscard]] CUserCmd& m_LastCmd();
	PTRDATAMAP_FIELD(int, m_nButtons, getPredictionDataMap(), "m_nButtons");
	PTRDATAMAP_FIELD(int, m_nImpulse, getPredictionDataMap(), "m_nImpulse");
	DATAMAP_FIELD(Vec3, m_vecAbsVelocity, getPredictionDataMap(), "m_vecAbsVelocity");
	DATAMAP_FIELD(Vec3, m_vecNetworkOrigin, getPredictionDataMap(), "m_vecNetworkOrigin");
	DATAMAP_FIELD(int, m_iEFlags, getPredictionDataMap(), "m_iEFlags");
	VFUNC(DataMap_t*, getPredictionDataMap, DATAMAP_PREDICTION, (), (this));
	VFUNC(void, preThink, PRE_THINK, (), (this));
	VFUNC(void, think, THINK, (), (this));
	void runThink();
	void postThink();
	void checkHasThinkFunction(bool isThinkingHint = false);
	VFUNC(void, selectItem, SELECTITEM, (const char* string, int subType = 0), (this, string, subType));
	bool usingStandardWeaponsInVehicle();
	VFUNC(void, updateCollisionBounds, UPDATE_COLLISION_BOUNDS, (), (this));
	VFUNC(void, setSequence, SET_SEQUENCE, (int seq), (this, seq));
	VFUNC(void, studioFrameAdvance, STUDIO_FRAME_ADVANCE, (), (this));
	// VEHICLES ONLY
	VFUNC(void, processMovement, PROCESS_MOVEMENT, (Entity_t* veh, Player_t* player, CMoveData* data), (this, veh, player, data));
	[[nodiscard]] bool physicsRunThink(thinkmethods_t think);
	[[nodiscard]] CUtlVector<ClientHitVerify_t> m_vecBulletVerifyListClient();

	void setAbsOrigin(const Vec3& origin);
	[[nodiscard]] Weapon_t* getActiveWeapon();
	[[nodiscard]] bool isAlive() { return m_iHealth() > 0; }
	[[nodiscard]] bool isInAir() { return !(m_fFlags() & FL_ONGROUND); }
	[[nodiscard]] bool isMoving() { return m_vecVelocity().toVecPrev().length() > 0.1f; }

	[[nodiscard]] Vec3 getHitboxPos(const int id);
	[[nodiscard]] Vec3 getBonePos(const int id);
	[[nodiscard]] Vec3 getHitgroupPos(const int hitgroup);
	[[nodiscard]] bool isC4Owner();
	[[nodiscard]] std::string getName();
	[[nodiscard]] std::string_view getRawName();
	[[nodiscard]] int getKills();
	[[nodiscard]] int getDeaths();
	[[nodiscard]] int getPing();
	[[nodiscard]] std::string getRank(bool useShortName = false);
	[[nodiscard]] int getWins();
	[[nodiscard]] bool isPossibleToSee(Player_t* player, const Vec3& pos);
	[[nodiscard]] bool isViewInSmoke(const Vec3& pos);
	[[nodiscard]] bool isOtherTeam(Player_t* player);
	// address as number
	[[nodiscard]] uintptr_t getLiteralAddress();

	// https://github.com/perilouswithadollarsign/cstrike15_src/blob/f82112a2388b841d72cb62ca48ab1846dfcc11c8/game/shared/collisionproperty.cpp#L845
	[[nodiscard]] AABB_t getOcclusionBounds();
	// https://github.com/perilouswithadollarsign/cstrike15_src/blob/f82112a2388b841d72cb62ca48ab1846dfcc11c8/game/server/gameinterface.cpp#L2772
	[[nodiscard]] AABB_t getCameraBounds();
};

////////////////////////////////////////////////////////////////////////////////////////////

class FogController_t : public Entity_t
{
public:
	NETVAR(bool, m_fogenable, "DT_FogController", "m_fog.enable");
	NETVAR(float, m_fogstart, "DT_FogController", "m_fog.start");
	NETVAR(float, m_fogend, "DT_FogController", "m_fog.end");
	NETVAR(float, m_fogmaxdensity, "DT_FogController", "m_fog.maxdensity");
	NETVAR(int, m_fogcolorPrimary, "DT_FogController", "m_fog.colorPrimary");
	NETVAR(int, m_fogcolorSecondary, "DT_FogController", "m_fog.colorSecondary");
};

////////////////////////////////////////////////////////////////////////////////////////////

class EnvTonemapController_t : public Entity_t
{
public:
	NETVAR(bool, m_bUseCustomAutoExposureMin, "DT_EnvTonemapController", "m_bUseCustomAutoExposureMin");
	NETVAR(bool, m_bUseCustomAutoExposureMax, "DT_EnvTonemapController", "m_bUseCustomAutoExposureMax");
	NETVAR(float, m_flCustomAutoExposureMin, "DT_EnvTonemapController", "m_flCustomAutoExposureMin");
	NETVAR(float, m_flCustomAutoExposureMax, "DT_EnvTonemapController", "m_flCustomAutoExposureMax");
	NETVAR(bool, m_bUseCustomBloomScale, "DT_EnvTonemapController", "m_bUseCustomBloomScale");
	NETVAR(float, m_flCustomBloomScale, "DT_EnvTonemapController", "m_flCustomBloomScale");
};

class EnvAmbientLight_t : public Entity_t
{
public:
	NETVAR(Vec3, m_vecColor, "DT_EnvAmbientLight", "m_vecColor");
};

#undef RENDERABLE
#undef NETWORKABLE

////////////////////////////////////////////////////////////////////////////////////////////
```

`hack/SDK/structs/indexes.hpp`:

```hpp
#pragma once

enum VTableIndexes
{
	ISPLAYER = 158,
	ISWEAPON = 166,
	INACCURACY = 483,
	SPREAD = 453,
	WEAPONINFO = 461,
	PUNCH = 346,
	ABS_ORIGIN = 10,
	ABS_ANGLE = 11,
	CLIENT_CLASS = 2,
	COLLIDEABLE = 3,
	GET_INDEX = 10,
	RENDER_BOUNDS = 17,
	SETUP_BONES = 13,
	GET_MODEL = 8,
	DRAW_MODEL = 9,
	IS_DORMANT = 9,
	RENDERABLE_TO_WORLD = 32,
	RELEASE = 1,
	PRE_DATA_CHANGED = 4,
	DATA_CHANGED = 5,
	PRE_DATA_UPDATE = 6,
	POST_DATA_UPDATE = 7,
	DATAMAP_PREDICTION = 17,
	PRE_THINK = 318,
	THINK = 139,
	UPDATE_WEAPON_PENALTY = 484,
	UPDATE_COLLISION_BOUNDS = 340,
	POST_THINK = 319,
	SET_SEQUENCE = 219,
	STUDIO_FRAME_ADVANCE = 220,
	SELECTITEM = 330,
	PROCESS_MOVEMENT = 5,
};
```

`hack/SDK/varMapping.hpp`:

```hpp
#pragma once

#include "CUtlVector.hpp"

class VarMapEntry_t
{
public:
	uint16_t m_type;
	uint16_t m_needsToInterpolate;	// Set to false when this var doesn't
	// need Interpolate() called on it anymore.
	void* m_data;
	/*IInterpolatedVar**/ void* m_watcher;
};

struct VarMapping_t
{
	constexpr VarMapping_t() :
		m_interpolatedEntries{ 0 }
	{}

	CUtlVector<VarMapEntry_t> m_Entries;
	int	m_interpolatedEntries;
	float m_lastInterpolationTime;
};
```

`hack/SDK/vars.hpp`:

```hpp
#pragma once

#pragma region bone_masks
#define BONE_SCREEN_ALIGN_CYLINDER	0x10	// bone aligns to the screen, constrained by it's own axis.

#define BONE_USED_MASK				0x0007FF00
#define BONE_USED_BY_ANYTHING		0x0007FF00
#define BONE_USED_BY_HITBOX			0x00000100	// bone (or child) is used by a hit box
#define BONE_USED_BY_ATTACHMENT		0x00000200	// bone (or child) is used by an attachment point
#define BONE_USED_BY_VERTEX_MASK	0x0003FC00
#define BONE_USED_BY_VERTEX_LOD0	0x00000400	// bone (or child) is used by the toplevel model via skinned vertex
#define BONE_USED_BY_VERTEX_LOD1	0x00000800
#define BONE_USED_BY_VERTEX_LOD2	0x00001000
#define BONE_USED_BY_VERTEX_LOD3	0x00002000
#define BONE_USED_BY_VERTEX_LOD4	0x00004000
#define BONE_USED_BY_VERTEX_LOD5	0x00008000
#define BONE_USED_BY_VERTEX_LOD6	0x00010000
#define BONE_USED_BY_VERTEX_LOD7	0x00020000
#define BONE_USED_BY_BONE_MERGE		0x00040000	// bone is available for bone merge to occur against it

// 256 actually, correct me if I am wrong, but for simple stuff such as getbone or gethitbox to 3d pos
// there is no need to go with its 256 value
#define MAX_BONES 128
#pragma endregion

#pragma region player_masks
// CBaseEntity::m_fFlags
// PLAYER SPECIFIC FLAGS FIRST BECAUSE WE USE ONLY A FEW BITS OF NETWORK PRECISION
#define	FL_ONGROUND				(1<<0)	// At rest / on the ground
#define FL_DUCKING				(1<<1)	// Player flag -- Player is fully crouched
#define	FL_WATERJUMP			(1<<3)	// player jumping out of water
#define FL_ONTRAIN				(1<<4) // Player is _controlling_ a train, so movement commands should be ignored on client during prediction.
#define FL_INRAIN				(1<<5)	// Indicates the entity is standing in rain
#define FL_FROZEN				(1<<6) // Player is frozen for 3rd person camera
#define FL_ATCONTROLS			(1<<7) // Player can't move, but keeps key inputs for controlling another entity
#define	FL_CLIENT				(1<<8)	// Is a player
#define FL_FAKECLIENT			(1<<9)	// Fake client, simulated server side; don't send network messages to them
#define	FL_INWATER				(1<<10)	// In water

// NOTE if you move things up, make sure to change this value
#define PLAYER_FLAG_BITS		11

// NON-PLAYER SPECIFIC (i.e., not used by GameMovement or the client .dll ) -- Can still be applied to players, though
#define	FL_FLY					(1<<11)	// Changes the SV_Movestep() behavior to not need to be on ground
#define	FL_SWIM					(1<<12)	// Changes the SV_Movestep() behavior to not need to be on ground (but stay in water)
#define	FL_CONVEYOR				(1<<13)
#define	FL_NPC					(1<<14)
#define	FL_GODMODE				(1<<15)
#define	FL_NOTARGET				(1<<16)
#define	FL_AIMTARGET			(1<<17)	// set if the crosshair needs to aim onto the entity
#define	FL_PARTIALGROUND		(1<<18)	// not all corners are valid
#define FL_STATICPROP			(1<<19)	// Eetsa static prop!
#define FL_GRAPHED				(1<<20) // worldgraph has this ent listed as something that blocks a connection
#define FL_GRENADE				(1<<21)
#define FL_STEPMOVEMENT			(1<<22)	// Changes the SV_Movestep() behavior to not do any processing
#define FL_DONTTOUCH			(1<<23)	// Doesn't generate touch functions, generates Untouch() for anything it was touching when this flag was set
#define FL_BASEVELOCITY			(1<<24)	// Base velocity has been applied this frame (used to convert base velocity into momentum)
#define FL_WORLDBRUSH			(1<<25)	// Not moveable/removeable brush entity (really part of the world, but represented as an entity for transparency or something)
#define FL_OBJECT				(1<<26) // Terrible name. This is an object that NPCs should see. Missiles, for example.
#define FL_KILLME				(1<<27)	// This entity is marked for death -- will be freed by game DLL
#define FL_ONFIRE				(1<<28)	// You know...
#define FL_DISSOLVING			(1<<29) // We're dissolving!
#define FL_TRANSRAGDOLL			(1<<30) // In the process of turning into a client side ragdoll.
#define FL_UNBLOCKABLE_BY_PLAYER (1<<31) // pusher that can't be blocked by the player


#define IN_ATTACK  (1 << 0)
#define IN_JUMP   (1 << 1)
#define IN_DUCK   (1 << 2)
#define IN_FORWARD  (1 << 3)
#define IN_BACK   (1 << 4)
#define IN_USE   (1 << 5)
#define IN_CANCEL  (1 << 6)
#define IN_LEFT   (1 << 7)
#define IN_RIGHT  (1 << 8)
#define IN_MOVELEFT  (1 << 9)
#define IN_MOVERIGHT (1 << 10)
#define IN_ATTACK2  (1 << 11)
#define IN_RUN   (1 << 12)
#define IN_RELOAD  (1 << 13)
#define IN_ALT1   (1 << 14)
#define IN_ALT2   (1 << 15)
#define IN_SCORE  (1 << 16)
#define IN_SPEED  (1 << 17)
#define IN_WALK   (1 << 18)
#define IN_ZOOM   (1 << 19)
#define IN_WEAPON1  (1 << 20)
#define IN_WEAPON2  (1 << 21)
#define IN_BULLRUSH  (1 << 22)
#define IN_GRENADE1  (1 << 23)
#define IN_GRENADE2  (1 << 24)
#define IN_LOOKSPIN  (1 << 25)
#pragma endregion

#pragma region texture_names
#define TEXTURE_GROUP_LIGHTMAP						        "Lightmaps"
#define TEXTURE_GROUP_WORLD							          "World textures"
#define TEXTURE_GROUP_MODEL							          "Model textures"
#define TEXTURE_GROUP_VGUI							          "VGUI textures"
#define TEXTURE_GROUP_PARTICLE						        "Particle textures"
#define TEXTURE_GROUP_DECAL							          "Decal textures"
#define TEXTURE_GROUP_SKYBOX						          "SkyBox textures"
#define TEXTURE_GROUP_CLIENT_EFFECTS				      "ClientEffect textures"
#define TEXTURE_GROUP_OTHER							          "Other textures"
#define TEXTURE_GROUP_PRECACHED						        "Precached"
#define TEXTURE_GROUP_CUBE_MAP						        "CubeMap textures"
#define TEXTURE_GROUP_RENDER_TARGET					      "RenderTargets"
#define TEXTURE_GROUP_UNACCOUNTED					        "Unaccounted textures"
//#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER		  "Static Vertex"
#define TEXTURE_GROUP_STATIC_INDEX_BUFFER			    "Static Indices"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_DISP		"Displacement Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_COLOR	"Lighting Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_WORLD	"World Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_MODELS	"Model Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_OTHER	"Other Verts"
#define TEXTURE_GROUP_DYNAMIC_INDEX_BUFFER			  "Dynamic Indices"
#define TEXTURE_GROUP_DYNAMIC_VERTEX_BUFFER			  "Dynamic Verts"
#define TEXTURE_GROUP_DEPTH_BUFFER					      "DepthBuffer"
#define TEXTURE_GROUP_VIEW_MODEL					        "ViewModel"
#define TEXTURE_GROUP_PIXEL_SHADERS					      "Pixel Shaders"
#define TEXTURE_GROUP_VERTEX_SHADERS				      "Vertex Shaders"
#define TEXTURE_GROUP_RENDER_TARGET_SURFACE			  "RenderTarget Surfaces"
#define TEXTURE_GROUP_MORPH_TARGETS					      "Morph Targets"
#pragma endregion

#pragma region content_masks
#define	CONTENTS_EMPTY			0		// No contents

#define	CONTENTS_SOLID			0x1		// an eye is never valid in a solid
#define	CONTENTS_WINDOW			0x2		// translucent, but not watery (glass)
#define	CONTENTS_AUX			0x4
#define	CONTENTS_GRATE			0x8		// alpha-tested "grate" textures.  Bullets/sight pass through, but solids don't
#define	CONTENTS_SLIME			0x10
#define	CONTENTS_WATER			0x20
#define	CONTENTS_BLOCKLOS		0x40	// block AI line of sight
#define CONTENTS_OPAQUE			0x80	// things that cannot be seen through (may be non-solid though)
#define	LAST_VISIBLE_CONTENTS	0x80
#define ALL_VISIBLE_CONTENTS (LAST_VISIBLE_CONTENTS | (LAST_VISIBLE_CONTENTS-1))

#define CONTENTS_TESTFOGVOLUME	0x100
#define CONTENTS_UNUSED			0x200	

// unused 
// NOTE: If it's visible, grab from the top + update LAST_VISIBLE_CONTENTS
// if not visible, then grab from the bottom.
#define CONTENTS_UNUSED6		0x400

#define CONTENTS_TEAM1			0x800	// per team contents used to differentiate collisions 
#define CONTENTS_TEAM2			0x1000	// between players and objects on different teams

// ignore CONTENTS_OPAQUE on surfaces that have SURF_NODRAW
#define CONTENTS_IGNORE_NODRAW_OPAQUE	0x2000

// hits entities which are MOVETYPE_PUSH (doors, plats, etc.)
#define CONTENTS_MOVEABLE		0x4000

// remaining contents are non-visible, and don't eat brushes
#define	CONTENTS_AREAPORTAL		0x8000

#define	CONTENTS_PLAYERCLIP		0x10000
#define	CONTENTS_MONSTERCLIP	0x20000

// currents can be added to any other contents, and may be mixed
#define	CONTENTS_CURRENT_0		0x40000
#define	CONTENTS_CURRENT_90		0x80000
#define	CONTENTS_CURRENT_180	0x100000
#define	CONTENTS_CURRENT_270	0x200000
#define	CONTENTS_CURRENT_UP		0x400000
#define	CONTENTS_CURRENT_DOWN	0x800000

#define	CONTENTS_ORIGIN			0x1000000	// removed before bsping an entity

#define	CONTENTS_MONSTER		0x2000000	// should never be on a brush, only in game
#define	CONTENTS_DEBRIS			0x4000000
#define	CONTENTS_DETAIL			0x8000000	// brushes to be added after vis leafs
#define	CONTENTS_TRANSLUCENT	0x10000000	// auto set if any surface has trans
#define	CONTENTS_LADDER			0x20000000
#define CONTENTS_HITBOX			0x40000000	// use accurate hitboxes on trace


#define	CONTENTS_ORIGIN			0x1000000	// removed before bsping an entity

#define	CONTENTS_MONSTER		0x2000000	// should never be on a brush, only in game
#define	CONTENTS_DEBRIS			0x4000000
#define	CONTENTS_DETAIL			0x8000000	// brushes to be added after vis leafs
#define	CONTENTS_TRANSLUCENT	0x10000000	// auto set if any surface has trans
#define	CONTENTS_LADDER			0x20000000
#define CONTENTS_HITBOX			0x40000000	// use accurate hitboxes on trace
#pragma endregion

#pragma region masks
#define MASK_ALL						(0xFFFFFFFF)
#define MASK_SOLID						(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)
#define MASK_PLAYERSOLID				(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_PLAYERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)
#define MASK_NPCSOLID					(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)
#define MASK_NPCFLUID					(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER)
#define MASK_WATER						(CONTENTS_WATER|CONTENTS_MOVEABLE|CONTENTS_SLIME)
#define MASK_OPAQUE						(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_OPAQUE)
#define MASK_OPAQUE_AND_NPCS			(MASK_OPAQUE|CONTENTS_MONSTER)
#define MASK_BLOCKLOS					(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_BLOCKLOS)
#define MASK_BLOCKLOS_AND_NPCS			(MASK_BLOCKLOS|CONTENTS_MONSTER)
#define MASK_VISIBLE					(MASK_OPAQUE|CONTENTS_IGNORE_NODRAW_OPAQUE)
#define MASK_VISIBLE_AND_NPCS			(MASK_OPAQUE_AND_NPCS|CONTENTS_IGNORE_NODRAW_OPAQUE)
#define MASK_SHOT						(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_HITBOX)
#define MASK_SHOT_BRUSHONLY				(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_DEBRIS)
#define MASK_SHOT_HULL					(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_GRATE)
#define MASK_SHOT_PORTAL				(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTER)
#define MASK_SOLID_BRUSHONLY			(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_GRATE)
#define MASK_PLAYERSOLID_BRUSHONLY		(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_PLAYERCLIP|CONTENTS_GRATE)
#define MASK_NPCSOLID_BRUSHONLY			(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP|CONTENTS_GRATE)
#define MASK_NPCWORLDSTATIC				(CONTENTS_SOLID|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP|CONTENTS_GRATE)
#define MASK_NPCWORLDSTATIC_FLUID		(CONTENTS_SOLID|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP)
#define MASK_SPLITAREAPORTAL			(CONTENTS_WATER|CONTENTS_SLIME)
#define MASK_CURRENT					(CONTENTS_CURRENT_0|CONTENTS_CURRENT_90|CONTENTS_CURRENT_180|CONTENTS_CURRENT_270|CONTENTS_CURRENT_UP|CONTENTS_CURRENT_DOWN)
#define MASK_DEADSOLID					(CONTENTS_SOLID|CONTENTS_PLAYERCLIP|CONTENTS_WINDOW|CONTENTS_GRATE)
#define	MASK_PLAYER						(CONTENTS_HITBOX|CONTENTS_MONSTER|CONTENTS_DEBRIS|CONTENTS_MOVEABLE|CONTENTS_SOLID|CONTENTS_WINDOW|CONTENTS_GRATE)
#pragma endregion

#pragma region netflows
#define FLOW_OUTGOING	0
#define FLOW_INCOMING	1
#define MAX_FLOWS		2		// in & out
#pragma endregion

#pragma region create_render_flags
#define CREATERENDERTARGETFLAGS_HDR				0x00000001
#define CREATERENDERTARGETFLAGS_AUTOMIPMAP		0x00000002
#define CREATERENDERTARGETFLAGS_UNFILTERABLE_OK 0x00000004
#pragma endregion

#pragma region edicts
// How many bits to use to encode an edict.
#define	MAX_EDICT_BITS				11			// # of bits needed to represent max edicts
// Max # of edicts in a level
#define	MAX_EDICTS					(1<<MAX_EDICT_BITS)

// How many bits to use to encode an server class index
#define MAX_SERVER_CLASS_BITS		9
// Max # of networkable server classes
#define MAX_SERVER_CLASSES			(1<<MAX_SERVER_CLASS_BITS)
#pragma endregion

// no idea how to call it
#pragma region defs_unknown_name
#define TICK_NEVER_THINK		( -1 )
#pragma endregion

```

`hack/cheats/classes/CM.cpp`:

```cpp
#include "createMove.hpp"

void CreateMoveInPredictionType::runAll(CUserCmd* cmd)
{
	for (auto el : m_hacksRun)
		el->run(cmd);
}

void CreateMovePrePredictionType::runAll(CUserCmd* cmd)
{
	for (auto el : m_hacksRun)
		el->run(cmd);
}

void CreateMovePostPredictionType::runAll(CUserCmd* cmd)
{
	for (auto el : m_hacksRun)
		el->run(cmd);
}
```

`hack/cheats/classes/DM.cpp`:

```cpp
#include "drawModel.hpp"

void DrawModelType::runAll(void* result, const DrawModelState_t& state, const ModelRenderInfo_t& info, Matrix3x4* matrix)
{
	for (auto el : m_hacksRun)
		el->run(result, state, info, matrix);
}
```

`hack/cheats/classes/DPSE.cpp`:

```cpp
#include "doPostScreen.hpp"

void DoPostScreenType::runAll()
{
	for (auto el : m_hacksRun)
		el->run();
}
```

`hack/cheats/classes/OV.cpp`:

```cpp
#include <cheats/classes/overrideView.hpp>

void OverrideViewType::runAll(CViewSetup* view)
{
	for (auto el : m_hacksRun)
		el->run(view);
}
```

`hack/cheats/classes/README.md`:

```md
classes: contain "types" where the code in hooks will run.

pseudo with wrong code below
```c++
void renderBox(...); // something that draws it

type paintHook(...)
{
    ...

	if(panel == ...)
		renderBox(...); // WRONG, we don't want to manually pass them everytime

    ...
}
```

correct code
```c++
class RenderPlayer : public RenderableSurfaceType
{
public:
	constexpr RenderPlayer() :
		PaintBaseType{} // adding the object to the buffer with what to run
	{}

	virtual void init() override;
	virtual void reset() override; // optional, resets what you need when levelInitPostEntity is called
	virtual void load() override; // optional, levelInitPreEntity is called
	virtual void draw() override; // put all stuff that draws anything related with "player render" keyword
private:
	void renderBox(...);
}

[[maybe_unused]] inline auto g_RenderPlayer = RenderPlayer{}; // we have our draw running without modyfying code in hooks
```
There are also types that don't run anything, look ``OnlyInitType``

Hooks body code is not modified due to the fact ``runAll()`` methods are static, as well as any base method ending with ``All()``
Keep in mind that very specific hooks for the feature are not stored in vector anyhow. There is no need to store this object and execute only 1 element.
For example motion blur, cache, fakelatency, modulateColor. Those are executed by public static methods.
```

`hack/cheats/classes/VR.cpp`:

```cpp
#include "viewRender.hpp"

void ViewRenderType::runAll(const CViewSetup& view)
{
	for (auto el : m_hacksRun)
		el->run(view);
}

```

`hack/cheats/classes/base.cpp`:

```cpp
#include "base.hpp"

#include <utilities/console/console.hpp>
#include <utilities/tools/tools.hpp>

void BaseHack::initAll()
{
	for (auto el : m_hacks)
		el->init();

	LOG_DEBUG(XOR("Inited {} functions!"), m_hacks.size());
}

void BaseHack::shutdownAll()
{
	for (auto el : m_hacks)
		el->shutdown();
}

void BaseHack::resetAll()
{
	for (auto el : m_hacks)
		el->reset();
}

void BaseHack::loadAll()
{
	for (auto el : m_hacks)
		el->load();
}

void BaseHack::restartRoundAll()
{
	for (auto el : m_hacks)
		el->roundRestart();
}
```

`hack/cheats/classes/base.hpp`:

```hpp
#pragma once

#include <vector>
#include <memory>

// a base class for creating hacks, see folder "classes" and features and example how to use it.
// we should not care what is first as init or last, those things to init should not depend at all.
class BaseHack
{
public:
	constexpr BaseHack() { m_hacks.push_back(this); }

	static void initAll();
	static void resetAll();
	static void loadAll();
	static void shutdownAll();
	static void restartRoundAll();
protected:
	virtual void init() = 0;
	virtual void reset() = 0;
	virtual void load() = 0;
	virtual void shutdown() = 0;
	virtual void roundRestart() = 0;
private:
	inline static std::vector<BaseHack*> m_hacks;
};

#define GLOBAL_FEATURE(className) [[maybe_unused]] inline auto g_##className = std::unique_ptr<className>{ new className };
```

`hack/cheats/classes/createMove.hpp`:

```hpp
#pragma once

#include "base.hpp"

#include <vector>

class CUserCmd;

class CreateMoveInPredictionType : protected BaseHack
{
public:
	constexpr CreateMoveInPredictionType() :
		BaseHack{}
	{
		m_hacksRun.push_back(this);
	}

	static void runAll(CUserCmd* cmd);
protected:
	virtual void run(CUserCmd* cmd) = 0;
	// keep those methods to be nothing as default
	// mostly we don't need all of them
	virtual void init() override {};
	virtual void load() override {};
	virtual void reset() override {};
	virtual void shutdown() override {};
	virtual void roundRestart() override {};
private:
	inline static std::vector<CreateMoveInPredictionType*> m_hacksRun;
};

class CreateMovePrePredictionType : protected BaseHack
{
public:
	constexpr CreateMovePrePredictionType() :
		BaseHack{}
	{
		m_hacksRun.push_back(this);
	}

	static void runAll(CUserCmd* cmd);
protected:
	virtual void run(CUserCmd* cmd) = 0;
	// keep those methods to be nothing as default
	// mostly we don't need all of them
	virtual void init() override {};
	virtual void load() override {};
	virtual void reset() override {};
	virtual void shutdown() override {};
	virtual void roundRestart() override {};
private:
	inline static std::vector<CreateMovePrePredictionType*> m_hacksRun;
};

class CreateMovePostPredictionType : protected BaseHack
{
public:
	constexpr CreateMovePostPredictionType() :
		BaseHack{}
	{
		m_hacksRun.push_back(this);
	}

	static void runAll(CUserCmd* cmd);
protected:
	virtual void run(CUserCmd* cmd) = 0;
	// keep those methods to be nothing as default
	// mostly we don't need all of them
	virtual void init() override {};
	virtual void load() override {};
	virtual void reset() override {};
	virtual void shutdown() override {};
	virtual void roundRestart() override {};
private:
	inline static std::vector<CreateMovePostPredictionType*> m_hacksRun;
};
```

`hack/cheats/classes/doPostScreen.hpp`:

```hpp
#pragma once

#include "base.hpp"

#include <vector>

class DoPostScreenType : protected BaseHack
{
public:
	constexpr DoPostScreenType() :
		BaseHack{}
	{
		m_hacksRun.push_back(this);
	}
public:
	static void runAll();
protected:
	virtual void run() = 0;
	// keep those methods to be nothing as default
	// mostly we don't need all of them
	virtual void init() override {};
	virtual void load() override {};
	virtual void reset() override {};
	virtual void shutdown() override {};
	virtual void roundRestart() override {};
private:
	inline static std::vector<DoPostScreenType*> m_hacksRun;
};
```

`hack/cheats/classes/drawModel.hpp`:

```hpp
#pragma once

#include "base.hpp"
#include <SDK/math/matrix.hpp>

#include <vector>

struct DrawModelState_t;
struct ModelRenderInfo_t;

class DrawModelType : protected BaseHack
{
public:
	constexpr DrawModelType() :
		BaseHack{}
	{
		m_hacksRun.push_back(this);
	}

public:
	static void runAll(void* result, const DrawModelState_t& state, const ModelRenderInfo_t& info, Matrix3x4* matrix);
protected:
	virtual void run(void* result, const DrawModelState_t& state, const ModelRenderInfo_t& info, Matrix3x4* matrix) = 0;
	// keep those methods to be nothing as default
	// mostly we don't need all of them
	virtual void init() override {};
	virtual void load() override {};
	virtual void reset() override {};
	virtual void shutdown() override {};
	virtual void roundRestart() override {};
private:
	inline static std::vector<DrawModelType*> m_hacksRun;
};
```

`hack/cheats/classes/frameStage.cpp`:

```cpp
#include "frameStage.hpp"

void FrameStageType::runAll(int frame)
{
	for (auto el : m_hacksRun)
		el->run(frame);
}
```

`hack/cheats/classes/frameStage.hpp`:

```hpp
#pragma once

#include "base.hpp"

#include <vector>

class FrameStageType : protected BaseHack
{
public:
	constexpr FrameStageType() :
		BaseHack{}
	{
		m_hacksRun.push_back(this);
	}

	static void runAll(int frame);
protected:
	virtual void run(int frame) = 0;
	// keep those methods to be nothing as default
	// mostly we don't need all of them
	virtual void init() override {};
	virtual void load() override {};
	virtual void reset() override {};
	virtual void shutdown() override {};
	virtual void roundRestart() override {};
private:
	inline static std::vector<FrameStageType*> m_hacksRun;
};
```

`hack/cheats/classes/onlyInit.hpp`:

```hpp
#pragma once

#include "base.hpp"

// when only init is needed, or we want to control execution by ourselves in special places
class OnlyInitType : protected BaseHack
{
public:
	constexpr OnlyInitType() :
		BaseHack{}
	{}
	// keep those methods to be nothing as default
	// mostly we don't need all of them
protected:
	virtual void reset() override {};
	virtual void load() override {};
	virtual void shutdown() override {};
	virtual void roundRestart() override {};
};
```

`hack/cheats/classes/overViewMap.cpp`:

```cpp
#include <cheats/classes/overViewMap.hpp>

void OverViewMapType::runAll(MapStruct* map)
{
	for (auto el : m_hacksRun)
		el->run(map);
}
```

`hack/cheats/classes/overViewMap.hpp`:

```hpp
#pragma once

#include "base.hpp"

#include <vector>

struct MapStruct;

class OverViewMapType : protected BaseHack
{
public:
	constexpr OverViewMapType() :
		BaseHack{}
	{
		m_hacksRun.push_back(this);
	}

	static void runAll(MapStruct* map);
protected:
	virtual void run(MapStruct* map) = 0;
	// keep those methods to be nothing as default
	// mostly we don't need all of them
	virtual void init() override {};
	virtual void load() override {};
	virtual void reset() override {};
	virtual void shutdown() override {};
	virtual void roundRestart() override {};
private:
	inline static std::vector<OverViewMapType*> m_hacksRun;
};
```

`hack/cheats/classes/overrideView.hpp`:

```hpp
#pragma once

#include "base.hpp"

#include <vector>

class CViewSetup;

class OverrideViewType : protected BaseHack
{
public:
	constexpr OverrideViewType() :
		BaseHack{}
	{
		m_hacksRun.push_back(this);
	}

	static void runAll(CViewSetup* view);
protected:
	virtual void run(CViewSetup* view) = 0;
	// keep those methods to be nothing as default
	// mostly we don't need all of them
	virtual void init() override {};
	virtual void load() override {};
	virtual void reset() override {};
	virtual void shutdown() override {};
	virtual void roundRestart() override {};
private:
	inline static std::vector<OverrideViewType*> m_hacksRun;
};
```

`hack/cheats/classes/renderableToPresent.cpp`:

```cpp
#include "renderableToPresent.hpp"

void RenderablePresentType::runAll()
{
	for (auto el : m_hacksRun)
		el->draw();
}
```

`hack/cheats/classes/renderableToPresent.hpp`:

```hpp
#pragma once

#include "base.hpp"

#include <vector>

class RenderablePresentType : protected BaseHack
{
public:
	constexpr RenderablePresentType() :
		BaseHack{}
	{
		m_hacksRun.push_back(this);
	}

	static void runAll();
protected:
	virtual void draw() = 0;
	// keep those methods to be nothing as default
	// mostly we don't need all of them
	virtual void init() override {};
	virtual void load() override {};
	virtual void reset() override {};
	virtual void shutdown() override {};
	virtual void roundRestart() override {};
private:
	inline static std::vector<RenderablePresentType*> m_hacksRun;
};
```

`hack/cheats/classes/renderableToSurface.cpp`:

```cpp
#include "renderableToSurface.hpp"

void RenderableSurfaceType::runAll()
{
	for (auto el : m_hacksRun)
		el->draw();
}
```

`hack/cheats/classes/renderableToSurface.hpp`:

```hpp
#pragma once

#include "base.hpp"

#include <vector>

class RenderableSurfaceType : protected BaseHack
{
public:
	constexpr RenderableSurfaceType()
		: BaseHack{}
	{
		m_hacksRun.push_back(this);
	}

	static void runAll();
protected:
	virtual void draw() = 0;
	// keep those methods to be nothing as default
	// mostly we don't need all of them
	virtual void init() override {};
	virtual void load() override {};
	virtual void reset() override {};
	virtual void shutdown() override {};
	virtual void roundRestart() override {};
private:
	inline static std::vector<RenderableSurfaceType*> m_hacksRun;
};
```

`hack/cheats/classes/screen2dEffects.cpp`:

```cpp
#include "screen2dEffects.hpp"

void Screen2DEffectsType::runAll()
{
	for (auto el : m_hacksRun)
		el->run();
}

```

`hack/cheats/classes/screen2dEffects.hpp`:

```hpp
#pragma once

#include "base.hpp"

#include <vector>

class Screen2DEffectsType : protected BaseHack
{
public:
	constexpr Screen2DEffectsType() :
		BaseHack{}
	{
		m_hacksRun.push_back(this);
	}

	static void runAll();
protected:
	virtual void run() = 0;
	// keep those methods to be nothing as default
	// mostly we don't need all of them
	virtual void init() override {};
	virtual void load() override {};
	virtual void reset() override {};
	virtual void shutdown() override {};
	virtual void roundRestart() override {};
private:
	inline static std::vector<Screen2DEffectsType*> m_hacksRun;
};
```

`hack/cheats/classes/viewRender.hpp`:

```hpp
#pragma once

#include "base.hpp"

#include <vector>

class CViewSetup;

class ViewRenderType : protected BaseHack
{
public:
	constexpr ViewRenderType() :
		BaseHack{}
	{
		m_hacksRun.push_back(this);
	}

	static void runAll(const CViewSetup& view);
protected:
	virtual void run(const CViewSetup& view) = 0;
	// keep those methods to be nothing as default
	// mostly we don't need all of them
	virtual void init() override {};
	virtual void load() override {};
	virtual void reset() override {};
	virtual void shutdown() override {};
	virtual void roundRestart() override {};
private:
	inline static std::vector<ViewRenderType*> m_hacksRun;
};
```

`hack/cheats/features/RCS/RCS.cpp`:

```cpp
#include "RCS.hpp"

#include "../aimbot/aimbot.hpp"

#include <SDK/CUserCmd.hpp>
#include <SDK/ICvar.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/math/Vector.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <SDK/structs/Entity.hpp>

#include <cheats/game/game.hpp>
#include <config/vars.hpp>
#include <utilities/tools/tools.hpp>

void RCS::init()
{
	m_scale = memory::interfaces::cvar->findVar(XOR("weapon_recoil_scale"));
}

void RCS::run(CUserCmd* cmd)
{
	auto cfg = g_Aimbot->getCachedConfig();

	if (!cfg.rcs)
		return;

	if (!game::isAvailable())
		return;

	auto weapon = game::localPlayer->getActiveWeapon();

	if (!weapon)
		return;

	if (weapon->isNonAimable())
		return;

	if (weapon->isSniper())
		return;

	prepare(cmd);
}

void RCS::prepare(CUserCmd* cmd)
{
	auto cfg = g_Aimbot->getCachedConfig();

	static auto oldPunch = game::localPlayer->m_aimPunchAngle() * m_scale->getFloat();
	if (cmd->m_buttons & IN_ATTACK)
	{
		auto punch = game::localPlayer->m_aimPunchAngle() * m_scale->getFloat();

		punch[Coord::X] *= cfg.rcsX;
		punch[Coord::Y] *= cfg.rcsY;

		auto toMove = cmd->m_viewangles += (oldPunch - punch);
		toMove.clamp();

		memory::interfaces::engine->setViewAngles(toMove);

		oldPunch = punch;
	}
	else
	{
		auto punch = game::localPlayer->m_aimPunchAngle() * m_scale->getFloat();
		punch[Coord::X] *= cfg.rcsX;
		punch[Coord::Y] *= cfg.rcsY;

		oldPunch = punch;
	}
}

```

`hack/cheats/features/RCS/RCS.hpp`:

```hpp
#pragma once

#include <cheats/classes/createMove.hpp>

class IConVar;

class RCS : protected CreateMoveInPredictionType
{
public:
	constexpr RCS() :
		CreateMoveInPredictionType{}
	{}

protected:
	virtual void init() override;
	virtual void run(CUserCmd* cmd) override;
	virtual void reset() override {};
	virtual void shutdown() override {};
private:
	void prepare(CUserCmd* cmd);
	IConVar* m_scale;
};

GLOBAL_FEATURE(RCS);
```

`hack/cheats/features/aimbot/aimbot.cpp`:

```cpp
#include "aimbot.hpp"

#include "../cache/cache.hpp"
#include "../backtrack/backtrack.hpp"

#include <SDK/IVEngineClient.hpp>
#include <SDK/CUserCmd.hpp>
#include <SDK/CGlobalVars.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/vars.hpp>
#include <SDK/Enums.hpp>
#include <SDK/ICvar.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/IVModelInfo.hpp>
#include <SDK/structs/Entity.hpp>
#include <SDK/math/Vector.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <config/vars.hpp>
#include <cheats/game/globals.hpp>
#include <cheats/game/game.hpp>
#include <utilities/math/math.hpp>
#include <utilities/tools/wrappers.hpp>
#include <utilities/rand.hpp>
#include <cheats/features/blacklist/blacklist.hpp>

void Aimbot::init()
{
	m_scale = memory::interfaces::cvar->findVar(XOR("weapon_recoil_scale"));
}

Vec3 Aimbot::smoothAim(CUserCmd* cmd, const Vec3& angle, Player_t* target, float cfgSmooth)
{
	if (cfgSmooth == 0.0f)
		return angle;

	//printf("%i, %i\n", cmd->m_mousedx, cmd->m_mousedy);

	const float smooth = std::clamp(cfgSmooth, 0.0f, 1.0f);
	const float skill = 0.5f;
	const float targetVel = target->m_vecVelocity().length();
	const float maxVel = target->m_flMaxspeed();
	const float velScaled = std::clamp(targetVel / maxVel, 0.0f, 1.0f);
	const float distance = target->m_vecOrigin().distTo(game::localPlayer->m_vecOrigin());
	const float distanceScaled = std::clamp(distance / 1000.0f, 0.0f, 1.0f);
	const float smoothFactor = std::min(std::lerp(smooth, 1.0f, (velScaled * 0.2f + distanceScaled * 0.1f) * skill), 1.0f);
	Vec3 delta = angle;
	Vec3 ret;
	switch (m_config.smoothMode)
	{
	case E2T(SmoothMode::LINEAR):
		ret = angle * (1.0f - smoothFactor);
		break;
	case E2T(SmoothMode::AIM_LENGTH):
		ret = delta - (delta * smoothFactor);
		break;
	case E2T(SmoothMode::AIM_CUBIC):
	{
		const float t = 1.0f - smoothFactor;
		const float cubic = t * t * (3.0f - 2.0f * t);
		ret = delta * cubic;
		break;
	}
	}
	if (m_config.curveAim)
	{
		Vec3 curved = ret + Vec3(ret[1] * m_config.curveX, ret[0] * m_config.curveY, 0.0f);
		ret = curved * smoothFactor;
	}
	return ret;
}

float Aimbot::getRandomizedSmooth(float currentSmooth)
{
	const float sineWave = std::sin(static_cast<float>(memory::interfaces::globalVars->m_tickCount));
	const float factor = sineWave * m_config.randomizationRatio;
	const float smoothness = currentSmooth + factor;
	return currentSmooth *= smoothness;
}

void Aimbot::run(CUserCmd* cmd)
{
	m_view = cmd->m_viewangles;

	auto weapon = game::localPlayer->getActiveWeapon();
	if (!weapon)
		return;

	auto weaponCfg = CfgWeapon::getWeaponByIndex(weapon->m_iItemDefinitionIndex());
	if (weaponCfg == WeaponList::WEAPON_UNKNOWN)
		return;

	auto indexCfg = E2T(weaponCfg);
	m_config = vars::aim->weapons.at(indexCfg);

	if (!m_config.enabled)
		return;

	if (!game::isAvailable())
		return;

	if (!game::localPlayer->isAlive())
		return;

	if (weapon->isNonAimable())
	{
		resetFields(); // switching to knife when clicked
		return;
	}

	if (weapon->isSniper() && !game::localPlayer->m_bIsScoped())
		return;

	const auto myEye = game::localPlayer->getEyePos();
	const auto punch = (weapon->isRifle() || weapon->isSmg()) ? game::localPlayer->getAimPunch() : Vec3{};

	if (!isClicked(cmd))
	{
		resetFields();
		return;
	}

	if (!getBestTarget(cmd, weapon, myEye, punch))
		return;

	if (m_targets.front().m_pos.isZero())
		return;

	// everything sorted by fov. Blacklists go on top + they ofc are sorted
	// we always want front() as current target
	std::ranges::sort(m_targets,
		[this](const AimbotTarget_t& lhs, const AimbotTarget_t& rhs) // std::tie won't work in that case
		{
			if (g_Blacklist->isBlacklisted(lhs.m_player) ^ g_Blacklist->isBlacklisted(rhs.m_player))
			return g_Blacklist->isBlacklisted(lhs.m_player);

	return lhs.m_fov < rhs.m_fov;
		});

	auto [player, fov, index, bestHitbox, bestpos] = m_targets.front();

	if (m_config.aimBacktrack)
	{
		int boneID = 8; // HEAD start
		if (auto modelStudio = memory::interfaces::modelInfo->getStudioModel(player->getModel()); modelStudio != nullptr)
		{
			if (auto hitbox = modelStudio->getHitboxSet(0)->getHitbox(bestHitbox); hitbox != nullptr)
			{
				boneID = hitbox->m_bone;
			}
		}
		auto record = g_Backtrack->getAllRecords().at(player->getIndex());
		bestpos = record.at(record.size() / 2).m_matrix[boneID].origin(); // middle, u can play with this as u want to
	}

	auto angle = math::calcAngleRelative(myEye, bestpos, Vec3{ m_view + punch });
	angle.clamp();

	angle = smoothAim(cmd, angle, player, m_config.smooth);

	cmd->m_viewangles += angle;
	memory::interfaces::engine->setViewAngles(cmd->m_viewangles);

}

bool Aimbot::getBestTarget(CUserCmd* cmd, Weapon_t* wpn, const Vec3& eye, const Vec3& punch)
{
	/*bool isSame = m_temp == m_bestEnt;
	console.print("{}\n", isSame);*/

	static float delay = 0.0f;
	// will not work for the special case:
	// delay did not hit timer limit but we switched manually to new target -> should reset the timer. I couldn't detect it without false positives :(
	// epic solution - stop shooting and start again
	if (m_config.aimDelay)
	{
		/*if (m_bestEnt && m_bestEnt->isAlive())
		{
			m_temp = m_bestEnt;
		}*/
		if (m_targets.size() && !m_delay && !m_targets.front().m_player->isAlive()) // if ent is found and dead, then set field to delay and wait curr time + cfgtime
		{
			m_delay = true;
			delay = memory::interfaces::globalVars->m_curtime + (m_config.aimDelayVal / 1000.0f);
		}
		if (m_delay) // if the delay is hit, check time, so when ent died
		{
			if (delay <= memory::interfaces::globalVars->m_curtime)
				m_delay = false;
			else // need reset fields here and stop the method
			{
				m_targets.clear();
				return false;
			}
		}
	}

	m_targets.clear();

	auto hitboxes = getHitboxes();

	if (game::localPlayer->m_flFlashDuration() > 0.0f)
	{
		if (game::localPlayer->m_flFlashBangTime() >= m_config.flashLimit)
			return false;
	}

	for (auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::PLAYER))
	{
		auto ent = reinterpret_cast<Player_t*>(entity);

		if (!ent)
			continue;

		if (ent == game::localPlayer)
			continue;

		if (!ent->isAlive() || !game::localPlayer->isAlive())
			continue;

		if (!ent->isOtherTeam(game::localPlayer()))
			continue;

		if (ent->isDormant())
			continue;

		if (ent->m_bGunGameImmunity())
			continue;

		for (const auto pos : hitboxes)
		{
			Vec3 hitPos = ent->getHitboxPos(pos);

			auto angles = cmd->m_viewangles + punch;
			angles.clamp();

			if (!game::localPlayer->isPossibleToSee(ent, hitPos))
				continue;

			if (m_config.smokeCheck && game::localPlayer->isViewInSmoke(hitPos))
				continue;

			auto fov = m_config.methodAim == E2T(AimbotMethod::CROSSHAIR)
				? math::calcFov(eye, hitPos, angles)
				: math::calcFovReal(eye, hitPos, angles);

			if (fov <= m_config.fov)
				m_targets.emplace_back(AimbotTarget_t{ ent, fov, idx, pos, hitPos });
		}
	}

	return m_targets.size();
}

Player_t* Aimbot::getTargetted() const
{
	return m_bestEnt;
}

Vec3 Aimbot::getCachedView() const
{
	return m_view;
}

Vec3 Aimbot::getBestHibox() const
{
	return m_bestHitpos;
}

CfgWeapon Aimbot::getCachedConfig() const
{
	return m_config;
}

void Aimbot::resetFields()
{
	m_targets.clear();
	m_delay = false;
}

bool Aimbot::isClicked(CUserCmd* cmd)
{
	if (vars::aim->useKey)
	{
		if (vars::keys->aimbot.isEnabled())
			return true;
		else
			return false;
	}
	else
		return cmd->m_buttons & IN_ATTACK;
}

std::vector<size_t> Aimbot::getHitboxes()
{
	std::vector<size_t> hitboxes;

	switch (m_config.aimSelection)
	{
	case E2T(AimbotHitboxes::NEAREST):
	{
		for (size_t i = HITBOX_HEAD; i < HITBOX_MAX; i++)
			hitboxes.push_back(i);

		break;
	}
	case E2T(AimbotHitboxes::HEAD):
		hitboxes = { HITBOX_HEAD };
		break;
	case E2T(AimbotHitboxes::CHEST):
		hitboxes = { HITBOX_LOWER_CHEST };
		break;
	default:
		break;
	}

	return hitboxes;
}

```

`hack/cheats/features/aimbot/aimbot.hpp`:

```hpp
#pragma once

#include <cheats/classes/createMove.hpp>
#include <SDK/math/Vector.hpp>
#include <config/cfgWeapon.hpp>

#include <vector>

class CUserCmd;
class Player_t;
class Weapon_t;
class IConVar;

struct AimbotTarget_t
{
	Player_t* m_player;
	float m_fov;
	size_t m_index;
	size_t m_bestHitboxID;
	Vec3 m_pos;
};

class Aimbot : protected CreateMoveInPredictionType
{
public:
	constexpr Aimbot() :
		CreateMoveInPredictionType{}
	{}

	virtual void init() override;
	virtual void run(CUserCmd* cmd) override;

	Player_t* getTargetted() const;
	Vec3 getCachedView() const;
	Vec3 getBestHibox() const;
	CfgWeapon getCachedConfig() const;
private:
	void resetFields();
	[[nodiscard]] Vec3 smoothAim(CUserCmd* cmd, const Vec3& angle, Player_t* target, float cfgSmooth);
	[[nodiscard]] bool isClicked(CUserCmd* cmd);
	[[nodiscard]] bool getBestTarget(CUserCmd* cmd, Weapon_t* wpn, const Vec3& eye, const Vec3& punch);
	[[nodiscard]] float getRandomizedSmooth(float currentSmooth);

	[[nodiscard]] std::vector<size_t> getHitboxes();

	Player_t* m_bestEnt;
	Vec3 m_bestHitpos;
	bool m_delay;
	float m_delayTime;
	Vec3 m_view;
	int m_bestId;
	CfgWeapon m_config;
	int m_prevMouseDeltaX;
	int m_prevMouseDeltaY;

	IConVar* m_scale = nullptr;

	std::vector<AimbotTarget_t> m_targets;
};

GLOBAL_FEATURE(Aimbot);

```

`hack/cheats/features/aimbot/aimbotDraw.cpp`:

```cpp
#include "aimbotDraw.hpp"

#include <SDK/IWeapon.hpp>
#include <SDK/IEngineTrace.hpp>
#include <SDK/structs/Entity.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <utilities/math/math.hpp>
#include <render/render.hpp>
#include <utilities/tools/wrappers.hpp>

#include "aimbot.hpp"

void AimbotDraw::draw()
{
	drawFov();
	drawBestPoint();
}

void AimbotDraw::drawFov()
{
	auto cfg = g_Aimbot->getCachedConfig();

	if (!vars::aimPaint->enabledFov)
		return;

	if (!cfg.enabled)
		return;

	if (!cfg.fov)
		return;

	if (!game::isAvailable())
		return;

	const auto weapon = game::localPlayer->getActiveWeapon();

	if (!weapon)
		return;

	if (weapon->isNonAimable())
		return;

	float radius = 0.0f;

	switch (cfg.methodAim)
	{
	case E2T(AimbotMethod::CROSSHAIR):
	{
		radius = std::tan(math::DEG2RAD(cfg.fov) / 2.0f) / std::tan(math::DEG2RAD(globals::FOV) / 2.0f) * globals::screenX;

		break;
	}
	case E2T(AimbotMethod::DYNAMIC): // not very very accurate
	{
		Trace_t trace;
		TraceFilter filter{ game::localPlayer() };
		const auto myEye = game::localPlayer->getEyePos();
		constexpr float range = 8192.0f; // because we need max range possible
		const auto view = g_Aimbot->getCachedView();
		const auto end = myEye + (math::angleVec(view) * range);
		memory::interfaces::trace->traceRay({ myEye, end }, MASK_SHOT, &filter, &trace);
		// 3d end
		const auto destination = trace.m_end;

		// turn for visualization
		auto forward = math::angleVec(Vec3{ view[0], view[1] + 90.f, 0.f });
		// dist in calcFovReal
		forward *= cfg.fov * 10.0f;
		// final vector where we aim
		auto aimingView = destination + forward;

		if (ImVec2 v; imRender.worldToScreen(aimingView, v))
			radius = std::abs(globals::screenX / 2.0f - v.x);

		break;
	}
	}

	imRender.drawCircle(globals::screenX / 2.0f, globals::screenY / 2.0f, radius, 32, vars::aimPaint->colorFov());
}

void AimbotDraw::drawBestPoint()
{
	if (!vars::aimPaint->enabledPoint)
		return;

	if (!game::isAvailable())
		return;

	const auto hitbox = g_Aimbot->getBestHibox();
	if (hitbox.isZero())
		return;

	if (ImVec2 p; imRender.worldToScreen(hitbox, p))
		imRender.drawCircleFilled(p.x, p.y, 5, 12, vars::aimPaint->colorPoint());
}

```

`hack/cheats/features/aimbot/aimbotDraw.hpp`:

```hpp
#pragma once

#include <cheats/classes/renderableToSurface.hpp>

class AimbotDraw : protected RenderableSurfaceType
{
public:
	constexpr AimbotDraw() :
		RenderableSurfaceType{}
	{}

	virtual void draw() override;
private:
	void drawFov();
	void drawBestPoint();
};

GLOBAL_FEATURE(AimbotDraw);
```

`hack/cheats/features/backtrack/backteack.cpp`:

```cpp
#include "backtrack.hpp"

#include "../cache/cache.hpp"

#include <SDK/IVEngineClient.hpp>
#include <SDK/CUserCmd.hpp>
#include <SDK/CGlobalVars.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/vars.hpp>
#include <SDK/Enums.hpp>
#include <SDK/structs/Entity.hpp>
#include <SDK/ICvar.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>
#include <config/vars.hpp>
#include <utilities/math/math.hpp>
#include <utilities/tools/tools.hpp>

void Backtrack::init()
{
	cvars.updateRate = memory::interfaces::cvar->findVar(XOR("cl_updaterate"));
	cvars.maxUpdateRate = memory::interfaces::cvar->findVar(XOR("sv_maxupdaterate"));

	cvarsRatios.interp = memory::interfaces::cvar->findVar(XOR("cl_interp"))->getFloat();
	cvarsRatios.interpRatio = memory::interfaces::cvar->findVar(XOR("cl_interp_ratio"))->getFloat();
	cvarsRatios.minInterpRatio = memory::interfaces::cvar->findVar(XOR("sv_client_min_interp_ratio"))->getFloat();
	cvarsRatios.maxInterpRatio = memory::interfaces::cvar->findVar(XOR("sv_client_max_interp_ratio"))->getFloat();
	cvarsRatios.maxUnlag = memory::interfaces::cvar->findVar(XOR("sv_maxunlag"))->getFloat();
};

float Backtrack::getLerp() const
{
	float updateRate = cvars.maxUpdateRate ? cvars.maxUpdateRate->getFloat() : cvars.updateRate->getFloat();
	float ratio = cvarsRatios.interpRatio == 0.0f ? 1.0f : cvarsRatios.interpRatio;

	ratio = std::clamp(ratio, cvarsRatios.minInterpRatio, cvarsRatios.maxInterpRatio);
	return std::max(cvarsRatios.interp, (ratio / updateRate));
}

bool Backtrack::isValid(float simtime) const
{
	auto network = memory::interfaces::engine->getNameNetChannel();
	if (!network)
		return false;

	if (auto time = static_cast<int>(game::serverTime() - cvarsRatios.maxUnlag); simtime < time)
	{
		//printf("simtime precheck, sim %f lag sim %f\n", simtime, game::serverTime() - cvarsRatios.maxUnlag);
		return false;
	}

	auto delta = std::clamp(network->getLatency(FLOW_OUTGOING) + network->getLatency(FLOW_INCOMING) + getLerp(),
		0.0f, cvarsRatios.maxUnlag) - (game::serverTime() - simtime);
	return std::abs(delta) <= 0.2f;
}

float Backtrack::extraTicks() const
{
	if (!vars::misc->fakeLatency->enabled)
		return 0.0f;

	return vars::misc->fakeLatency->amount / 1000.0f;
}

void Backtrack::run(CUserCmd* cmd)
{
	if (!vars::backtrack->enabled)
		return;

	if (!game::localPlayer)
		return;

	if (!game::localPlayer->isAlive())
		return;

	if (!(cmd->m_buttons & IN_ATTACK))
		return;

	float bestFov = 180.0f;
	Player_t* bestPlayer = nullptr;
	int bestPlayerIdx = -1;
	int bestRecordIdx = -1;
	Vec3 bestPos = {};

	const auto aimPunch = game::localPlayer->getAimPunch();
	const auto myEye = game::localPlayer->getEyePos();

	for (auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::PLAYER))
	{
		auto ent = reinterpret_cast<Player_t*>(entity);

		if (ent == game::localPlayer)
			continue;

		if (!ent->isAlive())
			continue;

		if (ent->isDormant())
			continue;

		if (!ent->isOtherTeam(game::localPlayer()))
			continue;

		const auto& pos = ent->absOrigin();

		const auto fov = math::calcFovReal(myEye, pos, cmd->m_viewangles + aimPunch);
		if (fov < bestFov)
		{
			bestFov = fov;
			bestPlayer = ent;
			bestPlayerIdx = idx;
			bestPos = pos;
		}
	}

	if (bestPlayer)
	{
		if (game::localPlayer->m_flFlashDuration() > 0.0f)
		{
			if (game::localPlayer->m_flFlashBangTime() >= vars::backtrack->flashLimit)
				return;
		}

		if (vars::backtrack->smoke && game::localPlayer->isViewInSmoke(bestPos))
			return;

		bestFov = 180.0f;

		for (size_t i = 0; const auto & el : m_records.at(bestPlayerIdx))
		{
			if (!isValid(el.m_simtime))
				continue;

			const auto fov = math::calcFovReal(myEye, el.m_head, cmd->m_viewangles + aimPunch);

			if (fov < bestFov)
			{
				bestFov = fov;
				bestRecordIdx = i;
			}

			i++;
		}
	}

	if (bestRecordIdx != -1)
	{
		const auto& record = m_records.at(bestPlayerIdx).at(bestRecordIdx);

		auto simTimeCorrected = record.m_simtime;
		if (auto deltaLerp = getLerp() - memory::interfaces::globalVars->m_intervalPerTick; deltaLerp > 0.0f)
			simTimeCorrected += memory::interfaces::globalVars->m_intervalPerTick - deltaLerp;

		cmd->m_tickcount = game::timeToTicks(simTimeCorrected + getLerp());
	}
}

void BackTrackUpdater::run(int frame)
{
	m_correctTime = vars::backtrack->time / 1000.0f + g_Backtrack->extraTicks();

	if (frame != FRAME_RENDER_START)
		return;

	auto& records = g_Backtrack->getAllRecords();

	if (!game::localPlayer || !vars::backtrack->enabled || !game::localPlayer->isAlive())
	{
		for (auto& el : records)
			el.clear();
		return;
	}

	constexpr auto isGoodEnt = [](Player_t* ent)
	{
		if (ent == game::localPlayer)
			return false;

		if (ent->isDormant())
			return false;

		if (!ent->isAlive())
			return false;

		if (!ent->isOtherTeam(game::localPlayer()))
			return false;

		return true;
	};

	for (auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::PLAYER))
	{
		auto ent = reinterpret_cast<Player_t*>(entity);

		auto i = idx;

		if (!isGoodEnt(ent))
		{
			records.at(i).clear();
			continue;
		}

		if (records.at(i).size() && (records.at(i).front().m_simtime == ent->m_flSimulationTime()))
			continue;

		if (!g_Backtrack->isValid(ent->m_flSimulationTime() /*m_correct.at(i).m_correctSimtime*/))
			continue;

		Backtrack::StoredRecord record = {};
		record.m_origin = ent->absOrigin();
		record.m_simtime = ent->m_flSimulationTime();
		if (!ent->setupBonesShort(record.m_matrix.data(), ent->m_CachedBoneData().m_size,
			BONE_USED_MASK, memory::interfaces::globalVars->m_curtime))
			continue;
		record.m_head = record.m_matrix[8].origin();

		records.at(i).push_front(record);

		while (records.at(i).size() > 3 && records.at(i).size() > static_cast<size_t>(game::timeToTicks(m_correctTime)))
			records.at(i).pop_back();

		auto invalid = std::find_if(std::cbegin(records.at(i)), std::cend(records.at(i)), [this](const Backtrack::StoredRecord& rec)
			{
				return !g_Backtrack->isValid(rec.m_simtime);
			});

		if (invalid != std::cend(records.at(i)))
			records.at(i).erase(invalid, std::cend(records.at(i)));

		i++;
	}
}

```

`hack/cheats/features/backtrack/backtrack.hpp`:

```hpp
#pragma once

#include <cheats/classes/frameStage.hpp>
#include <cheats/classes/createMove.hpp>
#include <SDK/vars.hpp>
#include <SDK/math/Vector.hpp>
#include <SDK/math/matrix.hpp>

#include <deque>
#include <array>

class CUserCmd;
class INetChannel;
class IConVar;
class BackTrackUpdater;

class Backtrack : protected CreateMoveInPredictionType
{
public:
	Backtrack() :
		CreateMoveInPredictionType{}
	{}

	[[nodiscard]] bool isValid(float simtime) const;
protected:
	virtual void run(CUserCmd* cmd);
	virtual void init();
private:
	[[nodiscard]] float getLerp() const;
	[[nodiscard]] float extraTicks() const;

	struct StoredRecord
	{
		float m_simtime = 0.0f;
		Vec3 m_head = {};
		// use origin to set abs or for whatever need
		Vec3 m_origin = {};
		std::array<Matrix3x4, BONE_USED_BY_HITBOX> m_matrix;
	};

	struct convars
	{
		IConVar* updateRate = nullptr;
		IConVar* maxUpdateRate = nullptr;
	} cvars;

	struct convarRatios
	{
		float interp;
		float interpRatio;
		float minInterpRatio;
		float maxInterpRatio;
		float maxUnlag;
	} cvarsRatios;
	
	std::array<std::deque<StoredRecord>, 65> m_records;
public:
	[[nodiscard]] auto& getAllRecords() { return m_records; }

	friend BackTrackUpdater;
};

GLOBAL_FEATURE(Backtrack);

class BackTrackUpdater : protected FrameStageType
{
public:
	constexpr BackTrackUpdater() :
		FrameStageType{}
	{}

protected:
	virtual void run(int frame) override;
private:
	float m_correctTime;
};

GLOBAL_FEATURE(BackTrackUpdater);

```

`hack/cheats/features/blacklist/blacklist.cpp`:

```cpp
#include "blacklist.hpp"

#include <config/config.hpp>
#include <config/jsonExtended.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/console/console.hpp>

#include <SDK/IVEngineClient.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <SDK/structs/Entity.hpp>

using json = nlohmann::json;

void from_json(const json& j, Blacklist::BlacklistedPlayer& val)
{
	from_json(j, "Guid", val.m_guid);
	from_json(j, "Bot", val.m_bot);
	from_json(j, "Name", val.m_playerName);
}

void to_json(json& j, const Blacklist::BlacklistedPlayer& val)
{
	j["Guid"] = val.m_guid;
	j["Bot"] = val.m_bot;
	j["Name"] = val.m_playerName;
}

void Blacklist::init()
{
	m_folderName = XOR("blacklist");
	m_saveDir = config.getHackPath() / config.getExtraLoadPath() / m_folderName / getPathForConfig();

	loadCfg();
}

void Blacklist::reset()
{
	if (m_allGuids.empty())
		return;

	m_allGuids.erase(std::remove_if(m_allGuids.begin(), m_allGuids.end(), [this](const BlacklistedPlayer& player)
		{
			if (player.m_bot)
			{
				m_json.erase(m_json.find(getCorrectKey(player)));
				return true;
			}

	return false;
		})
	);
}

bool Blacklist::loadCfg()
{
	if (auto path = config.getHackPath() / config.getExtraLoadPath() / m_folderName; !std::filesystem::exists(path))
		std::filesystem::create_directories(path);

	std::ifstream input{ m_saveDir };
	if (!input)
		return false;

	if (!std::filesystem::is_empty(m_saveDir))
	{
		m_json = json::parse(input);

		for (const auto& [key, value] : m_json.items())
		{
			BlacklistedPlayer player;
			from_json(value, player);

			m_allGuids.push_back(player);
		}
	}

	return true;
}

bool Blacklist::saveCfg()
{
	std::ofstream out{ m_saveDir };
	if (!out)
		return false;

	json j;
	for (const auto& el : m_allGuids)
		to_json(j[getCorrectKey(el)], el);

	if (!j.empty())
		m_json.update(j);

	out << std::setw(4) << m_json;

	return true;
}

// for performance
void Blacklist::shutdown()
{
	if (!saveCfg())
		LOG_ERR(XOR("Saving config has failed"));
}

bool Blacklist::isBlacklisted(Player_t* ent) const
{
	const auto guid = getGuid(ent);
	auto itr = std::ranges::find_if(m_allGuids, [guid](const BlacklistedPlayer& player)
		{
			return player == guid;
		}
	);

	return itr != m_allGuids.end();
}

void Blacklist::add(Player_t* ent)
{
	const auto guid = getGuid(ent);
	if (!isBlacklisted(ent))
	{
		m_allGuids.push_back(guid);
		json j;
		to_json(j[getCorrectKey(guid)], guid);
		m_json.update(j);
	}
	else
		LOG_WARN(XOR("Player already blacklisted! guid: {} isBot {}"), guid.m_guid, guid.m_bot);
}

void Blacklist::remove(Player_t* ent)
{
	const auto guid = getGuid(ent);
	m_allGuids.erase(std::remove_if(m_allGuids.begin(), m_allGuids.end(), [this, guid](const BlacklistedPlayer& player)
		{
			if (player == guid)
			{
				m_json.erase(m_json.find(getCorrectKey(player)));
				return true;
			}

	return false;
		})
	);
}

std::filesystem::path Blacklist::getPathForConfig() const
{
	std::filesystem::path path(m_folderName);
	if (path.extension() != XOR(".json"))
		path.replace_extension(XOR(".json"));

	return path;
}

std::string Blacklist::getCorrectKey(const BlacklistedPlayer& player) const
{
	auto key = player.m_bot
		? FORMAT(XOR("{} BOT"), player.m_guid)
		: FORMAT(XOR("{}"), player.m_guid);

	return key;
}

Blacklist::BlacklistedPlayer Blacklist::getGuid(Player_t* ent) const
{
	PlayerInfo_t info;
	memory::interfaces::engine->getPlayerInfo(ent->getIndex(), &info);
	auto guid = info.m_fakePlayer
		? BlacklistedPlayer{ .m_guid = static_cast<uint64_t>(info.m_userID), .m_bot = true, .m_playerName = std::string{ info.m_name } }
	: BlacklistedPlayer{ .m_guid = info.m_steamID64, .m_bot = false, .m_playerName = std::string{ info.m_name } };

	return guid;
}
```

`hack/cheats/features/blacklist/blacklist.hpp`:

```hpp
#pragma once

#include <cheats/classes/onlyInit.hpp>

#include <nlohmann/json.hpp>

class Player_t;
struct PlayerInfo_t;

class Blacklist : protected OnlyInitType
{
public:
	Blacklist() :
		OnlyInitType{}
	{}

	struct BlacklistedPlayer
	{
		[[nodiscard]] constexpr bool operator==(const BlacklistedPlayer& rhs) const
		{
			return this->m_guid == rhs.m_guid && this->m_bot == rhs.m_bot;
		}

		uint64_t m_guid;
		bool m_bot;
		std::string m_playerName;
	};

	void add(Player_t* ent);
	void remove(Player_t* ent);
	bool isBlacklisted(Player_t* ent) const;
	BlacklistedPlayer getGuid(Player_t* ent) const;
protected:
	virtual void init() override;
	virtual void shutdown() override;
	virtual void reset() override;
private:
	bool loadCfg();
	bool saveCfg();
	std::filesystem::path getPathForConfig() const;
	std::string getCorrectKey(const BlacklistedPlayer& player) const;

	std::vector<BlacklistedPlayer> m_allGuids;
	std::string_view m_folderName;
	std::filesystem::path m_saveDir;
	nlohmann::json m_json;
};

GLOBAL_FEATURE(Blacklist);
```

`hack/cheats/features/cache/cache.cpp`:

```cpp
#include "cache.hpp"

#include <SDK/IVEngineClient.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/Enums.hpp>
#include <SDK/ClientClass.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <SDK/structs/Entity.hpp>
#include <cheats/game/game.hpp>

#include <ranges>

//const auto predictor = [](const EntityCache::HolderData& lhs, const EntityCache::HolderData& rhs)
//{
//	// do comparison by length to our location
//	const auto lhsToLocal = lhs.ent->absOrigin() - game::localPlayer->absOrigin();
//	const auto rhsToLocal = rhs.ent->absOrigin() - game::localPlayer->absOrigin();
//	return lhsToLocal.length() > rhsToLocal.length();
//};

void EntityCache::init()
{
	const int maxIdx = memory::interfaces::entList->getHighestIndex();
	if (maxIdx <= 1)
		return;

	HolderData data{};
	for (auto i : std::views::iota(1, maxIdx))
	{
		auto entity = reinterpret_cast<Entity_t*>(memory::interfaces::entList->getClientEntity(i));
		if (!entity)
			continue;

		const auto cl = entity->clientClass();
		if (!cl)
			continue;

		size_t index = i;
		size_t classID = cl->m_classID;

		data = HolderData{ .ent = entity, .idx = index, .classID = classID };
		fill(data);
	}
}

void EntityCache::add(Entity_t* ent)
{
	if (!checkRepeatable(ent))
		return;

	const auto possibleIndexes = getIndexes(ent);
	if (!possibleIndexes.has_value())
		return;

	auto [index, classID] = possibleIndexes.value();

	const auto data = HolderData{ .ent = ent, .idx = index, .classID = classID };
	fill(data);
}

std::optional<std::pair<size_t, size_t>> EntityCache::getIndexes(Entity_t* ent)
{
	int i = ent->getIndex();
	if (i <= 1)
		return std::nullopt;

	const auto cl = ent->clientClass();
	if (!cl)
		return std::nullopt;

	size_t index = i;
	size_t classID = cl->m_classID;

	return std::make_pair(index, classID);
}

bool EntityCache::checkRepeatable(Entity_t* ent)
{
	if (!ent)
		return false;

	for (auto [cacheType, ents] : m_entCache)
	{
		if (auto itr = std::ranges::find_if(ents,
			[ent](const HolderData& el)
			{
				return el.ent == ent;
			}
		); itr != ents.cend()) // do not add the same memory place
		{
			return false;
		}
	}

	return true;
}

void EntityCache::fill(const HolderData& data)
{
	if (auto id = data.classID; id >= CWeaponAug && id <= CWeaponXM1014
		|| id == CAK47 || id == CDEagle)
	{
		m_entCache[EntCacheType::WEAPON].emplace_back(data);
	}

	switch (data.classID)
	{
	case CCSPlayer:
		m_entCache[EntCacheType::PLAYER].emplace_back(data);
		break;
	case CBaseCSGrenadeProjectile:
	case CDecoyProjectile:
	case CMolotovProjectile:
	case CSmokeGrenadeProjectile:
	case CInferno:
		m_entCache[EntCacheType::GRENADE_PROJECTILES].emplace_back(data);
		break;
	case CFogController:
	case CEnvTonemapController:
	case CPostProcessController:
		m_entCache[EntCacheType::CONTROLLERS].emplace_back(data);
		break;
	case CPlantedC4:
		m_entCache[EntCacheType::WORLD_ENTS].emplace_back(data);
		break;
	default:
		break;
	}
}

void EntityCache::erase(Entity_t* ent)
{
	for (auto& [cacheType, ents] : m_entCache)
	{
		if (auto itr = std::ranges::find_if(ents,
			[ent](const auto& el)
			{
				return el.ent == ent;
			}
		); itr != ents.cend())
		{
			ents.erase(itr);
		}
	}
}

void EntityCache::clear()
{
	for ([[maybe_unused]] auto& [type, vec] : m_entCache)
		vec.clear();
}

#include <gamememory/memory.hpp>

void CacheFields::update()
{
	const auto hud = Memory::Address<CCSGO_HudRadar*>{ game::findHudElement("CCSGO_HudRadar") };
	if (!hud())
		return;

	const auto radar = hud.sub(0x14).cast<CSRadar*>()();

	for (int i = 1; i <= hud->m_sizeOfPlayers + 1; i++)
	{
		const auto& player = radar->m_players[i];

		//player.write();

		if (const auto idx = player.m_index; !idx)
			continue;
		else
			m_players.at(player.m_index) = player;
	}
}
```

`hack/cheats/features/cache/cache.hpp`:

```hpp
#pragma once

#include <vector>
#include <unordered_map>
#include <utility>
#include <optional>

class Entity_t;
struct RadarEntity;

enum class EntCacheType // add more if needed, each group should contain many idx's, player is the exception
{
	PLAYER,
	GRENADE_PROJECTILES,
	CONTROLLERS, // fog, tone, ambient...
	WORLD_ENTS, // c4 and such...
	WEAPON,
};

class EntityCache final
{
public:
	static void add(Entity_t* ent);
	static void erase(Entity_t* ent);
	static void clear();
	// we need to call this once
	// manual init is a thing due to unload during the round
	static void init();

	struct HolderData
	{
		Entity_t* ent;
		size_t idx;
		size_t classID;
	};
private:
	static void fill(const HolderData& data);
	static bool checkRepeatable(Entity_t* ent);
	static std::optional<std::pair<size_t, size_t>> getIndexes(Entity_t* ent);
public:
	inline static auto getCache(const EntCacheType& type)
	{
		return m_entCache[type];
	}
private:
	inline static std::unordered_map<EntCacheType, std::vector<HolderData>> m_entCache;
};

#include <SDK/CCSGO_HudRadar.hpp>

// for playerlist for better access to dormant fields
class CacheFields final
{
public:
	static void update();
	inline static auto getCachedFields()
	{
		return m_players;
	}
private:
	inline static std::array<RadarEntity, 65> m_players;
};
```

`hack/cheats/features/callbacks/callbacks.cpp`:

```cpp
#include "callbacks.hpp"

#include <SDK/CEffectData.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <utilities/console/console.hpp>
#include <gamememory/memory.hpp>

#include <ranges>

void Callbacks::addCallBack(const clbStruct& callb)
{
	auto itr = std::ranges::find_if(m_callbacks, [name = callb.m_name](const clbStruct& el)
		{
			return el.m_name == name;
		});

	if (itr != m_callbacks.cend())
		LOG_WARN(XOR("{} already exists! skipping..."), callb.m_name);
	else
		m_callbacks.push_back(callb);
}

// custom1
void example(const CEffectData& data)
{
	auto call = g_Callbacks->getCallbackByMemory(&example);
	call(data);
}

// custom2 - fail
void example2(const CEffectData& data)
{
	auto call = g_Callbacks->getCallbackByMemory(&example2);
	call(data);
}

void Callbacks::init()
{
	this->addCallBack({ XOR("Impact"), &example, nullptr });
	this->addCallBack({ XOR("Impact"), &example2, nullptr });

	m_head = memory::callbacksHead();

	for (auto head = m_head; head; head = head->m_next)
	{
		for (auto& el : m_callbacks)
		{
			// check by names on init, somehow we gotta point to correct name we passed
			if (std::string_view name = head->m_effectName; name == el.m_name)
			{
				el.m_callback = head->m_function; // own now the original function
				head->m_function = el.m_function; // point our edited function

				LOG_INFO(XOR("custom function inited, name: {} at addr {:#0x}"),
					name, reinterpret_cast<uintptr_t>(el.m_function));
			}
		}
	}
}

void Callbacks::shutdown()
{
	auto _head = m_head;
	for (auto head = _head; head; head = head->m_next)
	{
		for (auto& el : m_callbacks)
		{
			if (el.m_function == head->m_function) // check by address
				head->m_function = el.m_callback; // do not point to custom funcs anymore
		}
	}
}

clientEffectCallback Callbacks::getCallbackByMemory(/*const */clientEffectCallback/*&*/ callb)
{
	for (const auto& el : m_callbacks)
	{
		if (el.m_function == callb)
			return el.m_callback;
	}

	return nullptr;
}

```

`hack/cheats/features/callbacks/callbacks.hpp`:

```hpp
#pragma once

#include <cheats/classes/onlyInit.hpp>
#include <SDK/CClientEffectRegistration.hpp>

#include <vector>
#include <string>

class Callbacks : protected OnlyInitType
{
public:
	constexpr Callbacks() :
		OnlyInitType{}
	{}

	clientEffectCallback getCallbackByMemory(/*const */clientEffectCallback/*&*/ callb);
protected:
	virtual void init() override;
	virtual void shutdown() override;
private:
	struct clbStruct
	{
		std::string m_name; // effect's name
		clientEffectCallback m_function = nullptr; // init this on add as custom func
		clientEffectCallback m_callback = nullptr; // will be later inited
	};
	// Example of using it shown in cpp
	void addCallBack(const clbStruct& callb);

	std::vector<clbStruct> m_callbacks;
	CClientEffectRegistration* m_head;
};

GLOBAL_FEATURE(Callbacks);
```

`hack/cheats/features/discord/discord.cpp`:

```cpp
#include "discord.hpp"

#include <discord_register.h>
#include <discord_rpc.h>
#include <SDK/IVEngineClient.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <SDK/CGlobalVars.hpp>
#include <config/vars.hpp>
#include <cheats/game/game.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>

#include <cstring>
#include <chrono>
#include <unordered_map>

void DiscordPresence::init()
{
	Discord_Initialize(XOR("990623614527213578"), NULL, 1, XOR("730")); // GetAppID -> 730
}

static std::pair<std::string, std::string> getImage(const std::string& map)
{
#define AM(f, s) { XOR(f), XOR(s) }
	static std::unordered_map<std::string, std::string> mapNames = // my images under this app I have added
	{
		AM("de_dust2", "dust2"),
		AM("de_mirage", "mirage"),
		AM("de_inferno", "inferno"),
		AM("de_vertigo", "vertigo"),
		AM("de_cobble", "cobble"),
		AM("de_cache", "cache"),
		AM("de_iris", "iris"),
		AM("de_ancient", "ancient"),
		AM("de_train", "train"),
		AM("de_overpass", "overpass"),
		AM("de_nuke", "nuke"),
		AM("de_canals", "canals"),
		AM("de_climb", "climb"),
		AM("de_agency", "agency"),
		AM("cs_militia", "milita"),
		AM("de_office", "office"),
		AM("de_italy", "italy"),
		AM("de_assault", "assault"),
	};
#undef AM

	if (auto ok = mapNames.find(map); ok == mapNames.end())
		return std::make_pair(XOR("unknown"), XOR("unknown"));
	else
		return std::make_pair(ok->first, ok->second);
}

void DiscordPresence::run()
{
	if (!vars::misc->discord->enabled)
		return;

	DiscordRichPresence pres;
	std::memset(&pres, 0, sizeof(pres));

	static std::string state;

	static std::pair<std::string, std::string> image;

	if (!memory::interfaces::engine->isInGame())
	{
		state = XOR("In menu");
		image = getImage("");
	}
	else if (game::isAvailable())
	{
		auto map = memory::interfaces::engine->getLevelName();

		state = FORMAT(XOR("On map: {}"), map);
		image = getImage(map);
	}

	pres.state = state.c_str();

	static std::string details;
	if (game::isAvailable())
	{
		if (auto wpn = game::localPlayer->getActiveWeapon(); wpn)
		{
			std::string_view pos = game::localPlayer->m_szLastPlaceName();
			if (pos.empty())
				pos = XOR("null");
			details = FORMAT(XOR("Weapon: {} Pos: {}"), wpn->getWpnName(), pos);
		}
	}
	else
		details = XOR("Unknown details");

	pres.details = details.c_str();
	const static auto epoch = std::chrono::duration_cast<std::chrono::seconds>(std::chrono::system_clock::now().time_since_epoch()).count();
	pres.startTimestamp = epoch;

	pres.largeImageKey = image.second.c_str();
	pres.largeImageText = image.first.c_str();

	Discord_UpdatePresence(&pres);
}

void DiscordPresence::shutdown()
{
	Discord_ClearPresence();
	Discord_Shutdown();
}
```

`hack/cheats/features/discord/discord.hpp`:

```hpp
#pragma once

class DiscordPresence final
{
public:
	void init();
	void run();
	void shutdown();
};
```

`hack/cheats/features/events/events.cpp`:

```cpp
#include "events.hpp"

#include <SDK/interfaces/interfaces.hpp>
#include <cheats/game/globals.hpp>

void EventCallback::addToCallback(const std::string_view eventName, const std::function<void(IGameEvent*)>& callback)
{
	if (auto itr = m_map.find(eventName); itr != m_map.end())
	{
		// if found, then only push to vector with functions
		itr->second.push_back(callback);
	}
	else // create new
	{
		memory::interfaces::eventManager->addListener(this, eventName.data());
		m_map.emplace(std::make_pair
		(
			eventName,
			std::vector<std::function<void(IGameEvent*)>>{ callback }
		));
	}
}

void EventCallback::FireGameEvent(IGameEvent* event)
{
	for (const auto [name, funcs] : m_map)
	{
		if (const std::string_view ename{ event->getName() }; ename == name)
		{
			for (const auto& func : funcs)
				func(event);
		}
	}
}

void EventCallback::shutdown()
{
	memory::interfaces::eventManager->removeListener(this);
}
```

`hack/cheats/features/events/events.hpp`:

```hpp
#pragma once

#include <SDK/IGameEvent.hpp>

#include <string>
#include <functional>
#include <vector>
#include <unordered_map>

class EventsWrapper : public IGameEventListener
{
public:
	constexpr std::string_view getName() const { return m_name; }
protected:
	std::string_view m_name;
	virtual void FireGameEvent(IGameEvent* event) override {};
};

class EventCallback : public EventsWrapper
{
public:
	void addToCallback(const std::string_view eventName, const std::function<void(IGameEvent*)>& callback);
	void shutdown();
private:
	virtual void FireGameEvent(IGameEvent* event) override;
	std::unordered_map<std::string_view, std::vector<std::function<void(IGameEvent*)>>> m_map;
};

namespace events
{
	inline EventCallback globalEvent;
	inline void shutdown()
	{
		globalEvent.shutdown();
	}
	inline void add(const std::string_view eventName, const std::function<void(IGameEvent*)>& callback)
	{
		globalEvent.addToCallback(eventName, callback);
	}
}

```

`hack/cheats/features/fakelatency/fakelatency.cpp`:

```cpp
#include "fakelatency.hpp"

#include <SDK/IVEngineClient.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/ICvar.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <config/vars.hpp>
#include <cheats/game/game.hpp>
#include <cheats/hooks/hooks.hpp>

void FakeLatency::init()
{
	maxUnlag = memory::interfaces::cvar->findVar(XOR("sv_maxunlag"));
}

int FakeLatency::runDatagram(INetChannel* netChannel, void* datagram)
{
	if (datagram || !vars::misc->fakeLatency->enabled || !game::isAvailable())
		return CALL(netChannel, datagram);

	int reliableStateBackup = netChannel->m_inReliableState;
	int sequenceNrBackup = netChannel->m_inSequenceNr;

	float maxLatency = std::max(0.0f, std::clamp(vars::misc->fakeLatency->amount / 1000.f, 0.f, maxUnlag->getFloat())
		- netChannel->getLatency(FLOW_OUTGOING));
	addLatency(netChannel, maxLatency);

	const auto ret = CALL(netChannel, datagram);

	netChannel->m_inReliableState = reliableStateBackup;
	netChannel->m_inSequenceNr = sequenceNrBackup;

	return ret;
}

void FakeLatency::run(CUserCmd* cmd)
{
	updateSequences();
}

int FakeLatency::CALL(INetChannel* netChannel, void* datagram)
{
	return hooks::sendDatagram::original(netChannel, datagram);
}

void FakeLatency::updateSequences()
{
	if (!game::isAvailable())
		return;

	if (!vars::misc->fakeLatency->enabled)
	{
		clearSequences();
		return;
	}

	auto network = memory::interfaces::engine->getNameNetChannel();
	if (!network)
		return;

	if (m_lastSequence == 0)
		m_lastSequence = network->m_inSequenceNr;

	if (network->m_inSequenceNr > m_lastSequence)
	{
		m_lastSequence = network->m_inSequenceNr;
		m_sequences.emplace_front(
			SequenceRecord
			{
					network->m_inReliableState,
					network->m_outReliableState,
					network->m_inSequenceNr,
					game::serverTime()
			}
		);
	}

	if (m_sequences.size() > 2048)
		m_sequences.pop_back();
}

void FakeLatency::clearSequences()
{
	if (!m_sequences.empty())
	{
		m_lastSequence = 0;
		m_sequences.clear();
	}
}

void FakeLatency::addLatency(INetChannel* netChannel, float latency)
{
	for (auto& el : m_sequences)
	{
		if (game::serverTime() - el.m_curtime >= latency)
		{
			netChannel->m_inReliableState = el.m_inReliableState;
			netChannel->m_inSequenceNr = el.m_sequenceNr;
			break;
		}
	}
}

```

`hack/cheats/features/fakelatency/fakelatency.hpp`:

```hpp
#pragma once

#include <cheats/classes/createMove.hpp>

#include <deque>

class CUserCmd;
class INetChannel;
class IConVar;

class FakeLatency : public CreateMovePrePredictionType
{
public:
	FakeLatency() :
		CreateMovePrePredictionType{}
	{}

public:
	static int runDatagram(INetChannel* netChannel, void* datagram);
protected:
	virtual void run([[maybe_unused]] CUserCmd* cmd) override;
	virtual void init() override;
private:
	static void addLatency(INetChannel* netChannel, float latency);
	static int CALL(INetChannel* netChannel, void* datagram);
	void updateSequences();
	void clearSequences();

	struct SequenceRecord
	{
		int m_inReliableState;
		int m_outReliableState;
		int m_sequenceNr;
		float m_curtime;
	};

	int m_lastSequence = 0;
	inline static std::deque<SequenceRecord> m_sequences;
	inline static IConVar* maxUnlag = nullptr;
};

GLOBAL_FEATURE(FakeLatency);
```

`hack/cheats/features/logger/logger.cpp`:

```cpp
#include "logger.hpp"

#include <SDK/CGlobalVars.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>
#include <render/render.hpp>
#include <config/vars.hpp>
#include <cheats/features/events/events.hpp>
#include <cheats/game/globals.hpp>

void Logger::init()
{
	events::add(XOR("player_hurt"), std::bind(&Logger::handleHits, this, std::placeholders::_1));
}

void Logger::add(const Log_t& log)
{
	if (!vars::misc->logs->enabled)
		return;

	m_logs.push_back(log);
}

void Logger::draw()
{
	if (!vars::misc->logs->enabled)
		return;

	constexpr float animation = 0.2f;
	constexpr float fineClip = 10.0f;

	for (size_t i = 0; const auto & el : m_logs)
	{
		float in = std::clamp((memory::interfaces::globalVars->m_curtime - el.m_timeLog) / animation, 0.10f, 1.0f);
		float out = std::clamp((memory::interfaces::globalVars->m_curtime - el.m_timeLog - vars::misc->logs->time) / animation, 0.0f, 1.0f);

		float alpha = in * (1.0f - out);
		if (alpha <= 0.0f)
		{
			m_logs.erase(m_logs.begin() + i);
			continue;
		}

		float x = in * fineClip - out * fineClip;
		float y = ((el.m_font->FontSize * i) + fineClip) * alpha;

		if (y > globals::screenY * 0.3f)
		{
			m_logs.pop_back();
			break;
		}

		drawing::Text text{ el.m_font, ImVec2{ x, y }, Color::U32(el.m_color.getColorEditAlpha(alpha)), el.m_text, false, false };
		text.draw(ImGui::GetBackgroundDrawList());

		i++;
	}
}

void Logger::handleHits(IGameEvent* event)
{
	auto attacker = memory::interfaces::entList->getClientEntity(memory::interfaces::engine->getPlayerID(event->getInt(XOR("attacker"))));
	if (!attacker)
		return;

	// very important
	if (attacker != game::localPlayer)
		return;

	auto ent = reinterpret_cast<Player_t*>(memory::interfaces::entList->getClientEntity(memory::interfaces::engine->getPlayerID(event->getInt(XOR("userid")))));
	if (!ent) // should never happen
		return;

	auto dmg_health = event->getInt(XOR("dmg_health"));
	auto health = ent->m_iHealth() - dmg_health;
	auto hitgroup = event->getInt(XOR("hitgroup"));

	auto hitGroupToStr = [hitgroup]() -> std::string_view
	{
		switch (hitgroup)
		{
		case HITGROUP_HEAD:
			return XOR("Head");
		case HITGROUP_CHEST:
			return XOR("Chest");
		case HITGROUP_STOMACH:
			return XOR("Belly");
		case HITGROUP_LEFTARM:
			return XOR("Left arm");
		case HITGROUP_RIGHTARM:
			return XOR("right arm");
		case HITGROUP_LEFTLEG:
			return XOR("Left leg");
		case HITGROUP_RIGHTLEG:
			return XOR("Right arm");
		default:
			return FORMAT(XOR("Unk {}"), hitgroup);
		}
	};

	add(Log_t
		{
			.m_text = FORMAT(XOR("Hit {} for [{} hp {}hp left] dmg in {}"), ent->getName(), dmg_health, health, hitGroupToStr()),
			.m_color = Colors::Cyan,
			.m_timeLog = memory::interfaces::globalVars->m_curtime,
			.m_font = ImFonts::tahoma14
		});
}

```

`hack/cheats/features/logger/logger.hpp`:

```hpp
#pragma once

#include <cheats/classes/renderableToPresent.hpp>
#include <render/Color.hpp>

#include <vector>
#include <string>

struct ImFont;
class IGameEvent;

// TODO: run in present
class Logger : protected RenderablePresentType
{
public:
	constexpr Logger() :
		RenderablePresentType{}
	{}

	struct Log_t
	{
		std::string m_text;
		Color m_color;
		float m_timeLog;
		ImFont* m_font;
	};

	void add(const Log_t& log);
protected:
	virtual void init() override;
	virtual void draw() override;
private:
	void handleHits(IGameEvent* event);
	std::vector<Log_t> m_logs;
};

GLOBAL_FEATURE(Logger);
```

`hack/cheats/features/misc/cameras/freeCam.cpp`:

```cpp
#include "freeCam.hpp"

#include <SDK/CViewSetup.hpp>
#include <SDK/math/Vector.hpp>
#include <utilities/inputSystem.hpp>
#include <utilities/math/math.hpp>
#include <config/vars.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <menu/GUI-ImGui/menu.hpp>
#include <cheats/game/game.hpp>

void Freecam::run(CViewSetup* view)
{
	if (menu.isMenuActive())
		return;

	if (!game::isAvailable())
		return;

	static Vec3 v = view->m_angles;

	if (vars::misc->freeCam->enabled && vars::keys->freeCam.isEnabled())
	{
		m_inCam = true;
		if (inputHandler.isKeyPressed(VK_SHIFT))
			vars::misc->freeCam->speed += 0.1f;
		else if (inputHandler.isKeyPressed(VK_CONTROL))
			vars::misc->freeCam->speed -= 0.1f;

		Vec3 ang = view->m_angles;
		const float speed = std::clamp(vars::misc->freeCam->speed, 1.0f, 20.0f);

		const auto [forward, right, up] = math::angleVectors(ang);
		if (inputHandler.isKeyDown(VK_SPACE))
		{
			v += up * speed;
		}
		if (inputHandler.isKeyDown(0x57)) // w
		{
			v += forward * speed;
		}
		if (inputHandler.isKeyDown(0x41)) // a
		{
			v -= right * speed;
		}
		if (inputHandler.isKeyDown(0x53)) // s
		{
			v -= forward * speed;
		}
		if (inputHandler.isKeyDown(0x44)) // d
		{
			v += right * speed;
		}
		view->m_origin += v;
	}
	else
	{
		v = view->m_angles;
		m_inCam = false;
	}
}

#include <imgui.h>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>

void FreecamDraw::draw()
{
	if (!g_Freecam->isInCam())
		return;

	if (ImGui::Begin(XOR("Info##cam"), nullptr, ImGuiWindowFlags_AlwaysAutoResize /*| ImGuiWindowFlags_NoResize*/ | ImGuiWindowFlags_NoCollapse))
	{
		ImGui::TextUnformatted(FORMAT(XOR("Speed: {:.2f}"), vars::misc->freeCam->speed).c_str());

		ImGui::End();
	}
}
```

`hack/cheats/features/misc/cameras/freeCam.hpp`:

```hpp
#pragma once

#include <cheats/classes/overrideView.hpp>
#include <SDK/math/Vector.hpp>

class CViewSetup;

class Freecam : protected OverrideViewType
{
public:
	constexpr Freecam() :
		OverrideViewType{}
	{}

	[[nodiscard]] constexpr bool isInCam() const { return m_inCam; }
protected:
	// need to set angles to remove view effect
	virtual void run(CViewSetup* view) override;
private:
	bool m_inCam = false;
	Vec3 m_view;
};

GLOBAL_FEATURE(Freecam);

#include <cheats/classes/renderableToPresent.hpp>

class FreecamDraw : protected RenderablePresentType
{
public:
	constexpr FreecamDraw() :
		RenderablePresentType{}
	{}

protected:
	virtual void draw() override;
};

GLOBAL_FEATURE(FreecamDraw);
```

`hack/cheats/features/misc/cameras/freeLook.cpp`:

```cpp
#include "freeLook.hpp"

#include <SDK/CUserCmd.hpp>
#include <SDK/CViewSetup.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <config/vars.hpp>

void FreeLook::run(CUserCmd* cmd)
{
	if (!vars::misc->freeLook->enabled)
		return;

	if (!vars::keys->freeLook.isEnabled())
	{
		m_lastAngle = cmd->m_viewangles;
		m_lastAngleLook = {};
	}
	else
	{
		if (m_lastAngleLook.isZero())
			m_lastAngleLook = m_lastAngle;

		m_lastAngleLook += (cmd->m_viewangles - m_lastAngle);
		m_lastAngleLook.normalize().clamp();

		memory::interfaces::engine->setViewAngles(m_lastAngle);
	}
}

void FreeLookViewer::run(CViewSetup* view)
{
	if (!vars::misc->freeLook->enabled)
		return;

	if (vars::keys->freeLook.isEnabled())
	{
		const auto look = g_FreeLook->m_lastAngleLook;

		if (look.isZero())
			return;

		view->m_angles[0] = look[0];
		view->m_angles[1] = look[1];
	}
}
```

`hack/cheats/features/misc/cameras/freeLook.hpp`:

```hpp
#pragma once

#include <cheats/classes/createMove.hpp>
#include <cheats/classes/overrideView.hpp>

#include <SDK/math/Vector.hpp>

class CUserCmd;
class CViewSetup;
class FreeLookViewer;

// pubg like freelook
class FreeLook : protected CreateMovePrePredictionType
{
public:
	constexpr FreeLook() :
		CreateMovePrePredictionType{}
	{}

protected:
	virtual void run(CUserCmd* cmd) override;
private:
	Vec3 m_lastAngle;
	Vec3 m_lastAngleLook;

	friend FreeLookViewer;
};

GLOBAL_FEATURE(FreeLook);

class FreeLookViewer : protected OverrideViewType
{
public:
	constexpr FreeLookViewer() :
		OverrideViewType{}
	{}

protected:
	virtual void run(CViewSetup* view) override;
};

GLOBAL_FEATURE(FreeLookViewer);

```

`hack/cheats/features/misc/disable/interpolate.cpp`:

```cpp
#include "interpolate.hpp"

#include <cheats/game/game.hpp>
#include <cheats/features/cache/cache.hpp>
#include <config/vars.hpp>

void Interpolate::run(int frame)
{
	if (!vars::misc->disableItems->interpolate)
		return;

	if (frame != FRAME_NET_UPDATE_POSTDATAUPDATE_END)
		return;

	for (auto [ent, idx, classID] : EntityCache::getCache(EntCacheType::PLAYER))
	{
		const auto entity = reinterpret_cast<Player_t*>(ent);
		const auto map = entity->getVarMap();
		if (!map)
			continue;

		for (auto i : std::views::iota(0, map->m_interpolatedEntries))
		{
			auto entry = &map->m_Entries[i];
			entry->m_needsToInterpolate = false;
		}
	}
}
```

`hack/cheats/features/misc/disable/interpolate.hpp`:

```hpp
#pragma once

#include <cheats/classes/frameStage.hpp>

class Interpolate : protected FrameStageType
{
public:
	constexpr Interpolate()
		: FrameStageType{}
	{}

protected:
	virtual void run(int frame) override;
};
```

`hack/cheats/features/misc/flashlight/flashlight.cpp`:

```cpp
#include "flashlight.hpp"

#include <SDK/CFlashlightEffect.hpp>
#include <SDK/IMemAlloc.hpp>
#include <SDK/Enums.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/ISurface.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <SDK/structs/Entity.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <utilities/math/math.hpp>
#include <gamememory/memory.hpp>
#include <utilities/tools/wrappers.hpp>
#include <utilities/tools/tools.hpp>

CFlashlightEffect* Flashlight::createFlashlight(float fov, Entity_t* ent, const char* effectName,
	float farZ, float linearAtten)
{
	auto flashlightMemory = reinterpret_cast<CFlashlightEffect*>(memory::interfaces::memAlloc->_alloc(sizeof(CFlashlightEffect)));
	if (!flashlightMemory)
		return nullptr;

	memory::flashlightCreate()(flashlightMemory, nullptr, 0.0f, 0.0f, 0.0f, fov, ent->getIndex(), effectName, farZ, linearAtten);

	return flashlightMemory;
}

void Flashlight::destroyFlashLight(CFlashlightEffect* flashlight)
{
	memory::flashlightDestroy()(flashlight, nullptr); // second arg is not even used there
}

void Flashlight::updateFlashlight(CFlashlightEffect* flashlight, const Vec3& pos, const Vec3& forward, const Vec3& right, const Vec3& up)
{
	memory::flashlightUpdate()(flashlight, flashlight->m_entIndex, pos, forward, right, up, flashlight->m_fov,
		flashlight->m_farZ, flashlight->m_LinearAtten, flashlight->m_castsShadows, flashlight->m_textureName);
}

void Flashlight::run(int frame)
{
	if (globals::isShutdown)
		return;

	if (frame != FRAME_RENDER_START)
		return;

	if (!game::isAvailable())
		return;

	if (!game::localPlayer->isAlive())
		return;

	if (!vars::misc->flashLight->enabled)
		return;

	auto key = vars::keys->flashLight;
	switch (key.getKeyMode())
	{
	case KeyMode::DOWN:
	{
		static bool done = false;

		if (key.isDown())
		{
			if (!done)
			{
				memory::interfaces::surface->playSound(XOR("items\\flashlight1.wav"));
				m_flashlight = createFlashlight(vars::misc->flashLight->fov, game::localPlayer());
				done = true;
			}
		}
		else
		{
			if (done)
			{
				destroyFlashLight(m_flashlight);
				m_flashlight = nullptr;
				done = false;
			}
		}

		break;
	}
	case KeyMode::TOGGLE:
	{
		if (key.isPressed())
		{
			memory::interfaces::surface->playSound(XOR("items\\flashlight1.wav"));

			if (m_flashlight)
			{
				destroyFlashLight(m_flashlight);
				m_flashlight = nullptr;
			}
			else
				m_flashlight = createFlashlight(vars::misc->flashLight->fov, game::localPlayer());
		}

		break;
	}
	}

	if (!m_flashlight)
		return;

	Vec3 angle;
	memory::interfaces::engine->getViewAngles(angle);
	auto [forward, right, up] = math::angleVectors(angle);

	m_flashlight->m_isOn = true;
	m_flashlight->m_castsShadows = true;
	m_flashlight->m_bigMode = vars::misc->flashLight->bigMode;
	m_flashlight->m_fov = vars::misc->flashLight->fov;

	updateFlashlight(m_flashlight, game::localPlayer->getEyePos(), forward, right, up);
}

void Flashlight::shutdown()
{
	if (m_flashlight)
	{
		destroyFlashLight(m_flashlight);
		m_flashlight = nullptr;
	}
}
```

`hack/cheats/features/misc/flashlight/flashlight.hpp`:

```hpp
#pragma once

#include <cheats/classes/frameStage.hpp>
#include <utilities/tools/tools.hpp>

#include <SDK/math/Vector.hpp>

class Entity_t;
class CFlashlightEffect;

class Flashlight : protected FrameStageType
{
public:
	constexpr Flashlight() :
		FrameStageType{}
	{}

protected:
	virtual void run(int frame) override;
	virtual void shutdown() override;
private:
	CFlashlightEffect* createFlashlight(float fov, Entity_t* ent, const char* effectName = XOR("effects/flashlight001"),
		float farZ = 1000.0f, float linearAtten = 1000.0f);
	void destroyFlashLight(CFlashlightEffect* flashlight);
	void updateFlashlight(CFlashlightEffect* flashlight, const Vec3& pos, const Vec3& forward, const Vec3& right, const Vec3& up);

	CFlashlightEffect* m_flashlight = nullptr;
};

GLOBAL_FEATURE(Flashlight);
```

`hack/cheats/features/misc/movement/movement.cpp`:

```cpp
#include "movement.hpp"

#include <SDK/CUserCmd.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/ICvar.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <cheats/game/game.hpp>
#include <config/vars.hpp>
#include <utilities/math/math.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <utilities/rand.hpp>

enum movetypes
{
	NOCLIP = 8,
	LADDER = 9
};

void Movement::init()
{
	m_sideSpeed = memory::interfaces::cvar->findVar(XOR("cl_sidespeed"));
}

void Movement::run(CUserCmd* cmd)
{
	bunnyhop(cmd);
	strafe(cmd);
}

void Movement::bunnyhop(CUserCmd* cmd)
{
	if (!vars::misc->bunnyHop->enabled)
		return;

	static bool skip = false;
	static bool jumped = false;

	if (!game::localPlayer)
		return;

	if (auto renderMode = game::localPlayer->m_nRenderMode(); renderMode == NOCLIP || renderMode == LADDER)
		return;

	if (Random::getRandom<int>(0, 100) > vars::misc->bunnyHop->chance)
		return;

	const bool jump = cmd->m_buttons & IN_JUMP;

	if (!jumped && skip)
	{
		skip = false;
		cmd->m_buttons |= IN_JUMP;
	}
	else if (jump)
	{
		if (!game::localPlayer->isInAir())
		{
			jumped = true;
			skip = true;
		}
		else
		{
			cmd->m_buttons &= ~IN_JUMP;
			jumped = true;
		}
	}
	else
	{
		jumped = false;
		skip = false;
	}
}

void Movement::strafe(CUserCmd* cmd)
{
	const int mode = vars::misc->bunnyHop->indexStrafe;
	if (mode == E2T(MovementStraferMode::OFF))
		return;

	if (!game::localPlayer)
		return;

	if (auto renderMode = game::localPlayer->m_nRenderMode(); renderMode == NOCLIP || renderMode == LADDER)
		return;

	[[maybe_unused]] const bool jump = cmd->m_buttons & IN_JUMP;
	const bool inAir = game::localPlayer->isInAir();

	if (!game::localPlayer->isMoving())
		return;

	const float speed = game::localPlayer->m_vecVelocity().toVecPrev().length();

	switch (mode)
	{
	case E2T(MovementStraferMode::SIDESPEED):
	{
		if (inAir)
			cmd->m_sidemove = cmd->m_mousedx > 1 ? m_sideSpeed->getFloat() : -m_sideSpeed->getFloat();

		break;
	}
	case E2T(MovementStraferMode::ROTATE):
	{
		auto rotateStrafe = [=](float rotation, const float forward)
		{
			rotation *= math::DEG2RAD(1.0f);

			cmd->m_forwardmove = std::cos(rotation) * forward;
			cmd->m_sidemove = std::sin(rotation) * forward;
		};

		if (inAir)
		{
			// https://www.quakeworld.nu/wiki/QW_physics_air
			const float idealAngle = std::clamp(math::RAD2DEG(std::asin(30.0f / speed) * 0.5f), 0.0f, 45.0f);
			const float side = cmd->m_commandNumber % 2 ? 1.0f : -1.0f; // or use static -/+
			rotateStrafe((idealAngle - 90.0f) * side, m_sideSpeed->getFloat());
		}

		break;
	}
	case E2T(MovementStraferMode::DIRECTIONAL):
	{
		if (inAir)
		{
			auto calcDelta = [=]() // https://www.unknowncheats.me/wiki/Counter_Strike_Global_Offensive:Proper_auto-strafer
			{
				const static float maxSpeed = game::localPlayer->m_flMaxspeed(); // this does not change, or it does? correct me
				//printf("maxspee %f\n", maxSpeed);
				const static auto sv_airaccelerate = memory::interfaces::cvar->findVar(XOR("sv_airaccelerate"));
				const float term = 30.0f / sv_airaccelerate->getFloat() / maxSpeed * 100.0f / speed;

				if (term < 1.0f && term > -1.0f)
					return std::acos(term);

				return 0.0f;
			};

			const float deltaAir = calcDelta();

			if (deltaAir != 0.0f)
			{
				const float yaw = math::DEG2RAD(cmd->m_viewangles[1]);
				const auto velocityVec = game::localPlayer->m_vecVelocity();
				const float velocityDirection = std::atan2(velocityVec[1], velocityVec[0]) - yaw;
				const float bestAngleMove = std::atan2(-cmd->m_sidemove, cmd->m_forwardmove);

				auto deltaAngle = [](float first, float second) // used to point out angle to finally calculate, detection of dir
				{
					const float delta = first - second;
					float res = std::isfinite(delta) ? std::remainder(delta, math::PI_2) : 0.0f;

					if (first > second)
					{
						if (res >= math::PI)
							res -= math::PI_2;
					}
					else
					{
						if (res <= -math::PI)
							res += math::PI_2;
					}

					return res;
				};

				const float delta = deltaAngle(velocityDirection, bestAngleMove);
				const float finalMove = delta < 0.0f ? velocityDirection + deltaAir : velocityDirection - deltaAir;

				cmd->m_forwardmove = std::cos(finalMove) * m_sideSpeed->getFloat();
				cmd->m_sidemove = -std::sin(finalMove) * m_sideSpeed->getFloat();
			}
		}

		break;
	}
	}
}

void MovementFix::run(CUserCmd* cmd, const Vec3& oldAngle)
{
	const Vec3 angle = Vec3{ 0.0f, oldAngle[1], 0.0f };
	auto [forward, right, up] = math::angleVectors(angle);
	forward.normalize(); right.normalize(); // because those are not yet normalized

	const Vec3 angleNow = Vec3{ 0.0f, cmd->m_viewangles[1], 0.0f };
	auto [forwardNow, rightNow, upNow] = math::angleVectors(angleNow);

	const Vec3 forwardOld = forward * cmd->m_forwardmove;
	const Vec3 sideOld = right * cmd->m_sidemove;

	const float newForwardMove = forwardOld.dot(forwardNow) + sideOld.dot(forwardNow);
	const float newSideMove = forwardOld.dot(rightNow) + sideOld.dot(rightNow);

	cmd->m_forwardmove = newForwardMove;
	cmd->m_sidemove = newSideMove;
}
```

`hack/cheats/features/misc/movement/movement.hpp`:

```hpp
#pragma once

#include <cheats/classes/createMove.hpp>
#include <SDK/math/Vector.hpp>

class CUserCmd;
class IConVar;

class Movement : protected CreateMovePrePredictionType
{
public:
	constexpr Movement() :
		CreateMovePrePredictionType{}
	{}

protected:
	virtual void run(CUserCmd* cmd) override;
	virtual void init() override;
private:
	// https://www.unknowncheats.me/forum/counterstrike-global-offensive/333797-humanised-bhop.html
	void bunnyhop(CUserCmd* cmd);
	void strafe(CUserCmd* cmd);

	IConVar* m_sideSpeed;
};

GLOBAL_FEATURE(Movement);

class MovementFix
{
public:
	static void run(CUserCmd* cmd, const Vec3& oldAngle);
};
```

`hack/cheats/features/misc/thirdperson/thirdperson.cpp`:

```cpp
#include "thirdperson.hpp"

#include <SDK/IEngineTrace.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/Input.hpp>
#include <SDK/vars.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <utilities/math/math.hpp>
#include <config/vars.hpp>

void Thirdperson::run(CViewSetup* view)
{
	if (!vars::misc->thirdp->enabled)
		return;

	if (!game::isAvailable())
		return;

	if (bool state = vars::keys->thirdP.isEnabled(); state)
	{
		Vec3 angles = game::getViewAngles();

		Trace_t trace;

		float fixedX = angles[0] += vars::misc->thirdp->x;
		float fixedY = angles[1] += vars::misc->thirdp->y;

		Vec3 camera = Vec3
		{
			std::cos(math::DEG2RAD(fixedY)) * vars::misc->thirdp->distance,
			std::sin(math::DEG2RAD(fixedY)) * vars::misc->thirdp->distance,
			std::sin(math::DEG2RAD(-fixedX)) * vars::misc->thirdp->distance,
		};
		Vec3 eyePos = game::localPlayer->getEyePos();
		TraceFilter filter;
		filter.m_skip = game::localPlayer();
		memory::interfaces::trace->traceRay({ eyePos, (eyePos - camera) }, MASK_SOLID, &filter, &trace);

		memory::interfaces::input->m_cameraInThirdPerson = state;
		memory::interfaces::input->m_cameraOffset = Vec3{ fixedX, fixedY, vars::misc->thirdp->distance * ((trace.m_fraction < 1.0f) ? trace.m_fraction : 1.0f) };
	}
	else if (globals::isShutdown || !state)
	{
		memory::interfaces::input->m_cameraInThirdPerson = false;
		memory::interfaces::input->m_cameraOffset = {};
	}
}
```

`hack/cheats/features/misc/thirdperson/thirdperson.hpp`:

```hpp
#pragma once

#include <cheats/classes/overrideView.hpp>

class CViewSetup;

class Thirdperson : protected OverrideViewType
{
public:
	constexpr Thirdperson() :
		OverrideViewType{}
	{}

protected:
	virtual void run([[maybe_unused]] CViewSetup* view) override;
};

GLOBAL_FEATURE(Thirdperson);

```

`hack/cheats/features/particle/particle.cpp`:

```cpp
#include "particle.hpp"

#include <SDK/interfaces/interfaces.hpp>
#include <SDK/math/Vector.hpp>
#include <utilities/utilities.hpp>
#include <gamememory/memory.hpp>

void* Particle::getCallAddr(const std::string& name)
{
	int ret = -1;
	if (memory::particleIsCached()(memory::particleSystem(), name.c_str()))
		memory::particleFindStringIndex()(reinterpret_cast<int*>(reinterpret_cast<uintptr_t>(memory::particleSystem()) + 0x14), &ret, name.c_str()); // esi+14h

	if (ret == -1)
		return nullptr;
	// *v3 + 4 * v5 - > v5 is casted unsigned __int16
	return *reinterpret_cast<void**>(*reinterpret_cast<uintptr_t*>(memory::particleSystem()) + (0x4 * static_cast<uint16_t>(ret)));
}

void Particle::dispatchParticle(const std::string& name, const Vec3& pos)
{
	Vec3 copyPos = pos;

	void* addr = getCallAddr(name);
	const static auto _call = memory::particleCall();
	void* created = createParticle(_call, addr, &copyPos);

	// update pos, you can see bytes in set control point
	__asm add esp, 8
	*reinterpret_cast<Vec3*>(reinterpret_cast<uintptr_t>(created) + 0x3B4) = copyPos;


	memory::particleSetControlPoint()(created, 0, &copyPos);
	memory::particleSetControlPoint()(created, 1, &copyPos);
}

// because calling ParticleStart or doing this by DispatchEvent did not work
// have to wrap this for new particle keyvalues method, new because judging by xrefs there was some "old" method
__declspec(naked) void* Particle::createParticle(void* caller, void* addr, Vec3* pos)
{
	__asm
	{
		push ebp
		mov ebp, esp
		push 0x0FFFFFFFF
		push 0
		mov edx, addr
		push ecx
		push pos
		call caller
		add esp, 0x10
		mov esp, ebp
		pop ebp
		retn
	}
}
```

`hack/cheats/features/particle/particle.hpp`:

```hpp
#pragma once

#include <SDK/math/Vector.hpp>

#include <string>

class Particle
{	
public:
	static void dispatchParticle(const std::string& name, const Vec3& pos);
private:
	static void* getCallAddr(const std::string& name);
	// caller is passed because it's a naked function
	static void* createParticle(void* caller, void* addr, Vec3* pos);
};
```

`hack/cheats/features/prediction/prediction.cpp`:

```cpp
#include "prediction.hpp"

#include <SDK/CGameMovement.hpp>
#include <SDK/CUserCmd.hpp>
#include <SDK/CGlobalVars.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/IWeapon.hpp>
#include <SDK/CPredictionCopy.hpp>
#include <SDK/IClientState.hpp>
#include <SDK/structs/Entity.hpp>
#include <cheats/game/game.hpp>
#include <gamememory/memory.hpp>

void Prediction::init()
{
	m_predicionRandomSeed = memory::predictionSeed();
	m_data = memory::predictionData();
	m_player = memory::predictedPlayer();
}

// 55 8B EC 83 E4 C0 83 EC 34 53 56 8B 75 08
void Prediction::start(CUserCmd* cmd)
{
	if (!game::localPlayer)
		return;

	update();

	*game::localPlayer->m_pCurrentCommand() = cmd;
	game::localPlayer->m_LastCmd() = *cmd;

	*m_predicionRandomSeed = cmd->m_randomSeed;
	*m_player = game::localPlayer();

	// backup pre-prediction
	cache = PredictionCache
	{
		.isInPrediction = memory::interfaces::prediction->m_inPrediction,
		.isFirstTimePredicted = memory::interfaces::prediction->m_firstTimePredicted,
		.curTime = memory::interfaces::globalVars->m_curtime,
		.frameTime = memory::interfaces::globalVars->m_frametime,
		.tick = game::localPlayer->m_nTickBase(),
	};

	const auto weapon = game::localPlayer()->getActiveWeapon();
	if (weapon && !weapon->isNonAimable())
	{
		cache.weaponPenalty = weapon->getInaccuracy();
		cache.recoilIndex = weapon->m_flRecoilIndex();
	}

	memory::interfaces::globalVars->m_curtime = game::ticksToTime(game::localPlayer->m_nTickBase());
	memory::interfaces::globalVars->m_frametime = (memory::interfaces::prediction->m_enginePaused/* || game::localPlayer->m_fFlags() & FL_FROZEN*/)
		? 0.0f : memory::interfaces::globalVars->m_intervalPerTick;
	memory::interfaces::globalVars->m_tickCount = game::localPlayer->m_nTickBase();
	memory::interfaces::prediction->m_inPrediction = true;
	memory::interfaces::prediction->m_firstTimePredicted = false;

	// https://github.com/perilouswithadollarsign/cstrike15_src/blob/f82112a2388b841d72cb62ca48ab1846dfcc11c8/game/client/prediction.cpp#L1058
	cmd->m_buttons |= game::localPlayer->m_afButtonForced();
	cmd->m_buttons &= ~game::localPlayer->m_afButtonDisabled();

	memory::interfaces::gameMovement->startTrackPredictionErrors(game::localPlayer());

	if (cmd->m_weaponSelect != 0)
	{
		// >=0 < 0x2000
		const auto weaponFromHandle = reinterpret_cast<Weapon_t*>(memory::interfaces::entList->getClientEntity(cmd->m_weaponSelect));
		if (weaponFromHandle)
		{
			const auto data = memory::interfaces::weaponInterface->getWpnData(weaponFromHandle->m_iItemDefinitionIndex());
			if (data)
			{
				game::localPlayer->selectItem(data->m_WeaponName, cmd->m_weaponSubtype);
			}
		}
	}

	Entity_t* veh = nullptr;
	if (const auto vehHandle = game::localPlayer->m_hVehicle(); vehHandle.isValid()) // 0xFFFFFFFF
		veh = reinterpret_cast<Entity_t*>(memory::interfaces::entList->getClientFromHandle(vehHandle));

	if (cmd->m_impulse && (!veh || game::localPlayer->usingStandardWeaponsInVehicle()))
		*game::localPlayer->m_nImpulse() = cmd->m_impulse;

	// https://github.com/perilouswithadollarsign/cstrike15_src/blob/f82112a2388b841d72cb62ca48ab1846dfcc11c8/game/client/prediction.cpp#L1090
	const auto cmdButtons = cmd->m_buttons;
	const auto localButtons = *game::localPlayer->m_nButtons();
	const auto buttonChanged = cmdButtons ^ localButtons;
	game::localPlayer()->m_afButtonLast() = localButtons;
	*game::localPlayer->m_nButtons() = cmdButtons;
	game::localPlayer->m_afButtonPressed() = buttonChanged & cmdButtons;
	game::localPlayer->m_afButtonReleased() = buttonChanged & (~cmdButtons);

	memory::interfaces::prediction->checkMovingGround(game::localPlayer(), memory::interfaces::globalVars->m_frametime);
	memory::interfaces::prediction->setLocalViewangles(cmd->m_viewangles);

	if (game::localPlayer->physicsRunThink(THINK_FIRE_ALL_FUNCTIONS))
		game::localPlayer->preThink();

	if (auto tick = game::localPlayer->m_nNextThinkTick();
		*tick > 0 && *tick <= game::localPlayer->m_nTickBase())
	{
		*tick = TICK_NEVER_THINK;
		game::localPlayer->runThink();
	}

	memory::interfaces::moveHelper->setHost(game::localPlayer());
	memory::interfaces::prediction->setupMove(game::localPlayer(), cmd, memory::interfaces::moveHelper(), m_data);
	if (!veh)
		memory::interfaces::gameMovement->processMovement(game::localPlayer(), m_data);
	else
		game::localPlayer->processMovement(veh, game::localPlayer(), m_data);
	memory::interfaces::prediction->finishMove(game::localPlayer(), cmd, m_data);
	memory::interfaces::moveHelper->processImpacts();

	game::localPlayer->m_vecAbsVelocity() = m_data->m_velocity;
	game::localPlayer->setAbsOrigin(game::localPlayer->m_vecNetworkOrigin());
	// https://gitlab.com/KittenPopo/csgo-2018-source/-/blob/main/game/client/prediction.cpp#L1513
	game::localPlayer->m_iEFlags() &= ~(EFL_DIRTY_ABSTRANSFORM | EFL_DIRTY_ABSVELOCITY);

	game::localPlayer->postThink();
	CPredictionCopy copyPost(PC_EVERYTHING, reinterpret_cast<byte*>(game::localPlayer()), PC_DATA_NORMAL, m_startData.get(), PC_DATA_PACKED, CPredictionCopy::TRANSFERDATA_COPYONLY);
	copyPost.transferData("Prediction::Post", game::localPlayer->getIndex(), game::localPlayer->getPredictionDataMap());

	if (weapon && !weapon->isNonAimable())
		weapon->updateAccuracyPenalty();

	memory::interfaces::prediction->m_inPrediction = cache.isInPrediction;
	memory::interfaces::prediction->m_firstTimePredicted = cache.isFirstTimePredicted;
}

void Prediction::end()
{
	if (!game::localPlayer)
		return;

	memory::interfaces::gameMovement->finishTrackPredictionErrors(game::localPlayer());
	memory::interfaces::moveHelper->setHost(nullptr);

	*m_predicionRandomSeed = -1;
	*m_player = nullptr;
	*game::localPlayer->m_pCurrentCommand() = nullptr;

	memory::interfaces::globalVars->m_curtime = cache.curTime;
	memory::interfaces::globalVars->m_frametime = cache.frameTime;
	memory::interfaces::globalVars->m_tickCount = cache.tick;

	if (memory::interfaces::globalVars->m_frametime > 0.0f)
		++game::localPlayer->m_nTickBase();

	if (const auto wpn = game::localPlayer->getActiveWeapon(); wpn && !wpn->isNonAimable())
	{
		wpn->m_fAccuracyPenalty() = cache.weaponPenalty;
		wpn->m_flRecoilIndex() = cache.recoilIndex;
	}

	memory::interfaces::gameMovement->reset();
}

void Prediction::addToPrediction(CUserCmd* cmd, const std::function<void()>& fun)
{
	start(cmd);
	fun();
	end();
}

void Prediction::patchDatamap()
{
	// https://www.unknowncheats.me/forum/counterstrike-global-offensive/564094-guwop-prediction-datamap-variable-fix.html
	const auto map = game::localPlayer->getPredictionDataMap();
	static std::unique_ptr<Typedescription_t[]> data(new Typedescription_t[map->m_dataFields + 1]);
	std::memcpy(data.get(), map->m_dataDescription, map->m_dataFields * sizeof(Typedescription_t));

	Typedescription_t velmod = {};

	velmod.m_type = FIELD_FLOAT;
	velmod.m_name = XOR("m_flVelocityModifier");
	velmod.m_offset[TD_OFFSET_NORMAL] = netvarMan.getNetvar(XOR("DT_CSPlayer"), XOR("m_flVelocityModifier"));
	//int copiedPackedSize = map->m_packedSize;
	//copiedPackedSize = ALIGN_VALUE(copiedPackedSize, sizeof(float));
	//velmod.m_offset[TD_OFFSET_PACKED] = copiedPackedSize;
	velmod.m_size = 1;
	velmod.m_flags = FTYPEDESC_INSENDTABLE;
	velmod.m_sizeInBytes = sizeof(float);
	velmod.fieldTolerance = 0.1f;

	std::memcpy(&data.get()[map->m_dataFields], &velmod, sizeof(Typedescription_t));

	map->m_dataDescription = data.get();
	map->m_dataFields += 1;
	// https://gitlab.com/KittenPopo/csgo-2018-source/-/blob/main/game/shared/predictioncopy.cpp#L1556
	map->m_optimizedDataMap = nullptr; // Forcing the game to recompute flattened chains.

	memory::interfaces::prediction->shutdownPredictables();
	memory::interfaces::prediction->reinitPredictables();
}

void Prediction::update()
{
	const static auto state = memory::interfaces::clientState;
	// https://github.com/perilouswithadollarsign/cstrike15_src/blob/f82112a2388b841d72cb62ca48ab1846dfcc11c8/engine/cl_pred.cpp#L64
	if (bool validframe = state->m_deltaTick > 0)
		memory::interfaces::prediction->update(state->m_deltaTick, validframe,
			state->m_lastCommandAck, state->m_lastOutGoingCommand + state->m_chockedCommands);

	static std::once_flag once;
	std::call_once(once, [&]()
		{
			patchDatamap();
		});

	const auto map = game::localPlayer->getPredictionDataMap();
	int size = map->m_packedSize;
	assert(size > 0);

	// At least 4 bytes to avoid some really bad stuff
	m_allocSize = std::max(size, 4);
	if (!m_startData)
	{
		auto allocated = std::make_unique<byte[]>(m_allocSize);
		m_startData = std::move(allocated);
	}

	CPredictionCopy copy(PC_EVERYTHING, m_startData.get(), PC_DATA_PACKED, reinterpret_cast<const byte*>(game::localPlayer()), PC_DATA_NORMAL, CPredictionCopy::TRANSFERDATA_COPYONLY);
	copy.transferData("Prediction::Update-Start", game::localPlayer->getIndex(), map);
}
```

`hack/cheats/features/prediction/prediction.hpp`:

```hpp
#pragma once

#include <cheats/classes/onlyInit.hpp>
#include <SDK/IPrediction.hpp>

#include <functional>

class CUserCmd;
class Player_t;
class Weapon_t;

class Prediction : protected OnlyInitType
{
public:
	constexpr Prediction() :
		OnlyInitType{}
	{}

	void addToPrediction(CUserCmd* cmd, const std::function<void()>& fun);
	void update();
protected:
	virtual void init() override;
private:
	struct PredictionCache
	{
		bool isInPrediction;
		bool isFirstTimePredicted;
		float curTime;
		float frameTime;
		int tick;
		float weaponPenalty;
		float recoilIndex;
	} cache;

	void start(CUserCmd* cmd);
	void end();
	void patchDatamap();
	float m_curTime;
	float m_frameTime;
	uintptr_t* m_predicionRandomSeed;
	CMoveData* m_data;
	Player_t** m_player;
	std::unique_ptr<byte[]> m_startData;
	std::unique_ptr<byte[]> m_endData;
	size_t m_allocSize;
};

GLOBAL_FEATURE(Prediction);

```

`hack/cheats/features/triggerbot/triggerbot.cpp`:

```cpp
#include "triggerbot.hpp"

#include "../aimbot/aimbot.hpp"

#include <SDK/IVEngineClient.hpp>
#include <SDK/CUserCmd.hpp>
#include <SDK/CGlobalVars.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/vars.hpp>
#include <SDK/structs/Entity.hpp>
#include <SDK/IWeapon.hpp>
#include <SDK/IEngineTrace.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <config/vars.hpp>
#include <cheats/game/game.hpp>
#include <utilities/math/math.hpp>

void Triggerbot::run(CUserCmd* cmd)
{
	auto cfg = g_Aimbot->getCachedConfig();

	if (!cfg.triggerbot)
		return;

	if (!game::isAvailable())
		return;

	if (!game::localPlayer->isAlive())
		return;

	const auto weapon = game::localPlayer->getActiveWeapon();
	if (!weapon)
		return;

	if (weapon->isNonAimable() || weapon->isEmpty())
		return;

	if (weapon->isSniper() && !game::localPlayer->m_bIsScoped())
		return;

	const auto myEye = game::localPlayer->getEyePos();
	const auto range = weapon->getWpnInfo()->m_range;
	// punch is needed to not fallback with bad constant shooting
	const auto end = myEye + math::angleVec(cmd->m_viewangles + game::localPlayer->getAimPunch()) * range;

	// initialize delays, timer api is not needed since game shares this information
	/*static auto delay = std::chrono::high_resolution_clock::now();
	const auto current = std::chrono::high_resolution_clock::now();*/
	static auto delay = memory::interfaces::globalVars->m_realtime;
	const auto current = memory::interfaces::globalVars->m_realtime;

	// because this time is in seconds, so delay must be /1000 (s->ms), when using chrono, you can cast to ms so it's more flexible
	if ((current - delay) < cfg.triggerbotDelay / 1000.0f)
		return;

	if (game::localPlayer->m_flFlashDuration() > 0.0f)
	{
		if (game::localPlayer->m_flFlashBangTime() >= cfg.flashLimit)
			return;
	}

	if (cfg.smokeCheck && game::localPlayer->isViewInSmoke(end))
		return;

	Trace_t trace;
	TraceFilter filter;

	filter.m_skip = game::localPlayer();
	memory::interfaces::trace->traceRay({ myEye, end }, MASK_PLAYER, &filter, &trace);

	// so this way we skip time of trace
	delay = current;

	if (trace.m_hitgroup == 0)
		return;

	auto entity = trace.m_entity;
	if (!entity)
		return;

	if (!entity->isOtherTeam(game::localPlayer()))
		return;

	if (!entity->isPlayer())
		return;

	if (entity->isDormant())
		return;

	if (!entity->isAlive())
		return;

	if (entity->m_bGunGameImmunity())
		return;

	//if (!game::localPlayer->isPossibleToSee(entity, entity->getEyePos()))
	//	return;

	// that is bad way
	/*if (delay >= vars::iTriggerDelay)
	{
		delay = 0;
		cmd->m_buttons |= IN_ATTACK;
	}*/

	cmd->m_buttons |= IN_ATTACK;
	delay = 0.0f;
}
```

`hack/cheats/features/triggerbot/triggerbot.hpp`:

```hpp
#pragma once

#include <cheats/classes/createMove.hpp>

class Triggerbot : protected CreateMoveInPredictionType
{
public:
	constexpr Triggerbot() :
		CreateMoveInPredictionType{}
	{}

protected:
	virtual void run(CUserCmd* cmd) override;
};

GLOBAL_FEATURE(Triggerbot);

```

`hack/cheats/features/visuals/chams/chams.cpp`:

```cpp
#include "chams.hpp"

#include "editor.hpp"

#include <SDK/material.hpp>
#include <SDK/IMaterialSystem.hpp>
#include <SDK/KeyValuesSys.hpp>
#include <SDK/KeyValues.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/IVModelRender.hpp>
#include <SDK/IVModelInfo.hpp>
#include <SDK/IVStudioRender.hpp>
#include <SDK/interfaces/interfaces.hpp>

#include <utilities/tools/wrappers.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/console/console.hpp>
#include <config/vars.hpp>
#include <cheats/game/game.hpp>

std::optional<Mat_t> Chams::addMaterialByBuffer(const Mat_t& material, bool suppress)
{
	if (const auto itr = std::ranges::find_if(m_materials, [suppress, material](const auto& m)
		{
			if (!suppress && material.data.name == m.data.name) // yes, this should be 3 lines, ide formatting goes crazy
			{
				return true;
			}
			else
			{
				return false;
			}
		}); itr != m_materials.end())
	{
		LOG_ERR(XOR("Can't add material {}, duplicating names..."), material.data.name);
		return std::nullopt;
	}
	else
	{
		LOG_DEBUG(XOR("Adding material {}"), material.data.name);
	}

	KeyValues* key = new KeyValues(material.data.key.c_str());
	key->fromBuffer(material.data.name.c_str(), material.data.buf.c_str());

	Mat_t matToPush = material;
	matToPush.mat = memory::interfaces::matSys->createMaterial(material.data.name.c_str(), key);

	if (!matToPush.mat->isError())
		matToPush.mat->addRefCount();
	else
	{
		LOG_ERR(XOR("Material {} error"), material.data.name);
		return std::nullopt;
	}

	return matToPush;
}

std::optional<Mat_t> Chams::addMaterialByString(const Mat_t& material, bool suppress)
{
	if (const auto itr = std::ranges::find_if(m_materials, [suppress, material](const auto& m)
		{
			if (!suppress && material.data.name == m.data.name) // yes, this should be 3 lines, ide formatting goes crazy
			{
				return true;
			}
			else
			{
				return false;
			}
		}); itr != m_materials.end())
	{
		LOG_ERR(XOR("Can't add material {}, duplicating names..."), material.data.name);
		return std::nullopt;
	}
	else
	{
		LOG_DEBUG(XOR("Adding material {}"), material.data.name);
	}

	Mat_t matToPush = material;
	matToPush.mat = memory::interfaces::matSys->createMaterial(material.data.name.c_str(),
		KeyValues::fromString(material.data.key.c_str(), material.data.buf.c_str()));

	if (!matToPush.mat->isError())
		matToPush.mat->addRefCount();
	else
	{
		LOG_ERR(XOR("Material {} error"), material.data.name);
		return std::nullopt;
	}

	return matToPush;
}

void Chams::init()
{
	m_materials.emplace_back(addMaterialByString(Mat_t{ .data = Mat_t::Data{.name = XOR("Flat"), .key = XOR("UnlitGeneric") } }).value());
	m_materials.emplace_back(addMaterialByString(Mat_t{ .data = Mat_t::Data{.name = XOR("Generic"), .key = XOR("VertexLitGeneric") } }).value());
	m_materials.emplace_back(addMaterialByString(Mat_t{ .type = Mat_t::ExtraType::GLOW, .data = Mat_t::Data{.name = XOR("Glow"), .key = XOR("VertexLitGeneric"),
		.buf = XOR("$additive 1 $envmap models/effects/cube_white $envmapfresnel 1") } }).value());
	m_materials.emplace_back(addMaterialByString(Mat_t{ .data = Mat_t::Data{.name = XOR("Metalic"), .key = XOR("VertexLitGeneric"),
		.buf = XOR("$basetexture white $envmap env_cubemap $normalmapalphaenvmapmask 1 $envmapcontrast 1 $nofog 1 $model 1 $nocull 0 $selfillum 1 $halfambert 1 $znearer 0 $flat 1")} }).value());
	m_materials.emplace_back(addMaterialByString(Mat_t{ .data = Mat_t::Data{.name = XOR("Pearlescent"), .key = XOR("VertexLitGeneric"),
		.buf = XOR("$ambientonly 1 $phong 1 $pearlescent 3 $basemapalphaphongmask 1") } }).value());

	g_MaterialEditor->initEditor();
}

void Chams::overrideChams(int styles, bool ignore, bool wireframe, const Color& color, bool force, bool call)
{
	Mat_t mat = m_materials.at(styles);
	
	if (!mat)
		return;

	if (mat->isError())
		return;

	mat->setMaterialVarFlag(MATERIAL_VAR_ADDITIVE, false);
	mat->setMaterialVarFlag(MATERIAL_VAR_WIREFRAME, wireframe);
	mat->setMaterialVarFlag(MATERIAL_VAR_IGNOREZ, ignore);

	if (mat.type == Mat_t::ExtraType::GLOW)
	{
		static bool found = false;
		auto matColor = mat->findVar(XOR("$envmaptint"), &found);
		if (found)
			matColor->setValues(color);

		mat->setMaterialVarFlag(MATERIAL_VAR_ADDITIVE, true);
	}

	mat->modulateAllColor(color);

	if (force)
		memory::interfaces::studioRender->forcedMaterialOverride(mat.mat);
	if (call)
		CALL(m_result, m_state, m_info, m_matrix);
}

#include <cheats/hooks/hooks.hpp>

void Chams::CALL(void* result, const DrawModelState_t& state, const ModelRenderInfo_t& info, Matrix3x4* matrix)
{
	hooks::drawModel::original(memory::interfaces::modelRender(), result, state, info, matrix);
}

void Chams::run(void* result, const DrawModelState_t& state, const ModelRenderInfo_t& info, Matrix3x4* matrix)
{
	m_result = result;
	m_state = state;
	m_info = info;
	m_matrix = matrix;

	if (!game::isAvailable())
		return;

	if (!game::localPlayer->isAlive())
		return;

	auto ent = reinterpret_cast<Player_t*>(memory::interfaces::entList->getClientEntity(info.m_entIndex));
	drawBackTrack(ent);

	if (ent && ent->isPlayer() && ent->isAlive() && ent->isOtherTeam(game::localPlayer()))
	{
		if (!vars::visuals->chams->players)
			return;

		if (vars::visuals->chams->enabledXQZPlayers)
		{
			overrideChams(vars::visuals->chams->indexPlayers, true, false, vars::visuals->chams->colorXQZPlayers());
		}

		overrideChams(vars::visuals->chams->indexPlayers, false, false, vars::visuals->chams->colorPlayers(), true, false);
		return;

	}
	if (std::string_view name = info.m_model->m_name; name.starts_with(XOR("models/weapons/v_")))
	{
		name = name.substr(17); // skip useless characters

		if (name.find(XOR("arms")) != std::string::npos)
		{
			if (!vars::visuals->chams->enabledArms)
				return;

			auto mat = memory::interfaces::matSys->findMaterial(name.data(), XOR(TEXTURE_GROUP_MODEL));
			if (!mat)
				return;

			if (vars::visuals->chams->armsHide)
			{
				mat->setMaterialVarFlag(MATERIAL_VAR_NO_DRAW, true);
				memory::interfaces::studioRender->forcedMaterialOverride(mat);
				return;
			}

			overrideChams(vars::visuals->chams->indexArms, false, false, vars::visuals->chams->colorArms(), true, false);
			return;
		}
		else if (name.find(XOR("fists")) == std::string::npos &&
			name.find(XOR("tablet")) == std::string::npos &&
			name.find(XOR("arms")) == std::string::npos &&
			!game::localPlayer->m_bIsScoped())
		{
			if (!vars::visuals->chams->enabledWeapons)
				return;

			auto mat = memory::interfaces::matSys->findMaterial(name.data(), XOR(TEXTURE_GROUP_MODEL));
			if (!mat)
				return;

			if (vars::visuals->chams->weaponHide)
			{
				mat->setMaterialVarFlag(MATERIAL_VAR_NO_DRAW, true);
				memory::interfaces::studioRender->forcedMaterialOverride(mat);
				return;
			}

			overrideChams(vars::visuals->chams->indexWeapons, false, false, vars::visuals->chams->colorWeapons(), true, false);
			return;
		}
	}
}

#include "../../backtrack/backtrack.hpp"
#include <SDK/CGlobalVars.hpp>

void Chams::drawBackTrack(Player_t* ent)
{
	if (!vars::visuals->chams->enabledBacktrack)
		return;

	if (!ent)
		return;

	if (!ent->isAlive())
		return;

	if (!ent->isOtherTeam(game::localPlayer())) // backtrack works only for enemies here anyway
		return;

	auto record = &g_Backtrack->getAllRecords().at(m_info.m_entIndex);
	if (!record)
		return;

	if (record->empty())
		return;

	switch (vars::visuals->chams->indexBacktrack)
	{
	case E2T(BTChamsType::STABLE):
	{
		for (size_t i = 0; i < record->size(); i++)
		{
			if (!g_Backtrack->isValid(record->at(i).m_simtime))
				break;

			overrideChams(vars::visuals->chams->modeBacktrack, false, false, vars::visuals->chams->colorBacktrack(), true, false);
			CALL(m_result, m_state, m_info, record->at(i).m_matrix.data());
			memory::interfaces::studioRender->forcedMaterialOverride(nullptr);
		}
		break;
	}
	case E2T(BTChamsType::LAST_TICK):
	{
		if (g_Backtrack->isValid(record->front().m_simtime))
		{
			overrideChams(vars::visuals->chams->modeBacktrack, false, false, vars::visuals->chams->colorBacktrack(), true, false);
			CALL(m_result, m_state, m_info, record->back().m_matrix.data());
			memory::interfaces::studioRender->forcedMaterialOverride(nullptr);
		}
		break;
	}
	case E2T(BTChamsType::RAINBOW):
	{
		for (size_t i = 0; i < record->size(); i++)
		{
			if (!g_Backtrack->isValid(record->at(i).m_simtime))
				break;

			overrideChams(vars::visuals->chams->modeBacktrack, false, false,
				Color::rainbowColor(memory::interfaces::globalVars->m_curtime + (i / 3.0f), vars::visuals->chams->rainbowBacktrackSpeed), true, false);
			CALL(m_result, m_state, m_info, record->at(i).m_matrix.data());
			memory::interfaces::studioRender->forcedMaterialOverride(nullptr);
		}
		break;
	}
	case E2T(BTChamsType::COLOR_CHANGE):
	{
		Color fromCfg = vars::visuals->chams->colorBacktrack();

		for (size_t i = 0; i < record->size(); i++)
		{
			if (!g_Backtrack->isValid(record->at(i).m_simtime))
				break;

			Color color(fromCfg.r() - (i * (1.0f / record->size())),
				i * (fromCfg.g() / record->size()), fromCfg.b(), fromCfg.a());

			overrideChams(vars::visuals->chams->modeBacktrack, false, false, color, true, false);
			CALL(m_result, m_state, m_info, record->at(i).m_matrix.data());
			memory::interfaces::studioRender->forcedMaterialOverride(nullptr);
		}
		break;
	}
	default:
		break;
	}
}

```

`hack/cheats/features/visuals/chams/chams.hpp`:

```hpp
#pragma once

#include "mat.hpp"

#include <cheats/classes/drawModel.hpp>
#include <SDK/IVModelRender.hpp>
#include <SDK/IVModelRender.hpp>
#include <SDK/math/matrix.hpp>

#include <string>
#include <vector>
//#include <propagate_const> impossible rn

class Color;
struct DrawModelState_t;
struct ModelRenderInfo_t;
class Player_t;
class IMaterial;
class KeyValues;

class MaterialEditor;

class Chams : protected DrawModelType
{
public:
	Chams() :
		DrawModelType{}
	{}

	std::vector<Mat_t> getMaterials() const { return m_materials; }
protected:
	virtual void run(void* result, const DrawModelState_t& state, const ModelRenderInfo_t& info, Matrix3x4* matrix) override;
	virtual void init() override;
private:
	void overrideChams(int styles, bool ignore, bool wireframe, const Color& color, bool force = true, bool call = true);
	void drawBackTrack(Player_t* ent);
	void CALL(void* result, const DrawModelState_t& state, const ModelRenderInfo_t& info, Matrix3x4* matrix);

	std::optional<Mat_t> addMaterialByBuffer(const Mat_t& material, bool suppress = false);
	std::optional<Mat_t> addMaterialByString(const Mat_t& material, bool suppress = false);

	std::vector<Mat_t> m_materials;

	void* m_result;
	DrawModelState_t m_state;
	ModelRenderInfo_t m_info;
	Matrix3x4* m_matrix;

	friend MaterialEditor;
};

GLOBAL_FEATURE(Chams);
```

`hack/cheats/features/visuals/chams/editor.cpp`:

```cpp
#include "editor.hpp"

#include <cheats/classes/renderableToPresent.hpp>
#include <utilities/tools/wrappers.hpp>
#include <utilities/tools/tools.hpp>
#include <menu/GUI-ImGui/animations.hpp>
#include <imgui_stdlib.h>
#include <deps/magic_enum/prettyNames.hpp>
#include <config/jsonExtended.hpp>
#include <config/config.hpp>

#include <ranges>
#include <fstream>

using json = nlohmann::json;

void from_json(const json& j, Mat_t::Data& val)
{
	from_json(j, "Name", val.name);
	from_json(j, "Key", val.key);
	from_json(j, "Buf", val.buf);
}

void to_json(json& j, const Mat_t::Data& val)
{
	j["Name"] = val.name;
	j["Key"] = val.key;
	j["Buf"] = val.buf;
}

void from_json(const json& j, Mat_t& val)
{
	from_json(j, "Data", val.data);
	from_json(j, "Type", val.type);
	from_json(j, "Strategy", val.strategy);
}

void to_json(json& j, const Mat_t& val)
{
	j["Data"] = val.data;
	j["Type"] = val.type;
	j["Strategy"] = val.strategy;
}

// use this correctly
// read: https://developer.valvesoftware.com/wiki/Category:Shaders
// and lists, in this case you unortunately have to copy key 
// WIPPPPPP, ugly code
void MaterialEditor::draw()
{
	if (!m_open)
		return;
	// [SECTION] Example App: Simple Layout / ShowExampleAppLayout() demo ref
	ImGui::SetNextWindowSize(ImVec2(500, 440), ImGuiCond_FirstUseEver);
	if (ImGui::Begin("Material editor", &m_open, ImGuiWindowFlags_NoCollapse))
	{
		static size_t index = m_oldIndex;
		static Mat_t material = getMaterialIndexed(index).value_or(Mat_t{});
		{
			ImGui::BeginChild(XOR("left pane"), ImVec2{ 150.0f, 0.0f }, true);

			for (auto i : std::views::iota(m_oldIndex, g_Chams->m_materials.size()))
			{
				if (ImGui::Animations::Selectable(g_Chams->m_materials.at(i).data.name.data(), index == i))
				{
					index = i;
					material = getMaterialIndexed(index).value();
					m_ImEditor.SetText(material.data.buf);
				}
			}


			ImGui::EndChild();
		}
		ImGui::SameLine();


		ImGui::BeginChild(XOR("Materials view"));

		if (g_Chams->m_materials.size() > m_oldIndex)
			ImGui::TextUnformatted(FORMAT(XOR("{}"), g_Chams->m_materials.at(index).data.name).c_str());
		else
			ImGui::TextUnformatted(XOR("No materials yet, add one!"));
		ImGui::Separator();

		ImGui::TextUnformatted(XOR("Strategy"));
		ImGui::RadioButton(XOR("Buffer"), reinterpret_cast<int*>(material.strategy), 0);
		ImGui::SameLine();
		ImGui::RadioButton(XOR("From String"), reinterpret_cast<int*>(material.strategy), 1);
		ImGui::InputText(XOR("Name"), &material.data.name);
		ImGui::InputText(XOR("Key"), &material.data.key);
		ImGui::Animations::Combo(XOR("Style"), reinterpret_cast<int*>(&material.type), magic_enum::enum_names_pretty<Mat_t::ExtraType>());

		if (ImGui::Animations::Button(XOR("Delete")))
		{
			size_t elementsRemoved = std::erase_if(g_Chams->m_materials,
				[this](const auto& m)
				{
					if (m.isFromEditor && m.data.name == material.data.name)
					{
						m_json.erase(m_json.find(material.data.name));
						return true;
					}
					else
					{
						return false;
					}
				});
			if (elementsRemoved > 0)
			{
				saveCfg();
				index -= elementsRemoved;
				size_t correctIndex = g_Chams->m_materials.size() - elementsRemoved;
				material = getMaterialIndexed(index).value_or(Mat_t{});
				m_ImEditor.SetText(material.data.buf);
			}
		}
		ImGui::SameLine();
		if (ImGui::Animations::Button(XOR("Add")))
		{
			std::optional<Mat_t> mat;

			if (material.strategy == Mat_t::StrategyType::FROM_STRING) // not from buffer
			{
				// prob good to split the \n 's here ?
				mat = g_Chams->addMaterialByString(Mat_t
					{
						.isFromEditor = true, .type = material.type, .strategy = material.strategy,
						.data = Mat_t::Data{ .name = material.data.name, .key = material.data.key, .buf = m_ImEditor.GetText() }
					});
			}
			else
			{
				mat = g_Chams->addMaterialByBuffer(Mat_t
					{
						.isFromEditor = true, .type = material.type, .strategy = material.strategy,
						.data = Mat_t::Data{ .name = material.data.name, .key = material.data.key, .buf = m_ImEditor.GetText() }
					});
			}

			if (mat.has_value())
			{
				g_Chams->m_materials.emplace_back(mat.value());
				saveCfg();
			}
		}
		ImGui::SameLine();
		if (ImGui::Animations::Button(XOR("Update")))
		{
			if (const auto itr = std::ranges::find_if(g_Chams->m_materials,
				[=](const auto& m)
				{
					if (m.data.name == material.data.name)
					{
						return true;
					}
					else
					{
						return false;
					}
				}); itr != g_Chams->m_materials.end())
			{
				*itr = Mat_t
				{
					.isFromEditor = true, .type = material.type, .strategy = material.strategy,
					.data = Mat_t::Data{ .name = material.data.name, .key = material.data.key, .buf = m_ImEditor.GetText() } 
				};
			}
		}

		m_ImEditor.Render(XOR("Editor##mat"));

		ImGui::EndChild();

		ImGui::End();
	}
}

void MaterialEditor::initEditor()
{
	m_folderName = XOR("materials");
	m_saveDir = config.getHackPath() / config.getExtraLoadPath() / m_folderName / getPathForConfig();

	m_oldIndex = g_Chams->m_materials.size();
	loadCfg();

	for (auto i : std::views::iota(m_oldIndex, g_Chams->m_materials.size()))
		g_Chams->m_materials.at(i) = g_Chams->addMaterialByBuffer(g_Chams->m_materials.at(i), true).value();
}

bool MaterialEditor::loadCfg()
{
	if (auto path = config.getHackPath() / config.getExtraLoadPath() / m_folderName; !std::filesystem::exists(path))
		std::filesystem::create_directories(path);

	std::ifstream input{ m_saveDir };
	if (!input)
		return false;

	if (!std::filesystem::is_empty(m_saveDir))
	{
		m_json = json::parse(input);

		for (const auto& [key, value] : m_json.items())
		{
			Mat_t material;
			from_json(value, material);
			material.isFromEditor = true;

			g_Chams->m_materials.push_back(material);
		}
	}

	return true;
}

bool MaterialEditor::saveCfg()
{
	std::ofstream out{ m_saveDir };
	if (!out)
		return false;

	json j;
	for (auto i : std::views::iota(m_oldIndex, g_Chams->m_materials.size()))
		to_json(j[g_Chams->m_materials.at(i).data.name], g_Chams->m_materials.at(i));

	if (!j.empty())
		m_json.update(j);

	out << std::setw(4) << m_json;

	return true;
}

std::filesystem::path MaterialEditor::getPathForConfig() const
{
	std::filesystem::path path(m_folderName);
	if (path.extension() != XOR(".json"))
		path.replace_extension(XOR(".json"));

	return path;
}

std::optional<Mat_t> MaterialEditor::getMaterialIndexed(size_t index) const
{
	if (index < m_oldIndex)
		return std::nullopt;

	if (index >= g_Chams->m_materials.size())
		return std::nullopt;

	const auto& material = g_Chams->m_materials.at(index);
	return Mat_t
	{
		.isFromEditor = true, .type = material.type, .strategy = material.strategy,
		.data = Mat_t::Data{.name = material.data.name, .key = material.data.key, .buf = material.data.buf }
	};
}
```

`hack/cheats/features/visuals/chams/editor.hpp`:

```hpp
#pragma once

#include "chams.hpp"

#include <cheats/classes/renderableToPresent.hpp>
#include <nlohmann/json.hpp>
#include <deps/ImGui/TextEditor.hpp>

class MaterialEditor : protected RenderablePresentType
{
public:
	MaterialEditor()
		: RenderablePresentType{}
	{}

protected:
	virtual void draw() override;
public:
	void initEditor();
	void changeState() { m_open = !m_open; }
private:

	bool loadCfg();
	bool saveCfg();
	std::filesystem::path getPathForConfig() const;
	std::optional<Mat_t> getMaterialIndexed(size_t index) const;

	bool m_open{ false };
	size_t m_oldIndex; // before custom
	std::string_view m_folderName;
	std::filesystem::path m_saveDir;
	TextEditor m_ImEditor;
	nlohmann::json m_json;
};

GLOBAL_FEATURE(MaterialEditor);
```

`hack/cheats/features/visuals/chams/mat.hpp`:

```hpp
#pragma once

#include <string>

class IMaterial;

struct Mat_t
{
	struct Data
	{
		std::string name{};
		std::string key{};
		std::string buf{};
	};

	enum class ExtraType
	{
		NONE,
		GLOW = 1
	};

	enum class StrategyType
	{
		BUFFER,
		FROM_STRING
	};

	bool isFromEditor{ false }; // editor
	ExtraType type{ ExtraType::NONE };
	StrategyType strategy{ StrategyType::BUFFER }; // editor
	Data data{};
	IMaterial* mat{};

	constexpr IMaterial* operator->() const { return mat; }
	constexpr bool operator!() const { return mat == nullptr; }
};
```

`hack/cheats/features/visuals/glow/glow.cpp`:

```cpp
#include "glow.hpp"

#include <SDK/IMaterialSystem.hpp>
#include <SDK/IVModelRender.hpp>
#include <SDK/CGlowManager.hpp>
#include <SDK/ClientClass.hpp>
#include <SDK/Enums.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>
#include <config/vars.hpp>

void Glow::run()
{
	if (!vars::visuals->glow->enabled)
		return;

	if (!game::isAvailable())
		return;

	for (int i = 0; i < memory::interfaces::glowManager->m_size; i++)
	{
		auto& glow = memory::interfaces::glowManager->m_objects[i];

		if (glow.unused())
			continue;

		auto ent = reinterpret_cast<Player_t*>(glow.m_entity);

		if (!ent)
			continue;

		if (ent->isDormant())
			continue;
		
		auto cl = ent->clientClass();

		if (!cl)
			continue;

		switch (cl->m_classID)
		{
		case CCSPlayer:
		{
			if (!ent->isOtherTeam(game::localPlayer()))
			{
				glow.set(vars::visuals->glow->colorPlayer());
				glow.m_fullBloom = false;
			}
			break;
		}
		default:
			break;
		}
	}
}
```

`hack/cheats/features/visuals/glow/glow.hpp`:

```hpp
#pragma once

#include <cheats/classes/doPostScreen.hpp>

class Glow : protected DoPostScreenType
{
public:
	constexpr Glow() :
		DoPostScreenType{}
	{}

protected:
	virtual void run() override;
};

GLOBAL_FEATURE(Glow);
```

`hack/cheats/features/visuals/hitmarker/hitmark.cpp`:

```cpp
#include "hitmark.hpp"

#include <SDK/CGlobalVars.hpp>
#include <SDK/IGameEvent.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/ISurface.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <render/render.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <cheats/features/events/events.hpp>

#include <functional>

// TODO: try if this is okay-ish https://gitlab.com/KittenPopo/csgo-2018-source/-/blob/main/game/shared/takedamageinfo.h#L24
// and then: https://gitlab.com/KittenPopo/csgo-2018-source/-/blob/main/game/server/player.cpp#L1725
// server.dll 55 8B EC 83 EC 18 56 57 8B 7D 08 8B F1 57
// retaddr to check 84 C0 74 34 8B 4D 08 8B 01 
void Hitmarker::init()
{
	events::add(XOR("player_hurt"), std::bind(&Hitmarker::handleHits, this, std::placeholders::_1));
}

void Hitmarker::draw()
{
	if (!vars::misc->hitmarker->enabled)
		return;

	if (!game::localPlayer)
		return;

	if (!game::localPlayer->isAlive())
		return;

	int x, y;
	bool mode3D = vars::misc->hitmarker->enabled3D;
	if (!mode3D)
	{
		x = globals::screenX / 2;
		y = globals::screenY / 2;
	}

	float currentAlpha = 0.0f;
	for (size_t i = 0; const auto & el : m_hitmarkers)
	{
		float diff = el.m_expire - memory::interfaces::globalVars->m_curtime;

		if (diff < 0.0f)
		{
			m_hitmarkers.erase(m_hitmarkers.begin() + i);
			continue;
		}

		if (mode3D)
		{
			if (ImVec2 s; imRender.worldToScreen(el.m_pos, s))
			{
				x = static_cast<int>(s.x);
				y = static_cast<int>(s.y);
			}
			else
				continue;
		}

		currentAlpha = diff / vars::misc->hitmarker->time;
		float sizeFont = 16.0f;
		Color actualColor = vars::misc->hitmarker->colorNormal().getColorEditAlpha(currentAlpha);
		float lineX = 10.0f;
		float lineY = 5.0f;

		if (el.isAvailable() && el.m_head)
		{
			actualColor = vars::misc->hitmarker->colorHead().getColorEditAlpha(currentAlpha);
			sizeFont = 24.0f;
			lineX = 14.0f;
			lineY = 7.0f;
		}
		else if (!el.isAvailable())
		{
			actualColor = vars::misc->hitmarker->colorDead().getColorEditAlpha(currentAlpha);
			sizeFont = 28.0f;
			lineX = 18.0f;
			lineY = 9.0f;
		}

		float lineAddonX = lineX;
		float lineAddonY = lineY;
		if (vars::misc->hitmarker->enabledResize)
		{
			lineAddonX = lineX / (1.0f / (currentAlpha + 0.01f)); // prevent division by 0 and make ratio
			lineAddonY = lineY / (1.0f / (currentAlpha + 0.01f));
		}

		imRender.drawLine(x - lineAddonX, y + lineAddonX, x - lineAddonY, y + lineAddonY, actualColor);
		imRender.drawLine(x + lineAddonX, y + lineAddonX, x + lineAddonY, y + lineAddonY, actualColor);
		imRender.drawLine(x - lineAddonX, y - lineAddonX, x - lineAddonY, y - lineAddonY, actualColor);
		imRender.drawLine(x + lineAddonX, y - lineAddonX, x + lineAddonY, y - lineAddonY, actualColor);

		constexpr int moveMultiply = 25;
		float correction = (1.0f - currentAlpha) * moveMultiply; // this maybe should have el.expire ratio to previous one
		float Xcorrection = x + 8.0f + (correction * 0.6f); // multiply 0.6 to get a bit niver effect, 8 comes from padding
		float Ycorrection = y - (correction * 4.0f); // 4.0f comes from hardcoding. Make it more nice, maybe there are better ways for this

		imRender.text(Xcorrection, Ycorrection, sizeFont, ImFonts::tahoma14, FORMAT(XOR("{}"), el.m_dmg), false, actualColor, false);

		i++;
	}
}

void Hitmarker::handleHits(IGameEvent* event)
{
	if (!vars::misc->hitmarker->enabled)
		return;

	auto attacker = memory::interfaces::entList->getClientEntity(memory::interfaces::engine->getPlayerID(event->getInt(XOR("attacker"))));
	if (!attacker)
		return;

	// very important
	if (attacker != game::localPlayer)
		return;

	auto ent = reinterpret_cast<Player_t*>(memory::interfaces::entList->getClientEntity(memory::interfaces::engine->getPlayerID(event->getInt(XOR("userid")))));
	if (!ent) // should never happen
		return;

	auto dmg_health = event->getInt(XOR("dmg_health"));
	auto health = ent->m_iHealth() - dmg_health;
	auto hitgroup = event->getInt(XOR("hitgroup"));

	Hitmark_t hit =
	{
		memory::interfaces::globalVars->m_curtime + vars::misc->hitmarker->time,
		dmg_health,
		ent->m_iHealth() - dmg_health,
		hitgroup == 1, // head
		ent->getHitgroupPos(hitgroup)
	};
	m_hitmarkers.push_back(hit);

	if (vars::misc->hitmarker->play)
		memory::interfaces::surface->playSound(XOR("buttons\\arena_switch_press_02.wav"));
}

```

`hack/cheats/features/visuals/hitmarker/hitmark.hpp`:

```hpp
#pragma once

#include <cheats/classes/renderableToSurface.hpp>
#include <SDK/math/Vector.hpp>

class IGameEvent;

class Hitmarker : protected RenderableSurfaceType
{
public:
	constexpr Hitmarker() :
		RenderableSurfaceType{}
	{}

protected:
	virtual void draw() override;
	virtual void init() override;
private:
	void handleHits(IGameEvent* event);

	struct Hitmark_t
	{
		float m_expire;
		int m_dmg;
		int m_health;
		bool m_head;
		Vec3 m_pos;

		bool isAvailable() const { return m_health >= 0; }
	};
	std::vector<Hitmark_t> m_hitmarkers;
};

GLOBAL_FEATURE(Hitmarker);
```

`hack/cheats/features/visuals/list/playerlist.cpp`:

```cpp
#include "playerlist.hpp"

#include <cheats/features/cache/cache.hpp>
#include <cheats/game/game.hpp>
#include <config/vars.hpp>
#include <SDK/structs/Entity.hpp>
#include <SDK/Enums.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <menu/GUI-ImGui/animations.hpp>
#include <cheats/features/blacklist/blacklist.hpp>
#include <render/Color.hpp>

#include <imgui.h>
#include <magic_enum.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>

#include <ranges>
#include <iostream>

struct TableStruct
{
	constexpr TableStruct(const std::string_view name, const int flags, bool* cfg = nullptr)
		: name{ name }, flags{ flags }, cfg{ cfg }
	{}

	std::string_view name;
	int flags;
	bool* cfg = nullptr; // some are default always
};

void PlayerList::draw()
{
	if (!vars::misc->playerList->enabled)
		return;

	if (!game::isAvailable())
		return;

	// ImGui demo: Tables/Borders
	if (ImGui::Begin(XOR("PlayerList"), &vars::misc->playerList->enabled))
	{
		static std::array tableNames
		{
			TableStruct{ XOR("Name"), ImGuiTableColumnFlags_NoHide },
			TableStruct{ XOR("Health"), ImGuiTableColumnFlags_WidthFixed, &vars::misc->playerList->health },
			TableStruct{ XOR("Money"), ImGuiTableColumnFlags_WidthFixed, &vars::misc->playerList->money },
			TableStruct{ XOR("Team"), ImGuiTableColumnFlags_WidthFixed, &vars::misc->playerList->teamID },
			TableStruct{ XOR("Place"), ImGuiTableColumnFlags_WidthFixed, &vars::misc->playerList->lastPlace },
			TableStruct{ XOR("Blacklist"), ImGuiTableColumnFlags_WidthFixed | ImGuiTableColumnFlags_NoResize }
		};

		if (ImGui::BeginTable("", tableNames.size(),
			ImGuiTableFlags_Borders | ImGuiTableFlags_Hideable | ImGuiTableFlags_Resizable /*| ImGuiTableFlags_Sortable*/))
		{
			for (size_t i = 0; const auto [name, flags, cfg] : tableNames)
			{
				ImGui::TableSetupColumn(name.data(), flags);
				if (cfg)
					ImGui::TableSetColumnEnabled(i, *cfg);

				i++;
			}
			ImGui::TableHeadersRow();

			auto players = EntityCache::getCache(EntCacheType::PLAYER);
			std::ranges::sort(players,
				[](const EntityCache::HolderData& lhs, const EntityCache::HolderData& rhs)
				{
					auto lhsEnt = reinterpret_cast<Player_t*>(lhs.ent);
					auto rhsEnt = reinterpret_cast<Player_t*>(rhs.ent);
					bool lhsIsOtherTeam = lhsEnt->isOtherTeam(game::localPlayer());
					bool rhsIsOtherTeam = rhsEnt->isOtherTeam(game::localPlayer());

					if (lhsIsOtherTeam ^ rhsIsOtherTeam)
						return lhsIsOtherTeam;

					return false;
				}
			);

			for (size_t i = 0; auto [entity, idx, classID] : players)
			{
				auto ent = reinterpret_cast<Player_t*>(entity);

				if (ent == game::localPlayer)
					continue;

				// check once again, will be faster than extra vector
				bool isEnemy = ent->isOtherTeam(game::localPlayer());

				// allow buttons to be executed for ONLY selected player
				ImGui::PushID(i);

				ImGui::TableNextRow();

				if (ImGui::TableNextColumn())
				{
					ImVec4 color = isEnemy ? ImVec4{ 1.0f, 0.0f, 0.0f, 1.0f } : ImVec4{ 0.0f, 1.0f, 0.0f, 1.0f };
					ImGui::PushStyleColor(ImGuiCol_Text, color);
					ImGui::TextUnformatted(ent->getRawName().data());
					ImGui::PopStyleColor();
				}

				if (ImGui::TableNextColumn())
				{
					const auto health = ent->isDormant()
						? CacheFields::getCachedFields().at(idx).m_health
						: ent->m_iHealth();
					ImVec4 color;
					std::memcpy(&color, Color::healthBased(health).data(), 4 * sizeof(float));

					ImGui::PushStyleColor(ImGuiCol_Text, color);
					std::string text = health == 0 ? XOR("DEAD") : FORMAT(XOR("{}"), health);
					ImGui::TextUnformatted(text.c_str());
					ImGui::PopStyleColor();

					if (health)
					{
						ImGui::SameLine();
						ImGui::TextUnformatted(XOR("HP"));
					}
				}

				if (ImGui::TableNextColumn())
				{
					ImGui::TextUnformatted(FORMAT(XOR("{}$"), ent->m_iAccount()).c_str());
				}

				if (ImGui::TableNextColumn())
				{
					ImGui::TextUnformatted(FORMAT(XOR("{} ({})"), ent->m_iTeamNum(),
						magic_enum::enum_names<TeamID>().at(ent->m_iTeamNum())).c_str());
				}

				if (ImGui::TableNextColumn())
				{
					ImGui::TextUnformatted(ent->m_szLastPlaceName());
				}

				if (ImGui::TableNextColumn())
				{
					enum class BlacklistAction { ADD, REMOVE };

					const auto blacklist = !g_Blacklist->isBlacklisted(ent)
						? std::make_pair(FORMAT(XOR("Add##{}"), idx), BlacklistAction::ADD)
						: std::make_pair(FORMAT(XOR("Delete##{}"), idx), BlacklistAction::REMOVE);

					const auto [title, isOn] = blacklist;

					if (ImGui::Animations::Button(title.c_str(), ImVec2{ -std::numeric_limits<float>::min(), 0.0f }))
					{	
						isOn == BlacklistAction::ADD
							? g_Blacklist->add(ent)
							: g_Blacklist->remove(ent);
					}
				}

				ImGui::PopID();

				i++;
			}

			ImGui::EndTable();
		}

		ImGui::End();
	}
}

```

`hack/cheats/features/visuals/list/playerlist.hpp`:

```hpp
#pragma once

#include <cheats/classes/renderableToPresent.hpp>

class PlayerList : protected RenderablePresentType
{
public:
	constexpr PlayerList() :
		RenderablePresentType{}
	{}
protected:
	virtual void draw() override;
};

GLOBAL_FEATURE(PlayerList);
```

`hack/cheats/features/visuals/mirrorcam/mirrorCam.cpp`:

```cpp
#include "mirrorCam.hpp"

#include <d3d9.h>

#include <imgui.h>

#include <SDK/interfaces/interfaces.hpp>
#include <SDK/IMaterialSystem.hpp>
#include <SDK/ITexture.hpp>
#include <SDK/IMatRenderContext.hpp>
#include <SDK/CViewSetup.hpp>
#include <SDK/IVRenderView.hpp>
#include <SDK/CGlobalVars.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/inputSystem.hpp>
#include <utilities/console/console.hpp>
#include <cheats/hooks/hooks.hpp>
#include <cheats/game/game.hpp>
#include <config/vars.hpp>

void MirrorCam::run(const CViewSetup& view)
{
	// this might eat some FPS, if enabled
	if (!vars::misc->mirrorCam->enabled)
		return;

	CViewSetup v = view;

	v.m_angles[Coord::Y] = v.m_angles[Coord::Y] + 180.0f; // back
	v.x = v.xOld = 0;
	v.y = v.yOld = 0;
	v.m_width = v.m_widthOld = static_cast<int>(m_size[Coord::X]);
	v.m_height = v.m_heightOld = static_cast<int>(m_size[Coord::Y]);
	v.m_aspectRatio = static_cast<float>(v.m_width / v.m_height);
	v.m_nearZ = v.m_nearViewModelZ = 7.0f;
	v.m_fov = 50.0f;

	auto ctx = memory::interfaces::matSys->getRenderContext();
	ctx->pushRenderTargetAndViewport();
	ctx->setRenderTarget(m_texture);

	hooks::viewRender::original(memory::interfaces::viewRender(), v, v, VIEW_CLEAR_COLOR | VIEW_CLEAR_DEPTH | VIEW_CLEAR_STENCIL, 0);

	ctx->popRenderTargetAndViewport();
	ctx->release();
}

IDirect3DTexture9* MirrorCam::getTexture() const
{
	return m_texture->m_handle[0]->m_texture;
}

void MirrorCamDraw::draw()
{
	if (!game::isAvailable())
		return;

	if (!g_MirrorCam->m_inited)
	{
		//interfaces::matSys->forceBeginRenderTargetAllocation();
		g_MirrorCam->m_texture = memory::interfaces::matSys->createFullFrameRenderTarget(XOR("mirrorCam"));
		//interfaces::matSys->forceEndRenderTargetAllocation();

		g_MirrorCam->m_inited = true;

		LOG_INFO(XOR("Inited mirrorcam texture!"));
	}

	if (!vars::misc->mirrorCam->enabled)
		return;

	if (vars::misc->mirrorCam->onKey)
	{
		if (!vars::keys->mirrorCam.isEnabled())
			return;
	}

	// useless, use getActual...
	// raw sizes, returns ur screen size
	/*D3DSURFACE_DESC surfaceDesc;
	m_texture->m_handle[0]->m_texture->GetLevelDesc(0, &surfaceDesc);*/

	if (ImGui::Begin(XOR("Camera"), nullptr, ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse))
	{
		// https://gitlab.com/KittenPopo/csgo-2018-source/-/blob/main/tier2/renderutils.cpp#L988
		// ^ is proper scaling what game does

		if (auto size = ImGui::GetContentRegionAvail(); size.x != 0.0f && size.y != 0.0f) // / 0
		{
			float xRatio = static_cast<float>(g_MirrorCam->m_texture->getActualWidth()) / size.x;
			float yRatio = static_cast<float>(g_MirrorCam->m_texture->getActualHeight()) / size.y;

			g_MirrorCam->setSize(Vec2{ size.x * xRatio, size.y * yRatio });
			ImGui::Image(g_MirrorCam->getTexture(), size);
		}

		ImGui::End();
	}
}

```

`hack/cheats/features/visuals/mirrorcam/mirrorCam.hpp`:

```hpp
#pragma once

#include <cheats/classes/renderableToPresent.hpp>
#include <cheats/classes/viewRender.hpp>

#include <SDK/math/Vector.hpp>

class CViewSetup;
class ITexture;
struct IDirect3DTexture9;
class MirrorCamDraw;

class MirrorCam : protected ViewRenderType
{
public:
	constexpr MirrorCam() :
		ViewRenderType{}
	{}

protected:
	virtual void run(const CViewSetup& view) override;
private:
	constexpr void setSize(const Vec2& size) { m_size = size; }
	IDirect3DTexture9* getTexture() const;

	Vec2 m_size = Vec2{ 1.0f, 1.0f };
	ITexture* m_texture;
	bool m_inited = false;

	friend MirrorCamDraw;
};

GLOBAL_FEATURE(MirrorCam);

class MirrorCamDraw : protected RenderablePresentType
{
public:
	constexpr MirrorCamDraw() :
		RenderablePresentType{}
	{}

protected:
	virtual void draw() override;
};

GLOBAL_FEATURE(MirrorCamDraw);

```

`hack/cheats/features/visuals/misc/crosshair.cpp`:

```cpp
#include "crosshair.hpp"

#include <SDK/IVEngineClient.hpp>
#include <SDK/IEngineTrace.hpp>
#include <SDK/ICvar.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/IWeapon.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <utilities/tools/wrappers.hpp>
#include <utilities/math/math.hpp>
#include <render/render.hpp>

void Crosshair::init()
{
	m_crosshairRecoil = memory::interfaces::cvar->findVar(XOR("cl_crosshair_recoil"));
	m_scale = memory::interfaces::cvar->findVar(XOR("weapon_recoil_scale"));
}

void Crosshair::draw()
{
	int cfgCross = vars::misc->crosshair->index;

	m_crosshairRecoil->setValue(cfgCross == E2T(CrossHairTypes::ENGINE) ? true : false);

	if (!cfgCross)
		return;

	if (!game::localPlayer)
		return;

	if (!memory::interfaces::engine->isConnected())
		return;

	if (!game::localPlayer->isAlive())
		return;

	float x = globals::screenX / 2.0f;
	float y = globals::screenY / 2.0f;

	const auto weapon = game::localPlayer->getActiveWeapon();
	if (!weapon)
		return;

	auto getPunchPos = [=]()
	{
		Vec3 angle;
		memory::interfaces::engine->getViewAngles(angle);
		angle += game::localPlayer->m_aimPunchAngle() * m_scale->getFloat();

		auto start = game::localPlayer->getEyePos();
		auto end = start + math::angleVec(angle) * weapon->getWpnInfo()->m_range;

		return end;
	};

	switch (cfgCross)
	{
	case E2T(CrossHairTypes::STATIC):
	{
		float moveCross = 8.0f;

		imRender.drawLine(x - moveCross, y, x + moveCross, y, Colors::Black, 3.0f);
		imRender.drawLine(x, y - moveCross, x, y + moveCross, Colors::Black, 3.0f);

		moveCross -= 1.5f;

		imRender.drawLine(x - moveCross, y, x + moveCross, y, Colors::LightBlue, 1.0f);
		imRender.drawLine(x, y - moveCross, x, y + moveCross, Colors::LightBlue, 1.0f);
		break;
	}
	case E2T(CrossHairTypes::RECOIL):
	{
		if (ImVec2 endScreen; imRender.worldToScreen(getPunchPos(), endScreen))
		{
			float x = endScreen.x;
			float y = endScreen.y;

			float moveCross = 8.0f;

			imRender.drawLine(x - moveCross, y, x + moveCross, y, Colors::Black, 3.0f);
			imRender.drawLine(x, y - moveCross, x, y + moveCross, Colors::Black, 3.0f);

			moveCross -= 1.5f;

			imRender.drawLine(x - moveCross, y, x + moveCross, y, Colors::LightBlue, 1.0f);
			imRender.drawLine(x, y - moveCross, x, y + moveCross, Colors::LightBlue, 1.0f);
		}
		break;
	}
	case E2T(CrossHairTypes::SPREAD):
	{
		if (ImVec2 endScreen; imRender.worldToScreen(getPunchPos(), endScreen))
		{
			// this is game's logic how to do it
			/*float spread = weapon->getSpread();
			float inaccuracy = weapon->getInaccuracy();
			float scaledSpread = ((inaccuracy + spread) * 320.0f / std::tan(DEG2RAD(globals::FOV) / 2.0f));
			int radiusSpread = scaledSpread * y / 480.0f;

			if (game::localPlayer->m_vecVelocity().length2D() > 0.0f)
				radiusSpread = inaccuracy * 1000.0f;*/
			float inaccuracy = weapon->getInaccuracy();
			float radiusSpread = inaccuracy * 1000.0f;
			float x = endScreen.x;
			float y = endScreen.y;

			imRender.drawCircle(x, y, radiusSpread, 32, Colors::Black);
			imRender.drawCircleFilled(x, y, radiusSpread, 32, Colors::LightBlue.getColorEditAlpha(0.2f));
		}
		break;
	}
	default:
		break;
	}
}

```

`hack/cheats/features/visuals/misc/crosshair.hpp`:

```hpp
#pragma once

#include <cheats/classes/renderableToSurface.hpp>

class IConVar;

class Crosshair : protected RenderableSurfaceType
{
public:
	constexpr Crosshair() :
		RenderableSurfaceType{}
	{}

protected:
	virtual void init() override;
	virtual void draw() override;
private:
	IConVar* m_scale;
	IConVar* m_crosshairRecoil;
};

GLOBAL_FEATURE(Crosshair);

```

`hack/cheats/features/visuals/misc/drawInfo.hpp`:

```hpp
#pragma once

#include <cheats/classes/renderableToPresent.hpp>

class IGameEvent;

class MiscInfo : protected RenderablePresentType
{
public:
	constexpr MiscInfo() :
		RenderablePresentType{}
	{}

protected:
	virtual void init() override;
	virtual void draw() override;
private:
	void addHits(IGameEvent* event);
	void resetHits(IGameEvent* event);
	uint32_t m_allHits;
};

GLOBAL_FEATURE(MiscInfo);
```

`hack/cheats/features/visuals/misc/drawinfo.cpp`:

```cpp
#include "drawinfo.hpp"

#include <SDK/IVEngineClient.hpp>
#include <SDK/IWeapon.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/IClientEntityList.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <render/render.hpp>
#include <cheats/features/events/events.hpp>

void MiscInfo::init()
{
	if (game::isAvailable())
	{
		m_allHits = game::localPlayer->m_totalHitsOnServer(); // those gets clamped at 255 :(
		// https://gitlab.com/KittenPopo/csgo-2018-source/-/blob/main/game/shared/cstrike15/cs_player_shared.cpp#L1682
		// ida: direct reference: [actual address in first opcode] E8 ? ? ? ? 8B 44 24 24 46 
	}

	events::add(XOR("player_hurt"), std::bind(&MiscInfo::addHits, this, std::placeholders::_1));
	events::add(XOR("round_end"), std::bind(&MiscInfo::resetHits, this, std::placeholders::_1));
}

void MiscInfo::addHits(IGameEvent* event)
{
	auto attacker = memory::interfaces::entList->getClientEntity(memory::interfaces::engine->getPlayerID(event->getInt(XOR("attacker"))));
	if (!attacker)
		return;

	// very important
	if (attacker != game::localPlayer)
		return;

	auto ent = reinterpret_cast<Player_t*>(memory::interfaces::entList->getClientEntity(memory::interfaces::engine->getPlayerID(event->getInt(XOR("userid")))));
	if (!ent) // should never happen
		return;

	++m_allHits;
}

void MiscInfo::resetHits(IGameEvent* event)
{
	m_allHits = 0;
}

void MiscInfo::draw()
{
	if (!vars::misc->info->enabled)
		return;

	if (!game::isAvailable())
		return;

	const auto weapon = game::localPlayer->getActiveWeapon();
	if (!weapon)
		return;

	auto text = []
	(const std::string& text, const Color& color)
	{
		ImGui::PushStyleColor(ImGuiCol_Text, ImVec4{ color.r(), color.g(), color.b(), color.a() });
		ImGui::TextUnformatted(text.c_str()); // because textcolored is formatted by va args
		ImGui::PopStyleColor();
	};

	if (ImGui::Begin(XOR("##info"), nullptr, ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoBackground | ImGuiWindowFlags_NoTitleBar
		| ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoScrollbar))
	{
		text(FORMAT(XOR("Map: {}"), memory::interfaces::engine->getLevelName()), Colors::Green);
		text(FORMAT(XOR("Weapon {}"), weapon->getWpnInfo()->m_WeaponName), Colors::Yellow);
		text(FORMAT(XOR("[{} / {}] DMG [{}HP]"), weapon->m_iClip1(), weapon->m_iPrimaryReserveAmmoCount(), weapon->getWpnInfo()->m_damage), Colors::Yellow);
		text(FORMAT(XOR("Current In-accuracy {:.2f}%"), weapon->getInaccuracy() * 100.0f), Colors::Yellow);
		text(FORMAT(XOR("Zoom level {}"), weapon->m_zoomLevel()), Colors::Yellow);
		text(FORMAT(XOR("POS: X {:.2f} Y {:.2f} Z {:.2f}"), game::localPlayer->absOrigin()[Coord::X], game::localPlayer->absOrigin()[Coord::Y], game::localPlayer->absOrigin()[Coord::Z]), Colors::Yellow);
		text(FORMAT(XOR("Velocity {:.2f}"), game::localPlayer->m_vecVelocity().toVecPrev().length()), Colors::Yellow);
		text(FORMAT(XOR("Kills {}"), game::localPlayer->getKills()), Colors::Yellow);
		text(FORMAT(XOR("Deaths {}"), game::localPlayer->getDeaths()), Colors::Yellow);
		// escape divide by zero exceptions by using this trick
		float kd = game::localPlayer->getKills() / (game::localPlayer->getDeaths() ? game::localPlayer->getDeaths() : 1.0f);
		float kpm = game::localPlayer->getKills() / (game::serverTime() / 60.0f);
		text(FORMAT(XOR("KD {:.2f} KPM: {:.2f}"), kd, kpm), Colors::Yellow);
		text(FORMAT(XOR("Ping {}"), game::localPlayer->getPing()), Colors::Yellow);
		float accuracy = game::localPlayer->m_vecBulletVerifyListClient().m_size
			? (static_cast<float>(m_allHits) / static_cast<float>(game::localPlayer->m_vecBulletVerifyListClient().m_size)) * 100.0f
			: 0.0f;
		float fixedKills = game::localPlayer->getKills() ? game::localPlayer->getKills() : 1.0f;
		float hs = game::localPlayer->m_iNumRoundKillsHeadshots()
			? (static_cast<float>(game::localPlayer->m_iNumRoundKillsHeadshots()) / fixedKills) * 100.0f
			: 0.0f;
		text(FORMAT(XOR("Accuracy [{} / {}] {:.2f}% HS {:.2f}%"),
			m_allHits, game::localPlayer->m_vecBulletVerifyListClient().m_size, accuracy, hs), Colors::Yellow);

		ImGui::End();
	}
}
```

`hack/cheats/features/visuals/misc/hat.cpp`:

```cpp
#include "hat.hpp"

#include <SDK/CGlobalVars.hpp>
#include <SDK/Input.hpp>
#include <SDK/math/Vector.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <utilities/math/math.hpp>
#include <render/render.hpp>

void Hat::draw()
{
	if (!vars::misc->hat->enabled)
		return;

	if (!game::isAvailable())
		return;

	if (!memory::interfaces::input->m_cameraInThirdPerson)
		return;

	auto pos = game::localPlayer->getBonePos(8); // you can play around with vec.z

	// config.get<> enjoyer

	if (vars::misc->hat->rainbow)
	{
		drawConeEditedRainbow(pos, vars::misc->hat->radius, 86, vars::misc->hat->size,
			vars::misc->hat->rainbowSpeed, vars::misc->hat->rainbowAlpha, vars::misc->hat->rainbowLinesAlpha);
	}
	else
	{
		imRender.drawCone(pos, vars::misc->hat->radius, 86, vars::misc->hat->size,
			vars::misc->hat->colorTriangle(), vars::misc->hat->colorLine(), true, 2.0f);
	}
}

void Hat::drawConeEditedRainbow(const Vec3& pos, const float radius, const int points, const float size,
	const float speed, const int trianglesAlpha, const int linesAlpha, const float thickness)
{
	ImVec2 orignalW2S = {};
	if (!imRender.worldToScreen(pos, orignalW2S))
		return;

	float step = math::PI * 2.0f / points;
	for (float angle = 0.0f; angle < (math::PI * 2.0f); angle += step)
	{
		Vec3 startWorld = Vec3{ radius * std::cos(angle) + pos[Coord::X], radius * std::sin(angle) + pos[Coord::Y], pos[Coord::Z] };
		Vec3 endWorld = Vec3{ radius * std::cos(angle + step) + pos[Coord::X], radius * std::sin(angle + step) + pos[Coord::Y], pos[Coord::Z] };

		if (ImVec2 start, end; imRender.worldToScreen(startWorld, start) && imRender.worldToScreen(endWorld, end))
		{
			imRender.drawLine(start, end,
				Color::rainbowColor(memory::interfaces::globalVars->m_curtime + angle, speed).getColorEditAlphaInt(linesAlpha), thickness);
			imRender.drawTrianglePoly({ orignalW2S.x, orignalW2S.y + size }, start, end,
				Color::rainbowColor(memory::interfaces::globalVars->m_curtime + angle, speed).getColorEditAlphaInt(trianglesAlpha));
		}
	}
}
```

`hack/cheats/features/visuals/misc/hat.hpp`:

```hpp
#pragma once

#include <cheats/classes/renderableToSurface.hpp>

#include <SDK/math/Vector.hpp>

class Hat : protected RenderableSurfaceType
{
public:
	constexpr Hat() :
		RenderableSurfaceType{}
	{}

protected:
	virtual void draw() override;
private:
	void drawConeEditedRainbow(const Vec3& pos, const float radius, const int points, const float size,
		const float speed, const int trianglesAlpha, const int linesAlpha, const float thickness = 2.0f);
};

GLOBAL_FEATURE(Hat);

```

`hack/cheats/features/visuals/misc/motionblur.cpp`:

```cpp
#include "motionblur.hpp"

#include <SDK/CViewSetup.hpp>
#include <SDK/CGlobalVars.hpp>
#include <SDK/IMaterialSystem.hpp>
#include <SDK/ITexture.hpp>
#include <SDK/math/Vector.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <utilities/math/math.hpp>
#include <utilities/tools/tools.hpp>
#include <gamememory/memory.hpp>

// 1:1 from https://github.com/perilouswithadollarsign/cstrike15_src/blob/f82112a2388b841d72cb62ca48ab1846dfcc11c8/game/client/viewpostprocess.cpp#L2996
// with small reduce of code because we dont care for portal/ps3 stuff and also we dont care for detecting blur, but knowing it's enabled
void MotionBlur::run(CViewSetup* view)
{
	if (!vars::misc->motionBlur->enabled)
		return;

	if (!game::isAvailable())
		return;

	if (!game::localPlayer->isAlive())
		return;

	constexpr auto resetArr = [](std::array<float, 4>& arr, size_t indexesToReset)
	{
		for (size_t i = 0; auto & el : arr)
		{
			if (i == indexesToReset)
				break;

			el = 0.0f;

			i++;
		}
	};

	if (view)
	{
		float timeElapsed = memory::interfaces::globalVars->m_realtime - m_motionHistory.m_lastTimeUpdate;

		float currentPitch = view->m_angles[Coord::X];
		while (currentPitch > 180.0f)
			currentPitch -= 360.0f;
		while (currentPitch < -180.0f)
			currentPitch += 360.0f;

		float currentYaw = view->m_angles[Coord::Y];
		while (currentYaw > 180.0f)
			currentYaw -= 360.0f;
		while (currentYaw < -180.0f)
			currentYaw += 360.0f;

		auto [currentForwardVec, currentSideVec, uselessVec ] = math::angleVectors(view->m_angles);

		Vec3 currentPosition = view->m_origin;
		Vec3 positionChange = m_motionHistory.m_previousPositon - currentPosition;

		if ((positionChange.length() > 30.0f) && (timeElapsed >= 0.5f))
		{
			resetArr(m_motionBlurValues, m_motionBlurValues.size());
		}
		else if (timeElapsed > (1.0f / 15.0f))
		{
			resetArr(m_motionBlurValues, m_motionBlurValues.size());
		}
		else if (positionChange.length() > 50.0f)
		{
			m_motionHistory.m_noRotationalMotionBlurUntil = memory::interfaces::globalVars->m_realtime + 1.0f;
		}
		else
		{
			const float horizontalFov = view->m_fov;
			const float verticalFov = (view->m_aspectRatio <= 0.0f) ? (view->m_fov) : (view->m_fov / view->m_aspectRatio);
			const float viewDotMotion = currentForwardVec.dot(positionChange);

			if (vars::misc->motionBlur->forward)
				m_motionBlurValues[2] = viewDotMotion;
			else
				m_motionBlurValues[2] = viewDotMotion * std::abs(currentForwardVec[2]);

			const float sideDotMotion = currentSideVec.dot(positionChange);
			float yawDiffOriginal = m_motionHistory.m_previousYaw - currentYaw;
			if (((m_motionHistory.m_previousYaw - currentYaw > 180.0f) || (m_motionHistory.m_previousYaw - currentYaw < -180.0f)) &&
				((m_motionHistory.m_previousYaw + currentYaw > -180.0f) && (m_motionHistory.m_previousYaw + currentYaw < 180.0f)))
				yawDiffOriginal = m_motionHistory.m_previousYaw + currentYaw;

			float yawDiffAdjusted = yawDiffOriginal + (sideDotMotion / 3.0f);

			if (yawDiffOriginal < 0.0f)
				yawDiffAdjusted = std::clamp(yawDiffAdjusted, yawDiffOriginal, 0.0f);
			else
				yawDiffAdjusted = std::clamp(yawDiffAdjusted, 0.0f, yawDiffOriginal);

			const float undampenedYaw = yawDiffAdjusted / horizontalFov;
			m_motionBlurValues[0] = undampenedYaw * (1.0f - (std::abs(currentPitch) / 90.0f));

			const float pitchCompensateMask = 1.0f - ((1.0f - std::abs(currentForwardVec[2])) * (1.0f - std::abs(currentForwardVec[2])));
			const float pitchDiffOriginal = m_motionHistory.m_previousPitch - currentPitch;
			float pitchdiffAdjusted = pitchDiffOriginal;

			if (currentPitch > 0.0f)
				pitchdiffAdjusted = pitchDiffOriginal - ((viewDotMotion / 2.0f) * pitchCompensateMask);
			else
				pitchdiffAdjusted = pitchDiffOriginal + ((viewDotMotion / 2.0f) * pitchCompensateMask);

			if (pitchDiffOriginal < 0.0f)
				pitchdiffAdjusted = std::clamp(pitchdiffAdjusted, pitchDiffOriginal, 0.0f);
			else
				pitchdiffAdjusted = std::clamp(pitchdiffAdjusted, 0.0f, pitchDiffOriginal);

			m_motionBlurValues[1] = pitchdiffAdjusted / verticalFov;
			m_motionBlurValues[3] = undampenedYaw;
			m_motionBlurValues[3] *= (std::abs(currentPitch) / 90.0f) * (std::abs(currentPitch) / 90.0f) * (std::abs(currentPitch) / 90.0f);

			if (timeElapsed > 0.0f)
				m_motionBlurValues[2] /= timeElapsed * 30.0f;
			else
				m_motionBlurValues[2] = 0.0f;

			m_motionBlurValues[2] = std::clamp((std::abs(m_motionBlurValues[2]) - vars::misc->motionBlur->fallingMin) / (vars::misc->motionBlur->fallingMax - vars::misc->motionBlur->fallingMin),
				0.0f, 1.0f) * (m_motionBlurValues[2] >= 0.0f ? 1.0f : -1.0f);
			m_motionBlurValues[2] /= 30.0f;
			m_motionBlurValues[0] *= vars::misc->motionBlur->rotationIntensity * vars::misc->motionBlur->strength;
			m_motionBlurValues[1] *= vars::misc->motionBlur->rotationIntensity * vars::misc->motionBlur->strength;
			m_motionBlurValues[2] *= vars::misc->motionBlur->fallingIntensity * vars::misc->motionBlur->strength;
			m_motionBlurValues[3] *= vars::misc->motionBlur->rollIntensity * vars::misc->motionBlur->strength;

			float slowFps = 30.0f;
			float fastFps = 50.0f;
			float currentFps = (timeElapsed > 0.0f) ? (1.0f / timeElapsed) : 0.0f;
			float dumpenFactor = std::clamp(((currentFps - slowFps) / (fastFps - slowFps)), 0.0f, 1.0f);

			m_motionBlurValues[0] *= dumpenFactor;
			m_motionBlurValues[1] *= dumpenFactor;
			m_motionBlurValues[2] *= dumpenFactor;
			m_motionBlurValues[3] *= dumpenFactor;
		}

		if (memory::interfaces::globalVars->m_realtime < m_motionHistory.m_noRotationalMotionBlurUntil)
		{
			resetArr(m_motionBlurValues, 3);
		}
		else
		{
			m_motionHistory.m_noRotationalMotionBlurUntil = 0.0f;
		}

		m_motionHistory.m_previousPositon = currentPosition;
		m_motionHistory.m_previousPitch = currentPitch;
		m_motionHistory.m_previousYaw = currentYaw;
		m_motionHistory.m_lastTimeUpdate = memory::interfaces::globalVars->m_realtime;

		static ITexture* _rt_FullFrameFB = memory::interfaces::matSys->findTexture("_rt_FullFrameFB", TEXTURE_GROUP_RENDER_TARGET);

		int x = view->x;
		int y = view->y;
		int w = view->m_width;
		int h = view->m_height;

		float srcWidth = static_cast<float>(_rt_FullFrameFB->getActualWidth());
		float srcHeight = static_cast<float>(_rt_FullFrameFB->getActualHeight());
		int offset;
		offset = (x > 0) ? 1 : 0;
		m_motionBlurViewportValues[0] = static_cast<float>(x + offset) / (srcWidth - 1);

		offset = (x < (srcWidth - 1)) ? -1 : 0;
		m_motionBlurViewportValues[3] = static_cast<float>(x + w + offset) / (srcWidth - 1);

		offset = (y > 0) ? 1 : 0;
		m_motionBlurViewportValues[1] = static_cast<float>(y + offset) / (srcHeight - 1);

		offset = (y < (srcHeight - 1)) ? -1 : 0;
		m_motionBlurViewportValues[2] = static_cast<float>(y + h + offset) / (srcHeight - 1);

		for (auto& el : m_motionBlurViewportValues)
		{
			if (el <= 0.0f)
				el = -1.0f;
			else if (el >= 1.0f)
				el = 2.0f;
		}
	}
}

void MotionBlur::render()
{
	if (!vars::misc->motionBlur->enabled)
		return;

	if (!game::isAvailable())
		return;

	if (!game::localPlayer->isAlive())
		return;

	static IMaterial* motion_blur = memory::interfaces::matSys->findMaterial(XOR("dev/motion_blur"), XOR(TEXTURE_GROUP_RENDER_TARGET), false);

	static IMaterialVar* MotionBlurInternal = motion_blur->findVar(XOR("$MotionBlurInternal"), nullptr, false);

	MotionBlurInternal->setVectorComponent(m_motionBlurValues[0], 0);
	MotionBlurInternal->setVectorComponent(m_motionBlurValues[1], 1);
	MotionBlurInternal->setVectorComponent(m_motionBlurValues[2], 2);
	MotionBlurInternal->setVectorComponent(m_motionBlurValues[3], 3);
	
	// todo: find easiest way to trick the game we run motion blur, (easiest and best way - mempatch correct bytes)

	// edit those fields from memory, todo
	//float* motionBlurIntervalValues = *reinterpret_cast<float**>(m_motionBlurAddr);
	//motionBlurIntervalValues = m_motionBlurValues.data();

	static IMaterialVar* MotionBlurViewPortInternal = motion_blur->findVar(XOR("$MotionBlurViewportInternal"), nullptr, false);

	MotionBlurViewPortInternal->setVectorComponent(m_motionBlurViewportValues[0], 0);
	MotionBlurViewPortInternal->setVectorComponent(m_motionBlurViewportValues[1], 1);
	MotionBlurViewPortInternal->setVectorComponent(m_motionBlurViewportValues[2], 2);
	MotionBlurViewPortInternal->setVectorComponent(m_motionBlurViewportValues[3], 3);

	// this code will make fullscreen blured, you probably don't want it. Also group will fuck up everything
	// TEXTURE_GROUP_CLIENT_EFFECTS will pass
	/*auto ctx = interfaces::matSys->getRenderContext();
	ctx->drawScreenSpaceRectangle(motion_blur, 0, 0, globals::screenX, globals::screenY, 0, 0,
		globals::screenX, globals::screenY, globals::screenX, globals::screenY);
	ctx->release();*/

	// so we have to wrap it and call directly in isdepth hook to prevent problems like weapon being blurred
	const static auto _call = memory::drawSpacedRectangle();
	__asm
	{
		push globals::screenY
		push globals::screenX
		push 0
		xor edx, edx
		mov ecx, motion_blur
		call _call
		add esp, 12
	}
}

```

`hack/cheats/features/visuals/misc/motionblur.hpp`:

```hpp
#pragma once

#include <cheats/classes/overrideView.hpp>
#include <SDK/math/Vector.hpp>

#include <array>

class CViewSetup;

class MotionBlur : protected OverrideViewType
{
public:
	MotionBlur() :
		OverrideViewType{}
	{}

	static void render();
protected:
	virtual void run(CViewSetup* view) override;
private:
	struct MotionBlurHistory_t
	{
		constexpr MotionBlurHistory_t() :
			m_lastTimeUpdate{ 0.0f }, m_previousPitch{ 0.0f }, m_previousYaw{ 0.0f },
			m_previousPositon{ Vec3{} }, m_noRotationalMotionBlurUntil{ 0.0f }
		{}

		float m_lastTimeUpdate;
		float m_previousPitch;
		float m_previousYaw;
		Vec3 m_previousPositon;
		float m_noRotationalMotionBlurUntil;
	} m_motionHistory;

	inline static std::array<float, 4> m_motionBlurValues = { 0.0f, 0.0f, 0.0f, 0.0f };
	inline static std::array<float, 4> m_motionBlurViewportValues = { 0.0f, 0.0f, 0.0f, 0.0f };
};

GLOBAL_FEATURE(MotionBlur);

```

`hack/cheats/features/visuals/misc/noscope.cpp`:

```cpp
#include "noscope.hpp"

#include <SDK/IMaterialSystem.hpp>
#include <SDK/vars.hpp>
#include <SDK/Enums.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <utilities/tools/tools.hpp>
#include <render/render.hpp>

void NoScope::draw()
{
	if (!vars::misc->scope->enabled)
		return;

	if (!game::isAvailable())
		return;

	auto weapon = game::localPlayer->getActiveWeapon();
	if (!weapon)
		return;

	if (!weapon->isSniper())
		return;

	if (game::localPlayer->m_bIsScoped())
	{
		imRender.drawLine(globals::screenX / 2.0f, 0.0f, globals::screenX / 2.0f, static_cast<float>(globals::screenY), Colors::Black);
		imRender.drawLine(0.0f, globals::screenY / 2.0f, static_cast<float>(globals::screenX), globals::screenY / 2.0f, Colors::Black);
	}
}

void NoScopeBlur::init()
{
	m_blurScope = memory::interfaces::matSys->findMaterial(XOR("dev/scope_bluroverlay"), XOR(TEXTURE_GROUP_OTHER));
}

void NoScopeBlur::run()
{
	m_blurScope->setMaterialVarFlag(MATERIAL_VAR_NO_DRAW, vars::misc->scope->enabled);
}

```

`hack/cheats/features/visuals/misc/noscope.hpp`:

```hpp
#pragma once

#include <cheats/classes/renderableToSurface.hpp>
#include <cheats/classes/doPostScreen.hpp>

class IMaterial;

class NoScope : protected RenderableSurfaceType
{
public:
	constexpr NoScope() :
		RenderableSurfaceType{}
	{}

protected:
	virtual void draw() override;
};

GLOBAL_FEATURE(NoScope);

class NoScopeBlur : protected DoPostScreenType
{
public:
	constexpr NoScopeBlur() :
		DoPostScreenType{}
	{}

protected:
	virtual void run() override;
	virtual void init() override;
private:
	IMaterial* m_blurScope;
};

GLOBAL_FEATURE(NoScopeBlur);

```

`hack/cheats/features/visuals/misc/screenEffects.cpp`:

```cpp
#include "screenEffects.hpp"

#include <SDK/IMaterialSystem.hpp>
#include <SDK/IMatRenderContext.hpp>
#include <SDK/vars.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <menu/GUI-ImGui/selections.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <utilities/tools/tools.hpp>

void ScreenEffects::init()
{
	for (const std::string_view el : selections::screenEffects)
	{
		bool mark = false;
		if (el == "effects/nightvision") // this looks bad, dunno
			mark = true;

		m_materials.emplace_back(std::make_pair(memory::interfaces::matSys->findMaterial(
			el.data(), TEXTURE_GROUP_CLIENT_EFFECTS), mark));
	}
}

void ScreenEffects::run()
{
	if (!game::isAvailable())
		return;

	int cfg = vars::visuals->world->screenEffect->index;
	if (cfg == 0)
		return;

	Color color = vars::visuals->world->screenEffect->color();

	auto material = m_materials.at(cfg).first;
	material->colorModulate(color); // -> works for night vision

	static bool found = false;
	auto var = material->findVar(XOR("$c0_x"), &found);
	if(found)
		var->setValue(vars::visuals->world->screenEffect->param);

	if (m_materials.at(cfg).second) //nightvisioson
		game::localPlayer->m_flNightVisionAlpha() = color.a();

	auto ctx = memory::interfaces::matSys->getRenderContext();
	ctx->drawScreenSpaceRectangle(material, 0, 0, globals::screenX, globals::screenY, 0, 0,
	 static_cast<float>(globals::screenX), static_cast<float>(globals::screenY), globals::screenX, globals::screenY);
	ctx->release();
}

```

`hack/cheats/features/visuals/misc/screenEffects.hpp`:

```hpp
#pragma once

#include <cheats/classes/screen2dEffects.hpp>

#include <vector>

class IMaterial;

class ScreenEffects : protected Screen2DEffectsType
{
public:
	constexpr ScreenEffects() :
		Screen2DEffectsType{}
	{}

protected:
	virtual void run() override;
	virtual void init() override;
private:
	std::vector<std::pair<IMaterial*, bool>> m_materials;
};

GLOBAL_FEATURE(ScreenEffects);

```

`hack/cheats/features/visuals/misc/trails.cpp`:

```cpp
#include "trails.hpp"

#include <SDK/CGlobalVars.hpp>
#include <SDK/IViewRenderBeams.hpp>
#include <SDK/IEffects.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <render/render.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>

void Trails::draw()
{
	static Vec3 end;

	if (!game::isAvailable())
		return;

	int type = vars::misc->trail->mode;

	if (!vars::misc->trail->enabled)
		return;

	if (type != E2T(MovementTrail::BEAM))
	{
		// prepare the point to be corrected
		end = game::localPlayer->m_vecOrigin();
	}

	Color color = vars::misc->trail->color();

	switch (type)
	{
	case E2T(MovementTrail::BEAM):
	{
		if (!game::localPlayer->isMoving()) // do not add beams on not moving
			return;

		const Vec3 start = game::localPlayer->m_vecOrigin();

		BeamInfo_t info = {};

		info.m_type = TE_BEAMPOINTS;
		info.m_modelName = XOR("sprites/purplelaser1.vmt");
		info.m_modelIndex = -1;
		info.m_vecStart = start;
		info.m_vecEnd = end;
		info.m_haloIndex = -1;
		info.m_haloScale = 0.0f;
		info.m_life = vars::misc->trail->time;
		info.m_width = 5.0f;
		info.m_endWidth = 5.0f;
		info.m_fadeLength = 0.0f;
		info.m_amplitude = 2.0;
		info.m_brightness = 255.0f;
		info.m_red = color.rMultiplied();
		info.m_green = color.gMultiplied();
		info.m_blue = color.bMultiplied();
		info.m_speed = vars::misc->trail->beamSpeed;
		info.m_startFrame = 0;
		info.m_frameRate = 0.0f;
		info.m_segments = 2;
		info.m_renderable = true;

		auto myBeam = memory::interfaces::beams->createBeamPoints(info);

		// change to pos after beam is drawn, since it's static it's possible
		end = start;

		break;
	}
	case E2T(MovementTrail::LINE):
	{
		float curtime = memory::interfaces::globalVars->m_curtime;

		if (game::localPlayer->isMoving())
			m_trails.push_back(Trail_t{ game::localPlayer->m_vecOrigin(), curtime + vars::misc->trail->time, color });

		Vec3 last = {};
		if (!m_trails.empty())
			last = m_trails.front().m_pos;

		for (size_t i = 0; const auto & el : m_trails)
		{
			if (el.m_expire < curtime)
			{
				m_trails.erase(m_trails.begin() + i);
				continue;
			}

			if (ImVec2 start, end; !last.isZero() && imRender.worldToScreen(el.m_pos, start) && imRender.worldToScreen(last, end))
				imRender.drawLine(start, end, el.m_col, 3.0f);

			last = el.m_pos;

			i++;
		}

		break;
	}
	case E2T(MovementTrail::SPLASH):
	{
		if (game::localPlayer->isMoving())
			memory::interfaces::effects->energySplash(game::localPlayer->m_vecOrigin(), {}, true);

		break;
	}
	default:
		break;
	}
}
```

`hack/cheats/features/visuals/misc/trails.hpp`:

```hpp
#pragma once

#include <cheats/classes/renderableToSurface.hpp>
#include <SDK/math/Vector.hpp>
#include <render/Color.hpp>

class Trails : protected RenderableSurfaceType
{
public:
	constexpr Trails() :
		RenderableSurfaceType{}
	{}

protected:
	virtual void draw() override;
private:
	struct Trail_t
	{
		Vec3 m_pos;
		float m_expire;
		Color m_col;
	};

	std::vector<Trail_t> m_trails;
};

GLOBAL_FEATURE(Trails);

```

`hack/cheats/features/visuals/player/boxes.cpp`:

```cpp
#include "boxes.hpp"

#include <SDK/CGlobalVars.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <config/vars.hpp>
#include <render/render.hpp>
#include <utilities/math/math.hpp>

void BoxesDraw::drawBox2D(const Box& box, bool isDormant, float dormacyAlpha)
{
	Color color = isDormant
		? vars::visuals->esp->boxes->color().getColorEditAlpha(dormacyAlpha)
		: vars::visuals->esp->boxes->color();

	Color outlineCol = isDormant
		? Colors::Black.getColorEditAlpha(dormacyAlpha)
		: Colors::Black.getColorEditAlpha(color.a());

	bool outlined = vars::visuals->esp->boxes->outline;

	if (outlined)
	{
		imRender.drawRect(box.x - 1.0f, box.y - 1.0f, box.w + 2.0f, box.h + 2.0f, outlineCol);
		imRender.drawRect(box.x + 1.0f, box.y + 1.0f, box.w - 2.0f, box.h - 2.0f, outlineCol);
	}
	imRender.drawRect(box.x, box.y, box.w, box.h, color);
}


void BoxesDraw::drawBox2DFilled(const Box& box, bool isDormant, float dormacyAlpha)
{
	Color fill = isDormant
		? vars::visuals->esp->boxes->fill().getColorEditAlpha(dormacyAlpha)
		: vars::visuals->esp->boxes->fill();

	if (!vars::visuals->esp->boxes->multiColor)
		imRender.drawRectFilled(box.x, box.y, box.w, box.h, fill);
	else
	{
		float speed = vars::visuals->esp->boxes->multiColorSpeed;
		float time = memory::interfaces::globalVars->m_curtime;

		float alpha = fill.a();

		imRender.drawRectFilledMultiColor(box.x, box.y, box.w, box.h,
			Color::rainbowColor(time, speed).getColorEditAlpha(alpha),
			Color::rainbowColor(time + 1.0f, speed).getColorEditAlpha(alpha),
			Color::rainbowColor(time + 2.0f, speed).getColorEditAlpha(alpha),
			Color::rainbowColor(time + 3.0f, speed).getColorEditAlpha(alpha));
	}
	drawBox2D(box, isDormant, dormacyAlpha);
}

static ImVec2 operator-(const ImVec2& v, float val)
{
	return ImVec2{ v.x - val, v.y - val };
}

static ImVec2 operator+(const ImVec2& v, float val)
{
	return ImVec2{ v.x + val, v.y + val };
}

void BoxesDraw::drawBox3DFilled(const Box& box, bool isDormant, float dormacyAlpha, float thickness)
{
	Color fill = isDormant
		? vars::visuals->esp->boxes->fill().getColorEditAlpha(dormacyAlpha)
		: vars::visuals->esp->boxes->fill();

	bool outlined = /*config.get<bool>(vars.bBoxOutlined)*/ false; // looks bad on 3d

	auto maybeScanned = math::grahamScan(box.points);
	if (!maybeScanned.has_value())
		return;

	auto points = maybeScanned.value();

	std::reverse(points.begin(), points.end());
	imRender.drawPolyGon(points, fill);

	drawBox3D(box, isDormant, dormacyAlpha, thickness);
}

void BoxesDraw::drawBox3DFilledMultiColor(const Box& box, bool isDormant, float dormacyAlpha, float thickness)
{
	Color fill = isDormant
		? vars::visuals->esp->boxes->fill().getColorEditAlpha(dormacyAlpha)
		: vars::visuals->esp->boxes->fill();

	bool outlined = /*config.get<bool>(vars.bBoxOutlined)*/ false;

	float speed = vars::visuals->esp->boxes->multiColorSpeed;
	float time = memory::interfaces::globalVars->m_curtime;

	float alpha = fill.a();

	std::vector colors =
	{
		Color::U32(Color::rainbowColor(time, speed).getColorEditAlpha(alpha)),
		Color::U32(Color::rainbowColor(time + 1.0f, speed).getColorEditAlpha(alpha)),
		Color::U32(Color::rainbowColor(time + 2.0f, speed).getColorEditAlpha(alpha)),
		Color::U32(Color::rainbowColor(time + 3.0f, speed).getColorEditAlpha(alpha)),
		Color::U32(Color::rainbowColor(time + 4.0f, speed).getColorEditAlpha(alpha)),
		Color::U32(Color::rainbowColor(time + 5.0f, speed).getColorEditAlpha(alpha)),
	};

	auto maybeScanned = math::grahamScan(box.points);
	if (!maybeScanned.has_value())
		return;

	auto points = maybeScanned.value();

	size_t delta = colors.size() - points.size();
	std::reverse(points.begin(), points.end());
	imRender.drawPolyGonMultiColor(points, colors); // any way to make it smooth trnasmition in vertex? I couldn't think of

	drawBox3D(box, isDormant, dormacyAlpha, thickness);
}

void BoxesDraw::drawBox3D(const Box& box, bool isDormant, float dormacyAlpha, float thickness)
{
	Color color = isDormant
		? vars::visuals->esp->boxes->color().getColorEditAlpha(dormacyAlpha)
		: vars::visuals->esp->boxes->color();

	bool outlined = /*config.get<bool>(vars.bBoxOutlined)*/ false;

	Color outlineCol = isDormant
		? Colors::Black.getColorEditAlpha(dormacyAlpha)
		: Colors::Black.getColorEditAlpha(color.a());

	for (size_t i = 1; i < 5; i++)
	{
		// BOTTOM 0,1,2,3
		imRender.drawLine(box.points.at(i - 1), box.points.at(i % 4), color, thickness);
		if (outlined)
			imRender.drawLine(box.points.at(i - 1) + 1.0f - thickness, box.points.at(i % 4) + 1.0f - thickness, outlineCol);
		// TOP 4,5,6,7
		imRender.drawLine(box.points.at(i + 3), box.points.at(i % 4 + 4), color, thickness);
		if (outlined)
			imRender.drawLine(box.points.at(i + 3) + 1.0f - thickness, box.points.at(i % 4 + 4) + 1.0f - thickness, outlineCol);
		// MISSING TOP
		imRender.drawLine(box.points.at(i - 1), box.points.at(i + 3), color, thickness);
		if (outlined)
			imRender.drawLine(box.points.at(i - 1) + 1.0f - thickness, box.points.at(i + 3) + 1.0f - thickness, outlineCol);
	}
}

```

`hack/cheats/features/visuals/player/boxes.hpp`:

```hpp
#pragma once

#include <cheats/classes/base.hpp>

struct Box;

struct BoxesDraw
{
	static void drawBox2D(const Box& box, bool isDormant, float dormacyAlpha);
	static void drawBox2DFilled(const Box& box, bool isDormant, float dormacyAlpha);
	static void drawBox3D(const Box& box, bool isDormant, float dormacyAlpha, float thickness = 1.0f);
	static void drawBox3DFilled(const Box& box, bool isDormant, float dormacyAlpha, float thickness = 1.0f);
	static void drawBox3DFilledMultiColor(const Box& box, bool isDormant, float dormacyAlpha, float thickness = 1.0f);
};

```

`hack/cheats/features/visuals/player/dormacy.hpp`:

```hpp
#pragma once

#include <SDK/CCSGO_HudRadar.hpp>

#include <array>

// TODO
//class Dormacy
//{
//private:
//	struct DormacyInfo_t
//	{
//		float m_alpha;
//		Vec3 m_lastPos;
//		float m_lastUpdate;
//		bool m_valid;
//
//		bool isValid() const;
//	};
//public:
//	DormacyInfo_t getDormacy();
//private:
//	std::array<DormacyInfo_t, 65> m_players;
//	std::array<float, 65> m_alpha;
//};
```

`hack/cheats/features/visuals/player/enemyWarn.cpp`:

```cpp
#include "enemyWarn.hpp"

#include <SDK/ICvar.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/IEngineTrace.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <SDK/structs/Entity.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <utilities/math/math.hpp>
#include <render/render.hpp>
#include <utilities/tools/tools.hpp>


void EnemyWarning::init()
{
	m_scale = memory::interfaces::cvar->findVar(XOR("weapon_recoil_scale"));
}

std::pair<bool, bool> EnemyWarning::check(Player_t* ent)
{
	if (!vars::misc->aimWarn->enabled)
		return { false, false };

	if (!game::isAvailable())
		return { false, false };

	auto posDelta = ent->getEyePos() - game::localPlayer->getEyePos();
	/*Vector idealAimAngle = math::vectorToAngle(posDelta);

	idealAimAngle -= ent->m_aimPunchAngle() * m_scale->getFloat();

	Vector curEnemyAngle = ent->m_angEyeAngles();
	curEnemyAngle.normalize();*/

	auto forward = math::angleVec(game::localPlayer->m_angEyeAngles());
	// yeah that's hardcoded and not 100% accurate, I thought of something like in radar as "fov view", but we can't be sure if enemy uses fov changer
	bool isBehind = posDelta.dot(forward) < 15.0f;

	bool check = ent->isPossibleToSee(game::localPlayer(), game::localPlayer->getEyePos()) && !isBehind;

	// dynamic fov
	// float fov = math::calcFovReal(ent->getEyePos(), game::localPlayer->getBonePos(3), curEnemyAngle); // 3 is middle body

	Trace_t trace;
	TraceFilter filter{ ent };
	const auto eye = ent->getEyePos();
	constexpr float range = 8192.0f; // because we need max range possible
	const auto end = eye + (math::angleVec(ent->m_angEyeAngles()) * range);
	memory::interfaces::trace->traceRay({ eye, end }, MASK_PLAYER, &filter, &trace);

	bool checkAim = trace.m_hitgroup != 0;

	return { check, checkAim };
}

void EnemyWarning::draw(const std::pair<bool, bool>& checks)
{
	if(checks.first) // trace
		imRender.text(globals::screenX / 2.0f, 60.0f, ImFonts::tahoma14, XOR("Enemy can see you"), true, Colors::Green);
	if(checks.second) // dynamic fov
		imRender.text(globals::screenX / 2.0f, 80.0f, ImFonts::tahoma14, XOR("Enemy is aiming you"), true, Colors::Red);
}
```

`hack/cheats/features/visuals/player/enemyWarn.hpp`:

```hpp
#pragma once

#include <cheats/classes/onlyInit.hpp>

#include <utility>

class Player_t;
class IConVar;

class EnemyWarning : protected OnlyInitType
{
public:
	constexpr EnemyWarning() :
		OnlyInitType{}
	{}

	std::pair<bool, bool> check(Player_t* ent);
	void draw(const std::pair<bool, bool>& checks);
protected:
	virtual void init() override;
private:
	IConVar* m_scale;
};

GLOBAL_FEATURE(EnemyWarning);

```

`hack/cheats/features/visuals/player/player.cpp`:

```cpp
#include "player.hpp"

#include "boxes.hpp"
#include "enemyWarn.hpp"
#include "sounds.hpp"
#include "../../aimbot/aimbot.hpp"
#include "../../backtrack/backtrack.hpp"
#include "../../events/events.hpp"
#include "../../cache/cache.hpp"

#include <SDK/CGlobalVars.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/IVModelInfo.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/IVEffects.hpp>
#include <SDK/IGameEvent.hpp>
#include <SDK/IViewRenderBeams.hpp>
#include <SDK/animations.hpp>
#include <SDK/ICvar.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/IWeapon.hpp>
#include <SDK/structs/Entity.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <config/vars.hpp>
#include <cheats/game/game.hpp>
#include <render/render.hpp>
#include <utilities/math/math.hpp>
#include <cheats/game/globals.hpp>

#include <ranges>

void PlayerVisuals::init()
{
	events::add(XOR("round_prestart"), std::bind(&PlayerVisuals::resetDormacy, this, std::placeholders::_1));
}

void PlayerVisuals::draw()
{
	if (!vars::visuals->esp->boxes->enabled)
		return;

	if (!game::isAvailable())
		return;

	bool drawDead = vars::visuals->esp->checks->dead;

	std::pair<bool, bool> warnChecks = { false, false };

	bool isFlashOk = true;
	if (game::localPlayer->m_flFlashDuration() > 0.0f)
	{
		if (game::localPlayer->m_flFlashBangTime() >= vars::visuals->esp->checks->flashLimit)
			isFlashOk = false;
	}

	for (auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::PLAYER))
	{
		auto ent = reinterpret_cast<Player_t*>(entity);

		if (ent == game::localPlayer)
			continue;

		if (!ent->isAlive())
			continue;

		if (!ent->isOtherTeam(game::localPlayer()))
			continue;

		updateDormacy(ent);

		if (m_calledEvent)
			continue;

		if (!m_dormant.at(idx).isValid())
			continue;

		// not going to render targets that are too far away
		if (game::localPlayer->absOrigin().distToMeters(entity->absOrigin()) > 150.0f)
			continue;

		auto runFeatures = [=]()
		{
			if (vars::visuals->esp->checks->visible
				&& !game::localPlayer->isPossibleToSee(ent, ent->getHitboxPos(HITBOX_HEAD)))
				return;

			if (vars::visuals->esp->checks->visible
				&& game::localPlayer->isViewInSmoke(ent->getHitboxPos(HITBOX_BELLY)))
				return;

			if (!isFlashOk)
				return;

			drawPlayer(ent);
			drawSkeleton(ent);
			runDLight(ent);
			drawLaser(ent);
			SoundDraw::findBest(ent);
		};

		if (drawDead)
		{
			if (!game::localPlayer->isAlive())
				runFeatures();
		}
		else
			runFeatures();

		warnChecks = g_EnemyWarning->check(ent);
	}
	SoundDraw::draw();
	g_EnemyWarning->draw(warnChecks);
}

void PlayerVisuals::drawHealth(Player_t* ent, const Box& box)
{
	if (!vars::visuals->esp->healthBar->enabled)
		return;

	constexpr int maxHealth = 100;
	constexpr float frequency = maxHealth * (1.0f / 0.5f);

	auto& health = m_health.at(ent->getIndex());
	const auto realHealth = ent->m_iHealth();
	if (health > realHealth)
		health -= frequency * memory::interfaces::globalVars->m_frametime;
	else
		health = static_cast<float>(realHealth);

	const auto offset = health * box.h / maxHealth;
	const auto pad = box.h - offset;

	Box newBox =
	{
		box.x - 5.0f,
		box.y,
		2.0f,
		box.h,
	};

	// fill first
	imRender.drawRoundedRectFilled(newBox.x - 1.0f, newBox.y - 1.0f, 4.0f, newBox.h + 2.0f, 120.0f, Colors::Black.getColorEditAlpha(m_dormant.at(ent->getIndex()).m_alpha));
	imRender.drawRoundedRectFilled(newBox.x, newBox.y + pad, 2.0f, offset, 120.0f, Color::healthBased(ent->m_iHealth()).getColorEditAlpha(m_dormant.at(ent->getIndex()).m_alpha));

	// if the player has health below max, then draw HP info
	if (health < 100)
	{
		auto text = FORMAT(XOR("{}"), realHealth);
		float fontSize = game::getScaledFont(ent->absOrigin(), game::localPlayer->absOrigin(), 100.0f, 10.0f, 14.0f);
		auto size = ImFonts::franklinGothic12->CalcTextSizeA(fontSize, std::numeric_limits<float>::max(), 0.0f, text.c_str());

		imRender.text(newBox.x - 4.0f - size.x, newBox.y + pad - 4.0f,
			fontSize, ImFonts::franklinGothic12, text, false, Colors::White.getColorEditAlpha(m_dormant.at(ent->getIndex()).m_alpha));
	}
}

void PlayerVisuals::drawArmor(Player_t* ent, const Box& box)
{
	if (!vars::visuals->esp->armorBar->enabled)
		return;
	
	constexpr int maxArmor = 100;
	constexpr float frequency = maxArmor * (1.0f / 0.5f);
	auto& armor = m_armor.at(ent->getIndex());
	const auto realArmor = ent->m_ArmorValue();

	if (armor > realArmor)
		armor -= frequency * memory::interfaces::globalVars->m_frametime;
	else
		armor = static_cast<float>(realArmor);

	const auto offset = armor * box.h / maxArmor;
	const auto pad = box.h - offset;

	Box newBox =
	{
		box.x + box.w + 3.0f,
		box.y,
		2.0f,
		box.h,
	};

	Color armorCol = Color(0, static_cast<int>(armor * 1.4f), 255); // light to blue, something simple

	if (armor != 0)
	{
		imRender.drawRoundedRectFilled(newBox.x - 1.0f, newBox.y - 1.0f, 4.0f, newBox.h + 2.0f, 120.0f, Colors::Black.getColorEditAlpha(m_dormant.at(ent->getIndex()).m_alpha));
		imRender.drawRoundedRectFilled(newBox.x, newBox.y + pad, 2.0f, offset, 120.0f, armorCol.getColorEditAlpha(m_dormant.at(ent->getIndex()).m_alpha));
	}

	/*if (armor < 100 && armor != 0)
		imRender.text(newBox.x - 2.0f, newBox.y + pad - 4.0f,
			ImFonts::franklinGothic, std::format(XOR("{}"), realArmor), false, Colors::White);*/
}

#include <SDK/ILocalize.hpp>

void PlayerVisuals::drawWeapon(Player_t* ent, const Box& box)
{
	if (!vars::visuals->esp->weaponBar->enabled)
		return;

	auto weapon = ent->getActiveWeapon();
	if (!weapon)
		return;

	Color tex = vars::visuals->esp->weaponBar->text();

	int maxAmmo = weapon->getWpnInfo()->m_maxClip1;
	int currentAmmo = weapon->m_iClip1();

	imRender.text(box.x + box.w / 2, box.y + box.h + 5, ImFonts::franklinGothic12, FORMAT(XOR("{} {}/{}"),
		vars::visuals->esp->weaponBar->translate ? memory::interfaces::localize->findAsUTF8(weapon->getWpnInfo()->m_WeaponName) : ent->getActiveWeapon()->getWpnName(), currentAmmo, maxAmmo),
		true, tex.getColorEditAlpha(m_dormant.at(ent->getIndex()).m_alpha));

	// skip useless trash for calculations
	if (weapon->isNonAimable())
		return;

	Box newBox =
	{
		box.x,
		box.y + box.h + 3.0f,
		box.w + 2.0f,
		2.0f
	};

	float barWidth = currentAmmo * box.w / maxAmmo;
	bool isReloading = false;
	auto animlayer = ent->getAnimOverlays()[1];

	if (animlayer.m_sequence)
	{
		auto sequenceActivity = ent->getSequenceActivity(animlayer.m_sequence);
		isReloading = sequenceActivity == 967 && animlayer.m_weight; // ACT_CSGO_RELOAD

		if (isReloading && animlayer.m_weight != 0.0f && animlayer.m_cycle < 0.99f)
			barWidth = (animlayer.m_cycle * box.w) / 1.0f;
	}

	imRender.drawRectFilled(newBox.x - 1.0f, newBox.y - 1.0f, newBox.w, 4.0f, Colors::Black.getColorEditAlpha(m_dormant.at(ent->getIndex()).m_alpha));
	imRender.drawRectFilled(newBox.x, newBox.y, barWidth, 2.0f, vars::visuals->esp->weaponBar->bar().getColorEditAlpha(m_dormant.at(ent->getIndex()).m_alpha));
}

void PlayerVisuals::drawInfo(Player_t* ent, const Box& box)
{
	std::vector<std::pair<std::string, Color>> flags = {};
	using cont = std::vector<bool>; // container

	PlayerInfo_t info = {};
	if (!memory::interfaces::engine->getPlayerInfo(ent->getIndex(), &info))
		return;

	auto cfgflags = vars::visuals->esp->flags->flags;

	if (cfgflags.at(E2T(EspFlags::BOT)))
		if(info.m_fakePlayer)
			flags.emplace_back(std::make_pair(XOR("BOT"), Colors::Yellow.getColorEditAlpha(m_dormant.at(ent->getIndex()).m_alpha)));

	if (cfgflags.at(E2T(EspFlags::MONEY)))
		flags.emplace_back(std::make_pair(FORMAT(XOR("{}$"), ent->m_iAccount()), Colors::Green.getColorEditAlpha(m_dormant.at(ent->getIndex()).m_alpha)));

	if (cfgflags.at(E2T(EspFlags::WINS)))
		flags.emplace_back(std::make_pair(FORMAT(XOR("Wins {}"), ent->getWins()), Colors::Green.getColorEditAlpha(m_dormant.at(ent->getIndex()).m_alpha)));

	if (cfgflags.at(E2T(EspFlags::RANK)))
		flags.emplace_back(std::make_pair(FORMAT(XOR("Rank {}"), ent->getRank()), Colors::White.getColorEditAlpha(m_dormant.at(ent->getIndex()).m_alpha)));

	if (cfgflags.at(E2T(EspFlags::ARMOR)))
	{
		std::string text = "";
		if (ent->m_bHasHelmet() && ent->m_ArmorValue())
			text = XOR("H KEV");
		else if (!ent->m_bHasHelmet() && ent->m_ArmorValue())
			text = XOR("KEV");

		flags.emplace_back(std::make_pair(text, Colors::White));
	}

	if (cfgflags.at(E2T(EspFlags::ZOOM)))
		if(ent->m_bIsScoped())
			flags.emplace_back(std::make_pair(XOR("ZOOM"), Colors::White.getColorEditAlpha(m_dormant.at(ent->getIndex()).m_alpha)));

	if (cfgflags.at(E2T(EspFlags::C4)))
		if (ent->isC4Owner())
			flags.emplace_back(std::make_pair(XOR("C4"), Colors::Orange.getColorEditAlpha(m_dormant.at(ent->getIndex()).m_alpha)));

	float fontSize = game::getScaledFont(ent->absOrigin(), game::localPlayer()->absOrigin(), 60.0f, 11.0f, 16.0f);

	float padding = 0.0f;
	float addon = vars::visuals->esp->armorBar->enabled ? 6.0f : 0.0f;

	for (size_t i = 0; const auto & [name, color] : flags)
	{
		imRender.text(box.x + box.w + addon + 2.0f, box.y + padding, fontSize, ImFonts::verdana12, name, false, color, false);
		auto textSize = ImFonts::verdana12->CalcTextSizeA(fontSize, std::numeric_limits<float>::max(), 0.0f, name.c_str());
		padding += textSize.y;
		i++;

		if (i != flags.size() && padding + fontSize > box.h) // when too many flags for long distances
		{
			imRender.text(box.x + box.w + addon + 2.0f, box.y + padding, fontSize, ImFonts::verdana12,
				FORMAT(XOR("{} more..."), flags.size() - i), false, Colors::White.getColorEditAlpha(m_dormant.at(ent->getIndex()).m_alpha), false);
			break;
		}
	}
}

void PlayerVisuals::drawnName(Player_t* ent, const Box& box)
{
	if (!vars::visuals->esp->nameBar->enabled)
		return;

	float fontSize = game::getScaledFont(ent->absOrigin(), game::localPlayer()->absOrigin());

	imRender.text(box.x + box.w / 2.0f, box.y - fontSize - 2.0f, fontSize, ImFonts::verdana12, ent->getName(), true,
		Color::healthBased(ent->m_iHealth()).getColorEditAlpha(m_dormant.at(ent->getIndex()).m_alpha), false);
}

// yoinked: https://www.unknowncheats.me/wiki/Counter_Strike_Global_Offensive:Bone_ESP
void PlayerVisuals::drawSkeleton(Player_t* ent)
{
	if (!vars::visuals->esp->skeleton->enabled)
		return;

	auto model = ent->getModel();
	if (!model)
		return;

	auto studio = memory::interfaces::modelInfo->getStudioModel(model);
	if (!studio)
		return;

	// have to check if selected record is filled, if no then just skip
	auto record = !g_Backtrack->getAllRecords().at(ent->getIndex()).empty() ? &g_Backtrack->getAllRecords().at(ent->getIndex()) : nullptr;
	auto skeletPos = [=](const size_t idx)
	{
		auto child = record != nullptr
			? record->back().m_matrix[idx].origin()
			: ent->getBonePos(idx);
		return child;
	};

	// bone IDs
	constexpr auto chest = 6;
	constexpr auto lowerChest = 5;

	for (auto i : std::views::iota(0, studio->m_bonesCount))
	{
		auto bone = studio->getBone(i);
		if (!bone)
			continue;

		if (bone->m_parent == -1)
			continue;

		if (!(bone->m_flags & BONE_USED_BY_HITBOX))
			continue;

		if (record && !g_Backtrack->isValid(record->front().m_simtime)) // if backtrack
			continue;

		auto child = skeletPos(i);
		auto parent = skeletPos(bone->m_parent);
		auto chestbone = skeletPos(chest);
		auto upper = skeletPos(chest + 1) - chestbone;
		auto breast = chestbone + upper / 2.0f;

		auto deltachild = child - breast;
		auto deltaparent = parent - breast;

		if (deltaparent.length() < 9.0f && deltachild.length() < 9.0f)
			parent = breast;

		if (i == lowerChest)
			child = breast;

		if (std::abs(deltachild[Coord::Z]) < 5.0f && deltaparent.length() < 5.0f && deltachild.length() < 5.0f || i == chest)
			continue;

		if (vars::visuals->esp->skeleton->showDebug)
		{
			if (ImVec2 s; imRender.worldToScreen(ent->getBonePos(i), s))
				imRender.text(s.x, s.y, ImFonts::franklinGothic12, FORMAT(XOR("{}"), i), true, Colors::White, true);
		}

		if (ImVec2 start, end; imRender.worldToScreen(parent, start) && imRender.worldToScreen(child, end))
			imRender.drawLine(start, end, vars::visuals->esp->skeleton->color().getColorEditAlpha(m_dormant.at(ent->getIndex()).m_alpha));
	}
}

void PlayerVisuals::drawSnapLine(Player_t* ent, const Box& box)
{
	if (ent == g_Aimbot->getTargetted())
	{
		// lines on the bottom and center bottom box
		imRender.drawLine(globals::screenX / 2.0f, static_cast<float>(globals::screenY), box.x + box.w / 2, box.y + box.h, Colors::Purple);
	}
}

void PlayerVisuals::drawLaser(Player_t* ent)
{
	if (!vars::visuals->esp->lasers->enabled)
		return;

	// get from where to start, "laser ESP" is always starting from head I think
	auto start = ent->getBonePos(8);
	// get angle to draw with correct view
	auto forward = math::angleVec(ent->m_angEyeAngles());
	// end is where lines just ends, this 70 is hardcoded, but whatever here tbh
	auto end = start + forward * 70.f;

	if (ImVec2 startP, endLine; imRender.worldToScreen(start, startP) && imRender.worldToScreen(end, endLine))
	{
		imRender.drawCircleFilled(startP.x, startP.y, 3, 32, Colors::Red);
		imRender.drawLine(startP, endLine, Colors::Purple.getColorEditAlpha(m_dormant.at(ent->getIndex()).m_alpha));
	}
}

void PlayerVisuals::runDLight(Player_t* ent)
{
	// https://github.com/ValveSoftware/source-sdk-2013/blob/0d8dceea4310fde5706b3ce1c70609d72a38efdf/sp/src/game/client/c_spotlight_end.cpp#L112

	if (!vars::visuals->esp->dlight->enabled)
		return;

	auto dLight = memory::interfaces::efx->clAllocDLight(ent->getIndex());
	dLight->m_color = vars::visuals->esp->dlight->color();
	dLight->m_origin = ent->m_vecOrigin();
	dLight->m_radius = vars::visuals->esp->dlight->radius;
	dLight->m_die = memory::interfaces::globalVars->m_curtime + 0.1f;
	dLight->m_exponent = static_cast<char>(vars::visuals->esp->dlight->exponent);
	dLight->m_decay = vars::visuals->esp->dlight->decay;
	dLight->m_key = ent->getIndex();
}

void PlayerVisuals::drawPlayer(Player_t* ent)
{
	if (!vars::visuals->esp->boxes->enabled)
		return;

	Box box{ent};
	if (!box.isValid())
		return;

	constexpr float maxDist = 100.0f; // start fade
	constexpr float closeLimit = 5.0f; // don't draw too close
	float dist = game::localPlayer->absOrigin().distToMeters(m_dormant.at(ent->getIndex()).m_lastPos);
	float ratio = (dist - closeLimit) / maxDist;
	ratio = std::clamp(ratio, 0.0f, 0.45f); // clamp it to lower alpha

	// if dormacy is fade upadting, then use this alpha
	if (auto dormacyA = m_dormant.at(ent->getIndex()).m_alpha; dormacyA > ratio)
		m_boxAlpha.at(ent->getIndex()) = dormacyA;
	else // if not, use distance fade logic
	{
		float ratioDormant = 1.0f / (1.0f / vars::visuals->dormacy->time);
		float step = ratioDormant * memory::interfaces::globalVars->m_frametime;

		m_boxAlpha.at(ent->getIndex()) += step;
		m_boxAlpha.at(ent->getIndex()) = std::clamp(m_boxAlpha.at(ent->getIndex()), 0.0f, ratio);
	}

	bool isDormant = ent->isDormant();

	switch (vars::visuals->esp->boxes->mode)
	{
	case E2T(BoxTypes::BOX2D):
		BoxesDraw::drawBox2D(box, isDormant, m_boxAlpha.at(ent->getIndex()));
		break;
	case E2T(BoxTypes::FILLED2D):
		BoxesDraw::drawBox2DFilled(box, isDormant, m_boxAlpha.at(ent->getIndex()));
		break;
	case E2T(BoxTypes::BOX3D):
		BoxesDraw::drawBox3D(box, isDormant, m_boxAlpha.at(ent->getIndex()));
		break;
	case E2T(BoxTypes::FILLED3D):
	{
		if (!vars::visuals->esp->boxes->multiColor)
			BoxesDraw::drawBox3DFilled(box, isDormant, m_boxAlpha.at(ent->getIndex()));
		else
			BoxesDraw::drawBox3DFilledMultiColor(box, isDormant, m_boxAlpha.at(ent->getIndex()));
		break;
	}
	default:
		break;
	}

	drawHealth(ent, box);
	drawArmor(ent, box);
	drawWeapon(ent, box);
	drawInfo(ent, box);
	drawSnapLine(ent, box);
	drawnName(ent, box);
}

void PlayerVisuals::updateDormacy(Player_t* ent)
{
	auto& dormacy = m_dormant.at(ent->getIndex());

	float ratio = 1.0f / vars::visuals->dormacy->time;
	float step = ratio * memory::interfaces::globalVars->m_frametime;

	if (ent->isDormant())
	{
		dormacy.m_alpha -= step;
		ent->setAbsOrigin(ent->absOrigin());
	}
	else
	{
		m_calledEvent = false; // to remove problems on round restarts
		dormacy.m_lastPos = ent->absOrigin();
		dormacy.m_alpha += step;
		dormacy.m_lastUpdate = memory::interfaces::globalVars->m_curtime;
	}

	dormacy.m_alpha = std::clamp(dormacy.m_alpha, 0.0f, 1.0f);
}

bool PlayerVisuals::DormacyInfo_t::isValid() const
{
	return memory::interfaces::globalVars->m_curtime - m_lastUpdate < vars::visuals->dormacy->limit;
}

void PlayerVisuals::resetDormacy(IGameEvent* event)
{
	m_calledEvent = true;
}
```

`hack/cheats/features/visuals/player/player.hpp`:

```hpp
#pragma once

#include <cheats/classes/renderableToSurface.hpp>
#include <SDK/math/Vector.hpp>
#include <SDK/math/Vector.hpp>

#include <array>
#include <deque>

struct Box;
class IGameEvent;
class Player_t;
class Entity_t;
struct Box3D;
class Color;

class PlayerVisuals : protected RenderableSurfaceType
{
public:
	constexpr PlayerVisuals() :
		RenderableSurfaceType{}
	{}

protected:
	virtual void draw() override;
	virtual void init() override;
private:
	void drawInfo(Player_t* ent, const Box& box);
	void drawnName(Player_t* ent, const Box& box);
	void drawPlayer(Player_t* ent);
	void runDLight(Player_t* ent);
	void drawHealth(Player_t* ent, const Box& box);
	void drawArmor(Player_t* ent, const Box& box);
	void drawWeapon(Player_t* ent, const Box& box);
	void drawSkeleton(Player_t* ent);
	void drawSnapLine(Player_t* ent, const Box& box);
	void drawLaser(Player_t* ent);
	void resetDormacy([[maybe_unused]] IGameEvent* event);
	void updateDormacy(Player_t* ent);

	std::array<float, 65> m_health;
	std::array<float, 65> m_armor;

	struct DormacyInfo_t
	{
		float m_alpha;
		Vec3 m_lastPos;
		float m_lastUpdate;
		bool m_calledEvent;

		bool isValid() const;
	};

	// for everything except boxes
	std::array<DormacyInfo_t, 65> m_dormant;
	std::array<float, 65> m_boxAlpha;

	bool m_calledEvent; // for dormacy resets
};

GLOBAL_FEATURE(PlayerVisuals);

```

`hack/cheats/features/visuals/player/sounds.cpp`:

```cpp
#include "sounds.hpp"

#include "../../events/events.hpp"

#include <SDK/CGlobalVars.hpp>
#include <SDK/IGameEvent.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <SDK/structs/Entity.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <render/render.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>

// https://www.unknowncheats.me/forum/counterstrike-global-offensive/333825-bloodhound-inspired-legit-csgo-esp.html
void SoundDraw::findBest(Player_t* ent)
{
	if (!vars::visuals->sound->enabled)
		return;

	int index = ent->getIndex();

	float x = globals::screenX / 2.0f;
	float y = globals::screenY / 2.0f;
	float maxDist = vars::visuals->sound->maxDist;
	float maxDistLine = vars::visuals->sound->maxDistLine;

	for (size_t i = 0; const auto & el : m_steps.at(index))
	{
		float diff = el.m_expire - memory::interfaces::globalVars->m_curtime;

		if (diff < 0.0f)
		{
			m_steps.at(index).erase(m_steps.at(index).begin() + i);
			continue;
		}

		ImVec2 elPos;
		if (!imRender.worldToScreen(el.m_pos, elPos))
			continue;

		//float scale = diff / config.get<float>(vars.fStepTime); // ratio
		float alpha = (maxDist - el.m_pos.distToMeters(game::localPlayer->absOrigin())) / maxDist; // alpha fading per distance
		if (alpha < 0.1f)
			continue;

		if (constexpr float maxDiff = 1.0f; diff < maxDiff) // fading effect
			alpha = (diff / maxDiff) * alpha;

		// again same thing, I don't want to use ent origin but current pos
		auto scaledFont = [=](const float division = 80.0f, const float min = 12.0f, const float max = 30.0f)
		{
			float dist = el.m_pos.distTo(game::localPlayer->absOrigin());
			float fontSize = std::clamp(division / (dist / division), min, max);
			return fontSize;
		};

		float rad = scaledFont(50.0f, 3.0f, 8.0f);
		imRender.drawCircleFilled(elPos.x, elPos.y, rad, 32,
			vars::visuals->sound->color().getColorEditAlpha(alpha));

		float distFromMiddle = std::round(std::sqrt((elPos.x - x) * (elPos.x - x) + (elPos.y - y) * (elPos.y - y)));

		if (distFromMiddle < maxDistLine)
		{
			if (!m_bestStep.m_player || distFromMiddle < m_bestStep.m_maxPixels)
			{
				m_bestStep.m_player = el.m_player;
				m_bestStep.m_pos = el.m_pos;
				m_bestStep.m_timeToPrint = diff;
				m_bestStep.m_maxPixels = distFromMiddle;
				// better not
				/*bestStep.m_fontSize = scaledFont(50.0f, 10.0f, 18.0f);*/
			}
		}

		i++;
	}
}

void SoundDraw::draw()
{
	float x = globals::screenX / 2.0f;
	float y = globals::screenY / 2.0f;

	if (m_bestStep.m_player)
	{
		if (ImVec2 pos; imRender.worldToScreen(m_bestStep.m_pos, pos))
		{
			std::string_view place = m_bestStep.m_player->m_szLastPlaceName();
			if (place.empty())
				place = XOR("Unknown");
			std::string nameText = FORMAT(XOR("{} -> {} [{:.1f}m]"), m_bestStep.m_player->getName(),
				place, game::localPlayer->absOrigin().distToMeters(m_bestStep.m_pos));
			std::string timeText = FORMAT(XOR("Time left {:.1f}s"), m_bestStep.m_timeToPrint);

			x = globals::screenX / 2.5f;

			float textSize = std::max(
				imRender.getTextSize(ImFonts::tahoma14, timeText).x,
				imRender.getTextSize(ImFonts::tahoma14, nameText).x);

			static float fontSize = ImFonts::tahoma14->FontSize + 2.0f;

			imRender.text(x, y, ImFonts::tahoma14, timeText, false, Colors::White);
			imRender.text(x, y - fontSize, ImFonts::tahoma14, nameText, false, Colors::White);
			imRender.drawLine(x, y, x + textSize, y, vars::visuals->sound->colorLine());
			imRender.drawLine(x + textSize, y, pos.x, pos.y, vars::visuals->sound->colorLine());
		}

		m_bestStep.m_player = nullptr;
	}
}

void SoundDraw::pushSteps(Player_t* ent)
{
	if (!ent->isOtherTeam(game::localPlayer()))
		return;

	StepData_t step{ ent, ent->absOrigin(), memory::interfaces::globalVars->m_curtime + vars::visuals->sound->time };
	m_steps.at(step.m_player->getIndex()).push_back(step);
}
```

`hack/cheats/features/visuals/player/sounds.hpp`:

```hpp
#pragma once

#include <cheats/classes/onlyInit.hpp>
#include <SDK/math/Vector.hpp>

#include <array>
#include <deque>

class IGameEvent;
class Entity_t;
class Player_t;

class SoundDraw
{
public:
	static void draw();
	static void findBest(Player_t* ent);
	static void pushSteps(Player_t* ent);
private:
	struct StepData_t
	{
		StepData_t() = default;
		constexpr StepData_t(Player_t* player, const Vec3& pos, float expire)
			: m_player{ player }, m_pos{ pos }, m_expire{ expire }
		{}

		Player_t* m_player = nullptr;
		Vec3 m_pos;
		float m_expire;
		float m_maxPixels;
		float m_timeToPrint;
		float m_fontSize;
	};

	inline static std::array<std::deque<StepData_t>, 65> m_steps;
	inline static StepData_t m_bestStep;
};

```

`hack/cheats/features/visuals/plots/plots.cpp`:

```cpp
#include "plots.hpp"

#include <SDK/ICvar.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/CGlobalVars.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>
#include <menu/GUI-ImGui/animations.hpp>
#include <config/vars.hpp>
#include <utilities/utilities.hpp>
#include <render/render.hpp>
#include <utilities/console/console.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>

#include <numeric>

void Plots::draw()
{
	drawFps();
	drawVelocity();
}

void Plots::drawFps()
{
	if (!vars::misc->plots->enabledFps)
		return;

	// static so we can get records get saved
	static std::deque<float> records;

	auto getfps = []() -> float // this is how they do it
	{
		static float realfps = 0.0f;
		realfps = 0.9f * realfps + (1.0f - 0.9f) * memory::interfaces::globalVars->m_absoluteframetime;

		return 1.0f / realfps;
	};

	const float fps = getfps();
	// when loading, you have a chance of freezing
	if (std::isinf(fps))
	{
		LOG_WARN("record for plot got skipped due to infinity");
		return;
	}

	static float acceptanceCustom = 1.0f;

	records.push_back(fps);

	while (records.size() > static_cast<size_t>(RECORDS_SIZE / acceptanceCustom))
		records.pop_front();

	static float MAX_FPS = memory::interfaces::engine->isInGame() ? 350.0f : 120.0f;

	if (vars::misc->plots->fpsCustom)
	{
		if (ImGui::Begin(XOR("Sliders for plot"), &vars::misc->plots->fpsCustom, ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize))
		{
			if (memory::interfaces::engine->isInGame()) // not enaled in menu
				ImGui::Animations::SliderFloat(XOR("Set max FPS"), &MAX_FPS, 30.0f, 1000.0f, XOR("%.2f"), ImGuiSliderFlags_Logarithmic); // hardcoded ranges, we should maybe run some avg fps getter
			ImGui::Animations::SliderFloat(XOR("Acceptance multiply fps"), &acceptanceCustom, 0.2f, 20.0f, XOR("%.2f"), ImGuiSliderFlags_Logarithmic);
			ImGui::Animations::ColorPicker(XOR("Color lines plot fps"), &vars::misc->plots->colorFPS);

			ImGui::End();
		}
	}

	if (ImGui::Begin(FORMAT(XOR("Plot FPS AVG {:.2f}###Plot FPS"),
		std::reduce(records.begin(), records.end()) / records.size()).c_str(), &vars::misc->plots->enabledFps, ImGuiWindowFlags_NoCollapse))
	{
		auto& style = ImGui::GetStyle();
		const bool backupLines = style.AntiAliasedLines;
		style.AntiAliasedLines = false;
		const auto windowSize = ImGui::GetContentRegionAvail();
		const auto windowPos = ImGui::GetCursorScreenPos();
		const auto windowList = ImGui::GetWindowDrawList();

		const float acceptance = windowSize.x / static_cast<float>(RECORDS_SIZE / acceptanceCustom);
		const float scaledavg = MAX_FPS / windowSize.y;
		std::vector<ImVec2> points;
		for (size_t i = 0; const auto currentFPS : records)
		{
			const float currentX = i * acceptance;
			const float currentY = std::max(windowSize.y - (currentFPS / scaledavg), 1.0f);
			points.emplace_back(windowPos.x + currentX, windowPos.y + currentY);

			i++;
		}
		drawing::Polyline{ points, Color::U32(vars::misc->plots->colorFPS()), 0, 1.0f }.draw(windowList);
		
		style.AntiAliasedLines = backupLines;
		ImGui::End();
	}
}

void Plots::drawVelocity()
{
	if (!vars::misc->plots->enabledVelocity)
		return;

	if (!memory::interfaces::engine->isInGame() || !game::localPlayer->isAlive())
		return;

	static float MAX_SPEEED_MOVE = memory::interfaces::cvar->findVar(XOR("sv_maxspeed"))->getFloat(); // should be accurate
	static bool transparent = false;

	if (vars::misc->plots->velocityCustom)
	{
		if (ImGui::Begin(XOR("Sliders for velocity plot"), &vars::misc->plots->velocityCustom, ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize))
		{
			//ImGui::Animated::SliderFloat(XOR("Set max velocity"), &MAX_SPEEED_MOVE, 450.0f, 1000.0f, XOR("%.2f"), ImGuiSliderFlags_Logarithmic); // who will ever get this velocity? adjust if needed
			ImGui::Animations::SliderFloat(XOR("Acceptance multiply vel"), &m_acceptanceVelocity, 0.2f, 20.0f, XOR("%.2f"), ImGuiSliderFlags_Logarithmic);
			ImGui::Animations::ColorPicker(XOR("Color lines plot vel"), &vars::misc->plots->colorVelocity);
			ImGui::Animations::Checkbox(XOR("Run transparent"), &transparent);
			ImGui::SameLine();
			ImGui::HelpMarker(XOR("Will add some flags!\nEg: no resize"));

			ImGui::End();
		}
	}

	const int flags = transparent
		? ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoBackground | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize
		: ImGuiWindowFlags_NoCollapse;

	if (ImGui::Begin(FORMAT(XOR("Plot Velocity AVG {:.2f}###Plot Velocity"),
		std::reduce(m_VelocityRecords.begin(), m_VelocityRecords.end()) / m_VelocityRecords.size()).c_str(), &vars::misc->plots->enabledVelocity, flags))
	{
		auto& style = ImGui::GetStyle();
		const bool backupLines = style.AntiAliasedLines;
		style.AntiAliasedLines = false;
		const auto windowSize = ImGui::GetContentRegionAvail();
		const auto windowPos = ImGui::GetCursorScreenPos();
		const auto windowList = ImGui::GetWindowDrawList();

		const float acceptance = windowSize.x / static_cast<float>(RECORDS_SIZE / m_acceptanceVelocity);
		const float scaledavg = MAX_SPEEED_MOVE / windowSize.y;
		std::vector<ImVec2> points;
		for (size_t i = 0; const auto currentVel : m_VelocityRecords)
		{
			const float currentX = i * acceptance;
			const float currentY = std::max(windowSize.y - (currentVel / scaledavg), 1.0f);
			points.emplace_back(windowPos.x + currentX, windowPos.y + currentY);

			i++;
		}
		drawing::Polyline{ points, Color::U32(vars::misc->plots->colorVelocity()), 0, 1.0f }.draw(windowList);
		
		style.AntiAliasedLines = backupLines;
		ImGui::End();
	}
}

void VelocityGather::run(CUserCmd* cmd)
{
	if (!vars::misc->plots->enabledVelocity)
		return;

	if (!game::localPlayer)
		return;

	if (!memory::interfaces::engine->isInGame() || !game::localPlayer->isAlive())
	{
		g_Plots->m_VelocityRecords.clear();
		return;
	}

	float vel = game::localPlayer->m_vecVelocity().toVecPrev().length();
	if (std::isinf(vel))
	{
		LOG_WARN("record for plot got skipped due to infinity");
		return;
	}

	g_Plots->m_VelocityRecords.emplace_back(game::localPlayer->m_vecVelocity().toVecPrev().length());

	// width
	while (g_Plots->m_VelocityRecords.size() > static_cast<size_t>(g_Plots->RECORDS_SIZE / g_Plots->m_acceptanceVelocity))
		g_Plots->m_VelocityRecords.pop_front();
}

```

`hack/cheats/features/visuals/plots/plots.hpp`:

```hpp
#pragma once

#include <cheats/classes/renderableToPresent.hpp>
#include <cheats/classes/createMove.hpp>

#include <deque>

class VelocityGather;
class CUserCmd;

class Plots : protected RenderablePresentType
{
public:
	Plots() :
		RenderablePresentType{}
	{}

protected:
	virtual void draw() override;
private:
	void drawFps();
	void drawVelocity();

	std::deque<float> m_VelocityRecords;
	std::deque<float> m_FpsRecords;

	inline static constexpr float RECORDS_SIZE = 300.0f;
	inline static float m_acceptanceVelocity = 1.0;

	friend VelocityGather;
};

GLOBAL_FEATURE(Plots);

class VelocityGather : protected CreateMoveInPredictionType
{
public:
	constexpr VelocityGather() :
		CreateMoveInPredictionType{}
	{}

protected:
	virtual void run(CUserCmd* cmd) override;
};

GLOBAL_FEATURE(VelocityGather);

```

`hack/cheats/features/visuals/radar/radar.cpp`:

```cpp
#include "radar.hpp"

#include <cheats/features/cache/cache.hpp>

#include <SDK/IVEngineClient.hpp>
#include <SDK/CGlobalVars.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/math/Vector.hpp>
#include <SDK/MapStruct.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <render/render.hpp>
#include <utilities/math/math.hpp>
#include <utilities/res.hpp>
#include <utilities/console/console.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>

#include <imgui.h>
#include <imgui_internal.h>

#include <d3dx9.h>

ImVec2 Radar::entToRadar(const Vec3& eye, const Vec3& angles, const Vec3& entPos, const float scale, bool clipRanges)
{
	float dotThickness = vars::misc->radar->thickness;

	float directionX = entPos[Coord::X] - eye[Coord::X];
	float directionY = -(entPos[Coord::Y] - eye[Coord::Y]);

	auto yawDeg = angles[Coord::Y] - 90.0f;
	// calculate dots of radian and return correct view
	const auto yawToRadian = math::DEG2RAD(yawDeg);
	const auto cosine = std::cos(yawToRadian);
	const auto sine = std::sin(yawToRadian);
	float dotX = (directionX * cosine - directionY * sine) / 20.0f;
	float dotY = (directionX * sine + directionY * cosine) / 20.0f;
	// return correct scale, it zooms in/out depends what value is thrown
	dotX *= scale;
	dotY *= scale;

	const auto size = ImGui::GetWindowSize();

	// correct it for our center screen of rectangle radar
	dotX += size.x / 2.0f;
	dotY += size.y / 2.0f;

	// do not draw out of range, added pos, even we pass 0, but for clarity
	if (clipRanges && vars::misc->radar->ranges)
	{
		dotX = std::clamp(dotX, dotThickness, size.x - dotThickness);
		dotY = std::clamp(dotY, dotThickness, size.y - dotThickness);
	}

	const auto pos = ImGui::GetWindowPos();
	dotX += pos.x;
	dotY += pos.y;

	return ImVec2{ dotX, dotY };
}

void Radar::manuallyInitPos()
{
	if (!game::isAvailable())
		return;

	const auto map = Memory::Address<MapStruct*>{ game::findHudElement(XOR("CCSGO_MapOverview")) }.sub(0x14);
	m_pos = map->m_origin;
	m_scale = map->m_scale;

	m_inited = true;
}

bool Radar::manuallyInitTexture()
{
	if (!game::isAvailable())
		return false;

	std::string levelName = memory::interfaces::engine->getLevelName();

	// not really working for workshops
	if (auto place = levelName.rfind('/'); place != std::string::npos)
		levelName = levelName.substr(place + 1, levelName.size());

	std::string path = FORMAT(XOR("csgo\\resource\\overviews\\{}_radar.dds"), levelName);

	// prob not supported format
	/*Resource res{ path };
	if (res.getTexture())
		m_mapTexture = res.getTexture();
	else
		return false;*/

	if (auto hr = D3DXCreateTextureFromFileA(memory::interfaces::dx9Device(), path.c_str(), &m_mapTexture); hr == D3D_OK)
		LOG_INFO(XOR("Created map texture from path: {}"), path);
	else
	{
		LOG_ERR(XOR("Creating map texture from path failed, code: {}"), hr);
		return false;
	}

	return true;
}

Radar::MapPos Radar::getMapPos() const
{
	return MapPos{ m_pos, m_scale * 1000.0f };
}

void Radar::drawMap()
{
	if (!m_inited)
		manuallyInitPos();

	auto map = getMapPos();

	// square
	float size = map.m_scale;
	std::array poses =
	{
		Vec3{ m_pos[Coord::X], m_pos[Coord::Y], 0.0f },
		Vec3{ m_pos[Coord::X] + size, m_pos[Coord::Y], 0.0f },
		Vec3{ m_pos[Coord::X] + size, m_pos[Coord::Y] - size, 0.0f },
		Vec3{ m_pos[Coord::X], m_pos[Coord::Y] - size, 0.0f },
	};

	const auto myEye = game::localPlayer->getEyePos();
	Vec3 ang = {};
	memory::interfaces::engine->getViewAngles(ang);
	const float scale = vars::misc->radar->scale;

	auto p1 = entToRadar(myEye, ang, poses.at(0), scale, false);
	auto p2 = entToRadar(myEye, ang, poses.at(1), scale, false);
	auto p3 = entToRadar(myEye, ang, poses.at(2), scale, false);
	auto p4 = entToRadar(myEye, ang, poses.at(3), scale, false);

	ImGui::GetWindowDrawList()->AddImageQuad(m_mapTexture, p1, p2, p3, p4);
}

void Radar::draw()
{
	if (!vars::misc->radar->enabled)
		return;

	if (!game::localPlayer)
		return;

	if (!memory::interfaces::engine->isInGame())
		return;

	float size = vars::misc->radar->size;
	ImGui::SetNextWindowSize({ size, size });
	if (ImGui::Begin(XOR("Radar"), &vars::misc->radar->enabled, ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize))
	{
		const auto windowList = ImGui::GetWindowDrawList();
		const auto windowPos = ImGui::GetWindowPos();
		const auto windowSize = ImGui::GetWindowSize();

		const float scaledFov = globals::FOV / 5.0f;
		// assume calculation is only in straight line representing 2D, so max = 180 deg, and this is not correct in 100%, idk better solution
		const float fovAddon = windowSize.y / std::tan(math::DEG2RAD((180.0f - (globals::FOV + scaledFov)) / 2.0f));

		const float middleX = windowSize.x / 2.0f;
		const float middleY = windowSize.y / 2.0f;

		drawMap();

		drawing::TriangleFilled{
			ImVec2{ windowPos.x + middleX, windowPos.y + middleY },
			ImVec2{ windowPos.x + middleX, windowPos.y },
			ImVec2{ windowPos.x + middleX + fovAddon / 2.0f, windowPos.y },
			Color::U32(Colors::White.getColorEditAlpha(0.4f)) }.draw(windowList);

		drawing::TriangleFilled{
			ImVec2{ windowPos.x + middleX, windowPos.y + middleY },
			ImVec2{ windowPos.x + middleX, windowPos.y },
			ImVec2{ windowPos.x + middleX - fovAddon / 2.0f, windowPos.y },
			Color::U32(Colors::White.getColorEditAlpha(0.4f)) }.draw(windowList);

		drawing::Line{
			ImVec2{ windowPos.x + middleX + fovAddon / 2.0f, windowPos.y },
			ImVec2{ windowPos.x + middleX, windowPos.y + middleY },
			Color::U32(Colors::White), 1.0f }.draw(windowList);

		drawing::Line{
			ImVec2{ windowPos.x + middleX - fovAddon / 2.0f, windowPos.y },
			ImVec2{ windowPos.x + middleX, windowPos.y + middleY },
			Color::U32(Colors::White), 1.0f }.draw(windowList);

		drawing::Line{
			ImVec2{ windowPos.x + 0.0f, windowPos.y + middleY },
			ImVec2{ windowPos.x + windowSize.x, windowPos.y + middleY },
			Color::U32(Colors::White), 1.0f }.draw(windowList);

		drawing::Line{
			ImVec2{ windowPos.x + middleX, windowPos.y + 0.0f },
			ImVec2{ windowPos.x + middleX, windowPos.y + windowSize.y },
			Color::U32(Colors::White), 1.0f }.draw(windowList);

		// draw small circle where are we
		drawing::CircleFilled{ 
			ImVec2{ windowPos.x + middleX, windowPos.y + middleY },
			5.0f, 12, Color::U32(Colors::Green) }.draw(windowList);

		const auto myEye = game::localPlayer->getEyePos();
		Vec3 viewAngle = {};
		memory::interfaces::engine->getViewAngles(viewAngle);

		for(auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::PLAYER))
		{
			auto ent = reinterpret_cast<Player_t*>(entity);

			if (!ent)
				continue;

			if (ent->isDormant())
				continue;

			if (ent == game::localPlayer)
				continue;

			if (!ent->isAlive() || !game::localPlayer->isAlive())
				continue;

			if (!ent->isOtherTeam(game::localPlayer()))
				continue;

			const auto entRotatedPos = entToRadar(myEye, viewAngle, ent->absOrigin(),
				vars::misc->radar->scale, true);

			const auto entYaw = math::normalizeYaw(ent->m_angEyeAngles()[Coord::Y]);

			// or use atan2 if 270 is magic for you
			const auto rotated = 270.0f - entYaw + viewAngle[Coord::Y];
			const auto dotRad = vars::misc->radar->length;

			const auto finalX = dotRad * std::cos(math::DEG2RAD(rotated));
			const auto finalY = dotRad * std::sin(math::DEG2RAD(rotated));

			if (vars::misc->radar->ranges ? true : entRotatedPos.x != 0.0f && entRotatedPos.y != 0.0f)
			{
				const auto dotThickness = vars::misc->radar->thickness;
				const float radian = math::DEG2RAD(rotated);
				const float radian90 = math::DEG2RAD(rotated + 90);

				const ImVec2 p1 = ImVec2{ (dotThickness / 2.0f) * std::cos(radian90) + entRotatedPos.x, (dotThickness / 2.0f) * std::sin(radian90) + entRotatedPos.y };
				const ImVec2 p2 = ImVec2{ (-dotThickness / 2.0f) * std::cos(radian90) + entRotatedPos.x, (-dotThickness / 2.0f) * std::sin(radian90) + entRotatedPos.y };
				const ImVec2 p3 = ImVec2{ dotThickness * std::cos(radian) + entRotatedPos.x, dotThickness * std::sin(radian) + entRotatedPos.y };
				drawing::TriangleFilled{ p1, p2, p3, Color::U32(vars::misc->radar->colorPlayer()) }.draw(windowList);
				drawing::Line{ p3, { p3.x + finalX, p3.y + finalY }, Color::U32(vars::misc->radar->colorLine()), 1.0f }.draw(windowList);

			}
		}
		
		ImGui::End();
	}
}

// important to call this after hook return
void RadarSizeHelper::run(MapStruct* map)
{
	g_Radar->m_pos = map->m_origin;
	g_Radar->m_scale = map->m_scale;

	g_Radar->m_inited = true;
}

```

`hack/cheats/features/visuals/radar/radar.hpp`:

```hpp
#pragma once

#include <cheats/classes/renderableToPresent.hpp>
#include <cheats/classes/overViewMap.hpp>
#include <SDK/math/Vector.hpp>

#include <cstdint>
#include <string>

class RadarSizeHelper;
struct IDirect3DTexture9;
struct ImVec2;

// texture - https://www.unknowncheats.me/forum/counterstrike-global-offensive/317765-getting-map-overview-information-textured-radar.html
class Radar : protected RenderablePresentType
{
public:
	constexpr Radar() :
		RenderablePresentType{}
	{}

	[[nodiscard]] constexpr IDirect3DTexture9*& getTexture() { return m_mapTexture; }
	constexpr void setInited(bool val) { m_inited = val; }
	// will only work for vanilla maps
	bool manuallyInitTexture();
protected:
	virtual void draw() override;
private:
	[[nodiscard]] ImVec2 entToRadar(const Vec3& eye, const Vec3& angles, const Vec3& entPos, const float scale, bool clipRanges);
	struct MapPos
	{
		Vec2 m_pos;
		float m_scale;
	};
	MapPos getMapPos() const;
	void drawMap();
	void manuallyInitPos();

	Vec2 m_pos;
	float m_scale;
	Vec2 m_drawSize;
	Vec2 m_drawPos;
	bool m_inited;
	IDirect3DTexture9* m_mapTexture;

	friend RadarSizeHelper;
};

GLOBAL_FEATURE(Radar);

class RadarSizeHelper : public OverViewMapType
{
public:
	constexpr RadarSizeHelper() :
		OverViewMapType{}
	{}

protected:
	virtual void run(MapStruct* map);
};

GLOBAL_FEATURE(RadarSizeHelper);

```

`hack/cheats/features/visuals/tracer/tracer.cpp`:

```cpp
#include "tracer.hpp"

#include "../../events/events.hpp"

#include <SDK/CGlobalVars.hpp>
#include <SDK/IGameEvent.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/math/Vector.hpp>
#include <SDK/IEngineTrace.hpp>
#include <SDK/IViewRenderBeams.hpp>
#include <SDK/math/Vector.hpp>
#include <SDK/clientHitVerify.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <render/render.hpp>
#include <utilities/utilities.hpp>
#include <menu/GUI-ImGui/selections.hpp>

#include <ranges>

void BulletTracer::draw()
{
	if (!vars::visuals->world->tracer->enabled)
		return;

	if (!game::isAvailable())
		return;

	if (!game::localPlayer->isAlive())
		return;

	CfgBeam cfgbeam = vars::visuals->world->tracer->beamTracer;

	auto m_vecBulletVerifyListClient = game::localPlayer->m_vecBulletVerifyListClient();
	static int gameBulletCount = m_vecBulletVerifyListClient.m_size; // init current count

	for (int i = m_vecBulletVerifyListClient.m_size; i > gameBulletCount; i--) // get current bullets, NOT all
		m_hitsClientSide.emplace_back(HitStruct_t
			{
				m_vecBulletVerifyListClient[i - 1].m_pos,
				memory::interfaces::globalVars->m_curtime + cfgbeam.life
			});

	if (m_vecBulletVerifyListClient.m_size != gameBulletCount)
		gameBulletCount = m_vecBulletVerifyListClient.m_size;

	Color outline = vars::visuals->world->impacts->colorClient();
	Color fill = vars::visuals->world->impacts->colorClientFill();

	for (size_t i = 0; auto & el : m_hitsClientSide)
	{
		float diff = el.m_expire - memory::interfaces::globalVars->m_curtime;

		if (diff < 0.0f)
		{
			m_hitsClientSide.erase(m_hitsClientSide.begin() + i);
			continue;
		}

		if (el.called)
			continue;

		if (!el.called)
		{
			Trace_t tr;
			Vec3 src = game::localPlayer->getEyePos();
			TraceFilter filter;
			filter.m_skip = game::localPlayer();
			memory::interfaces::trace->traceRay({ src, el.m_pos }, MASK_PLAYER, &filter, &tr);

			auto convertToFlag = [](const std::string& flag)
			{
				int ret = 0;
				for (const auto& el : std::views::split(flag, '|'))
				{
					std::string v{ el.begin(), el.end() };
					int num = std::stoi(v);
					ret |= num;
				}

				return ret;
			};

			BeamInfo_t info = {};

			auto& strWithoutSpaces = cfgbeam.flags;
			strWithoutSpaces.erase(std::remove(strWithoutSpaces.begin(), strWithoutSpaces.end(), ' '), strWithoutSpaces.end());

			info.m_type = /*convertToFlag(config.get<std::string>(vars.sBulletTracerType))*/ TE_BEAMPOINTS;
			info.m_flags = convertToFlag(strWithoutSpaces);
			info.m_modelName = selections::beamNames.at(cfgbeam.index);
			info.m_modelIndex = -1;
			info.m_haloIndex = -1;
			info.m_haloScale = 0.0f;
			info.m_life = cfgbeam.life;
			info.m_width = cfgbeam.width;
			info.m_endWidth = cfgbeam.width;
			info.m_fadeLength = cfgbeam.fadeLength;
			info.m_amplitude = cfgbeam.amplitude;
			info.m_red = cfgbeam.color().rMultiplied();
			info.m_green = cfgbeam.color().gMultiplied();
			info.m_blue = cfgbeam.color().bMultiplied();
			info.m_brightness = cfgbeam.color().aMultiplied();
			info.m_speed = cfgbeam.speed;
			info.m_startFrame = static_cast<int>(cfgbeam.startFrame);
			info.m_frameRate = cfgbeam.frameRate;
			info.m_vecStart = src;
			info.m_vecEnd = tr.m_end;
			info.m_segments = cfgbeam.segments;
			info.m_renderable = true;

			memory::interfaces::beams->createBeamPoints(info);

			el.called = true;
		}

		i++;
	}
}
```

`hack/cheats/features/visuals/tracer/tracer.hpp`:

```hpp
#pragma once

#include <cheats/classes/renderableToSurface.hpp>
#include <SDK/math/Vector.hpp>

class BulletTracer : protected RenderableSurfaceType
{
public:
	constexpr BulletTracer() :
		RenderableSurfaceType{}
	{}

protected:
	void draw() override;
private:
	struct HitStruct_t
	{
		Vec3 m_pos;
		float m_expire;
		bool called = false;
	};

	std::vector<HitStruct_t> m_hitsClientSide;
};

GLOBAL_FEATURE(BulletTracer);

```

`hack/cheats/features/visuals/world/ambient.cpp`:

```cpp
#include "ambient.hpp"

#include <SDK/ICvar.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/Enums.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <utilities/tools/tools.hpp>
#include <config/vars.hpp>
#include <cheats/game/globals.hpp>

// C7 44 24 ? ? ? ? ? 8B 84 24 ? ? ? ? in sdsshader_dx9 looks to be an array of those
void AmbientLight::init()
{
	m_ambientR = memory::interfaces::cvar->findVar(XOR("mat_ambient_light_r"));
	m_ambientG = memory::interfaces::cvar->findVar(XOR("mat_ambient_light_g"));
	m_ambientB = memory::interfaces::cvar->findVar(XOR("mat_ambient_light_b"));
}

void AmbientLight::run(int frame)
{
	if (frame != FRAME_RENDER_START)
		return;

	if (auto cfg = vars::visuals->world->ambient->enabled; cfg && (m_buttonState || m_pickerState))
	{
		auto cfgCol = vars::visuals->world->ambient->color();

		m_ambientR->setValue(cfgCol.r());
		m_ambientG->setValue(cfgCol.g());
		m_ambientB->setValue(cfgCol.b());

	}
	else if (globals::isShutdown || (!cfg && m_buttonState))
	{
		m_ambientR->setValue(0.0f);
		m_ambientG->setValue(0.0f);
		m_ambientB->setValue(0.0f);
	}
}
```

`hack/cheats/features/visuals/world/ambient.hpp`:

```hpp
#pragma once

#include <cheats/classes/frameStage.hpp>

class IConVar;

class AmbientLight : protected FrameStageType
{
public:
	constexpr AmbientLight() :
		FrameStageType{}
	{}

	void setButtonState(bool state) { m_buttonState = state; }
	void setPickerState(bool state) { m_pickerState = state; }
protected:
	virtual void run(int frame) override;
	virtual void init() override;
private:
	IConVar* m_ambientR;
	IConVar* m_ambientG;
	IConVar* m_ambientB;

	bool m_buttonState = false;
	bool m_pickerState = false;
};

GLOBAL_FEATURE(AmbientLight);
```

`hack/cheats/features/visuals/world/bomb.cpp`:

```cpp
#include "bomb.hpp"

#include "../../events/events.hpp"
#include "../../cache/cache.hpp"

#include <SDK/CGlobalVars.hpp>
#include <SDK/IEffects.hpp>
#include <SDK/Enums.hpp>
#include <SDK/ClientClass.hpp>
#include <SDK/IBaseClientDll.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/IGameEvent.hpp>
#include <SDK/ICvar.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/math/Vector.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>

#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <render/render.hpp>
#include <utilities/math/math.hpp>


void BombOverlay::init()
{
	m_timer = memory::interfaces::cvar->findVar(XOR("mp_c4timer"));

	events::add(XOR("bomb_planted"), std::bind(&BombOverlay::handleWhoPlanted, this, std::placeholders::_1));
}

void BombOverlay::roundRestart()
{
	g_BombOverlay->m_bombEnt = nullptr;
}

void BombOverlay::draw()
{
	if (!game::isAvailable())
		m_bombEnt = nullptr;

	if (!m_bombEnt)
		return;

	if (!vars::visuals->world->bomb->enabled)
		return;

	const auto bombent = reinterpret_cast<Bomb_t*>(m_bombEnt);
	const auto bombtime = bombent->m_flC4Blow() - memory::interfaces::globalVars->m_curtime;
	const auto defusetime = m_bombEnt->m_flDefuseCountDown() - memory::interfaces::globalVars->m_curtime;
	auto ent = reinterpret_cast<Player_t*>(memory::interfaces::entList->getClientFromHandle(m_bombEnt->m_hBombDefuser()));
	const auto defuseMaxTime = ent && ent->m_bHasDefuser() ? 5.0f : 10.0f; // check ent too

	if (bombtime < 0.0f || bombent->m_bBombDefused())
	{
		m_bombEnt = nullptr;
		return;
	}

	// https://www.unknowncheats.me/forum/counterstrike-global-offensive/389530-bomb-damage-indicator.html
	constexpr float bombRadius = 500.0f; // there is no info for this, run some map scanner
	constexpr float sigma = (500.0f * 3.5f) / 3.0f;
	const float hypDist = (m_bombEnt->getEyePos() - game::localPlayer->getEyePos()).length();
	const float dmg = game::scaleDamageArmor((bombRadius * (std::exp(-hypDist * hypDist / (2.0f * sigma * sigma)))), static_cast<float>(game::localPlayer->m_ArmorValue()));
	const bool isSafe = dmg < game::localPlayer->m_iHealth();

	float scaled = m_bombEnt->m_hBombDefuser().isValid() ? (defusetime / defuseMaxTime) : (bombtime / m_timer->getFloat());

	float fdef = defusetime / defuseMaxTime;
	float fbomb = bombtime / m_timer->getFloat();
	float forRed = m_bombEnt->m_hBombDefuser().isValid() ? fdef : fbomb;
	float forGreen = m_bombEnt->m_hBombDefuser().isValid() ? fdef : fbomb;

	float r = (1.0f - forRed);
	Color color{ r, forGreen, 0.0f, 0.8f };

	ImGui::SetNextWindowSize({ 300.0f, 150.0f });
	ImGui::PushStyleColor(ImGuiCol_WindowBg, Color::U32(vars::visuals->world->bomb->background()));
	if (ImGui::Begin(XOR("Bomb c4"), &vars::visuals->world->bomb->enabled, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize))
	{
		const auto size = ImGui::GetWindowSize();
		const auto pos = ImGui::GetWindowPos();
		const auto draw = ImGui::GetWindowDrawList();

		constexpr float minAngle = -90.0f;
		const float maxAngle = math::RAD2DEG(math::PI * 2.0f * scaled) + minAngle;

		const float scaledRadius = std::min(size.x, size.y) / 4.0f;
		const auto xCircle = (size.x - scaledRadius) * 0.95f;
		const auto yCircle = size.y / 2.0f;

		drawing::Arc{ ImVec2{ pos.x + xCircle, pos.y + yCircle }, scaledRadius, math::DEG2RAD(minAngle), math::DEG2RAD(maxAngle), 32, Color::U32(color), 0, 5.0f }.draw(draw);
		const auto text = defusetime > bombtime ? XOR("Too late") : FORMAT(XOR("{:.2f}"), m_bombEnt->m_hBombDefuser().isValid() ? defusetime : bombtime);
		drawing::Text{ ImFonts::tahoma14, ImVec2{ pos.x + xCircle, pos.y + yCircle - ImFonts::tahoma14->FontSize / 2.0f },
			Color::U32(Colors::White), text, false, true }.draw(draw);
		constexpr float fontSizeC4 = 40.0f;
		drawing::TextSize{ fontSizeC4, ImFonts::icon, ImVec2{ pos.x + 5.0f, pos.y + 5.0f },
			Color::U32(Colors::White), u8"\uE031"_u8str, false, false }.draw(draw);

		float yPosInfo = pos.y + size.y / 2.0f;

		if (!m_whoPlanted.empty())
		{
			drawing::Text{ ImFonts::tahoma20, ImVec2{ pos.x + 5.0f, yPosInfo }, Color::U32(Colors::White),
			FORMAT(XOR("Planted by {}s"), m_whoPlanted), false, false }.draw(draw);
			yPosInfo -= ImFonts::tahoma20->FontSize;
		}
		if (m_bombEnt->m_hBombDefuser().isValid())
		{
			drawing::Text{ ImFonts::tahoma20, ImVec2{ pos.x + 5.0f, yPosInfo }, Color::U32(Colors::White),
			FORMAT(XOR("Defusing {}"), ent->getName()), false, false }.draw(draw);
			yPosInfo -= ImFonts::tahoma20->FontSize;
		}

		float yCentreInfo = pos.y + 2.0f + ImFonts::tahoma20->FontSize;
		drawing::Text{ ImFonts::tahoma20, ImVec2{ pos.x + size.x / 2.0f, yCentreInfo }, Color::U32(Colors::White), FORMAT(XOR("Site {}"), m_bombEnt->getBombSiteName()), false, true }.draw(draw);
		yCentreInfo += ImFonts::tahoma20->FontSize;
		drawing::Text{ ImFonts::tahoma20, ImVec2{ pos.x + size.x / 2.0f, yCentreInfo }, Color::U32(isSafe ? Colors::Green : Colors::Red), FORMAT(XOR("Damage {:.2f}"), dmg), false, true }.draw(draw);

		ImGui::End();
	}
	ImGui::PopStyleColor();
}

void BombOverlay::handleWhoPlanted(IGameEvent* event)
{
	auto who = reinterpret_cast<Player_t*>(memory::interfaces::entList->getClientEntity(memory::interfaces::engine->getPlayerID(event->getInt(XOR("userid")))));
	if (!who)
		return;

	m_whoPlanted = who->getName();
}

void BombOverlayEntGrabber::run(int frame)
{
	if (frame != FRAME_RENDER_START)
		return;

	for (auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::WORLD_ENTS))
	{
		if (classID != CPlantedC4)
			continue;

		g_BombOverlay->m_bombEnt = reinterpret_cast<Bomb_t*>(entity);
	}
}
```

`hack/cheats/features/visuals/world/bomb.hpp`:

```hpp
#pragma once

#include <cheats/classes/renderableToPresent.hpp>
#include <cheats/classes/frameStage.hpp>

class Bomb_t;
class IConVar;
class IGameEvent;
class BombOverlayEntGrabber;

class BombOverlay : protected RenderablePresentType
{
public:
	constexpr BombOverlay() :
		RenderablePresentType{}
	{}

	void setBombEnt(Bomb_t* ent) { m_bombEnt = ent; }
protected:
	virtual void draw() override;
	virtual void init() override;
	virtual void roundRestart() override;
private:
	void handleWhoPlanted(IGameEvent* event);

	Bomb_t* m_bombEnt;
	IConVar* m_timer;
	std::string m_whoPlanted;

	friend BombOverlayEntGrabber;
};

GLOBAL_FEATURE(BombOverlay);

class BombOverlayEntGrabber : protected FrameStageType
{
public:
	constexpr BombOverlayEntGrabber()
		: FrameStageType{}
	{}

protected:
	virtual void run(int frame) override;
};

GLOBAL_FEATURE(BombOverlayEntGrabber);

```

`hack/cheats/features/visuals/world/dropped.cpp`:

```cpp
#include "dropped.hpp"

#include "../../cache/cache.hpp"

#include <SDK/ILocalize.hpp>
#include <SDK/IWeapon.hpp>
#include <SDK/IVModelInfo.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <render/render.hpp>
#include <utilities/utilities.hpp>

void DroppedWeapons::draw()
{
	if (!vars::visuals->esp->dropped->enabled)
		return;

	for (auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::WEAPON))
	{
		auto handle = memory::interfaces::entList->getClientFromHandle(entity->m_hOwnerEntity());
		if (handle)
			continue;

		auto wpn = reinterpret_cast<Weapon_t*>(entity);
		if (!wpn)
			continue;

		Box box{ entity };
		if (!box.isValid())
			continue;
	
		float fontSize = game::getScaledFont(entity->absOrigin(), game::localPlayer()->absOrigin(), 60.0f, 11.0f, 16.0f);
		using cont = std::vector<bool>;
		float padding = 0.0f;

		constexpr float maxDist = 25.0f;
		float alpha = (maxDist - entity->absOrigin().distToMeters(game::localPlayer->absOrigin())) / (maxDist / 1.5f);

		if (alpha < 0.0f)
			continue;

		auto getTextSize = [=](const std::string& text, ImFont* font = ImFonts::verdana12)
		{
			return font->CalcTextSizeA(fontSize, std::numeric_limits<float>::max(), 0.0f, text.c_str());
		};

		auto flags = vars::visuals->esp->dropped->flags;

		if (flags.at(E2T(DroppedFlags::BOX))) // startpoint - no pad
		{
			imRender.drawRect(box.x - 1.0f, box.y - 1.0f, box.w + 2.0f, box.h + 2.0f, Colors::Black.getColorEditAlpha(alpha));
			imRender.drawRect(box.x + 1.0f, box.y + 1.0f, box.w - 2.0f, box.h - 2.0f, Colors::Black.getColorEditAlpha(alpha));
			imRender.drawRect(box.x, box.y, box.w, box.h, vars::visuals->esp->dropped->color().getColorEditAlpha(alpha));
		}
		if (flags.at(E2T(DroppedFlags::AMMO)) && !wpn->isNonAimable()) // no pad font logic, we just draw extra box
		{
			constexpr float startPad = 3.0f;

			imRender.drawRectFilled(box.x - 1.0f, box.y + box.h - 1.0f + startPad, box.w + 2.0f, 4.0f, Colors::Black.getColorEditAlpha(alpha));
			imRender.drawRectFilled(box.x, box.y + box.h + startPad,
				wpn->m_iClip1() * box.w / wpn->getWpnInfo()->m_maxClip1, 2.0f, vars::visuals->esp->dropped->color().getColorEditAlpha(alpha));

			padding += 4.0f;
		}
		if (flags.at(E2T(DroppedFlags::TEXT)))
		{
			auto name = vars::visuals->esp->weaponBar->translate
				? memory::interfaces::localize->findAsUTF8(wpn->getWpnInfo()->m_WeaponName)
				: wpn->getWpnName();
			imRender.text(box.x + box.w / 2, box.y + box.h + 2 + padding, fontSize, ImFonts::verdana12,
				name, true, vars::visuals->esp->dropped->color().getColorEditAlpha(alpha));

			auto textSize = getTextSize(name);
			padding += textSize.y;
		}
		if (flags.at(E2T(DroppedFlags::ICON)))
		{
			auto name = utilities::u8toStr(wpn->getIcon());
			imRender.text(box.x + box.w / 2, box.y + box.h + 2 + padding, fontSize, ImFonts::icon,
				name, true, vars::visuals->esp->dropped->color().getColorEditAlpha(alpha));

			auto textSize = getTextSize(name, ImFonts::icon);
			padding += textSize.y;
		}
	}
}

```

`hack/cheats/features/visuals/world/dropped.hpp`:

```hpp
#pragma once

#include <cheats/classes/renderableToSurface.hpp>

class DroppedWeapons : protected RenderableSurfaceType
{
public:
	constexpr DroppedWeapons() :
		RenderableSurfaceType{}
	{}

protected:
	virtual void draw() override;
};

GLOBAL_FEATURE(DroppedWeapons);

```

`hack/cheats/features/visuals/world/fog.cpp`:

```cpp
#include "fog.hpp"

#include "../../cache/cache.hpp"

#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>

static constexpr uint32_t U32RGB(const SDKColor& clr)
{
	return (clr.r & 0x0FF) | ((clr.g & 0x0FF) << 8) | ((clr.b & 0x0FF) << 16);
}

void FogController::run(int frame)
{
	if (frame != FRAME_RENDER_START)
		return;

	if (!game::isAvailable())
		return;

	for (auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::CONTROLLERS))
	{
		if (classID != CFogController)
			continue;

		auto ent = reinterpret_cast<FogController_t*>(entity);

		if (globals::isShutdown)
		{
			ent->m_fogenable() = false;
			break;
		}

		if (bool opt = vars::visuals->world->fog->enabled; opt)
			ent->m_fogenable() = opt;
		else
		{
			ent->m_fogenable() = opt;
			break;
		}

		SDKColor col = vars::visuals->world->fog->color();

		ent->m_fogstart() = 0.0f;
		ent->m_fogend() = vars::visuals->world->fog->distance * 10.0f;
		ent->m_fogmaxdensity() = col.a / 100.0f;
		ent->m_fogcolorPrimary() = U32RGB(col);
		ent->m_fogcolorSecondary() = U32RGB(col);
	}
}

```

`hack/cheats/features/visuals/world/fog.hpp`:

```hpp
#pragma once

#include <cheats/classes/frameStage.hpp>

class FogController_t;

class FogController : protected FrameStageType
{
public:
	constexpr FogController() :
		FrameStageType{}
	{}

protected:
	virtual void run(int frame) override;
};

GLOBAL_FEATURE(FogController);

```

`hack/cheats/features/visuals/world/impacts.cpp`:

```cpp
#include "impacts.hpp"

#include "../../events/events.hpp"

#include <SDK/CGlobalVars.hpp>
#include <SDK/IEngineTrace.hpp>
#include <SDK/IGameEvent.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/clientHitVerify.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <render/render.hpp>
#include <utilities/tools/tools.hpp>

void BulletImpactsClient::draw()
{
	if (!vars::visuals->world->impacts->enabledClient)
		return;

	if (!game::isAvailable())
		return;

	auto m_vecBulletVerifyListClient = game::localPlayer->m_vecBulletVerifyListClient();
	static int gameBulletCount = m_vecBulletVerifyListClient.m_size; // init current count

	for (int i = m_vecBulletVerifyListClient.m_size; i > gameBulletCount; i--) // get current bullets, NOT all
		m_hitsClientSide.emplace_back(HitStruct_t
			{
				m_vecBulletVerifyListClient[i - 1].m_pos,
				memory::interfaces::globalVars->m_curtime + vars::visuals->world->impacts->timeClient
			});

	if (m_vecBulletVerifyListClient.m_size != gameBulletCount)
		gameBulletCount = m_vecBulletVerifyListClient.m_size;

	Color outline = vars::visuals->world->impacts->colorClient();
	Color fill = vars::visuals->world->impacts->colorClientFill();

	for (size_t i = 0; const auto & el : m_hitsClientSide)
	{
		float diff = el.m_expire - memory::interfaces::globalVars->m_curtime;

		if (diff < 0.0f)
		{
			m_hitsClientSide.erase(m_hitsClientSide.begin() + i);
			continue;
		}

		imRender.drawBox3DFilled(el.m_pos, 4.0f, 4.0f, outline, fill);

		i++;
	}
}

```

`hack/cheats/features/visuals/world/impacts.hpp`:

```hpp
#pragma once

#include <cheats/classes/renderableToSurface.hpp>
#include <cheats/classes/onlyInit.hpp>

#include <SDK/math/Vector.hpp>

class IGameEvent;

class BulletImpactsClient : protected RenderableSurfaceType
{
public:
	constexpr BulletImpactsClient() :
		RenderableSurfaceType{}
	{}

protected:
	virtual void draw() override;
private:
	struct HitStruct_t
	{
		Vec3 m_pos;
		float m_expire;
	};

	std::vector<HitStruct_t> m_hitsClientSide;
};

GLOBAL_FEATURE(BulletImpactsClient);

```

`hack/cheats/features/visuals/world/modulateColors.cpp`:

```cpp
#include "modulateColors.hpp"

#include <SDK/IMaterialSystem.hpp>
#include <config/vars.hpp>
#include <utilities/tools/tools.hpp>
#include <cheats/game/globals.hpp>

#include <unordered_map>

void ModulateColor::run(void* thisptr, float* r, float* g, float* b)
{
	if (!vars::visuals->world->modulate->enabled)
		return;

	auto editColor = [=](CfgColor* color)
	{
		*r = color->getColor().r();
		*g = color->getColor().g();
		*b = color->getColor().b();
		color->refresh();
	};

	auto material = reinterpret_cast<IMaterial*>(thisptr);

	if (!material)
		return;

	if (material->isError())
		return;

	std::string_view name = material->getTextureGroupName();

	static std::unordered_map<std::string_view, CfgColor*> mapped =
	{
		{ XOR("World textures"), &vars::visuals->world->modulate->texture },
		{ XOR("StaticProp textures"), &vars::visuals->world->modulate->prop },
		{ XOR("SkyBox textures"), &vars::visuals->world->modulate->sky },
	};

	bool goodMat = false;

	if (auto itr = mapped.find(name); itr != mapped.end())
	{
		editColor(itr->second);
		goodMat = true;
	}

	constexpr int shaderAlpha = 5;

	if (auto shader = material->getShaderParams()[shaderAlpha]; goodMat)
	{
		!globals::isShutdown
			? shader->setValue(vars::visuals->world->modulate->shader / 100.0f)
			: shader->setValue(1.0f); // default val reset
	}
}
```

`hack/cheats/features/visuals/world/modulateColors.hpp`:

```hpp
#pragma once

class ModulateColor
{
public:
	static void run(void* thisptr, float* r, float* g, float* b);
};

```

`hack/cheats/features/visuals/world/molotov.cpp`:

```cpp
#include "molotov.hpp"

#include "../../cache/cache.hpp"

#include <SDK/CGlobalVars.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <render/render.hpp>
#include <utilities/math/math.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>

void MolotovDraw::draw()
{
	if (!vars::visuals->world->molotov->enabled)
		return;

	for (auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::GRENADE_PROJECTILES))
	{
		if (classID != CInferno)
			continue;

		auto molotov = reinterpret_cast<Inferno_t*>(entity);

		// https://github.com/perilouswithadollarsign/cstrike15_src/blob/master/game/server/cstrike15/Effects/inferno.cpp
		// here you can see ratios and everything

		//Vector min = {}, max = {};
		//ent->getRenderBounds(min, max);
		//imRender.drawCircle3DFilled(molotov->absOrigin(), 0.5f * Vector(max - min).length2D(), 32, config.get<Color>(vars.cMolotovRange));

		//imRender.text(screen.x, screen.y, ImFonts::tahoma, XOR("Molotov"), false, config.get<Color>(vars.cMolotovRangeText));
		float time = molotov->spawnTime() + molotov->expireTime() - memory::interfaces::globalVars->m_curtime;
		float scale = time / molotov->expireTime();

		const auto& origin = molotov->absOrigin();
		constexpr int molotovRadius = 60; // 30 * 2

		//std::vector<ImVec2> points = {};
		Color col = vars::visuals->world->molotov->color();

		//std::vector<ImVec2> points;

		for (int i = 0; i < molotov->m_fireCount(); i++)
		{
			auto pos = origin + molotov->getInfernoPos(i);
			imRender.drawCircle3DFilled(pos, molotovRadius, 32, col, col);

			/*ImVec2 posw;
			if (!imRender.worldToScreen(pos, posw))
				break;

			points.push_back(posw);*/

			//imRender.text(posw.x, posw.y, ImFonts::tahoma, std::to_string(i), false, Colors::Cyan);*/
			// points are not on edge, this will need some graph path logic, and will be done soon
		}
		static float size = ImFonts::tahoma14->FontSize;
		// timer
		if (ImVec2 s; imRender.worldToScreen(origin, s))
		{
			imRender.drawProgressRing(s.x, s.y, 25, 32, -90.0f, scale, 5.0f, Colors::LightBlue);
			imRender.text(s.x, s.y - (size / 2.0f), ImFonts::tahoma14, FORMAT(XOR("{:.2f}s"), time), true, Colors::White);
		}
	}

	/*auto g = math::giftWrap(points);
	imRender.drawPolyGon(g, Colors::LightBlue);*/ // still too less points to make is "cool"
}
```

`hack/cheats/features/visuals/world/molotov.hpp`:

```hpp
#pragma once

#include <cheats/classes/renderableToSurface.hpp>

class Inferno_t;

class MolotovDraw : protected RenderableSurfaceType
{
public:
	constexpr MolotovDraw() :
		RenderableSurfaceType{}
	{}

protected:
	virtual void draw() override;
};

GLOBAL_FEATURE(MolotovDraw);

```

`hack/cheats/features/visuals/world/nadepred.cpp`:

```cpp
#include "nadepred.hpp"

#include <SDK/math/Vector.hpp>
#include <SDK/IWeapon.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/CGlobalVars.hpp>
#include <SDK/IEngineTrace.hpp>
#include <SDK/ICvar.hpp>
#include <SDK/Convar.hpp>
#include <SDK/Enums.hpp>
#include <SDK/CUserCmd.hpp>
#include <SDK/ClientClass.hpp>
#include <SDK/IVModelInfo.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <config/vars.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <render/render.hpp>
#include <utilities/math/math.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <gamememory/memory.hpp>

#include "../../cache/cache.hpp"

#include <ranges>

#define DETONATE 1
#define BOUNCE 2

enum ACT
{
	ACT_NONE,
	ACT_THROW,
	ACT_LOB,
	ACT_DROP,
};

void GreandePredictionButton::run(CUserCmd* cmd)
{
	if (!vars::misc->nade->enabledPred)
		return;

	if (vars::misc->nade->predAlways)
	{
		m_button = ACT_THROW;
		return;
	}

	m_button = ACT_NONE;

	int attack = cmd->m_buttons & IN_ATTACK;
	int attack2 = cmd->m_buttons & IN_ATTACK2;

	if (attack || attack2)
	{
		if (attack && attack2)
			m_button = ACT_LOB;
		else if (!attack)
			m_button = ACT_DROP;
		else
			m_button = ACT_THROW;
	}

	runView();
}

void GreandePredictionButton::runView()
{
	if (!vars::misc->nade->enabledPred)
		return;

	if (!game::isAvailable())
		return;

	auto wpn = game::localPlayer->getActiveWeapon();
	if (!wpn || !wpn->isGrenade())
		return;

	if (m_button != ACT_NONE)
	{
		m_weaponIdx = wpn->m_iItemDefinitionIndex();
		g_GrenadePrediction->simulate();
	}
	else
		m_weaponIdx = 0;
}

struct DmgNadeInfo_t
{
public:
	constexpr DmgNadeInfo_t(const ImVec2& pos, const std::string& dmgtext, const Color& color)
		: m_pos{ pos }, m_textDmg{ dmgtext }, m_color{ color }
	{}

	ImVec2 m_pos;
	std::string m_textDmg;
	Color m_color;
};

void GrenadePrediction::draw()
{
	if (!vars::misc->nade->enabledPred)
		return;

	if (!game::isAvailable())
		return;

	auto weapon = game::localPlayer->getActiveWeapon();
	if (!weapon)
		return;

	if (!weapon->isGrenade())
		return;

	if (!g_GreandePredictionButton->getWeaponIdx())
		return;

	if (m_path.empty())
		return;

	std::vector<DmgNadeInfo_t> nadesDmg = {};

	// valve values
	constexpr float a = 105.0f;
	constexpr float b = 25.0f;
	constexpr float c = 140.0f;

	for (auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::PLAYER))
	{
		auto ent = reinterpret_cast<Player_t*>(entity);
		if (!ent)
			continue;

		if (ent->isDormant())
			continue;

		if (!ent->isAlive())
			continue;

		if (!ent->isOtherTeam(game::localPlayer()))
			continue;

		float deltaDist = (ent->absOrigin() - m_path.back()).length();

		if (int idx = weapon->m_iItemDefinitionIndex(); idx == WEAPON_HEGRENADE)
		{
			if (deltaDist > 350.0f) // nade always same
				continue;

			float d = ((deltaDist - b) / c);
			float dmg = a * std::exp(-d * d);
			float resultDmg = game::scaleDamageArmor(dmg, static_cast<float>(ent->m_ArmorValue()));
			if (resultDmg < 0.1f)
				continue;

			float dmgDealt = ent->m_iHealth() - resultDmg;
			if (ImVec2 pos; imRender.worldToScreen(ent->absOrigin(), pos))
			{
				std::string text = dmgDealt < 0.0f ? XOR("DIE") : FORMAT(XOR("{:.2f}"), -resultDmg);
				nadesDmg.emplace_back(pos, text, Color::healthBased(static_cast<uint8_t>(dmgDealt)));
			}
		}
		else if (idx == WEAPON_MOLOTOV || idx == WEAPON_INCGRENADE)
		{
			if (deltaDist > 180.0f) // 180 is not always accurate perfectly
				continue;

			if (ImVec2 pos; imRender.worldToScreen(ent->absOrigin(), pos))
				nadesDmg.emplace_back(pos, XOR("In range"), Colors::LightBlue);
		}
	}

	for (Vec3 prev = m_path.front(); const auto & el : m_path)
	{
		if (ImVec2 start, end; imRender.worldToScreen(prev, start) && imRender.worldToScreen(el, end))
			imRender.drawLine(start, end, vars::misc->nade->colorPredLine(), 2.0f);

		prev = el;
	}

	for (const auto& el : m_bounces)
	{
		imRender.drawBox3DFilled(el, 2.0f, 2.0f, vars::misc->nade->colorPredBox(), vars::misc->nade->colorPredBoxFill());
	}

	for (const auto& [pos, text, color] : nadesDmg)
	{
		imRender.text(pos.x, pos.y, ImFonts::tahoma20, text, true, color, false);
	}

	//imRender.drawCircle3D(m_path.back(), weapon->getNadeRadius(), 32, Colors::White);
}

// not using magic value given by valve, so we never are based on buttons
void GrenadePrediction::setup(Vec3& src, Vec3& vecThrow, const Vec3& viewangles)
{
	auto weapon = game::localPlayer->getActiveWeapon();
	if (!weapon)
		return;

	Vec3 angThrow = viewangles;
	float pitch = math::normalizePitch(angThrow[Coord::X]);

	constexpr float inversed = 10.0f / 90.0f;
	angThrow[Coord::X] -= (90.0f - std::abs(angThrow[Coord::X])) * inversed;
	Vec3 forward = math::angleVec(angThrow);

	float m_flThrowStrength = weapon->m_flThrowStrength();
	float clampedVelWeapon = std::min(std::max(weapon->getWpnInfo()->m_throwVelocity * 0.9f, 15.0f), 750.0f);

	float throwHeight = (m_flThrowStrength * 12.0f) - 12.0f;

	src = game::localPlayer->getEyePos();

	float finalVel = clampedVelWeapon * ((0.7f * m_flThrowStrength) + 0.3f);

	Vec3 start = game::localPlayer->getEyePos() += Vec3{ 0.0f, 0.0f, throwHeight };
	Vec3 end = start + (forward * 22.0f);

	Trace_t tr;
	traceHull(src, end, tr);

	Vec3 back = forward;
	back *= 6.0f;
	src = tr.m_end;
	src -= back;

	vecThrow = game::localPlayer->m_vecVelocity();
	vecThrow *= 1.25f;
	vecThrow += forward * finalVel;
}

void GrenadePrediction::simulate()
{
	Vec3 vecSrc, vecThrow;
	Vec3 angles; memory::interfaces::engine->getViewAngles(angles);
	setup(vecSrc, vecThrow, angles);

	float interval = memory::interfaces::globalVars->m_intervalPerTick;
	size_t logstep = static_cast<size_t>(0.05f / interval);
	size_t logtimer = 0;

	m_path.clear();
	m_bounces.clear();

	for (auto i : std::views::iota(0, 1024)) // 1024 is hardcoded, we prob will never ever reach it
	{
		if (!logtimer)
			m_path.push_back(vecSrc);

		size_t s = step(vecSrc, vecThrow, i, interval);

		if (s & DETONATE)
			break;

		if (s & BOUNCE || logtimer >= logstep)
			logtimer = 0;
		else
			++logtimer;

		if (vecThrow.isZero())
			break;
	}

	m_path.push_back(vecSrc);
	m_bounces.push_back(vecSrc);
}

size_t GrenadePrediction::step(Vec3& src, Vec3& vecThrow, int tick, float interval)
{
	Vec3 move;
	addGravityMove(move, vecThrow, interval);
	Trace_t tr;
	pushEntity(src, move, tr);

	size_t result = 0;

	if (checkDetonate(vecThrow, tr, tick, interval))
		result |= DETONATE;

	if (tr.didHit())
	{
		result |= BOUNCE;
		resolveFlyCollisionCustom(tr, vecThrow, move, interval);
		m_bounces.push_back(tr.m_end);
	}

	if (auto size = m_bounces.size() - 1; !m_bounces.empty() && size > 20)
		m_bounces.erase(m_bounces.begin() + size);

	src = tr.m_end;
	return result;
}

bool GrenadePrediction::checkDetonate(const Vec3& vecThrow, const Trace_t& tr, int tick, float interval)
{
	auto check = [=](float amount = 0.2f)
	{
		return !(tick % game::timeToTicks(amount));
	};

	const float time = game::ticksToTime(tick);

	switch (g_GreandePredictionButton->getWeaponIdx())
	{
	case WEAPON_SMOKEGRENADE:
	{
		return vecThrow.toVecPrev().length() <= 0.1f && check();
	}
	case WEAPON_DECOY:
	{
		return vecThrow.toVecPrev().length() <= 0.2f && check();
	}
	case WEAPON_MOLOTOV:
	case WEAPON_INCGRENADE:
	{
		const static float molotov_throw_detonate_time = memory::interfaces::cvar->findVar(XOR("molotov_throw_detonate_time"))->getFloat();
		const static float weapon_molotov_maxdetonateslope = memory::interfaces::cvar->findVar(XOR("weapon_molotov_maxdetonateslope"))->getFloat();

		if (tr.didHit() && tr.m_plane.m_normal[Coord::Z] >= std::cos(math::DEG2RAD(weapon_molotov_maxdetonateslope)))
			return true;

		return time >= molotov_throw_detonate_time && check(0.1f);
	}
	case WEAPON_FLASHBANG:
	case WEAPON_HEGRENADE:
		return time >= 1.5f && check();
	default:
		return false;
	}

	return false;
}

// should add more traces, as in some cases the prediction can fail badly
void GrenadePrediction::traceHull(Vec3& src, Vec3& end, Trace_t& tr)
{
	uintptr_t filter[] =
	{
		*reinterpret_cast<uintptr_t*>(memory::traceFilterSimple()),
		reinterpret_cast<uintptr_t>(game::localPlayer()),
		0,
		0
	};

	memory::interfaces::trace->traceRay({ src, end, Vec3{ -2.0f, -2.0f, -2.0f }, Vec3{ 2.0f, 2.0f, 2.0f } }, MASK_SOLID, reinterpret_cast<TraceFilter*>(&filter), &tr);
}

void GrenadePrediction::addGravityMove(Vec3& move, Vec3& vel, float frametime)
{
	move[Coord::X] = vel[Coord::X] * frametime;
	move[Coord::Y] = vel[Coord::Y] * frametime;

	const static float svgrav = memory::interfaces::cvar->findVar(XOR("sv_gravity"))->getFloat();
	float gravity = svgrav * 0.4f;
	float z = vel[Coord::Z] - (gravity * frametime);
	move[Coord::Z] = ((vel[Coord::Z] + z) / 2.0f) * frametime;

	vel[Coord::Z] = z;
}

void GrenadePrediction::pushEntity(Vec3& src, const Vec3& move, Trace_t& tr)
{
	Vec3 end = src;
	end += move;
	traceHull(src, end, tr);
}

void GrenadePrediction::resolveFlyCollisionCustom(Trace_t& tr, Vec3& velocity, const Vec3& move, float interval)
{
	/*float surfaceElasticity = 1.0;*/
	if (auto e = tr.m_entity; e) // if it's any entity
	{
		if (auto e = tr.m_entity; e->isPlayer()) // if player don't stop but make it bouned a lot slower
		{
			/*surfaceElasticity = 0.3f;*/
			velocity *= 0.3f;
			return;
		}

		if (e->isBreakable()) // for example glass or window
		{
			if (!e->isAlive()) // any better solution?
			{
				velocity *= 0.4f;
				return;
			}
		}
		// here some checks are needed, I honestly don't know how to make it pixel perfect in this case
	}

	constexpr float surfaceElasticity = 1.0f;
	constexpr float nadeElascity = 0.45f;
	static float totalElascity = surfaceElasticity * nadeElascity;
	totalElascity = std::clamp(totalElascity, 0.0f, 0.9f);

	Vec3 absVelocity;
	physicsClipVelocity(velocity, tr.m_plane.m_normal, absVelocity, 2.0f);
	absVelocity *= totalElascity;

	constexpr float minSpeed = 20.0f * 20.0f;
	float speedAbsSqr = absVelocity.lengthSqrt();

	if (speedAbsSqr < minSpeed)
		absVelocity = {};

	if (tr.m_plane.m_normal[Coord::Z] > 0.7f)
	{
		velocity = absVelocity;
		absVelocity *= ((1.0f - tr.m_fraction) * interval);
		pushEntity(tr.m_end, absVelocity * ((1.0f - tr.m_fraction) * interval), tr);
	}
	else
	{
		velocity = absVelocity;
	}
}

void GrenadePrediction::physicsClipVelocity(const Vec3& in, const Vec3& normal, Vec3& out, float overbounce)
{
	constexpr float STOP_EPSILON = 0.1f;

	float backoff = in.dot(normal) * overbounce;
	for (auto i : std::views::iota(0, 3))
	{
		out[i] = in[i] - (normal[i] * backoff);

		if (out[i] > -STOP_EPSILON && out[i] < STOP_EPSILON)
			out[i] = 0.0f;
	}
}

```

`hack/cheats/features/visuals/world/nadepred.hpp`:

```hpp
#pragma once

#include <cheats/classes/createMove.hpp>
#include <cheats/classes/onlyInit.hpp>
#include <cheats/classes/renderableToSurface.hpp>
#include <SDK/math/Vector.hpp>

#include <vector>

struct Trace_t;
class Entity_t;
class Player_t;
class Nade_t;
enum WeaponIndex;
struct Studiohdr_t;

class GrenadePrediction;

class GreandePredictionButton : protected CreateMovePrePredictionType
{
public:
	constexpr GreandePredictionButton() :
		CreateMovePrePredictionType{}
	{}

	[[nodiscard]] int getButton() const { return m_button; }
	[[nodiscard]] int getWeaponIdx() const { return m_weaponIdx; }
protected:
	virtual void run(CUserCmd* cmd);
private:
	void runView();
	int m_button;
	int m_weaponIdx;
};

GLOBAL_FEATURE(GreandePredictionButton);

// a lot of code is in cstrike15 leak, as I tried to do this I run on few cases where it was not pixel perfect
// fix is def needed, for breakables bounces
class GrenadePrediction : protected RenderableSurfaceType
{
public:
	constexpr GrenadePrediction() :
		RenderableSurfaceType{}
	{}

protected:
	friend GreandePredictionButton;

	virtual void draw() override;
private:
	std::vector<Vec3> m_path;
	std::vector<Vec3> m_bounces;
protected:
	void setup(Vec3& src, Vec3& vecThrow, const Vec3& viewangles);
	[[nodiscard]] size_t step(Vec3& src, Vec3& vecThrow, int tick, float interval);
	void simulate();
	bool checkDetonate(const Vec3& vecThrow, const Trace_t& tr, int tick, float interval);
	void addGravityMove(Vec3& move, Vec3& vel, float frametime);
private:
	void traceHull(Vec3& src, Vec3& end, Trace_t& tr);
	void pushEntity(Vec3& src, const Vec3& move, Trace_t& tr);
	void resolveFlyCollisionCustom(Trace_t& tr, Vec3& velocity, const Vec3& move, float interval);
protected:
	void physicsClipVelocity(const Vec3& in, const Vec3& normal, Vec3& out, float overbounce);
};

GLOBAL_FEATURE(GrenadePrediction);

```

`hack/cheats/features/visuals/world/nadewarn.cpp`:

```cpp
#include "nadewarn.hpp"

#include <SDK/math/Vector.hpp>
#include <SDK/IWeapon.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/CGlobalVars.hpp>
#include <SDK/IEngineTrace.hpp>
#include <SDK/ICvar.hpp>
#include <SDK/Convar.hpp>
#include <SDK/Enums.hpp>
#include <SDK/CUserCmd.hpp>
#include <SDK/ClientClass.hpp>
#include <SDK/IVModelInfo.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <config/vars.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <render/render.hpp>
#include <utilities/math/math.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <utilities/utilities.hpp>
#include <gamememory/memory.hpp>

#include <ranges>

bool NadeTrace_t::step(float interval)
{
	if (m_detonated)
		return true;

	Vec3 move;
	addGravityMove(move, m_velocity, interval);
	Trace_t tr;
	pushEntity(move, tr);

	if (tr.didHit())
		resolveFlyCollisionCustom(tr, interval);

	m_pos = tr.m_end;

	return false;
}

void NadeTrace_t::physicsClipVelocity(const Vec3& in, const Vec3& normal, Vec3& out, float overbounce)
{
	constexpr float STOP_EPSILON = 0.1f;

	float backoff = in.dot(normal) * overbounce;
	for (auto i : std::views::iota(0, 3))
	{
		out[i] = in[i] - (normal[i] * backoff);

		if (out[i] > -STOP_EPSILON && out[i] < STOP_EPSILON)
			out[i] = 0.f;
	}
}

void NadeTrace_t::addGravityMove(Vec3& move, Vec3& vel, float frametime)
{
	move[Coord::X] = vel[Coord::X] * frametime;
	move[Coord::Y] = vel[Coord::Y] * frametime;

	const static float svgrav = memory::interfaces::cvar->findVar(XOR("sv_gravity"))->getFloat();
	float gravity = svgrav * 0.4f;
	float z = vel[Coord::Z] - (gravity * frametime);
	move[Coord::Z] = ((vel[Coord::Z] + z) / 2.0f) * frametime;

	vel[Coord::Z] = z;
}

void NadeTrace_t::traceHull(const Vec3& src, const Vec3& end, Entity_t* entity, Trace_t* tr)
{
	uintptr_t filter[] =
	{
		*reinterpret_cast<uintptr_t*>(memory::traceFilterSimple()),
		reinterpret_cast<uintptr_t>(entity),
		0,
		0
	};

	memory::interfaces::trace->traceRay({ src, end, Vec3{ -2.0f, -2.0f, -2.0f }, Vec3{ 2.f, 2.0f, 2.0f } }, MASK_SOLID, reinterpret_cast<TraceFilter*>(&filter), tr);
}

void NadeTrace_t::pushEntity(const Vec3& src, Trace_t& tr)
{
	traceHull(m_pos, m_pos + src, m_nadeOwner, &tr);

	// lazy attempt... see nadepred check code
	if (m_index == WEAPON_MOLOTOV || m_index == WEAPON_INCGRENADE)
	{
		const static float weapon_molotov_maxdetonateslope = memory::interfaces::cvar->findVar(XOR("weapon_molotov_maxdetonateslope"))->getFloat();

		if (bool res = tr.didHit() && tr.m_plane.m_normal[Coord::Z] >= std::cos(math::DEG2RAD(weapon_molotov_maxdetonateslope)); res)
			destroyTrace();
	}
}

void NadeTrace_t::resolveFlyCollisionCustom(Trace_t& tr, float interval)
{
	/*float surfaceElasticity = 1.0;*/
	if (auto e = tr.m_entity; e) // if it's any entity
	{
		if (auto e = tr.m_entity; e->isPlayer()) // if player don't stop but make it bouned a lot slower
		{
			/*surfaceElasticity = 0.3f;*/
			m_velocity *= 0.3f;
			return;
		}

		if (e->isBreakable()) // for example glass or window
		{
			if (!e->isAlive()) // any better solution?
			{
				m_velocity *= 0.4f;
				return;
			}
		}
		// here some checks are needed, I honestly don't know how to make it pixel perfect in this case
	}

	constexpr float surfaceElasticity = 1.0f;
	constexpr float nadeElascity = 0.45f;
	float totalElascity = surfaceElasticity * nadeElascity;
	totalElascity = std::clamp(totalElascity, 0.0f, 0.9f);

	Vec3 absVelocity;
	physicsClipVelocity(m_velocity, tr.m_plane.m_normal, absVelocity, 2.0f);
	absVelocity *= totalElascity;

	constexpr float minSpeed = 20.0f * 20.0f;
	float speedAbsSqr = absVelocity.lengthSqrt();

	if (speedAbsSqr < minSpeed)
		absVelocity = {};

	if (tr.m_plane.m_normal[Coord::Z] > 0.7f)
	{
		m_velocity = absVelocity;
		absVelocity *= ((1.0f - tr.m_fraction) * interval);
		pushEntity(absVelocity * ((1.0f - tr.m_fraction) * interval), tr);
	}
	else
		m_velocity = absVelocity;

	// or velocity
	if (m_bouncesCheck > 20)
		return destroyTrace();

	++m_bouncesCheck;
}

void NadeTrace_t::handleDestroy()
{
	if (m_index == WEAPON_DECOY || m_index == WEAPON_SMOKEGRENADE)
		if (m_velocity.toVecPrev().length() <= 0.1f) // ghetto workaround, at least we can be sure this is accurate
		{
			//printf("did destroy\n");
			destroyTrace();
		}

	if (game::ticksToTime(m_tick) > m_nadeDetonateTime)
		destroyTrace();

	m_nextTick = m_tick + game::timeToTicks(0.2f);
}

void NadeTrace_t::handleDetonates()
{
	switch (m_index)
	{
	case WEAPON_SMOKEGRENADE:
	{
		m_nadeDetonateTime = 3.0f;
		break;
	}
	case WEAPON_DECOY:
	{
		m_nadeDetonateTime = 5.0f;
		break;
	}
	case WEAPON_FLASHBANG:
	case WEAPON_HEGRENADE:
	{
		m_nadeDetonateTime = 1.5f;
		break;
	}
	case WEAPON_MOLOTOV:
	case WEAPON_INCGRENADE:
	{
		const static auto molotov_throw_detonate_time = memory::interfaces::cvar->findVar(XOR("molotov_throw_detonate_time"));
		m_nadeDetonateTime = molotov_throw_detonate_time->getFloat();
		break;
	}
	default:
		m_nadeDetonateTime = 0.0f;
		break;
	}
}

void NadeTrace_t::simulate(const Vec3& pos, const Vec3& velocity, float nadeThrowTime, uint32_t ticks)
{
	m_pos = pos;
	m_velocity = velocity;

	handleDetonates();

	float interval = memory::interfaces::globalVars->m_intervalPerTick;
	for (; m_tick < game::timeToTicks(500.0f); m_tick++) // 500 = 500 * 2 about 1000+
	{
		if (m_nextTick <= m_tick)
			handleDestroy();

		if (m_tick < ticks)
			continue;

		if (step(interval))
			break;

		push();
	}

	m_nadeEndTime = nadeThrowTime + game::ticksToTime(m_tick);
}

void NadeTrace_t::destroyTrace()
{
	m_detonated = true;
}

void NadeTrace_t::push()
{
	m_path.push_back(m_pos);
}

bool NadeTrace_t::draw(Entity_t* entity, WeaponIndex idx)
{
	if (m_path.empty())
		return false;

	ImVec2 start; // need access outside
	if (float dist = m_path.back().distToMeters(game::localPlayer->absOrigin()); dist > vars::misc->nade->tracerDist)
		return false;

	for (Vec3 prev = m_path.front(); const auto & el : m_path)
	{
		if (ImVec2 end; imRender.worldToScreen(prev, start) && imRender.worldToScreen(el, end))
			imRender.drawLine(start, end, vars::misc->nade->colorTracer(), 2.0f);

		prev = el;
	}

	// from visuals, but not gonna use current ent pos for better look
	auto scaledFont = [=](const float division = 80.0f, const float min = 12.0f, const float max = 30.0f)
	{
		float dist = m_path.back().distTo(game::localPlayer->absOrigin());
		float fontSize = std::clamp(division / (dist / division), min, max);
		return fontSize;
	};

	float scale = ((m_nadeEndTime - memory::interfaces::globalVars->m_curtime) / game::ticksToTime(m_tick));
	float rad = scaledFont();

	imRender.drawCircleFilled(start.x, start.y, rad, 32, Colors::Black);
	imRender.drawProgressRing(start.x, start.y, rad, 32, -90, scale, 3.0f, Colors::Green);

	auto name = utilities::u8toStr(reinterpret_cast<Weapon_t*>(entity)->getIcon(idx));
	auto size = ImFonts::icon->CalcTextSizeA(rad + 5.0f, std::numeric_limits<float>::max(), 0.0f, name.c_str());
	imRender.text(start.x, start.y - (size.y / 2.0f), rad + 5.0f, ImFonts::icon, name, true, Colors::White, false);

	auto rotatePoint2D = [](const Vec2& source, const Vec2& dest, float rotateAngle)
	{
		const auto delta = dest - source;

		Vec2 pointRotation
		{
			delta[Coord::X] * std::sin(rotateAngle) - delta[Coord::Y] * std::cos(rotateAngle),
			delta[Coord::X] * std::cos(rotateAngle) + delta[Coord::Y] * std::sin(rotateAngle)
		};

		return source + pointRotation;
	};

	ImVec2 uselessVec;
	if (vars::misc->nade->tracerWarn && !imRender.worldToScreen(m_pos, uselessVec))
	{
		const auto centre = Vec2{ globals::screenX / 2.0f, globals::screenY / 2.0f };

		Vec3 localViewAngle;
		memory::interfaces::engine->getViewAngles(localViewAngle);
		const auto& localPos = game::localPlayer->absOrigin();
		const auto angleToNade = math::calcAngleRelative(localPos, m_pos, localViewAngle);

		auto screenPosition = centre;
		screenPosition[Coord::X] -= std::clamp(localPos.distTo(m_pos), 120.0f, centre[Coord::Y] - 12.0f); // 12.0f - min size possible here so wanna clip it

		const auto pos = rotatePoint2D(centre, screenPosition, math::DEG2RAD(angleToNade[Coord::Y]));

		imRender.drawCircleFilled(pos[Coord::X], pos[Coord::Y], rad, 32, Colors::Black);
		imRender.drawProgressRing(pos[Coord::X], pos[Coord::Y], rad, 32, -90.0f, scale, 3.0f, Colors::Green);

		auto name = utilities::u8toStr(reinterpret_cast<Weapon_t*>(entity)->getIcon(idx));
		auto size = ImFonts::icon->CalcTextSizeA(rad + 5.0f, std::numeric_limits<float>::max(), 0.0f, name.c_str());
		imRender.text(pos[Coord::X], pos[Coord::Y] - (size.y / 2.0f), rad + 5.0f, ImFonts::icon, name, true, Colors::White, false);
	}

	return true;
}

#include "../../cache/cache.hpp"

void GrenadeWarningPaint::draw()
{
	if (!m_datas.empty())
		m_datas.clear();

	if (!vars::misc->nade->enabledTracer)
		return;

	for (auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::GRENADE_PROJECTILES))
	{
		auto ent = reinterpret_cast<Nade_t*>(entity);

		if (ent->isDormant())
			continue;

		auto model = ent->getModel();
		if (!model)
			return;

		auto studio = memory::interfaces::modelInfo->getStudioModel(model);
		if (!studio)
			return;

		auto wpnIdx = game::getNadeByClass(classID, studio);
		if (wpnIdx == WEAPON_NONE)
			return;

		m_datas.emplace(std::make_pair(
			idx,
			NadeTrace_t
			{
				reinterpret_cast<Player_t*>(memory::interfaces::entList->getClientFromHandle(ent->m_hThrower())),
				wpnIdx
			}));

		// simulates, in this place because there is no much math related stuff needed for angles etc
		m_datas.at(idx).simulate(
			ent->m_vecOrigin(),
			reinterpret_cast<Player_t*>(ent)->m_vecVelocity(),
			ent->m_flSpawnTime(),
			game::timeToTicks(reinterpret_cast<Player_t*>(ent)->m_flSimulationTime() - ent->m_flSpawnTime())
		);

		// if no path, then delete this owner from map
		if (!m_datas.at(idx).draw(ent, wpnIdx))
			m_datas.erase(idx);
	}
}
```

`hack/cheats/features/visuals/world/nadewarn.hpp`:

```hpp
#pragma once

#include <cheats/classes/renderableToSurface.hpp>
#include <SDK/math/Vector.hpp>

#include <vector>
#include <unordered_map>

struct Trace_t;
class Entity_t;
class Player_t;
class Nade_t;
enum WeaponIndex;
struct Studiohdr_t;
class GrenadeWarningPaint;

// code not fully made by me
// Uses much less math than predicting the full throw due to existance of networkable values
class NadeTrace_t
{
public:
	NadeTrace_t() = default;
	constexpr NadeTrace_t(Player_t* owner, WeaponIndex index) :
		m_nadeOwner{ owner }, m_index{ index }
	{}

	void simulate(const Vec3& pos, const Vec3& velocity, float nadeThrowTime, uint32_t ticks);
	bool draw(Entity_t* entity, WeaponIndex idx);
private:
	void addGravityMove(Vec3& move, Vec3& vel, float frametime);
	void physicsClipVelocity(const Vec3& in, const Vec3& normal, Vec3& out, float overbounce);
	void destroyTrace();
	void push();
	void handleDetonates();
	void handleDestroy();
	bool step(float interval);
	void traceHull(const Vec3& src, const Vec3& end, Entity_t* entity, Trace_t* tr);
	void pushEntity(const Vec3& src, Trace_t& tr);
	void resolveFlyCollisionCustom(Trace_t& tr, float interval);

	bool m_detonated = false;
	// nade index
	WeaponIndex m_index = {};
	// current tick for nade loop
	uint32_t m_tick = {};
	// next tick, based on passed addon, to make this more perfect with tick timing
	uint32_t m_nextTick = {};
	// for decoy
	size_t m_bouncesCheck = 0;

	Player_t* m_nadeOwner = nullptr;
	Vec3 m_pos = {};
	Vec3 m_velocity = {};
	float m_nadeDetonateTime = {};
	float m_nadeEndTime = {};
	std::vector<Vec3> m_path = {};
};

class GrenadeWarningPaint : protected RenderableSurfaceType
{
public:
	GrenadeWarningPaint() :
		RenderableSurfaceType{}
	{}

protected:
	virtual void draw();
private:
	std::unordered_map<int, NadeTrace_t> m_datas = {};
};

GLOBAL_FEATURE(GrenadeWarningPaint);
```

`hack/cheats/features/visuals/world/projectiles.cpp`:

```cpp
#include "projectiles.hpp"

#include "nadewarn.hpp"
#include "../../cache/cache.hpp"

#include <SDK/IWeapon.hpp>
#include <SDK/IVModelInfo.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <cheats/game/game.hpp>
#include <config/vars.hpp>
#include <utilities/tools/tools.hpp>
#include <render/render.hpp>

void Projectiles::draw()
{
	if(!game::isAvailable())
		return;

	if (!vars::visuals->world->projectiles->enabled)
		return;

	for (auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::GRENADE_PROJECTILES))
	{
		auto model = entity->getModel();
		if (!model)
			continue;

		auto studio = memory::interfaces::modelInfo->getStudioModel(model);
		if (!studio)
			continue;

		auto wpn = reinterpret_cast<Weapon_t*>(entity);
		if (!wpn) // should not ever happen
			continue;

		auto wpnIdx = game::getNadeByClass(classID, studio);
		if (wpnIdx == WEAPON_NONE)
			continue;

		std::pair<std::string, Color> nades;

		switch (wpnIdx)
		{
		case WEAPON_FLASHBANG:
		{
			nades = { XOR("FLASHBANG"), vars::visuals->world->projectiles->flash() };
			break;
		}
		case WEAPON_HEGRENADE:
		{
			if (wpn->m_nExplodeEffectTickBegin() < 1) // prevent too long time
				nades = { XOR("GRENADE"), vars::visuals->world->projectiles->nade() };
			break;
		}
		case WEAPON_MOLOTOV:
		case WEAPON_INCGRENADE:
		{
			nades = { XOR("FIRE"), vars::visuals->world->projectiles->molotov() };
			break;
		}
		case WEAPON_SMOKEGRENADE:
		{
			if (!reinterpret_cast<Smoke_t*>(wpn)->m_nSmokeEffectTickBegin()) // prevent too long time
				nades = { XOR("SMOKE"), vars::visuals->world->projectiles->smoke() };
			break;
		}
		case WEAPON_DECOY:
		{
			nades = { XOR("DECOY"), vars::visuals->world->projectiles->decoy() }; // this nade time is also too long, check velocity if it's very low
			break;
		}
		case WEAPON_NONE: // understand as NADE_NONE
			return;
		}

		auto [text, col] = nades;

		if (Box box{ entity }; box.isValid())
			imRender.text(box.x + box.w / 2, box.y + box.h + 2, ImFonts::verdana12, text, true, col);
	}
}
```

`hack/cheats/features/visuals/world/projectiles.hpp`:

```hpp
#pragma once

#include <cheats/classes/renderableToSurface.hpp>

class Projectiles : protected RenderableSurfaceType
{
public:
	constexpr Projectiles() :
		RenderableSurfaceType{}
	{}

protected:
	virtual void draw() override;
};

GLOBAL_FEATURE(Projectiles);

```

`hack/cheats/features/visuals/world/removeSky.cpp`:

```cpp
#include "removeSky.hpp"

#include <SDK/ICvar.hpp>
#include <SDK/Convar.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <config/vars.hpp>
#include <utilities/tools/tools.hpp>

void RemoveSky::init()
{
	m_sky = memory::interfaces::cvar->findVar(XOR("r_3dsky"));
}

void RemoveSky::run()
{
	vars::visuals->world->sky->removeSky ? m_sky->setValue(false) : m_sky->setValue(true);
}

```

`hack/cheats/features/visuals/world/removeSky.hpp`:

```hpp
#pragma once

#include <cheats/classes/doPostScreen.hpp>

class IConVar;

class RemoveSky : protected DoPostScreenType
{
public:
	constexpr RemoveSky() :
		DoPostScreenType{}
	{}

protected:
	virtual void run();
	virtual void init() override;
private:
	IConVar* m_sky;
};

GLOBAL_FEATURE(RemoveSky);

```

`hack/cheats/features/visuals/world/skybox.cpp`:

```cpp
#include "skybox.hpp"

#include <SDK/ICvar.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/math/Vector.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <utilities/tools/tools.hpp>
#include <gamememory/memory.hpp>
#include <menu/GUI-ImGui/selections.hpp>

void SkyboxEdit::init()
{
	checkCustomSkybox();
	reloadCustomSkyboxes();
}

void SkyboxEdit::run(int frame)
{
	if (frame != FRAME_RENDER_START)
		return;

	if (!m_changed)
		return;

	if (!game::isAvailable())
		return;

	// bool to point true = custom
	std::pair<int, bool> keySky;
	if (auto custom = vars::visuals->world->sky->indexCustom; custom > 0)
		keySky = { custom, true };
	else
		keySky = { vars::visuals->world->sky->indexNormal, false };

	if (keySky.first != 0 && !globals::isShutdown) // is not none and there is no shutdown
	{
		keySky.second == true
			? loadSkybox(m_allCustomSkyboxes.at(keySky.first).c_str())
			: loadSkybox(selections::skyboxes.at(keySky.first));
	}
	else
	{
		// restore the sky
		const static auto oldSky = memory::interfaces::cvar->findVar(XOR("sv_skyname"));
		loadSkybox(oldSky->m_string);
	}
}

void SkyboxEdit::loadSkybox(const std::string& name)
{
	memory::loadSky()(name.c_str());
}

void SkyboxEdit::checkCustomSkybox()
{
	auto path = std::filesystem::current_path() / XOR("csgo") / XOR("materials") / XOR("skybox");

	if (!std::filesystem::exists(path))
	{
		if (!std::filesystem::create_directories(path))
			return;
	}

	m_pathCustomSkybox = path;
}

void SkyboxEdit::reloadCustomSkyboxes()
{
	m_allCustomSkyboxes.clear();
	m_allCustomSkyboxes.emplace_back(XOR("none"));
	auto iterator = std::filesystem::directory_iterator(m_pathCustomSkybox);
	for (const auto& entry : iterator)
	{
		if (std::string name = entry.path().filename().string();
			entry.path().extension() == XOR(".vtf") && !name.empty())
		{
			m_allCustomSkyboxes.push_back(name);
		}
	}
}

```

`hack/cheats/features/visuals/world/skybox.hpp`:

```hpp
#pragma once

#include <cheats/classes/frameStage.hpp>

#include <string>
#include <filesystem>
#include <vector>

class SkyboxEdit : protected FrameStageType
{
public:
	constexpr SkyboxEdit() :
		FrameStageType{}
	{}

	void reloadCustomSkyboxes();
	std::vector<std::string> getAllCustomSkyBoxes() const { return m_allCustomSkyboxes; }
protected:
	virtual void run(int frame) override;
	virtual void init() override;
private:
	void loadSkybox(const std::string& name);
	void checkCustomSkybox();

	std::filesystem::path m_pathCustomSkybox;
	std::vector<std::string> m_allCustomSkyboxes;

	bool m_changed = false;
public:
	void handleButtonState(bool state) { m_changed = state; }
};

GLOBAL_FEATURE(SkyboxEdit);

```

`hack/cheats/features/visuals/world/smoke.cpp`:

```cpp
#include "smoke.hpp"

#include "../../cache/cache.hpp"

#include <SDK/CGlobalVars.hpp>
#include <SDK/IEffects.hpp>
#include <SDK/math/Vector.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <cheats/game/game.hpp>
#include <config/vars.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <render/render.hpp>
#include <utilities/math/math.hpp>
#include <gamememory/memory.hpp>

void SmokeDraw::draw()
{
	if (!vars::visuals->world->smoke->enabled)
		return;

	for (auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::GRENADE_PROJECTILES))
	{
		if (classID != CSmokeGrenadeProjectile)
			continue;

		auto ent = reinterpret_cast<Smoke_t*>(entity);

		if (!ent->m_nSmokeEffectTickBegin())
		{
			drawCustomSmokeEffect(ent->absOrigin(), 30.0f);
			continue;
		}

		float time = game::ticksToTime(ent->m_nSmokeEffectTickBegin()) + ent->expireTime() - memory::interfaces::globalVars->m_curtime;
		float scale = time / ent->expireTime();

		const auto& origin = ent->absOrigin();
		constexpr int smokeRadius = 144;

		imRender.drawCircle3DFilled(origin, smokeRadius, 216, Colors::Grey, Colors::Black, true, 2.0f);
		drawCustomSmokeEffect(origin, smokeRadius);

		static float size = ImFonts::tahoma14->FontSize;
		if (ImVec2 s; imRender.worldToScreen(origin, s))
		{
			imRender.drawProgressRing(s.x, s.y, 25, 32, -90, scale, 5.0f, Colors::LightBlue);
			imRender.text(s.x, s.y - (size / 2.0f), ImFonts::tahoma14, FORMAT(XOR("{:.2f}s"), time), true, Colors::White);
		}
	}
}

void SmokeDraw::drawCustomSmokeEffect(const Vec3& pos, float radius)
{
	// clockwise for better effect
	Vec3 end = Vec3
	{
		radius * std::sin(memory::interfaces::globalVars->m_curtime) + pos[Coord::X],
		radius * std::cos(memory::interfaces::globalVars->m_curtime) + pos[Coord::Y],
		pos[Coord::Z]
	};

	memory::interfaces::effects->smoke(end, -1, 5.0f, 1.0f);
}

void SmokeRemoval::run(int frame)
{
	if (frame != FRAME_RENDER_START)
		return;

	if (!game::localPlayer)
		return;

	if (vars::visuals->world->smoke->enabled) // remove effects from inside, this is why we nulling smoke count
		*reinterpret_cast<uintptr_t*>(memory::smokeCount()) = 0;
}

```

`hack/cheats/features/visuals/world/smoke.hpp`:

```hpp
#pragma once

#include <cheats/classes/renderableToSurface.hpp>
#include <cheats/classes/frameStage.hpp>

#include <SDK/math/Vector.hpp>

class SmokeDraw : protected RenderableSurfaceType
{
public:
	constexpr SmokeDraw() :
		RenderableSurfaceType{}
	{}

protected:
	virtual void draw() override;
private:
	void drawCustomSmokeEffect(const Vec3& pos, float radius);
};

GLOBAL_FEATURE(SmokeDraw);

class SmokeRemoval : protected FrameStageType
{
public:
	constexpr SmokeRemoval() :
		FrameStageType{}
	{}

protected:
	virtual void run(int frame) override;
};

GLOBAL_FEATURE(SmokeRemoval);

```

`hack/cheats/features/visuals/world/tone.cpp`:

```cpp
#include "tone.hpp"

#include "../../cache/cache.hpp"

#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>

void ToneController::run(int frame)
{
	if (frame != FRAME_RENDER_START)
		return;

	if (!game::isAvailable())
		return;

	for (auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::CONTROLLERS))
	{
		if (classID != CEnvTonemapController)
			continue;

		auto ent = reinterpret_cast<EnvTonemapController_t*>(entity);

		// this is needed to ONLY change when we changed anything
		if (auto cfg = vars::visuals->world->tone->enabled; cfg && (m_checkStateSlider || m_checkStateButton))
		{
			ent->m_bUseCustomAutoExposureMin() = cfg;
			ent->m_bUseCustomAutoExposureMax() = cfg;
			ent->m_bUseCustomBloomScale() = cfg;
			ent->m_flCustomAutoExposureMin() = vars::visuals->world->tone->min;
			ent->m_flCustomAutoExposureMax() = vars::visuals->world->tone->max;
			ent->m_flCustomBloomScale() = vars::visuals->world->tone->bloom;
		}
		else if (globals::isShutdown || (!cfg && m_checkStateButton))
		{
			ent->m_bUseCustomAutoExposureMin() = false;
			ent->m_bUseCustomAutoExposureMax() = false;
			ent->m_bUseCustomBloomScale() = false;
		}
	}
}

```

`hack/cheats/features/visuals/world/tone.hpp`:

```hpp
#pragma once

#include <cheats/classes/frameStage.hpp>

class ToneController : protected FrameStageType
{
public:
	constexpr ToneController() :
		FrameStageType{}
	{}

	void setStateSlider(bool state) { m_checkStateSlider = state; }
	void setStateButton(bool state) { m_checkStateButton = state; }
protected:
	virtual void run(int frame) override;
private:
	bool m_checkStateSlider = false;
	bool m_checkStateButton = false;
};

GLOBAL_FEATURE(ToneController);

```

`hack/cheats/features/visuals/world/weather.cpp`:

```cpp
#include "weather.hpp"

#include <SDK/CGlobalVars.hpp>
#include <SDK/IEffects.hpp>
#include <SDK/Enums.hpp>
#include <SDK/ClientClass.hpp>
#include <SDK/IBaseClientDll.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/ICollideable.hpp>
#include <SDK/ICvar.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/math/Vector.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <utilities/utilities.hpp>
#include <utilities/rand.hpp>

#include <imgui.h>

void WeatherController::run(int frame)
{
	if (frame != FRAME_RENDER_START)
		return;

	if (!game::isAvailable())
		return;

	// when enable/shutdown
	auto reset = [this]()
	{
		if (m_weather.m_created)
		{
			m_weather.m_created = false;
			if (auto w = m_weather.m_ent)
			{
				w->release();
				w = nullptr;
			}
		}
	};

	auto getNetworkable = [this]() -> Entity_t*
	{
		auto ent = reinterpret_cast<Entity_t*>(memory::interfaces::preciptation->m_createFn(MAX_EDICTS - 1, Random::getRandom<int>(0x0, 0xFFF)));
		if (!ent)
			return nullptr;

		return ent;
	};

	// it will only actually reset when the rain is created
	if (globals::isShutdown || !vars::visuals->world->weather->enabled)
	{
		reset();
		return;
	}

	// reduce calling it often
	if (!m_weather.m_created)
	{
		if (!getNetworkable())
			return;

		m_weather.m_ent = reinterpret_cast<Entity_t*>(memory::interfaces::entList->getClientEntity(MAX_EDICTS - 1));
		if (!m_weather.m_ent)
			return;

		constexpr float halfP = Vec3::MAX_ARG / 2.0f;
		constexpr float halfM = -Vec3::MAX_ARG / 2.0f;

		m_weather.m_ent->m_nPrecipType() = PRECIPITATION_TYPE_SNOW;

		m_weather.m_ent->preDataUpdate(DATA_UPDATE_CREATED);
		m_weather.m_ent->onPreDataChanged(DATA_UPDATE_CREATED);

		m_weather.m_ent->collideable()->OBBMins() = Vec3{ halfM, halfM, halfM };
		m_weather.m_ent->collideable()->OBBMaxs() = Vec3{ halfP, halfP, halfP };

		m_weather.m_ent->onDataChanged(DATA_UPDATE_CREATED);
		m_weather.m_ent->postDataUpdate(DATA_UPDATE_CREATED);

		m_weather.m_created = true;
	}
}

void WeatherController::implMenu()
{
	const static auto cvarLenght = memory::interfaces::cvar->findVar(XOR("r_rainlength"));
	const static auto cvarRainSpeed = memory::interfaces::cvar->findVar(XOR("r_rainspeed"));
	const static auto cvarRadius = memory::interfaces::cvar->findVar(XOR("r_rainradius"));
	const static auto cvarWidth = memory::interfaces::cvar->findVar(XOR("r_rainwidth"));
	const static auto cvarSidevel = memory::interfaces::cvar->findVar(XOR("r_RainSideVel"));
	const static auto cvarAlpha = memory::interfaces::cvar->findVar(XOR("r_rainalpha"));
	const static auto cvarWindSpeed = memory::interfaces::cvar->findVar(XOR("cl_windspeed"));

	const static std::array defaults =
	{
		std::make_pair(cvarLenght, cvarLenght->getFloat()),
		std::make_pair(cvarRainSpeed, cvarRainSpeed->getFloat()),
		std::make_pair(cvarRadius, cvarRadius->getFloat()),
		std::make_pair(cvarWidth, cvarWidth->getFloat()),
		std::make_pair(cvarSidevel, cvarSidevel->getFloat()),
		std::make_pair(cvarAlpha, cvarAlpha->getFloat()),
		std::make_pair(cvarWindSpeed, cvarWindSpeed->getFloat()),
	};

	static std::once_flag onceFlag;
	std::call_once(onceFlag, [&]()
		{
			
		});

	if (ImGui::SliderFloat(XOR("r_rainlength"), &vars::visuals->world->weather->length, 0.0f, 1.0f))
	{
		cvarLenght->setValue(vars::visuals->world->weather->length);
	}
	if (ImGui::SliderFloat(XOR("r_rainspeed"), &vars::visuals->world->weather->rainSpeed, 0.0f, 1000.0f))
	{
		cvarRainSpeed->setValue(vars::visuals->world->weather->rainSpeed);
	}
	if (ImGui::SliderFloat(XOR("r_rainradius"), &vars::visuals->world->weather->radius, 0.0f, 3000.0f))
	{
		cvarRadius->setValue(vars::visuals->world->weather->radius);
	}
	if (ImGui::SliderFloat(XOR("r_rainwidth"), &vars::visuals->world->weather->width, 0.0f, 5.0f))
	{
		cvarWidth->setValue(vars::visuals->world->weather->width);
	}
	if (ImGui::SliderFloat(XOR("r_RainSideVel"), &vars::visuals->world->weather->velocity, 0.0f, 1000.0f))
	{
		cvarSidevel->setValue(vars::visuals->world->weather->velocity);
	}
	if (ImGui::SliderFloat(XOR("r_rainalpha"), &vars::visuals->world->weather->alpha, 0.0f, 1.0f))
	{
		cvarAlpha->setValue(vars::visuals->world->weather->alpha);
	}
	if (ImGui::SliderFloat(XOR("cl_windspeed"), &vars::visuals->world->weather->windSpeed, 0.0f, 1000.0f))
	{
		cvarWindSpeed->setValue(vars::visuals->world->weather->windSpeed);
	}
	if (ImGui::Button(XOR("Default rain cvars")))
	{
		for (const auto [convar, defVal] : defaults)
			convar->setValue(defVal);
	}
}

void WeatherController::reset()
{
	m_weather.m_created = false;
}
```

`hack/cheats/features/visuals/world/weather.hpp`:

```hpp
#pragma once

#include <cheats/classes/frameStage.hpp>
#include <cheats/classes/overViewMap.hpp>

class Entity_t;
class WeatherReset;
struct MapStruct;

class WeatherController : protected FrameStageType
{
public:
	constexpr WeatherController() :
		FrameStageType{}
	{}

	// add to imgui
	void implMenu();
protected:
	virtual void run(int frame) override;
	virtual void reset() override;
private:
	struct WeatherFields_t
	{
		Entity_t* m_ent = nullptr;
		bool m_created = false;
	} m_weather;

	friend WeatherReset;
};

GLOBAL_FEATURE(WeatherController);

```

`hack/cheats/features/visuals/world/zeus.cpp`:

```cpp
#include "zeus.hpp"

#include <SDK/ICvar.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/IWeapon.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <cheats/game/game.hpp>
#include <config/vars.hpp>
#include <utilities/utilities.hpp>
#include <render/render.hpp>

void ZeusDraw::init()
{
	m_party = memory::interfaces::cvar->findVar(XOR("sv_party_mode"));
}

void ZeusDraw::draw()
{
	if (!game::isAvailable())
		return;

	vars::visuals->world->zeus->party ? m_party->setValue(true) : m_party->setValue(false);

	if (!vars::visuals->world->zeus->enabled)
		return;

	auto weapon = game::localPlayer->getActiveWeapon();
	if (!weapon)
		return;

	if (weapon->m_iItemDefinitionIndex() == WEAPON_TASER)
	{
		const static float range = weapon->getWpnInfo()->m_range;
		const Vec3 abs = game::localPlayer->absOrigin() + Vec3{ 0.0f, 0.0f, 30.0f }; // small correction to get correct trace visually, will still throw false positives on stairs etc...

		Color color = vars::visuals->world->zeus->color();

		if (vars::visuals->world->zeus->tracing)
			imRender.drawCircle3DTraced(abs, range, 32, game::localPlayer(), color, true, 2.5f);
		else
			imRender.drawCircle3D(abs, range, 32, color, true, 2.0f);
	}
}
```

`hack/cheats/features/visuals/world/zeus.hpp`:

```hpp
#pragma once

#include <cheats/classes/renderableToSurface.hpp>

class IConVar;

class ZeusDraw : protected RenderableSurfaceType
{
public:
	constexpr ZeusDraw() :
		RenderableSurfaceType{}
	{}

protected:
	virtual void draw() override;
	virtual void init() override;
private:
	IConVar* m_party;
};

GLOBAL_FEATURE(ZeusDraw);

```

`hack/cheats/game/game.cpp`:

```cpp
#include "game.hpp"

#include <SDK/IVEngineClient.hpp>
#include <SDK/CUserCmd.hpp>
#include <SDK/CGlobalVars.hpp>
#include <SDK/interfaces/interfaces.hpp>

bool game::isAvailable()
{
	if (!localPlayer)
		return false;

	if (!memory::interfaces::engine->isConnected())
		return false;

	if (!memory::interfaces::engine->isInGame())
		return false;

	return true;
}

float game::serverTime(CUserCmd* cmd)
{
	static int tick;
	static CUserCmd* lastCmd;

	if (cmd)
	{
		if (!lastCmd || lastCmd->m_predicted)
			tick = localPlayer->m_nTickBase();
		else
			tick++;
		lastCmd = cmd;
	}
	return tick * memory::interfaces::globalVars->m_intervalPerTick;
}

void LocalPlayer::init()
{
	m_local = memory::localPlayer();
}

uint32_t game::timeToTicks(float time)
{
	return static_cast<uint32_t>(0.5f + time / memory::interfaces::globalVars->m_intervalPerTick);
}

float game::ticksToTime(uint32_t ticks)
{
	return memory::interfaces::globalVars->m_intervalPerTick * static_cast<float>(ticks);
}

// https://www.unknowncheats.me/forum/counterstrike-global-offensive/183347-bomb-damage-indicator.html
float game::scaleDamageArmor(float dmg, const float armor)
{
	if (armor > 0.0f)
	{
		float newDmg = dmg * 0.5f;
		float scaledArmor = (dmg - newDmg) * 0.5f;

		if (scaledArmor > armor)
		{
			scaledArmor = armor * (1.0f / 0.5f);
			newDmg = dmg - scaledArmor;
		}
		dmg = newDmg;
	}

	return dmg;
}

#include <SDK/CHudChat.hpp>

bool game::isChatOpen()
{
	const auto chat = findHudElement<CHudChat*>(XOR("CCSGO_HudChat"));
	return chat->m_isOpen;
}

float game::getScaledFont(const Vec3& source, const Vec3& destination, const float division, const float min, const float max)
{
	const float dist = source.distTo(destination);
	const float fontSize = std::clamp(division / (dist / division), min, max);
	return fontSize;
}

#include <SDK/CStudioHdr.hpp>

WeaponIndex game::getNadeByClass(int idx, Studiohdr_t* studio)
{
	switch (std::string_view name = studio->m_name; idx)
	{
	case CBaseCSGrenadeProjectile:
	{
		if (name.find(XOR("ggrenade")) != std::string::npos)
			return WEAPON_HEGRENADE;
		else
			return WEAPON_FLASHBANG;
	}
	case CSmokeGrenadeProjectile:
		return WEAPON_SMOKEGRENADE;
	case CMolotovProjectile:
	{
		if (name.find(XOR("molotov")) != std::string::npos)
			return WEAPON_MOLOTOV;
		else
			return WEAPON_INCGRENADE;
	}
	case CDecoyProjectile:
		return WEAPON_DECOY;
	default:
		break;
	}

	return WEAPON_NONE;
}

Vec3 game::getViewAngles()
{
	Vec3 ret;
	memory::interfaces::engine->getViewAngles(ret);

	return ret;
}

```

`hack/cheats/game/game.hpp`:

```hpp
#pragma once

#include <SDK/structs/Entity.hpp>
#include <gamememory/memory.hpp>

class CUserCmd;
struct Studiohdr_t;

class LocalPlayer final
{
public:
	// 
	constexpr LocalPlayer()
		: m_local{ nullptr }
	{}
	// do it once only
	void init();
	// ent == localplayer
	[[nodiscard]] constexpr bool operator==(void* ent) const { return *m_local == ent; }
	// !localplayer
	[[nodiscard]] constexpr bool operator!() const { return *m_local == nullptr; }
	// get pointer to localplayer
	[[nodiscard]] constexpr Player_t* operator()() const { return *m_local; }
	// operator for making it like normal pointer
	// possible alternative use: localplayer()->
	// ^ uses no overloaded operator
	[[nodiscard]] constexpr Player_t* operator->() const { return *m_local; }
private:
	Player_t** m_local;
};

namespace game
{
	inline LocalPlayer localPlayer;
	[[nodiscard]] bool isAvailable();
	float serverTime(CUserCmd* cmd = nullptr);
	[[nodiscard]] uint32_t timeToTicks(float time);
	[[nodiscard]] float ticksToTime(uint32_t ticks);
	[[nodiscard]] float scaleDamageArmor(float dmg, const float armor);
	template<typename T = uintptr_t*>
	[[nodiscard]] T findHudElement(const std::string_view name);
	[[nodiscard]] bool isChatOpen();
	[[nodiscard]] float getScaledFont(const Vec3& source, const Vec3& destination, const float division = 80.0f, const float min = 12.0f, const float max = 30.0f);
	// studio is special case arg - because henade and flashbang have exactly same class id
	// and people who think definition index is ok are wrong, player ents DON'T hold the nade anymore in that case
	[[nodiscard]] WeaponIndex getNadeByClass(int idx, Studiohdr_t* studio);
	[[nodiscard]] Vec3 getViewAngles();
}

template<typename T>
T game::findHudElement(const std::string_view name)
{
	return reinterpret_cast<T>(memory::hudfindElement()(memory::csgoHud(), name.data()));
}
```

`hack/cheats/game/globals.hpp`:

```hpp
#pragma once

#include <Windows.h>
#include <vector>

namespace globals
{
	inline float FOV = 90.0f;
	inline HMODULE instance = NULL;
	inline int screenX = 0;
	inline int screenY = 0;
	inline int mouseX = 0;
	inline int mouseY = 0;
	inline HWND csgoWHND = NULL;
	inline bool isShutdown = false;
	inline bool isInHotkey = false;
}
```

`hack/cheats/hooks/addEntity.cpp`:

```cpp
#include "hooks.hpp"

#include <SDK/IClientEntityList.hpp>
#include <SDK/structs/Entity.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <cheats/features/cache/cache.hpp>

hooks::addEnt::value FASTCALL hooks::addEnt::hooked(FAST_ARGS, void* handleEnt, EHandle_t handle)
{
	Entity_t* ent = reinterpret_cast<Entity_t*>(memory::interfaces::entList->getClientFromHandle(handle));
	EntityCache::add(ent);

	original(thisptr, handleEnt, handle);
}
```

`hack/cheats/hooks/buildTransformations.cpp`:

```cpp
#include "hooks.hpp"

#include <SDK/CStudioHdr.hpp>
#include <SDK/CUtlVector.hpp>
#include <SDK/math/matrix.hpp>

//#include "../../SDK/CGlobalVars.hpp"
//#include "../../SDK/structs/Entity.hpp"
//#include "../../SDK/interfaces/interfaces.hpp"

// prevent spoofing convar for jiggle bones
hooks::buildTransformations::value FASTCALL hooks::buildTransformations::hooked(FAST_ARGS, CStudioHdr* hdr, void* pos, void* q, const Matrix3x4& matrix, int boneMask, void* computed)
{
	//for (int i = 1; i <= interfaces::globalVars->m_maxClients; i++)
	//{
	//    auto ent = reinterpret_cast<Entity_t*>(reinterpret_cast<uintptr_t>(thisptr) + 0x64);

	//    if (ent)
	//        continue;

	//    // and here u check flags |= 8, but there are better ways like on bottom
	//}

	CUtlVector<int> flags = hdr->m_boneFlags;

	for (int i = 0; i < hdr->m_boneFlags.m_size; i++)
	{
		hdr->m_boneFlags.m_elementsCount[i] &= ~4;
	}

	original(thisptr, hdr, pos, q, matrix, boneMask, computed);

	hdr->m_boneFlags = flags;
}
```

`hack/cheats/hooks/createEvent.cpp`:

```cpp
#include "hooks.hpp"

hooks::createEvent::value FASTCALL hooks::createEvent::hooked(FAST_ARGS, const char* name, bool allowed, uint32_t unk)
{
	//allowed = true;

	return original(thisptr, name, allowed, unk);
}
```

`hack/cheats/hooks/createMove.cpp`:

```cpp
#include "hooks.hpp"

#include "../classes/createMove.hpp"
#include "../features/prediction/prediction.hpp"
#include "../features/misc/movement/movement.hpp"
#include "../features/misc/cameras/freeCam.hpp"

#include <SDK/CUserCmd.hpp>
#include <SDK/Input.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/ClientClass.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>

#pragma warning(disable: 4409)

//bool __stdcall hooks::createMove::hooked(float inputFrame, CUserCmd* cmd)
//{
//	static auto orig = original;
//
//	game::localPlayer = reinterpret_cast<Player_t*>(interfaces::entList->getClientEntity(interfaces::engine->getLocalPlayer()));
//
//	if (!cmd || !cmd->m_commandNumber || !game::localPlayer)
//		return orig(inputFrame, cmd);
//
//	// thanks for reminding me https://github.com/Bartis1313/csgo/issues/4
//	if (orig(inputFrame, cmd))
//		interfaces::prediction->setLocalViewangles(cmd->m_viewangles);
//
//	return false;
//}

// to get the sendPacket correctly and no need to define it anywhere in headers
void FASTCALL createMoveProxy(FAST_ARGS, int sequence, float inputTime, bool active, bool& sendPacket)
{
	hooks::proxyCreateMove::original(thisptr, sequence, inputTime, active);

	CUserCmd* cmd = memory::interfaces::input->getUserCmd(0, sequence);
	if (!cmd || !cmd->m_commandNumber)
		return;

	CVerifiedUserCmd* verifiedCmd = memory::interfaces::input->getVerifiedUserCmd(sequence);
	if (!verifiedCmd)
		return;

	Vec3 oldAngle = cmd->m_viewangles;

	// otherwise we moving
	if (g_Freecam->isInCam())
	{
		cmd->m_buttons = 0;
		cmd->m_forwardmove = 0;
		cmd->m_sidemove = 0;
		cmd->m_upmove = 0;
	}

	game::serverTime(cmd);
	CreateMovePrePredictionType::runAll(cmd);

	//g_Prediction->addToPrediction(cmd, [=]()
	//	{
			CreateMoveInPredictionType::runAll(cmd);
	//	});

	CreateMovePostPredictionType::runAll(cmd);

	MovementFix::run(cmd, oldAngle);

	// don't get untrusted
	cmd->m_viewangles.normalize();
	cmd->m_viewangles.clamp();

	verifiedCmd->m_cmd = *cmd;
	verifiedCmd->m_crc = cmd->getChecksum();
}

// wrapper for function
__declspec(naked) hooks::proxyCreateMove::value FASTCALL hooks::proxyCreateMove::hooked(FAST_ARGS, int sequence, float inputFrame, bool active)
{
	__asm
	{
		push ebp
		mov ebp, esp
		push ebx
		push esp
		push active
		push inputFrame
		push sequence
		call createMoveProxy
		pop ebx
		pop ebp
		retn 0xC
	}
}
```

`hack/cheats/hooks/doPostScreenEffects.cpp`:

```cpp
#include "hooks.hpp"

#include "../classes/doPostScreen.hpp"

#include <gamememory/memory.hpp>

hooks::doPostScreenEffects::value FASTCALL hooks::doPostScreenEffects::hooked(FAST_ARGS, int val)
{
	DoPostScreenType::runAll();

	return original(memory::interfaces::clientMode(), val);
}
```

`hack/cheats/hooks/drawIndexPrimitive.cpp`:

```cpp
#include "hooks.hpp"

#include <gamememory/memory.hpp>
#include <SDK/structs/Entity.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/IVEngineClient.hpp>
#include <cheats/game/globals.hpp>
#include <cheats/game/game.hpp>
#include <SDK/material.hpp>

#include <intrin.h>
#include <Psapi.h>

// not placed in SDK, unique use-case
//struct MaterialEbp
//{
//private:
//	void* context1; // 2, probs due to 2 textures in here
//	void* context2;
//	void* stack; // is present before material is not null
//public:
//	IMaterial* material;
//private:
//	void* dynamicProp; // attachment
//	void* unkStack;
//	int unkMaybeInit;
//	void* texture1;
//	void* texture2;
//	void* heapAfterTextureCleanup;
//};

// data[0] - all combined? some global instance of stack materials
// data[1] - studiorender
// data[2] - materialsystem
// data[3] - world render list
// data[4] - entity
// ... many other heaps that pretty often are copies / post calls results. Don't need this here
static void* getStack(void** data)
{
	if (!data)
		return nullptr;

	void** next = *reinterpret_cast<void***>(data);

	const static auto retAddr = memory::renderDrawPoints();
	if (data[1] == retAddr)
	{
		/*auto m = *reinterpret_cast<IMaterial**>((uintptr_t)data[2] + 0xC);
		if (m)
		{
			printf("%s\n", m->getName());
		}*/

		return next[4];
	}

	return getStack(next);
}

static Player_t* getPlayer(void** data)
{
	return reinterpret_cast<Player_t*>(getStack(data));
}

hooks::drawIndexedPrimitive::value D3DAPI hooks::drawIndexedPrimitive::hooked(IDirect3DDevice9* device, D3DPRIMITIVETYPE primType, INT basevertexIndex, UINT minVertexIndex,
	UINT numVertices, UINT startIndex, UINT primCount)
{
	auto res = original(device, primType, basevertexIndex, minVertexIndex, numVertices, startIndex, primCount);

	void** data = nullptr;
	__asm mov data, ebp

	auto ent = getPlayer(data);
	if (!ent)
		return res;

	if (!game::localPlayer)
		return res;

	if (ent == game::localPlayer)
		return res;

	if (!ent->isAlive())
		return res;

	if (ent->isOtherTeam(game::localPlayer()))
	{
		// draw here

		// return true;
	}

	return res;
}
```

`hack/cheats/hooks/drawModel.cpp`:

```cpp
#include "hooks.hpp"

#include "../classes/drawModel.hpp"

#include <SDK/IVModelRender.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/interfaces/interfaces.hpp>

hooks::drawModel::value FASTCALL hooks::drawModel::hooked(FAST_ARGS, void* result, const DrawModelState_t& state, const ModelRenderInfo_t& info, Matrix3x4* matrix)
{
	if(!memory::interfaces::engine->isInGame() || memory::interfaces::modelRender->isForcedMaterial())
		return original(memory::interfaces::modelRender(), result, state, info, matrix);

	DrawModelType::runAll(result, state, info, matrix);

	original(memory::interfaces::modelRender(), result, state, info, matrix);
	memory::interfaces::modelRender->overrideMaterial(nullptr);
}
```

`hack/cheats/hooks/emitSound.cpp`:

```cpp
#include "hooks.hpp"

hooks::emitSound::value FASTCALL hooks::emitSound::hooked(FAST_ARGS, void* filter, int index, int channel,
	const char* name, uint32_t shash, const char* sample, float volume, int seed, int level,
	int flags, int pitch, const Vec3& origin, const Vec3& direction, void* vec, bool updatePos, float soundTime, int speakerEntity, void* soundParams)
{
	return original(thisptr, filter, index, channel,
		name, shash, sample, volume, seed, level,
		flags, pitch, origin, direction, vec, updatePos, soundTime, speakerEntity, soundParams);
}
```

`hack/cheats/hooks/eraseEntity.cpp`:

```cpp
#include "hooks.hpp"

#include <SDK/IClientEntityList.hpp>
#include <SDK/structs/Entity.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <cheats/features/cache/cache.hpp>

hooks::removeEnt::value FASTCALL hooks::removeEnt::hooked(FAST_ARGS, void* handleEnt, EHandle_t handle)
{
	Entity_t* ent = reinterpret_cast<Entity_t*>(memory::interfaces::entList->getClientFromHandle(handle));
	EntityCache::erase(ent);

	original(thisptr, handleEnt, handle);
}
```

`hack/cheats/hooks/fireIntern.cpp`:

```cpp
#include "hooks.hpp"

#include <cheats/features/events/events.hpp>

hooks::fireIntern::value FASTCALL hooks::fireIntern::hooked(FAST_ARGS, IGameEvent* event, bool server, bool client)
{
	/*for (const auto [name, funcs] : EventCallback::getCallbacks())
	{
		if (const std::string_view ename{ event->getName() }; ename == name)
		{
			for (const auto& func : funcs)
				func(event);
		}
	}*/

	original(thisptr, event, server, client);
}
```

`hack/cheats/hooks/frameStageNotify.cpp`:

```cpp
#include "hooks.hpp"

#include "../classes/frameStage.hpp"

hooks::frameStageNotify::value FASTCALL hooks::frameStageNotify::hooked(FAST_ARGS, int frame)
{
	FrameStageType::runAll(frame);

	original(thisptr, frame);
}

```

`hack/cheats/hooks/fxBlood.cpp`:

```cpp
#include "hooks.hpp"

// why this doesn't work or gets called?
// these floats are treated like 0-255 color
hooks::fxBlood::value FASTCALL hooks::fxBlood::hooked(FAST_ARGS, Vec3& pos, Vec3& dir, float r, float g, float b, float a)
{
	return original(thisptr, pos, dir, 0, 100, 200, 255);
}
```

`hack/cheats/hooks/getColorModulation.cpp`:

```cpp
#include "hooks.hpp"

#include "../features/visuals/world/modulateColors.hpp"

#include <cheats/game/globals.hpp>

hooks::getColorModulation::value FASTCALL hooks::getColorModulation::hooked(FAST_ARGS, float* r, float* g, float* b)
{
	original(thisptr, r, g, b);

	ModulateColor::run(thisptr, r, g, b);
}
```

`hack/cheats/hooks/helpers/helper.hpp`:

```hpp
#pragma once

#include <Minhook.h>
#include <utilities/tools/tools.hpp>
#include <utilities/console/console.hpp>

namespace hookHelper
{
	template<typename T>
	inline constexpr void** ORIGINAL(T& arg)
	{
		return reinterpret_cast<void**>(&arg);
	}

	inline void tryHook(void* target, void* detour, void* original, const std::string_view name)
	{
		const MH_STATUS hk = MH_CreateHook(static_cast<LPVOID>(target), static_cast<LPVOID>(detour), static_cast<LPVOID*>(original));
		if (hk != MH_OK)
			throw std::runtime_error(FORMAT(XOR("{} hook error"), name));
		LOG_INFO(XOR("{} -> {} hooked at addr 0x{:X}"), name, MH_StatusToString(hk), reinterpret_cast<uintptr_t>(target));
	}

	inline void checkAllHooks()
	{
		const auto status = MH_EnableHook(MH_ALL_HOOKS);
		if (status != MH_OK)
			throw std::runtime_error(XOR("MH_EnableHook error"));
	}

	inline void initMinhook()
	{
		if (MH_Initialize() != MH_OK)
			throw std::runtime_error(XOR("MH_Initialize error"));
	}

	inline void shutdownAllHooks()
	{
		MH_DisableHook(MH_ALL_HOOKS);
		MH_RemoveHook(MH_ALL_HOOKS);
		MH_Uninitialize();
	}
}
```

`hack/cheats/hooks/hooks.cpp`:

```cpp
#include "hooks.hpp"
#include "helpers/helper.hpp"
#include "wndproc.hpp"

#include <SDK/ConVar.hpp>
#include <SDK/ICvar.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <utilities/console/console.hpp>
#include <utilities/tools/tools.hpp>
#include <gamememory/memory.hpp>

void hooks::init()
{
#define HOOK(target, name) \
if constexpr (name::index != hooks::indexNone) { \
hookHelper::tryHook(vfunc::getVFunc(target, name::index), &name::hooked, \
	hookHelper::ORIGINAL(name::original), XOR(#name)); \
} \
else { \
	hookHelper::tryHook(target, &name::hooked, \
	hookHelper::ORIGINAL(name::original), XOR(#name)); \
}
	hookHelper::initMinhook();

	HOOK(static_cast<LPVOID>(VirtualQueryEx), hooks::customVirtualQuerry);
	HOOK(memory::clientValidAddr(), hooks::clientValidAddr);
	HOOK(memory::enginevalidAddr(), hooks::engineValidAddr);
	HOOK(memory::studioRenderValidAddr(), hooks::studioRenderValidAddr);
	HOOK(memory::materialSysValidAddr(), hooks::materialSystemValidAddr);
	HOOK(memory::isUsingPropDebug(), hooks::isUsingStaticPropDebugModes);
	HOOK(memory::getColorModulation(), hooks::getColorModulation);
	HOOK(memory::extraBonesProcessing(), hooks::doExtraBonesProcessing);
	HOOK(memory::buildTransformations(), hooks::buildTransformations);
	HOOK(memory::particleSimulate(), hooks::particlesSimulations);
	HOOK(memory::sendDataGram(), hooks::sendDatagram);
	HOOK(memory::unkOverviewMap(), hooks::unknownOverViewFun);
	HOOK(memory::isDepth(), hooks::isDepthOfField);
	HOOK(memory::fxBlood(), hooks::fxBlood);
	HOOK(memory::addEnt(), hooks::addEnt);
	HOOK(memory::removeEnt(), hooks::removeEnt);
	HOOK(memory::interfaces::dx9Device(), hooks::reset);
	HOOK(memory::interfaces::dx9Device(), hooks::present);
	//HOOK(memory::interfaces::dx9Device(), hooks::drawIndexedPrimitive);
	HOOK(memory::interfaces::client(), hooks::proxyCreateMove);
	HOOK(memory::interfaces::client(), hooks::frameStageNotify);
	HOOK(memory::interfaces::client(), hooks::levelInitPreEntity);
	HOOK(memory::interfaces::client(), hooks::levelInitPostEntity);
	HOOK(memory::interfaces::client(), hooks::levelShutdown);
	HOOK(memory::interfaces::panel(), hooks::paintTraverse);
	HOOK(memory::interfaces::modelRender(), hooks::drawModel);
	HOOK(memory::interfaces::clientMode(), hooks::overrideView);
	HOOK(memory::interfaces::clientMode(), hooks::doPostScreenEffects);
	HOOK(memory::interfaces::surface(), hooks::lockCursor);
	HOOK(memory::interfaces::cvar->findVar(XOR("sv_cheats")), hooks::sv_cheats);
	HOOK(memory::interfaces::fileSystem(), hooks::unknownFileSystem);
	HOOK(memory::interfaces::fileSystem(), hooks::unkFileCheck);
	HOOK(memory::interfaces::fileSystem(), hooks::getUnverifiedFileHashes);
	HOOK(memory::interfaces::viewRender(), hooks::viewRender);
	HOOK(memory::interfaces::viewRender(), hooks::screen2DEffect);
	HOOK(memory::interfaces::engine(), hooks::isHltv);
	HOOK(memory::isFollowedEntity(), hooks::isFollowingEntity);
	HOOK(memory::spottedEntityUpdate(), hooks::processSpottedEntityUpdate);
	HOOK(memory::interfaces::sound(), hooks::emitSound);
	HOOK(memory::interfaces::eventManager(), hooks::createEvent);
	HOOK(memory::fireInternfn(), hooks::fireIntern);
	HOOK(memory::interfaces::prediction(), hooks::runCommand);
	HOOK(memory::preRound(), hooks::preRestartRound);
	HOOK(memory::playSoundStep(), hooks::playStepSound);
	HOOK(memory::interfaces::renderView(), hooks::sceneEnd);

#undef HOOK

	hookHelper::checkAllHooks();

	LOG_INFO(XOR("hooks success"));
}

void hooks::shutdown()
{
	hookHelper::shutdownAllHooks();
}
```

`hack/cheats/hooks/hooks.hpp`:

```hpp
#pragma once

#include <SDK/math/matrix.hpp>
#include <SDK/math/Vector.hpp>

#include <d3d9.h>

enum hookIndexes
{
	PAINTTRAVERSE = 41,
	CREATEMOVE = 24,
	DRAWMODEL = 21,
	OVERRIDE = 18,
	POSTSCREENEFFECT = 44,
	FRAMESTAGE = 37,
	LOCK_CURSOR = 67,
	RESETDX = 16,
	PRESENTDX = 17,
	PROXY_MOVE = 22,
	END_SCENE = 42,
	SV_CHEATS = 13,
	DRAW_IDX_PRIMITIVE = 82,
	UNKOWN_FILESYS = 89,
	UNVERIFIED_FILE_HASHES= 101,
	UNK_FILE_CHECK = 128,
	RENDER_VIEW = 6,
	IS_HLTV = 93,
	SCREEN_2D_EFFECT = 39,
	LEVEL_INIT_PREENT = 5,
	LEVEL_INIT_POSTENT = 6,
	LEVEL_SHUTDOWN = 7,
	EMIT_SOUND = 5,
	CREATE_EVENT = 7,
	RUN_COMMAND = 19,
	RENDER_VIEW_SCENE_END = 9,
};

class IPanel;
class CViewSetup;
struct DrawModelState_t;
struct ModelRenderInfo_t;
struct CStudioHdr;
class CParticleCollection;
class INetChannel;
struct MapStruct;
class IMaterialSystem;
class IGameEvent;
class CUserCmd;
class Player_t;
class IMoveHelper;
struct EHandle_t;

#define FAST_ARGS [[maybe_unused]] void* thisptr, [[maybe_unused]] void* edx
#define FASTCALL __fastcall
// for easier macro in cpp
#define EMPTY_INDEX	0xFFF

#define HOOK_STRUCT_VFUNC(name, type, idx, ...) \
struct name { \
	using value = type; \
	using fn = type(__thiscall*)(void*, __VA_ARGS__); \
	static type __fastcall hooked(FAST_ARGS, __VA_ARGS__); \
	inline static fn original = nullptr; \
	static constexpr int index = idx; \
};

#define HOOK_STRUCT_FUNC(name, type, ...) \
struct name { \
	using value = type; \
	using fn = type(__thiscall*)(void*, __VA_ARGS__); \
	static type __fastcall hooked(FAST_ARGS, __VA_ARGS__); \
	inline static fn original = nullptr; \
	static constexpr int index = EMPTY_INDEX; \
};

#define HOOK_STRUCT_API_VFUNC(name, type, idx, ...) \
struct name { \
	using value = type; \
	using fn = type(__stdcall*)(__VA_ARGS__); \
	static type __stdcall hooked(__VA_ARGS__); \
	inline static fn original = nullptr; \
	static constexpr int index = idx; \
};

#define HOOK_STRUCT_API(name, type, ...) \
struct name { \
	using value = type; \
	using fn = type(__stdcall*)(__VA_ARGS__); \
	static type __stdcall hooked(__VA_ARGS__); \
	inline static fn original = nullptr; \
	static constexpr int index = EMPTY_INDEX; \
};

namespace hooks
{
	void init();
	void shutdown();

	inline static constexpr auto indexNone = EMPTY_INDEX;

	HOOK_STRUCT_VFUNC(paintTraverse, void, PAINTTRAVERSE, uint32_t, bool, bool);
	HOOK_STRUCT_VFUNC(drawModel, void, DRAWMODEL, void*, const DrawModelState_t&, const ModelRenderInfo_t&, Matrix3x4*);
	HOOK_STRUCT_VFUNC(overrideView, void, OVERRIDE, CViewSetup*);
	HOOK_STRUCT_VFUNC(doPostScreenEffects, int, POSTSCREENEFFECT, int);
	HOOK_STRUCT_VFUNC(frameStageNotify, void, FRAMESTAGE, int);
	HOOK_STRUCT_VFUNC(lockCursor, void, LOCK_CURSOR);
	HOOK_STRUCT_VFUNC(proxyCreateMove, void, PROXY_MOVE, int, float, bool);
	HOOK_STRUCT_VFUNC(unknownFileSystem, int, UNKOWN_FILESYS, void*);
	HOOK_STRUCT_VFUNC(getUnverifiedFileHashes, int, UNVERIFIED_FILE_HASHES, int);
	HOOK_STRUCT_VFUNC(unkFileCheck, int, UNK_FILE_CHECK);
	HOOK_STRUCT_VFUNC(sv_cheats, bool, SV_CHEATS);
	HOOK_STRUCT_VFUNC(viewRender, void, RENDER_VIEW, const CViewSetup&, const CViewSetup&, int, int);
	HOOK_STRUCT_VFUNC(isHltv, bool, IS_HLTV);
	HOOK_STRUCT_VFUNC(screen2DEffect, void, SCREEN_2D_EFFECT, CViewSetup*);
	// reset everything
	HOOK_STRUCT_VFUNC(levelInitPreEntity, void, LEVEL_INIT_PREENT, const char*);
	// map loads - use any visual change
	HOOK_STRUCT_VFUNC(levelInitPostEntity, void, LEVEL_INIT_POSTENT);
	HOOK_STRUCT_VFUNC(levelShutdown, void, LEVEL_SHUTDOWN);
	HOOK_STRUCT_VFUNC(emitSound, void, EMIT_SOUND, void*, int, int, const char*, uint32_t, const char*, float, int, int, int, int, const Vec3&, const Vec3&, void*, bool, float, int, void*);
	HOOK_STRUCT_VFUNC(createEvent, IGameEvent*, CREATE_EVENT, const char*, bool, uint32_t);
	HOOK_STRUCT_VFUNC(runCommand, void, RUN_COMMAND, Player_t*, CUserCmd*, IMoveHelper*);
	HOOK_STRUCT_VFUNC(sceneEnd, void, RENDER_VIEW_SCENE_END);

	HOOK_STRUCT_FUNC(getColorModulation, void, float*, float*, float*);
	HOOK_STRUCT_FUNC(buildTransformations, void, CStudioHdr*, void*, void*, const Matrix3x4&, int, void*);
	HOOK_STRUCT_FUNC(doExtraBonesProcessing, void, void*, void*, void* q, const Matrix3x4&, void*, void*);
	HOOK_STRUCT_FUNC(particlesSimulations, void);
	HOOK_STRUCT_FUNC(sendDatagram, int, void*);
	HOOK_STRUCT_FUNC(unknownOverViewFun, int, int);
	HOOK_STRUCT_FUNC(isDepthOfField, bool);
	HOOK_STRUCT_FUNC(fxBlood, void, Vec3&, Vec3&, float, float, float, float);
	HOOK_STRUCT_FUNC(clientValidAddr, char, const char*);
	HOOK_STRUCT_FUNC(engineValidAddr, char, const char*);
	HOOK_STRUCT_FUNC(studioRenderValidAddr, char, const char*);
	HOOK_STRUCT_FUNC(materialSystemValidAddr, char, const char*);
	HOOK_STRUCT_FUNC(isUsingStaticPropDebugModes, bool);
	HOOK_STRUCT_FUNC(addEnt, void, void*, EHandle_t);
	HOOK_STRUCT_FUNC(removeEnt, void, void*, EHandle_t);
	HOOK_STRUCT_FUNC(isFollowingEntity, bool);
	HOOK_STRUCT_FUNC(processSpottedEntityUpdate, bool, void*);
	HOOK_STRUCT_FUNC(fireIntern, void, IGameEvent*, bool, bool);
	HOOK_STRUCT_FUNC(preRestartRound, void);
	HOOK_STRUCT_FUNC(playStepSound, int, Vec3&, void*, float, bool, void*);
	HOOK_STRUCT_API(customVirtualQuerry, BOOL, HANDLE, LPCVOID, PMEMORY_BASIC_INFORMATION, SIZE_T);

	HOOK_STRUCT_API_VFUNC(reset, long, RESETDX, IDirect3DDevice9*, D3DPRESENT_PARAMETERS*);
	HOOK_STRUCT_API_VFUNC(present, long, PRESENTDX, IDirect3DDevice9*, RECT*, RECT*, HWND, RGNDATA*);
	HOOK_STRUCT_API_VFUNC(drawIndexedPrimitive, long, DRAW_IDX_PRIMITIVE, IDirect3DDevice9*, D3DPRIMITIVETYPE, INT, UINT, UINT, UINT, UINT);
}

#undef HOOK_STRUCT_VFUNC
#undef HOOK_STRUCT_FUNC
#undef HOOK_STRUCT_API_VFUNC
#undef HOOK_STRUCT_API
#undef EMPTY_INDEX

```

`hack/cheats/hooks/isDepth.cpp`:

```cpp
#include "hooks.hpp"

#include "../features/visuals/misc/motionblur.hpp"

hooks::isDepthOfField::value FASTCALL hooks::isDepthOfField::hooked(FAST_ARGS)
{
	MotionBlur::render();

	return false;
}
```

`hack/cheats/hooks/isFollowingEntity.cpp`:

```cpp
#include "hooks.hpp"

#include <gamememory/memory.hpp>
#include <config/vars.hpp>

hooks::isFollowingEntity::value FASTCALL hooks::isFollowingEntity::hooked(FAST_ARGS)
{
	if (vars::misc->disableItems->interpolate && _ReturnAddress() == memory::retAddrToInterpolation.cast<void*>()())
	{
		return true;
	}

	return original(thisptr);
}
```

`hack/cheats/hooks/isHltv.cpp`:

```cpp
#include "hooks.hpp"

#include <intrin.h>

#include <SDK/CGlobalVars.hpp>
#include <gamememory/memory.hpp>
#include <config/vars.hpp>

hooks::isHltv::value FASTCALL hooks::isHltv::hooked(FAST_ARGS)
{
	uintptr_t ent;
	__asm mov ent, edi

	const static auto occlusion = memory::occlusion();
	const static auto velocity = memory::velocity();
	const static auto accumulate = memory::accumulate();
	const uintptr_t ret = reinterpret_cast<uintptr_t>(_ReturnAddress());

	if (ret == occlusion)
	{
		// no need to set those values for normal view
		if (vars::misc->mirrorCam->enabled && ent)
		{
			*reinterpret_cast<int*>(ent + 0xA24) = -1;
			*reinterpret_cast<int*>(ent + 0xA30) = memory::interfaces::globalVars->m_frameCount;
			*reinterpret_cast<int*>(ent + 0xA2C) = *reinterpret_cast<int*>(ent + 0xA28);
			*reinterpret_cast<int*>(ent + 0xA28) = 0;

			return true;
		}
	}

	// skip layers & setup velocity -> or EFL_DIRTY_ABSANGVELOCITY and set direct vel not interpolated
	if (ret == velocity || ret == accumulate)
		return true;
	
	return original(thisptr);
}
```

`hack/cheats/hooks/levelInitPostEntity.cpp`:

```cpp
#include "hooks.hpp"

#include <cheats/classes/base.hpp>
#include <gamememory/memory.hpp>

hooks::levelInitPostEntity::value FASTCALL hooks::levelInitPostEntity::hooked(FAST_ARGS)
{
	g_Memory.postInit();
	BaseHack::loadAll();

	original(thisptr);
}
```

`hack/cheats/hooks/levelInitPreEntity.cpp`:

```cpp
#include "hooks.hpp"

#include <cheats/classes/base.hpp>

hooks::levelInitPreEntity::value FASTCALL hooks::levelInitPreEntity::hooked(FAST_ARGS, const char* map)
{
	BaseHack::resetAll();

	original(thisptr, map);
}
```

`hack/cheats/hooks/levelShutdown.cpp`:

```cpp
#include "hooks.hpp"

#include <SDK/interfaces/interfaces.hpp>

hooks::levelShutdown::value FASTCALL hooks::levelShutdown::hooked(FAST_ARGS)
{
	original(thisptr);
}
```

`hack/cheats/hooks/lockCursor.cpp`:

```cpp
#include "hooks.hpp"

#include <SDK/ISurface.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <menu/GUI-ImGui/menu.hpp>

hooks::lockCursor::value FASTCALL hooks::lockCursor::hooked(FAST_ARGS)
{
	if (menu.isMenuActive())
	{
		memory::interfaces::surface->unlockCursor();
		return;
	}

	original(thisptr);
}
```

`hack/cheats/hooks/overrideView.cpp`:

```cpp
#include "hooks.hpp"

#include "../classes/overrideView.hpp"

#include <SDK/CViewSetup.hpp>
#include <SDK/structs/Entity.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <cheats/game/globals.hpp>
#include <cheats/game/game.hpp>
#include <config/vars.hpp>

hooks::overrideView::value FASTCALL hooks::overrideView::hooked(FAST_ARGS, CViewSetup* view)
{	
	if(!game::isAvailable())
		return original(thisptr, view);

	if (!game::localPlayer->m_bIsScoped())
		if (auto fov = vars::misc->fov->value; fov > 0.0f || fov < 0.0f)
			view->m_fov += fov;

	globals::FOV = view->m_fov;
	OverrideViewType::runAll(view);

	original(thisptr, view);
}
```

`hack/cheats/hooks/paintTraverse.cpp`:

```cpp
#include "hooks.hpp"

#include "../classes/renderableToSurface.hpp"

#include <SDK/IVEngineClient.hpp>
#include <SDK/IPanel.hpp>
#include <SDK/ISurface.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <render/render.hpp>
#include <menu/x88Menu/x88menu.hpp>
#include <utilities/res.hpp>
#include <utilities/tools/tools.hpp>

static void getScreen()
{
	int x, y;
	memory::interfaces::engine->getScreenSize(x, y);
	globals::screenX = x;
	globals::screenY = y;
}

static void getMouse()
{
	int x, y;
	memory::interfaces::surface->getCursor(x, y);
	globals::mouseX = x;
	globals::mouseY = y;
}

hooks::paintTraverse::value FASTCALL hooks::paintTraverse::hooked(FAST_ARGS, unsigned int panel, bool forceRepaint, bool allowForce)
{
	getScreen();
	getMouse();

	if (memory::interfaces::engine->isTakingScreenshot())
		return;

	const std::string_view panelName = memory::interfaces::panel->getName(panel);

	static unsigned int panelScope = 0;
	static unsigned int panelID = 0;

	if (!panelScope)
	{
		if (panelName == XOR("HudZoom"))
			panelScope = panel;
	}
	else if (panelScope == panel)
	{
		if (memory::interfaces::engine->isInGame() && vars::misc->scope->enabled)
			return;
	}

	original(thisptr, panel, forceRepaint, allowForce);

	//static Resource res{ IDB_PNG1, "PNG" };

	if (!panelID)
	{
		if (panelName == XOR("FocusOverlayPanel"))
			panelID = panel;
	}
	else if (panelID == panel)
	{
		imRender.addToRender([]()
			{
				RenderableSurfaceType::runAll();
			});

		x88menu.draw();
	}
}
```

`hack/cheats/hooks/particlesSimulation.cpp`:

```cpp
#include "hooks.hpp"

#include <SDK/CParticelCollection.hpp>
#include <config/vars.hpp>

#include <array>
#include <string>
#include <ranges>

constexpr std::array mollyNames =
{
	"explosion_molotov_air",
	"extinguish_fire",
	"molotov_groundfire",
	"molotov_groundfire_fallback",
	"molotov_groundfire_fallback2",
	"molotov_explosion",
	"weapon_molotov_held",
	"weapon_molotov_fp",
	"weapon_molotov_thrown",
};

constexpr std::array smokenames =
{
	"explosion_smokegrenade",
	"explosion_smokegrenade_fallback"
};

constexpr std::array bloodnames =
{
	"blood_impact_light",
	"blood_impact_medium",
	"blood_impact_heavy",
	"blood_impact_light_headshot"
};

hooks::particlesSimulations::value FASTCALL hooks::particlesSimulations::hooked(FAST_ARGS)
{
	original(thisptr);

	auto ptr = reinterpret_cast<CParticleCollection*>(thisptr);
	CParticleCollection* root = ptr;
	while (root->m_parent)
		root = root->m_parent;

	std::string_view name = root->m_def.m_obj->m_name.m_buffer;
	Color colorMolly = vars::visuals->world->particles->colorMolotov();
	Color colorBlood = vars::visuals->world->particles->colorBlood();
	Color colorSmoke = vars::visuals->world->particles->colorSmoke();

	if (vars::visuals->world->particles->enabledSmoke)
	{
		if (auto itr = std::find(smokenames.cbegin(), smokenames.cend(), name); itr != smokenames.cend())
		{
			for (auto i : std::views::iota(0, ptr->m_activeParticles))
			{
				ptr->m_particleAttributes.modulateColor(colorSmoke, i);
			}
		}
	}

	if (vars::visuals->world->particles->enabledBlood)
	{
		if (auto itr = std::find(bloodnames.cbegin(), bloodnames.cend(), name); itr != bloodnames.cend())
		{
			for (auto i : std::views::iota(0, ptr->m_activeParticles))
			{
				ptr->m_particleAttributes.modulateColor(colorBlood, i);
			}
		}
	}

	if (vars::visuals->world->particles->enabledMolotov)
	{
		if (auto itr = std::find(mollyNames.cbegin(), mollyNames.cend(), name); itr != mollyNames.cend())
		{
			for (auto i : std::views::iota(0, ptr->m_activeParticles))
			{
				ptr->m_particleAttributes.modulateColor(colorMolly, i);
			}
		}
	}
}
```

`hack/cheats/hooks/playStepSound.cpp`:

```cpp
#include "hooks.hpp"

#include <cheats/game/game.hpp>
#include <cheats/features/visuals/player/sounds.hpp>

hooks::playStepSound::value FASTCALL hooks::playStepSound::hooked(FAST_ARGS, Vec3& origin, void* surface, float volume, bool force, void* unk)
{
	if (!thisptr)
		return original(thisptr, origin, surface, volume, force, unk);

	if(thisptr == game::localPlayer)
		return original(thisptr, origin, surface, volume, force, unk);

	SoundDraw::pushSteps(reinterpret_cast<Player_t*>(thisptr));

	return original(thisptr, origin, surface, volume, force, unk);
}
```

`hack/cheats/hooks/preRoundRestart.cpp`:

```cpp
#include "hooks.hpp"

#include <cheats/classes/base.hpp>

hooks::preRestartRound::value FASTCALL hooks::preRestartRound::hooked(FAST_ARGS)
{
	BaseHack::restartRoundAll();

	original(thisptr);
}
```

`hack/cheats/hooks/present.cpp`:

```cpp
#include "hooks.hpp"

#include "../classes/renderableToPresent.hpp"

#include <menu/GUI-ImGui/menu.hpp>
#include <menu/GUI-ImGui/background.hpp>
#include <render/render.hpp>
#include <utilities/console/console.hpp>
#include <utilities/res.hpp>
#include <utilities/tools/tools.hpp>

#include <imgui_impl_dx9.h>
#include <imgui_impl_win32.h>

#include <d3d9.h>

hooks::present::value D3DAPI hooks::present::hooked(IDirect3DDevice9* device, RECT* srcRect, RECT* dstRect, HWND window, RGNDATA* region)
{
	// check if there is any context, needed when shutdown
	if (!ImGui::GetCurrentContext())
		return original(device, srcRect, dstRect, window, region);

	static auto bOnce = [=]()
	{
		ImGui_ImplDX9_Init(device);
		// style, colors, ini file etc.
		menu.init();

		LOG_DEBUG(XOR("init for present success"));

		return true;
	} ();

	static Resource res{ IDB_PNG1, "PNG" };

	// BEGIN DRAW
	ImGui_ImplDX9_NewFrame();
	ImGui_ImplWin32_NewFrame();
	ImGui::NewFrame();
	// anything that is responsible by imgui to be drawn, not including the game's w2s
	{
		menu.draw();
		const auto imdraw = ImGui::GetBackgroundDrawList();
		imRender.renderPresent(imdraw);
		background.draw(imdraw);
		RenderablePresentType::runAll();
	}

	// END DRAW
	ImGui::EndFrame();
	ImGui::Render();

	// CHECK RENDER
	if (device->BeginScene() == D3D_OK)
	{
		ImGui_ImplDX9_RenderDrawData(ImGui::GetDrawData());
		device->EndScene();
	}

	return original(device, srcRect, dstRect, window, region);
}
```

`hack/cheats/hooks/processSpottedEntityUpdate.cpp`:

```cpp
#include "hooks.hpp"

#include <cheats/features/cache/cache.hpp>

hooks::processSpottedEntityUpdate::value FASTCALL hooks::processSpottedEntityUpdate::hooked(FAST_ARGS, void* unk) // CCSUsrMsg_ProcessSpottedEntityUpdate
{
	//int size = *reinterpret_cast<int*>((uintptr_t)unk + 0xC);
	//printf("size is %i\n", size);

	CacheFields::update();

	return original(thisptr, unk);
}
```

`hack/cheats/hooks/renderView.cpp`:

```cpp
#include "hooks.hpp"

#include "../classes/viewRender.hpp"

#include <SDK/CViewSetup.hpp>

hooks::viewRender::value FASTCALL hooks::viewRender::hooked(FAST_ARGS, const CViewSetup& view, const CViewSetup& hud, int clearFlags, int whatToDraw)
{
	ViewRenderType::runAll(view);

	original(thisptr, view, hud, clearFlags, whatToDraw);
}
```

`hack/cheats/hooks/reset.cpp`:

```cpp
#include "hooks.hpp"

#include <imgui_impl_dx9.h>

#include <d3d9.h>

hooks::reset::value D3DAPI hooks::reset::hooked(IDirect3DDevice9* device, D3DPRESENT_PARAMETERS* params)
{
	ImGui_ImplDX9_InvalidateDeviceObjects();

	const auto hr = original(device, params);

	if (hr == D3D_OK)
		ImGui_ImplDX9_CreateDeviceObjects();

	return hr;
}
```

`hack/cheats/hooks/runCommand.cpp`:

```cpp
#include "hooks.hpp"

#include <SDK/CUserCmd.hpp>
#include <SDK/IClientState.hpp>
#include <SDK/structs/Entity.hpp>

hooks::runCommand::value FASTCALL hooks::runCommand::hooked(FAST_ARGS, Player_t* player, CUserCmd* cmd, IMoveHelper* moveHelper)
{
	return original(thisptr, player, cmd, moveHelper);
}
```

`hack/cheats/hooks/screen2deffect.cpp`:

```cpp
#include "hooks.hpp"

#include "../classes/screen2dEffects.hpp"

hooks::screen2DEffect::value FASTCALL hooks::screen2DEffect::hooked(FAST_ARGS, CViewSetup* view)
{
	Screen2DEffectsType::runAll();

	original(thisptr, view);
}
```

`hack/cheats/hooks/sendDatagram.cpp`:

```cpp
#include "hooks.hpp"

#include "../features/fakelatency/fakelatency.hpp"

hooks::sendDatagram::value FASTCALL hooks::sendDatagram::hooked(FAST_ARGS, void* datagram)
{
	return FakeLatency::runDatagram(reinterpret_cast<INetChannel*>(thisptr), datagram);
}
```

`hack/cheats/hooks/unknownFIleSys.cpp`:

```cpp
#include "hooks.hpp"

#include <d3dx9.h>
#include <intrin.h>

#include "../features/visuals/radar/radar.hpp"

#include <SDK/interfaces/interfaces.hpp>
#include <utilities/console/console.hpp>
#include <utilities/tools/tools.hpp>
#include <gamememory/memory.hpp>

// A DWORD (magic number) containing the four character code value 'DDS ' (0x20534444).
#define DDS_HEADER 0x20534444

hooks::unknownFileSystem::value FASTCALL hooks::unknownFileSystem::hooked(FAST_ARGS, void* image)
{
	uintptr_t thisptrStack;
	__asm mov thisptrStack, ebx;

	//const static auto ret = utilities::patternScan(PANORAMA_DLL, UNK_FILESYS);

	// dunno, this had to be inited before (retAddr)
	if (image && _ReturnAddress() == memory::returnAddrRadarImage() && *reinterpret_cast<uintptr_t*>(image) == DDS_HEADER)
	{
		size_t size = *reinterpret_cast<size_t*>(thisptrStack + 0x50);
		// again broken
		/*Resource res{ image, size };
		radar.m_mapTexture = res.getTexture();*/

		if (auto hr = D3DXCreateTextureFromFileInMemory(memory::interfaces::dx9Device(), image, size, &g_Radar->getTexture()); hr == D3D_OK)
			LOG_INFO(XOR("Created map texture, size: {}"), size);
		else
			LOG_ERR(XOR("Creating map texture failed, code: {}"), hr);
	}

	return original(thisptr, image);
}
```

`hack/cheats/hooks/unknownOverviewMap.cpp`:

```cpp
#include "hooks.hpp"

#include "../classes/overViewMap.hpp"

#include <SDK/MapStruct.hpp>

hooks::unknownOverViewFun::value FASTCALL hooks::unknownOverViewFun::hooked(FAST_ARGS, int unk)
{
	int ret = original(thisptr, unk);
	OverViewMapType::runAll(reinterpret_cast<MapStruct*>(thisptr));
	return ret;
}
```

`hack/cheats/hooks/validAddrChecks.cpp`:

```cpp
#include "hooks.hpp"

#include <config/vars.hpp>
#include <gamememory/memory.hpp>

#include <intrin.h>

hooks::clientValidAddr::value FASTCALL hooks::clientValidAddr::hooked(FAST_ARGS, [[maybe_unused]] const char* lpModuleName)
{
	return 1;
}

hooks::engineValidAddr::value FASTCALL hooks::engineValidAddr::hooked(FAST_ARGS, [[maybe_unused]] const char* lpModuleName)
{
	return 1;
}

hooks::studioRenderValidAddr::value FASTCALL hooks::studioRenderValidAddr::hooked(FAST_ARGS, [[maybe_unused]] const char* lpModuleName)
{
	return 1;
}

hooks::materialSystemValidAddr::value FASTCALL hooks::materialSystemValidAddr::hooked(FAST_ARGS, [[maybe_unused]] const char* lpModuleName)
{
	return 1;
}

hooks::isUsingStaticPropDebugModes::value FASTCALL hooks::isUsingStaticPropDebugModes::hooked(FAST_ARGS)
{
	return vars::visuals->world->modulate->enabled; // might check ret addr, but pretty useless imho
}

hooks::doExtraBonesProcessing::value FASTCALL hooks::doExtraBonesProcessing::hooked(FAST_ARGS,
	[[maybe_unused]] void* hdr, [[maybe_unused]] void* pos,
	[[maybe_unused]] void* q, [[maybe_unused]] const Matrix3x4& matrix,
	[[maybe_unused]] void* computed, [[maybe_unused]] void* contex)
{
	return;
}

hooks::getUnverifiedFileHashes::value FASTCALL hooks::getUnverifiedFileHashes::hooked(FAST_ARGS, [[maybe_unused]] int maxFiles)
{
	return 0;
}

hooks::unkFileCheck::value FASTCALL hooks::unkFileCheck::hooked(FAST_ARGS)
{
	return 1; // 2 is kick
}

hooks::sv_cheats::value FASTCALL hooks::sv_cheats::hooked(FAST_ARGS)
{
	if (_ReturnAddress() == memory::camThink() && vars::misc->thirdp->enabled)
		return true;

	return original(thisptr);
}

#include <cheats/game/globals.hpp>
#include <utilities/console/console.hpp>
#include <utilities/tools/tools.hpp>

hooks::customVirtualQuerry::value WINAPI hooks::customVirtualQuerry::hooked(HANDLE hProcess, LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength)
{
	auto originalRes = original(hProcess, lpAddress, lpBuffer, dwLength);

	std::once_flag once;
	LPHANDLE csgo = NULL;
	std::call_once(once, [csgo]
		{
			HANDLE proc = LI_FN(GetCurrentProcess)();
			LI_FN(DuplicateHandle).cached()(proc, globals::instance, proc, csgo, PROCESS_ALL_ACCESS, FALSE, 0);
		});

	if (originalRes && hProcess == &csgo) // do it for cs ONLY
	{
		const auto before = lpBuffer->Protect;
		lpBuffer->Protect &= ~PAGE_EXECUTE;
		lpBuffer->Protect |= PAGE_NOACCESS;

		LOG_DEBUG(XOR("lpBuffer->Protect = {} now {}"), before, lpBuffer->Protect);
	}
	return originalRes;
}
```

`hack/cheats/hooks/viewRenderSceneEnd.cpp`:

```cpp
#include "hooks.hpp"

hooks::sceneEnd::value FASTCALL hooks::sceneEnd::hooked(FAST_ARGS)
{
	original(thisptr);
}
```

`hack/cheats/hooks/wndproc.cpp`:

```cpp
#include "wndproc.hpp"

#include <menu/GUI-ImGui/menu.hpp>
#include <config/vars.hpp>
#include <utilities/tools/tools.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <utilities/console/console.hpp>
#include <utilities/console/consoleDraw.hpp>

#include <MinHook.h>
#include <imgui_impl_win32.h>

extern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam);

void wndProcSys::init()
{
	currentWindow = LI_FN_CACHED(FindWindowA)(XOR("Valve001"), NULL);
	wndProcOriginal = reinterpret_cast<WNDPROC>(LI_FN(SetWindowLongW)(currentWindow, GWL_WNDPROC, reinterpret_cast<LONG>(wndProcSys::wndproc)));
}

#include <SDK/InputSystem.hpp>
#include <config/key.hpp>
#include <utilities/inputSystem.hpp>
#include <menu/x88Menu/x88menu.hpp>

void wndProcSys::shutdown()
{
	LI_FN(SetWindowLongW)(currentWindow, GWL_WNDPROC, reinterpret_cast<LONG>(wndProcSys::wndProcOriginal));
	memory::interfaces::iSystem->enableInput(true);
}

LRESULT wndProcSys::wndproc(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam)
{
	// init content for imgui, once
	static auto bOnce = [=]()
	{
		ImGui::CreateContext();
		ImGui_ImplWin32_Init(hwnd);

		LOG_INFO(XOR("init for wndProc success"));

		return true;
	} ();

	inputHandler.run(message, wparam);
	x88menu.handleKeys();

	vars::keys->aimbot.update();
	vars::keys->thirdP.update();
	vars::keys->freeLook.update();
	vars::keys->freeCam.update();
	vars::keys->mirrorCam.update();

	if (vars::keys->menu.isPressed())
		menu.changeActive();

	if (vars::keys->console.isPressed())
		g_LogDrawer->handleKeys();

	memory::interfaces::iSystem->enableInput(!menu.isMenuActive());
	
	if(menu.isMenuActive() && ImGui_ImplWin32_WndProcHandler(hwnd, message, wparam, lparam))
		return TRUE;
	
	return LI_FN_CACHED(CallWindowProcA)(wndProcOriginal, hwnd, message, wparam, lparam);
}
```

`hack/cheats/hooks/wndproc.hpp`:

```hpp
#pragma once

#include <Windows.h>

struct wndProcSys
{
	inline static WNDPROC wndProcOriginal = nullptr;
	inline static HWND currentWindow = nullptr;
	inline static LRESULT wndproc(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam);

	static void init();
	static void shutdown();
};
```

`hack/config/cfgBeam.hpp`:

```hpp
#pragma once

#include "cfgcolor.hpp"

struct CfgBeam
{
	int index;
	std::string flags;
	float life;
	CfgColor color;
	float width;
	float fadeLength;
	float amplitude;
	float speed;
	float startFrame;
	float frameRate;
	int segments;
};
```

`hack/config/cfgWeapon.cpp`:

```cpp
#include "cfgWeapon.hpp"

#include <SDK/Enums.hpp>

WeaponList CfgWeapon::getWeaponByIndex(int weaponID)
{
	switch (weaponID)
	{
	case WEAPON_GLOCK:
	case WEAPON_USP_SILENCER:
	case WEAPON_CZ75A:
	case WEAPON_P250:
	case WEAPON_TEC9:
	case WEAPON_FIVESEVEN:
	case WEAPON_ELITE:
	case WEAPON_HKP2000:
		return WeaponList::WEAPON_PISTOL;
	case WEAPON_DEAGLE:
		return WeaponList::WEAPON_DEAGLE;
	case WEAPON_REVOLVER:
		return WeaponList::WEAPON_REVOLVER;
	case WEAPON_AK47:
	case WEAPON_M4A1:
	case WEAPON_M4A1_SILENCER:
	case WEAPON_GALILAR:
	case WEAPON_FAMAS:
	case WEAPON_SG553:
	case WEAPON_AUG:
		return WeaponList::WEAPON_RIFFLE;
	case WEAPON_SSG08:
		return WeaponList::WEAPON_SCOUT;
	case WEAPON_AWP:
		return WeaponList::WEAPON_AWP;
	case WEAPON_SCAR20:
	case WEAPON_G3SG1:
		return WeaponList::WEAPON_AUTOSNIPER;
	case WEAPON_NOVA:
	case WEAPON_MAG7:
	case WEAPON_XM1014:
	case WEAPON_SAWEDOFF:
		return WeaponList::WEAPON_SHOTGUN;
	case WEAPON_NEGEV:
	case WEAPON_M249:
		return WeaponList::WEAPON_MG;
	case WEAPON_P90:
	case WEAPON_MAC10:
	case WEAPON_MP7:
	case WEAPON_MP9:
	case WEAPON_MP5SD:
	case WEAPON_UMP45:
	case WEAPON_BIZON:
		return WeaponList::WEAPON_SMG;
	default:
		return WeaponList::WEAPON_UNKNOWN;
	}
}
```

`hack/config/cfgWeapon.hpp`:

```hpp
#pragma once

#include "enums.hpp"

#include <array>

enum class WeaponList
{
	WEAPON_RIFFLE,
	WEAPON_SMG,
	WEAPON_MG,
	WEAPON_PISTOL,
	WEAPON_DEAGLE,
	WEAPON_REVOLVER,
	WEAPON_SCOUT,
	WEAPON_AWP,
	WEAPON_AUTOSNIPER,
	WEAPON_SHOTGUN,
	WEAPON_UNKNOWN,
};

class CfgWeapon
{
public:
	bool enabled = false;
	float fov = 5.0f;
	float smooth = 0.5f;
	bool randomization = false;
	float randomizationRatio = smooth / 5.0f;
	int smoothMode = static_cast<int>(SmoothMode::LINEAR);
	bool curveAim = false;
	float curveX = 0.5f;
	float curveY = 0.3f;
	int methodAim = static_cast<int>(AimbotMethod::CROSSHAIR);;
	int aimSelection = static_cast<int>(AimbotHitboxes::NEAREST);
	bool aimDelay = false;
	float aimDelayVal = 0.0f;
	bool aimBacktrack = false;
	bool rcs = false;
	float rcsX = 0.5f;
	float rcsY = 0.5f;
	bool triggerbot = false;
	float triggerbotDelay = 150.0f;
	bool smokeCheck = true;
	float flashLimit = 120.0f;

	static WeaponList getWeaponByIndex(int weaponID);
};
```

`hack/config/cfgcolor.cpp`:

```cpp
#include "cfgcolor.hpp"

#include <cmath>
#include <numbers>

#include <SDK/CGlobalVars.hpp>
#include <SDK/interfaces/interfaces.hpp>

#include "cfgcolor.hpp"

#include <cmath>
#include <numbers>

#include <SDK/CGlobalVars.hpp>
#include <gamememory/memory.hpp>

void CfgColor::updateCol(float gameTime, float multiply)
{
	this->m_color.at(0) = std::cos(gameTime * multiply) * 0.5f + 0.5f;
	this->m_color.at(1) = std::cos(gameTime * multiply - 2.0f * std::numbers::pi_v<float> / 3.0f) * 0.5f + 0.5f;
	this->m_color.at(2) = std::cos(gameTime * multiply - 4.0f * std::numbers::pi_v<float> / 3.0f) * 0.5f + 0.5f;
}

void CfgColor::refresh()
{
	if (memory::interfaces::globalVars())
	{
		if (this->getRainbow())
			this->updateCol(memory::interfaces::globalVars->m_realtime, this->getSpeed());
	}
}
```

`hack/config/cfgcolor.hpp`:

```hpp
#pragma once

#include <render/Color.hpp>

class CfgColor
{
public:
	CfgColor() = default;
	constexpr CfgColor(const Color& color, bool rainbow = false, float speed = 0.5f)
		: m_color{ color }, m_rainbow{ rainbow }, m_speed{ speed }
	{}

	constexpr CfgColor& operator=(const CfgColor& other)
	{
		this->m_color = other.getColor();
		this->m_rainbow = other.getRainbow();
		this->m_speed = other.getSpeed();
		//this->refresh();
		return *this;
	}
	constexpr CfgColor& operator=(const Color& other)
	{
		this->m_color = other;
		return *this;
	}

	auto operator()() { refresh(); return m_color; }

	constexpr Color getColor() const { return m_color; }
	constexpr Color& getColorRef() { return m_color; }
	constexpr bool getRainbow() const { return m_rainbow; }
	constexpr bool& getRainbowRef() { return m_rainbow; }
	constexpr float getSpeed() const { return m_speed; }
	constexpr float& getSpeedRef() { return m_speed; }
	void refresh();
private:
	void updateCol(float gameTime, float multiply);
	bool m_rainbow;
	Color m_color;
	float m_speed = 0.5f;
};
```

`hack/config/config.cpp`:

```cpp
#include "config.hpp"

#include "vars.hpp"
#include "jsonExtended.hpp"

#include <shlobj.h>
#include <stdexcept>
#include <format>
#include <fstream>
#include <filesystem>

#include <utilities/utilities.hpp>
#include <utilities/console/console.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <render/Color.hpp>

bool Config::save(const std::string& file)
{
	if (file.empty())
	{
		LOG_ERR(XOR("provided config name was empty"));
		return false;
	}

	json j;

	to_json(j["Aim"], *vars::aim);
	to_json(j["AimPaint"], *vars::aimPaint);
	to_json(j["Visuals"], *vars::visuals);
	to_json(j["Keys"], *vars::keys);
	to_json(j["Backtrack"], *vars::backtrack);
	to_json(j["Misc"], *vars::misc);
	to_json(j["Styling"], *vars::styling);

	try
	{
		std::ofstream out{ utilities::toLowerCase((getHackPath() / getPathForConfig(file)).string()) };
		if (!out)
			return false;

		out << std::setw(4) << j;
	}
	catch (const std::ofstream::failure& err)
	{
		LOG_ERR(XOR("Saving {} file has failed: {}"), file, err.what());
	}

	LOG_INFO(XOR("Saving file {}"), file);

	return true;
}

bool Config::load(const std::string& file)
{
	std::ifstream input{ getHackPath() / getPathForConfig(file) };
	if (!input)
		return false;

	json j = json::parse(input);

	from_json(j["Aim"], *vars::aim);
	from_json(j["AimPaint"], *vars::aimPaint);
	from_json(j["Visuals"], *vars::visuals);
	from_json(j["Keys"], *vars::keys);
	from_json(j["Backtrack"], *vars::backtrack);
	from_json(j["Misc"], *vars::misc);
	from_json(j["Styling"], *vars::styling);

	LOG_INFO(XOR("Loading file {}"), file);

	return true;
}

std::filesystem::path Config::getPathForConfig(const std::string& file)
{
	std::filesystem::path path(file);
	if (path.extension() != XOR(".cfg"))
		path.replace_extension(XOR(".cfg"));

	return path;
}

bool Config::init(const std::string& defName, const std::string& defLoadFileName, const std::filesystem::path& loadPath)
{
	m_defaultConfig = defName;
	m_defaultFileNameLoad = defLoadFileName;
	m_loadExtraPath = loadPath;

	// check if the path to where save files is even a directory
	if (auto path = getHackPath(); !std::filesystem::exists(path))
	{
		// after removal, create the folder, from there the path is possible to reach
		if (!std::filesystem::create_directories(path))
			return false;
	}

	// same thing in load
	if (auto path = getHackPath() / m_loadExtraPath; !std::filesystem::exists(path))
	{
		// after removal, create the folder, from there the path is possible to reach
		if (!std::filesystem::create_directories(path))
			return false;
	}

	// default file doesn't exist
	if (auto path = getHackPath() / m_defaultConfig; !std::filesystem::exists(path))
	{
		LOG_WARN(XOR("Creating default file, because it doesn't exist: {}"), path.string());

		if (!save(m_defaultConfig))
			return false;
	}

	// loading file doesnt exists
	if (auto path = getHackPath() / m_loadExtraPath / m_defaultFileNameLoad ; !std::filesystem::exists(path))
	{
		LOG_WARN(XOR("Creating loading file, because it doesn't exist: {}"), path.string());

		if (!startSave(m_defaultConfig))
			return false;
	}

	if (!startLoad())
		return false;

	// loaded file exists but config file is gone, then cleanup
	if (auto path = getHackPath() / loadedCfgName; !std::filesystem::exists(path))
	{
		LOG_WARN(XOR("Creating loaded file, because it doesn't exist: {}"), path.string());

		if (!save(loadedCfgName))
			return false;
	}

	if (!load(loadedCfgName))
		return false;

	// push file names with .cfg into vector
	reload();

	return true;
}

bool Config::startLoad()
{
	std::ifstream input{ getHackPath() / m_loadExtraPath / m_defaultFileNameLoad };
	if (!input)
		return false;

	json j = json::parse(input);

	from_json(j, "Name", loadedCfgName);

	return true;
}

bool Config::startSave(const std::string& name)
{
	json j;
	j["Name"] = name;

	std::ofstream out{ getHackPath() / m_loadExtraPath / m_defaultFileNameLoad };
	if (!out)
		return false;

	out << j;

	return true;
}

void Config::reload()
{
	m_allFilesInFolder.clear();
	auto iterator = std::filesystem::directory_iterator(getHackPath());
	for (const auto& entry : iterator)
	{
		if (std::string name = entry.path().filename().string();
			entry.path().extension() == XOR(".cfg") && !name.empty())
		{
			m_allFilesInFolder.push_back(name);
		}
	}
}

std::filesystem::path Config::getDocumentsPath()
{
	if (static CHAR documents[MAX_PATH]; SUCCEEDED(LI_FN_CACHED(SHGetFolderPathA)(NULL, CSIDL_PERSONAL, NULL, SHGFP_TYPE_CURRENT, documents)))
		return std::filesystem::path{ documents };

	return {};
}

std::filesystem::path Config::getHackPath() const
{
	assert(getDocumentsPath().empty() == false && "hacks path was empty");

	std::filesystem::path toReturn;
	toReturn.assign(getDocumentsPath() / m_path);
	return toReturn;
}

void Config::deleteCfg(const std::string& file)
{
	auto path = getPathForConfig(file);

	if (path.string() == m_defaultConfig)
	{
		LOG_ERR(XOR("Can't delete default config"));
		return;
	}

	if (auto toDel = getHackPath() / path; std::filesystem::remove(toDel))
		LOG_INFO(XOR("Removed config {}"), toDel.filename().string());
}
```

`hack/config/config.hpp`:

```hpp
#pragma once

#include <filesystem>
#include <vector>
#include <iostream>
#include <string>

#include "key.hpp"
#include "cfgcolor.hpp"
#include "cfgWeapon.hpp"

class Config
{
public:
	Config() = default;
	bool startLoad();
	bool startSave(const std::string& name);

	void setFolder(const std::filesystem::path& hackPath) { m_path = hackPath; }
	bool save(const std::string& file);
	bool load(const std::string& file);
	void deleteCfg(const std::string& file);
	/// <summary>
	/// init the config
	/// </summary>
	/// <param name="defName">Default name of the config</param>
	/// <param name="defLoadFileName">Default name of the filename to gather load info</param>
	/// <param name="hackPath">Default path of where config is saved</param>
	/// <param name="loadPath">Default utility path for detection which cfg to load
	/// Full path is hackPath / hackPatch, meaning you are fine with passing folder name only</param>
	/// <returns>true if success</returns>
	bool init(const std::string& defName, const std::string& defLoadFileName, const std::filesystem::path& loadPath);
	void reload();
	
	// get main folder
	[[nodiscard]] std::filesystem::path getHackPath() const;
	// get all files
	[[nodiscard]] std::vector<std::string> getAllConfigFiles() const { return m_allFilesInFolder; }
	// get documents path, static
	[[nodiscard]] static std::filesystem::path getDocumentsPath();
	// file to load
	[[nodiscard]] std::string getCfgToLoad() const { return loadedCfgName; }
	// get DEFAULT name, returns the field m_defaultConfig which never change
	[[nodiscard]] std::string getDefaultConfigName() const { return m_defaultConfig; }
	// extra folder for utilities
	[[nodiscard]] std::filesystem::path getExtraLoadPath() const { return m_loadExtraPath; }
private:
	[[nodiscard]] std::filesystem::path getPathForConfig(const std::string& file);

	std::vector<std::string> m_allFilesInFolder;
	std::string m_defaultConfig;
	std::string m_defaultFileNameLoad;
	std::string loadedCfgName;	
	std::filesystem::path m_path;
	std::filesystem::path m_loadExtraPath;
};

inline Config config;
```

`hack/config/enums.hpp`:

```hpp
#pragma once

enum class AimbotWeapon
{
	RIFFLE,
	SMG,
	MACHINE_GUN,
	PISTOL,
	DEAGLE,
	REVOLVER,
	SCOUT,
	AWP,
	AUTO_SNIPER,
	SHOTGUN
};

enum class AimbotHitboxes
{
	NEAREST,
	HEAD,
	CHEST
};

enum class SmoothMode
{
	LINEAR,
	AIM_LENGTH,
	AIM_CUBIC
};

enum class CrossHairTypes
{
	OFF,
	STATIC,
	RECOIL,
	ENGINE,
	SPREAD
};

enum class ChamsType
{
	FLAT,
	GENERIC,
	GLOW,
	METALIC,
	PEARLSCENT
};

enum class BTChamsType
{
	STABLE,
	LAST_TICK,
	RAINBOW,
	COLOR_CHANGE
};

enum class BoxTypes
{
	OFF,
	BOX2D,
	FILLED2D,
	BOX3D,
	FILLED3D
};

enum class MovementTrail
{
	BEAM,
	LINE,
	SPLASH
};

enum class EspFlags
{
	BOT,
	MONEY,
	WINS,
	RANK,
	ARMOR,
	ZOOM,
	C4,
};

enum class DroppedFlags
{
	BOX,
	TEXT,
	ICON,
	AMMO,
};

enum class MovementStraferMode
{
	OFF,
	SIDESPEED,
	ROTATE,
	DIRECTIONAL
};

enum class AimbotMethod
{
	CROSSHAIR,
	DYNAMIC
};

enum class MenuTypes
{
	CHERRY,
	DARK,
	CLASSIC,
	WHITE
};
```

`hack/config/jsonExtended.cpp`:

```cpp
#include "jsonExtended.hpp"

using namespace nlohmann::detail;

template<typename T, size_t SIZE>
void from_json(const json& j, const std::string& key, std::array<T, SIZE>& val)
{
	if (!j.contains(key))
		return;

	if (auto jval = j.at(key); jval.is_array())
	{
		// get_to throwing some weird exception to allow only numbers?
		for (size_t i = 0; i < jval.size(); i++)
			val[i] = jval[i];
		/*jval.get_to<T>(val[i]);*/
	}
}

void from_json(const json& j, CfgWeapon& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Fov", val.fov);
	from_json(j, "Smooth", val.smooth);
	from_json(j, "Smooth mode", val.smoothMode);
	from_json(j, "Randomization", val.randomization);
	from_json(j, "Randomization Ratio", val.randomizationRatio);
	from_json(j, "Curve", val.curveAim);
	from_json(j, "Curve X", val.curveX);
	from_json(j, "Curve Y", val.curveY);
	from_json(j, "Aim method", val.methodAim);
	from_json(j, "Aim selection", val.aimSelection);
	from_json(j, "Aim delay enabled", val.aimDelay);
	from_json(j, "Aim delay ms", val.aimDelayVal);
	from_json(j, "Rcs enabled", val.rcs);
	from_json(j, "Rcs X", val.rcsX);
	from_json(j, "Rcs Y", val.rcsY);
	from_json(j, "Triggerbot enabled", val.triggerbot);
	from_json(j, "Triggerbot delay", val.triggerbotDelay);
	from_json(j, "Smoke check", val.smokeCheck);
	from_json(j, "Flash alpha limit", val.flashLimit);
}

void to_json(json& j, const CfgWeapon& val)
{
	j["Enabled"] = val.enabled;
	j["Fov"] = val.fov;
	j["Smooth"] = val.smooth;
	j["Smooth mode"] = val.smoothMode;
	j["Randomization"] = val.randomization;
	j["Randomization Ratio"] = val.randomizationRatio;
	j["Curve"] = val.curveAim;
	j["Curve X"] = val.curveX;
	j["Curve Y"] = val.curveY;
	j["Aim method"] = val.methodAim;
	j["Aim selection"] = val.aimSelection;
	j["Aim delay enabled"] = val.aimDelay;
	j["Aim delay ms"] = val.aimDelayVal;
	j["Rcs enabled"] = val.rcs;
	j["Rcs X"] = val.rcsX;
	j["Rcs Y"] = val.rcsY;
	j["Triggerbot enabled"] = val.triggerbot;
	j["Triggerbot delay"] = val.triggerbotDelay;
	j["Smoke check"] = val.smokeCheck;
	j["Flash alpha limit"] = val.flashLimit;
}

void from_json(const json& j, CfgColor& val)
{
	from_json(j, "RGBA", val.getColorRef().getRef());
	from_json(j, "Rainbow", val.getRainbowRef());
	from_json(j, "Speed", val.getSpeedRef());
}
#include <iostream>

void to_json(json& j, const CfgColor& val)
{
	j["RGBA"] = val.getColor().get();
	j["Rainbow"] = val.getRainbow();
	j["Speed"] = val.getSpeed();
}

void from_json(const json& j, CfgBeam& val)
{
	from_json(j["Index"], val.index);
	from_json(j["Flags"], val.flags);
	from_json(j["Life"], val.life);
	from_json(j["BeamCol"], val.color);
	from_json(j["Width"], val.width);
	from_json(j["Fade length"], val.fadeLength);
	from_json(j["Amplitude"], val.amplitude);
	from_json(j["Speed"], val.speed);
	from_json(j["Start frame"], val.startFrame);
	from_json(j["Framerate"], val.frameRate);
	from_json(j["Segments"], val.segments);
}

void to_json(json& j, const CfgBeam& val)
{
	j["Index"] = val.index;
	j["Flags"] = val.flags;
	j["Life"] = val.life;
	j["BeamCol"]= val.color;
	j["Width"] = val.width;
	j["Fade length"] = val.fadeLength;
	j["Amplitude"] = val.amplitude;
	j["Speed"] = val.speed;
	j["Start frame"] = val.startFrame;
	j["Framerate"] = val.frameRate;
	j["Segments"] = val.segments;
}

void from_json(const json& j, Key& val)
{
	from_json(j, "Mode", val.getKeyModeInt());
	from_json(j, "Code", val.getKeyCode());
}

void to_json(json& j, const Key& val)
{
	j["Mode"] = (int)val.getKeyMode();
	j["Code"] = val.getKeyCode();
}

void from_json(const json& j, VarAim& val)
{
	from_json(j, "AimbotArr", val.weapons);
	from_json(j, "Use key", val.useKey);
}

void to_json(json& j, const VarAim& val)
{
	j["AimbotArr"] = val.weapons;
	j["Use key"] = val.useKey;
}

void from_json(const json& j, VarAimPaint& val)
{
	from_json(j, "Enabled fov", val.enabledFov);
	from_json(j, "Enabled point", val.enabledPoint);
	from_json(j["Color Fov"], val.colorFov);
	from_json(j["Color paint"], val.colorPoint);
}

void to_json(json& j, const VarAimPaint& val)
{
	j["Enabled fov"] = val.enabledFov;
	j["Enabled point"] = val.enabledPoint;
	j["Color Fov"] = val.colorFov;
	j["Color paint"] = val.colorPoint;
}

void from_json(const json& j, VarVisuals& val)
{
	from_json(j["Chams"], *val.chams);
	from_json(j["Glow"], *val.glow);
	from_json(j["Esp"], *val.esp);
	from_json(j["Sound"], *val.sound);
	from_json(j["Dormacy"], *val.dormacy);
	from_json(j["World"], *val.world);
}

void to_json(json& j, const VarVisuals& val)
{
	to_json(j["Chams"], *val.chams);
	to_json(j["Glow"], *val.glow);
	to_json(j["Esp"], *val.esp);
	to_json(j["Sound"], *val.sound);
	to_json(j["Dormacy"], *val.dormacy);
	to_json(j["World"], *val.world);
}

void from_json(const json& j, VarVisuals::VarChams& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Enabled Players", val.players);
	from_json(j, "Index of Players", val.indexPlayers);
	from_json(j["Color players"], val.colorPlayers);
	from_json(j, "Enabled XQZ Players", val.enabledXQZPlayers);
	from_json(j["Color XQZ players"], val.colorXQZPlayers);
	from_json(j, "Enabled Weapons", val.enabledWeapons);
	from_json(j, "Disable Weapons", val.weaponHide);
	from_json(j, "Index of weapons", val.indexWeapons);
	from_json(j["Color weapons"], val.colorWeapons);
	from_json(j, "Enabled Arms", val.enabledArms);
	from_json(j, "Disable Arms", val.armsHide);
	from_json(j["Color arms"], val.colorArms);
	from_json(j, "Index of arms", val.indexArms);
	from_json(j, "Enable Backtrack Chams", val.enabledBacktrack);
	from_json(j, "Index Backtrack Chams", val.indexBacktrack);
	from_json(j["Color backtrack"], val.colorBacktrack);
	from_json(j, "Backtrack chams mode", val.modeBacktrack);
	from_json(j, "Backtrack chams rainbow", val.rainbowBacktrack);
	from_json(j, "Backtrack chams speed", val.rainbowBacktrackSpeed);
}

void to_json(json& j, const VarVisuals::VarChams& val)
{
	j["Enabled"] = val.enabled;
	j["Enabled Players"] = val.players;
	j["Index of Players"] = val.indexPlayers;
	j["Color players"] = val.colorPlayers;
	j["Enabled XQZ Players"] = val.enabledXQZPlayers;
	j["Color XQZ players"] = val.colorXQZPlayers;
	j["Enabled Weapons"] = val.enabledWeapons;
	j["Disable Weapons"] = val.weaponHide;
	j["Index of weapons"] = val.indexWeapons;
	j["Color weapons"] = val.colorWeapons;
	j["Enabled Arms"] = val.enabledArms;
	j["Disable Arms"] = val.armsHide;
	j["Color arms"] = val.colorArms;
	j["Index of arms"] = val.indexArms;
	j["Enable Backtrack Chams"] = val.enabledBacktrack;
	j["Index Backtrack Chams"] = val.indexBacktrack;
	j["Color backtrack"] = val.colorBacktrack;
	j["Backtrack chams mode"] = val.modeBacktrack;
	j["Backtrack chams rainbow"] = val.rainbowBacktrack;
	j["Backtrack chams speed"] = val.rainbowBacktrackSpeed;
}

void from_json(const json& j, VarVisuals::VarGlow& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j["Color player"], val.colorPlayer);
}

void to_json(json& j, const VarVisuals::VarGlow& val)
{
	j["Enabled"] = val.enabled;
	j["Color player"] = val.colorPlayer;
}

void from_json(const json& j, VarVisuals::VarEsp& val)
{
	from_json(j["Boxes"], *val.boxes);
	from_json(j["HealthBar"], *val.healthBar);
	from_json(j["ArmorBar"], *val.armorBar);
	from_json(j["WeaponBar"], *val.weaponBar);
	from_json(j["Name"], *val.nameBar);
	from_json(j["Skeleton"], *val.skeleton);
	from_json(j["Dlight"], *val.dlight);
	from_json(j["ExtraInfo"], *val.extraInfo);
	from_json(j["Flags"], *val.flags);
	from_json(j["Lasers"], *val.lasers);
	from_json(j["Checks"], *val.checks);
	from_json(j["Dropped"], *val.dropped);
}

void to_json(json& j, const VarVisuals::VarEsp& val)
{
	to_json(j["Boxes"], *val.boxes);
	to_json(j["HealthBar"], *val.healthBar);
	to_json(j["ArmorBar"], *val.armorBar);
	to_json(j["WeaponBar"], *val.weaponBar);
	to_json(j["Name"], *val.nameBar);
	to_json(j["Skeleton"], *val.skeleton);
	to_json(j["Dlight"], *val.dlight);
	to_json(j["ExtraInfo"], *val.extraInfo);
	to_json(j["Flags"], *val.flags);
	to_json(j["Lasers"], *val.lasers);
	to_json(j["Checks"], *val.checks);
	to_json(j["Dropped"], *val.dropped);
}

void from_json(const json& j, VarVisuals::VarEsp::VarBoxes& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Mode", val.mode);
	from_json(j["Lines"], val.color);
	from_json(j["Fill"], val.fill);
	from_json(j, "Outlined", val.outline);
	from_json(j, "Multicolor", val.multiColor);
	from_json(j, "Speed", val.multiColorSpeed);
}

void to_json(json& j, const VarVisuals::VarEsp::VarBoxes& val)
{
	j["Enabled"] = val.enabled;
	j["Mode"] = val.mode;
	j["Lines"] = val.color;
	j["Fill"] = val.fill;
	j["Outlined"] = val.outline;
	j["Multicolor"] = val.multiColor;
	j["Speed"] = val.multiColorSpeed;
}

void from_json(const json& j, VarVisuals::VarEsp::VarHealthBar& val)
{
	from_json(j, "Enabled", val.enabled);
}

void to_json(json& j, const VarVisuals::VarEsp::VarHealthBar& val)
{
	j["Enabled"] = val.enabled;
}

void from_json(const json& j, VarVisuals::VarEsp::VarArmorBar& val)
{
	from_json(j, "Enabled", val.enabled);
}

void to_json(json& j, const VarVisuals::VarEsp::VarArmorBar& val)
{
	j["Enabled"] = val.enabled;
}

void from_json(const json& j, VarVisuals::VarEsp::VarWeaponBar& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Enabled Translate", val.translate);
	from_json(j["Text"], val.text);
	from_json(j["Bar"], val.bar);
}

void to_json(json& j, const VarVisuals::VarEsp::VarWeaponBar& val)
{
	j["Enabled"] = val.enabled;
	j["Enabled Translate"] = val.translate;
	j["Text"] = val.text;
	j["Bar"] = val.bar;
}

void from_json(const json& j, VarVisuals::VarEsp::VarName& val)
{
	from_json(j, "Enabled", val.enabled);
}

void to_json(json& j, const VarVisuals::VarEsp::VarName& val)
{
	j["Enabled"] = val.enabled;
}

void from_json(const json& j, VarVisuals::VarEsp::VarSkeleton& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j["Lines"], val.color);
	from_json(j, "Debug points", val.showDebug);
}

void to_json(json& j, const VarVisuals::VarEsp::VarSkeleton& val)
{
	j["Enabled"] = val.enabled;
	j["Lines"] = val.color;
	j["Debug points"] = val.showDebug;
}

void from_json(const json& j, VarVisuals::VarEsp::VarDlight& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j["Color"], val.color);
	from_json(j, "Radius", val.radius);
	from_json(j, "Decay", val.decay);
	from_json(j, "Exponent", val.exponent);
}

void to_json(json& j, const VarVisuals::VarEsp::VarDlight& val)
{
	j["Enabled"] = val.enabled;
	j["Color"] = val.color;
	j["Radius"] = val.radius;
	j["Decay"] = val.decay;
	j["Exponent"] = val.exponent;
}

void from_json(const json& j, VarVisuals::VarEsp::VarExtraInfo& val)
{
	from_json(j, "Enabled", val.enabled);
}

void to_json(json& j, const VarVisuals::VarEsp::VarExtraInfo& val)
{
	j["Enabled"] = val.enabled;
}

void from_json(const json& j, VarVisuals::VarEsp::VarFlags& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Flags", val.flags);
}

void to_json(json& j, const VarVisuals::VarEsp::VarFlags& val)
{
	j["Enabled"] = val.enabled;
	j["Flags"] = val.flags;
}

void from_json(const json& j, VarVisuals::VarEsp::VarLasers& val)
{
	from_json(j, "Enabled", val.enabled);
}

void to_json(json& j, const VarVisuals::VarEsp::VarLasers& val)
{
	j["Enabled"] = val.enabled;
}

void from_json(const json& j, VarVisuals::VarEsp::VarChecks& val)
{
	from_json(j, "Dead only", val.dead);
	from_json(j, "Smoke check", val.smoke);
	from_json(j, "Visible check", val.visible);
	from_json(j, "Flash limit", val.flashLimit);
}

void to_json(json& j, const VarVisuals::VarEsp::VarChecks& val)
{
	j["Dead only"] = val.dead;
	j["Smoke check"] = val.smoke;
	j["Visible check"] = val.visible;
	j["Flash limit"] = val.flashLimit;
}

void from_json(const json& j, VarVisuals::VarEsp::VarDropped& val)
{
	from_json(j, "Enbaled", val.enabled);
	from_json(j["Color"], val.color);
	from_json(j, "Flags", val.flags);
}

void to_json(json& j, const VarVisuals::VarEsp::VarDropped& val)
{
	j["Enabled"] = val.enabled;
	j["Color"] =val.color;
	j["Flags"] = val.flags;
}

void from_json(const json& j, VarVisuals::VarSound& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j["Color"], val.color);
	from_json(j, "Time", val.time);
	from_json(j, "Max dist", val.maxDist);
	from_json(j, "Max dist line", val.maxDistLine);
	from_json(j["Line"], val.colorLine);
}

void to_json(json& j, const VarVisuals::VarSound& val)
{
	j["Enabled"] = val.enabled;
	j["Color"] = val.color;
	j["Time"] = val.enabled;
	j["Max dist"] = val.enabled;
	j["Max dist line"] = val.enabled;
	j["Line"] = val.colorLine;
}

void from_json(const json& j, VarVisuals::VarDormacy& val)
{
	from_json(j, "Time", val.time);
	from_json(j, "Time limit", val.limit);
}

void to_json(json& j, const VarVisuals::VarDormacy& val)
{
	j["Time"] = val.time;
	j["Time limit"] = val.limit;
}

void from_json(const json& j, VarVisuals::VarWorld& val)
{
	from_json(j["Bomb"], *val.bomb);
	from_json(j["Projectiles"], *val.projectiles);
	from_json(j["Sky"], *val.sky);
	from_json(j["Modulate"], *val.modulate);
	from_json(j["Molotov"], *val.molotov);
	from_json(j["Smoke"], *val.smoke);
	from_json(j["Zeus"], *val.zeus);
	from_json(j["Particles"], *val.particles);
	from_json(j["Tracer"], *val.tracer);
	from_json(j["Impacts"], *val.impacts);
	from_json(j["Fog"], *val.fog);
	from_json(j["ScreenEffect"], *val.screenEffect);
	from_json(j["Tone"], *val.tone);
	from_json(j["Weather"], *val.weather);
	from_json(j["Ambient"], *val.ambient);
}

void to_json(json& j, const VarVisuals::VarWorld& val)
{
	to_json(j["Bomb"], *val.bomb);
	to_json(j["Projectiles"], *val.projectiles);
	to_json(j["Sky"], *val.sky);
	to_json(j["Modulate"], *val.modulate);
	to_json(j["Molotov"], *val.molotov);
	to_json(j["Smoke"], *val.smoke);
	to_json(j["Zeus"], *val.zeus);
	to_json(j["Particles"], *val.particles);
	to_json(j["Tracer"], *val.tracer);
	to_json(j["Impacts"], *val.impacts);
	to_json(j["Fog"], *val.fog);
	to_json(j["ScreenEffect"], *val.screenEffect);
	to_json(j["Tone"], *val.tone);
	to_json(j["Weather"], *val.weather);
	to_json(j["Ambient"], *val.ambient);
}

void from_json(const json& j, VarVisuals::VarWorld::VarBomb& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j["Color"], val.background);
}

void to_json(json& j, const VarVisuals::VarWorld::VarBomb& val)
{
	j["Enabled"] = val.enabled;
	j["Color"] = val.background;
}

void from_json(const json& j, VarVisuals::VarWorld::VarProjectiles& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j["Flash"], val.flash);
	from_json(j["Nade"], val.nade);
	from_json(j["Molotov"], val.molotov);
	from_json(j["Smoke"], val.smoke);
	from_json(j["Decoy"], val.decoy);
}

void to_json(json& j, const VarVisuals::VarWorld::VarProjectiles& val)
{
	j["Enabled"] = val.enabled;
	j["Flash"] = val.flash;
	j["Nade"] = val.nade;
	j["Molotov"] = val.molotov;
	j["Smoke"] = val.smoke;
	j["Decoy"] = val.decoy;
}

void from_json(const json& j, VarVisuals::VarWorld::VarSky& val)
{
	from_json(j, "Skybox normal", val.indexNormal);
	from_json(j, "Skybox custom", val.indexCustom);
	from_json(j, "Remove sky", val.removeSky);
}

void to_json(json& j, const VarVisuals::VarWorld::VarSky& val)
{
	j["Skybox normal"] = val.indexNormal;
	j["Skybox custom"] = val.indexCustom;
	j["Remove sky"] = val.removeSky;
}

void from_json(const json& j, VarVisuals::VarWorld::VarModulate& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j["Texture"], val.texture);
	from_json(j["Prop"], val.prop);
	from_json(j["Sky"], val.sky);
	from_json(j, "Shader param", val.shader);
}

void to_json(json& j, const VarVisuals::VarWorld::VarModulate& val)
{
	j["Enabled"] = val.enabled;
	j["Texture"] = val.texture;
	j["Prop"] = val.prop;
	j["Sky"] = val.sky;
	j["Shader param"] = val.shader;
}

void from_json(const json& j, VarVisuals::VarWorld::VarMolotov& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j["Molly"], val.color);
	from_json(j["Text"], val.colorText);
}

void to_json(json& j, const VarVisuals::VarWorld::VarMolotov& val)
{
	j["Enabled"] = val.enabled;
	j["Molly"] = val.color;
	j["Text"] = val.colorText;
}

void from_json(const json& j, VarVisuals::VarWorld::VarSmoke& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j["Color"], val.color);
}

void to_json(json& j, const VarVisuals::VarWorld::VarSmoke& val)
{
	j["Enabled"] = val.enabled;
	j["Color"] = val.color;
}

void from_json(const json& j, VarVisuals::VarWorld::VarZeus& val)
{
	from_json(j, "Range", val.enabled);
	from_json(j, "Party", val.party);
	from_json(j, "Tracing", val.tracing);
	from_json(j["Color"], val.color);
}

void to_json(json& j, const VarVisuals::VarWorld::VarZeus& val)
{
	j["Range"] = val.enabled;
	j["Party"] = val.party;
	j["Tracing"] = val.tracing;
	j["Color"]= val.color;
}

void from_json(const json& j, VarVisuals::VarWorld::VarParticles& val)
{
	from_json(j, "Enabled Smoke", val.enabledSmoke);
	from_json(j["Smoke"], val.colorSmoke);
	from_json(j, "Enabled Blood", val.enabledBlood);
	from_json(j["Blood"], val.colorBlood);
	from_json(j, "Enabled Molly", val.enabledMolotov);
	from_json(j["Molly"], val.colorMolotov);
}

void to_json(json& j, const VarVisuals::VarWorld::VarParticles& val)
{
	j["Enabled Smoke"] = val.enabledSmoke;
	j["Smoke"], val.colorSmoke;
	j["Enabled Blood"] = val.enabledBlood;
	j["Blood"], val.colorBlood;
	j["Enabled Molly"] = val.enabledMolotov;
	j["Molly"], val.colorMolotov;
}

void from_json(const json& j, VarVisuals::VarWorld::VarTracer& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j["Beam"], val.beamTracer);
}

void to_json(json& j, const VarVisuals::VarWorld::VarTracer& val)
{
	j["Enabled"] = val.enabled;
	j["Beam"]= val.beamTracer;
}

void from_json(const json& j, VarVisuals::VarWorld::VarImpacts& val)
{
	from_json(j, "Client enabled", val.enabledClient);
	from_json(j, "Client time", val.timeClient);
	from_json(j["LineClient"], val.colorClient);
	from_json(j["FillClient"], val.colorClientFill);
	from_json(j, "Local enabled", val.enabledClient);
	from_json(j, "Local time", val.timeLocal);
	from_json(j["LineLocal"],  val.colorLocal);
	from_json(j["FillLocal"], val.colorLocalFill);
}

void to_json(json& j, const VarVisuals::VarWorld::VarImpacts& val)
{
	j["Client enabled"] = val.enabledClient;
	j["Client time"] = val.timeClient;
	j["LineClient"]= val.colorClient;
	j["FillClient"]= val.colorClientFill;
	j["Local enabled"] = val.enabledClient;
	j["Local time"] = val.timeLocal;
	j["LineLocal"]= val.colorLocal;
	j["FillLocal"]= val.colorLocalFill;
}

void from_json(const json& j, VarVisuals::VarWorld::VarFog& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Distance", val.distance);
	from_json(j["Color"], val.color);
}

void to_json(json& j, const VarVisuals::VarWorld::VarFog& val)
{
	j["Enabled"] = val.enabled;
	j["Distance"] = val.distance;
	j["Color"] = val.color;
}

void from_json(const json& j, VarVisuals::VarWorld::VarScreenEffect& val)
{
	from_json(j, "Index", val.index);
	from_json(j, "Param", val.param);
	from_json(j["Color"], val.color);
}

void to_json(json& j, const VarVisuals::VarWorld::VarScreenEffect& val)
{
	j["Index"] = val.index;
	j["Param"] = val.param;
	j["Color"] = val.color;
}

void from_json(const json& j, VarVisuals::VarWorld::VarTone& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Min", val.min);
	from_json(j, "max", val.max);
	from_json(j, "Bloom", val.bloom);
}

void to_json(json& j, const VarVisuals::VarWorld::VarTone& val)
{
	j["Enabled"] = val.enabled;
	j["Min"] = val.min;
	j["Max"] = val.max;
	j["Bloom"] = val.bloom;
}

void from_json(const json& j, VarVisuals::VarWorld::VarWeather& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Length", val.length);
	from_json(j, "Rain Speed", val.rainSpeed);
	from_json(j, "Width", val.width);
	from_json(j, "Velocity", val.velocity);
	from_json(j, "Alpha", val.alpha);
	from_json(j, "Wind", val.windSpeed);
}

void to_json(json& j, const VarVisuals::VarWorld::VarWeather& val)
{
	j["Enabled"] = val.enabled;
	j["Length"] = val.length;
	j["Rain Speed"] = val.rainSpeed;
	j["Width"] = val.width;
	j["Velocity"] = val.velocity;
	j["Alpha"] = val.alpha;
	j["Wind"] = val.windSpeed;
}

void from_json(const json& j, VarVisuals::VarWorld::VarAmbient& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j[ "Color"], val.color);
}

void to_json(json& j, const VarVisuals::VarWorld::VarAmbient& val)
{
	j["Enabled"] = val.enabled;
	j["Color"], val.color;
}

void from_json(const json& j, VarKeys& val)
{
	from_json(j, "Enabled X88", val.enabledX88Menu);
	from_json(j["Aimbot"], val.aimbot);
	from_json(j["Menu"], val.menu);
	from_json(j["Panic"], val.panic);
	from_json(j["Logs"], val.console);
	from_json(j["Freelook"], val.freeLook);
	from_json(j["MirrorCam"], val.mirrorCam);
	from_json(j["FreeCam"], val.freeCam);
	from_json(j["FlashLight"], val.flashLight);
	from_json(j["Thirdp"], val.thirdP);
}

void to_json(json& j, const VarKeys& val)
{
	j["Enabled X88"] = val.enabledX88Menu;
	j["Aimbot"] = val.aimbot;
	j["Menu"] = val.menu;
	j["Panic"] = val.panic;
	j["Logs"] = val.console;
	j["Freelook"] = val.freeLook;
	j["MirrorCam"] = val.mirrorCam;
	j["FreeCam"] = val.freeCam;
	j["FlashLight"] = val.flashLight;
	j["Thirdp"] = val.thirdP;
}

void from_json(const json& j, VarBacktrack& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Time", val.time);
	from_json(j, "Smoke", val.smoke);
	from_json(j, "Flash limit", val.flashLimit);
}

void to_json(json& j, const VarBacktrack& val)
{
	j["Enabled"] = val.enabled;
	j["Time"] = val.time;
	j["Smoke"] = val.smoke;
	j["Flash limit"] = val.flashLimit;
}

void from_json(const json& j, VarMisc& val)
{
	from_json(j["Logs"], *val.logs);
	from_json(j["Fov"], *val.fov);
	from_json(j["ThridP"], *val.thirdp);
	from_json(j["Crosshair"], *val.crosshair);
	from_json(j["FakeLatency"], *val.fakeLatency);
	from_json(j["BunnyHop"], *val.bunnyHop);
	from_json(j["Hitmarker"], *val.hitmarker);
	from_json(j["Scope"], *val.scope);
	from_json(j["Plots"], *val.plots);
	from_json(j["Info"], *val.info);
	from_json(j["Playerlist"], *val.playerList);
	from_json(j["AimWarn"], *val.aimWarn);
	from_json(j["Radar"], *val.radar);
	from_json(j["Trail"], *val.trail);
	from_json(j["Nades"], *val.nade);
	from_json(j["Hat"], *val.hat);
	from_json(j["Discord"], *val.discord);
	from_json(j["MotionBlur"], *val.motionBlur);
	from_json(j["FreeLook"], *val.freeLook);
	from_json(j["MirrorCam"], *val.mirrorCam);
	from_json(j["FreeCam"], *val.freeCam);
	from_json(j["Flashlight"], *val.flashLight);
	from_json(j["DisableItems"], *val.disableItems);
}

void to_json(json& j, const VarMisc& val)
{
	to_json(j["Logs"], *val.logs);
	to_json(j["Fov"], *val.fov);
	to_json(j["ThridP"], *val.thirdp);
	to_json(j["Crosshair"], *val.crosshair);
	to_json(j["FakeLatency"], *val.fakeLatency);
	to_json(j["BunnyHop"], *val.bunnyHop);
	to_json(j["Hitmarker"], *val.hitmarker);
	to_json(j["Scope"], *val.scope);
	to_json(j["Plots"], *val.plots);
	to_json(j["Info"], *val.info);
	to_json(j["Playerlist"], *val.playerList);
	to_json(j["AimWarn"], *val.aimWarn);
	to_json(j["Radar"], *val.radar);
	to_json(j["Trail"], *val.trail);
	to_json(j["Nades"], *val.nade);
	to_json(j["Hat"], *val.hat);
	to_json(j["Discord"], *val.discord);
	to_json(j["MotionBlur"], *val.motionBlur);
	to_json(j["FreeLook"], *val.freeLook);
	to_json(j["MirrorCam"], *val.mirrorCam);
	to_json(j["FreeCam"], *val.freeCam);
	to_json(j["Flashlight"], *val.flashLight);
	to_json(j["DisableItems"], *val.disableItems);
}

void from_json(const json& j, VarMisc::VarLogs& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Time", val.time);
}

void to_json(json& j, const VarMisc::VarLogs& val)
{
	j["Enabled"] = val.enabled;
	j["Time"] = val.time;
}

void from_json(const json& j, VarMisc::VarFov& val)
{
	from_json(j, "Fov", val.value);
}

void to_json(json& j, const VarMisc::VarFov& val)
{
	j["Fov"] = val.value;
}

void from_json(const json& j, VarMisc::VarThridP& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Distance", val.distance);
	from_json(j, "X", val.x);
	from_json(j, "Y", val.y);
}

void to_json(json& j, const VarMisc::VarThridP& val)
{
	j["Enabled"] = val.enabled;
	j["Distance"] = val.distance;
	j["X"] = val.x;
	j["Y"] = val.y;
}

void from_json(const json& j, VarMisc::VarCrosshair& val)
{
	from_json(j, "Mode", val.index);
}

void to_json(json& j, const VarMisc::VarCrosshair& val)
{
	j["Mode"] = val.index;
}

void from_json(const json& j, VarMisc::VarFakeLatency& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Amount", val.amount);
}

void to_json(json& j, const VarMisc::VarFakeLatency& val)
{
	j["Enabled"] = val.enabled;
	j["Amount"] = val.amount;
}

void from_json(const json& j, VarMisc::VarBunnyHop& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Chance", val.chance);
	from_json(j, "Mode", val.indexStrafe);
}

void to_json(json& j, const VarMisc::VarBunnyHop& val)
{
	j["Enabled"] = val.enabled;
	j["Chance"] = val.chance;
	j["Mode"] = val.indexStrafe;
}

void from_json(const json& j, VarMisc::VarHitmarker& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Play", val.play);
	from_json(j, "3D", val.enabled3D);
	from_json(j, "Resize", val.enabledResize);
	from_json(j["Normal"], val.colorNormal);
	from_json(j["Head"], val.colorHead);
	from_json(j["Dead"], val.colorDead);
	from_json(j, "Time", val.time);
}

void to_json(json& j, const VarMisc::VarHitmarker& val)
{
	j["Enabled"] = val.enabled;
	j["Play"] = val.play;
	j["3D"] = val.enabled3D;
	j["Resize"] = val.enabledResize;
	j["Normal"]=val.colorNormal;
	j["Head"]=val.colorHead;
	j["Dead"]= val.colorDead;
	j["Time"] = val.time;
}

void from_json(const json& j, VarMisc::VarScope& val)
{
	from_json(j, "Enabled", val.enabled);
}

void to_json(json& j, const VarMisc::VarScope& val)
{
	j["Enabled"] = val.enabled;
}

void from_json(const json& j, VarMisc::VarPlots& val)
{
	from_json(j, "Enabled FPS", val.enabledFps);
	from_json(j, "Enabled Velocity", val.enabledVelocity);
	from_json(j["Fps"], val.colorFPS);
	from_json(j["Velocity"], val.colorVelocity);
	from_json(j, "FPS cap", val.fpsCap);
	from_json(j, "FPS custom", val.fpsCustom);
	from_json(j, "Velocity custom", val.velocityCustom);
	from_json(j, "Velocity cap", val.velocityCap);
}

void to_json(json& j, const VarMisc::VarPlots& val)
{
	j["Enabled FPS"] = val.enabledFps;
	j["Enabled Velocity"] = val.enabledVelocity;
	j["Fps"]= val.colorFPS;
	j["Velocity"]= val.colorVelocity;
	j["FPS cap"] = val.fpsCap;
	j["FPS custom"] = val.fpsCustom;
	j["Velocity custom"] = val.velocityCustom;
	j["Velocity cap"] = val.velocityCap;
}

void from_json(const json& j, VarMisc::VarInfo& val)
{
	from_json(j, "Enabled", val.enabled);
}

void to_json(json& j, const VarMisc::VarInfo& val)
{
	j["Enabled"] = val.enabled;
}

void from_json(const json& j, VarMisc::VarPlayerList& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Health", val.health);
	from_json(j, "Team", val.teamID);
	from_json(j, "Money", val.money);
	from_json(j, "LastPlace", val.lastPlace);
}

void to_json(json& j, const VarMisc::VarPlayerList& val)
{
	j["Enabled"] = val.enabled;
	j["Health"] = val.health;
	j["Team"] = val.teamID;
	j["Money"] = val.money;
	j["LastPlace"] = val.lastPlace;
}

void from_json(const json& j, VarMisc::VarAimWarn& val)
{
	from_json(j, "Enabled", val.enabled);
}

void to_json(json& j, const VarMisc::VarAimWarn& val)
{
	j["Enabled"] = val.enabled;
}

void from_json(const json& j, VarMisc::VarRadar& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j["Line"], val.colorLine);
	from_json(j["Player"], val.colorPlayer);
	from_json(j, "Thickness", val.thickness);
	from_json(j, "Length", val.length);
	from_json(j, "Scale", val.scale);
	from_json(j, "Ranges", val.ranges);
	from_json(j, "Size", val.size);
}

void to_json(json& j, const VarMisc::VarRadar& val)
{
	j["Enabled"] = val.enabled;
	j["Line"]= val.colorLine;
	j["Player"]= val.colorPlayer;
	j["Thickness"] = val.thickness;
	j["Length"] = val.length;
	j["Scale"] = val.scale;
	j["Ranges"] = val.ranges;
	j["Size"] = val.size;
}

void from_json(const json& j, VarMisc::VarTrail& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Mode", val.mode);
	from_json(j["Color"], val.color);
	from_json(j, "Rainbow Col", val.rainbow);
	from_json(j, "Speed", val.rainbowSpeed);
	from_json(j, "Beam Speed", val.beamSpeed);
	from_json(j, "Life", val.time);
}

void to_json(json& j, const VarMisc::VarTrail& val)
{
	j["Enabled"] = val.enabled;
	j["Mode"] = val.mode;
	j["Color"]= val.color;
	j["Rainbow Col"] = val.rainbow;
	j["Speed"] = val.rainbowSpeed;
	j["Beam Speed"] = val.beamSpeed;
	j["Life"] = val.time;
}

void from_json(const json& j, VarMisc::VarNades& val)
{
	from_json(j, "Enable prediction", val.enabledPred);
	from_json(j, "Always", val.predAlways);
	from_json(j["Pred"], val.colorPredLine);
	from_json(j["Fill"], val.colorPredBoxFill);
	from_json(j["Outline"], val.colorPredBox);
	from_json(j["Enable tracer"], val.enabledTracer);
	from_json(j["TracerLine"], val.colorTracer);
	from_json(j, "Tracer distance", val.tracerDist);
	from_json(j, "Tracer warning", val.tracerWarn);
}

void to_json(json& j, const VarMisc::VarNades& val)
{
	j["Enable prediction"] = val.enabledPred;
	j["Always"] = val.predAlways;
	j["Pred"]= val.colorPredLine;
	j["Fill"]= val.colorPredBoxFill;
	j["Outline"]= val.colorPredBox;
	j["Enable tracer"] = val.enabledTracer;
	j["TracerLine"]= val.colorTracer;
	j["Tracer distance"] = val.tracerDist;
	j["Tracer warning"] = val.tracerWarn;
}

void from_json(const json& j, VarMisc::VarHat& val)
{
	from_json(j, "Enable", val.enabled);
	from_json(j, "Enable rainbow", val.rainbow);
	from_json(j, "Speed", val.rainbowSpeed);
	from_json(j, "Size", val.size);
	from_json(j, "Radius", val.radius);
	from_json(j, "Triangle alpha", val.rainbowAlpha);
	from_json(j, "Line alpha", val.rainbowLinesAlpha);
	from_json(j["Triangle"], val.colorTriangle);
	from_json(j["Line"], val.colorLine);
}

void to_json(json& j, const VarMisc::VarHat& val)
{
	j["Enable"] = val.enabled;
	j["Enable rainbow"] = val.rainbow;
	j["Speed"] = val.rainbowSpeed;
	j["Size"] = val.size;
	j["Radius"] = val.radius;
	j["Triangle alpha"] = val.rainbowAlpha;
	j["Line alpha"] = val.rainbowLinesAlpha;
	j["Triangle"]= val.colorTriangle;
	j["Line"]= val.colorLine;
}

void from_json(const json& j, VarMisc::VarDiscord& val)
{
	from_json(j, "Enable", val.enabled);
}

void to_json(json& j, const VarMisc::VarDiscord& val)
{
	j["Enable"] = val.enabled;
}

void from_json(const json& j, VarMisc::VarMotionBlur& val)
{
	from_json(j, "Enable", val.enabled);
	from_json(j, "Forward", val.forward);
	from_json(j, "Falling Intensity", val.fallingIntensity);
	from_json(j, "Falling Min", val.fallingMin);
	from_json(j, "Falling Max", val.fallingMax);
	from_json(j, "Strength", val.strength);
	from_json(j, "Rotation Intensity", val.rotationIntensity);
	from_json(j, "Roll Intensity", val.rollIntensity);
}

void to_json(json& j, const VarMisc::VarMotionBlur& val)
{
	j["Enable"] = val.enabled;
	j["Forward"] = val.forward;
	j["Falling Intensity"] = val.fallingIntensity;
	j["Falling Min"] = val.fallingMin;
	j["Falling Max"] = val.fallingMax;
	j["Strength"] = val.strength;
	j["Rotation Intensity"] = val.rotationIntensity;
	j["Roll Intensity"] = val.rollIntensity;
}

void from_json(const json& j, VarMisc::VarFreeLook& val)
{
	from_json(j, "Enable", val.enabled);
}

void to_json(json& j, const VarMisc::VarFreeLook& val)
{
	j["Enable"] = val.enabled;
}

void from_json(const json& j, VarMisc::VarMirrorCam& val)
{
	from_json(j, "Enable", val.enabled);
	from_json(j, "On key", val.onKey);
}

void to_json(json& j, const VarMisc::VarMirrorCam& val)
{
	j["Enable"] = val.enabled;
	j["On key"] = val.onKey;
}

void from_json(const json& j, VarMisc::VarFreeCam& val)
{
	from_json(j, "Enable", val.enabled);
	from_json(j, "Speed", val.speed);
}

void to_json(json& j, const VarMisc::VarFreeCam& val)
{
	j["Enable"] = val.enabled;
	j["Speed"] = val.speed;
}

void from_json(const json& j, VarMisc::VarFlashlight& val)
{
	from_json(j, "Enable", val.enabled);
	from_json(j, "Big mode", val.bigMode);
	from_json(j, "Fov", val.fov);
}

void to_json(json& j, const VarMisc::VarFlashlight& val)
{
	j["Enable"] = val.enabled;
	j["Big mode"] = val.bigMode;
	j["Fov"] = val.fov;
}

void from_json(const json& j, VarMisc::DisableItems& val)
{
	from_json(j, "Interpolate", val.interpolate);
}

void to_json(json& j, const VarMisc::DisableItems& val)
{
	j["Interpolate"] = val.interpolate;
}

#include <imgui.h>

void from_json(const json& j, VarStyling& val)
{
	from_json(j, "Index", val.index);
	from_json(j, "Background", val.background);
	from_json(j, "Background speed", val.speed);
	from_json(j, "Background distance points", val.distance);
	from_json(j, "Background points size", val.size);
	from_json(j["1"], val.color1);
	from_json(j["2"], val.color2);
	from_json(j["3"], val.color3);
	from_json(j["ImGuiStyling"], val.imStyle);
	from_json(j["GroupPanel Colors"], val.groupPanelBackground);
	from_json(j["GroupPanel Line"], val.groupPanelLines);
	from_json(j["SmoothAlpha"], val.smoothAlpha);
	from_json(j["SmoothOutline"], val.smoothOutline);
	from_json(j["SmoothPop"], val.smoothPop);
	from_json(j["SmoothMove"], val.speedMove);
}

void to_json(json& j, const VarStyling& val)
{
	j["Index"] = val.index;
	j["Background"] = val.background;
	j["Background speed"] = val.speed;
	j["Background distance points"] = val.distance;
	j["Background points size"] = val.size;
	j["1"], val.color1;
	j["2"], val.color2;
	j["3"], val.color3;
	j["ImGuiStyling"] = val.imStyle;
	j["GroupPanel Colors"] = val.groupPanelBackground;
	j["GroupPanel Line"] = val.groupPanelLines;
	j["SmoothAlpha"] = val.smoothAlpha;
	j["SmoothOutline"] = val.smoothOutline;
	j["SmoothPop"] = val.smoothPop;
	j["SmoothMove"] = val.speedMove;
}

void from_json(const json& j, ImVec2& val)
{
	from_json(j, "x", val.x);
	from_json(j, "y", val.y);
}

void to_json(json& j, const ImVec2& val)
{
	j["x"] = val.x;
	j["y"] = val.y;
}

void from_json(const json& j, ImVec4& val)
{
	from_json(j, "x", val.x);
	from_json(j, "y", val.y);
	from_json(j, "z", val.z);
	from_json(j, "w", val.w);
}

void to_json(json& j, const ImVec4& val)
{
	j["x"] = val.x;
	j["y"] = val.y;
	j["z"] = val.z;
	j["w"] = val.w;
}

// only reason for this: because span won't wrap it in one func
template<typename T, size_t SIZE>
void from_json(const json& j, const std::string& key, T val[SIZE])
{
	if (!j.contains(key))
		return;

	if (auto jval = j.at(key); jval.is_array())
	{
		// get_to throwing some weird exception to allow only numbers?
		for (size_t i = 0; i < jval.size(); i++)
			val[i] = jval[i];
		/*jval.get_to<T>(val[i]);*/
	}
}

void from_json(const json& j, ImGuiStyle& val)
{
	from_json(j, "Alpha", val.Alpha);
	from_json(j, "AisabledAlpha", val.DisabledAlpha);
	from_json(j["WindowPadding"], val.WindowPadding);
	from_json(j, "WindowRounding", val.WindowRounding);
	from_json(j, "WindowBorderSize", val.WindowBorderSize);
	from_json(j["WindowMinSize"], val.WindowMinSize);
	from_json(j["WindowTitleAlign"], val.WindowTitleAlign);
	from_json(j, "WindowMenuButtonPosition", val.WindowMenuButtonPosition);
	from_json(j, "ChildRounding", val.ChildRounding);
	from_json(j, "ChildBorderSize", val.ChildBorderSize);
	from_json(j, "PopupRounding", val.PopupRounding);
	from_json(j, "PopupBorderSize", val.PopupBorderSize);
	from_json(j["FramePadding"], val.FramePadding);
	from_json(j, "FrameRounding", val.FrameRounding);
	from_json(j, "FrameBorderSize", val.FrameBorderSize);
	from_json(j["ItemSpacing"], val.ItemSpacing);
	from_json(j["ItemInnerSpacing"], val.ItemInnerSpacing);
	from_json(j["CellPadding"], val.CellPadding);
	from_json(j["TouchExtraPadding"], val.TouchExtraPadding);
	from_json(j, "IndentSpacing", val.IndentSpacing);
	from_json(j, "ColumnsMinSpacing", val.ColumnsMinSpacing);
	from_json(j, "ScrollbarSize", val.ScrollbarSize);
	from_json(j, "ScrollbarRounding", val.ScrollbarRounding);
	from_json(j, "GrabMinSize", val.GrabMinSize);
	from_json(j, "LogSliderDeadzone", val.LogSliderDeadzone);
	from_json(j, "TabRounding", val.TabRounding);
	from_json(j, "TabBorderSize", val.TabBorderSize);
	from_json(j, "TabMinWidthForCloseButton", val.TabMinWidthForCloseButton);
	from_json(j, "ColorButtonPosition", val.ColorButtonPosition);
	from_json(j["ButtonTextAlign"], val.ButtonTextAlign);
	from_json(j["SelectableTextAlign"], val.SelectableTextAlign);
	from_json(j["DisplayWindowPadding"], val.DisplayWindowPadding);
	from_json(j["DisplaySafeAreaPadding"], val.DisplaySafeAreaPadding);
	from_json(j, "MouseCursorScale", val.MouseCursorScale);
	from_json(j, "AntiAliasedLines", val.AntiAliasedLines);
	from_json(j, "AntiAliasedLinesUseTex", val.AntiAliasedLinesUseTex);
	from_json(j, "AntiAliasedFill", val.AntiAliasedFill);
	from_json(j, "CurveTessellationTol", val.CurveTessellationTol);
	from_json(j, "CircleTessellationMaxError", val.CircleTessellationMaxError);
	from_json<ImVec4, ImGuiCol_COUNT>(j, "Colors", val.Colors);
}

void to_json(json& j, const ImGuiStyle& val)
{
	j["Alpha"] = val.Alpha;
	j["AisabledAlpha"] = val.DisabledAlpha;
	j["WindowPadding"]= val.WindowPadding;
	j["WindowRounding"] = val.WindowRounding;
	j["WindowBorderSize"] = val.WindowBorderSize;
	j["WindowMinSize"]= val.WindowMinSize;
	j["WindowTitleAlign"]= val.WindowTitleAlign;
	j["WindowMenuButtonPosition"] = val.WindowMenuButtonPosition;
	j["ChildRounding"] = val.ChildRounding;
	j["ChildBorderSize"] = val.ChildBorderSize;
	j["PopupRounding"]  = val.PopupRounding;
	j["PopupBorderSize"] = val.PopupBorderSize;
	j["FramePadding"]= val.FramePadding;
	j["FrameRounding"] = val.FrameRounding;
	j["FrameBorderSize"] = val.FrameBorderSize;
	j["ItemSpacing"]= val.ItemSpacing;
	j["ItemInnerSpacing"]= val.ItemInnerSpacing;
	j["CellPadding"]= val.CellPadding;
	j["TouchExtraPadding"]= val.TouchExtraPadding;
	j["IndentSpacing"] = val.IndentSpacing;
	j["ColumnsMinSpacing"] = val.ColumnsMinSpacing;
	j["ScrollbarSize"] = val.ScrollbarSize;
	j["ScrollbarRounding"] = val.ScrollbarRounding;
	j["GrabMinSize"] = val.GrabMinSize;
	j["LogSliderDeadzone"] = val.LogSliderDeadzone;
	j["TabRounding"] = val.TabRounding;
	j["TabBorderSize"] = val.TabBorderSize;
	j["TabMinWidthForCloseButton"] = val.TabMinWidthForCloseButton;
	j["ColorButtonPosition"] = val.ColorButtonPosition;
	j["ButtonTextAlign"]= val.ButtonTextAlign;
	j["SelectableTextAlign"]= val.SelectableTextAlign;
	j["DisplayWindowPadding"]= val.DisplayWindowPadding;
	j["DisplaySafeAreaPadding"]= val.DisplaySafeAreaPadding;
	j["MouseCursorScale"] = val.MouseCursorScale;
	j["AntiAliasedLines"] = val.AntiAliasedLines;
	j["AntiAliasedLinesUseTex"] = val.AntiAliasedLinesUseTex;
	j["AntiAliasedFill"] = val.AntiAliasedFill;
	j["CurveTessellationTol"] = val.CurveTessellationTol;
	j["CircleTessellationMaxError"] = val.CircleTessellationMaxError;
	j["Colors"] = val.Colors;
}
```

`hack/config/jsonExtended.hpp`:

```hpp
#pragma once

#include <imgui.h>

#include "vars.hpp"

#include <nlohmann/json.hpp>

struct ImVec2;
struct ImVec4;
struct ImGuiStyle;

using json = nlohmann::json;

template<typename T>
void from_json(const json& j, const std::string& key, T& val);

void to_json(json& j, const CfgWeapon& val);
void to_json(json& j, const CfgColor& val);
void to_json(json& j, const CfgBeam& val);
void to_json(json& j, const Key& val);

void to_json(json& j, const VarAim& val);
void to_json(json& j, const VarAimPaint& val);
void to_json(json& j, const VarVisuals& val);
void to_json(json& j, const VarVisuals::VarChams& val);
void to_json(json& j, const VarVisuals::VarGlow& val);
void to_json(json& j, const VarVisuals::VarEsp& val);
void to_json(json& j, const VarVisuals::VarEsp::VarBoxes& val);
void to_json(json& j, const VarVisuals::VarEsp::VarHealthBar& val);
void to_json(json& j, const VarVisuals::VarEsp::VarArmorBar& val);
void to_json(json& j, const VarVisuals::VarEsp::VarWeaponBar& val);
void to_json(json& j, const VarVisuals::VarEsp::VarName& val);
void to_json(json& j, const VarVisuals::VarEsp::VarSkeleton& val);
void to_json(json& j, const VarVisuals::VarEsp::VarDlight& val);
void to_json(json& j, const VarVisuals::VarEsp::VarExtraInfo& val);
void to_json(json& j, const VarVisuals::VarEsp::VarFlags& val);
void to_json(json& j, const VarVisuals::VarEsp::VarLasers& val);
void to_json(json& j, const VarVisuals::VarEsp::VarChecks& val);
void to_json(json& j, const VarVisuals::VarEsp::VarDropped& val);
void to_json(json& j, const VarVisuals::VarSound& val);
void to_json(json& j, const VarVisuals::VarDormacy& val);
void to_json(json& j, const VarVisuals::VarWorld& val);
void to_json(json& j, const VarVisuals::VarWorld::VarBomb& val);
void to_json(json& j, const VarVisuals::VarWorld::VarProjectiles& val);
void to_json(json& j, const VarVisuals::VarWorld::VarSky& val);
void to_json(json& j, const VarVisuals::VarWorld::VarModulate& val);
void to_json(json& j, const VarVisuals::VarWorld::VarMolotov& val);
void to_json(json& j, const VarVisuals::VarWorld::VarSmoke& val);
void to_json(json& j, const VarVisuals::VarWorld::VarZeus& val);
void to_json(json& j, const VarVisuals::VarWorld::VarParticles& val);
void to_json(json& j, const VarVisuals::VarWorld::VarTracer& val);
void to_json(json& j, const VarVisuals::VarWorld::VarImpacts& val);
void to_json(json& j, const VarVisuals::VarWorld::VarFog& val);
void to_json(json& j, const VarVisuals::VarWorld::VarScreenEffect& val);
void to_json(json& j, const VarVisuals::VarWorld::VarTone& val);
void to_json(json& j, const VarVisuals::VarWorld::VarWeather& val);
void to_json(json& j, const VarVisuals::VarWorld::VarAmbient& val);
void to_json(json& j, const VarKeys& val);
void to_json(json& j, const VarBacktrack& val);
void to_json(json& j, const VarMisc& val);
void to_json(json& j, const VarMisc::VarLogs& val);
void to_json(json& j, const VarMisc::VarFov& val);
void to_json(json& j, const VarMisc::VarThridP& val);
void to_json(json& j, const VarMisc::VarCrosshair& val);
void to_json(json& j, const VarMisc::VarFakeLatency& val);
void to_json(json& j, const VarMisc::VarBunnyHop& val);
void to_json(json& j, const VarMisc::VarHitmarker& val);
void to_json(json& j, const VarMisc::VarScope& val);
void to_json(json& j, const VarMisc::VarPlots& val);
void to_json(json& j, const VarMisc::VarInfo& val);
void to_json(json& j, const VarMisc::VarPlayerList& val);
void to_json(json& j, const VarMisc::VarAimWarn& val);
void to_json(json& j, const VarMisc::VarRadar& val);
void to_json(json& j, const VarMisc::VarTrail& val);
void to_json(json& j, const VarMisc::VarNades& val);
void to_json(json& j, const VarMisc::VarHat& val);
void to_json(json& j, const VarMisc::VarDiscord& val);
void to_json(json& j, const VarMisc::VarMotionBlur& val);
void to_json(json& j, const VarMisc::VarFreeLook& val);
void to_json(json& j, const VarMisc::VarMirrorCam& val);
void to_json(json& j, const VarMisc::VarFreeCam& val);
void to_json(json& j, const VarMisc::VarFlashlight& val);
void to_json(json& j, const VarMisc::DisableItems& val);
void to_json(json& j, const VarStyling& val);
void to_json(json& j, const ImVec2& val);
void to_json(json& j, const ImVec4& val);
void to_json(json& j, const ImGuiStyle& val);

void from_json(const json& j, CfgWeapon& val);
void from_json(const json& j, CfgColor& val);
void from_json(const json& j, CfgBeam& val);
void from_json(const json& j, Key& val);

void from_json(const json& j, VarAim& val);
void from_json(const json& j, VarAimPaint& val);
void from_json(const json& j, VarVisuals& val);
void from_json(const json& j, VarVisuals::VarChams& val);
void from_json(const json& j, VarVisuals::VarGlow& val);
void from_json(const json& j, VarVisuals::VarEsp& val);
void from_json(const json& j, VarVisuals::VarEsp::VarBoxes& val);
void from_json(const json& j, VarVisuals::VarEsp::VarHealthBar& val);
void from_json(const json& j, VarVisuals::VarEsp::VarArmorBar& val);
void from_json(const json& j, VarVisuals::VarEsp::VarWeaponBar& val);
void from_json(const json& j, VarVisuals::VarEsp::VarName& val);
void from_json(const json& j, VarVisuals::VarEsp::VarSkeleton& val);
void from_json(const json& j, VarVisuals::VarEsp::VarDlight& val);
void from_json(const json& j, VarVisuals::VarEsp::VarExtraInfo& val);
void from_json(const json& j, VarVisuals::VarEsp::VarFlags& val);
void from_json(const json& j, VarVisuals::VarEsp::VarLasers& val);
void from_json(const json& j, VarVisuals::VarEsp::VarChecks& val);
void from_json(const json& j, VarVisuals::VarEsp::VarDropped& val);
void from_json(const json& j, VarVisuals::VarSound& val);
void from_json(const json& j, VarVisuals::VarDormacy& val);
void from_json(const json& j, VarVisuals::VarWorld& val);
void from_json(const json& j, VarVisuals::VarWorld::VarBomb& val);
void from_json(const json& j, VarVisuals::VarWorld::VarProjectiles& val);
void from_json(const json& j, VarVisuals::VarWorld::VarSky& val);
void from_json(const json& j, VarVisuals::VarWorld::VarModulate& val);
void from_json(const json& j, VarVisuals::VarWorld::VarMolotov& val);
void from_json(const json& j, VarVisuals::VarWorld::VarSmoke& val);
void from_json(const json& j, VarVisuals::VarWorld::VarZeus& val);
void from_json(const json& j, VarVisuals::VarWorld::VarParticles& val);
void from_json(const json& j, VarVisuals::VarWorld::VarTracer& val);
void from_json(const json& j, VarVisuals::VarWorld::VarImpacts& val);
void from_json(const json& j, VarVisuals::VarWorld::VarFog& val);
void from_json(const json& j, VarVisuals::VarWorld::VarScreenEffect& val);
void from_json(const json& j, VarVisuals::VarWorld::VarTone& val);
void from_json(const json& j, VarVisuals::VarWorld::VarWeather& val);
void from_json(const json& j, VarVisuals::VarWorld::VarAmbient& val);
void from_json(const json& j, VarKeys& val);
void from_json(const json& j, VarBacktrack& val);
void from_json(const json& j, VarMisc& val);
void from_json(const json& j, VarMisc::VarLogs& val);
void from_json(const json& j, VarMisc::VarFov& val);
void from_json(const json& j, VarMisc::VarThridP& val);
void from_json(const json& j, VarMisc::VarCrosshair& val);
void from_json(const json& j, VarMisc::VarFakeLatency& val);
void from_json(const json& j, VarMisc::VarBunnyHop& val);
void from_json(const json& j, VarMisc::VarHitmarker& val);
void from_json(const json& j, VarMisc::VarScope& val);
void from_json(const json& j, VarMisc::VarPlots& val);
void from_json(const json& j, VarMisc::VarInfo& val);
void from_json(const json& j, VarMisc::VarPlayerList& val);
void from_json(const json& j, VarMisc::VarAimWarn& val);
void from_json(const json& j, VarMisc::VarRadar& val);
void from_json(const json& j, VarMisc::VarTrail& val);
void from_json(const json& j, VarMisc::VarNades& val);
void from_json(const json& j, VarMisc::VarHat& val);
void from_json(const json& j, VarMisc::VarDiscord& val);
void from_json(const json& j, VarMisc::VarMotionBlur& val);
void from_json(const json& j, VarMisc::VarFreeLook& val);
void from_json(const json& j, VarMisc::VarMirrorCam& val);
void from_json(const json& j, VarMisc::VarFreeCam& val);
void from_json(const json& j, VarMisc::VarFlashlight& val);
void from_json(const json& j, VarMisc::DisableItems& val);
void from_json(const json& j, VarStyling& val);
void from_json(const json& j, ImVec2& val);
void from_json(const json& j, ImVec4& val);
void from_json(const json& j, ImGuiStyle& val);

template<typename T>
void from_json(const json& j, const std::string& key, T& val)
{
	if (!j.contains(key))
		return;

	auto& jval = j.at(key);
	jval.get_to<T>(val);
}
```

`hack/config/key.cpp`:

```cpp
#include "key.hpp"

#include <Windows.h>
#include <array>

#include <utilities/inputSystem.hpp>

#include <imgui.h>

// should pass to hotkey by some callback or array arg
constexpr std::array badKeys =
{
	0x5B, 0x5C
};

// used only in menu so no need to care for own input handler here
bool Key::checkKey()
{
	for (const auto el : badKeys)
	{
		if (ImGui::IsKeyPressed(static_cast<ImGuiKey>(el)))
			return true;
	}

	// imgui has many key handlers, so mouse is not treated like keyboard
	// 0=left, 1=right, 2=middle + extras (ImGuiMouseButton_COUNT == 5)
	for (int i = 0; i < IM_ARRAYSIZE(ImGui::GetIO().MouseDown); i++)
	{
		if (ImGui::IsMouseClicked(i))
		{
			// need this switch because imgui has own bool arr
			switch (i)
			{
			case 0:
				m_keyCode = VK_LBUTTON;
				break;
			case 1:
				m_keyCode = VK_RBUTTON;
				break;
			case 2:
				m_keyCode = VK_MBUTTON;
				break;
			case 3:
				m_keyCode = VK_XBUTTON1;
				break;
			case 4:
				m_keyCode = VK_XBUTTON2;
				break;
			default:
				break;
			}
			return true;
		}
	}

	for (int i = 0; i < IM_ARRAYSIZE(ImGui::GetIO().KeysDown); i++)
	{
		if (ImGui::IsKeyPressed(static_cast<ImGuiKey>(i)))
		{
			m_keyCode = i;
			return true;
		}
	}

	return false;
}

// for mouse events
//static constexpr int keyToImKey(int id)
//{
//    switch (id)
//    {
//    case VK_LBUTTON:
//        return 0;
//    case VK_RBUTTON:
//        return 1;
//    case VK_MBUTTON:
//        return 2;
//    case VK_XBUTTON1:
//        return 3;
//    case VK_XBUTTON2:
//        return 4;
//    default:
//        return -1;
//    }
//}

void Key::update()
{
	if (m_keyMode != KeyMode::TOGGLE)
		return;

	if (isPressed())
		m_toggle = !m_toggle;
}

bool Key::isPressed() const
{
	return inputHandler.isKeyPressed(m_keyCode);
}

bool Key::isDown() const
{
	/*auto msk = keyToImKey(m_keyCode);

	if (msk >= 0 && msk <= 4)
		return ImGui::IsMouseDown(msk);*/

	return inputHandler.isKeyDown(m_keyCode);
}

bool Key::isToggled() const
{
	return m_toggle;
}

bool Key::isEnabled() const
{
	switch (m_keyMode)
	{
	case KeyMode::DOWN:
		return isDown();
	case KeyMode::TOGGLE:
		return isToggled();
	default:
		break;
	}
	return false;
}

std::array<std::pair<KeyMode, const char*>, E2T(KeyMode::KEYMODE_SIZE)> Key::getKeyPairs()
{
	static std::array p =
	{
		std::make_pair(KeyMode::DOWN, "DOWN"),
		std::make_pair(KeyMode::TOGGLE, "TOGGLE")
	};
	return p;
}

```

`hack/config/key.hpp`:

```hpp
#pragma once

#include <vector>
#include <string>
#include <utility>

#include <utilities/tools/wrappers.hpp>

enum class KeyMode : size_t
{
	DOWN,
	TOGGLE,
	KEYMODE_SIZE
};

// cleanup this
class Key
{
public:
	Key() = default;
	constexpr Key(KeyMode mode, int code)
		: m_keyMode{ mode }, m_keyCode{ code }
	{}
	// use only for simple keys for features etc...
	// if class contains an "active" field then this will be a problem
	void update();
	bool isEnabled() const;
	// to hotkey
	bool checkKey();
	bool isPressed() const;
	bool isDown() const;
	bool isToggled() const;
	int getKeyCode() const { return m_keyCode; }
	int& getKeyCode() { return m_keyCode; }
	KeyMode getKeyMode() const { return m_keyMode; }
	KeyMode& getKeyMode() { return m_keyMode; }
	int& getKeyModeInt() { return (int&)(m_keyMode); }
	void setKeyMode(KeyMode mode) { m_keyMode = mode; }
	static std::array<std::pair<KeyMode, const char*>, E2T(KeyMode::KEYMODE_SIZE)> getKeyPairs();
private:
	bool m_toggle = false;
	int m_keyCode;
	KeyMode m_keyMode;
};
```

`hack/config/vars.hpp`:

```hpp
#pragma once

#include "enums.hpp"
#include "cfgWeapon.hpp"
#include "cfgcolor.hpp"
#include "key.hpp"
#include "cfgBeam.hpp"

#include <utilities/tools/wrappers.hpp>
#include <magic_enum.hpp>

#include <memory>
#include <cstdint>
#include <array>

#define USE_NAMESPACE_VARS(cl, name) \
namespace vars { \
	inline std::unique_ptr<cl> name{ new cl }; \
}

struct VarAim
{
	std::array<CfgWeapon, magic_enum::enum_count<WeaponList>()> weapons;
	bool useKey = false;
};
USE_NAMESPACE_VARS(VarAim, aim);

struct VarAimPaint
{
	bool enabledFov = false;
	bool enabledPoint = false;
	CfgColor colorFov = Colors::LightBlue;
	CfgColor colorPoint = Colors::LightBlue;
};
USE_NAMESPACE_VARS(VarAimPaint, aimPaint);

struct VarVisuals
{
	struct VarChams
	{
		bool enabled = false;
		bool players = false;
		int indexPlayers = 0;
		CfgColor colorPlayers = Color{ 255, 0, 255, 255 };
		bool enabledXQZPlayers = false;
		CfgColor colorXQZPlayers = Color{ 0, 100, 255, 255 };
		bool enabledWeapons = false;
		bool weaponHide = false;
		int indexWeapons = 0;
		CfgColor colorWeapons = Color{ 255, 0, 255, 255 };
		bool armsHide = false;
		bool enabledArms = false;
		CfgColor colorArms = Color{ 255, 0, 255, 255 };
		int indexArms = 0;
		int indexBacktrack = 0;
		bool enabledBacktrack = false;
		CfgColor colorBacktrack = Color{ 255, 0, 255, 255 };
		int modeBacktrack = 0;
		bool rainbowBacktrack = false;
		float rainbowBacktrackSpeed = 0.5f;
	};
	std::unique_ptr<VarChams> chams{ new VarChams };

	struct VarGlow
	{
		bool enabled = false;
		CfgColor colorPlayer = Colors::Purple;
	};
	std::unique_ptr<VarGlow> glow{ new VarGlow };

	struct VarEsp
	{
		struct VarBoxes
		{
			bool enabled = false;
			int mode = 0;
			CfgColor color = Colors::Purple;
			CfgColor fill = Color{ 0, 0, 0, 140 };
			bool multiColor = false;
			bool outline = false;
			float multiColorSpeed = 1.0f;
		};
		std::unique_ptr<VarBoxes> boxes{ new VarBoxes };

		struct VarHealthBar
		{
			bool enabled = false;
		};
		std::unique_ptr<VarHealthBar> healthBar{ new VarHealthBar };

		struct VarArmorBar
		{
			bool enabled = false;
		};
		std::unique_ptr<VarArmorBar> armorBar{ new VarArmorBar };

		struct VarWeaponBar
		{
			bool enabled = false;
			bool translate = false;
			CfgColor text = Colors::White;
			CfgColor bar = Colors::Turquoise;
		};
		std::unique_ptr<VarWeaponBar> weaponBar{ new VarWeaponBar };

		struct VarName
		{
			bool enabled = false;
		};
		std::unique_ptr<VarName> nameBar{ new VarName };

		struct VarSkeleton
		{
			bool enabled = false;
			CfgColor color = Colors::White;
			bool showDebug = false;
		};
		std::unique_ptr<VarSkeleton> skeleton{ new VarSkeleton };

		struct VarDlight
		{
			bool enabled = false;
			CfgColor color = Color{ 20, 70, 150, 255 };
			float radius = 50.0f;
			float decay = 30.0f;
			float exponent = 8.0f;
		};
		std::unique_ptr<VarDlight> dlight{ new VarDlight };

		struct VarExtraInfo
		{
			bool enabled = false;
		};
		std::unique_ptr<VarExtraInfo> extraInfo{ new VarExtraInfo };

		struct VarFlags
		{
			std::array<bool, magic_enum::enum_count<EspFlags>()> flags{ false };
			bool enabled = false;
		};
		std::unique_ptr<VarFlags> flags{ new VarFlags };

		struct VarLasers
		{
			bool enabled = false;
		};
		std::unique_ptr<VarLasers> lasers{ new VarLasers };

		struct VarChecks
		{
			bool dead = false;
			bool smoke = false;
			bool visible = false;
			float flashLimit = 120.0f;
		};
		std::unique_ptr<VarChecks> checks{ new VarChecks };

		struct VarDropped
		{
			bool enabled = false;
			CfgColor color = Colors::White;
			std::array<bool, magic_enum::enum_count<DroppedFlags>()> flags{ false };
		};
		std::unique_ptr<VarDropped> dropped{ new VarDropped };
	};
	std::unique_ptr<VarEsp> esp{ new VarEsp };

	struct VarSound
	{
		bool enabled = false;
		CfgColor color = Colors::LightBlue;
		float time = 10.0f;
		float maxDist = 50.0f;
		float maxDistLine = 80.0f;
		CfgColor colorLine = Colors::White;
	};
	std::unique_ptr<VarSound> sound{ new VarSound };

	struct VarDormacy
	{
		float time = 1.0f;
		float limit = 15.0f;
	};
	std::unique_ptr<VarDormacy> dormacy{ new VarDormacy };

	struct VarWorld
	{
		struct VarBomb
		{
			bool enabled = false;
			CfgColor background = Colors::Black;
		};
		std::unique_ptr<VarBomb> bomb{ new VarBomb };

		struct VarProjectiles
		{
			bool enabled = false;
			CfgColor flash = Color{ 130, 0, 200, 255 };
			CfgColor nade = Color{ 130, 180, 20, 255 };
			CfgColor molotov = Color{ 130, 200, 120, 255 };
			CfgColor smoke = Color{ 20, 70, 30, 255 };
			CfgColor decoy = Color{ 0, 30, 60, 255 };
		};
		std::unique_ptr<VarProjectiles> projectiles{ new VarProjectiles };

		struct VarSky
		{
			int indexNormal = 0U;
			int indexCustom = 0U;
			bool removeSky = false;
		};
		std::unique_ptr<VarSky> sky{ new VarSky };

		struct VarModulate
		{
			bool enabled = false;
			CfgColor texture = Colors::White;
			CfgColor prop = Colors::White;
			CfgColor sky = Colors::White;
			float shader = 100.0f;
		};
		std::unique_ptr<VarModulate> modulate{ new VarModulate };

		struct VarMolotov
		{
			bool enabled = false;
			CfgColor color = Colors::Red.getColorEditAlpha(0.3f);
			CfgColor colorText = Colors::White;
		};
		std::unique_ptr<VarMolotov> molotov{ new VarMolotov };

		struct VarSmoke
		{
			bool enabled = false;
			CfgColor color = Colors::White;
		};
		std::unique_ptr<VarSmoke> smoke{ new VarSmoke };

		struct VarZeus
		{
			bool enabled = false;
			bool party = false;
			bool tracing = false;
			CfgColor color = CfgColor{ Colors::Palevioletred, true, 4.0f };
		};
		std::unique_ptr<VarZeus> zeus{ new VarZeus };

		struct VarParticles
		{
			bool enabledBlood = false;
			CfgColor colorBlood = Colors::Purple;
			bool enabledMolotov = false;
			CfgColor colorMolotov = Colors::Purple;
			bool enabledSmoke = false;
			CfgColor colorSmoke = Colors::Purple;
		};
		std::unique_ptr<VarParticles> particles{ new VarParticles };

		struct VarTracer
		{
			bool enabled = false;
			CfgBeam beamTracer = CfgBeam
			{
				0U,
				"4|8",
				2.0f,
				Colors::LightBlue,
				2.0f,
				1.0f,
				2.0f,
				1.0f,
				0.0f,
				60.0f,
				2
			};
		};
		std::unique_ptr<VarTracer> tracer{ new VarTracer };

		struct VarImpacts
		{
			bool enabledClient = false;
			float timeClient = 3.0f;
			CfgColor colorClient = Colors::Cyan;
			CfgColor colorClientFill = Colors::Red;
			bool enabledLocal = false;
			float timeLocal = 3.0f;
			CfgColor colorLocal = Colors::Cyan;
			CfgColor colorLocalFill = Colors::Red;
		};
		std::unique_ptr<VarImpacts> impacts{ new VarImpacts };

		struct VarFog
		{
			bool enabled = false;
			float distance = 500.0f;
			CfgColor color = Colors::Purple;
		};
		std::unique_ptr<VarFog> fog{ new VarFog };

		struct VarScreenEffect
		{
			int index = 0U;
			float param = 1.0f;
			CfgColor color = Colors::LightBlue;
		};
		std::unique_ptr<VarScreenEffect> screenEffect{ new VarScreenEffect };

		struct VarTone
		{
			bool enabled = false;
			float min = 0.5f;
			float max = 0.5f;
			float bloom = 0.0f;
		};
		std::unique_ptr<VarTone> tone{ new VarTone };

		struct VarWeather
		{
			bool enabled = false;
			float length = 0.0f;
			float rainSpeed = 0.0f;
			float radius = 0.0f;
			float width = 0.0f;
			float velocity = 0.0f;
			float alpha = 0.0f;
			float windSpeed = 0.0f;
		};
		std::unique_ptr<VarWeather> weather{ new VarWeather };

		struct VarAmbient
		{
			bool enabled = false;
			CfgColor color = Colors::LightBlue;
		};
		std::unique_ptr<VarAmbient> ambient{ new VarAmbient };
	};
	std::unique_ptr<VarWorld> world{ new VarWorld };
};
USE_NAMESPACE_VARS(VarVisuals, visuals);

struct VarKeys
{
	bool enabledX88Menu = true;
	Key aimbot = Key{ KeyMode::DOWN, VK_LBUTTON };
	Key menu = Key{ KeyMode::TOGGLE, VK_INSERT };
	Key panic = Key{ KeyMode::DOWN, VK_DELETE };
	Key console = Key{ KeyMode::TOGGLE, VK_HOME };
	Key freeLook = Key{ KeyMode::DOWN, VK_MENU };
	Key mirrorCam = Key{ KeyMode::TOGGLE, VK_F1 };
	Key freeCam = Key{ KeyMode::TOGGLE, VK_F2 };
	Key flashLight = Key{ KeyMode::TOGGLE, 0x4C }; // L key
	Key thirdP = Key{ KeyMode::TOGGLE, 0x56 }; // V key
};
USE_NAMESPACE_VARS(VarKeys, keys);

struct VarBacktrack
{
	bool enabled = false;
	float time = 200.0f;
	bool smoke = true;
	float flashLimit = 120.0f;
};
USE_NAMESPACE_VARS(VarBacktrack, backtrack);

struct VarMisc
{
	struct VarLogs
	{
		float time = 4.0f;
		bool enabled = false;
	};
	std::unique_ptr<VarLogs> logs{ new VarLogs };

	struct VarFov
	{
		float value = 0.0f;
	};
	std::unique_ptr<VarFov> fov{ new VarFov };

	struct VarThridP
	{
		bool enabled = false;
		float distance = 200.0f;
		float x = 0.0f;
		float y = 0.0f;
	};
	std::unique_ptr<VarThridP> thirdp{ new VarThridP };

	struct VarCrosshair
	{
		int index = 0;
	};
	std::unique_ptr<VarCrosshair> crosshair{ new VarCrosshair };

	struct VarFakeLatency
	{
		bool enabled = false;
		float amount = 200.0f;
	};
	std::unique_ptr<VarFakeLatency> fakeLatency{ new VarFakeLatency };

	struct VarBunnyHop
	{
		bool enabled = false;
		int chance = 0;
		int indexStrafe = 0;
	};
	std::unique_ptr<VarBunnyHop> bunnyHop{ new VarBunnyHop };

	struct VarHitmarker
	{
		bool enabled = false;
		bool play = false;
		bool enabled3D = false;
		bool enabledResize = false;
		CfgColor colorNormal = Colors::White;
		CfgColor colorHead = Colors::Pink;
		CfgColor colorDead = Colors::Green;
		float time = 0.8f;
	};
	std::unique_ptr<VarHitmarker> hitmarker{ new VarHitmarker };

	struct VarScope
	{
		bool enabled = false;
	};
	std::unique_ptr<VarScope> scope{ new VarScope };

	struct VarPlots
	{
		bool enabledFps = false;
		bool enabledVelocity = false;
		CfgColor colorVelocity = Colors::White;
		CfgColor colorFPS = Colors::White;
		float fpsCap = false;
		bool fpsCustom = false;
		bool velocityCustom = false;
		bool velocityCap = false;
	};
	std::unique_ptr<VarPlots> plots{ new VarPlots };

	struct VarInfo
	{
		bool enabled = false;
	};
	std::unique_ptr<VarInfo> info{ new VarInfo };

	struct VarPlayerList
	{
		bool enabled = false;
		bool health = false;
		bool teamID = false;
		bool money = false;
		bool lastPlace = false;
	};
	std::unique_ptr<VarPlayerList> playerList{ new VarPlayerList };

	struct VarAimWarn
	{
		bool enabled = false;
	};
	std::unique_ptr<VarAimWarn> aimWarn{ new VarAimWarn };

	struct VarRadar
	{
		bool enabled = false;
		CfgColor colorLine = Colors::White;
		CfgColor colorPlayer = Colors::Purple;
		float thickness = 5.0f;
		float length = 20.0f;
		float scale = 1.8f;
		bool ranges = true;
		float size = 200.0f;
	};
	std::unique_ptr<VarRadar> radar{ new VarRadar };

	struct VarTrail
	{
		int mode = 0;
		bool enabled = false;
		CfgColor color = Colors::Coral;
		bool rainbow = false;
		float rainbowSpeed = 3.0f;
		float beamSpeed = 2.0f;
		float time = 4.0f;
	};
	std::unique_ptr<VarTrail> trail{ new VarTrail };

	struct VarNades
	{
		bool enabledPred = false;
		bool predAlways = false;
		CfgColor colorPredLine = Colors::LightBlue;
		CfgColor colorPredBoxFill = Colors::Green;
		CfgColor colorPredBox = Colors::Green;
		bool enabledTracer = false;
		CfgColor colorTracer = Colors::LightBlue;
		float tracerDist = 30.0f;
		bool tracerWarn = false;
	};
	std::unique_ptr<VarNades> nade{ new VarNades };

	struct VarHat
	{
		bool enabled = false;
		bool rainbow = false;
		float rainbowSpeed = 3.0f;
		float size = -30.0f;
		float radius = 20.0f;
		int rainbowAlpha = 70;
		int rainbowLinesAlpha = 180;
		CfgColor colorTriangle = Colors::Palevioletred;
		CfgColor colorLine = Colors::Palevioletred;
	};
	std::unique_ptr<VarHat> hat{ new VarHat };

	struct VarDiscord
	{
		bool enabled = false;
	};
	std::unique_ptr<VarDiscord> discord{ new VarDiscord };

	struct VarMotionBlur
	{
		bool enabled = false;
		bool forward = false;
		float fallingIntensity = 1.0f;
		float fallingMin = 10.0f;
		float fallingMax = 20.0f;
		float strength = 1.0f;
		float rotationIntensity = 0.15f;
		float rollIntensity = 0.3f;
	};
	std::unique_ptr<VarMotionBlur> motionBlur{ new VarMotionBlur };

	struct VarFreeLook
	{
		bool enabled = false;
	};
	std::unique_ptr<VarFreeLook> freeLook{ new VarFreeLook };

	struct VarMirrorCam
	{
		bool enabled = false;
		bool onKey = false;
	};
	std::unique_ptr<VarMirrorCam> mirrorCam{ new VarMirrorCam };

	struct VarFreeCam
	{
		bool enabled = false;
		float speed = 1.0f;
	};
	std::unique_ptr<VarFreeCam> freeCam{ new VarFreeCam };

	struct VarFlashlight
	{
		bool enabled = false;
		bool bigMode = false;
		float fov = 30.0f;
	};
	std::unique_ptr<VarFlashlight> flashLight{ new VarFlashlight };

	struct DisableItems
	{
		bool interpolate = false;
	};
	std::unique_ptr<DisableItems> disableItems{ new DisableItems };
};
USE_NAMESPACE_VARS(VarMisc, misc);

struct ImGuiStyle;

#include <utilities/utilities.hpp>
#include <imgui.h>

struct VarStyling
{
	int index = 0;
	bool background = false;
	float speed = 2.0f;
	float distance = 200.0f;
	int size = 150;
	CfgColor color1 = Color{ 220, 10, 100, 255 };
	CfgColor color2 = Color{ 65, 75, 105, 255 };
	CfgColor color3 = Color{ 220, 240, 240, 255 };
	ImGuiStyle imStyle;
	std::array<CfgColor, 4> groupPanelBackground = utilities::getFilledArray<CfgColor, 4>(Color{ 0, 140, 250, 0 });
	CfgColor groupPanelLines = Colors::White;
	float smoothAlpha = 0.1f;
	float smoothOutline = 0.1f;
	float smoothPop = 0.0f;
	float speedMove = 10.0f;
};
USE_NAMESPACE_VARS(VarStyling, styling);

#undef USE_NAMESPACE_VARS
```

`hack/deps/ImGui/TextEditor.cpp`:

```cpp
#include <algorithm>
#include <chrono>
#include <string>
#include <regex>
#include <cmath>

#include <deps/ImGui/TextEditor.hpp>

#define IMGUI_DEFINE_MATH_OPERATORS
#include "imgui.h" // for imGui::GetCurrentWindow()

#pragma warning(disable: 4018)

// TODO
// - multiline comments vs single-line: latter is blocking start of a ML

template<class InputIt1, class InputIt2, class BinaryPredicate>
bool equals(InputIt1 first1, InputIt1 last1,
	InputIt2 first2, InputIt2 last2, BinaryPredicate p)
{
	for (; first1 != last1 && first2 != last2; ++first1, ++first2)
	{
		if (!p(*first1, *first2))
			return false;
	}
	return first1 == last1 && first2 == last2;
}

TextEditor::TextEditor()
	: mLineSpacing(1.0f)
	, mUndoIndex(0)
	, mTabSize(4)
	, mOverwrite(false)
	, mReadOnly(false)
	, mWithinRender(false)
	, mScrollToCursor(false)
	, mScrollToTop(false)
	, mTextChanged(false)
	, mColorizerEnabled(true)
	, mTextStart(20.0f)
	, mLeftMargin(10)
	, mColorRangeMin(0)
	, mColorRangeMax(0)
	, mSelectionMode(SelectionMode::Normal)
	, mCheckComments(true)
	, mHandleKeyboardInputs(true)
	, mHandleMouseInputs(true)
	, mIgnoreImGuiChild(false)
	, mShowWhitespaces(true)
	, mShowShortTabGlyphs(false)
	, mStartTime(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count())
	, mLastClick(-1.0f)
{
	SetPalette(GetMarianaPalette());
	mLines.push_back(Line());
}

TextEditor::~TextEditor()
{
}

void TextEditor::SetLanguageDefinition(const LanguageDefinition& aLanguageDef)
{
	mLanguageDefinition = &aLanguageDef;
	mRegexList.clear();

	for (const auto& r : mLanguageDefinition->mTokenRegexStrings)
		mRegexList.push_back(std::make_pair(std::regex(r.first, std::regex_constants::optimize), r.second));

	Colorize();
}

const char* TextEditor::GetLanguageDefinitionName() const
{
	return mLanguageDefinition != nullptr ? mLanguageDefinition->mName.c_str() : "unknown";
}

void TextEditor::SetPalette(const Palette& aValue)
{
	mPaletteBase = aValue;
}

std::string TextEditor::GetText(const Coordinates& aStart, const Coordinates& aEnd) const
{
	std::string result;

	auto lstart = aStart.mLine;
	auto lend = aEnd.mLine;
	auto istart = GetCharacterIndex(aStart);
	auto iend = GetCharacterIndex(aEnd);
	size_t s = 0;

	for (size_t i = lstart; i < lend; i++)
		s += mLines[i].size();

	result.reserve(s + s / 8);

	while (istart < iend || lstart < lend)
	{
		if (lstart >= (int)mLines.size())
			break;

		auto& line = mLines[lstart];
		if (istart < (int)line.size())
		{
			result += line[istart].mChar;
			istart++;
		}
		else
		{
			istart = 0;
			++lstart;
			result += '\n';
		}
	}

	return result;
}

TextEditor::Coordinates TextEditor::GetActualCursorCoordinates(int aCursor) const
{
	if (aCursor == -1)
		return SanitizeCoordinates(mState.mCursors[mState.mCurrentCursor].mCursorPosition);
	else
		return SanitizeCoordinates(mState.mCursors[aCursor].mCursorPosition);
}

TextEditor::Coordinates TextEditor::SanitizeCoordinates(const Coordinates& aValue) const
{
	auto line = aValue.mLine;
	auto column = aValue.mColumn;
	if (line >= (int)mLines.size())
	{
		if (mLines.empty())
		{
			line = 0;
			column = 0;
		}
		else
		{
			line = (int)mLines.size() - 1;
			column = GetLineMaxColumn(line);
		}
		return Coordinates(line, column);
	}
	else
	{
		column = mLines.empty() ? 0 : std::min(column, GetLineMaxColumn(line));
		return Coordinates(line, column);
	}
}

// https://en.wikipedia.org/wiki/UTF-8
// We assume that the char is a standalone character (<128) or a leading byte of an UTF-8 code sequence (non-10xxxxxx code)
static int UTF8CharLength(TextEditor::Char c)
{
	if ((c & 0xFE) == 0xFC)
		return 6;
	if ((c & 0xFC) == 0xF8)
		return 5;
	if ((c & 0xF8) == 0xF0)
		return 4;
	else if ((c & 0xF0) == 0xE0)
		return 3;
	else if ((c & 0xE0) == 0xC0)
		return 2;
	return 1;
}

// "Borrowed" from ImGui source
static inline int ImTextCharToUtf8(char* buf, int buf_size, unsigned int c)
{
	if (c < 0x80)
	{
		buf[0] = (char)c;
		return 1;
	}
	if (c < 0x800)
	{
		if (buf_size < 2) return 0;
		buf[0] = (char)(0xc0 + (c >> 6));
		buf[1] = (char)(0x80 + (c & 0x3f));
		return 2;
	}
	if (c >= 0xdc00 && c < 0xe000)
	{
		return 0;
	}
	if (c >= 0xd800 && c < 0xdc00)
	{
		if (buf_size < 4) return 0;
		buf[0] = (char)(0xf0 + (c >> 18));
		buf[1] = (char)(0x80 + ((c >> 12) & 0x3f));
		buf[2] = (char)(0x80 + ((c >> 6) & 0x3f));
		buf[3] = (char)(0x80 + ((c) & 0x3f));
		return 4;
	}
	//else if (c < 0x10000)
	{
		if (buf_size < 3) return 0;
		buf[0] = (char)(0xe0 + (c >> 12));
		buf[1] = (char)(0x80 + ((c >> 6) & 0x3f));
		buf[2] = (char)(0x80 + ((c) & 0x3f));
		return 3;
	}
}

void TextEditor::Advance(Coordinates& aCoordinates) const
{
	if (aCoordinates.mLine >= (int)mLines.size())
		return;

	auto& line = mLines[aCoordinates.mLine];
	auto cindex = GetCharacterIndexLeftSide(aCoordinates);

	if (cindex < (int)line.size())
	{
		auto delta = UTF8CharLength(line[cindex].mChar);
		cindex = std::min(cindex + delta, (int)line.size());
	}
	else if (mLines.size() > aCoordinates.mLine + 1)
	{
		++aCoordinates.mLine;
		cindex = 0;
	}
	aCoordinates.mColumn = GetCharacterColumn(aCoordinates.mLine, cindex);
}

void TextEditor::DeleteRange(const Coordinates& aStart, const Coordinates& aEnd)
{
	assert(aEnd >= aStart);
	assert(!mReadOnly);

	//printf("D(%d.%d)-(%d.%d)\n", aStart.mLine, aStart.mColumn, aEnd.mLine, aEnd.mColumn);

	if (aEnd == aStart)
		return;

	auto start = GetCharacterIndexLeftSide(aStart);
	auto end = GetCharacterIndex(aEnd);

	if (aStart.mLine == aEnd.mLine)
	{
		auto n = GetLineMaxColumn(aStart.mLine);
		if (aEnd.mColumn >= n)
			RemoveGlyphsFromLine(aStart.mLine, start); // from start to end of line
		else
			RemoveGlyphsFromLine(aStart.mLine, start, end);
	}
	else
	{
		RemoveGlyphsFromLine(aStart.mLine, start); // from start to end of line
		RemoveGlyphsFromLine(aEnd.mLine, 0, end);
		auto& firstLine = mLines[aStart.mLine];
		auto& lastLine = mLines[aEnd.mLine];

		if (aStart.mLine < aEnd.mLine)
			AddGlyphsToLine(aStart.mLine, firstLine.size(), lastLine.begin(), lastLine.end());

		if (aStart.mLine < aEnd.mLine)
			RemoveLines(aStart.mLine + 1, aEnd.mLine + 1);
	}

	mTextChanged = true;
}

int TextEditor::InsertTextAt(Coordinates& /* inout */ aWhere, const char* aValue)
{
	assert(!mReadOnly);

	int cindex = GetCharacterIndex(aWhere);
	int totalLines = 0;
	while (*aValue != '\0')
	{
		assert(!mLines.empty());

		if (*aValue == '\r')
		{
			// skip
			++aValue;
		}
		else if (*aValue == '\n')
		{
			if (cindex < (int)mLines[aWhere.mLine].size())
			{
				auto& newLine = InsertLine(aWhere.mLine + 1);
				auto& line = mLines[aWhere.mLine];
				AddGlyphsToLine(aWhere.mLine + 1, 0, line.begin() + cindex, line.end());
				RemoveGlyphsFromLine(aWhere.mLine, cindex);
			}
			else
			{
				InsertLine(aWhere.mLine + 1);
			}
			++aWhere.mLine;
			aWhere.mColumn = 0;
			cindex = 0;
			++totalLines;
			++aValue;
		}
		else
		{
			auto& line = mLines[aWhere.mLine];
			auto d = UTF8CharLength(*aValue);
			while (d-- > 0 && *aValue != '\0')
				AddGlyphToLine(aWhere.mLine, cindex++, Glyph(*aValue++, PaletteIndex::Default));
			aWhere.mColumn = GetCharacterColumn(aWhere.mLine, cindex);
		}

		mTextChanged = true;
	}

	return totalLines;
}

void TextEditor::AddUndo(UndoRecord& aValue)
{
	assert(!mReadOnly);
	//printf("AddUndo: (@%d.%d) +\'%s' [%d.%d .. %d.%d], -\'%s', [%d.%d .. %d.%d] (@%d.%d)\n",
	//	aValue.mBefore.mCursorPosition.mLine, aValue.mBefore.mCursorPosition.mColumn,
	//	aValue.mAdded.c_str(), aValue.mAddedStart.mLine, aValue.mAddedStart.mColumn, aValue.mAddedEnd.mLine, aValue.mAddedEnd.mColumn,
	//	aValue.mRemoved.c_str(), aValue.mRemovedStart.mLine, aValue.mRemovedStart.mColumn, aValue.mRemovedEnd.mLine, aValue.mRemovedEnd.mColumn,
	//	aValue.mAfter.mCursorPosition.mLine, aValue.mAfter.mCursorPosition.mColumn
	//	);

	mUndoBuffer.resize((size_t)(mUndoIndex + 1));
	mUndoBuffer.back() = aValue;
	++mUndoIndex;
}

TextEditor::Coordinates TextEditor::ScreenPosToCoordinates(const ImVec2& aPosition, bool aInsertionMode, bool* isOverLineNumber) const
{
	ImVec2 origin = ImGui::GetCursorScreenPos();
	ImVec2 local(aPosition.x - origin.x + 3.0f, aPosition.y - origin.y);

	if (isOverLineNumber != nullptr)
		*isOverLineNumber = local.x < mTextStart;

	float spaceSize = ImGui::GetFont()->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, " ").x;

	int lineNo = std::max(0, (int)floor(local.y / mCharAdvance.y));

	int columnCoord = 0;

	if (lineNo >= 0 && lineNo < (int)mLines.size())
	{
		auto& line = mLines.at(lineNo);

		int columnIndex = 0;
		std::string cumulatedString = "";
		float columnWidth = 0.0f;
		float columnX = 0.0f;
		int delta = 0;

		// First we find the hovered column coord.
		for (size_t columnIndex = 0; columnIndex < line.size(); ++columnIndex)
		{
			float columnWidth = 0.0f;
			int delta = 0;

			if (line[columnIndex].mChar == '\t')
			{
				float oldX = columnX;
				columnX = (1.0f + std::floor((1.0f + columnX) / (float(mTabSize) * spaceSize))) * (float(mTabSize) * spaceSize);
				columnWidth = columnX - oldX;
				delta = mTabSize - (columnCoord % mTabSize);
			}
			else
			{
				char buf[7];
				auto d = UTF8CharLength(line[columnIndex].mChar);
				int i = 0;
				while (i < 6 && d-- > 0)
					buf[i++] = line[columnIndex].mChar;
				buf[i] = '\0';
				columnWidth = ImGui::GetFont()->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, buf).x;
				columnX += columnWidth;
				delta = 1;
			}

			if (mTextStart + columnX - (aInsertionMode ? 0.5f : 0.0f) * columnWidth < local.x)
				columnCoord += delta;
			else
				break;
		}

		// Then we reduce by 1 column coord if cursor is on the left side of the hovered column.
		//if (aInsertionMode && mTextStart + columnX - columnWidth * 2.0f < local.x)
		//	columnIndex = std::min((int)line.size() - 1, columnIndex + 1);
	}

	return SanitizeCoordinates(Coordinates(lineNo, columnCoord));
}

TextEditor::Coordinates TextEditor::FindWordStart(const Coordinates& aFrom) const
{
	Coordinates at = aFrom;
	if (at.mLine >= (int)mLines.size())
		return at;

	auto& line = mLines[at.mLine];
	auto cindex = GetCharacterIndexLeftSide(at);

	if (cindex >= (int)line.size())
		return at;

	bool initialIsWordChar = IsGlyphWordChar(line[cindex]);
	bool initialIsSpace = isspace(line[cindex].mChar);
	uint8_t initialChar = line[cindex].mChar;
	bool needToAdvance = false;
	while (true)
	{
		--cindex;
		if (cindex < 0)
		{
			cindex = 0;
			break;
		}

		auto c = line[cindex].mChar;
		if ((c & 0xC0) != 0x80)	// not UTF code sequence 10xxxxxx
		{
			bool isWordChar = IsGlyphWordChar(line[cindex]);
			bool isSpace = isspace(line[cindex].mChar);
			if (initialIsSpace && !isSpace || initialIsWordChar && !isWordChar || !initialIsWordChar && !initialIsSpace && initialChar != line[cindex].mChar)
			{
				needToAdvance = true;
				break;
			}
		}
	}
	at.mColumn = GetCharacterColumn(at.mLine, cindex);
	if (needToAdvance)
		Advance(at);
	return at;
}

TextEditor::Coordinates TextEditor::FindWordEnd(const Coordinates& aFrom) const
{
	Coordinates at = aFrom;
	if (at.mLine >= (int)mLines.size())
		return at;

	auto& line = mLines[at.mLine];
	auto cindex = GetCharacterIndexLeftSide(at);

	if (cindex >= (int)line.size())
		return at;

	bool initialIsWordChar = IsGlyphWordChar(line[cindex]);
	bool initialIsSpace = isspace(line[cindex].mChar);
	uint8_t initialChar = line[cindex].mChar;
	while (true)
	{
		auto d = UTF8CharLength(line[cindex].mChar);
		cindex += d;
		if (cindex >= (int)line.size())
			break;

		bool isWordChar = IsGlyphWordChar(line[cindex]);
		bool isSpace = isspace(line[cindex].mChar);
		if (initialIsSpace && !isSpace || initialIsWordChar && !isWordChar || !initialIsWordChar && !initialIsSpace && initialChar != line[cindex].mChar)
			break;
	}
	at.mColumn = GetCharacterColumn(at.mLine, cindex);
	return at;
}

TextEditor::Coordinates TextEditor::FindNextWord(const Coordinates& aFrom) const
{
	Coordinates at = aFrom;
	if (at.mLine >= (int)mLines.size())
		return at;

	// skip to the next non-word character
	auto cindex = GetCharacterIndex(aFrom);
	bool isword = false;
	bool skip = false;
	if (cindex < (int)mLines[at.mLine].size())
	{
		auto& line = mLines[at.mLine];
		isword = !!isalnum(line[cindex].mChar);
		skip = isword;
	}

	while (!isword || skip)
	{
		if (at.mLine >= mLines.size())
		{
			auto l = std::max(0, (int)mLines.size() - 1);
			return Coordinates(l, GetLineMaxColumn(l));
		}

		auto& line = mLines[at.mLine];
		if (cindex < (int)line.size())
		{
			isword = isalnum(line[cindex].mChar);

			if (isword && !skip)
				return Coordinates(at.mLine, GetCharacterColumn(at.mLine, cindex));

			if (!isword)
				skip = false;

			cindex++;
		}
		else
		{
			cindex = 0;
			++at.mLine;
			skip = false;
			isword = false;
		}
	}

	return at;
}

int TextEditor::GetCharacterIndexLeftSide(const Coordinates& aCoordinates) const
{
	if (aCoordinates.mLine >= mLines.size())
		return -1;

	auto& line = mLines[aCoordinates.mLine];
	int c = 0;
	int i = 0;
	int tabCoordsLeft = 0;

	for (; i < line.size() && c < aCoordinates.mColumn;)
	{
		if (line[i].mChar == '\t')
		{
			if (tabCoordsLeft == 0)
				tabCoordsLeft = mTabSize - (c % mTabSize);
			if (tabCoordsLeft > 0)
				tabCoordsLeft--;
			c++;
		}
		else
			++c;
		if (tabCoordsLeft == 0)
			i += UTF8CharLength(line[i].mChar);
	}
	return i;
}

int TextEditor::GetCharacterIndex(const Coordinates& aCoordinates) const
{
	if (aCoordinates.mLine >= mLines.size())
		return -1;
	auto& line = mLines[aCoordinates.mLine];
	int c = 0;
	int i = 0;
	for (; i < line.size() && c < aCoordinates.mColumn;)
	{
		if (line[i].mChar == '\t')
			c = (c / mTabSize) * mTabSize + mTabSize;
		else
			++c;
		i += UTF8CharLength(line[i].mChar);
	}
	return i;
}

int TextEditor::GetCharacterColumn(int aLine, int aIndex) const
{
	if (aLine >= mLines.size())
		return 0;
	auto& line = mLines[aLine];
	int col = 0;
	int i = 0;
	while (i < aIndex && i < (int)line.size())
	{
		auto c = line[i].mChar;
		i += UTF8CharLength(c);
		if (c == '\t')
			col = (col / mTabSize) * mTabSize + mTabSize;
		else
			col++;
	}
	return col;
}

int TextEditor::GetLineCharacterCount(int aLine) const
{
	if (aLine >= mLines.size())
		return 0;
	auto& line = mLines[aLine];
	int c = 0;
	for (unsigned i = 0; i < line.size(); c++)
		i += UTF8CharLength(line[i].mChar);
	return c;
}

int TextEditor::GetLineMaxColumn(int aLine) const
{
	if (aLine >= mLines.size())
		return 0;
	auto& line = mLines[aLine];
	int col = 0;
	for (unsigned i = 0; i < line.size(); )
	{
		auto c = line[i].mChar;
		if (c == '\t')
			col = (col / mTabSize) * mTabSize + mTabSize;
		else
			col++;
		i += UTF8CharLength(c);
	}
	return col;
}

bool TextEditor::IsOnWordBoundary(const Coordinates& aAt) const
{
	if (aAt.mLine >= (int)mLines.size() || aAt.mColumn == 0)
		return true;

	auto& line = mLines[aAt.mLine];
	auto cindex = GetCharacterIndex(aAt);
	if (cindex >= (int)line.size())
		return true;

	if (mColorizerEnabled)
		return line[cindex].mColorIndex != line[size_t(cindex - 1)].mColorIndex;

	return isspace(line[cindex].mChar) != isspace(line[cindex - 1].mChar);
}

void TextEditor::RemoveLines(int aStart, int aEnd)
{
	assert(!mReadOnly);
	assert(aEnd >= aStart);
	assert(mLines.size() > (size_t)(aEnd - aStart));

	ErrorMarkers etmp;
	for (auto& i : mErrorMarkers)
	{
		ErrorMarkers::value_type e(i.first >= aStart ? i.first - 1 : i.first, i.second);
		if (e.first >= aStart && e.first <= aEnd)
			continue;
		etmp.insert(e);
	}
	mErrorMarkers = std::move(etmp);

	Breakpoints btmp;
	for (auto i : mBreakpoints)
	{
		if (i >= aStart && i <= aEnd)
			continue;
		btmp.insert(i >= aStart ? i - 1 : i);
	}
	mBreakpoints = std::move(btmp);

	mLines.erase(mLines.begin() + aStart, mLines.begin() + aEnd);
	assert(!mLines.empty());

	mTextChanged = true;

	OnLinesDeleted(aStart, aEnd);
}

void TextEditor::RemoveLine(int aIndex, const std::unordered_set<int>* aHandledCursors)
{
	assert(!mReadOnly);
	assert(mLines.size() > 1);

	ErrorMarkers etmp;
	for (auto& i : mErrorMarkers)
	{
		ErrorMarkers::value_type e(i.first > aIndex ? i.first - 1 : i.first, i.second);
		if (e.first - 1 == aIndex)
			continue;
		etmp.insert(e);
	}
	mErrorMarkers = std::move(etmp);

	Breakpoints btmp;
	for (auto i : mBreakpoints)
	{
		if (i == aIndex)
			continue;
		btmp.insert(i >= aIndex ? i - 1 : i);
	}
	mBreakpoints = std::move(btmp);

	mLines.erase(mLines.begin() + aIndex);
	assert(!mLines.empty());

	mTextChanged = true;

	OnLineDeleted(aIndex, aHandledCursors);
}

void TextEditor::RemoveCurrentLines()
{
	UndoRecord u;
	u.mBefore = mState;

	if (HasSelection())
	{
		for (int c = mState.mCurrentCursor; c > -1; c--)
		{
			u.mOperations.push_back({ GetSelectedText(c), mState.mCursors[c].mSelectionStart, mState.mCursors[c].mSelectionEnd, UndoOperationType::Delete });
			DeleteSelection(c);
		}
	}

	for (int c = mState.mCurrentCursor; c > -1; c--)
	{
		int currentLine = mState.mCursors[c].mCursorPosition.mLine;
		int nextLine = currentLine + 1;
		int prevLine = currentLine - 1;

		Coordinates toDeleteStart, toDeleteEnd;
		if (mLines.size() > nextLine) // next line exists
		{
			toDeleteStart = Coordinates(currentLine, 0);
			toDeleteEnd = Coordinates(nextLine, 0);
			SetCursorPosition({ mState.mCursors[c].mCursorPosition.mLine, 0 }, c);
		}
		else if (prevLine > -1) // previous line exists
		{
			toDeleteStart = Coordinates(prevLine, GetLineMaxColumn(prevLine));
			toDeleteEnd = Coordinates(currentLine, GetLineMaxColumn(currentLine));
			SetCursorPosition({ prevLine, 0 }, c);
		}
		else
		{
			toDeleteStart = Coordinates(currentLine, 0);
			toDeleteEnd = Coordinates(currentLine, GetLineMaxColumn(currentLine));
			SetCursorPosition({ currentLine, 0 }, c);
		}

		u.mOperations.push_back({ GetText(toDeleteStart, toDeleteEnd), toDeleteStart, toDeleteEnd, UndoOperationType::Delete });

		std::unordered_set<int> handledCursors = { c };
		if (toDeleteStart.mLine != toDeleteEnd.mLine)
			RemoveLine(currentLine, &handledCursors);
		else
			DeleteRange(toDeleteStart, toDeleteEnd);
	}

	u.mAfter = mState;
	AddUndo(u);
}

void TextEditor::OnLineChanged(bool aBeforeChange, int aLine, int aColumn, int aCharCount, bool aDeleted)
{
	static std::unordered_map<int, int> cursorCharIndices;
	if (aBeforeChange)
	{
		cursorCharIndices.clear();
		for (int c = 0; c <= mState.mCurrentCursor; c++)
		{
			if (mState.mCursors[c].mCursorPosition.mLine == aLine)
			{
				if (mState.mCursors[c].mCursorPosition.mColumn > aColumn)
				{
					cursorCharIndices[c] = GetCharacterIndex({ aLine, mState.mCursors[c].mCursorPosition.mColumn });
					cursorCharIndices[c] += aDeleted ? -aCharCount : aCharCount;
				}
			}
		}
	}
	else
	{
		for (auto& item : cursorCharIndices)
			SetCursorPosition({ aLine, GetCharacterColumn(aLine, item.second) }, item.first);
	}
}

void TextEditor::RemoveGlyphsFromLine(int aLine, int aStartChar, int aEndChar)
{
	int column = GetCharacterColumn(aLine, aStartChar);
	int deltaX = GetCharacterColumn(aLine, aEndChar) - column;
	auto& line = mLines[aLine];
	OnLineChanged(true, aLine, column, aEndChar - aStartChar, true);
	line.erase(line.begin() + aStartChar, aEndChar == -1 ? line.end() : line.begin() + aEndChar);
	OnLineChanged(false, aLine, column, aEndChar - aStartChar, true);
}

void TextEditor::AddGlyphsToLine(int aLine, int aTargetIndex, Line::iterator aSourceStart, Line::iterator aSourceEnd)
{
	int targetColumn = GetCharacterColumn(aLine, aTargetIndex);
	int charsInserted = std::distance(aSourceStart, aSourceEnd);
	auto& line = mLines[aLine];
	OnLineChanged(true, aLine, targetColumn, charsInserted, false);
	line.insert(line.begin() + aTargetIndex, aSourceStart, aSourceEnd);
	OnLineChanged(false, aLine, targetColumn, charsInserted, false);
}

void TextEditor::AddGlyphToLine(int aLine, int aTargetIndex, Glyph aGlyph)
{
	int targetColumn = GetCharacterColumn(aLine, aTargetIndex);
	auto& line = mLines[aLine];
	OnLineChanged(true, aLine, targetColumn, 1, false);
	line.insert(line.begin() + aTargetIndex, aGlyph);
	OnLineChanged(false, aLine, targetColumn, 1, false);
}

TextEditor::Line& TextEditor::InsertLine(int aIndex)
{
	assert(!mReadOnly);

	auto& result = *mLines.insert(mLines.begin() + aIndex, Line());

	ErrorMarkers etmp;
	for (auto& i : mErrorMarkers)
		etmp.insert(ErrorMarkers::value_type(i.first >= aIndex ? i.first + 1 : i.first, i.second));
	mErrorMarkers = std::move(etmp);

	Breakpoints btmp;
	for (auto i : mBreakpoints)
		btmp.insert(i >= aIndex ? i + 1 : i);
	mBreakpoints = std::move(btmp);

	OnLineAdded(aIndex);

	return result;
}

std::string TextEditor::GetWordUnderCursor() const
{
	auto c = GetCursorPosition();
	return GetWordAt(c);
}

std::string TextEditor::GetWordAt(const Coordinates& aCoords) const
{
	auto start = FindWordStart(aCoords);
	auto end = FindWordEnd(aCoords);

	std::string r;

	auto istart = GetCharacterIndex(start);
	auto iend = GetCharacterIndex(end);

	for (auto it = istart; it < iend; ++it)
		r.push_back(mLines[aCoords.mLine][it].mChar);

	return r;
}

ImU32 TextEditor::GetGlyphColor(const Glyph& aGlyph) const
{
	if (!mColorizerEnabled)
		return mPalette[(int)PaletteIndex::Default];
	if (aGlyph.mComment)
		return mPalette[(int)PaletteIndex::Comment];
	if (aGlyph.mMultiLineComment)
		return mPalette[(int)PaletteIndex::MultiLineComment];
	auto const color = mPalette[(int)aGlyph.mColorIndex];
	if (aGlyph.mPreprocessor)
	{
		const auto ppcolor = mPalette[(int)PaletteIndex::Preprocessor];
		const int c0 = ((ppcolor & 0xff) + (color & 0xff)) / 2;
		const int c1 = (((ppcolor >> 8) & 0xff) + ((color >> 8) & 0xff)) / 2;
		const int c2 = (((ppcolor >> 16) & 0xff) + ((color >> 16) & 0xff)) / 2;
		const int c3 = (((ppcolor >> 24) & 0xff) + ((color >> 24) & 0xff)) / 2;
		return ImU32(c0 | (c1 << 8) | (c2 << 16) | (c3 << 24));
	}
	return color;
}

bool TextEditor::IsGlyphWordChar(const Glyph& aGlyph)
{
	int sizeInBytes = UTF8CharLength(aGlyph.mChar);
	return sizeInBytes > 1 ||
		aGlyph.mChar >= 'a' && aGlyph.mChar <= 'z' ||
		aGlyph.mChar >= 'A' && aGlyph.mChar <= 'Z' ||
		aGlyph.mChar >= '0' && aGlyph.mChar <= '9' ||
		aGlyph.mChar == '_';
}

void TextEditor::HandleKeyboardInputs(bool aParentIsFocused)
{
	if (ImGui::IsWindowFocused() || aParentIsFocused)
	{
		if (ImGui::IsWindowHovered())
			ImGui::SetMouseCursor(ImGuiMouseCursor_TextInput);
		//ImGui::CaptureKeyboardFromApp(true);

		ImGuiIO& io = ImGui::GetIO();
		auto isOSX = io.ConfigMacOSXBehaviors;
		auto alt = io.KeyAlt;
		auto ctrl = io.KeyCtrl;
		auto shift = io.KeyShift;
		auto super = io.KeySuper;

		auto isShortcut = (isOSX ? (super && !ctrl) : (ctrl && !super)) && !alt && !shift;
		auto isShiftShortcut = (isOSX ? (super && !ctrl) : (ctrl && !super)) && shift && !alt;
		auto isWordmoveKey = isOSX ? alt : ctrl;
		auto isAltOnly = alt && !ctrl && !shift && !super;
		auto isCtrlOnly = ctrl && !alt && !shift && !super;
		auto isShiftOnly = shift && !alt && !ctrl && !super;

		io.WantCaptureKeyboard = true;
		io.WantTextInput = true;

		if (!IsReadOnly() && isShortcut && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Z)))
			Undo();
		else if (!IsReadOnly() && isAltOnly && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Backspace)))
			Undo();
		else if (!IsReadOnly() && isShortcut && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Y)))
			Redo();
		else if (!IsReadOnly() && isShiftShortcut && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Z)))
			Redo();
		else if (!alt && !ctrl && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_UpArrow)))
			MoveUp(1, shift);
		else if (!alt && !ctrl && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_DownArrow)))
			MoveDown(1, shift);
		else if ((isOSX ? !ctrl : !alt) && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_LeftArrow)))
			MoveLeft(1, shift, isWordmoveKey);
		else if ((isOSX ? !ctrl : !alt) && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_RightArrow)))
			MoveRight(1, shift, isWordmoveKey);
		else if (!alt && !ctrl && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_PageUp)))
			MoveUp(GetPageSize() - 4, shift);
		else if (!alt && !ctrl && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_PageDown)))
			MoveDown(GetPageSize() - 4, shift);
		else if (ctrl && !alt && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Home)))
			MoveTop(shift);
		else if (ctrl && !alt && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_End)))
			MoveBottom(shift);
		else if (!alt && !ctrl && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Home)))
			MoveHome(shift);
		else if (!alt && !ctrl && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_End)))
			MoveEnd(shift);
		else if (!IsReadOnly() && !alt && !shift && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Delete)))
			Delete(ctrl);
		else if (!IsReadOnly() && !alt && !shift && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Backspace)))
			Backspace(ctrl);
		else if (!IsReadOnly() && !alt && ctrl && shift && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_K)))
			RemoveCurrentLines();
		else if (!IsReadOnly() && !alt && ctrl && !shift && !super && ImGui::IsKeyPressed(static_cast<ImGuiKey>('[')))
			ChangeCurrentLinesIndentation(false);
		else if (!IsReadOnly() && !alt && ctrl && !shift && !super && ImGui::IsKeyPressed(static_cast<ImGuiKey>('[')))
			ChangeCurrentLinesIndentation(true);
		else if (!alt && !ctrl && !shift && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Insert)))
			mOverwrite ^= true;
		else if (isCtrlOnly && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Insert)))
			Copy();
		else if (isShortcut && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_C)))
			Copy();
		else if (!IsReadOnly() && isShiftOnly && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Insert)))
			Paste();
		else if (!IsReadOnly() && isShortcut && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_V)))
			Paste();
		else if (isShortcut && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_X)))
			Cut();
		else if (isShiftOnly && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Delete)))
			Cut();
		else if (isShortcut && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_A)))
			SelectAll();
		else if (!IsReadOnly() && !alt && !ctrl && !shift && !super && (ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Enter)) || ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_KeyPadEnter))))
			EnterCharacter('\n', false);
		else if (!IsReadOnly() && !alt && !ctrl && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Tab)))
			EnterCharacter('\t', shift);
		if (!IsReadOnly() && !io.InputQueueCharacters.empty() && !ctrl && !super)
		{
			for (int i = 0; i < io.InputQueueCharacters.Size; i++)
			{
				auto c = io.InputQueueCharacters[i];
				if (c != 0 && (c == '\n' || c >= 32))
					EnterCharacter(c, shift);
			}
			io.InputQueueCharacters.resize(0);
		}
	}
}

void TextEditor::HandleMouseInputs()
{
	ImGuiIO& io = ImGui::GetIO();
	auto shift = io.KeyShift;
	auto ctrl = io.ConfigMacOSXBehaviors ? io.KeySuper : io.KeyCtrl;
	auto alt = io.ConfigMacOSXBehaviors ? io.KeyCtrl : io.KeyAlt;

	if (ImGui::IsWindowHovered())
	{
		auto click = ImGui::IsMouseClicked(0);
		if (!shift && !alt)
		{
			auto doubleClick = ImGui::IsMouseDoubleClicked(0);
			auto t = ImGui::GetTime();
			auto tripleClick = click && !doubleClick && (mLastClick != -1.0f && (t - mLastClick) < io.MouseDoubleClickTime);

			/*
			Left mouse button triple click
			*/

			if (tripleClick)
			{
				if (ctrl)
					mState.AddCursor();
				else
					mState.mCurrentCursor = 0;

				mState.mCursors[mState.mCurrentCursor].mCursorPosition = mState.mCursors[mState.mCurrentCursor].mInteractiveStart = mState.mCursors[mState.mCurrentCursor].mInteractiveEnd = ScreenPosToCoordinates(ImGui::GetMousePos());
				mSelectionMode = SelectionMode::Line;
				SetSelection(mState.mCursors[mState.mCurrentCursor].mInteractiveStart, mState.mCursors[mState.mCurrentCursor].mInteractiveEnd, mSelectionMode);

				mLastClick = -1.0f;
			}

			/*
			Left mouse button double click
			*/

			else if (doubleClick)
			{
				if (ctrl)
					mState.AddCursor();
				else
					mState.mCurrentCursor = 0;

				mState.mCursors[mState.mCurrentCursor].mCursorPosition = mState.mCursors[mState.mCurrentCursor].mInteractiveStart = mState.mCursors[mState.mCurrentCursor].mInteractiveEnd = ScreenPosToCoordinates(ImGui::GetMousePos());
				mState.mCursors[mState.mCurrentCursor].mInteractiveStart = FindWordStart(mState.mCursors[mState.mCurrentCursor].mCursorPosition);
				mState.mCursors[mState.mCurrentCursor].mCursorPosition = mState.mCursors[mState.mCurrentCursor].mInteractiveEnd = FindWordEnd(mState.mCursors[mState.mCurrentCursor].mCursorPosition);
				if (mSelectionMode == SelectionMode::Line)
					mSelectionMode = SelectionMode::Normal;
				else
					mSelectionMode = SelectionMode::Word;
				SetSelection(mState.mCursors[mState.mCurrentCursor].mInteractiveStart, mState.mCursors[mState.mCurrentCursor].mInteractiveEnd, mSelectionMode);

				mLastClick = (float)ImGui::GetTime();
			}

			/*
			Left mouse button click
			*/
			else if (click)
			{
				if (ctrl)
					mState.AddCursor();
				else
					mState.mCurrentCursor = 0;

				bool isOverLineNumber;
				mState.mCursors[mState.mCurrentCursor].mCursorPosition = mState.mCursors[mState.mCurrentCursor].mInteractiveStart = mState.mCursors[mState.mCurrentCursor].mInteractiveEnd = ScreenPosToCoordinates(ImGui::GetMousePos(), !mOverwrite, &isOverLineNumber);
				if (isOverLineNumber)
					mSelectionMode = SelectionMode::Line;
				else if (ctrl)
					mSelectionMode = SelectionMode::Word;
				else
					mSelectionMode = SelectionMode::Normal;
				SetSelection(mState.mCursors[mState.mCurrentCursor].mInteractiveStart, mState.mCursors[mState.mCurrentCursor].mInteractiveEnd, mSelectionMode, -1, ctrl);

				mLastClick = (float)ImGui::GetTime();
			}
			// Mouse left button dragging (=> update selection)
			else if (ImGui::IsMouseDragging(0) && ImGui::IsMouseDown(0))
			{
				mDraggingSelection = true;
				io.WantCaptureMouse = true;
				mState.mCursors[mState.mCurrentCursor].mCursorPosition = mState.mCursors[mState.mCurrentCursor].mInteractiveEnd = ScreenPosToCoordinates(ImGui::GetMousePos(), !mOverwrite);
				SetSelection(mState.mCursors[mState.mCurrentCursor].mInteractiveStart, mState.mCursors[mState.mCurrentCursor].mInteractiveEnd, mSelectionMode);
			}
			else if (ImGui::IsMouseReleased(0))
			{
				mDraggingSelection = false;

				// sort from cursors from top to bottom
				std::sort(mState.mCursors.begin(), mState.mCursors.begin() + (mState.mCurrentCursor + 1), [](const Cursor& a, const Cursor& b) -> bool
					{
						return a.mSelectionStart < b.mSelectionStart;
					});
				MergeCursorsIfPossible();
			}
		}
		else if (shift)
		{
			if (click)
			{
				Coordinates oldCursorPosition = mState.mCursors[mState.mCurrentCursor].mCursorPosition;
				Coordinates newSelection = ScreenPosToCoordinates(ImGui::GetMousePos(), !mOverwrite);
				if (newSelection > mState.mCursors[mState.mCurrentCursor].mCursorPosition)
					SetSelectionEnd(newSelection);
				else
					SetSelectionStart(newSelection);
				mState.mCursors[mState.mCurrentCursor].mInteractiveEnd = mState.mCursors[mState.mCurrentCursor].mSelectionEnd;
				mState.mCursors[mState.mCurrentCursor].mInteractiveStart = mState.mCursors[mState.mCurrentCursor].mSelectionStart;
				mState.mCursors[mState.mCurrentCursor].mCursorPosition = newSelection;
				mState.mCursors[mState.mCurrentCursor].mCursorPositionChanged = oldCursorPosition != newSelection;
			}
		}
	}
}

void TextEditor::UpdatePalette()
{
	/* Update palette with the current alpha from style */
	for (int i = 0; i < (int)PaletteIndex::Max; ++i)
	{
		auto color = U32ColorToVec4(mPaletteBase[i]);
		color.w *= ImGui::GetStyle().Alpha;
		mPalette[i] = ImGui::ColorConvertFloat4ToU32(color);
	}
}

void TextEditor::Render(bool aParentIsFocused)
{
	/* Compute mCharAdvance regarding to scaled font size (Ctrl + mouse wheel)*/
	const float fontSize = ImGui::GetFont()->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, "#", nullptr, nullptr).x;
	mCharAdvance = ImVec2(fontSize, ImGui::GetTextLineHeightWithSpacing() * mLineSpacing);

	assert(mLineBuffer.empty());

	auto contentSize = ImGui::GetWindowContentRegionMax();
	auto drawList = ImGui::GetWindowDrawList();
	float longest(mTextStart);

	if (mScrollToTop)
	{
		mScrollToTop = false;
		ImGui::SetScrollY(0.f);
	}

	ImVec2 cursorScreenPos = ImGui::GetCursorScreenPos();
	auto scrollX = ImGui::GetScrollX();
	auto scrollY = ImGui::GetScrollY();

	auto lineNo = (int)floor(scrollY / mCharAdvance.y);
	auto globalLineMax = (int)mLines.size();
	auto lineMax = std::max(0, std::min((int)mLines.size() - 1, lineNo + (int)floor((scrollY + contentSize.y) / mCharAdvance.y)));

	// Deduce mTextStart by evaluating mLines size (global lineMax) plus two spaces as text width
	char buf[16];
	snprintf(buf, 16, " %d ", globalLineMax);
	mTextStart = ImGui::GetFont()->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, buf, nullptr, nullptr).x + mLeftMargin;

	if (!mLines.empty())
	{
		float spaceSize = ImGui::GetFont()->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, " ", nullptr, nullptr).x;

		while (lineNo <= lineMax)
		{
			ImVec2 lineStartScreenPos = ImVec2(cursorScreenPos.x, cursorScreenPos.y + lineNo * mCharAdvance.y);
			ImVec2 textScreenPos = ImVec2(lineStartScreenPos.x + mTextStart, lineStartScreenPos.y);

			auto& line = mLines[lineNo];
			longest = std::max(mTextStart + TextDistanceToLineStart(Coordinates(lineNo, GetLineMaxColumn(lineNo))), longest);
			auto columnNo = 0;
			Coordinates lineStartCoord(lineNo, 0);
			Coordinates lineEndCoord(lineNo, GetLineMaxColumn(lineNo));

			// Draw selection for the current line
			for (int c = 0; c <= mState.mCurrentCursor; c++)
			{
				float sstart = -1.0f;
				float ssend = -1.0f;

				assert(mState.mCursors[c].mSelectionStart <= mState.mCursors[c].mSelectionEnd);
				if (mState.mCursors[c].mSelectionStart <= lineEndCoord)
					sstart = mState.mCursors[c].mSelectionStart > lineStartCoord ? TextDistanceToLineStart(mState.mCursors[c].mSelectionStart) : 0.0f;
				if (mState.mCursors[c].mSelectionEnd > lineStartCoord)
					ssend = TextDistanceToLineStart(mState.mCursors[c].mSelectionEnd < lineEndCoord ? mState.mCursors[c].mSelectionEnd : lineEndCoord);

				if (mState.mCursors[c].mSelectionEnd.mLine > lineNo)
					ssend += mCharAdvance.x;

				if (sstart != -1 && ssend != -1 && sstart < ssend)
				{
					ImVec2 vstart(lineStartScreenPos.x + mTextStart + sstart, lineStartScreenPos.y);
					ImVec2 vend(lineStartScreenPos.x + mTextStart + ssend, lineStartScreenPos.y + mCharAdvance.y);
					drawList->AddRectFilled(vstart, vend, mPalette[(int)PaletteIndex::Selection]);
				}
			}

			// Draw breakpoints
			auto start = ImVec2(lineStartScreenPos.x + scrollX, lineStartScreenPos.y);

			if (mBreakpoints.count(lineNo + 1) != 0)
			{
				auto end = ImVec2(lineStartScreenPos.x + contentSize.x + 2.0f * scrollX, lineStartScreenPos.y + mCharAdvance.y);
				drawList->AddRectFilled(start, end, mPalette[(int)PaletteIndex::Breakpoint]);
			}

			// Draw error markers
			auto errorIt = mErrorMarkers.find(lineNo + 1);
			if (errorIt != mErrorMarkers.end())
			{
				auto end = ImVec2(lineStartScreenPos.x + contentSize.x + 2.0f * scrollX, lineStartScreenPos.y + mCharAdvance.y);
				drawList->AddRectFilled(start, end, mPalette[(int)PaletteIndex::ErrorMarker]);

				if (ImGui::IsMouseHoveringRect(lineStartScreenPos, end))
				{
					ImGui::BeginTooltip();
					ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 0.2f, 0.2f, 1.0f));
					ImGui::Text("Error at line %d:", errorIt->first);
					ImGui::PopStyleColor();
					ImGui::Separator();
					ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 1.0f, 0.2f, 1.0f));
					ImGui::Text("%s", errorIt->second.c_str());
					ImGui::PopStyleColor();
					ImGui::EndTooltip();
				}
			}

			// Draw line number (right aligned)
			snprintf(buf, 16, "%d  ", lineNo + 1);

			auto lineNoWidth = ImGui::GetFont()->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, buf, nullptr, nullptr).x;
			drawList->AddText(ImVec2(lineStartScreenPos.x + mTextStart - lineNoWidth, lineStartScreenPos.y), mPalette[(int)PaletteIndex::LineNumber], buf);

			std::vector<Coordinates> cursorCoordsInThisLine;
			for (int c = 0; c <= mState.mCurrentCursor; c++)
			{
				if (mState.mCursors[c].mCursorPosition.mLine == lineNo)
					cursorCoordsInThisLine.push_back(mState.mCursors[c].mCursorPosition);
			}
			if (cursorCoordsInThisLine.size() > 0)
			{
				auto focused = ImGui::IsWindowFocused() || aParentIsFocused;

				// Render the cursors
				if (focused)
				{
					for (const auto& cursorCoords : cursorCoordsInThisLine)
					{
						float width = 1.0f;
						auto cindex = GetCharacterIndex(cursorCoords);
						float cx = TextDistanceToLineStart(cursorCoords);

						if (mOverwrite && cindex < (int)line.size())
						{
							auto c = line[cindex].mChar;
							if (c == '\t')
							{
								auto x = (1.0f + std::floor((1.0f + cx) / (float(mTabSize) * spaceSize))) * (float(mTabSize) * spaceSize);
								width = x - cx;
							}
							else
							{
								char buf2[2];
								buf2[0] = line[cindex].mChar;
								buf2[1] = '\0';
								width = ImGui::GetFont()->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, buf2).x;
							}
						}
						ImVec2 cstart(textScreenPos.x + cx, lineStartScreenPos.y);
						ImVec2 cend(textScreenPos.x + cx + width, lineStartScreenPos.y + mCharAdvance.y);
						drawList->AddRectFilled(cstart, cend, mPalette[(int)PaletteIndex::Cursor]);
					}
				}
			}

			// Render colorized text
			auto prevColor = line.empty() ? mPalette[(int)PaletteIndex::Default] : GetGlyphColor(line[0]);
			ImVec2 bufferOffset;

			for (int i = 0; i < line.size();)
			{
				auto& glyph = line[i];
				auto color = GetGlyphColor(glyph);

				if ((color != prevColor || glyph.mChar == '\t' || glyph.mChar == ' ') && !mLineBuffer.empty())
				{
					const ImVec2 newOffset(textScreenPos.x + bufferOffset.x, textScreenPos.y + bufferOffset.y);
					drawList->AddText(newOffset, prevColor, mLineBuffer.c_str());
					auto textSize = ImGui::GetFont()->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, mLineBuffer.c_str(), nullptr, nullptr);
					bufferOffset.x += textSize.x;
					mLineBuffer.clear();
				}
				prevColor = color;

				if (glyph.mChar == '\t')
				{
					auto oldX = bufferOffset.x;
					bufferOffset.x = (1.0f + std::floor((1.0f + bufferOffset.x) / (float(mTabSize) * spaceSize))) * (float(mTabSize) * spaceSize);
					++i;

					if (mShowWhitespaces)
					{
						ImVec2 p1, p2, p3, p4;

						if (mShowShortTabGlyphs)
						{
							const auto s = ImGui::GetFontSize();
							const auto x1 = textScreenPos.x + oldX + 1.0f;
							const auto x2 = textScreenPos.x + oldX + mCharAdvance.x - 1.0f;
							const auto y = textScreenPos.y + bufferOffset.y + s * 0.5f;

							p1 = ImVec2(x1, y);
							p2 = ImVec2(x2, y);
							p3 = ImVec2(x2 - s * 0.16f, y - s * 0.16f);
							p4 = ImVec2(x2 - s * 0.16f, y + s * 0.16f);
						}
						else
						{
							const auto s = ImGui::GetFontSize();
							const auto x1 = textScreenPos.x + oldX + 1.0f;
							const auto x2 = textScreenPos.x + bufferOffset.x - 1.0f;
							const auto y = textScreenPos.y + bufferOffset.y + s * 0.5f;

							p1 = ImVec2(x1, y);
							p2 = ImVec2(x2, y);
							p3 = ImVec2(x2 - s * 0.2f, y - s * 0.2f);
							p4 = ImVec2(x2 - s * 0.2f, y + s * 0.2f);
						}

						drawList->AddLine(p1, p2, mPalette[(int)PaletteIndex::ControlCharacter]);
						drawList->AddLine(p2, p3, mPalette[(int)PaletteIndex::ControlCharacter]);
						drawList->AddLine(p2, p4, mPalette[(int)PaletteIndex::ControlCharacter]);
					}
				}
				else if (glyph.mChar == ' ')
				{
					if (mShowWhitespaces)
					{
						const auto s = ImGui::GetFontSize();
						const auto x = textScreenPos.x + bufferOffset.x + spaceSize * 0.5f;
						const auto y = textScreenPos.y + bufferOffset.y + s * 0.5f;
						drawList->AddCircleFilled(ImVec2(x, y), 1.5f, 0x80808080, 4);
					}
					bufferOffset.x += spaceSize;
					i++;
				}
				else
				{
					auto l = UTF8CharLength(glyph.mChar);
					while (l-- > 0)
						mLineBuffer.push_back(line[i++].mChar);
				}
				++columnNo;
			}

			if (!mLineBuffer.empty())
			{
				const ImVec2 newOffset(textScreenPos.x + bufferOffset.x, textScreenPos.y + bufferOffset.y);
				drawList->AddText(newOffset, prevColor, mLineBuffer.c_str());
				mLineBuffer.clear();
			}

			++lineNo;
		}

		// Draw a tooltip on known identifiers/preprocessor symbols
		if (ImGui::IsMousePosValid() && ImGui::IsWindowHovered() && mLanguageDefinition != nullptr)
		{
			auto mpos = ImGui::GetMousePos();
			ImVec2 origin = ImGui::GetCursorScreenPos();
			ImVec2 local(mpos.x - origin.x, mpos.y - origin.y);
			//printf("Mouse: pos(%g, %g), origin(%g, %g), local(%g, %g)\n", mpos.x, mpos.y, origin.x, origin.y, local.x, local.y);
			if (local.x >= mTextStart)
			{
				auto pos = ScreenPosToCoordinates(mpos);
				//printf("Coord(%d, %d)\n", pos.mLine, pos.mColumn);
				auto id = GetWordAt(pos);
				if (!id.empty())
				{
					auto it = mLanguageDefinition->mIdentifiers.find(id);
					if (it != mLanguageDefinition->mIdentifiers.end())
					{
						ImGui::BeginTooltip();
						ImGui::TextUnformatted(it->second.mDeclaration.c_str());
						ImGui::EndTooltip();
					}
					else
					{
						auto pi = mLanguageDefinition->mPreprocIdentifiers.find(id);
						if (pi != mLanguageDefinition->mPreprocIdentifiers.end())
						{
							ImGui::BeginTooltip();
							ImGui::TextUnformatted(pi->second.mDeclaration.c_str());
							ImGui::EndTooltip();
						}
					}
				}
			}
		}
	}

	ImGui::SetCursorPos(ImVec2(0, 0));
	ImGui::Dummy(ImVec2((longest + 2), mLines.size() * mCharAdvance.y));

	if (mScrollToCursor)
	{
		EnsureCursorVisible();
		mScrollToCursor = false;
	}
}

void TextEditor::Render(const char* aTitle, bool aParentIsFocused, const ImVec2& aSize, bool aBorder)
{
	for (int c = 0; c <= mState.mCurrentCursor; c++)
	{
		if (mState.mCursors[c].mCursorPositionChanged)
			OnCursorPositionChanged(c);
		if (c <= mState.mCurrentCursor)
			mState.mCursors[c].mCursorPositionChanged = false;
	}

	mWithinRender = true;
	mTextChanged = false;

	UpdatePalette();

	ImGui::PushStyleColor(ImGuiCol_ChildBg, ImGui::ColorConvertU32ToFloat4(mPalette[(int)PaletteIndex::Background]));
	ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.0f, 0.0f));
	if (!mIgnoreImGuiChild)
		ImGui::BeginChild(aTitle, aSize, aBorder, ImGuiWindowFlags_HorizontalScrollbar | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoNavInputs);

	if (mHandleKeyboardInputs)
	{
		HandleKeyboardInputs(aParentIsFocused);
		ImGui::PushAllowKeyboardFocus(true);
	}

	if (mHandleMouseInputs)
		HandleMouseInputs();

	ColorizeInternal();
	Render(aParentIsFocused);

	if (mHandleKeyboardInputs)
		ImGui::PopAllowKeyboardFocus();

	if (!mIgnoreImGuiChild)
		ImGui::EndChild();

	ImGui::PopStyleVar();
	ImGui::PopStyleColor();

	mWithinRender = false;
}

void TextEditor::SetText(const std::string& aText)
{
	mLines.clear();
	mLines.emplace_back(Line());
	for (auto chr : aText)
	{
		if (chr == '\r')
		{
			// ignore the carriage return character
		}
		else if (chr == '\n')
			mLines.emplace_back(Line());
		else
		{
			mLines.back().emplace_back(Glyph(chr, PaletteIndex::Default));
		}
	}

	mTextChanged = true;
	mScrollToTop = true;

	mUndoBuffer.clear();
	mUndoIndex = 0;

	Colorize();
}

void TextEditor::SetTextLines(const std::vector<std::string>& aLines)
{
	mLines.clear();

	if (aLines.empty())
	{
		mLines.emplace_back(Line());
	}
	else
	{
		mLines.resize(aLines.size());

		for (size_t i = 0; i < aLines.size(); ++i)
		{
			const std::string& aLine = aLines[i];

			mLines[i].reserve(aLine.size());
			for (size_t j = 0; j < aLine.size(); ++j)
				mLines[i].emplace_back(Glyph(aLine[j], PaletteIndex::Default));
		}
	}

	mTextChanged = true;
	mScrollToTop = true;

	mUndoBuffer.clear();
	mUndoIndex = 0;

	Colorize();
}


void TextEditor::ChangeCurrentLinesIndentation(bool aIncrease)
{
	assert(!mReadOnly);

	UndoRecord u;
	u.mBefore = mState;

	for (int c = mState.mCurrentCursor; c > -1; c--)
	{
		auto start = mState.mCursors[c].mSelectionStart;
		auto end = mState.mCursors[c].mSelectionEnd;
		auto originalEnd = end;

		if (start > end)
			std::swap(start, end);
		start.mColumn = 0;
		//			end.mColumn = end.mLine < mLines.size() ? mLines[end.mLine].size() : 0;
		if (end.mColumn == 0 && end.mLine > 0)
			--end.mLine;
		if (end.mLine >= (int)mLines.size())
			end.mLine = mLines.empty() ? 0 : (int)mLines.size() - 1;
		end.mColumn = GetLineMaxColumn(end.mLine);

		//if (end.mColumn >= GetLineMaxColumn(end.mLine))
		//	end.mColumn = GetLineMaxColumn(end.mLine) - 1;

		UndoOperation removeOperation = { GetText(start, end) , start, end, UndoOperationType::Delete };

		bool modified = false;

		for (int i = start.mLine; i <= end.mLine; i++)
		{
			auto& line = mLines[i];
			if (!aIncrease)
			{
				if (!line.empty())

				{
					if (line.front().mChar == '\t')
					{
						RemoveGlyphsFromLine(i, 0, 1);
						modified = true;
					}
					else
					{
						for (int j = 0; j < mTabSize && !line.empty() && line.front().mChar == ' '; j++)
						{
							RemoveGlyphsFromLine(i, 0, 1);
							modified = true;
						}
					}
				}
			}
			else if (mLines[i].size() > 0)
			{
				AddGlyphToLine(i, 0, Glyph('\t', TextEditor::PaletteIndex::Background));
				modified = true;
			}
		}

		if (modified)
		{
			start = Coordinates(start.mLine, GetCharacterColumn(start.mLine, 0));
			Coordinates rangeEnd;
			std::string addedText;
			if (originalEnd.mColumn != 0)
			{
				end = Coordinates(end.mLine, GetLineMaxColumn(end.mLine));
				rangeEnd = end;
				addedText = GetText(start, end);
			}
			else
			{
				end = Coordinates(originalEnd.mLine, 0);
				rangeEnd = Coordinates(end.mLine - 1, GetLineMaxColumn(end.mLine - 1));
				addedText = GetText(start, rangeEnd);
			}

			u.mOperations.push_back(removeOperation);
			u.mOperations.push_back({ addedText , start, rangeEnd, UndoOperationType::Add });
			u.mAfter = mState;

			mState.mCursors[c].mSelectionStart = start;
			mState.mCursors[c].mSelectionEnd = end;

			mTextChanged = true;
		}
	}

	EnsureCursorVisible();
	if (u.mOperations.size() > 0)
		AddUndo(u);
}

void TextEditor::EnterCharacter(ImWchar aChar, bool aShift)
{
	assert(!mReadOnly);

	bool hasSelection = HasSelection();
	bool anyCursorHasMultilineSelection = false;
	for (int c = mState.mCurrentCursor; c > -1; c--)
		if (mState.mCursors[c].mSelectionStart.mLine != mState.mCursors[c].mSelectionEnd.mLine)
		{
			anyCursorHasMultilineSelection = true;
			break;
		}
	bool isIndentOperation = hasSelection && anyCursorHasMultilineSelection && aChar == '\t';
	if (isIndentOperation)
	{
		ChangeCurrentLinesIndentation(!aShift);
		return;
	}

	UndoRecord u;
	u.mBefore = mState;

	if (hasSelection)
	{
		for (int c = mState.mCurrentCursor; c > -1; c--)
		{
			u.mOperations.push_back({ GetSelectedText(c), mState.mCursors[c].mSelectionStart, mState.mCursors[c].mSelectionEnd, UndoOperationType::Delete });
			DeleteSelection(c);
		}
	} // HasSelection

	std::vector<Coordinates> coords;
	for (int c = mState.mCurrentCursor; c > -1; c--) // order important here for typing \n in the same line at the same time
	{
		auto coord = GetActualCursorCoordinates(c);
		coords.push_back(coord);
		UndoOperation added;
		added.mType = UndoOperationType::Add;
		added.mStart = coord;

		assert(!mLines.empty());

		if (aChar == '\n')
		{
			InsertLine(coord.mLine + 1);
			auto& line = mLines[coord.mLine];
			auto& newLine = mLines[coord.mLine + 1];

			added.mText = "";
			added.mText += (char)aChar;
			if (mLanguageDefinition != nullptr && mLanguageDefinition->mAutoIndentation)
				for (size_t it = 0; it < line.size() && isascii(line[it].mChar) && isblank(line[it].mChar); ++it)
				{
					newLine.push_back(line[it]);
					added.mText += line[it].mChar;
				}

			const size_t whitespaceSize = newLine.size();
			auto cindex = GetCharacterIndex(coord);
			AddGlyphsToLine(coord.mLine + 1, newLine.size(), line.begin() + cindex, line.end());
			RemoveGlyphsFromLine(coord.mLine, cindex);
			SetCursorPosition(Coordinates(coord.mLine + 1, GetCharacterColumn(coord.mLine + 1, (int)whitespaceSize)), c);
		}
		else
		{
			char buf[7];
			int e = ImTextCharToUtf8(buf, 7, aChar);
			if (e > 0)
			{
				buf[e] = '\0';
				auto& line = mLines[coord.mLine];
				auto cindex = GetCharacterIndex(coord);

				if (mOverwrite && cindex < (int)line.size())
				{
					auto d = UTF8CharLength(line[cindex].mChar);

					UndoOperation removed;
					removed.mType = UndoOperationType::Delete;
					removed.mStart = mState.mCursors[c].mCursorPosition;
					removed.mEnd = Coordinates(coord.mLine, GetCharacterColumn(coord.mLine, cindex + d));

					while (d-- > 0 && cindex < (int)line.size())
					{
						removed.mText += line[cindex].mChar;
						RemoveGlyphsFromLine(coord.mLine, cindex, cindex + 1);
					}
					u.mOperations.push_back(removed);
				}

				for (auto p = buf; *p != '\0'; p++, ++cindex)
					AddGlyphToLine(coord.mLine, cindex, Glyph(*p, PaletteIndex::Default));
				added.mText = buf;

				SetCursorPosition(Coordinates(coord.mLine, GetCharacterColumn(coord.mLine, cindex)), c);
			}
			else
				continue;
		}

		mTextChanged = true;

		added.mEnd = GetActualCursorCoordinates(c);
		u.mOperations.push_back(added);
	}

	u.mAfter = mState;
	AddUndo(u);

	for (const auto& coord : coords)
		Colorize(coord.mLine - 1, 3);
	EnsureCursorVisible();
}

void TextEditor::SetReadOnly(bool aValue)
{
	mReadOnly = aValue;
}

void TextEditor::OnCursorPositionChanged(int aCursor)
{
	if (mDraggingSelection)
		return;

	//std::cout << "Cursor position changed\n";
	// sort from cursors from top to bottom
	std::sort(mState.mCursors.begin(), mState.mCursors.begin() + (mState.mCurrentCursor + 1), [](const Cursor& a, const Cursor& b) -> bool
		{
			return a.mSelectionStart < b.mSelectionStart;
		});
	MergeCursorsIfPossible();
}

void TextEditor::SetColorizerEnable(bool aValue)
{
	mColorizerEnabled = aValue;
}

void TextEditor::SetCursorPosition(const Coordinates& aPosition, int aCursor)
{
	if (aCursor == -1)
		aCursor = mState.mCurrentCursor;

	//std::string log = "Moved cursor " + std::to_string(aCursor) + " from " +
	//	std::to_string(mState.mCursors[aCursor].mCursorPosition.mLine) + "," + std::to_string(mState.mCursors[aCursor].mCursorPosition.mColumn) + " to ";

	if (mState.mCursors[aCursor].mCursorPosition != aPosition)
	{
		mState.mCursors[aCursor].mCursorPosition = aPosition;
		mState.mCursors[aCursor].mCursorPositionChanged = true;
		EnsureCursorVisible();
	}

	//log += std::to_string(mState.mCursors[aCursor].mCursorPosition.mLine) + "," + std::to_string(mState.mCursors[aCursor].mCursorPosition.mColumn);
	//std::cout << log << std::endl;
}

void TextEditor::SetSelectionStart(const Coordinates& aPosition, int aCursor)
{
	if (aCursor == -1)
		aCursor = mState.mCurrentCursor;

	mState.mCursors[aCursor].mSelectionStart = SanitizeCoordinates(aPosition);
	if (mState.mCursors[aCursor].mSelectionStart > mState.mCursors[aCursor].mSelectionEnd)
		std::swap(mState.mCursors[aCursor].mSelectionStart, mState.mCursors[aCursor].mSelectionEnd);
}

void TextEditor::SetSelectionEnd(const Coordinates& aPosition, int aCursor)
{
	if (aCursor == -1)
		aCursor = mState.mCurrentCursor;

	mState.mCursors[aCursor].mSelectionEnd = SanitizeCoordinates(aPosition);
	if (mState.mCursors[aCursor].mSelectionStart > mState.mCursors[aCursor].mSelectionEnd)
		std::swap(mState.mCursors[aCursor].mSelectionStart, mState.mCursors[aCursor].mSelectionEnd);
}

void TextEditor::SetSelection(const Coordinates& aStart, const Coordinates& aEnd, SelectionMode aMode, int aCursor, bool isSpawningNewCursor)
{
	if (aCursor == -1)
		aCursor = mState.mCurrentCursor;

	auto oldSelStart = mState.mCursors[aCursor].mSelectionStart;
	auto oldSelEnd = mState.mCursors[aCursor].mSelectionEnd;

	mState.mCursors[aCursor].mSelectionStart = SanitizeCoordinates(aStart);
	mState.mCursors[aCursor].mSelectionEnd = SanitizeCoordinates(aEnd);
	if (mState.mCursors[aCursor].mSelectionStart > mState.mCursors[aCursor].mSelectionEnd)
		std::swap(mState.mCursors[aCursor].mSelectionStart, mState.mCursors[aCursor].mSelectionEnd);

	switch (aMode)
	{
	case TextEditor::SelectionMode::Normal:
	case TextEditor::SelectionMode::Word:
		break;
	case TextEditor::SelectionMode::Line:
	{
		const auto lineNo = mState.mCursors[aCursor].mSelectionEnd.mLine;
		const auto lineSize = (size_t)lineNo < mLines.size() ? mLines[lineNo].size() : 0;
		mState.mCursors[aCursor].mSelectionStart = Coordinates(mState.mCursors[aCursor].mSelectionStart.mLine, 0);
		mState.mCursors[aCursor].mSelectionEnd = mLines.size() > lineNo + 1 ? Coordinates(lineNo + 1, 0) : Coordinates(lineNo, GetLineMaxColumn(lineNo));
		mState.mCursors[aCursor].mCursorPosition = mState.mCursors[aCursor].mSelectionEnd;
		break;
	}
	default:
		break;
	}

	if (mState.mCursors[aCursor].mSelectionStart != oldSelStart ||
		mState.mCursors[aCursor].mSelectionEnd != oldSelEnd)
		if (!isSpawningNewCursor)
			mState.mCursors[aCursor].mCursorPositionChanged = true;
}

void TextEditor::SetTabSize(int aValue)
{
	mTabSize = std::max(0, std::min(32, aValue));
}

void TextEditor::InsertText(const std::string& aValue, int aCursor)
{
	InsertText(aValue.c_str(), aCursor);
}

void TextEditor::InsertText(const char* aValue, int aCursor)
{
	if (aValue == nullptr)
		return;
	if (aCursor == -1)
		aCursor = mState.mCurrentCursor;

	auto pos = GetActualCursorCoordinates(aCursor);
	auto start = std::min(pos, mState.mCursors[aCursor].mSelectionStart);
	int totalLines = pos.mLine - start.mLine;

	totalLines += InsertTextAt(pos, aValue);

	SetSelection(pos, pos, SelectionMode::Normal, aCursor);
	SetCursorPosition(pos, aCursor);
	Colorize(start.mLine - 1, totalLines + 2);
}

void TextEditor::DeleteSelection(int aCursor)
{
	if (aCursor == -1)
		aCursor = mState.mCurrentCursor;

	assert(mState.mCursors[aCursor].mSelectionEnd >= mState.mCursors[aCursor].mSelectionStart);

	if (mState.mCursors[aCursor].mSelectionEnd == mState.mCursors[aCursor].mSelectionStart)
		return;

	DeleteRange(mState.mCursors[aCursor].mSelectionStart, mState.mCursors[aCursor].mSelectionEnd);

	SetSelection(mState.mCursors[aCursor].mSelectionStart, mState.mCursors[aCursor].mSelectionStart, SelectionMode::Normal, aCursor);
	SetCursorPosition(mState.mCursors[aCursor].mSelectionStart, aCursor);
	mState.mCursors[aCursor].mInteractiveStart = mState.mCursors[aCursor].mSelectionStart;
	mState.mCursors[aCursor].mInteractiveEnd = mState.mCursors[aCursor].mSelectionEnd;
	Colorize(mState.mCursors[aCursor].mSelectionStart.mLine, 1);
}

void TextEditor::MoveUp(int aAmount, bool aSelect)
{
	if (HasSelection() && !aSelect)
	{
		for (int c = 0; c <= mState.mCurrentCursor; c++)
		{
			SetSelection(mState.mCursors[c].mSelectionStart, mState.mCursors[c].mSelectionStart, SelectionMode::Normal, c);
			SetCursorPosition(mState.mCursors[c].mSelectionStart);
		}
	}
	else
	{
		for (int c = 0; c <= mState.mCurrentCursor; c++)
		{
			auto oldPos = mState.mCursors[c].mCursorPosition;
			mState.mCursors[c].mCursorPosition.mLine = std::max(0, mState.mCursors[c].mCursorPosition.mLine - aAmount);
			if (oldPos != mState.mCursors[c].mCursorPosition)
			{
				if (aSelect)
				{
					if (oldPos == mState.mCursors[c].mInteractiveStart)
						mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mCursorPosition;
					else if (oldPos == mState.mCursors[c].mInteractiveEnd)
						mState.mCursors[c].mInteractiveEnd = mState.mCursors[c].mCursorPosition;
					else
					{
						mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mCursorPosition;
						mState.mCursors[c].mInteractiveEnd = oldPos;
					}
				}
				else
					mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mInteractiveEnd = mState.mCursors[c].mCursorPosition;
				SetSelection(mState.mCursors[c].mInteractiveStart, mState.mCursors[c].mInteractiveEnd, SelectionMode::Normal, c);
			}
		}
	}
	EnsureCursorVisible();
}

void TextEditor::MoveDown(int aAmount, bool aSelect)
{
	if (HasSelection() && !aSelect)
	{
		for (int c = 0; c <= mState.mCurrentCursor; c++)
		{
			SetSelection(mState.mCursors[c].mSelectionEnd, mState.mCursors[c].mSelectionEnd, SelectionMode::Normal, c);
			SetCursorPosition(mState.mCursors[c].mSelectionEnd);
		}
	}
	else
	{
		for (int c = 0; c <= mState.mCurrentCursor; c++)
		{
			assert(mState.mCursors[c].mCursorPosition.mColumn >= 0);
			auto oldPos = mState.mCursors[c].mCursorPosition;
			mState.mCursors[c].mCursorPosition.mLine = std::max(0, std::min((int)mLines.size() - 1, mState.mCursors[c].mCursorPosition.mLine + aAmount));

			if (mState.mCursors[c].mCursorPosition != oldPos)
			{
				if (aSelect)
				{
					if (oldPos == mState.mCursors[c].mInteractiveEnd)
						mState.mCursors[c].mInteractiveEnd = mState.mCursors[c].mCursorPosition;
					else if (oldPos == mState.mCursors[c].mInteractiveStart)
						mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mCursorPosition;
					else
					{
						mState.mCursors[c].mInteractiveStart = oldPos;
						mState.mCursors[c].mInteractiveEnd = mState.mCursors[c].mCursorPosition;
					}
				}
				else
					mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mInteractiveEnd = mState.mCursors[c].mCursorPosition;
				SetSelection(mState.mCursors[c].mInteractiveStart, mState.mCursors[c].mInteractiveEnd, SelectionMode::Normal, c);

			}
		}
	}
	EnsureCursorVisible();
}

static bool IsUTFSequence(char c)
{
	return (c & 0xC0) == 0x80;
}

void TextEditor::MoveLeft(int aAmount, bool aSelect, bool aWordMode)
{
	if (mLines.empty())
		return;

	if (HasSelection() && !aSelect && !aWordMode)
	{
		for (int c = 0; c <= mState.mCurrentCursor; c++)
		{
			SetSelection(mState.mCursors[c].mSelectionStart, mState.mCursors[c].mSelectionStart, SelectionMode::Normal, c);
			SetCursorPosition(mState.mCursors[c].mSelectionStart);
		}
	}
	else
	{
		for (int c = 0; c <= mState.mCurrentCursor; c++)
		{
			int amount = aAmount;
			auto oldPos = mState.mCursors[c].mCursorPosition;
			mState.mCursors[c].mCursorPosition = GetActualCursorCoordinates(c);
			auto line = mState.mCursors[c].mCursorPosition.mLine;
			auto cindex = GetCharacterIndex(mState.mCursors[c].mCursorPosition);

			while (amount-- > 0)
			{
				if (cindex == 0)
				{
					if (line > 0)
					{
						--line;
						if ((int)mLines.size() > line)
							cindex = (int)mLines[line].size();
						else
							cindex = 0;
					}
				}
				else
				{
					--cindex;
					if (cindex > 0)
					{
						if ((int)mLines.size() > line)
						{
							while (cindex > 0 && IsUTFSequence(mLines[line][cindex].mChar))
								--cindex;
						}
					}
				}

				mState.mCursors[c].mCursorPosition = Coordinates(line, GetCharacterColumn(line, cindex));
				if (aWordMode)
				{
					mState.mCursors[c].mCursorPosition = FindWordStart(mState.mCursors[c].mCursorPosition);
					cindex = GetCharacterIndex(mState.mCursors[c].mCursorPosition);
				}
			}

			mState.mCursors[c].mCursorPosition = Coordinates(line, GetCharacterColumn(line, cindex));
			std::cout << "changed from " << oldPos.mColumn << " to " << mState.mCursors[c].mCursorPosition.mColumn << std::endl;

			assert(mState.mCursors[c].mCursorPosition.mColumn >= 0);
			if (aSelect)
			{
				if (oldPos == mState.mCursors[c].mInteractiveStart)
					mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mCursorPosition;
				else if (oldPos == mState.mCursors[c].mInteractiveEnd)
					mState.mCursors[c].mInteractiveEnd = mState.mCursors[c].mCursorPosition;
				else
				{
					mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mCursorPosition;
					mState.mCursors[c].mInteractiveEnd = oldPos;
				}
			}
			else
			{
				if (HasSelection() && !aWordMode)
					mState.mCursors[c].mCursorPosition = mState.mCursors[c].mInteractiveStart;
				mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mInteractiveEnd = mState.mCursors[c].mCursorPosition;
			}
			std::cout << "Setting selection for " << c << std::endl;
			SetSelection(mState.mCursors[c].mInteractiveStart, mState.mCursors[c].mInteractiveEnd, aSelect && aWordMode ? SelectionMode::Word : SelectionMode::Normal, c);
		}
	}
	EnsureCursorVisible();
}

void TextEditor::MoveRight(int aAmount, bool aSelect, bool aWordMode)
{
	if (mLines.empty())
		return;

	if (HasSelection() && !aSelect && !aWordMode)
	{
		for (int c = 0; c <= mState.mCurrentCursor; c++)
		{
			SetSelection(mState.mCursors[c].mSelectionEnd, mState.mCursors[c].mSelectionEnd, SelectionMode::Normal, c);
			SetCursorPosition(mState.mCursors[c].mSelectionEnd);
		}
	}
	else
	{
		for (int c = 0; c <= mState.mCurrentCursor; c++)
		{
			auto oldPos = mState.mCursors[c].mCursorPosition;
			if (oldPos.mLine >= mLines.size())
				continue;

			int amount = aAmount;
			auto cindex = GetCharacterIndex(mState.mCursors[c].mCursorPosition);
			while (amount-- > 0)
			{
				auto lindex = mState.mCursors[c].mCursorPosition.mLine;
				auto& line = mLines[lindex];

				if (cindex >= line.size())
				{
					if (mState.mCursors[c].mCursorPosition.mLine < mLines.size() - 1)
					{
						mState.mCursors[c].mCursorPosition.mLine = std::max(0, std::min((int)mLines.size() - 1, mState.mCursors[c].mCursorPosition.mLine + 1));
						mState.mCursors[c].mCursorPosition.mColumn = 0;
					}
					else
						continue;
				}
				else
				{
					cindex += UTF8CharLength(line[cindex].mChar);
					mState.mCursors[c].mCursorPosition = Coordinates(lindex, GetCharacterColumn(lindex, cindex));
					if (aWordMode)
						mState.mCursors[c].mCursorPosition = FindWordEnd(mState.mCursors[c].mCursorPosition);
				}
			}

			if (aSelect)
			{
				if (oldPos == mState.mCursors[c].mInteractiveEnd)
					mState.mCursors[c].mInteractiveEnd = SanitizeCoordinates(mState.mCursors[c].mCursorPosition);
				else if (oldPos == mState.mCursors[c].mInteractiveStart)
					mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mCursorPosition;
				else
				{
					mState.mCursors[c].mInteractiveStart = oldPos;
					mState.mCursors[c].mInteractiveEnd = mState.mCursors[c].mCursorPosition;
				}
			}
			else
			{
				if (HasSelection() && !aWordMode)
					mState.mCursors[c].mCursorPosition = mState.mCursors[c].mInteractiveEnd;
				mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mInteractiveEnd = mState.mCursors[c].mCursorPosition;
			}
			SetSelection(mState.mCursors[c].mInteractiveStart, mState.mCursors[c].mInteractiveEnd, aSelect && aWordMode ? SelectionMode::Word : SelectionMode::Normal, c);
		}
	}
	EnsureCursorVisible();
}

void TextEditor::MoveTop(bool aSelect)
{
	mState.mCurrentCursor = 0;
	auto oldPos = mState.mCursors[mState.mCurrentCursor].mCursorPosition;
	SetCursorPosition(Coordinates(0, 0));

	if (mState.mCursors[mState.mCurrentCursor].mCursorPosition != oldPos)
	{
		if (aSelect)
		{
			mState.mCursors[mState.mCurrentCursor].mInteractiveEnd = oldPos;
			mState.mCursors[mState.mCurrentCursor].mInteractiveStart = mState.mCursors[mState.mCurrentCursor].mCursorPosition;
		}
		else
			mState.mCursors[mState.mCurrentCursor].mInteractiveStart = mState.mCursors[mState.mCurrentCursor].mInteractiveEnd = mState.mCursors[mState.mCurrentCursor].mCursorPosition;
		SetSelection(mState.mCursors[mState.mCurrentCursor].mInteractiveStart, mState.mCursors[mState.mCurrentCursor].mInteractiveEnd);
	}
}

void TextEditor::TextEditor::MoveBottom(bool aSelect)
{
	mState.mCurrentCursor = 0;
	auto oldPos = GetCursorPosition();
	auto newPos = Coordinates((int)mLines.size() - 1, 0);
	SetCursorPosition(newPos);
	if (aSelect)
	{
		mState.mCursors[mState.mCurrentCursor].mInteractiveStart = oldPos;
		mState.mCursors[mState.mCurrentCursor].mInteractiveEnd = newPos;
	}
	else
		mState.mCursors[mState.mCurrentCursor].mInteractiveStart = mState.mCursors[mState.mCurrentCursor].mInteractiveEnd = newPos;
	SetSelection(mState.mCursors[mState.mCurrentCursor].mInteractiveStart, mState.mCursors[mState.mCurrentCursor].mInteractiveEnd);
}

void TextEditor::MoveHome(bool aSelect)
{
	for (int c = 0; c <= mState.mCurrentCursor; c++)
	{
		auto oldPos = mState.mCursors[c].mCursorPosition;
		SetCursorPosition(Coordinates(mState.mCursors[c].mCursorPosition.mLine, 0), c);

		if (aSelect)
		{
			if (oldPos == mState.mCursors[c].mInteractiveStart)
				mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mCursorPosition;
			else if (oldPos == mState.mCursors[c].mInteractiveEnd)
				mState.mCursors[c].mInteractiveEnd = mState.mCursors[c].mCursorPosition;
			else
			{
				mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mCursorPosition;
				mState.mCursors[c].mInteractiveEnd = oldPos;
			}
		}
		else
			mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mInteractiveEnd = mState.mCursors[c].mCursorPosition;
		SetSelection(mState.mCursors[c].mInteractiveStart, mState.mCursors[c].mInteractiveEnd, SelectionMode::Normal, c);
	}
}

void TextEditor::MoveEnd(bool aSelect)
{
	for (int c = 0; c <= mState.mCurrentCursor; c++)
	{
		auto oldPos = mState.mCursors[c].mCursorPosition;
		SetCursorPosition(Coordinates(mState.mCursors[c].mCursorPosition.mLine, GetLineMaxColumn(oldPos.mLine)), c);

		if (aSelect)
		{
			if (oldPos == mState.mCursors[c].mInteractiveEnd)
				mState.mCursors[c].mInteractiveEnd = mState.mCursors[c].mCursorPosition;
			else if (oldPos == mState.mCursors[c].mInteractiveStart)
				mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mCursorPosition;
			else
			{
				mState.mCursors[c].mInteractiveStart = oldPos;
				mState.mCursors[c].mInteractiveEnd = mState.mCursors[c].mCursorPosition;
			}
		}
		else
			mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mInteractiveEnd = mState.mCursors[c].mCursorPosition;
		SetSelection(mState.mCursors[c].mInteractiveStart, mState.mCursors[c].mInteractiveEnd, SelectionMode::Normal, c);
	}
}

void TextEditor::Delete(bool aWordMode)
{
	assert(!mReadOnly);

	if (mLines.empty())
		return;

	UndoRecord u;
	u.mBefore = mState;

	if (HasSelection())
	{
		for (int c = mState.mCurrentCursor; c > -1; c--)
		{
			u.mOperations.push_back({ GetSelectedText(c), mState.mCursors[c].mSelectionStart, mState.mCursors[c].mSelectionEnd, UndoOperationType::Delete });
			DeleteSelection(c);
		}
	}
	else
	{
		std::vector<Coordinates> positions;
		for (int c = 0; c <= mState.mCurrentCursor; c++)
		{
			auto pos = GetActualCursorCoordinates(c);
			positions.push_back(pos);
			SetCursorPosition(pos, c);
			auto& line = mLines[pos.mLine];

			if (pos.mColumn == GetLineMaxColumn(pos.mLine))
			{
				if (pos.mLine == (int)mLines.size() - 1)
					continue;

				Coordinates startCoords = GetActualCursorCoordinates(c);
				Coordinates endCoords = startCoords;
				Advance(endCoords);
				u.mOperations.push_back({ "\n", startCoords, endCoords, UndoOperationType::Delete });

				auto& nextLine = mLines[pos.mLine + 1];
				AddGlyphsToLine(pos.mLine, line.size(), nextLine.begin(), nextLine.end());
				for (int otherCursor = c + 1;
					otherCursor <= mState.mCurrentCursor && mState.mCursors[otherCursor].mCursorPosition.mLine == pos.mLine + 1;
					otherCursor++) // move up cursors in next line
				{
					int otherCursorCharIndex = GetCharacterIndex(mState.mCursors[otherCursor].mCursorPosition);
					int otherCursorNewCharIndex = GetCharacterIndex(pos) + otherCursorCharIndex;
					auto targetCoords = Coordinates(pos.mLine, GetCharacterColumn(pos.mLine, otherCursorNewCharIndex));
					SetCursorPosition(targetCoords, otherCursor);
				}
				RemoveLine(pos.mLine + 1);
			}
			else
			{
				if (aWordMode)
				{
					Coordinates end = FindWordEnd(mState.mCursors[c].mCursorPosition);
					u.mOperations.push_back({ GetText(mState.mCursors[c].mCursorPosition, end),  mState.mCursors[c].mCursorPosition , end, UndoOperationType::Delete });
					DeleteRange(mState.mCursors[c].mCursorPosition, end);
					int charactersDeleted = end.mColumn - mState.mCursors[c].mCursorPosition.mColumn;
				}
				else
				{
					auto cindex = GetCharacterIndex(pos);

					Coordinates start = GetActualCursorCoordinates(c);
					Coordinates end = start;
					end.mColumn++;
					u.mOperations.push_back({ GetText(start, end), start, end, UndoOperationType::Delete });

					auto d = UTF8CharLength(line[cindex].mChar);
					while (d-- > 0 && cindex < (int)line.size())
						RemoveGlyphsFromLine(pos.mLine, cindex, cindex + 1);
				}
			}
		}

		mTextChanged = true;

		for (const auto& pos : positions)
			Colorize(pos.mLine, 1);
	}

	u.mAfter = mState;
	AddUndo(u);
}

void TextEditor::Backspace(bool aWordMode)
{
	assert(!mReadOnly);

	if (mLines.empty())
		return;

	UndoRecord u;
	u.mBefore = mState;

	if (HasSelection())
	{
		for (int c = mState.mCurrentCursor; c > -1; c--)
		{
			u.mOperations.push_back({ GetSelectedText(c), mState.mCursors[c].mSelectionStart, mState.mCursors[c].mSelectionEnd, UndoOperationType::Delete });
			DeleteSelection(c);
		}
	}
	else
	{
		for (int c = 0; c <= mState.mCurrentCursor; c++)
		{
			auto pos = GetActualCursorCoordinates(c);
			SetCursorPosition(pos, c);

			if (mState.mCursors[c].mCursorPosition.mColumn == 0)
			{
				if (mState.mCursors[c].mCursorPosition.mLine == 0)
					continue;

				Coordinates startCoords = Coordinates(pos.mLine - 1, GetLineMaxColumn(pos.mLine - 1));
				Coordinates endCoords = startCoords;
				Advance(endCoords);
				u.mOperations.push_back({ "\n", startCoords, endCoords, UndoOperationType::Delete });

				auto& line = mLines[mState.mCursors[c].mCursorPosition.mLine];
				int prevLineIndex = mState.mCursors[c].mCursorPosition.mLine - 1;
				auto& prevLine = mLines[prevLineIndex];
				auto prevSize = GetLineMaxColumn(prevLineIndex);
				AddGlyphsToLine(prevLineIndex, prevLine.size(), line.begin(), line.end());
				std::unordered_set<int> cursorsHandled = { c };
				for (int otherCursor = c + 1;
					otherCursor <= mState.mCurrentCursor && mState.mCursors[otherCursor].mCursorPosition.mLine == mState.mCursors[c].mCursorPosition.mLine;
					otherCursor++) // move up cursors in same line
				{
					int otherCursorCharIndex = GetCharacterIndex(mState.mCursors[otherCursor].mCursorPosition);
					int otherCursorNewCharIndex = GetCharacterIndex({ prevLineIndex, prevSize }) + otherCursorCharIndex;
					auto targetCoords = Coordinates(prevLineIndex, GetCharacterColumn(prevLineIndex, otherCursorNewCharIndex));
					SetCursorPosition(targetCoords, otherCursor);
					cursorsHandled.insert(otherCursor);
				}

				ErrorMarkers etmp;
				for (auto& i : mErrorMarkers)
					etmp.insert(ErrorMarkers::value_type(i.first - 1 == mState.mCursors[c].mCursorPosition.mLine ? i.first - 1 : i.first, i.second));
				mErrorMarkers = std::move(etmp);

				RemoveLine(mState.mCursors[c].mCursorPosition.mLine, &cursorsHandled);
				SetCursorPosition({ mState.mCursors[c].mCursorPosition.mLine - 1, prevSize }, c);
			}
			else
			{
				auto& line = mLines[mState.mCursors[c].mCursorPosition.mLine];

				if (aWordMode)
				{
					Coordinates start = FindWordStart(mState.mCursors[c].mCursorPosition - Coordinates(0, 1));
					u.mOperations.push_back({ GetText(start, mState.mCursors[c].mCursorPosition) , start, mState.mCursors[c].mCursorPosition, UndoOperationType::Delete });
					DeleteRange(start, mState.mCursors[c].mCursorPosition);
					int charactersDeleted = mState.mCursors[c].mCursorPosition.mColumn - start.mColumn;
					mState.mCursors[c].mCursorPosition.mColumn -= charactersDeleted;
				}
				else
				{
					auto cindex = GetCharacterIndex(pos) - 1;
					auto cend = cindex + 1;
					while (cindex > 0 && IsUTFSequence(line[cindex].mChar))
						--cindex;

					//if (cindex > 0 && UTF8CharLength(line[cindex].mChar) > 1)
					//	--cindex;

					UndoOperation removed;
					removed.mType = UndoOperationType::Delete;
					removed.mStart = removed.mEnd = GetActualCursorCoordinates(c);

					if (line[cindex].mChar == '\t')
					{
						int tabStartColumn = GetCharacterColumn(removed.mStart.mLine, cindex);
						int tabLength = removed.mStart.mColumn - tabStartColumn;
						mState.mCursors[c].mCursorPosition.mColumn -= tabLength;
						removed.mStart.mColumn -= tabLength;
					}
					else
					{
						--mState.mCursors[c].mCursorPosition.mColumn;
						--removed.mStart.mColumn;
					}

					while (cindex < line.size() && cend-- > cindex)
					{
						removed.mText += line[cindex].mChar;
						RemoveGlyphsFromLine(mState.mCursors[c].mCursorPosition.mLine, cindex, cindex + 1);
					}
					u.mOperations.push_back(removed);
				}
				mState.mCursors[c].mCursorPositionChanged = true;
			}
		}

		mTextChanged = true;

		EnsureCursorVisible();
		for (int c = 0; c <= mState.mCurrentCursor; c++)
			Colorize(mState.mCursors[c].mCursorPosition.mLine, 1);
	}

	u.mAfter = mState;
	AddUndo(u);
}

void TextEditor::SelectWordUnderCursor()
{
	auto c = GetCursorPosition();
	SetSelection(FindWordStart(c), FindWordEnd(c));
}

void TextEditor::SelectAll()
{
	SetSelection(Coordinates(0, 0), Coordinates((int)mLines.size(), 0), SelectionMode::Line);
}

bool TextEditor::HasSelection() const
{
	for (int c = 0; c <= mState.mCurrentCursor; c++)
		if (mState.mCursors[c].mSelectionEnd > mState.mCursors[c].mSelectionStart)
			return true;
	return false;
}

void TextEditor::Copy()
{
	if (HasSelection())
	{
		std::string clipboardText = GetClipboardText();
		ImGui::SetClipboardText(clipboardText.c_str());
	}
	else
	{
		if (!mLines.empty())
		{
			std::string str;
			auto& line = mLines[GetActualCursorCoordinates().mLine];
			for (auto& g : line)
				str.push_back(g.mChar);
			ImGui::SetClipboardText(str.c_str());
		}
	}
}

void TextEditor::Cut()
{
	if (IsReadOnly())
	{
		Copy();
	}
	else
	{
		if (HasSelection())
		{
			UndoRecord u;
			u.mBefore = mState;

			Copy();
			for (int c = mState.mCurrentCursor; c > -1; c--)
			{
				u.mOperations.push_back({ GetSelectedText(c), mState.mCursors[c].mSelectionStart, mState.mCursors[c].mSelectionEnd, UndoOperationType::Delete });
				DeleteSelection(c);
			}

			u.mAfter = mState;
			AddUndo(u);
		}
	}
}

void TextEditor::Paste()
{
	if (IsReadOnly())
		return;

	// check if we should do multicursor paste
	std::string clipText = ImGui::GetClipboardText();
	bool canPasteToMultipleCursors = false;
	std::vector<std::pair<int, int>> clipTextLines;
	if (mState.mCurrentCursor > 0)
	{
		clipTextLines.push_back({ 0,0 });
		for (int i = 0; i < clipText.length(); i++)
		{
			if (clipText[i] == '\n')
			{
				clipTextLines.back().second = i;
				clipTextLines.push_back({ i + 1, 0 });
			}
		}
		clipTextLines.back().second = clipText.length();
		canPasteToMultipleCursors = clipTextLines.size() == mState.mCurrentCursor + 1;
	}

	if (clipText.length() > 0)
	{
		UndoRecord u;
		u.mBefore = mState;

		if (HasSelection())
		{
			for (int c = mState.mCurrentCursor; c > -1; c--)
			{
				u.mOperations.push_back({ GetSelectedText(c), mState.mCursors[c].mSelectionStart, mState.mCursors[c].mSelectionEnd, UndoOperationType::Delete });
				DeleteSelection(c);
			}
		}

		for (int c = mState.mCurrentCursor; c > -1; c--)
		{
			Coordinates start = GetActualCursorCoordinates(c);
			if (canPasteToMultipleCursors)
			{
				std::string clipSubText = clipText.substr(clipTextLines[c].first, clipTextLines[c].second - clipTextLines[c].first);
				InsertText(clipSubText, c);
				u.mOperations.push_back({ clipSubText, start, GetActualCursorCoordinates(c), UndoOperationType::Add });
			}
			else
			{
				InsertText(clipText, c);
				u.mOperations.push_back({ clipText, start, GetActualCursorCoordinates(c), UndoOperationType::Add });
			}
		}

		u.mAfter = mState;
		AddUndo(u);
	}
}

bool TextEditor::CanUndo() const
{
	return !mReadOnly && mUndoIndex > 0;
}

bool TextEditor::CanRedo() const
{
	return !mReadOnly && mUndoIndex < (int)mUndoBuffer.size();
}

void TextEditor::Undo(int aSteps)
{
	while (CanUndo() && aSteps-- > 0)
		mUndoBuffer[--mUndoIndex].Undo(this);
}

void TextEditor::Redo(int aSteps)
{
	while (CanRedo() && aSteps-- > 0)
		mUndoBuffer[mUndoIndex++].Redo(this);
}

const TextEditor::Palette& TextEditor::GetDarkPalette()
{
	const static Palette p = { {
			0xb0b0b0ff,	// Default
			0x569cd6ff,	// Keyword
			0x00ff00ff,	// Number
			0xe07070ff,	// String
			0xe0a070ff, // Char literal
			0xffffffff, // Punctuation
			0x808040ff,	// Preprocessor
			0xaaaaaaff, // Identifier
			0x4dc69bff, // Known identifier
			0xa040c0ff, // Preproc identifier
			0x206020ff, // Comment (single line)
			0x206040ff, // Comment (multi line)
			0x101010ff, // Background
			0xe0e0e0ff, // Cursor
			0x2060a080, // Selection
			0xff200080, // ErrorMarker
			0x90909090, // ControlCharacter
			0x0080f040, // Breakpoint
			0x007070ff, // Line number
			0x00000040, // Current line fill
			0x80808040, // Current line fill (inactive)
			0xa0a0a040, // Current line edge
		} };
	return p;
}

const TextEditor::Palette& TextEditor::GetMarianaPalette()
{
	const static Palette p = { {
			0xffffffff,	// Default
			0xc695c6ff,	// Keyword
			0xf9ae58ff,	// Number
			0x99c794ff,	// String
			0xe0a070ff, // Char literal
			0x5fb4b4ff, // Punctuation
			0x808040ff,	// Preprocessor
			0xffffffff, // Identifier
			0x4dc69bff, // Known identifier
			0xe0a0ffff, // Preproc identifier
			0xa6acb9ff, // Comment (single line)
			0xa6acb9ff, // Comment (multi line)
			0x303841ff, // Background
			0xe0e0e0ff, // Cursor
			0x4e5a6580, // Selection
			0xec5f6680, // ErrorMarker
			0xffffff30, // ControlCharacter
			0x0080f040, // Breakpoint
			0xffffffb0, // Line number
			0x4e5a6580, // Current line fill
			0x4e5a6530, // Current line fill (inactive)
			0x4e5a65b0, // Current line edge
		} };
	return p;
}

const TextEditor::Palette& TextEditor::GetLightPalette()
{
	const static Palette p = { {
			0x404040ff,	// None
			0x060cffff,	// Keyword	
			0x008000ff,	// Number
			0xa02020ff,	// String
			0x704030ff, // Char literal
			0x000000ff, // Punctuation
			0x606040ff,	// Preprocessor
			0x404040ff, // Identifier
			0x106060ff, // Known identifier
			0xa040c0ff, // Preproc identifier
			0x205020ff, // Comment (single line)
			0x205040ff, // Comment (multi line)
			0xffffffff, // Background
			0x000000ff, // Cursor
			0x00006040, // Selection
			0xff1000a0, // ErrorMarker
			0x90909090, // ControlCharacter
			0x0080f080, // Breakpoint
			0x005050ff, // Line number
			0x00000040, // Current line fill
			0x80808040, // Current line fill (inactive)
			0x00000040, // Current line edge
		} };
	return p;
}

const TextEditor::Palette& TextEditor::GetRetroBluePalette()
{
	const static Palette p = { {
			0xffff00ff,	// None
			0x00ffffff,	// Keyword	
			0x00ff00ff,	// Number
			0x008080ff,	// String
			0x008080ff, // Char literal
			0xffffffff, // Punctuation
			0x008000ff,	// Preprocessor
			0xffff00ff, // Identifier
			0xffffffff, // Known identifier
			0xff00ffff, // Preproc identifier
			0x808080ff, // Comment (single line)
			0x404040ff, // Comment (multi line)
			0x000080ff, // Background
			0xff8000ff, // Cursor
			0x00ffff80, // Selection
			0xff0000a0, // ErrorMarker
			0x0080ff80, // Breakpoint
			0x008080ff, // Line number
			0x00000040, // Current line fill
			0x80808040, // Current line fill (inactive)
			0x00000040, // Current line edge
		} };
	return p;
}

void TextEditor::MergeCursorsIfPossible()
{
	// requires the cursors to be sorted from top to bottom
	std::unordered_set<int> cursorsToDelete;
	if (HasSelection())
	{
		// merge cursors if they overlap
		for (int c = mState.mCurrentCursor; c > 0; c--)// iterate backwards through pairs
		{
			int pc = c - 1;

			bool pcContainsC = mState.mCursors[pc].mSelectionEnd >= mState.mCursors[c].mSelectionEnd;
			bool pcContainsStartOfC = mState.mCursors[pc].mSelectionEnd >= mState.mCursors[c].mSelectionStart;

			if (pcContainsC)
			{
				cursorsToDelete.insert(c);
			}
			else if (pcContainsStartOfC)
			{
				mState.mCursors[pc].mSelectionEnd = mState.mCursors[c].mSelectionEnd;
				mState.mCursors[pc].mInteractiveEnd = mState.mCursors[c].mSelectionEnd;
				mState.mCursors[pc].mInteractiveStart = mState.mCursors[pc].mSelectionStart;
				mState.mCursors[pc].mCursorPosition = mState.mCursors[c].mSelectionEnd;
				cursorsToDelete.insert(c);
			}
		}
	}
	else
	{
		// merge cursors if they are at the same position
		for (int c = mState.mCurrentCursor; c > 0; c--)// iterate backwards through pairs
		{
			int pc = c - 1;
			if (mState.mCursors[pc].mCursorPosition == mState.mCursors[c].mCursorPosition)
				cursorsToDelete.insert(c);
		}
	}
	for (int c = mState.mCurrentCursor; c > -1; c--)// iterate backwards through each of them
	{
		if (cursorsToDelete.find(c) != cursorsToDelete.end())
			mState.mCursors.erase(mState.mCursors.begin() + c);
	}
	mState.mCurrentCursor -= cursorsToDelete.size();
}


std::string TextEditor::GetText() const
{
	auto lastLine = (int)mLines.size() - 1;
	auto lastLineLength = GetLineMaxColumn(lastLine);
	return GetText(Coordinates(), Coordinates(lastLine, lastLineLength));
}

std::vector<std::string> TextEditor::GetTextLines() const
{
	std::vector<std::string> result;

	result.reserve(mLines.size());

	for (auto& line : mLines)
	{
		std::string text;

		text.resize(line.size());

		for (size_t i = 0; i < line.size(); ++i)
			text[i] = line[i].mChar;

		result.emplace_back(std::move(text));
	}

	return result;
}

std::string TextEditor::GetClipboardText() const
{
	std::string result;
	for (int c = 0; c <= mState.mCurrentCursor; c++)
	{
		if (mState.mCursors[c].mSelectionStart < mState.mCursors[c].mSelectionEnd)
		{
			if (result.length() != 0)
				result += '\n';
			result += GetText(mState.mCursors[c].mSelectionStart, mState.mCursors[c].mSelectionEnd);
		}
	}
	return result;
}

std::string TextEditor::GetSelectedText(int aCursor) const
{
	if (aCursor == -1)
		aCursor = mState.mCurrentCursor;

	return GetText(mState.mCursors[aCursor].mSelectionStart, mState.mCursors[aCursor].mSelectionEnd);
}

std::string TextEditor::GetCurrentLineText()const
{
	auto lineLength = GetLineMaxColumn(mState.mCursors[mState.mCurrentCursor].mCursorPosition.mLine);
	return GetText(
		Coordinates(mState.mCursors[mState.mCurrentCursor].mCursorPosition.mLine, 0),
		Coordinates(mState.mCursors[mState.mCurrentCursor].mCursorPosition.mLine, lineLength));
}

void TextEditor::ProcessInputs()
{
}

void TextEditor::Colorize(int aFromLine, int aLines)
{
	int toLine = aLines == -1 ? (int)mLines.size() : std::min((int)mLines.size(), aFromLine + aLines);
	mColorRangeMin = std::min(mColorRangeMin, aFromLine);
	mColorRangeMax = std::max(mColorRangeMax, toLine);
	mColorRangeMin = std::max(0, mColorRangeMin);
	mColorRangeMax = std::max(mColorRangeMin, mColorRangeMax);
	mCheckComments = true;
}

void TextEditor::ColorizeRange(int aFromLine, int aToLine)
{
	if (mLines.empty() || aFromLine >= aToLine || mLanguageDefinition == nullptr)
		return;

	std::string buffer;
	std::cmatch results;
	std::string id;

	int endLine = std::max(0, std::min((int)mLines.size(), aToLine));
	for (int i = aFromLine; i < endLine; ++i)
	{
		auto& line = mLines[i];

		if (line.empty())
			continue;

		buffer.resize(line.size());
		for (size_t j = 0; j < line.size(); ++j)
		{
			auto& col = line[j];
			buffer[j] = col.mChar;
			col.mColorIndex = PaletteIndex::Default;
		}

		const char* bufferBegin = &buffer.front();
		const char* bufferEnd = bufferBegin + buffer.size();

		auto last = bufferEnd;

		for (auto first = bufferBegin; first != last; )
		{
			const char* token_begin = nullptr;
			const char* token_end = nullptr;
			PaletteIndex token_color = PaletteIndex::Default;

			bool hasTokenizeResult = false;

			if (mLanguageDefinition->mTokenize != nullptr)
			{
				if (mLanguageDefinition->mTokenize(first, last, token_begin, token_end, token_color))
					hasTokenizeResult = true;
			}

			if (hasTokenizeResult == false)
			{
				// todo : remove
				//printf("using regex for %.*s\n", first + 10 < last ? 10 : int(last - first), first);

				for (const auto& p : mRegexList)
				{
					if (std::regex_search(first, last, results, p.first, std::regex_constants::match_continuous))
					{
						hasTokenizeResult = true;

						auto& v = *results.begin();
						token_begin = v.first;
						token_end = v.second;
						token_color = p.second;
						break;
					}
				}
			}

			if (hasTokenizeResult == false)
			{
				first++;
			}
			else
			{
				const size_t token_length = token_end - token_begin;

				if (token_color == PaletteIndex::Identifier)
				{
					id.assign(token_begin, token_end);

					// todo : allmost all language definitions use lower case to specify keywords, so shouldn't this use ::tolower ?
					if (!mLanguageDefinition->mCaseSensitive)
						std::transform(id.begin(), id.end(), id.begin(), ::toupper);

					if (!line[first - bufferBegin].mPreprocessor)
					{
						if (mLanguageDefinition->mKeywords.count(id) != 0)
							token_color = PaletteIndex::Keyword;
						else if (mLanguageDefinition->mIdentifiers.count(id) != 0)
							token_color = PaletteIndex::KnownIdentifier;
						else if (mLanguageDefinition->mPreprocIdentifiers.count(id) != 0)
							token_color = PaletteIndex::PreprocIdentifier;
					}
					else
					{
						if (mLanguageDefinition->mPreprocIdentifiers.count(id) != 0)
							token_color = PaletteIndex::PreprocIdentifier;
					}
				}

				for (size_t j = 0; j < token_length; ++j)
					line[(token_begin - bufferBegin) + j].mColorIndex = token_color;

				first = token_end;
			}
		}
	}
}

void TextEditor::ColorizeInternal()
{
	if (mLines.empty() || !mColorizerEnabled || mLanguageDefinition == nullptr)
		return;

	if (mCheckComments)
	{
		auto endLine = mLines.size();
		auto endIndex = 0;
		auto commentStartLine = endLine;
		auto commentStartIndex = endIndex;
		auto withinString = false;
		auto withinSingleLineComment = false;
		auto withinPreproc = false;
		auto firstChar = true;			// there is no other non-whitespace characters in the line before
		auto concatenate = false;		// '\' on the very end of the line
		auto currentLine = 0;
		auto currentIndex = 0;
		while (currentLine < endLine || currentIndex < endIndex)
		{
			auto& line = mLines[currentLine];

			if (currentIndex == 0 && !concatenate)
			{
				withinSingleLineComment = false;
				withinPreproc = false;
				firstChar = true;
			}

			concatenate = false;

			if (!line.empty())
			{
				auto& g = line[currentIndex];
				auto c = g.mChar;

				if (c != mLanguageDefinition->mPreprocChar && !isspace(c))
					firstChar = false;

				if (currentIndex == (int)line.size() - 1 && line[line.size() - 1].mChar == '\\')
					concatenate = true;

				bool inComment = (commentStartLine < currentLine || (commentStartLine == currentLine && commentStartIndex <= currentIndex));

				if (withinString)
				{
					line[currentIndex].mMultiLineComment = inComment;

					if (c == '\"')
					{
						if (currentIndex + 1 < (int)line.size() && line[currentIndex + 1].mChar == '\"')
						{
							currentIndex += 1;
							if (currentIndex < (int)line.size())
								line[currentIndex].mMultiLineComment = inComment;
						}
						else
							withinString = false;
					}
					else if (c == '\\')
					{
						currentIndex += 1;
						if (currentIndex < (int)line.size())
							line[currentIndex].mMultiLineComment = inComment;
					}
				}
				else
				{
					if (firstChar && c == mLanguageDefinition->mPreprocChar)
						withinPreproc = true;

					if (c == '\"')
					{
						withinString = true;
						line[currentIndex].mMultiLineComment = inComment;
					}
					else
					{
						auto pred = [](const char& a, const Glyph& b) { return a == b.mChar; };
						auto from = line.begin() + currentIndex;
						auto& startStr = mLanguageDefinition->mCommentStart;
						auto& singleStartStr = mLanguageDefinition->mSingleLineComment;

						if (!withinSingleLineComment && currentIndex + startStr.size() <= line.size() &&
							equals(startStr.begin(), startStr.end(), from, from + startStr.size(), pred))
						{
							commentStartLine = currentLine;
							commentStartIndex = currentIndex;
						}
						else if (singleStartStr.size() > 0 &&
							currentIndex + singleStartStr.size() <= line.size() &&
							equals(singleStartStr.begin(), singleStartStr.end(), from, from + singleStartStr.size(), pred))
						{
							withinSingleLineComment = true;
						}

						inComment = (commentStartLine < currentLine || (commentStartLine == currentLine && commentStartIndex <= currentIndex));

						line[currentIndex].mMultiLineComment = inComment;
						line[currentIndex].mComment = withinSingleLineComment;

						auto& endStr = mLanguageDefinition->mCommentEnd;
						if (currentIndex + 1 >= (int)endStr.size() &&
							equals(endStr.begin(), endStr.end(), from + 1 - endStr.size(), from + 1, pred))
						{
							commentStartIndex = endIndex;
							commentStartLine = endLine;
						}
					}
				}
				line[currentIndex].mPreprocessor = withinPreproc;
				currentIndex += UTF8CharLength(c);
				if (currentIndex >= (int)line.size())
				{
					currentIndex = 0;
					++currentLine;
				}
			}
			else
			{
				currentIndex = 0;
				++currentLine;
			}
		}
		mCheckComments = false;
	}

	if (mColorRangeMin < mColorRangeMax)
	{
		const int increment = (mLanguageDefinition->mTokenize == nullptr) ? 10 : 10000;
		const int to = std::min(mColorRangeMin + increment, mColorRangeMax);
		ColorizeRange(mColorRangeMin, to);
		mColorRangeMin = to;

		if (mColorRangeMax == mColorRangeMin)
		{
			mColorRangeMin = std::numeric_limits<int>::max();
			mColorRangeMax = 0;
		}
		return;
	}
}

float TextEditor::TextDistanceToLineStart(const Coordinates& aFrom) const
{
	auto& line = mLines[aFrom.mLine];
	float distance = 0.0f;
	float spaceSize = ImGui::GetFont()->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, " ", nullptr, nullptr).x;
	int colIndex = GetCharacterIndex(aFrom);
	for (size_t it = 0u; it < line.size() && it < colIndex; )
	{
		if (line[it].mChar == '\t')
		{
			distance = (1.0f + std::floor((1.0f + distance) / (float(mTabSize) * spaceSize))) * (float(mTabSize) * spaceSize);
			++it;
		}
		else
		{
			auto d = UTF8CharLength(line[it].mChar);
			char tempCString[7];
			int i = 0;
			for (; i < 6 && d-- > 0 && it < (int)line.size(); i++, it++)
				tempCString[i] = line[it].mChar;

			tempCString[i] = '\0';
			distance += ImGui::GetFont()->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, tempCString, nullptr, nullptr).x;
		}
	}

	return distance;
}

void TextEditor::EnsureCursorVisible(int aCursor)
{
	if (aCursor == -1)
		aCursor = mState.mCurrentCursor;

	if (!mWithinRender)
	{
		mScrollToCursor = true;
		return;
	}

	float scrollX = ImGui::GetScrollX();
	float scrollY = ImGui::GetScrollY();

	auto height = ImGui::GetWindowHeight();
	auto width = ImGui::GetWindowWidth();

	auto top = 1 + (int)ceil(scrollY / mCharAdvance.y);
	auto bottom = (int)ceil((scrollY + height) / mCharAdvance.y);

	auto left = (int)ceil(scrollX / mCharAdvance.x);
	auto right = (int)ceil((scrollX + width) / mCharAdvance.x);

	auto pos = GetActualCursorCoordinates(aCursor);
	auto len = TextDistanceToLineStart(pos);

	if (pos.mLine < top)
		ImGui::SetScrollY(std::max(0.0f, (pos.mLine - 1) * mCharAdvance.y));
	if (pos.mLine > bottom - 4)
		ImGui::SetScrollY(std::max(0.0f, (pos.mLine + 4) * mCharAdvance.y - height));
	if (len + mTextStart < left + 4)
		ImGui::SetScrollX(std::max(0.0f, len + mTextStart - 4));
	if (len + mTextStart > right - 4)
		ImGui::SetScrollX(std::max(0.0f, len + mTextStart + 4 - width));
}

int TextEditor::GetPageSize() const
{
	auto height = ImGui::GetWindowHeight() - 20.0f;
	return (int)floor(height / mCharAdvance.y);
}

TextEditor::UndoRecord::UndoRecord(
	const std::vector<UndoOperation>& aOperations,
	TextEditor::EditorState& aBefore,
	TextEditor::EditorState& aAfter)
	: mOperations(aOperations)
	, mBefore(aBefore)
	, mAfter(aAfter)
{
	for (const UndoOperation& o : mOperations)
		assert(o.mStart <= o.mEnd);
}

void TextEditor::UndoRecord::Undo(TextEditor* aEditor)
{
	for (int i = mOperations.size() - 1; i > -1; i--)
	{
		const UndoOperation& operation = mOperations[i];
		if (!operation.mText.empty())
		{
			switch (operation.mType)
			{
			case UndoOperationType::Delete:
			{
				auto start = operation.mStart;
				aEditor->InsertTextAt(start, operation.mText.c_str());
				aEditor->Colorize(operation.mStart.mLine - 1, operation.mEnd.mLine - operation.mStart.mLine + 2);
				break;
			}
			case UndoOperationType::Add:
			{
				aEditor->DeleteRange(operation.mStart, operation.mEnd);
				aEditor->Colorize(operation.mStart.mLine - 1, operation.mEnd.mLine - operation.mStart.mLine + 2);
				break;
			}
			}
		}
	}

	aEditor->mState = mBefore;
	aEditor->EnsureCursorVisible();
}

void TextEditor::UndoRecord::Redo(TextEditor* aEditor)
{
	for (int i = 0; i < mOperations.size(); i++)
	{
		const UndoOperation& operation = mOperations[i];
		if (!operation.mText.empty())
		{
			switch (operation.mType)
			{
			case UndoOperationType::Delete:
			{
				aEditor->DeleteRange(operation.mStart, operation.mEnd);
				aEditor->Colorize(operation.mStart.mLine - 1, operation.mEnd.mLine - operation.mStart.mLine + 1);
				break;
			}
			case UndoOperationType::Add:
			{
				auto start = operation.mStart;
				aEditor->InsertTextAt(start, operation.mText.c_str());
				aEditor->Colorize(operation.mStart.mLine - 1, operation.mEnd.mLine - operation.mStart.mLine + 1);
				break;
			}
			}
		}
	}

	aEditor->mState = mAfter;
	aEditor->EnsureCursorVisible();
}
```

`hack/deps/ImGui/TextEditor.hpp`:

```hpp
#pragma once

#pragma once

#include <iostream>
#include <string>
#include <vector>
#include <array>
#include <memory>
#include <unordered_set>
#include <unordered_map>
#include <map>
#include <regex>
#include "imgui.h"

class IMGUI_API TextEditor
{
public:
	enum class PaletteIndex
	{
		Default,
		Keyword,
		Number,
		String,
		CharLiteral,
		Punctuation,
		Preprocessor,
		Identifier,
		KnownIdentifier,
		PreprocIdentifier,
		Comment,
		MultiLineComment,
		Background,
		Cursor,
		Selection,
		ErrorMarker,
		ControlCharacter,
		Breakpoint,
		LineNumber,
		CurrentLineFill,
		CurrentLineFillInactive,
		CurrentLineEdge,
		Max
	};

	enum class SelectionMode
	{
		Normal,
		Word,
		Line
	};

	struct Breakpoint
	{
		int mLine;
		bool mEnabled;
		std::string mCondition;

		Breakpoint()
			: mLine(-1)
			, mEnabled(false)
		{}
	};

	// Represents a character coordinate from the user's point of view,
	// i. e. consider an uniform grid (assuming fixed-width font) on the
	// screen as it is rendered, and each cell has its own coordinate, starting from 0.
	// Tabs are counted as [1..mTabSize] count empty spaces, depending on
	// how many space is necessary to reach the next tab stop.
	// For example, coordinate (1, 5) represents the character 'B' in a line "\tABC", when mTabSize = 4,
	// because it is rendered as "    ABC" on the screen.
	struct Coordinates
	{
		int mLine, mColumn;
		Coordinates() : mLine(0), mColumn(0) {}
		Coordinates(int aLine, int aColumn) : mLine(aLine), mColumn(aColumn)
		{
			assert(aLine >= 0);
			assert(aColumn >= 0);
		}
		static Coordinates Invalid() { static Coordinates invalid(-1, -1); return invalid; }

		bool operator ==(const Coordinates& o) const
		{
			return
				mLine == o.mLine &&
				mColumn == o.mColumn;
		}

		bool operator !=(const Coordinates& o) const
		{
			return
				mLine != o.mLine ||
				mColumn != o.mColumn;
		}

		bool operator <(const Coordinates& o) const
		{
			if (mLine != o.mLine)
				return mLine < o.mLine;
			return mColumn < o.mColumn;
		}

		bool operator >(const Coordinates& o) const
		{
			if (mLine != o.mLine)
				return mLine > o.mLine;
			return mColumn > o.mColumn;
		}

		bool operator <=(const Coordinates& o) const
		{
			if (mLine != o.mLine)
				return mLine < o.mLine;
			return mColumn <= o.mColumn;
		}

		bool operator >=(const Coordinates& o) const
		{
			if (mLine != o.mLine)
				return mLine > o.mLine;
			return mColumn >= o.mColumn;
		}

		Coordinates operator -(const Coordinates& o)
		{
			return Coordinates(mLine - o.mLine, mColumn - o.mColumn);
		}
	};

	struct Identifier
	{
		Coordinates mLocation;
		std::string mDeclaration;
	};

	typedef std::string String;
	typedef std::unordered_map<std::string, Identifier> Identifiers;
	typedef std::unordered_set<std::string> Keywords;
	typedef std::map<int, std::string> ErrorMarkers;
	typedef std::unordered_set<int> Breakpoints;
	typedef std::array<ImU32, (unsigned)PaletteIndex::Max> Palette;
	typedef uint8_t Char;

	struct Glyph
	{
		Char mChar;
		PaletteIndex mColorIndex = PaletteIndex::Default;
		bool mComment : 1;
		bool mMultiLineComment : 1;
		bool mPreprocessor : 1;

		Glyph(Char aChar, PaletteIndex aColorIndex) : mChar(aChar), mColorIndex(aColorIndex),
			mComment(false), mMultiLineComment(false), mPreprocessor(false) {}
	};

	typedef std::vector<Glyph> Line;
	typedef std::vector<Line> Lines;

	struct LanguageDefinition
	{
		typedef std::pair<std::string, PaletteIndex> TokenRegexString;
		typedef std::vector<TokenRegexString> TokenRegexStrings;
		typedef bool(*TokenizeCallback)(const char* in_begin, const char* in_end, const char*& out_begin, const char*& out_end, PaletteIndex& paletteIndex);

		std::string mName;
		Keywords mKeywords;
		Identifiers mIdentifiers;
		Identifiers mPreprocIdentifiers;
		std::string mCommentStart, mCommentEnd, mSingleLineComment;
		char mPreprocChar;
		bool mAutoIndentation;

		TokenizeCallback mTokenize;

		TokenRegexStrings mTokenRegexStrings;

		bool mCaseSensitive;

		LanguageDefinition()
			: mPreprocChar('#'), mAutoIndentation(true), mTokenize(nullptr), mCaseSensitive(true)
		{
		}

		static const LanguageDefinition& CPlusPlus();
		static const LanguageDefinition& HLSL();
		static const LanguageDefinition& GLSL();
		static const LanguageDefinition& Python();
		static const LanguageDefinition& C();
		static const LanguageDefinition& SQL();
		static const LanguageDefinition& AngelScript();
		static const LanguageDefinition& Lua();
	};

	enum class UndoOperationType { Add, Delete };
	struct UndoOperation
	{
		std::string mText;
		TextEditor::Coordinates mStart;
		TextEditor::Coordinates mEnd;
		UndoOperationType mType;
	};

	TextEditor();
	~TextEditor();

	void SetLanguageDefinition(const LanguageDefinition& aLanguageDef);
	const char* GetLanguageDefinitionName() const;

	const Palette& GetPalette() const { return mPaletteBase; }
	void SetPalette(const Palette& aValue);

	void SetErrorMarkers(const ErrorMarkers& aMarkers) { mErrorMarkers = aMarkers; }
	void SetBreakpoints(const Breakpoints& aMarkers) { mBreakpoints = aMarkers; }

	void Render(const char* aTitle, bool aParentIsFocused = false, const ImVec2& aSize = ImVec2(), bool aBorder = false);
	void SetText(const std::string& aText);
	std::string GetText() const;

	void SetTextLines(const std::vector<std::string>& aLines);
	std::vector<std::string> GetTextLines() const;

	std::string GetClipboardText() const;
	std::string GetSelectedText(int aCursor = -1) const;
	std::string GetCurrentLineText()const;

	int GetTotalLines() const { return (int)mLines.size(); }
	bool IsOverwrite() const { return mOverwrite; }

	void SetReadOnly(bool aValue);
	bool IsReadOnly() const { return mReadOnly; }
	bool IsTextChanged() const { return mTextChanged; }

	void OnCursorPositionChanged(int aCursor);

	bool IsColorizerEnabled() const { return mColorizerEnabled; }
	void SetColorizerEnable(bool aValue);

	Coordinates GetCursorPosition() const { return GetActualCursorCoordinates(); }
	void SetCursorPosition(const Coordinates& aPosition, int aCursor = -1);

	inline void OnLineDeleted(int aLineIndex, const std::unordered_set<int>* aHandledCursors = nullptr)
	{
		for (int c = 0; c <= mState.mCurrentCursor; c++)
		{
			if (mState.mCursors[c].mCursorPosition.mLine >= aLineIndex)
			{
				if (aHandledCursors == nullptr || aHandledCursors->find(c) == aHandledCursors->end()) // move up if has not been handled already
					SetCursorPosition({ mState.mCursors[c].mCursorPosition.mLine - 1, mState.mCursors[c].mCursorPosition.mColumn }, c);
			}
		}
	}
	inline void OnLinesDeleted(int aFirstLineIndex, int aLastLineIndex)
	{
		for (int c = 0; c <= mState.mCurrentCursor; c++)
		{
			if (mState.mCursors[c].mCursorPosition.mLine >= aFirstLineIndex)
				SetCursorPosition({ mState.mCursors[c].mCursorPosition.mLine - (aLastLineIndex - aFirstLineIndex), mState.mCursors[c].mCursorPosition.mColumn }, c);
		}
	}
	inline void OnLineAdded(int aLineIndex)
	{
		for (int c = 0; c <= mState.mCurrentCursor; c++)
		{
			if (mState.mCursors[c].mCursorPosition.mLine >= aLineIndex)
				SetCursorPosition({ mState.mCursors[c].mCursorPosition.mLine + 1, mState.mCursors[c].mCursorPosition.mColumn }, c);
		}
	}

	inline void SetHandleMouseInputs(bool aValue) { mHandleMouseInputs = aValue; }
	inline bool IsHandleMouseInputsEnabled() const { return mHandleMouseInputs; }

	inline void SetHandleKeyboardInputs(bool aValue) { mHandleKeyboardInputs = aValue; }
	inline bool IsHandleKeyboardInputsEnabled() const { return mHandleKeyboardInputs; }

	inline void SetImGuiChildIgnored(bool aValue) { mIgnoreImGuiChild = aValue; }
	inline bool IsImGuiChildIgnored() const { return mIgnoreImGuiChild; }

	inline void SetShowWhitespaces(bool aValue) { mShowWhitespaces = aValue; }
	inline bool IsShowingWhitespaces() const { return mShowWhitespaces; }

	inline void SetShowShortTabGlyphs(bool aValue) { mShowShortTabGlyphs = aValue; }
	inline bool IsShowingShortTabGlyphs() const { return mShowShortTabGlyphs; }

	inline ImVec4 U32ColorToVec4(ImU32 in) {
		float s = 1.0f / 255.0f;
		return ImVec4(
			((in >> IM_COL32_A_SHIFT) & 0xFF) * s,
			((in >> IM_COL32_B_SHIFT) & 0xFF) * s,
			((in >> IM_COL32_G_SHIFT) & 0xFF) * s,
			((in >> IM_COL32_R_SHIFT) & 0xFF) * s);
	}

	void SetTabSize(int aValue);
	inline int GetTabSize() const { return mTabSize; }

	void InsertText(const std::string& aValue, int aCursor = -1);
	void InsertText(const char* aValue, int aCursor = -1);

	void MoveUp(int aAmount = 1, bool aSelect = false);
	void MoveDown(int aAmount = 1, bool aSelect = false);
	void MoveLeft(int aAmount = 1, bool aSelect = false, bool aWordMode = false);
	void MoveRight(int aAmount = 1, bool aSelect = false, bool aWordMode = false);
	void MoveTop(bool aSelect = false);
	void MoveBottom(bool aSelect = false);
	void MoveHome(bool aSelect = false);
	void MoveEnd(bool aSelect = false);

	void SetSelectionStart(const Coordinates& aPosition, int aCursor = -1);
	void SetSelectionEnd(const Coordinates& aPosition, int aCursor = -1);
	void SetSelection(const Coordinates& aStart, const Coordinates& aEnd, SelectionMode aMode = SelectionMode::Normal, int aCursor = -1, bool isSpawningNewCursor = false);
	void SelectWordUnderCursor();
	void SelectAll();
	bool HasSelection() const;

	void Copy();
	void Cut();
	void Paste();
	void Delete(bool aWordMode = false);

	bool CanUndo() const;
	bool CanRedo() const;
	void Undo(int aSteps = 1);
	void Redo(int aSteps = 1);

	static const Palette& GetMarianaPalette();
	static const Palette& GetDarkPalette();
	static const Palette& GetLightPalette();
	static const Palette& GetRetroBluePalette();

	static bool IsGlyphWordChar(const Glyph& aGlyph);

	void ImGuiDebugPanel(const std::string& panelName = "Debug");
	void UnitTests();
private:
	typedef std::vector<std::pair<std::regex, PaletteIndex>> RegexList;

	struct Cursor
	{
		Coordinates mCursorPosition = { 0, 0 };
		Coordinates mSelectionStart = { 0,0 };
		Coordinates mSelectionEnd = { 0,0 };
		Coordinates mInteractiveStart = { 0,0 };
		Coordinates mInteractiveEnd = { 0,0 };
		bool mCursorPositionChanged = false;
	};

	struct EditorState
	{
		int mCurrentCursor = 0;
		std::vector<Cursor> mCursors = { {{0,0}} };
		void AddCursor()
		{
			mCurrentCursor++;
			mCursors.resize(mCurrentCursor + 1);
		}
	};

	void MergeCursorsIfPossible();

	class UndoRecord
	{
	public:
		UndoRecord() {}
		~UndoRecord() {}

		UndoRecord(
			const std::vector<UndoOperation>& aOperations,
			TextEditor::EditorState& aBefore,
			TextEditor::EditorState& aAfter);

		void Undo(TextEditor* aEditor);
		void Redo(TextEditor* aEditor);

		std::vector<UndoOperation> mOperations;

		EditorState mBefore;
		EditorState mAfter;
	};

	typedef std::vector<UndoRecord> UndoBuffer;

	void ProcessInputs();
	void Colorize(int aFromLine = 0, int aCount = -1);
	void ColorizeRange(int aFromLine = 0, int aToLine = 0);
	void ColorizeInternal();
	float TextDistanceToLineStart(const Coordinates& aFrom) const;
	void EnsureCursorVisible(int aCursor = -1);
	int GetPageSize() const;
	std::string GetText(const Coordinates& aStart, const Coordinates& aEnd) const;
	Coordinates GetActualCursorCoordinates(int aCursor = -1) const;
	Coordinates SanitizeCoordinates(const Coordinates& aValue) const;
	void Advance(Coordinates& aCoordinates) const;
	void DeleteRange(const Coordinates& aStart, const Coordinates& aEnd);
	int InsertTextAt(Coordinates& aWhere, const char* aValue);
	void AddUndo(UndoRecord& aValue);
	Coordinates ScreenPosToCoordinates(const ImVec2& aPosition, bool aInsertionMode = false, bool* isOverLineNumber = nullptr) const;
	Coordinates FindWordStart(const Coordinates& aFrom) const;
	Coordinates FindWordEnd(const Coordinates& aFrom) const;
	Coordinates FindNextWord(const Coordinates& aFrom) const;
	int GetCharacterIndexLeftSide(const Coordinates& aCoordinates) const;
	int GetCharacterIndex(const Coordinates& aCoordinates) const;
	int GetCharacterColumn(int aLine, int aIndex) const;
	int GetLineCharacterCount(int aLine) const;
	int GetLineMaxColumn(int aLine) const;
	bool IsOnWordBoundary(const Coordinates& aAt) const;
	void RemoveLines(int aStart, int aEnd);
	void RemoveLine(int aIndex, const std::unordered_set<int>* aHandledCursors = nullptr);
	void RemoveCurrentLines();
	void OnLineChanged(bool aBeforeChange, int aLine, int aColumn, int aCharCount, bool aDeleted);
	void RemoveGlyphsFromLine(int aLine, int aStartChar, int aEndChar = -1);
	void AddGlyphsToLine(int aLine, int aTargetIndex, Line::iterator aSourceStart, Line::iterator aSourceEnd);
	void AddGlyphToLine(int aLine, int aTargetIndex, Glyph aGlyph);
	Line& InsertLine(int aIndex);
	void ChangeCurrentLinesIndentation(bool aIncrease);
	void EnterCharacter(ImWchar aChar, bool aShift);
	void Backspace(bool aWordMode = false);
	void DeleteSelection(int aCursor = -1);
	std::string GetWordUnderCursor() const;
	std::string GetWordAt(const Coordinates& aCoords) const;
	ImU32 GetGlyphColor(const Glyph& aGlyph) const;

	void HandleKeyboardInputs(bool aParentIsFocused = false);
	void HandleMouseInputs();
	void UpdatePalette();
	void Render(bool aParentIsFocused = false);

	float mLineSpacing;
	Lines mLines;
	EditorState mState;
	UndoBuffer mUndoBuffer;
	int mUndoIndex;

	int mTabSize;
	bool mOverwrite;
	bool mReadOnly;
	bool mWithinRender;
	bool mScrollToCursor;
	bool mScrollToTop;
	bool mTextChanged;
	bool mColorizerEnabled;
	float mTextStart;                   // position (in pixels) where a code line starts relative to the left of the TextEditor.
	int  mLeftMargin;
	int mColorRangeMin, mColorRangeMax;
	SelectionMode mSelectionMode;
	bool mHandleKeyboardInputs;
	bool mHandleMouseInputs;
	bool mIgnoreImGuiChild;
	bool mShowWhitespaces;
	bool mShowShortTabGlyphs;
	bool mDraggingSelection = false;

	Palette mPaletteBase;
	Palette mPalette;
	const LanguageDefinition* mLanguageDefinition = nullptr;
	RegexList mRegexList;

	bool mCheckComments;
	Breakpoints mBreakpoints;
	ErrorMarkers mErrorMarkers;
	ImVec2 mCharAdvance;
	std::string mLineBuffer;
	uint64_t mStartTime;

	float mLastClick;
};
```

`hack/deps/ImGui/extraDraw.cpp`:

```cpp
#include <deps/ImGui/extraDraw.hpp>

#include <imgui_internal.h>

static inline ImDrawFlags FixRectCornerFlags(ImDrawFlags flags)
{
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    // Obsoleted in 1.82 (from February 2021)
    // Legacy Support for hard coded ~0 (used to be a suggested equivalent to ImDrawCornerFlags_All)
    //   ~0   --> ImDrawFlags_RoundCornersAll or 0
    if (flags == ~0)
        return ImDrawFlags_RoundCornersAll;

    // Legacy Support for hard coded 0x01 to 0x0F (matching 15 out of 16 old flags combinations)
    //   0x01 --> ImDrawFlags_RoundCornersTopLeft (VALUE 0x01 OVERLAPS ImDrawFlags_Closed but ImDrawFlags_Closed is never valid in this path!)
    //   0x02 --> ImDrawFlags_RoundCornersTopRight
    //   0x03 --> ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersTopRight
    //   0x04 --> ImDrawFlags_RoundCornersBotLeft
    //   0x05 --> ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersBotLeft
    //   ...
    //   0x0F --> ImDrawFlags_RoundCornersAll or 0
    // (See all values in ImDrawCornerFlags_)
    if (flags >= 0x01 && flags <= 0x0F)
        return (flags << 4);

    // We cannot support hard coded 0x00 with 'float rounding > 0.0f' --> replace with ImDrawFlags_RoundCornersNone or use 'float rounding = 0.0f'
#endif

    // If this triggers, please update your code replacing hardcoded values with new ImDrawFlags_RoundCorners* values.
    // Note that ImDrawFlags_Closed (== 0x01) is an invalid flag for AddRect(), AddRectFilled(), PathRect() etc...
    IM_ASSERT((flags & 0x0F) == 0 && "Misuse of legacy hardcoded ImDrawCornerFlags values!");

    if ((flags & ImDrawFlags_RoundCornersMask_) == 0)
        flags |= ImDrawFlags_RoundCornersAll;

    return flags;
}

void ImGui::ExtraDrawlist::AddRectFilledMultiColor(ImDrawList* draw_list, const ImVec2& p_min, const ImVec2& p_max, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left, float rounding, ImDrawFlags flags)
{
    if (((col_upr_left | col_upr_right | col_bot_right | col_bot_left) & IM_COL32_A_MASK) == 0)
        return;

    flags = FixRectCornerFlags(flags);
    rounding = ImMin(rounding, ImFabs(p_max.x - p_min.x) * (((flags & ImDrawCornerFlags_Top) == ImDrawCornerFlags_Top) || ((flags & ImDrawCornerFlags_Bot) == ImDrawCornerFlags_Bot) ? 0.5f : 1.0f) - 1.0f);
    rounding = ImMin(rounding, ImFabs(p_max.y - p_min.y) * (((flags & ImDrawCornerFlags_Left) == ImDrawCornerFlags_Left) || ((flags & ImDrawCornerFlags_Right) == ImDrawCornerFlags_Right) ? 0.5f : 1.0f) - 1.0f);

    // https://github.com/ocornut/imgui/issues/3710#issuecomment-758555966
    if (rounding > 0.0f)
    {
        const int size_before = draw_list->VtxBuffer.Size;
        draw_list->AddRectFilled(p_min, p_max, IM_COL32_WHITE, rounding, flags);
        const int size_after = draw_list->VtxBuffer.Size;

        for (int i = size_before; i < size_after; i++)
        {
            ImDrawVert* vert = draw_list->VtxBuffer.Data + i;

            ImVec4 upr_left = ImGui::ColorConvertU32ToFloat4(col_upr_left);
            ImVec4 bot_left = ImGui::ColorConvertU32ToFloat4(col_bot_left);
            ImVec4 up_right = ImGui::ColorConvertU32ToFloat4(col_upr_right);
            ImVec4 bot_right = ImGui::ColorConvertU32ToFloat4(col_bot_right);

            float X = ImClamp((vert->pos.x - p_min.x) / (p_max.x - p_min.x), 0.0f, 1.0f);

            // 4 colors - 8 deltas

            float r1 = upr_left.x + (up_right.x - upr_left.x) * X;
            float r2 = bot_left.x + (bot_right.x - bot_left.x) * X;

            float g1 = upr_left.y + (up_right.y - upr_left.y) * X;
            float g2 = bot_left.y + (bot_right.y - bot_left.y) * X;

            float b1 = upr_left.z + (up_right.z - upr_left.z) * X;
            float b2 = bot_left.z + (bot_right.z - bot_left.z) * X;

            float a1 = upr_left.w + (up_right.w - upr_left.w) * X;
            float a2 = bot_left.w + (bot_right.w - bot_left.w) * X;


            float Y = ImClamp((vert->pos.y - p_min.y) / (p_max.y - p_min.y), 0.0f, 1.0f);
            float r = r1 + (r2 - r1) * Y;
            float g = g1 + (g2 - g1) * Y;
            float b = b1 + (b2 - b1) * Y;
            float a = a1 + (a2 - a1) * Y;
            ImVec4 RGBA(r, g, b, a);

            RGBA = RGBA * ImGui::ColorConvertU32ToFloat4(vert->col);

            vert->col = ImColor(RGBA);
        }
        return;
    }

    const ImVec2 uv = draw_list->_Data->TexUvWhitePixel;
    draw_list->PrimReserve(6, 4);
    draw_list->PrimWriteIdx((ImDrawIdx)(draw_list->_VtxCurrentIdx)); 
    draw_list->PrimWriteIdx((ImDrawIdx)(draw_list->_VtxCurrentIdx + 1));
    draw_list->PrimWriteIdx((ImDrawIdx)(draw_list->_VtxCurrentIdx + 2));
    draw_list->PrimWriteIdx((ImDrawIdx)(draw_list->_VtxCurrentIdx));
    draw_list->PrimWriteIdx((ImDrawIdx)(draw_list->_VtxCurrentIdx + 2));
    draw_list->PrimWriteIdx((ImDrawIdx)(draw_list->_VtxCurrentIdx + 3));
    draw_list->PrimWriteVtx(p_min, uv, col_upr_left);
    draw_list->PrimWriteVtx(ImVec2(p_max.x, p_min.y), uv, col_upr_right);
    draw_list->PrimWriteVtx(p_max, uv, col_bot_right);
    draw_list->PrimWriteVtx(ImVec2(p_min.x, p_max.y), uv, col_bot_left);
}

void ImGui::ExtraDrawlist::AddConvexPolyFilledMultiColor(ImDrawList* draw_list, const ImVec2* points, const ImU32* col, const int points_count)
{
    const ImVec2 uv = draw_list->_Data->TexUvWhitePixel;

    if (draw_list->Flags & ImDrawListFlags_AntiAliasedFill)
    {
        // Anti-aliased Fill
        const float AA_SIZE = 1.0f;
        const int idx_count = (points_count - 2) * 3 + points_count * 6;
        const int vtx_count = (points_count * 2);
        draw_list->PrimReserve(idx_count, vtx_count);

        // Add indexes for fill
        unsigned int vtx_inner_idx = draw_list->_VtxCurrentIdx;
        unsigned int vtx_outer_idx = draw_list->_VtxCurrentIdx + 1;
        for (int i = 2; i < points_count; i++)
        {
            draw_list->_IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx);
            draw_list->_IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + ((i - 1) << 1));
            draw_list->_IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx + (i << 1));
            draw_list->_IdxWritePtr += 3;
        }

        // Compute normals
        ImVec2* temp_normals = (ImVec2*)alloca(points_count * sizeof(ImVec2)); //-V630
        for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)
        {
            const ImVec2& p0 = points[i0];
            const ImVec2& p1 = points[i1];
            ImVec2 diff = p1 - p0;
            diff *= ImInvLength(diff, 1.0f);
            temp_normals[i0].x = diff.y;
            temp_normals[i0].y = -diff.x;
        }

        for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)
        {
            // Average normals
            const ImVec2& n0 = temp_normals[i0];
            const ImVec2& n1 = temp_normals[i1];
            ImVec2 dm = (n0 + n1) * 0.5f;
            float dmr2 = dm.x * dm.x + dm.y * dm.y;
            if (dmr2 > 0.000001f)
            {
                float scale = 1.0f / dmr2;
                if (scale > 100.0f) scale = 100.0f;
                dm *= scale;
            }
            dm *= AA_SIZE * 0.5f;

            // Add vertices
            draw_list->_VtxWritePtr[0].pos = (points[i1] - dm);
            draw_list->_VtxWritePtr[0].uv = uv;
            draw_list->_VtxWritePtr[0].col = col[i1];        // Inner
            draw_list->_VtxWritePtr[1].pos = (points[i1] + dm);
            draw_list->_VtxWritePtr[1].uv = uv;
            draw_list->_VtxWritePtr[1].col = col[i1] & ~IM_COL32_A_MASK;  // Outer
            draw_list->_VtxWritePtr += 2;

            // Add indexes for fringes
            draw_list->_IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));
            draw_list->_IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (i0 << 1));
            draw_list->_IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));
            draw_list->_IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));
            draw_list->_IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx + (i1 << 1)); 
            draw_list->_IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));
            draw_list->_IdxWritePtr += 6;
        }
        draw_list->_VtxCurrentIdx += (ImDrawIdx)vtx_count;
    }
    else
    {
        // Non Anti-aliased Fill
        const int idx_count = (points_count - 2) * 3;
        const int vtx_count = points_count;
        draw_list->PrimReserve(idx_count, vtx_count);
        for (int i = 0; i < vtx_count; i++)
        {
            draw_list->_VtxWritePtr[0].pos = points[i];
            draw_list->_VtxWritePtr[0].uv = uv;
            draw_list->_VtxWritePtr[0].col = col[i];
            draw_list->_VtxWritePtr++;
        }
        for (int i = 2; i < points_count; i++)
        {
            draw_list->_IdxWritePtr[0] = (ImDrawIdx)(draw_list->_VtxCurrentIdx);
            draw_list->_IdxWritePtr[1] = (ImDrawIdx)(draw_list->_VtxCurrentIdx + i - 1);
            draw_list->_IdxWritePtr[2] = (ImDrawIdx)(draw_list->_VtxCurrentIdx + i);
            draw_list->_IdxWritePtr += 3;
        }
        draw_list->_VtxCurrentIdx += (ImDrawIdx)vtx_count;
    }
}
```

`hack/deps/ImGui/extraDraw.hpp`:

```hpp
#pragma once

#include <imgui.h>

namespace ImGui
{
	namespace ExtraDrawlist
	{
		void AddRectFilledMultiColor(ImDrawList* draw_list, const ImVec2& p_min, const ImVec2& p_max,
			ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left, float rounding, ImDrawFlags flags = 0);
		void AddConvexPolyFilledMultiColor(ImDrawList* draw_list, const ImVec2* points, const ImU32* col, const int points_count);
	}
}
```

`hack/deps/README.md`:

```md
Additional stuff for dependencies, contain extra functionalities.
```

`hack/deps/magic_enum/prettyNames.hpp`:

```hpp
#pragma once

#include <magic_enum.hpp>

// Returns a copy of enum_names() as std::array<std::string, SIZE> with "pretty name"
   // pretty name means:
   // MY_NAME -> My name
   // OKAYLONG -> Okaylong
namespace magic_enum {
    template <typename E>
    [[nodiscard]] constexpr auto enum_names_pretty() noexcept {
        constexpr auto ctoLower = [](char c) noexcept {
            return (c >= 'A' && c <= 'Z') ? static_cast<char>(c + ('a' - 'A')) : c;
        };

        constexpr auto view_arr = detail::names_v<std::decay_t<E>>;
        std::array<std::string, view_arr.size()> pretty;

        for (size_t i = 0; i < view_arr.size(); i++) {
            std::string name{ view_arr[i].data(), view_arr[i].length() };
            for (size_t sign = 1; sign < name.length(); sign++) {
                name[sign] = ctoLower(name[sign]);

                if (name[sign] == '_')
                    name[sign] = ' ';
            }
            pretty[i] = name;
        }

        return pretty;
    }
}
```

`hack/gamememory/memory.cpp`:

```cpp
#include "memory.hpp"

#include "sigs.hpp"
#include "modules.hpp"
#include "pattern.hpp"

#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <utilities/console/console.hpp>
#include <SDK/math/matrix.hpp>
#include <SDK/CTeslaInfo.hpp>
#include <SDK/CEffectData.hpp>
#include <SDK/IPrediction.hpp>
#include <SDK/CGameRules.hpp>
#include <SDK/Input.hpp>
#include <SDK/IViewRenderBeams.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <cheats/game/game.hpp>

#include <sstream>
#include <algorithm>
#include <optional>
#include <ranges>

template<typename T>
Memory::Address<T> Memory::Address<T>::scan(const std::string_view mod, const std::string_view sig, uintptr_t offset)
{
	const auto _module = g_Memory.getModule(mod);
	const auto dosHeader = reinterpret_cast<PIMAGE_DOS_HEADER>(_module);
	const auto ntHeaders = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<uint8_t*>(_module) + dosHeader->e_lfanew);
	const auto sizeOfImage = ntHeaders->OptionalHeader.SizeOfImage;
	const auto rangeStart = reinterpret_cast<uintptr_t>(_module);

	// tried boyer_moore_horspool_searcher, it would need some big edits to work
	/*const auto converted = SigConvert<std::byte>::get(sig);
	const auto searched = std::ranges::search(reinterpret_cast<std::byte*>(_module), reinterpret_cast<std::byte*>(_module) + sizeOfImage, converted.begin(), converted.end());


	if (std::ranges::begin(searched) != reinterpret_cast<std::byte*>(_module) + sizeOfImage)
	{
		m_addr = reinterpret_cast<uintptr_t>(std::ranges::begin(searched)) + offset;
		m_module = mod;
		return *this;
	}
	
	throw std::runtime_error{ FORMAT(XOR("Can't find following sig: {}(0x{}) in module: {}"), sig, offset, mod) };*/

	auto check = [](std::byte* data, const std::vector<std::optional<std::byte>>& _mask)
	{
		for (const auto& _byte : _mask)
		{
			if (_byte && _byte.value() != *data)
				return false;
			data++;
		}
		return true;
	};

	const auto converted = SigConvert<std::byte>::get(sig);

	for (auto i : std::views::iota(reinterpret_cast<size_t>(_module), static_cast<size_t>(sizeOfImage + reinterpret_cast<size_t>(_module))))
	{
		if (check(reinterpret_cast<std::byte*>(i), converted))
		{
			m_addr = i + offset;
			break;
		}
	}

	assert(m_addr);
	m_module = mod;
	return Address<T>{ m_addr };
}

template<typename T>
template<li::detail::offset_hash_pair hash>
Memory::Address<T> Memory::Address<T>::byExport(const std::string_view _module)
{
	EXPORT(m_addr, hash, _module);

	return Address<T>{ m_addr };
}

template<typename T>
template<typename TT>
Memory::Address<T> Memory::Address<T>::byVFunc(const Interface<TT>& ifc, size_t index)
{
	m_addr = reinterpret_cast<uintptr_t>(vfunc::getVFunc(reinterpret_cast<void*>(ifc.base), index));

	return Address<T>{ m_addr };
}

#include <SDK/IBaseClientDll.hpp>
#include <SDK/ClientClass.hpp>

template<typename T>
Memory::Address<T> Memory::Address<T>::findFromGame(ClassID id)
{
	for (auto _class = memory::interfaces::client->getAllClasses(); _class; _class = _class->m_next)
	{
		if (_class->m_classID == id)
			return Address<T>{ _class };
	}

	return Address<T>{ 0U };
}

#include <SDK/IVEngineClient.hpp>

template<typename T>
Memory::Address<T> Memory::Address<T>::findFromGameLoop(ClassID id)
{
	for (auto i : std::views::iota(memory::interfaces::engine->getMaxClients(), memory::interfaces::entList->getHighestIndex() + 1))
	{
		auto entity = reinterpret_cast<Entity_t*>(memory::interfaces::entList->getClientEntity(i));
		if (!entity)
			continue;

		auto idx = entity->clientClass()->m_classID;
		if (idx == id)
			return Address<T>{ entity };
	}

	return Address<T>{ 0U };
}

//#include <deps/fixed.hpp>

void Memory::init()
{
#define ADD_TO_MAP(name) \
	m_ModulesAddr[name] =  reinterpret_cast<HMODULE>(LI_MODULE(name).cached()); \

	ADD_TO_MAP("engine.dll");
	ADD_TO_MAP("client.dll");
	ADD_TO_MAP("vstdlib.dll");
	ADD_TO_MAP("vgui2.dll");
	ADD_TO_MAP("vguimatsurface.dll");
	ADD_TO_MAP("materialsystem.dll");
	ADD_TO_MAP("localize.dll");
	ADD_TO_MAP("studiorender.dll");
	ADD_TO_MAP("inputsystem.dll");
	ADD_TO_MAP("shaderapidx9.dll");
	ADD_TO_MAP("tier0.dll");
	ADD_TO_MAP("panorama.dll");
	ADD_TO_MAP("filesystem_stdio.dll");
	ADD_TO_MAP("datacache.dll");
	ADD_TO_MAP("server.dll");

#undef ADD_TO_MAP

	using namespace memory;
	using namespace memory::interfaces;

	traceFilterSimple = traceFilterSimple.scan(CLIENT_DLL, CTRACE_FILTER_SIMPLE, 0x3D);
	returnAddrRadarImage = returnAddrRadarImage.scan(PANORAMA_DLL, UNK_FILESYS);
	viewMatrixAddr = viewMatrixAddr.scan(CLIENT_DLL, VIEW_MATRIX_CLIENT, 0x3).deRef().add(0xB0);
	drawSpacedRectangle = drawSpacedRectangle.scan(CLIENT_DLL, DRAW_SPACE_RECTANGLE_CALL);
	motionBlurVec = motionBlurVec.scan(CLIENT_DLL, BLUR_MATERIAL_ARR_1, 0x1).deRef();
	disableTargetAlloc = disableTargetAlloc.scan(MATERIAL_DLL, DISABLE_RENDER_TARGET_ALLOC, 0x2);
	throughSmoke = throughSmoke.scan(CLIENT_DLL, GOES_THROUGH_SMOKE);
	smokeCount = throughSmoke.add(0x8).deRef().cast<uintptr_t>();
	loadSky = loadSky.scan(ENGINE_DLL, LOAD_SKY);
	callbacksHead = callbacksHead.scan(CLIENT_DLL, HEAD_OF_EFFECTS, 0x2).deRef(Dereference::TWICE);
	camThink = camThink.scan(CLIENT_DLL, CAM_THINK);
	renderDrawPoints = renderDrawPoints.scan(STUDIORENDER_DLL, R_STUDIODRAWPOINTS);
	localPlayer = localPlayer.scan(CLIENT_DLL, LOCAL_PLAYER, 0x2).deRef();
	csgoHud = csgoHud.scan(CLIENT_DLL, CSGO_HUD, 0x1).deRef();
	hudfindElement = hudfindElement.scan(CLIENT_DLL, FIND_ELEMENT);
	keyValuesFromString = keyValuesFromString.scan(CLIENT_DLL, KEY_VALUES_FROM_STR);
	animOverlays = animOverlays.scan(CLIENT_DLL, ANIMATION_LAYER, 0x2).deRef();
	sequenceActivity = sequenceActivity.scan(CLIENT_DLL, SEQUENCE_ACTIVITY);
	cachedBones = cachedBones.scan(CLIENT_DLL, CACHED_BONE, 0x2).deRef().add(0x4);
	setAbsOrigin = setAbsOrigin.scan(CLIENT_DLL, SETABSORIGIN);
	isC4Owner = isC4Owner.scan(CLIENT_DLL, HASC4);
	isBreakable = isBreakable.scan(CLIENT_DLL, IS_BREAKBLE);
	predictionData = predictionData.scan(CLIENT_DLL, PREDICTION_MOVE_DATA, 0x1).deRef(Dereference::TWICE);
	predictionSeed = predictionSeed.scan(CLIENT_DLL, PREDICTIONRANDOMSEED, 0x2).deRef();
	flashlightCreate = flashlightCreate.scan(CLIENT_DLL, FLASHLIGHT_CREATE);
	flashlightUpdate = flashlightUpdate.scan(CLIENT_DLL, FLASHLIGHT_UPDATE);
	flashlightDestroy = flashlightDestroy.scan(CLIENT_DLL, FLASHLIGHT_DESTROY);
	occlusion = occlusion.scan(CLIENT_DLL, SETUP_OCCLUSION);
	velocity = velocity.scan(CLIENT_DLL, SETUP_VELOCITY);
	accumulate = accumulate.scan(CLIENT_DLL, SETUP_VELOCITY);
	particleIsCached = particleIsCached.scan(CLIENT_DLL, IS_EFFECT_CACHED);
	particleSystem = particleSystem.scan(CLIENT_DLL, PARTICLE_SYSTEM, 0x7).deRef(Dereference::TWICE);
	particleFindStringIndex = particleFindStringIndex.scan(CLIENT_DLL, FIND_STRING_INDEX);
	particleCall = particleCall.scan(CLIENT_DLL, PARTICLE_CALL);
	particleSetControlPoint = particleSetControlPoint.scan(CLIENT_DLL, SET_PARTICLE_POINT);
	predictedPlayer = predictedPlayer.scan(CLIENT_DLL, PREDICTED_PLAYER).add(0x2).deRef();
	physicsRunThink = physicsRunThink.scan(CLIENT_DLL, PHYSICS_RUN_THINK);
	lastCommand = lastCommand.scan(CLIENT_DLL, LAST_COMMAND).add(0x2).deRef();
	retAddrToInterpolation = retAddrToInterpolation.scan(CLIENT_DLL, RET_ADDR_INTERPOLATION);
	postThinkPhysics = postThinkPhysics.scan(CLIENT_DLL, POST_THINK_PHYSICS);
	simulateEntities = simulateEntities.scan(CLIENT_DLL, SIMULATE_ENTITIES);
	vecClientImpacts = vecClientImpacts.scan(CLIENT_DLL, VEC_CLIENT_IPACT_LIST).add(0x2).deRef();
	loadFromBuffer = loadFromBuffer.scan(CLIENT_DLL, LOAD_FROM_BUFFER);
	keyValuesConstruct = keyValuesConstruct.scan(CLIENT_DLL, KEYVALUES_CONSTRUCT);
	keyValuesDestruct = keyValuesDestruct.scan(CLIENT_DLL, KEYVALUES_DESTRUCT);
	checkThinkFunction = checkThinkFunction.scan(CLIENT_DLL, CHECK_HAS_THINK_FN);
	usingStandardWeaponsVehicle = usingStandardWeaponsVehicle.scan(CLIENT_DLL, USING_STANDARD_WEAPONS_VEH);
	selectItem = selectItem.scan(CLIENT_DLL, SELECT_ITEM);
	transferData = transferData.scan(CLIENT_DLL, TRANSFER_DATA);
	reinitPredicatbles = reinitPredicatbles.scan(CLIENT_DLL, REINIT_PREDICTABLES);
	shutdownPredicatbles = shutdownPredicatbles.scan(CLIENT_DLL, SHUTDOWN_PREDICTABLES);

	// HOOKS

	clientValidAddr = clientValidAddr.scan(CLIENT_DLL, NEW_CHECK);
	enginevalidAddr = enginevalidAddr.scan(ENGINE_DLL, NEW_CHECK);
	studioRenderValidAddr = studioRenderValidAddr.scan(STUDIORENDER_DLL, NEW_CHECK);
	materialSysValidAddr = materialSysValidAddr.scan(MATERIAL_DLL, NEW_CHECK);
	isUsingPropDebug = isUsingPropDebug.scan(ENGINE_DLL, IS_USING_PROP_DEBUG).rel(0x1);
	getColorModulation = getColorModulation.scan(MATERIAL_DLL, GET_COLOR_MODULATION);
	extraBonesProcessing = extraBonesProcessing.scan(CLIENT_DLL, EXTRA_BONES_PROCCESSING);
	buildTransformations = buildTransformations.scan(CLIENT_DLL, BUILD_TRANSFORMATIONS);
	particleSimulate = particleSimulate.scan(CLIENT_DLL, PARTICLE_SIMULATE);
	sendDataGram = sendDataGram.scan(ENGINE_DLL, SEND_DATAGRAM);
	unkOverviewMap = unkOverviewMap.scan(CLIENT_DLL, UNK_OVERVIEWMAP);
	isDepth = isDepth.scan(CLIENT_DLL, IS_DEPTH);
	fxBlood = fxBlood.scan(CLIENT_DLL, FX_BLOOD);
	addEnt = addEnt.scan(CLIENT_DLL, ADD_ENT);
	removeEnt = removeEnt.scan(CLIENT_DLL, REMOVE_ENT);
	isFollowedEntity = isFollowedEntity.scan(CLIENT_DLL, IS_FOLLOWED_ENT);
	spottedEntityUpdate = spottedEntityUpdate.scan(CLIENT_DLL, SPOTTED_ENTITIY_UPDATE);
	fireInternfn = fireInternfn.scan(ENGINE_DLL, FIRE_INTERN);
	preRound = preRound.scan(SERVER_DLL, SERVER_PREROUND);
	playSoundStep = playSoundStep.scan(CLIENT_DLL, PLAY_STEP_SOUND);

	// REST

	tesla = tesla.scan(CLIENT_DLL, FX_TESLA);
	dispatchEffect = dispatchEffect.scan(CLIENT_DLL, DISPATCH_EFFECT);

	// SDK INTERFACES

	game::localPlayer.init();
	memory::interfaces::init();

	beams = beams.scan(CLIENT_DLL, BEAMS, 0x1).deRef();
	glowManager = glowManager.scan(CLIENT_DLL, GLOWMANAGER, 0x3).deRef();
	weaponInterface = weaponInterface.scan(CLIENT_DLL, WEAPONDATA, 0x2).deRef();
	moveHelper = moveHelper.scan(CLIENT_DLL, MOVEHELPER, 0x2).deRef(Dereference::TWICE);
	dx9Device = dx9Device.scan(SHARED_API, DX9_DEVICE, 0x1).deRef(Dereference::TWICE);
	clientState = clientState.scan(ENGINE_DLL, CLIENT_STATE, 0x1).deRef(Dereference::TWICE);
	viewRender = viewRender.scan(CLIENT_DLL, VIEW_RENDER, 0x2).deRef(Dereference::TWICE);

	keyValuesSys = keyValuesSys.byExport<"KeyValuesSystem"_hasher>(VSTD_DLL).cast<keyValuesSystem_t>()()();
	memAlloc = memAlloc.byExport<"g_pMemAlloc"_hasher>(TIER_DLL).deRef();
	moveHelper = moveHelper.scan(CLIENT_DLL, MOVEHELPER, 0x2).deRef(Dereference::TWICE);
	beams = beams.scan(CLIENT_DLL, BEAMS, 0x1).deRef();
	
	globalVars = globalVars.byVFunc(memory::interfaces::client, 0).add(0x1F).deRef(Memory::Dereference::TWICE);
	clientMode = clientMode.byVFunc(memory::interfaces::client, 10).add(0x5).deRef(Memory::Dereference::TWICE);
	input = input.byVFunc(memory::interfaces::client, 16).add(0x1).deRef();

	postInit();

	LOG_INFO(XOR("memory init success"));
}

void Memory::postInit()
{
	using namespace memory;
	using namespace memory::interfaces;

	preciptation = preciptation.findFromGame(CPrecipitation);
	resourceInterface = resourceInterface.findFromGameLoop(CCSPlayerResource);
	gameRules = gameRules.findFromGameLoop(CCSGameRulesProxy);
}
```

`hack/gamememory/memory.hpp`:

```hpp
#pragma once

#include <SDK/math/Vector.hpp>
#include <SDK/math/matrix.hpp>
#include <SDK/interfaces/ifc.hpp>
#include <SDK/CPlayerResource.hpp>
#include <utilities/tools/tools.hpp>

#include <cstdint>
#include <string>
#include <unordered_map>
#include <Windows.h>
#include <variant>
#include <type_traits>

struct CClientEffectRegistration;
class Player_t;
class AnimationLayer;
class CMoveData;
class ClientMode;
class IViewRenderBeams;
class CGlowManager;
class IWeapon;
class IMoveHelper;
class PlayerResource;
struct IDirect3DDevice9;
class IClientState;
class CGameRules;
class IViewRender;
class CTeslaInfo;
class CEffectData;
class KeyValuesSys;
class IMemAlloc;
class CGlobalVarsBase;
class Input;
class CFlashlightEffect;
class ClientClass;

enum ClassID;

using retaddr_t = uintptr_t;

class Memory
{
public:
	enum class Dereference : size_t
	{
		ONCE = 1,
		TWICE,
		THREE
	};

	void init();
	void postInit();

	template<typename T>
	struct Address
	{
		constexpr Address() = default;
		// pass by offset
		constexpr Address(uintptr_t addr) :
			m_addr{ addr }
		{}
		constexpr Address(void* addr) :
			m_addr{ reinterpret_cast<uintptr_t>(addr) }
		{}

		// raw place in memory as offset
		constexpr auto getRawAddr() const { return m_addr; }
		// cast to anything
		template<typename K>
		constexpr auto cast() const { return Address<K>{ m_addr }; }
		constexpr auto add(uintptr_t extraOffset) const { return Address{ m_addr + extraOffset }; }
		constexpr auto sub(uintptr_t extraOffset) const { return Address{ m_addr - extraOffset }; }
		// dereference x times. Possible args are: 1, 2, 3. There will for sure won't be a case for 4 level dereference. 3rd is very rare.
		constexpr auto deRef(Dereference times = Dereference::ONCE)
		{
			for ([[maybe_unused]] auto i : std::views::iota(0U, E2T(times)))
				m_addr = *reinterpret_cast<uintptr_t*>(m_addr);

			return Address<T>{ m_addr };
		}
		// get as rel32
		constexpr auto rel(uintptr_t relOffset = 0x1, uintptr_t absOffset = 0x0) const
		{
			const auto jump = m_addr + relOffset;
			const auto target = *reinterpret_cast<decltype(jump)*>(jump);
			return Address<T>{ jump + absOffset + 0x4 + target };
		}
		// will work for classes types too
		constexpr T operator()() const
		{
			if constexpr (std::is_class_v<T>)
				return *reinterpret_cast<T*>(m_addr);
			else
				return (T)(m_addr);
		}

		constexpr T operator->() const
		{
			if constexpr (std::is_class_v<T>)
				return *reinterpret_cast<T*>(m_addr);
			else
				return (T)(m_addr);
		}

		Address<T> scan(const std::string_view mod, const std::string_view sig, uintptr_t offset = 0);
		template<li::detail::offset_hash_pair hash>
		Address<T> byExport(const std::string_view module);
		template<typename TT>
		Address<T> byVFunc(const Interface<TT>& ifc, size_t index);
		// static pointer
		Address<T> findFromGame(ClassID id);
		// anything that changes every round
		Address<T> findFromGameLoop(ClassID id);

		using value = T;
		uintptr_t m_addr;
		std::string_view m_module;
	};
private:
	std::unordered_map<std::string_view, HMODULE> m_ModulesAddr;
public:
	HMODULE getModule(const std::string_view str) { return m_ModulesAddr.at(str); }
};

namespace memory
{
	using loadSky_t = void(__fastcall*)(const char*);
	using findHud_t = uintptr_t * (__thiscall*)(void* /*uintptr_t*/, const char*);
	using sequenceActivity_t = int(__fastcall*)(void*, void*, int);
	using inSmoke_t = bool(__cdecl*)(Vec3, Vec3);
	using isBreakable_t = bool(__thiscall*)(void*);
	using flashlightDestroy_t = void(__thiscall*)(void*, void*);
	using flashlightCreate_t = void* (__thiscall*)(void*, void*, float, float, float, float, int, const char*, float, float);
	using flashlightUpdate_t = void(__thiscall*)(void*, int, const Vec3&, const Vec3&, const Vec3&, const Vec3&, float, float, float, bool, const char*);
	using setAbsOrigin_t = void(__thiscall*)(void*, const Vec3&);
	using isC4Owner_t = bool(__thiscall*)(void*);
	using teslaCreate_t = void(__thiscall*)(CTeslaInfo&);
	using dispatchEffect_t = int(__fastcall*)(const char*, const CEffectData&);
	using particleCached_t = bool(__thiscall*)(void*, const char*);
	using particleFindString_t = void(__thiscall*)(void*, int*, const char*);
	using setParticleControlPoint_t = void(__thiscall*)(void*, int, Vec3*);
	using physicsRunThink_t = bool(__thiscall*)(void*, int);
	using postThinkPhysics_t = bool(__thiscall*)(Player_t*);
	using simulateEntities_t = void(__thiscall*)(Player_t*);
	using loadFromBuffer_t = void(__thiscall*)(void*, const char*, const char*, void*, const char*, void*, int);
	using keyValuesConstruct_t = void(__thiscall*)(void*, const char*, const char*, int); // or 3rd (2nd without thisptr) arg is int, not sure
	using keyValuesDestruct_t = void(__thiscall*)(void*, int);
	using keyValuesSystem_t = KeyValuesSys * (__cdecl*)();
	using checkThinkFunction_t = void(__thiscall*)(void*, bool);
	using usingStandardWeaponsInVehicle_t = bool(__thiscall*)(void*);
	using selectItem_t = void(__thiscall*)(void*, const char*, int);
	using transferData_t = int(__thiscall*)(void*, const char*, int, void*);
	using reinitPredictables_t = int(__stdcall*)();
	using shutdownPredictables_t = void(__stdcall*)();

	inline Memory::Address<uintptr_t> traceFilterSimple;
	inline Memory::Address<uintptr_t*> returnAddrRadarImage;
	inline Memory::Address<Matrix4x4> viewMatrixAddr;
	inline Memory::Address<uintptr_t> drawSpacedRectangle;
	inline Memory::Address<float*> motionBlurVec;
	inline Memory::Address<uintptr_t> disableTargetAlloc;
	inline Memory::Address<inSmoke_t> throughSmoke;
	inline Memory::Address<uintptr_t> smokeCount;
	inline Memory::Address<loadSky_t> loadSky;
	inline Memory::Address<CClientEffectRegistration*> callbacksHead;
	inline Memory::Address<void*> camThink;
	inline Memory::Address<void*> renderDrawPoints;
	inline Memory::Address<Player_t**> localPlayer;
	inline Memory::Address<void*> csgoHud;
	inline Memory::Address<findHud_t> hudfindElement;
	inline Memory::Address<uintptr_t> keyValuesFromString;
	inline Memory::Address<uintptr_t> animOverlays;
	inline Memory::Address<sequenceActivity_t> sequenceActivity;
	inline Memory::Address<uintptr_t> cachedBones;
	inline Memory::Address<setAbsOrigin_t> setAbsOrigin;
	inline Memory::Address<isC4Owner_t> isC4Owner;
	inline Memory::Address<isBreakable_t> isBreakable;
	inline Memory::Address<CMoveData*> predictionData;
	inline Memory::Address<uintptr_t*> predictionSeed;
	inline Memory::Address<flashlightCreate_t> flashlightCreate;
	inline Memory::Address<flashlightUpdate_t> flashlightUpdate;
	inline Memory::Address<flashlightDestroy_t> flashlightDestroy;
	inline Memory::Address<uintptr_t> occlusion;
	inline Memory::Address<uintptr_t> velocity;
	inline Memory::Address<uintptr_t> accumulate;
	inline Memory::Address<particleCached_t> particleIsCached;
	inline Memory::Address<void**> particleSystem;
	inline Memory::Address<particleFindString_t> particleFindStringIndex;
	inline Memory::Address<void*> particleCall;
	inline Memory::Address<setParticleControlPoint_t> particleSetControlPoint;
	inline Memory::Address<Player_t**> predictedPlayer;
	inline Memory::Address<physicsRunThink_t> physicsRunThink;
	inline Memory::Address<uintptr_t> lastCommand;
	inline Memory::Address<uintptr_t> retAddrToInterpolation;
	inline Memory::Address<postThinkPhysics_t> postThinkPhysics;
	inline Memory::Address<simulateEntities_t> simulateEntities;
	inline Memory::Address<uintptr_t> vecClientImpacts;
	inline Memory::Address<loadFromBuffer_t> loadFromBuffer;
	inline Memory::Address<keyValuesConstruct_t> keyValuesConstruct;
	inline Memory::Address<keyValuesDestruct_t> keyValuesDestruct;
	inline Memory::Address<checkThinkFunction_t> checkThinkFunction;
	inline Memory::Address<usingStandardWeaponsInVehicle_t> usingStandardWeaponsVehicle;
	inline Memory::Address<selectItem_t> selectItem;
	inline Memory::Address<transferData_t> transferData;
	inline Memory::Address<reinitPredictables_t> reinitPredicatbles;
	inline Memory::Address<shutdownPredictables_t> shutdownPredicatbles;

	inline Memory::Address<void*> clientValidAddr;
	inline Memory::Address<void*> enginevalidAddr;
	inline Memory::Address<void*> studioRenderValidAddr;
	inline Memory::Address<void*> materialSysValidAddr;
	inline Memory::Address<void*> isUsingPropDebug;
	inline Memory::Address<void*> getColorModulation;
	inline Memory::Address<void*> extraBonesProcessing;
	inline Memory::Address<void*> buildTransformations;
	inline Memory::Address<void*> particleSimulate;
	inline Memory::Address<void*> sendDataGram;
	inline Memory::Address<void*> unkOverviewMap;
	inline Memory::Address<void*> isDepth;
	inline Memory::Address<void*> fxBlood;
	inline Memory::Address<void*> addEnt;
	inline Memory::Address<void*> removeEnt;
	inline Memory::Address<void*> isFollowedEntity;
	inline Memory::Address<void*> spottedEntityUpdate;
	inline Memory::Address<void*> fireInternfn;
	inline Memory::Address<void*> preRound;
	inline Memory::Address<void*> playSoundStep;

	inline Memory::Address<teslaCreate_t> tesla;
	inline Memory::Address<dispatchEffect_t> dispatchEffect;

	namespace interfaces
	{
		inline Memory::Address<CGlowManager*> glowManager;
		inline Memory::Address<IWeapon*> weaponInterface;
		inline Memory::Address<PlayerResource*> resourceInterface;
		inline Memory::Address<IDirect3DDevice9*> dx9Device;
		inline Memory::Address<IClientState*> clientState;
		inline Memory::Address<IViewRender*> viewRender;
		inline Memory::Address<IMoveHelper*> moveHelper;
		inline Memory::Address<IViewRenderBeams*> beams;
		inline Memory::Address<KeyValuesSys*> keyValuesSys;
		inline Memory::Address<IMemAlloc*> memAlloc;
		inline Memory::Address<CGameRules*> gameRules;
		inline Memory::Address<CGlobalVarsBase*> globalVars;
		inline Memory::Address<ClientMode*> clientMode;
		inline Memory::Address<Input*> input;
		inline Memory::Address<ClientClass*> preciptation;
	}
}

[[maybe_unused]] inline auto g_Memory = Memory{};
```

`hack/gamememory/modules.hpp`:

```hpp
#pragma once

#include <utilities/tools/tools.hpp>

#define ENGINE_DLL					XOR("engine.dll")
#define CLIENT_DLL					XOR("client.dll")
#define VSTD_DLL					XOR("vstdlib.dll")
#define VGUI_DLL					XOR("vgui2.dll")
#define VGUIMAT_DLL					XOR("vguimatsurface.dll")
#define MATERIAL_DLL				XOR("materialsystem.dll")
#define LOCALIZE_DLL				XOR("localize.dll")
#define STUDIORENDER_DLL			XOR("studiorender.dll")
#define INPUTSYSTEM_DLL				XOR("inputsystem.dll")
#define SHARED_API					XOR("shaderapidx9.dll")
#define TIER_DLL					XOR("tier0.dll")
#define PANORAMA_DLL				XOR("panorama.dll")
#define FILESYS_DLL					XOR("filesystem_stdio.dll")
#define DATACACHE_DLL				XOR("datacache.dll")
#define SERVER_DLL					XOR("server.dll")
```

`hack/gamememory/pattern.hpp`:

```hpp
#pragma once

#include <ranges>
#include <string_view>
#include <vector>
#include <optional>

// can't make it constexpr with xor'ed strings
// only way is to use const char (&str)[N] as template literal which wont work
template<typename T>
struct SigConvert
{
	static auto get(const std::string_view sig)
	{
		std::vector<std::optional<T>> actualPattern; // idk how to get view split size shorty to optimize known vec size
		for (const auto& el : std::views::split(sig, delimer))
		{
			const std::string_view part{ el.begin(), el.end() };
			if (const auto itr = std::ranges::find(masks, part); itr != masks.end())
				actualPattern.emplace_back(std::nullopt);
			else
				actualPattern.emplace_back(convertHex(part));
		}

		return actualPattern;
	}
private:
	static T convertHex(std::string_view str)
	{
		int val;
		auto fallback = std::from_chars(str.data(), str.data() + str.size(), val, base);
		assert(fallback.ec == std::errc{});
		return static_cast<T>(val);
	}
	constexpr static std::array<std::string_view, 2U> masks = { "?", "??" };
	constexpr static char delimer = ' ';
	constexpr static short base = 0x10;
};
```

`hack/gamememory/sigs.hpp`:

```hpp
#pragma once

#include <utilities/tools/tools.hpp>

// I found by strictly setting glow color in console and finding what exactly changed in reclass
// or go EntityGlowEffects, list up xrefs. https://github.com/perilouswithadollarsign/cstrike15_src/blob/f82112a2388b841d72cb62ca48ab1846dfcc11c8/game/client/glow_outline_effect.cpp#L34
#define GLOWMANAGER					XOR("0F 11 05 ? ? ? ? 83 C8 01")
// const CViewRenderBeams::`vftable should be pushed in:
// #STR #STR: "r_drawbrushmodels", "engine/writez", "debug/debugtranslucentsinglecolor", "engine/modulatesinglecolor", "vgui/white", "r_drawentities", "Other textures"
#define BEAMS						XOR("B9 ? ? ? ? A1 ? ? ? ? FF 10 A1 ? ? ? ? B9")
// #STR: "%s stuck on object %i/%s", "client"
#define MOVEHELPER					XOR("8B 0D ? ? ? ? 8B 45 ? 51 8B D4 89 02 8B 01")
// #STR SelectWeightedSequence
// or never sig it and use exactly code that game uses
#define PREDICTIONRANDOMSEED		XOR("8B 0D ? ? ? ? BA ? ? ? ? E8 ? ? ? ? 83 C4 04")
// no STR
// it will be easier to find by live debugger
// or just find it below setabs one which is easier to find
#define SETABSANGLES				XOR("55 8B EC 83 E4 F8 83 EC 64 53 56 57 8B F1 E8")
// Ignoring unreasonable position (%f,%f,%"... is a hint
#define SETABSORIGIN				XOR("55 8B EC 83 E4 F8 51 53 56 57 8B F1 E8")
// should call check ammo cvar or smth
// #STR: ammo_50AE_impulse
#define WEAPONDATA					XOR("8B 35 ? ? ? ? FF 10 0F B7 C0")
// #STR: "weapon_c4"
#define HASC4						XOR("56 8B F1 85 F6 74 31")
// #STR: (mod_studio)
#define INVALIDATE_BONE_CACHE		XOR("80 3D ? ? ? ? ? 74 16 A1 ? ? ? ? 48 C7 81")
// useless since in here you can read it can be forced, but it's safer
// https://www.unknowncheats.me/forum/counterstrike-global-offensive/213556-changing-sky-spoofing-cvar.html
#define LOAD_SKY					XOR("55 8B EC 81 EC ? ? ? ? 56 57 8B F9 C7 45")
// anything with literal named bones/hitboxes
#define ANIMATION_LAYER				XOR("8B 89 ? ? ? ? 8D 0C D1")
// #STR: "No model!", "Not Found!
// and anything with sequence
#define SEQUENCE_ACTIVITY			XOR("55 8B EC 53 8B 5D 08 56 8B F1 83")
// also: 55 8B EC 8B 45 10 50 8B 4D 04, and more... this is for you to figure out. use xrefs...
#define NEW_CHECK					XOR("55 8B EC 56 8B F1 33 C0 57 8B 7D 08 8B 8E")
// #STR: "Video driver has crashed and been reset, re-uploading reso
#define DX9_DEVICE					XOR("A1 ? ? ? ? 50 8B 08 FF 51 0C")
// #STR: DebugView
// #STR: debug/
// finding it with live debugger is easier and I don't think it needs any explanation how to find your local view matrix
#define VIEW_MATRIX_CLIENT			XOR("0F 10 05 ? ? ? ? 8D 85 ? ? ? ? B9")
// #STR: "func_breakable", "func_breakable_surf"
#define IS_BREAKBLE					XOR("55 8B EC 51 56 8B F1 85 F6 74 68")
// this is needed because this convar will rely on many things, the r_drawspecificstaticprop and forcing isn't enough
// #STR: "CStaticProp::DrawModel", "Static_Prop_Rendering"
// just like in engine source, before Static_Prop_Rendering there will be a check before to that function
// first call is that function
// now, normal sig from selection points to many other functions so use a relative one
#define IS_USING_PROP_DEBUG			XOR("E8 ? ? ? ? 84 C0 8B 45 08")
// see how many pushes are logically to color struct
// should call this one:
// #STR: "CMaterial::PrecacheVars: error loading vmt file for %s\n", "vmt_patches"
#define GET_COLOR_MODULATION		XOR("55 8B EC 83 EC ? 56 8B F1 8A 46")
// disable useless processing on setupbones
// #STR: "ankle_R", "hand_L", "ball_L", "ball_R", "lh_ik_driver", "weapon_hand_R", "ankle_L"
#define EXTRA_BONES_PROCCESSING		XOR("55 8B EC 83 E4 F8 81 EC ? ? ? ? 53 56 8B F1 57 89 74 24 1C 80")
// disable jiggle bones without forcing convar
// better to use live debugger to find it by easier way
#define BUILD_TRANSFORMATIONS		XOR("55 8B EC 83 E4 F0 81 EC ? ? ? ? 56 57 8B F9 8B 0D ? ? ? ? 89 7C 24 28 8B")
// #STR: "view angles", "Pitch: %6.1f   Yaw: %6.1f %38s", "ideal angles", "Pitch: %6.1f   Yaw: %6.1f   Dist: %6.1f %19s", "camera offset", "Pitch: %6.1f   Yaw: %6.1f   Dist: %6.1f %16s", "sv_cheats"
#define CAM_THINK					XOR("85 C0 75 30 38 87")
// "#empty#", "#int#"
// also easy to find as 'KeyValuesSystem' should be generated in ida as externs
#define KEY_VALUES_FROM_STR			XOR("55 8B EC 83 E4 F8 81 EC 0C 05")
// found by checking what's inside bone threads
// str anything like bone access
// allocation done here? direct reference: 55 8B EC 83 EC 08 56 8B F1 8A 86
#define CACHED_BONE					XOR("FF B7 ? ? ? ? 52")
// #STR: "CParticleCollection::Simulate", "Particle Simulation"
#define PARTICLE_SIMULATE			XOR("55 8B EC 83 E4 F8 83 EC 30 56 57 8B F9 0F 28 E1 8B 0D ? ? ? ? F3 0F 11 64 24 ? 89 7C 24 18 8B 81")
#pragma region dumped_effect_names
/*
ManhackSparks
TeslaZap
TeslaHitboxes
CommandPointer
GunshipImpact
Smoke
MuzzleFlash
Error
BoltImpact
RPGShotDown
GlassImpact
EjectBrass_338Mag
EjectBrass_762Nato
EjectBrass_556
EjectBrass_57
EjectBrass_12Gauge
EjectBrass_9mm
CS_MuzzleFlash_X
CS_MuzzleFlash
KnifeSlash
Impact
CS_HolidayLight
csblood
waterripple
gunshotsplash
watersplashquiet
watersplash
TracerSound
ParticleTracer
Tracer
ShotgunShellEject
RifleShellEject
ShellEject
RagdollImpact
HelicopterMegaBomb
WaterSurfaceExplosion
Explosion
HunterDamage
BloodImpact
bloodspray
WheelDust
ShakeRopes
ParticleEffectStop
ParticleEffect
*/
#pragma endregion
// #STR: "DispatchEffect: effect \"%s\" not found on client\n", "Encountered multiple different effects with the same nam
// see what calls this and you can see head ptr, should be close to actual message
#define HEAD_OF_EFFECTS				XOR("8B 35 ? ? ? ? 85 F6 0F 84 ? ? ? ? 0F 1F 00")
// check CTraceFilterOmitPlayers
#define GOES_THROUGH_SMOKE			XOR("55 8B EC 83 EC 08 8B 15 ? ? ? ? 0F 57 C0")
// #STR: "TempEntity", "TE_DispatchEffect %s %s", "originx", "originy", "originz", "startx", "starty", "startz", "normalx", "normaly"
#define DISPATCH_EFFECT				XOR("55 8B EC 83 E4 F8 83 EC 20 56 57 8B F9 C7 44 24")
// #STR: "effects/tesla_glow_noz"
#define FX_TESLA					XOR("55 8B EC 81 EC ? ? ? ? 56 57 8B F9 8B 47 18")
// #STR: "effects/flashlight001", "Other textures"
#define FLASHLIGHT_CREATE			XOR("55 8B EC F3 0F 10 45 ? B8")
// #STR: "entindex", "flashlightHandle", "flashlightState", "FlashlightState"
#define FLASHLIGHT_DESTROY			XOR("56 8B F1 E8 ? ? ? ? 8B 4E 28")
// #STR: "CFlashlightEffect::UpdateLight", "FlashlightState", "entindex", "flashlightHandle", "flashlightState", "Flashlight Shadows"
#define FLASHLIGHT_UPDATE			XOR("55 8B EC 81 EC ? ? ? ? 53 56 8B F1 8B 0D ? ? ? ? 57 8B 81")
// my method is to first lookup the const CClientState::`vftable'
// we can see this function: direct reference: [actual address in first opcode] E8 ? ? ? ? EB 02 33 F6 85 FF
// a lot of initialization going on here, but most importantly we must find the pointer to clientstate
// skip reading to the last memset operation, see mov eax, edi -> this copies to the result
// first operation below is the offset to add. This although is very stupid method, better is this:
// "CEngineClient::SetViewAngles:  rejecting invalid value [%f %f %f]\n" see what is called under
// currently dword_1059F194, now to get it, there are many functions containing it. This sig needs small opcode add.
#define CLIENT_STATE				XOR("A1 ? ? ? ? 8B 88 ? ? ? ? 85 C9 75 07")
// STR: "CNetChan_TransmitBits->send", "CNetChan::SendDatagram
#define SEND_DATAGRAM				XOR("55 8B EC 83 E4 F0 B8 ? ? ? ? E8 ? ? ? ? 56 57 8B F9 89 7C 24 14")
// STR: const CTraceFilterSimple
#define CTRACE_FILTER_SIMPLE		XOR("55 8B EC 83 E4 F0 83 EC 7C 56 52")
// #STR: "CHudWeaponSelection"
#define CSGO_HUD					XOR("B9 ? ? ? ? 68 ? ? ? ? E8 ? ? ? ? 89")
// #STR: "[%d] Could not find Hud Element: %s\n"
#define FIND_ELEMENT				XOR("55 8B EC 53 8B 5D 08 56 57 8B F9 33 F6 39 77 28 7E 1E")
// https://gitlab.com/KittenPopo/csgo-2018-source/-/blob/main/studiorender/r_studiodraw.cpp#L451
// inside: direct reference: [actual address in first opcode] E8 ? ? ? ? 8B 4D 2C
// for ( i = this; v12 < a4; v11 += R_StudioDrawPoints((int)i, a2, a3, a6, a7, a8, v18, a10, a11) )
// need to get now mov instruction for ebp
// got it from here: https://www.unknowncheats.me/forum/counterstrike-global-offensive/125029-d3d-chams-without-vertcounts.html
#define R_STUDIODRAWPOINTS			XOR("8B 7D FC 03 F8 89 7D FC EB 1F")
// to find it you must check it yourself
// anything like Failed to convert image data to RGBA might help to path it
#define UNK_FILESYS					XOR("C7 43 ? ? ? ? ? 83 7C 24 ? ? 7C 25 8B 54 24 48")
// #STR: "Error! CMapOverview::SetMap: couldn't load file %s.\n", "file://{images_overviews}/%s_radar_spectate.dds", "pos_x", "pos_y", "scale", "resource/overviews/%s.txt"
#define UNK_OVERVIEWMAP				XOR("55 8B EC 81 EC ? ? ? ? 53 8B 5D 08 8B D3")
// #STR: "ClientScheme", "resource/ClientScheme.res", "VPhysics031", "VPhysicsSurfaceProps001", "VPhysicsCollision007", "ClientDLL"
// get this ptr https://gitlab.com/KittenPopo/csgo-2018-source/-/blob/main/game/client/cdll_client_int.cpp#L1323
#define VIEW_RENDER					XOR("8B 0D ? ? ? ? FF 75 0C 8B 45 08")
// #STR: "Client_Animation", "C_BaseAnimating::SetupBones", "*** ERROR: Bone access not allowed (entity %i:%s)\n", "%d:%s", "SetupBones: invalid bone array size (%d - needs %d)\n", "Client_Animation_Threaded"
#define ACCUMULATE_LAYERS			XOR("84 C0 75 0D F6 87")
#define SETUP_VELOCITY				XOR("84 C0 75 38 8B 0D ? ? ? ? 8B 01 8B 80")
#define SETUP_OCCLUSION				XOR("84 C0 0F 85 ? ? ? ? A1 ? ? ? ? 8B B7")
// #STR: "Tried BeginRenderTargetAllocation after game startup. If I
#define DISABLE_RENDER_TARGET_ALLOC XOR("80 B9 ? ? ? ? ? 74 0F")
// #STR: "userid", "entindex", "weaponhud_selection"
#define LOCAL_PLAYER				XOR("8B 0D ? ? ? ? 83 FF FF 74 07")
// from prediction stack
#define PREDICTION_MOVE_DATA		XOR("A1 ? ? ? ? F3 0F 59 CD")
// #STR: "Client: Missing precache for particle system \"%s\"!\n" - this func is a mess to start working on rain manually
#define DISPATCH_PARTICLE			XOR("55 8B EC 83 E4 F8 83 EC 6C 53 56 57 8B F9 8B DA 8D 4C 24 10 E8")
// see what's under:
// ; #STR: "$c0_x", "_rt_FullFrameFB", "_rt_SmallFB0", "Other textures", "dev/blurgaussian_3x3", "_rt_SmallFB1", "$c0_y", "$c1_x", "$c1_y", "RenderTargets"
// is called
#define IS_DEPTH					XOR("8B 0D ? ? ? ? 56 8B 01 FF 50 34 8B F0 85 F6 75 04")
// wrapper to allow in other hooks
// #STR: "_rt_FullFrameFB", "RenderTargets", "_rt_FullFrameFB%d"
#define DRAW_SPACE_RECTANGLE_CALL	XOR("55 8B EC 83 E4 ? 83 EC ? 53 56 57 8D 44 24 ? 89 4C")
// #STR: "StartParticleEffect:  Failed to find precached particle sy
#define START_PARTICLE_EFFECT		XOR("55 8B EC 83 EC 34 80 3D ? ? ? ? ? 53 56 57 8B DA 8B F1 0F 85")
// #STR: "state", "ParticleSystem_Destroy"
#define PARTICLE_SYSTEM_DESTROY		XOR("56 8B F1 F6 86 ? ? ? ? ? C7 06")
// #STR: "Attempted to create unknown particle system type \"%s\"!\n, "error", "explosion_smokegrenade"
// see what under this str gets called
#define PARTICLE_CALL				XOR("55 8B EC 83 EC ? 53 56 8B F2 89 75")
// found by following leak's code again use unknown particle as str ref
#define IS_EFFECT_CACHED			XOR("55 8B EC 83 EC ? 53 56 57 8B 7D ? 8D 59 ? 85 FF")
// #STR: "state", "ParticleSystem_SetControlPointPosition"
#define SET_PARTICLE_POINT			XOR("55 8B EC 53 8B 5D ? 56 8B F1 F6 86")
// explosion_smokegrenade, check inside: unknown particle
#define PARTICLE_SYSTEM				XOR("55 8B EC 51 56 8B 35 ? ? ? ? 8B CE")
// followed by leak's code
#define FIND_STRING_INDEX			XOR("55 8B EC 83 EC ? 53 8B 5D ? 57 8B F9 89 7D ? 85 DB")
// #STR: "Particle/Effect_Rendering", "FX_Blood"
#define	FX_BLOOD					XOR("55 8B EC 83 EC 34 53 56 57 8B F9 F3 0F")
// #STR: "$MotionBlurViewportInternal", "$MotionBlurInternal"
// you can see there is an offset with pointer that is pushed below, "push 4" is helpful, this is the part of editing vector
#define BLUR_MATERIAL_ARR_1			XOR("68 ? ? ? ? FF 50 34 8B 4E 08 5E 85 C9 74 0C")
// old was in VClientEntityList0 exactly like
// https://github.com/perilouswithadollarsign/cstrike15_src/blob/f82112a2388b841d72cb62ca48ab1846dfcc11c8/game/client/cliententitylist.h#L130
// now can't get addr by index, they are placed exactly in same place tho
#define ADD_ENT						XOR("55 8B EC 51 8B 45 0C 53 56 8B F1 57")
#define REMOVE_ENT					XOR("55 8B EC 51 8B 45 0C 53 8B D9 56 57 83 F8 FF 75 07")
// #STR: "CPrediction::ProcessMovement", and see what calls random seed by 0FFFFFFFF, at the bottom the jump is predicted player
#define PREDICTED_PLAYER			XOR("89 35 ? ? ? ? F3 0F 10 48 20")
// #STR: "CLIENT:  %s(%s) thinking for %.02f ms!!!\n", ".PAVC_BaseEntity@@"
#define PHYSICS_RUN_THINK			XOR("55 8B EC 83 EC 10 53 56 57 8B F9 8B 87")
// #STR: CPrediction::ProcessMovement
// and leak RunCommand
#define BUTTONS_FORCED				XOR("8B 86 44 33 ? ? 09 47 30")
// #STR: "CPrediction::ProcessMovement"
// and leak RunCommand
#define LAST_COMMAND				XOR("8D 8E ? ? ? ? 89 5C 24 3C")
// found by looking around in C_BaseEntity, I looked in mac binaries and compared current one
#define IS_FOLLOWED_ENT				XOR("F6 ? ? ? ? ? ? 74 31 80")
// #STR: "cl_updaterate"
#define RET_ADDR_INTERPOLATION		XOR("84 C0 0F 85 ? ? ? ? 38 05 ? ? ? ? 0F 84 ? ? ? ? 53")
// #STR: CPrediction::ProcessMovement
// and leak RunCommand
#define POST_THINK_PHYSICS			XOR("55 8B EC 83 E4 F8 81 EC ? ? ? ? 53 8B D9 56 57 83 BB")
// #STR: CPrediction::ProcessMovement
// and leak RunCommand
#define SIMULATE_ENTITIES			XOR("56 8B F1 57 8B BE ? ? ? ? 83 EF 01 78 74")
// #STR: "CCSPlayer", "CPlantedC4", "CHostage", "Unknown entity update received by ProcessSpottedEntityUpda, "Unknown entity class received in ProcessSpottedEntityUpdat
#define SPOTTED_ENTITIY_UPDATE		XOR("55 8B EC 83 EC 18 8B 45 08 53 56 57")
// "\ntime\tbullet\trange\trecovery\tinaccu"
// xref addtoTail() function or follow player stack direct reference: [actual address in first opcode] E8 ? ? ? ? 46 3B B3 ? ? ? ? 7C 8C 
#define VEC_CLIENT_IPACT_LIST		XOR("8D 8F ? ? ? ? F3 0F 10 84 24")
// #STR: "Server event \"%s\", Tick %i:\n", "GameEventListener2 callback in list that should NOT be - %, "Callback for event \"%s\" is NULL!!!\n", "portal2", "FireEvent: event '%s' not registered.\n", "Game event \"%s\", Tick %i:\n"
#define FIRE_INTERN					XOR("55 8B EC 83 E4 F8 83 EC 0C 8B C1 53 56")
// #STR: "KeyValues::LoadFromBuffer(%s%s%s): Begin"
#define LOAD_FROM_BUFFER			XOR("55 8B EC 83 E4 F8 83 EC 34 53 8B 5D 0C 89")
// #STR: "KeyValues::ParseIncludedKeys: Couldn't load included keyva
#define KEYVALUES_CONSTRUCT			XOR("55 8B EC 56 8B F1 33 C0 8B 4D 0C 81")
// #STR: "KeyValues::ParseIncludedKeys: Couldn't load included keyva
#define KEYVALUES_DESTRUCT			XOR("56 8B F1 E8 ? ? ? ? 8B 4E 14")
// #STR: CPrediction::ProcessMovement
#define USING_STANDARD_WEAPONS_VEH	XOR("56 57 8B F9 8B 97 ? ? ? ? 83 FA FF 74 43 0F")
// #STR: C_BasePlayer::`vftable
#define SELECT_ITEM					XOR("55 8B EC 56 8B F1 ? ? ? 85 C9 74 71 8B 06")
// #STR: CPrediction::ProcessMovement
#define CHECK_HAS_THINK_FN			XOR("55 8B EC 56 57 8B F9 8B B7 ? ? ? ? 8B")
// #STR: "C_BaseEntity::SaveData"
// just after first offset has been pushed with "SaveData", there is a copy
#define TRANSFER_DATA				XOR("55 8B EC 8B 45 10 53 56 8B F1 57")
// #STR: "Shutdown %i predictable entities and %i client-created ent
#define SHUTDOWN_PREDICTABLES		XOR("53 56 8B 35 ? ? ? ? 33 DB 57 33 FF")
// #STR: "%d:  Reinitialized %i predictable entities\n"
#define REINIT_PREDICTABLES			XOR("A1 ? ? ? ? B9 ? ? ? ? 53 56 FF 50 18")
// #STR: "userid", "gg_halftime"
#define SERVER_PREROUND				XOR("55 8B EC 83 EC 0C 53 8B D9 56 57 8B 03")
// #STR: "Can't find specific footstep sound! (%s) - Using the defau, "Heavy.Step", "T_Default.Suit", "CT_Default.Suit", "ct_%s"
#define PLAY_STEP_SOUND				XOR("55 8B EC 8B 45 18 81 EC")
// #STR: "userid", "health", "priority", "player_hurt", "attacker"
#define ON_TAKE_DMFG_ALIVE			XOR("55 8B EC 83 EC 18 56 57 8B 7D 08 8B F1 57")

```

`hack/menu/GUI-ImGui/animations.cpp`:

```cpp
#include "animations.hpp"

#include "menu.hpp"

#include <config/config.hpp>
#include <utilities/utilities.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>

void ImGui::Animations::setAnimationSpeeds()
{
	detail::speedAlpha = vars::styling->smoothAlpha;
	detail::speedOutline = vars::styling->smoothOutline;
	detail::speedMove = vars::styling->speedMove;
	detail::speedPop = vars::styling->smoothPop;
}

ImGui::Animations::AlphaAnimation ImGui::Animations::getAlpha(ImGuiID id, const AlphaLimits& limits)
{
	ImGuiContext& g = *GImGui;

	AlphaAnimation anim;
	const auto itr = alphas.find(id);
	if (itr != alphas.end())
		anim = itr->second;

	anim.alpha = ImLerpSmooth(anim.alpha, limits.alphaLimit, g.IO.DeltaTime, detail::speedAlpha);
	anim.outline = ImLerpSmooth(anim.outline, limits.outlineLimit, g.IO.DeltaTime, detail::speedOutline);

	alphas[id] = anim;
	return anim;
}

ImGui::Animations::SingleAnimation ImGui::Animations::getSingleAnimation(ImGuiID id, float max, float duration, float extraSpped)
{
	ImGuiContext& g = *GImGui;

	SingleAnimation anim;
	const auto itr = singleAnim.find(id);
	if (itr != singleAnim.end())
		anim = itr->second;

	anim.value = ImLerpSmooth(anim.value, max, g.IO.DeltaTime * extraSpped, duration);

	singleAnim[id] = anim;
	return anim;
}

ImGui::Animations::MoveAnimation ImGui::Animations::getMove(ImGuiID id, float lastTime, bool held, bool pressed)
{
	MoveAnimation move;
	const auto itr = moves.find(id);
	if (itr != moves.end())
		move = itr->second;

	const float temp_thickness = ImSaturate(lastTime * detail::speedMove);
	move.move = held ? temp_thickness : (1.0f - temp_thickness);

	moves[id] = move;
	return move;
}

ImGui::Animations::SingleField ImGui::Animations::getAndUpdateSingleField(ImGuiID id, float value)
{
	SingleField field = { .value = value };
	singleFields[id] = SingleField{ .value = value };
	return field;
}

float ImGui::Animations::getLastTime(ImGuiID id, bool held, bool pressed)
{
	ImGuiContext& g = *GImGui;

	float lastTime = 0.0f;
	const auto itr = timeStack.find(id);
	if (itr != timeStack.end())
		lastTime = itr->second;

	if (held || pressed)
		lastTime = 0.0f;

	if (lastTime == 0.f && !pressed)
		lastTime = g.LastActiveIdTimer;

	lastTime += g.IO.DeltaTime;
	timeStack[id] = lastTime;

	return lastTime;
}

void ImGui::Animations::RenderArrow(ImDrawList* draw_list, ImVec2 pos, ImU32 col, ImGuiDir dir, float angle, float scale)
{
	const float h = draw_list->_Data->FontSize * 1.00f;
	float r = h * 0.40f * scale;
	ImVec2 center = pos + ImVec2(h * 0.50f, h * 0.50f * scale);
	ImVec2 a, b, c;

	const float cangle = ImCos(angle);
	const float sangle = ImSin(angle);

	switch (dir)
	{
	case ImGuiDir_Up:
	case ImGuiDir_Down:
		if (dir == ImGuiDir_Up) r = -r;
		a = ImRotate(ImVec2(+0.000f, +0.750f), cangle, sangle) * r;
		b = ImRotate(ImVec2(-0.866f, -0.750f), cangle, sangle) * r;
		c = ImRotate(ImVec2(+0.866f, -0.750f), cangle, sangle) * r;
		break;
	case ImGuiDir_Left:
	case ImGuiDir_Right:
		if (dir == ImGuiDir_Left) r = -r;
		a = ImRotate(ImVec2(+0.750f, +0.000f), cangle, sangle) * r;
		b = ImRotate(ImVec2(-0.750f, +0.866f), cangle, sangle) * r;
		c = ImRotate(ImVec2(-0.750f, -0.866f), cangle, sangle) * r;
		break;
	case ImGuiDir_None:
	case ImGuiDir_COUNT:
		IM_ASSERT(0);
		break;
	}

	draw_list->AddTriangleFilled(center + a, center + b, center + c, col);
}

static float CalcMaxPopupHeightFromItemCount(int items_count)
{
	ImGuiContext& g = *GImGui;
	if (items_count <= 0)
		return FLT_MAX;
	return (g.FontSize + g.Style.ItemSpacing.y) * items_count - g.Style.ItemSpacing.y + (g.Style.WindowPadding.y * 2);
}

bool ImGui::Animations::BeginComboPopup(ImGuiID popup_id, const ImRect& bb, ImGuiComboFlags flags, float pop)
{
	ImGuiContext& g = *GImGui;
	if (!IsPopupOpen(popup_id, ImGuiPopupFlags_None))
	{
		g.NextWindowData.ClearFlags();
		return false;
	}

	// Set popup size
	float w = bb.GetWidth() * pop;
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint)
	{
		g.NextWindowData.SizeConstraintRect.Min.x = ImMax(g.NextWindowData.SizeConstraintRect.Min.x, w);
	}
	else
	{
		if ((flags & ImGuiComboFlags_HeightMask_) == 0)
			flags |= ImGuiComboFlags_HeightRegular;
		IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiComboFlags_HeightMask_)); // Only one
		int popup_max_height_in_items = -1;
		if (flags & ImGuiComboFlags_HeightRegular)     popup_max_height_in_items = 8;
		else if (flags & ImGuiComboFlags_HeightSmall)  popup_max_height_in_items = 4;
		else if (flags & ImGuiComboFlags_HeightLarge)  popup_max_height_in_items = 20;
		SetNextWindowSizeConstraints(ImVec2(w, 0.0f), ImVec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)));
	}

	// This is essentially a specialized version of BeginPopupEx()
	char name[16];
	ImFormatString(name, IM_ARRAYSIZE(name), "##Combo_%02d", g.BeginPopupStack.Size); // Recycle windows based on depth

	// Set position given a custom constraint (peak into expected window size so we can position it)
	// FIXME: This might be easier to express with an hypothetical SetNextWindowPosConstraints() function?
	// FIXME: This might be moved to Begin() or at least around the same spot where Tooltips and other Popups are calling FindBestWindowPosForPopupEx()?
	if (ImGuiWindow* popup_window = FindWindowByName(name))
		if (popup_window->WasActive)
		{
			// Always override 'AutoPosLastDirection' to not leave a chance for a past value to affect us.
			ImVec2 size_expected = CalcWindowNextAutoFitSize(popup_window);
			popup_window->AutoPosLastDirection = (flags & ImGuiComboFlags_PopupAlignLeft) ? ImGuiDir_Left : ImGuiDir_Down; // Left = "Below, Toward Left", Down = "Below, Toward Right (default)"
			ImRect r_outer = GetPopupAllowedExtentRect(popup_window);
			ImVec2 pos = FindBestWindowPosForPopupEx(bb.GetBL(), size_expected, &popup_window->AutoPosLastDirection, r_outer, bb, ImGuiPopupPositionPolicy_ComboBox);
			SetNextWindowPos(pos);
		}

	// We don't use BeginPopupEx() solely because we have a custom name string, which we could make an argument to BeginPopupEx()
	ImGuiWindowFlags window_flags = ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_Popup | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoMove;
	PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(g.Style.FramePadding.x, g.Style.WindowPadding.y)); // Horizontally align ourselves with the framed text
	bool ret = Begin(name, NULL, window_flags);
	PopStyleVar();
	if (!ret)
	{
		EndPopup();
		IM_ASSERT(0);   // This should never happen as we tested for IsPopupOpen() above
		return false;
	}
	return true;
}

void ImGui::Animations::RenderCheckMarkExtra(ImDrawList* draw_list, ImVec2 pos, ImU32 col, float sz, float thickness_extra)
{
	float thickness = ImMax(sz * thickness_extra / 5.0f, 1.0f) * thickness_extra;
	sz -= thickness * 0.5f;
	pos += ImVec2(thickness * 0.25f, thickness * 0.25f);

	float third = sz / 3.0f;
	float bx = pos.x + third;
	float by = pos.y + sz - third * 0.5f;
	draw_list->PathLineTo(ImVec2(bx - third, by - third));
	draw_list->PathLineTo(ImVec2(bx, by));
	draw_list->PathLineTo(ImVec2(bx + third * 2.0f, by - third * 2.0f));
	draw_list->PathStroke(col, 0, thickness);
}

void ImGui::Animations::RenderFrameAlpha(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border, float rounding, float alpha)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	ImColor color(fill_col);
	color.Value.w = alpha;
	window->DrawList->AddRectFilled(p_min, p_max, color, rounding);
	const float border_size = g.Style.FrameBorderSize;
	if (border && border_size > 0.0f)
	{
		window->DrawList->AddRect(p_min + ImVec2(1, 1), p_max + ImVec2(1, 1), GetColorU32(ImGuiCol_BorderShadow, alpha), rounding, 0, border_size);
		window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border, alpha), rounding, 0, border_size);
	}
}

void ImGui::Animations::RenderFrameAlphaOutline(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border, float rounding, float alpha, float outline)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	ImColor color(fill_col);
	color.Value.w = alpha;
	window->DrawList->AddRectFilled(p_min, p_max, color, rounding);
	const float border_size = g.Style.FrameBorderSize;
	if (border && border_size > 0.0f)
	{
		window->DrawList->AddRect(p_min + ImVec2(1, 1), p_max + ImVec2(1, 1), GetColorU32(ImGuiCol_BorderShadow, outline), rounding, 0, border_size);
		window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border, outline), rounding, 0, border_size);
	}
}

void ImGui::Animations::RenderFrameOutlineKeepFill(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border, float rounding, float outline)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);
	const float border_size = g.Style.FrameBorderSize;
	if (border && border_size > 0.0f)
	{
		window->DrawList->AddRect(p_min + ImVec2(1, 1), p_max + ImVec2(1, 1), GetColorU32(ImGuiCol_BorderShadow, outline), rounding, 0, border_size);
		window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border, outline), rounding, 0, border_size);
	}
}

void ImGui::Animations::RenderTextAlpha(ImVec2 pos, const char* text, const char* text_end, bool hide_text_after_hash, float alpha)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;

	// Hide anything after a '##' string
	const char* text_display_end;
	if (hide_text_after_hash)
	{
		text_display_end = FindRenderedTextEnd(text, text_end);
	}
	else
	{
		if (!text_end)
			text_end = text + strlen(text); // FIXME-OPT
		text_display_end = text_end;
	}

	if (text != text_display_end)
	{
		window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text, alpha), text, text_display_end);
		if (g.LogEnabled)
			LogRenderedText(&pos, text, text_display_end);
	}
}

void ImGui::Animations::RenderFrameBorderAlpha(ImVec2 p_min, ImVec2 p_max, float rounding, float alpha)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	const float border_size = g.Style.FrameBorderSize;
	if (border_size > 0.0f)
	{
		window->DrawList->AddRect(p_min + ImVec2(1, 1), p_max + ImVec2(1, 1), GetColorU32(ImGuiCol_BorderShadow, alpha), rounding, 0, border_size);
		window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border, alpha), rounding, 0, border_size);
	}
}

void ImGui::Animations::Hotkey(const char* label, Key* key, bool useExtended, const ImVec2& size)
{
	ImGui::PushID(label);
	if (std::strncmp(label, "##", 2))
		ImGui::TextUnformatted(label, std::strstr(label, "##"));

	ImGui::SameLine();

	if (const auto id = ImGui::GetID(label); ImGui::GetActiveID() == id)
	{
		ImGui::Animations::Button("...", size);
		ImGui::GetCurrentContext()->ActiveIdAllowOverlap = true;

		if ((!ImGui::IsItemHovered() && ImGui::GetIO().MouseClicked[0]) || key->checkKey())
		{
			globals::isInHotkey = false;
			ImGui::ClearActiveID();
		}

	}
	else if (ImGui::Animations::Button(utilities::getKeyName(key->getKeyCode()).c_str(), size))
	{
		globals::isInHotkey = true;
		ImGui::SetActiveID(id, GetCurrentWindow());
	}
	else
	{
		if (useExtended)
		{
			if (ImGui::BeginPopup("##pop", ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoMove))
			{
				for (const auto [mode, name] : Key::getKeyPairs())
				{
					bool selected = key->getKeyMode() == mode;
					if (ImGui::Animations::Selectable(name, &selected))
					{
						if (selected)
							key->setKeyMode(mode);
					}
				}

				ImGui::EndPopup();
			}
			else if (IsItemHovered())
			{
				ImGui::SetTooltip("Key mode");

				if (ImGui::GetIO().MouseClicked[1])
					ImGui::OpenPopup("##pop");
			}
		}
	}

	ImGui::PopID();
}

bool ImGui::Animations::Checkbox(const char* label, bool* v)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID(label);
	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	const float square_sz = GetFrameHeight();
	const ImVec2 pos = window->DC.CursorPos;
	const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));
	ItemSize(total_bb, style.FramePadding.y);
	if (!ItemAdd(total_bb, id))
	{
		IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Checkable | (*v ? ImGuiItemStatusFlags_Checked : 0));
		return false;
	}

	bool hovered, held;
	bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);
	if (pressed)
	{
		*v = !(*v);
		MarkItemEdited(id);
	}

	const auto lastTime = getLastTime(id, held, pressed);
	const auto move = getMove(id, lastTime, held, pressed);
	const float temp = ImSaturate(lastTime * detail::speedMove);
	float checkmark = checkmark = *v ? temp : 0.0f;

	const ImColor frame_col = ImColor(GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg));
	const float limitAlpha = frame_col.Value.w;
	const float limitAlphaOutline = hovered ? 1.0f : 0.4f; // breaking on lower alphas...

	const auto alphas = getAlpha(id, AlphaLimits{ .alphaLimit = limitAlpha, .outlineLimit = limitAlphaOutline });

	const float size_frame_extra = 3.f * move.move;
	ImVec2 extra_size = ImVec2(size_frame_extra, size_frame_extra);

	const ImRect check_bb(pos, pos + ImVec2(square_sz, square_sz));
	const ImRect frame_bb(ImVec2(pos + extra_size), pos + ImVec2(square_sz, square_sz) - extra_size);
	RenderNavHighlight(total_bb, id);
	RenderFrameAlphaOutline(frame_bb.Min, frame_bb.Max, frame_col, true, style.FrameRounding, alphas.alpha, alphas.outline);

	ImU32 check_col = GetColorU32(ImGuiCol_CheckMark);
	bool mixed_value = (g.LastItemData.InFlags & ImGuiItemFlags_MixedValue) != 0;
	if (mixed_value)
	{
		// Undocumented tristate/mixed/indeterminate checkbox (#2644)
		// This may seem awkwardly designed because the aim is to make ImGuiItemFlags_MixedValue supported by all widgets (not just checkbox)
		ImVec2 pad(ImMax(1.0f, IM_FLOOR(square_sz / 3.6f)), ImMax(1.0f, IM_FLOOR(square_sz / 3.6f)));
		window->DrawList->AddRectFilled(check_bb.Min + pad, check_bb.Max - pad, check_col, style.FrameRounding);
	}
	else if (*v || checkmark > 0.0f)
	{
		const float pad = ImMax(1.0f, IM_FLOOR(square_sz / 6.0f));
		RenderCheckMarkExtra(window->DrawList, check_bb.Min + ImVec2(pad, pad), check_col, square_sz - pad * 2.0f, checkmark);
	}

	ImVec2 label_pos = ImVec2(check_bb.Max.x + style.ItemInnerSpacing.x, check_bb.Min.y + style.FramePadding.y);
	if (g.LogEnabled)
		LogRenderedText(&label_pos, mixed_value ? "[~]" : *v ? "[x]" : "[ ]");
	if (label_size.x > 0.0f)
		RenderText(label_pos, label);

	IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Checkable | (*v ? ImGuiItemStatusFlags_Checked : 0));
	return pressed;
}

bool ImGui::Animations::BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = GetCurrentWindow();

	ImGuiNextWindowDataFlags backup_next_window_data_flags = g.NextWindowData.Flags;
	g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values
	if (window->SkipItems)
		return false;

	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID(label);
	IM_ASSERT((flags & (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)) != (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)); // Can't use both flags together

	const float arrow_size = (flags & ImGuiComboFlags_NoArrowButton) ? 0.0f : GetFrameHeight();
	const ImVec2 label_size = CalcTextSize(label, NULL, true);
	const float w = (flags & ImGuiComboFlags_NoPreview) ? arrow_size : CalcItemWidth();
	const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));
	const ImRect total_bb(bb.Min, bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));
	ItemSize(total_bb, style.FramePadding.y);
	if (!ItemAdd(total_bb, id, &bb))
		return false;

	// Open on click
	bool hovered, held;
	bool pressed = ButtonBehavior(bb, id, &hovered, &held);
	const ImGuiID popup_id = ImHashStr("##ComboPopup", 0, id);
	bool popup_open = IsPopupOpen(popup_id, ImGuiPopupFlags_None);
	if (pressed && !popup_open)
	{
		OpenPopupEx(popup_id, ImGuiPopupFlags_None);
		popup_open = true;
	}

	const float limitAlpha = ImColor(GetColorU32(hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg)).Value.w;
	const float limitAlphaOutline = hovered || popup_open ? 1.0f : 0.4f; // breaking on lower alphas...

	const auto alphas = getAlpha(id, AlphaLimits{ .alphaLimit = limitAlpha, .outlineLimit = limitAlphaOutline });
	const float limitPop = popup_open ? 1.0f : 0.0f;
	const auto pop = getSingleAnimation(id, limitPop, detail::speedPop, 6.0f); // lerping with normal time will be slow

	// Render shape
	const ImColor frame_col = ImColor(GetColorU32(hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg));
	const float value_x2 = ImMax(bb.Min.x, bb.Max.x - arrow_size);
	RenderNavHighlight(bb, id);
	if (!(flags & ImGuiComboFlags_NoPreview))
		window->DrawList->AddRectFilled(bb.Min, ImVec2(ImMax(bb.Min.x, bb.Max.x - 1.0f), bb.Max.y), frame_col, style.FrameRounding);
	if (!(flags & ImGuiComboFlags_NoArrowButton))
	{
		//ImU32 bg_col = GetColorU32((popup_open || hovered) ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
		ImU32 text_col = GetColorU32(ImGuiCol_Text, alphas.alpha);
		//window->DrawList->AddRectFilled(ImVec2(value_x2, bb.Min.y), bb.Max, bg_col, style.FrameRounding, (w <= arrow_size) ? ImDrawFlags_RoundCornersAll : ImDrawFlags_RoundCornersRight);
		if (value_x2 + arrow_size - style.FramePadding.x <= bb.Max.x)
			RenderArrow(window->DrawList, ImVec2(value_x2 + style.FramePadding.y, bb.Min.y + style.FramePadding.y), text_col, ImGuiDir_Down, -IM_PI * pop.value, 1.0f);
	}
	RenderFrameBorderAlpha(bb.Min, bb.Max, style.FrameRounding, alphas.outline);

	// Custom preview
	if (flags & ImGuiComboFlags_CustomPreview)
	{
		g.ComboPreviewData.PreviewRect = ImRect(bb.Min.x, bb.Min.y, value_x2, bb.Max.y);
		IM_ASSERT(preview_value == NULL || preview_value[0] == 0);
		preview_value = NULL;
	}

	// Render preview and label
	if (preview_value != NULL && !(flags & ImGuiComboFlags_NoPreview))
	{
		if (g.LogEnabled)
			LogSetNextTextDecoration("{", "}");
		RenderTextClipped(bb.Min + style.FramePadding, ImVec2(value_x2, bb.Max.y), preview_value, NULL, NULL);
	}
	if (label_size.x > 0)
		RenderText(ImVec2(bb.Max.x + style.ItemInnerSpacing.x, bb.Min.y + style.FramePadding.y), label);

	if (!popup_open)
		return false;

	g.NextWindowData.Flags = backup_next_window_data_flags;
	return BeginComboPopup(popup_id, bb, flags, /*pop.value*/ 1.0f);
}

bool ImGui::Animations::ColorPicker(const char* label, CfgColor* clr)
{
	constexpr auto pickerFlags = ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_NoSidePreview | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaBar;
	constexpr auto pickerButtonFlags = ImGuiColorEditFlags_NoTooltip | ImGuiColorEditFlags_AlphaPreview;
	constexpr auto paletteButoonFlags = ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoPicker | ImGuiColorEditFlags_NoTooltip;

	bool toReturn = false;

	static std::array<Color, 32> palette = {};
	static auto bOnce = [=]()
	{
		for (size_t i = 0; auto & el : palette)
		{
			ImGui::ColorConvertHSVtoRGB(i / static_cast<float>(palette.size()), 1.0f, 1.0f,
				el.at(0), el.at(1), el.at(2));
			el.at(3) = 1.0f;

			i++;
		}
		return true;
	} ();

	ImGui::PushID(label);

	bool openPopup = ImGui::Animations::ColorButton("##colbut", ImVec4{ clr->getColor().r(), clr->getColor().g(), clr->getColor().b(), clr->getColor().a() }, pickerButtonFlags);

	if (std::strncmp(label, "##", 2))
	{
		ImGui::SameLine();
		ImGui::TextUnformatted(label, std::strstr(label, "##"));
	}

	if (openPopup)
		ImGui::OpenPopup("##colpop");

	if (ImGui::BeginPopup("##colpop"))
	{
		std::array col{ clr->getColor().r(), clr->getColor().g(), clr->getColor().b(), clr->getColor().a() };
		toReturn = ImGui::ColorPicker4("##colpicker", col.data(), pickerFlags);
		*clr = CfgColor{ col, clr->getRainbow(), clr->getSpeed() };

		ImGui::SameLine();

		constexpr int seperateLimit = 7;
		constexpr auto paletteButtonSize = ImVec2{ 20.0f, 20.0f };

		if (ImGui::BeginChild("##colorsaddon", { seperateLimit * paletteButtonSize.x, 0.0f }))
		{
			for (size_t i = 0; const auto & el : palette)
			{
				ImGui::PushID(i);
				if ((i % seperateLimit) != 0)
					ImGui::SameLine(0.0f, ImGui::GetStyle().ItemSpacing.y);

				if (ImGui::Animations::ColorButton("##palette", ImVec4{ el.r(), el.g(), el.b(), el.a() }, paletteButoonFlags, paletteButtonSize))
				{
					*clr = CfgColor{ Color{ el, clr->getColor().a() }, clr->getRainbow(), clr->getSpeed() };
					toReturn = true;
				}
				ImGui::PopID();

				i++;
			}

			ImGui::Checkbox("Rainbow mode", &clr->getRainbowRef());
			if (clr->getRainbow())
			{
				ImGui::PushItemWidth(seperateLimit * paletteButtonSize.x);
				ImGui::SliderFloat("##ranbowspeed", &clr->getSpeedRef(), 0.0f, 15.0f, "Speed %.1f", ImGuiSliderFlags_Logarithmic);
				ImGui::PopItemWidth();

				// apply return as updated color
				toReturn = true;
			}

			ImGui::EndChild();
		}

		ImGui::EndPopup();

	}
	ImGui::PopID();

	return toReturn;
}

bool ImGui::Animations::PopupButton(const char* label, const std::function<void()>& fun)
{
	ImGui::PushID(label);

	if (ImGui::Animations::Button("Options"))
		ImGui::OpenPopup("");

	bool ret = false;
	if (ImGui::BeginPopup(""))
	{
		fun();
		ret = true;

		ImGui::EndPopup();
	}

	ImGui::PopID();

	return ret;
}

bool ImGui::Animations::Selectable(const char* label, bool selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;

	// Submit label or explicit size to ItemSize(), whereas ItemAdd() will submit a larger/spanning rectangle.
	ImGuiID id = window->GetID(label);
	ImVec2 label_size = CalcTextSize(label, NULL, true);
	ImVec2 size(size_arg.x != 0.0f ? size_arg.x : label_size.x, size_arg.y != 0.0f ? size_arg.y : label_size.y);
	ImVec2 pos = window->DC.CursorPos;
	pos.y += window->DC.CurrLineTextBaseOffset;
	ItemSize(size, 0.0f);

	// Fill horizontal space
	// We don't support (size < 0.0f) in Selectable() because the ItemSpacing extension would make explicitly right-aligned sizes not visibly match other widgets.
	const bool span_all_columns = (flags & ImGuiSelectableFlags_SpanAllColumns) != 0;
	const float min_x = span_all_columns ? window->ParentWorkRect.Min.x : pos.x;
	const float max_x = span_all_columns ? window->ParentWorkRect.Max.x : window->WorkRect.Max.x;
	if (size_arg.x == 0.0f || (flags & ImGuiSelectableFlags_SpanAvailWidth))
		size.x = ImMax(label_size.x, max_x - min_x);

	// Text stays at the submission position, but bounding box may be extended on both sides
	const ImVec2 text_min = pos;
	const ImVec2 text_max(min_x + size.x, pos.y + size.y);

	// Selectables are meant to be tightly packed together with no click-gap, so we extend their box to cover spacing between selectable.
	ImRect bb(min_x, pos.y, text_max.x, text_max.y);
	if ((flags & ImGuiSelectableFlags_NoPadWithHalfSpacing) == 0)
	{
		const float spacing_x = span_all_columns ? 0.0f : style.ItemSpacing.x;
		const float spacing_y = style.ItemSpacing.y;
		const float spacing_L = IM_FLOOR(spacing_x * 0.50f);
		const float spacing_U = IM_FLOOR(spacing_y * 0.50f);
		bb.Min.x -= spacing_L;
		bb.Min.y -= spacing_U;
		bb.Max.x += (spacing_x - spacing_L);
		bb.Max.y += (spacing_y - spacing_U);
	}
	//if (g.IO.KeyCtrl) { GetForegroundDrawList()->AddRect(bb.Min, bb.Max, IM_COL32(0, 255, 0, 255)); }

	// Modify ClipRect for the ItemAdd(), faster than doing a PushColumnsBackground/PushTableBackground for every Selectable..
	const float backup_clip_rect_min_x = window->ClipRect.Min.x;
	const float backup_clip_rect_max_x = window->ClipRect.Max.x;
	if (span_all_columns)
	{
		window->ClipRect.Min.x = window->ParentWorkRect.Min.x;
		window->ClipRect.Max.x = window->ParentWorkRect.Max.x;
	}

	const bool disabled_item = (flags & ImGuiSelectableFlags_Disabled) != 0;
	const bool item_add = ItemAdd(bb, id, NULL, disabled_item ? ImGuiItemFlags_Disabled : ImGuiItemFlags_None);
	if (span_all_columns)
	{
		window->ClipRect.Min.x = backup_clip_rect_min_x;
		window->ClipRect.Max.x = backup_clip_rect_max_x;
	}

	if (!item_add)
		return false;

	const bool disabled_global = (g.CurrentItemFlags & ImGuiItemFlags_Disabled) != 0;
	if (disabled_item && !disabled_global) // Only testing this as an optimization
		BeginDisabled();

	// FIXME: We can standardize the behavior of those two, we could also keep the fast path of override ClipRect + full push on render only,
	// which would be advantageous since most selectable are not selected.
	if (span_all_columns && window->DC.CurrentColumns)
		PushColumnsBackground();
	else if (span_all_columns && g.CurrentTable)
		TablePushBackgroundChannel();

	// We use NoHoldingActiveID on menus so user can click and _hold_ on a menu then drag to browse child entries
	ImGuiButtonFlags button_flags = 0;
	if (flags & ImGuiSelectableFlags_NoHoldingActiveID) { button_flags |= ImGuiButtonFlags_NoHoldingActiveId; }
	if (flags & ImGuiSelectableFlags_SelectOnClick) { button_flags |= ImGuiButtonFlags_PressedOnClick; }
	if (flags & ImGuiSelectableFlags_SelectOnRelease) { button_flags |= ImGuiButtonFlags_PressedOnRelease; }
	if (flags & ImGuiSelectableFlags_AllowDoubleClick) { button_flags |= ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnDoubleClick; }
	if (flags & ImGuiSelectableFlags_AllowItemOverlap) { button_flags |= ImGuiButtonFlags_AllowItemOverlap; }

	const bool was_selected = selected;
	bool hovered, held;
	bool pressed = ButtonBehavior(bb, id, &hovered, &held, button_flags);

	// Auto-select when moved into
	// - This will be more fully fleshed in the range-select branch
	// - This is not exposed as it won't nicely work with some user side handling of shift/control
	// - We cannot do 'if (g.NavJustMovedToId != id) { selected = false; pressed = was_selected; }' for two reasons
	//   - (1) it would require focus scope to be set, need exposing PushFocusScope() or equivalent (e.g. BeginSelection() calling PushFocusScope())
	//   - (2) usage will fail with clipped items
	//   The multi-select API aim to fix those issues, e.g. may be replaced with a BeginSelection() API.
	if((flags & ImGuiSelectableFlags_SelectOnNav) && g.NavJustMovedToId != 0 && g.NavJustMovedToFocusScopeId == g.CurrentFocusScopeId)
		if (g.NavJustMovedToId == id)
			selected = pressed = true;

	// Update NavId when clicking or when Hovering (this doesn't happen on most widgets), so navigation can be resumed with gamepad/keyboard
	if (pressed || (hovered && (flags & ImGuiSelectableFlags_SetNavIdOnHover)))
	{
		if (!g.NavDisableMouseHover && g.NavWindow == window && g.NavLayer == window->DC.NavLayerCurrent)
		{
			SetNavID(id, window->DC.NavLayerCurrent, g.CurrentFocusScopeId, WindowRectAbsToRel(window, bb)); // (bb == NavRect)
			g.NavDisableHighlight = true;
		}
	}
	if (pressed)
		MarkItemEdited(id);

	if (flags & ImGuiSelectableFlags_AllowItemOverlap)
		SetItemAllowOverlap();

	// In this branch, Selectable() cannot toggle the selection so this will never trigger.
	if (selected != was_selected) //-V547
		g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_ToggledSelection;

	// Render
	/*if (hovered || selected)
	{
		const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);
		RenderFrame(bb.Min, bb.Max, col, false, 0.0f);
	}*/

	float limitAlpha = hovered || selected ? ImColor(GetColorU32(ImGuiCol_Text)).Value.w : ImColor(GetColorU32(ImGuiCol_Text)).Value.w * 0.65f;

	const auto alpha = getSingleAnimation(id, limitAlpha, detail::speedAlpha);

	RenderNavHighlight(bb, id, ImGuiNavHighlightFlags_TypeThin | ImGuiNavHighlightFlags_NoRounding);

	if (span_all_columns && window->DC.CurrentColumns)
		PopColumnsBackground();
	else if (span_all_columns && g.CurrentTable)
		TablePopBackgroundChannel();

	const auto ImGuiCol_TextSelectable = ImVec4{ 0.26f, 0.59f, 0.98f, alpha.value };
	const auto colText = ImGui::ColorConvertU32ToFloat4(GetColorU32(ImGuiCol_Text, alpha.value));

	PushStyleColor(ImGuiCol_Text, GetColorU32(selected ? ImGuiCol_TextSelectable : colText));
	RenderTextClipped(text_min, text_max, label, NULL, &label_size, style.SelectableTextAlign, &bb);
	PopStyleColor();

	// Automatically close popups
	if (pressed && (window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiSelectableFlags_DontClosePopups) && !(g.LastItemData.InFlags & ImGuiItemFlags_SelectableDontClosePopup))
		CloseCurrentPopup();

	if (disabled_item && !disabled_global)
		EndDisabled();

	IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
	return pressed; //-V1020
}

bool ImGui::Animations::Combo(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int popup_max_height_in_items)
{
	ImGuiContext& g = *GImGui;

	// Call the getter to obtain the preview string which is a parameter to BeginCombo()
	const char* preview_value = NULL;
	if (*current_item >= 0 && *current_item < items_count)
		items_getter(data, *current_item, &preview_value);

	// The old Combo() API exposed "popup_max_height_in_items". The new more general BeginCombo() API doesn't have/need it, but we emulate it here.
	if (popup_max_height_in_items != -1 && !(g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint))
		SetNextWindowSizeConstraints(ImVec2(0, 0), ImVec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)));

	if (!BeginCombo(label, preview_value, ImGuiComboFlags_None))
		return false;

	// Display items
	// FIXME-OPT: Use clipper (but we need to disable it on the appearing frame to make sure our call to SetItemDefaultFocus() is processed)
	bool value_changed = false;
	for (int i = 0; i < items_count; i++)
	{
		PushID(i);
		const bool item_selected = (i == *current_item);
		const char* item_text;
		if (!items_getter(data, i, &item_text))
			item_text = "*Unknown item*";
		if (Selectable(item_text, item_selected, 0, ImVec2(0, 0)))
		{
			value_changed = true;
			*current_item = i;
		}
		if (item_selected)
			SetItemDefaultFocus();
		PopID();
	}

	EndCombo();

	if (value_changed)
		MarkItemEdited(g.LastItemData.ID);

	return value_changed;
}

static bool Items_ArrayGetter(void* data, int idx, const char** out_text)
{
	const char* const* items = (const char* const*)data;
	if (out_text)
		*out_text = items[idx];
	return true;
}

bool ImGui::Animations::Combo(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items)
{
	const bool value_changed = Combo(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_in_items);
	return value_changed;
}

bool ImGui::Animations::SliderScalar(const char* label, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID(label);
	const float w = CalcItemWidth();

	const ImVec2 label_size = CalcTextSize(label, NULL, true);
	const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));
	const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	const bool temp_input_allowed = (flags & ImGuiSliderFlags_NoInput) == 0;
	ItemSize(total_bb, style.FramePadding.y);
	if (!ItemAdd(total_bb, id, &frame_bb, temp_input_allowed ? ImGuiItemFlags_Inputable : 0))
		return false;

	// Default format string when passing NULL
	if (format == NULL)
		format = DataTypeGetInfo(data_type)->PrintFmt;

	// Tabbing or CTRL-clicking on Slider turns it into an input box
	const bool hovered = ItemHoverable(frame_bb, id);
	bool temp_input_is_active = temp_input_allowed && TempInputIsActive(id);
	if (!temp_input_is_active)
	{
		const bool input_requested_by_tabbing = temp_input_allowed && (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_FocusedByTabbing) != 0;
		const bool clicked = (hovered && g.IO.MouseClicked[0]);
		if (input_requested_by_tabbing || clicked || g.NavActivateId == id || g.NavActivateInputId == id)
		{
			SetActiveID(id, window);
			SetFocusID(id, window);
			FocusWindow(window);
			g.ActiveIdUsingNavDirMask |= (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);
			if (temp_input_allowed && (input_requested_by_tabbing || (clicked && g.IO.KeyCtrl) || g.NavActivateInputId == id))
				temp_input_is_active = true;
		}
	}

	if (temp_input_is_active)
	{
		// Only clamp CTRL+Click input when ImGuiSliderFlags_AlwaysClamp is set
		const bool is_clamp_input = (flags & ImGuiSliderFlags_AlwaysClamp) != 0;
		return TempInputScalar(frame_bb, id, label, data_type, p_data, format, is_clamp_input ? p_min : NULL, is_clamp_input ? p_max : NULL);
	}

	//const float limitAlpha = ImColor(GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg)).Value.w;
	const float limitAlpha = ImColor(GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg)).Value.w;
	const float limitAlphaOutline = hovered ? 1.0f : 0.4f; // breaking on lower alphas...

	const auto alpha = getAlpha(id, AlphaLimits{ .alphaLimit = limitAlpha, .outlineLimit = limitAlphaOutline });

	// Draw frame
	const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
	RenderNavHighlight(frame_bb, id);
	RenderFrameAlphaOutline(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding, alpha.alpha, alpha.outline);

	// Slider behavior
	ImRect grab_bb;
	const bool value_changed = SliderBehavior(frame_bb, id, data_type, p_data, p_min, p_max, format, flags, &grab_bb);
	if (value_changed)
		MarkItemEdited(id);

	// Render grab
	if (grab_bb.Max.x > grab_bb.Min.x)
		window->DrawList->AddRectFilled(grab_bb.Min, grab_bb.Max, GetColorU32(hovered ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab, alpha.outline), style.GrabRounding);
	/*window->DrawList->AddCircleFilled(grab_bb.GetCenter(), (grab_bb.Max.y - grab_bb.Min.y) / 2.0f, GetColorU32(hovered ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab, outline), 32);*/

// Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
	char value_buf[64];
	const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, p_data, format);
	if (g.LogEnabled)
		LogSetNextTextDecoration("{", "}");
	RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.5f));

	if (label_size.x > 0.0f)
		RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
	return value_changed;
}

bool ImGui::Animations::SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format, ImGuiSliderFlags flags)
{
	return SliderScalar(label, ImGuiDataType_Float, v, &v_min, &v_max, format, flags);
}

bool ImGui::Animations::SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format, ImGuiSliderFlags flags)
{
	return SliderScalarN(label, ImGuiDataType_Float, v, 2, &v_min, &v_max, format, flags);
}

bool ImGui::Animations::SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format, ImGuiSliderFlags flags)
{
	return SliderScalarN(label, ImGuiDataType_Float, v, 3, &v_min, &v_max, format, flags);
}

bool ImGui::Animations::SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format, ImGuiSliderFlags flags)
{
	return SliderScalarN(label, ImGuiDataType_Float, v, 4, &v_min, &v_max, format, flags);
}

bool ImGui::Animations::SliderAngle(const char* label, float* v_rad, float v_degrees_min, float v_degrees_max, const char* format, ImGuiSliderFlags flags)
{
	if (format == NULL)
		format = "%.0f deg";
	float v_deg = (*v_rad) * 360.0f / (2 * IM_PI);
	bool value_changed = SliderFloat(label, &v_deg, v_degrees_min, v_degrees_max, format, flags);
	*v_rad = v_deg * (2 * IM_PI) / 360.0f;
	return value_changed;
}

bool ImGui::Animations::SliderInt(const char* label, int* v, int v_min, int v_max, const char* format, ImGuiSliderFlags flags)
{
	return SliderScalar(label, ImGuiDataType_S32, v, &v_min, &v_max, format, flags);
}

bool ImGui::Animations::SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* format, ImGuiSliderFlags flags)
{
	return SliderScalarN(label, ImGuiDataType_S32, v, 2, &v_min, &v_max, format, flags);
}

bool ImGui::Animations::SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* format, ImGuiSliderFlags flags)
{
	return SliderScalarN(label, ImGuiDataType_S32, v, 3, &v_min, &v_max, format, flags);
}

bool ImGui::Animations::SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* format, ImGuiSliderFlags flags)
{
	return SliderScalarN(label, ImGuiDataType_S32, v, 4, &v_min, &v_max, format, flags);
}

bool ImGui::Animations::ButtonEx(const char* label, const ImVec2& size_arg, ImGuiButtonFlags flags)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID(label);
	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	ImVec2 pos = window->DC.CursorPos;
	if ((flags & ImGuiButtonFlags_AlignTextBaseLine) && style.FramePadding.y < window->DC.CurrLineTextBaseOffset) // Try to vertically align buttons that are smaller/have no padding so that text baseline matches (bit hacky, since it shouldn't be a flag)
		pos.y += window->DC.CurrLineTextBaseOffset - style.FramePadding.y;
	ImVec2 size = CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.0f, label_size.y + style.FramePadding.y * 2.0f);

	const ImRect bb(pos, pos + size);
	ItemSize(size, style.FramePadding.y);
	if (!ItemAdd(bb, id))
		return false;

	if (g.LastItemData.InFlags & ImGuiItemFlags_ButtonRepeat)
		flags |= ImGuiButtonFlags_Repeat;

	bool hovered, held;
	bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);

	const auto lastTime = getLastTime(id, held, pressed);
	const auto move = getMove(id, lastTime, held, pressed);

	const ImColor frame_col = ImColor(GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button));
	const float limitAlpha = frame_col.Value.w;
	const float limitAlphaOutline = hovered ? 1.0f : 0.4f; // breaking on lower alphas...

	const auto alphas = getAlpha(id, AlphaLimits{ .alphaLimit = limitAlpha, .outlineLimit = limitAlphaOutline });

	const float size_frame_extra = 3.f * move.move;
	ImVec2 extra_size = ImVec2(size_frame_extra, size_frame_extra);

	const ImRect frame_bb(ImVec2(pos + extra_size), pos + size - extra_size);

	// Render
	const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
	RenderNavHighlight(bb, id);
	RenderFrameAlphaOutline(frame_bb.Min, frame_bb.Max, col, true, style.FrameRounding, alphas.alpha, alphas.outline);

	if (g.LogEnabled)
		LogSetNextTextDecoration("[", "]");
	const ImVec2 pos_min = frame_bb.Min + style.FramePadding - (frame_bb.Min - bb.Min);
	const ImVec2 pos_max = frame_bb.Max - style.FramePadding - (frame_bb.Max - bb.Max);
	// I tried changing font size dynamically just for this text to use raw frame_bb.Min + style.FramePadding
	// for good effect it requires font reset, this thing wont be very friendly for cpu
	RenderTextClipped(pos_min, pos_max, label, NULL, &label_size, style.ButtonTextAlign, &frame_bb);

	IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
	return pressed;
}

bool ImGui::Animations::Button(const char* label, const ImVec2& size_arg)
{
	return ButtonEx(label, size_arg, ImGuiButtonFlags_None);
}

bool ImGui::Animations::ListBox(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)
{
	ImGuiContext& g = *GImGui;

	// Calculate size from "height_in_items"
	if (height_in_items < 0)
		height_in_items = ImMin(items_count, 7);
	float height_in_items_f = height_in_items + 0.25f;
	ImVec2 size(0.0f, ImFloor(GetTextLineHeightWithSpacing() * height_in_items_f + g.Style.FramePadding.y * 2.0f));

	if (!BeginListBox(label, size))
		return false;

	// Assume all items have even height (= 1 line of text). If you need items of different height,
	// you can create a custom version of ListBox() in your code without using the clipper.
	bool value_changed = false;
	ImGuiListClipper clipper;
	clipper.Begin(items_count, GetTextLineHeightWithSpacing()); // We know exactly our line height here so we pass it as a minor optimization, but generally you don't need to.
	while (clipper.Step())
		for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
		{
			const char* item_text;
			if (!items_getter(data, i, &item_text))
				item_text = "*Unknown item*";

			PushID(i);
			const bool item_selected = (i == *current_item);
			if (Selectable(item_text, item_selected))
			{
				*current_item = i;
				value_changed = true;
			}
			if (item_selected)
				SetItemDefaultFocus();
			PopID();
		}
	EndListBox();

	if (value_changed)
		MarkItemEdited(g.LastItemData.ID);

	return value_changed;
}

bool ImGui::Animations::ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags, ImVec2 size)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiID id = window->GetID(desc_id);
	float default_size = GetFrameHeight();
	if (size.x == 0.0f)
		size.x = default_size;
	if (size.y == 0.0f)
		size.y = default_size;
	const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
	ItemSize(bb, (size.y >= default_size) ? g.Style.FramePadding.y : 0.0f);
	if (!ItemAdd(bb, id))
		return false;

	bool hovered, held;
	bool pressed = ButtonBehavior(bb, id, &hovered, &held);

	if (flags & ImGuiColorEditFlags_NoAlpha)
		flags &= ~(ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf);

	ImVec4 col_rgb = col;
	if (flags & ImGuiColorEditFlags_InputHSV)
		ColorConvertHSVtoRGB(col_rgb.x, col_rgb.y, col_rgb.z, col_rgb.x, col_rgb.y, col_rgb.z);

	ImVec4 col_rgb_without_alpha(col_rgb.x, col_rgb.y, col_rgb.z, 1.0f);
	float grid_step = ImMin(size.x, size.y) / 2.99f;
	float rounding = ImMin(g.Style.FrameRounding, grid_step * 0.5f);
	ImRect bb_inner = bb;
	float off = 0.0f;

	const auto lastTime = getLastTime(id, held, pressed);
	const auto move = getMove(id, lastTime, held, pressed);

	const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
	const float limitAlpha = ImColor(frame_col).Value.w;
	const float limitAlphaOutline = hovered ? 1.0f : 0.4f; // breaking on lower alphas...

	const auto alphas = getAlpha(id, AlphaLimits{ .alphaLimit = limitAlpha, .outlineLimit = limitAlphaOutline });

	const float size_frame_extra = 3.f * move.move;
	ImVec2 extra_size = ImVec2(size_frame_extra, size_frame_extra);

	if ((flags & ImGuiColorEditFlags_NoBorder) == 0)
	{
		off = -0.75f; // The border (using Col_FrameBg) tends to look off when color is near-opaque and rounding is enabled. This offset seemed like a good middle ground to reduce those artifacts.
		bb_inner.Expand(off);
	}
	if ((flags & ImGuiColorEditFlags_AlphaPreviewHalf) && col_rgb.w < 1.0f)
	{
		float mid_x = IM_ROUND((bb_inner.Min.x + bb_inner.Max.x) * 0.5f);
		RenderColorRectWithAlphaCheckerboard(window->DrawList, ImVec2(bb_inner.Min.x + grid_step, bb_inner.Min.y) + extra_size, bb_inner.Max - extra_size, GetColorU32(col_rgb), grid_step, ImVec2(-grid_step + off, off), rounding, ImDrawFlags_RoundCornersRight);
		window->DrawList->AddRectFilled(ImVec2(bb_inner.Min.x + grid_step, bb_inner.Min.y) + extra_size, bb_inner.Max - extra_size, GetColorU32(col_rgb), rounding, ImDrawFlags_RoundCornersLeft);
	}
	else
	{
		// Because GetColorU32() multiplies by the global style Alpha and we don't want to display a checkerboard if the source code had no alpha
		ImVec4 col_source = (flags & ImGuiColorEditFlags_AlphaPreview) ? col_rgb : col_rgb_without_alpha;
		if (col_source.w < 1.0f)
			RenderColorRectWithAlphaCheckerboard(window->DrawList, bb_inner.Min + extra_size, bb_inner.Max - extra_size, GetColorU32(col_source), grid_step, ImVec2(off, off), rounding);
		else
			window->DrawList->AddRectFilled(bb_inner.Min + extra_size, bb_inner.Max - extra_size, GetColorU32(col_source), rounding);
	}
	RenderNavHighlight(bb, id);
	if ((flags & ImGuiColorEditFlags_NoBorder) == 0)
	{
		if (g.Style.FrameBorderSize > 0.0f)
			RenderFrameBorderAlpha(bb.Min + extra_size, bb.Max - extra_size, rounding, alphas.outline);
		else
			window->DrawList->AddRect(bb.Min + extra_size, bb.Max - extra_size, GetColorU32(ImGuiCol_FrameBg, alphas.outline), rounding); // Color button are often in need of some sort of border
	}

	// Drag and Drop Source
	// NB: The ActiveId test is merely an optional micro-optimization, BeginDragDropSource() does the same test.
	if (g.ActiveId == id && !(flags & ImGuiColorEditFlags_NoDragDrop) && BeginDragDropSource())
	{
		if (flags & ImGuiColorEditFlags_NoAlpha)
			SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F, &col_rgb, sizeof(float) * 3, ImGuiCond_Once);
		else
			SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F, &col_rgb, sizeof(float) * 4, ImGuiCond_Once);
		ColorButton(desc_id, col, flags);
		SameLine();
		TextEx("Color");
		EndDragDropSource();
	}

	// Tooltip
	if (!(flags & ImGuiColorEditFlags_NoTooltip) && hovered)
		ColorTooltip(desc_id, &col.x, flags & (ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf));

	return pressed;
}
```

`hack/menu/GUI-ImGui/animations.hpp`:

```hpp
#pragma once

#include <imgui.h>
#include <imgui_internal.h>

#include <unordered_map>
#include <functional>
#include <span>

class CfgColor;
class Key;

namespace ImGui
{
	namespace Animations
	{
		namespace detail
		{
			inline float speedAlpha = 0.0f;
			inline float speedOutline = 0.0f;
			inline float speedPop = 0.0f;
			inline float speedMove = 10.0f;
		}
		void setAnimationSpeeds();

		struct AlphaAnimation
		{
			float alpha{};
			float outline{};
		};

		struct MoveAnimation
		{
			float move{};
		};

		struct AlphaLimits
		{
			float alphaLimit{};
			float outlineLimit{};
		};

		struct SingleAnimation
		{
			float value{};
		};

		struct SingleField
		{
			float value{};
		};

		inline std::unordered_map<ImGuiID, AlphaAnimation> alphas;
		inline std::unordered_map<ImGuiID, MoveAnimation> moves;
		inline std::unordered_map<ImGuiID, SingleAnimation> singleAnim;
		inline std::unordered_map<ImGuiID, SingleField> singleFields;
		inline std::unordered_map<ImGuiID, float> timeStack; // fixed widget time based on their id. Not using it globally

		// functions seperated, don't return Animation as object. Instead contruct it on own in widget
		[[nodiscard]] AlphaAnimation getAlpha(ImGuiID id, const AlphaLimits& limits);
		[[nodiscard]] MoveAnimation getMove(ImGuiID id, float lastTime, bool held, bool pressed);
		[[nodiscard]] SingleAnimation getSingleAnimation(ImGuiID id, float max, float duration, float extraSpped = 1.0f);
		[[nodiscard]] SingleField getAndUpdateSingleField(ImGuiID id, float value);
		[[nodiscard]] float getLastTime(ImGuiID id, bool held, bool pressed);
		template<typename T>
		[[nodiscard]] static inline T ImLerpSmooth(T a, T b, float t, float smoothness);

		template<class T>
		concept dataLike = requires(T t)
		{
			t.size();
			t.data();
			t.begin();
			t.end();
		};

		void Hotkey(const char* label, Key* key, bool useExtended = true, const ImVec2& size = { 0.0f, 0.0f });
		bool Checkbox(const char* label, bool* v);
		bool BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags = 0);
		bool Combo(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items);
		bool Combo(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int popup_max_height_in_items);
		template<dataLike T>
		bool Combo(const char* label, int* item, const T& data, int height_in_items = -1);
		template<dataLike T>
		bool ListBox(const char* label, int* item, const T& data, int height_in_items = -1);
		template<typename T, size_t SIZE>
		requires (SIZE > 0U)
		void MultiCombo(const char* label, const std::array<T, SIZE>& names, std::array<bool, SIZE>* options);
		bool SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format = "%.3f", ImGuiSliderFlags flags = 0);     // adjust format to decorate the value with a prefix or a suffix for in-slider labels or unit display.
		bool SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
		bool SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
		bool SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
		bool SliderAngle(const char* label, float* v_rad, float v_degrees_min = -360.0f, float v_degrees_max = +360.0f, const char* format = "%.0f deg", ImGuiSliderFlags flags = 0);
		bool SliderInt(const char* label, int* v, int v_min, int v_max, const char* format = "%d", ImGuiSliderFlags flags = 0);
		bool SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* format = "%d", ImGuiSliderFlags flags = 0);
		bool SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* format = "%d", ImGuiSliderFlags flags = 0);
		bool SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* format = "%d", ImGuiSliderFlags flags = 0);
		bool SliderScalar(const char* label, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format = NULL, ImGuiSliderFlags flags = 0);
		bool ButtonEx(const char* label, const ImVec2& size_arg, ImGuiButtonFlags flags);
		bool Button(const char* label, const ImVec2& size_arg = ImVec2(0, 0));
		bool ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2(0, 0));
		bool ListBox(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items);
		// heavily based on code from demo, look "palette" in imgui demo file
		bool ColorPicker(const char* label, CfgColor* clr);
		bool PopupButton(const char* label, const std::function<void()>& fun);

		bool Selectable(const char* label, bool selected, ImGuiSelectableFlags flags = 0, const ImVec2& size_arg = ImVec2(0, 0));
		void RenderTextAlpha(ImVec2 pos, const char* text, const char* text_end, bool hide_text_after_hash, float alpha);
		void RenderCheckMarkExtra(ImDrawList* draw_list, ImVec2 pos, ImU32 col, float sz, float thickness_extra);
		void RenderFrameAlpha(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border, float rounding, float alpha);
		void RenderFrameAlphaOutline(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border, float rounding, float alpha, float outline);
		void RenderFrameOutlineKeepFill(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border, float rounding, float outline);
		void RenderFrameBorderAlpha(ImVec2 p_min, ImVec2 p_max, float rounding, float alpha);
		void RenderArrow(ImDrawList* draw_list, ImVec2 pos, ImU32 col, ImGuiDir dir, float angle, float scale);
		bool BeginComboPopup(ImGuiID popup_id, const ImRect& bb, ImGuiComboFlags flags, float pop);
	}
}

template<typename T, size_t SIZE>
	requires (SIZE > 0U)
void ImGui::Animations::MultiCombo(const char* label, const std::array<T, SIZE>& names, std::array<bool, SIZE>* options)
{
	ImVector<T> actives = {};
	for (size_t i = 0; const auto el : *options)
	{
		if (el) // if active selected
			actives.push_back(names[i]);

		i++;
	}

	std::string previewName = "";
	for (int i = 0; const auto & el : actives)
	{
		previewName += el;

		if (i < actives.size() - 1) // add ", " on every option but not last
			previewName += ", ";

		i++;
	}

	if (ImGui::Animations::BeginCombo(label, previewName.c_str()))
	{
		for (size_t i = 0; i < SIZE; i++) // creating view to make it "forced" to detect it as valid function args
		{
			if (ImGui::Animations::Selectable(std::string_view{ names[i] }.data(), options->at(i), ImGuiSelectableFlags_DontClosePopups))
				options->at(i) = !options->at(i);
		}

		ImGui::EndCombo();
	}
}

template<ImGui::Animations::dataLike T>
bool ImGui::Animations::Combo(const char* label, int* item, const T& data, int height_in_items)
{
	using typeContainer = typename std::decay<decltype(*data.begin())>::type;

	auto getter_arr = [](void* data, int idx, const char** out)
	{
		auto& v = *static_cast<T*>(data);

		if (out)
		{
			if constexpr (std::is_same_v<typeContainer, std::string>)
				*out = v[idx].c_str();
			else if constexpr (std::is_same_v<typeContainer, std::string_view>)
				*out = v[idx].data();
			else
				*out = v[idx];
		}
		return true;
	};

	return ImGui::Animations::Combo(label, item, getter_arr, const_cast<void*>(reinterpret_cast<const void*>(&data)), data.size(), height_in_items);
}

template<ImGui::Animations::dataLike T>
bool ImGui::Animations::ListBox(const char* label, int* item, const T& data, int height_in_items)
{
	using typeContainer = typename std::decay<decltype(*data.begin())>::type;

	auto getter_arr = [](void* data, int idx, const char** out)
	{
		auto& v = *static_cast<T*>(data);

		if (out)
		{
			if constexpr (std::is_same_v<typeContainer, std::string>)
				*out = v[idx].c_str();
			else if constexpr (std::is_same_v<typeContainer, std::string_view>)
				*out = v[idx].data();
			else
				*out = v[idx];
		}
		return true;
	};

	return ImGui::Animations::ListBox(label, item, getter_arr, const_cast<void*>(reinterpret_cast<const void*>(&data)), data.size(), height_in_items);
}

template<typename T>
static inline T ImGui::Animations::ImLerpSmooth(T a, T b, float t, float smoothness)
{
	t = (t > 1.0f) ? 1.0f : ((t < 0.0f) ? 0.0f : t);
	float interp = t * t * (3.0f - 2.0f * t);
	return (T)(a + (b - a) * (interp * smoothness + (1.0f - smoothness) * t));
}
```

`hack/menu/GUI-ImGui/background.cpp`:

```cpp
#include "background.hpp"

#include "menu.hpp"

#include <imgui.h>
#include <cheats/game/globals.hpp>
#include <utilities/utilities.hpp>
#include <utilities/rand.hpp>
#include <config/vars.hpp>

void Background::drawLine(const Vec2& start, const Vec2& end, const Color& color, float thickness)
{
	m_draw->AddLine(ImVec2{ start[Coord::X], start[Coord::Y] }, ImVec2{ end[Coord::X], end[Coord::Y] }, Color::U32(color), thickness);
}

void Background::drawCircleFilled(const Vec2& pos, float radius, size_t points, const Color& color)
{
	m_draw->AddCircleFilled(ImVec2{ pos[Coord::X], pos[Coord::Y] }, radius, Color::U32(color), points);
}

void Background::drawRectFilled(float x, float y, float width, float height, const Color& color)
{
	m_draw->AddRectFilled(ImVec2{ x, y }, ImVec2{ x + width, y + height }, Color::U32(color));
}

void Background::init()
{
	m_size = static_cast<size_t>(vars::styling->size);
	m_maxDistLines = vars::styling->distance;
	m_colorArr =
	{
		vars::styling->color1(),
		vars::styling->color2(),
		vars::styling->color3()
	};

	pushRandomPoints();
}

void Background::pushRandomPoints()
{
	m_particleArr.clear();

	float speed = vars::styling->speed;
	for (size_t i = 0; i < m_size; i++)
	{
		m_particleArr.emplace_back(
			ParticlePoint_t
			{
				Vec2{ static_cast<float>(Random::getRandom<size_t>(0, globals::screenX)), static_cast<float>(Random::getRandom<size_t>(0, globals::screenY)) }, // pos
				Vec2{ Random::getRandom<float>(-0.1f, 0.1f) * speed, Random::getRandom<float>(-0.1f, 0.1f) * speed }, // move
				Color	{ m_colorArr.at(Random::getRandom<size_t>(0, m_colorArr.size() - 1)) } // color
			});
	}
}

void Background::update(ParticlePoint_t& particle)
{
	if (particle.m_pos[Coord::X] > globals::screenX || particle.m_pos[Coord::X] < 0)
		particle.m_move[Coord::X] = -particle.m_move[Coord::X];

	if (particle.m_pos[Coord::Y] > globals::screenY || particle.m_pos[Coord::Y] < 0)
		particle.m_move[Coord::Y] = -particle.m_move[Coord::Y];

	particle.m_pos += particle.m_move;
}

void Background::find(ParticlePoint_t& particle)
{
	for (auto& el : m_particleArr)
	{
		if (auto dis = particle.m_pos.distTo(el.m_pos); dis < m_maxDistLines)
		{
			el.m_alpha = (m_maxDistLines - dis) / m_maxDistLines;
			drawLine(particle.m_pos, el.m_pos, particle.m_color.getColorEditAlpha(el.m_alpha));
		}
	}
}

void Background::draw(ImDrawList* _draw)
{
	if (globals::isShutdown)
		return;

	m_draw = _draw;

	static bool bOnce = [this]() // init
	{		
		init();

		return true;
	} ();

	if (!menu.isMenuActive())
		return;

	if (!vars::styling->background)
		return;

	drawRectFilled(0.0f, 0.0f, static_cast<float>(globals::screenX), static_cast<float>(globals::screenY), Colors::Grey);

	for (auto& el : m_particleArr)
	{
		update(el);
		find(el);
		drawCircleFilled(el.m_pos, 2, 6, Colors::Black);
	}
}
```

`hack/menu/GUI-ImGui/background.hpp`:

```hpp
#pragma once

#include <vector>

#include <render/Color.hpp>
#include <SDK/math/Vector.hpp>

struct ImDrawList;

struct ParticlePoint_t
{
	constexpr ParticlePoint_t(const Vec2& pos, const Vec2& move, const Color& color) :
		m_pos{ pos }, m_move{ move }, m_color{ color }
	{}

	Vec2 m_pos; // actual pos to draw
	Vec2 m_move; // how much to move the element +/- need small values!
	Color m_color;
	float m_alpha = 1.0f;
};

class Background
{
public:
	Background() = default;

	constexpr Background(size_t size, float maxDist, const std::vector<Color>& colorArr) :
		m_size{ size }, m_maxDistLines{ maxDist }, m_colorArr{ colorArr }
	{}

	void draw(ImDrawList* _draw);
	void init();
private:
	void pushRandomPoints();
	void update(ParticlePoint_t& particle);
	void find(ParticlePoint_t& particle);
	void drawLine(const Vec2& start, const Vec2& end, const Color& color, float thickness = 1.0f);
	void drawCircleFilled(const Vec2& pos, float radius, size_t points, const Color& color);
	void drawRectFilled(float x, float y, float width, float height, const Color& color);

	size_t m_size; // how many particless
	float m_maxDistLines; // dist between

	std::vector<ParticlePoint_t> m_particleArr;
	std::vector<Color> m_colorArr; // temp limited usage, FIXME

	ImDrawList* m_draw;
};

inline Background background;
```

`hack/menu/GUI-ImGui/imguiaddons.cpp`:

```cpp
#include "imguiaddons.hpp"

#include "menu.hpp"

#include <config/config.hpp>
#include <utilities/utilities.hpp>
#include <cheats/game/globals.hpp>

void ImGui::HelpMarker(const char* desc)
{
	ImGui::TextDisabled("(?)");
	if (ImGui::IsItemHovered())
	{
		ImGui::BeginTooltip();
		ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
		ImGui::TextUnformatted(desc);
		ImGui::PopTextWrapPos();
		ImGui::EndTooltip();
	}
}

#include <config/cfgcolor.hpp>

#include <config/vars.hpp>
#include <unordered_map>
#include <render/render.hpp>
#include <deps/ImGui/extraDraw.hpp>
#include <imgui_internal.h>

static std::unordered_map<ImGuiID, std::pair<ImVec2, ImVec2>> m_mapSizes = {};
static const char* g_GroupPanelName = nullptr;
static ImVector<ImRect> s_GroupPanelLabelStack;

void ImGui::BeginGroupPanel(const char* name, const ImVec2& size)
{
	g_GroupPanelName = name;

	auto id = ImGui::GetCurrentWindow()->GetID(name);
	auto [min, max] = m_mapSizes[id];

	ImGui::ExtraDrawlist::AddRectFilledMultiColor(
		ImGui::GetWindowDrawList(),
		min, max,
		Color::U32(vars::styling->groupPanelBackground[0]()),
		Color::U32(vars::styling->groupPanelBackground[1]()),
		Color::U32(vars::styling->groupPanelBackground[2]()),
		Color::U32(vars::styling->groupPanelBackground[3]()),
		ImGui::GetStyle().FrameRounding
	);

	ImGui::BeginGroup();

	auto cursorPos = ImGui::GetCursorScreenPos();
	auto itemSpacing = ImGui::GetStyle().ItemSpacing;
	ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0.0f, 0.0f));
	ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.0f, 0.0f));

	auto frameHeight = ImGui::GetFrameHeight();
	ImGui::BeginGroup();

	ImVec2 effectiveSize = size;
	if (size.x < 0.0f)
		effectiveSize.x = ImGui::GetContentRegionAvail().x;
	else
		effectiveSize.x = size.x;
	ImGui::Dummy(ImVec2(effectiveSize.x, 0.0f));

	ImGui::Dummy(ImVec2(frameHeight * 0.5f, 0.0f));
	ImGui::SameLine(0.0f, 0.0f);
	ImGui::BeginGroup();
	ImGui::Dummy(ImVec2(frameHeight * 0.5f, 0.0f));
	ImGui::SameLine(0.0f, 0.0f);
	ImGui::PushFont(ImFonts::tahoma20);
	ImGui::TextUnformatted(name);
	ImGui::PopFont();
	auto labelMin = ImGui::GetItemRectMin();
	auto labelMax = ImGui::GetItemRectMax();
	ImGui::SameLine(0.0f, 0.0f);
	ImGui::Dummy(ImVec2(0.0, frameHeight + itemSpacing.y));
	ImGui::BeginGroup();

	//ImGui::GetWindowDrawList()->AddRect(labelMin, labelMax, IM_COL32(255, 0, 255, 255));

	ImGui::PopStyleVar(2);

	ImGui::GetCurrentWindow()->ContentRegionRect.Max.x -= frameHeight * 0.5f;
	ImGui::GetCurrentWindow()->WorkRect.Max.x -= frameHeight * 0.5f;
	ImGui::GetCurrentWindow()->InnerRect.Max.x -= frameHeight * 0.5f;

	ImGui::GetCurrentWindow()->Size.x -= frameHeight;

	auto itemWidth = ImGui::CalcItemWidth();
	ImGui::PushItemWidth(ImMax(0.0f, itemWidth - frameHeight));

	s_GroupPanelLabelStack.push_back(ImRect(labelMin, labelMax));
}

void ImGui::EndGroupPanel()
{
	ImGui::PopItemWidth();

	auto itemSpacing = ImGui::GetStyle().ItemSpacing;

	ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0.0f, 0.0f));
	ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.0f, 0.0f));

	auto frameHeight = ImGui::GetFrameHeight();

	ImGui::EndGroup();

	//ImGui::GetWindowDrawList()->AddRectFilled(ImGui::GetItemRectMin(), ImGui::GetItemRectMax(), IM_COL32(0, 255, 0, 64), 4.0f);

	ImGui::EndGroup();

	ImGui::SameLine(0.0f, 0.0f);
	ImGui::Dummy(ImVec2(frameHeight * 0.5f, 0.0f));
	ImGui::Dummy(ImVec2(0.0, frameHeight - frameHeight * 0.5f - itemSpacing.y));

	ImGui::EndGroup();

	auto itemMin = ImGui::GetItemRectMin();
	auto itemMax = ImGui::GetItemRectMax();
	//ImGui::GetWindowDrawList()->AddRectFilled(itemMin, itemMax, IM_COL32(255, 0, 0, 64), 4.0f);

	auto labelRect = s_GroupPanelLabelStack.back();
	s_GroupPanelLabelStack.pop_back();

	ImVec2 halfFrame = ImVec2(frameHeight * 0.25f, frameHeight) * 0.5f;
	ImRect frameRect = ImRect(itemMin + halfFrame, itemMax + ImVec2{ 0.0f, 2.0f });
	labelRect.Min.x -= itemSpacing.x;
	labelRect.Max.x += itemSpacing.x;
	const auto colorLine = Color::U32(vars::styling->groupPanelLines());
	for (int i = 0; i < 4; ++i)
	{
		switch (i)
		{
			// left half-plane
		case 0: ImGui::PushClipRect(ImVec2(-FLT_MAX, -FLT_MAX), ImVec2(labelRect.Min.x, FLT_MAX), true); break;
			// right half-plane
		case 1: ImGui::PushClipRect(ImVec2(labelRect.Max.x, -FLT_MAX), ImVec2(FLT_MAX, FLT_MAX), true); break;
			// top
		case 2: ImGui::PushClipRect(ImVec2(labelRect.Min.x, -FLT_MAX), ImVec2(labelRect.Max.x, labelRect.Min.y), true); break;
			// bottom
		case 3: ImGui::PushClipRect(ImVec2(labelRect.Min.x, labelRect.Max.y), ImVec2(labelRect.Max.x, FLT_MAX), true); break;
		}

		ImGui::GetWindowDrawList()->AddRect(
			frameRect.Min, frameRect.Max,
			colorLine,
			ImGui::GetStyle().FrameRounding);

		ImGui::PopClipRect();
	}

	auto id = ImGui::GetCurrentWindow()->GetID(g_GroupPanelName);

	auto [itr, emplaced] = m_mapSizes.try_emplace(id, std::make_pair(frameRect.Min, frameRect.Max));
	if (!emplaced)
		itr->second = std::make_pair(frameRect.Min, frameRect.Max);

	ImGui::PopStyleVar(2);

	ImGui::GetCurrentWindow()->ContentRegionRect.Max.x += frameHeight * 0.5f;
	ImGui::GetCurrentWindow()->WorkRect.Max.x += frameHeight * 0.5f;
	ImGui::GetCurrentWindow()->InnerRect.Max.x += frameHeight * 0.5f;

	ImGui::GetCurrentWindow()->Size.x += frameHeight;

	ImGui::Dummy(ImVec2(0.0f, 0.0f));

	ImGui::EndGroup();
}

#include <config/vars.hpp>

void ImGui::ShowStyleEditorCfg(ImGuiStyle* ref)
{
	// You can pass in a reference ImGuiStyle structure to compare to, revert to and save to
	// (without a reference style pointer, we will use one compared locally as a reference)
	ImGuiStyle& style = ImGui::GetStyle();
	static ImGuiStyle ref_saved_style;
	// ugly methods for custom colors, TODO: do own struct for this
	static auto ref_saved_gradient = vars::styling->groupPanelBackground;
	static auto ref_saved_color_panel_line = vars::styling->groupPanelLines;

	// Default to using internal storage as reference
	static bool init = true;
	if (init && ref == NULL)
		ref_saved_style = style;
	init = false;
	if (ref == NULL)
		ref = &ref_saved_style;

	ImGui::PushItemWidth(ImGui::GetWindowWidth() * 0.50f);

	if (ImGui::ShowStyleSelector("Colors##Selector"))
		ref_saved_style = style;
	ImGui::ShowFontSelector("Fonts##Selector");

	// Simplified Settings (expose floating-pointer border sizes as boolean representing 0.0f or 1.0f)
	if (ImGui::SliderFloat("FrameRounding", &style.FrameRounding, 0.0f, 12.0f, "%.0f"))
		style.GrabRounding = style.FrameRounding; // Make GrabRounding always the same value as FrameRounding
	ImGui::SliderFloat("Smooth alpha", &vars::styling->smoothAlpha, 0.0f, 1.0f);
	ImGui::SliderFloat("Smooth outline", &vars::styling->smoothOutline, 0.0f, 1.0f);
	ImGui::SliderFloat("Smooth pop", &vars::styling->smoothPop, 0.0f, 1.0f);
	ImGui::SliderFloat("Speed move", &vars::styling->speedMove, 0.0f, 15.0f);
	{ bool border = (style.WindowBorderSize > 0.0f); if (ImGui::Checkbox("WindowBorder", &border)) { style.WindowBorderSize = border ? 1.0f : 0.0f; } }
	ImGui::SameLine();
	{ bool border = (style.FrameBorderSize > 0.0f);  if (ImGui::Checkbox("FrameBorder", &border)) { style.FrameBorderSize = border ? 1.0f : 0.0f; } }
	ImGui::SameLine();
	{ bool border = (style.PopupBorderSize > 0.0f);  if (ImGui::Checkbox("PopupBorder", &border)) { style.PopupBorderSize = border ? 1.0f : 0.0f; } }

	// Save/Revert button
	if (ImGui::Button("Save Ref"))
		*ref = ref_saved_style = style;
	ImGui::SameLine();
	if (ImGui::Button("Revert Ref"))
		style = *ref;
	ImGui::SameLine();
	HelpMarker(
		"Save/Revert in local non-persistent storage. Default Colors definition are not affected. "
		"Use \"Export\" below to save them somewhere.");

	ImGui::Separator();

	if (ImGui::BeginTabBar("##tabs", ImGuiTabBarFlags_None))
	{
		if (ImGui::BeginTabItem("Sizes"))
		{
			bool changedbut = false; // small optimazation for stack. Won't be huge, just less copying
			ImGui::Text("Main");
			changedbut |= ImGui::SliderFloat2("WindowPadding", (float*)&style.WindowPadding, 0.0f, 20.0f, "%.0f");
			changedbut |= ImGui::SliderFloat2("FramePadding", (float*)&style.FramePadding, 0.0f, 20.0f, "%.0f");
			changedbut |= ImGui::SliderFloat2("CellPadding", (float*)&style.CellPadding, 0.0f, 20.0f, "%.0f");
			changedbut |= ImGui::SliderFloat2("ItemSpacing", (float*)&style.ItemSpacing, 0.0f, 20.0f, "%.0f");
			changedbut |= ImGui::SliderFloat2("ItemInnerSpacing", (float*)&style.ItemInnerSpacing, 0.0f, 20.0f, "%.0f");
			changedbut |= ImGui::SliderFloat2("TouchExtraPadding", (float*)&style.TouchExtraPadding, 0.0f, 10.0f, "%.0f");
			changedbut |= ImGui::SliderFloat("IndentSpacing", &style.IndentSpacing, 0.0f, 30.0f, "%.0f");
			changedbut |= ImGui::SliderFloat("ScrollbarSize", &style.ScrollbarSize, 1.0f, 20.0f, "%.0f");
			changedbut |= ImGui::SliderFloat("GrabMinSize", &style.GrabMinSize, 1.0f, 20.0f, "%.0f");
			ImGui::Text("Borders");
			changedbut |= ImGui::SliderFloat("WindowBorderSize", &style.WindowBorderSize, 0.0f, 1.0f, "%.0f");
			changedbut |= ImGui::SliderFloat("ChildBorderSize", &style.ChildBorderSize, 0.0f, 1.0f, "%.0f");
			changedbut |= ImGui::SliderFloat("PopupBorderSize", &style.PopupBorderSize, 0.0f, 1.0f, "%.0f");
			changedbut |= ImGui::SliderFloat("FrameBorderSize", &style.FrameBorderSize, 0.0f, 3.0f, "%.0f");
			changedbut |= ImGui::SliderFloat("TabBorderSize", &style.TabBorderSize, 0.0f, 1.0f, "%.0f");
			ImGui::Text("Rounding");
			changedbut |= ImGui::SliderFloat("WindowRounding", &style.WindowRounding, 0.0f, 12.0f, "%.0f");
			changedbut |= ImGui::SliderFloat("ChildRounding", &style.ChildRounding, 0.0f, 12.0f, "%.0f");
			changedbut |= ImGui::SliderFloat("FrameRounding", &style.FrameRounding, 0.0f, 12.0f, "%.0f");
			changedbut |= ImGui::SliderFloat("PopupRounding", &style.PopupRounding, 0.0f, 12.0f, "%.0f");
			changedbut |= ImGui::SliderFloat("ScrollbarRounding", &style.ScrollbarRounding, 0.0f, 12.0f, "%.0f");
			changedbut |= ImGui::SliderFloat("GrabRounding", &style.GrabRounding, 0.0f, 12.0f, "%.0f");
			changedbut |= ImGui::SliderFloat("LogSliderDeadzone", &style.LogSliderDeadzone, 0.0f, 12.0f, "%.0f");
			changedbut |= ImGui::SliderFloat("TabRounding", &style.TabRounding, 0.0f, 12.0f, "%.0f");
			ImGui::Text("Alignment");
			changedbut |= ImGui::SliderFloat2("WindowTitleAlign", (float*)&style.WindowTitleAlign, 0.0f, 1.0f, "%.2f");
			int window_menu_button_position = style.WindowMenuButtonPosition + 1;
			if (changedbut |= ImGui::Combo("WindowMenuButtonPosition", (int*)&window_menu_button_position, "None\0Left\0Right\0"))
				style.WindowMenuButtonPosition = window_menu_button_position - 1;
			changedbut |= ImGui::Combo("ColorButtonPosition", (int*)&style.ColorButtonPosition, "Left\0Right\0");
			changedbut |= ImGui::SliderFloat2("ButtonTextAlign", (float*)&style.ButtonTextAlign, 0.0f, 1.0f, "%.2f");
			ImGui::SameLine(); HelpMarker("Alignment applies when a button is larger than its text content.");
			changedbut |= ImGui::SliderFloat2("SelectableTextAlign", (float*)&style.SelectableTextAlign, 0.0f, 1.0f, "%.2f");
			ImGui::SameLine(); HelpMarker("Alignment applies when a selectable is larger than its text content.");
			ImGui::Text("Safe Area Padding");
			ImGui::SameLine(); HelpMarker("Adjust if you cannot see the edges of your screen (e.g. on a TV where scaling has not been configured).");
			changedbut |= ImGui::SliderFloat2("DisplaySafeAreaPadding", (float*)&style.DisplaySafeAreaPadding, 0.0f, 30.0f, "%.0f");
			ImGui::EndTabItem();

			if (changedbut)
			{
				// this should obvioulsy be in some struct, or just overwite varstyle = style. But then we would save unwanted stuff
				vars::styling->imStyle.WindowPadding = style.WindowPadding;
				vars::styling->imStyle.FramePadding = style.FramePadding;
				vars::styling->imStyle.CellPadding = style.CellPadding;
				vars::styling->imStyle.ItemSpacing = style.ItemSpacing;
				vars::styling->imStyle.ItemInnerSpacing = style.ItemInnerSpacing;
				vars::styling->imStyle.TouchExtraPadding = style.TouchExtraPadding;
				vars::styling->imStyle.IndentSpacing = style.IndentSpacing;
				vars::styling->imStyle.ScrollbarSize = style.ScrollbarSize;
				vars::styling->imStyle.GrabMinSize = style.GrabMinSize;
				vars::styling->imStyle.WindowBorderSize = style.WindowBorderSize;
				vars::styling->imStyle.ChildBorderSize = style.ChildBorderSize;
				vars::styling->imStyle.PopupBorderSize = style.PopupBorderSize;
				vars::styling->imStyle.FrameBorderSize = style.FrameBorderSize;
				vars::styling->imStyle.TabBorderSize = style.TabBorderSize;
				vars::styling->imStyle.WindowRounding = style.WindowRounding;
				vars::styling->imStyle.ChildRounding = style.ChildRounding;
				vars::styling->imStyle.FrameRounding = style.FrameRounding;
				vars::styling->imStyle.PopupRounding = style.PopupRounding;
				vars::styling->imStyle.ScrollbarRounding = style.ScrollbarRounding;
				vars::styling->imStyle.GrabRounding = style.GrabRounding;
				vars::styling->imStyle.LogSliderDeadzone = style.LogSliderDeadzone;
				vars::styling->imStyle.TabRounding = style.TabRounding;
				vars::styling->imStyle.WindowMenuButtonPosition = style.WindowMenuButtonPosition;
				vars::styling->imStyle.ColorButtonPosition = style.ColorButtonPosition;
				vars::styling->imStyle.ButtonTextAlign = style.ButtonTextAlign;
				vars::styling->imStyle.SelectableTextAlign = style.SelectableTextAlign;
				vars::styling->imStyle.DisplaySafeAreaPadding = style.DisplaySafeAreaPadding;
			}
		}

		if (ImGui::BeginTabItem("Colors"))
		{
			static int output_dest = 0;
			static bool output_only_modified = true;

			static ImGuiTextFilter filter;
			filter.Draw("Filter colors", ImGui::GetFontSize() * 16);

			static ImGuiColorEditFlags alpha_flags = 0;
			if (ImGui::RadioButton("Opaque", alpha_flags == ImGuiColorEditFlags_None)) { alpha_flags = ImGuiColorEditFlags_None; } ImGui::SameLine();
			if (ImGui::RadioButton("Alpha", alpha_flags == ImGuiColorEditFlags_AlphaPreview)) { alpha_flags = ImGuiColorEditFlags_AlphaPreview; } ImGui::SameLine();
			if (ImGui::RadioButton("Both", alpha_flags == ImGuiColorEditFlags_AlphaPreviewHalf)) { alpha_flags = ImGuiColorEditFlags_AlphaPreviewHalf; } ImGui::SameLine();
			HelpMarker(
				"In the color list:\n"
				"Left-click on color square to open color picker,\n"
				"Right-click to open edit options menu.");

			ImGui::BeginChild("##colors", ImVec2(0, 0), true, ImGuiWindowFlags_AlwaysVerticalScrollbar | ImGuiWindowFlags_AlwaysHorizontalScrollbar | ImGuiWindowFlags_NavFlattened);
			ImGui::PushItemWidth(-160);
			for (int i = 0; i < ImGuiCol_COUNT; i++)
			{
				const char* name = ImGui::GetStyleColorName(i);
				if (!filter.PassFilter(name))
					continue;
				ImGui::PushID(i);
				ImGui::ColorEdit4("##color", (float*)&style.Colors[i], ImGuiColorEditFlags_AlphaBar | alpha_flags);
				if (memcmp(&style.Colors[i], &ref->Colors[i], sizeof(ImVec4)) != 0)
				{
					// Tips: in a real user application, you may want to merge and use an icon font into the main font,
					// so instead of "Save"/"Revert" you'd use icons!
					// Read the FAQ and docs/FONTS.md about using icon fonts. It's really easy and super convenient!
					ImGui::SameLine(0.0f, style.ItemInnerSpacing.x); if (ImGui::Button("Save"))
					{
						ref->Colors[i] = style.Colors[i];
						vars::styling->imStyle.Colors[i] = style.Colors[i];
					}
					ImGui::SameLine(0.0f, style.ItemInnerSpacing.x); if (ImGui::Button("Revert")) { style.Colors[i] = ref->Colors[i]; }
				}
				ImGui::SameLine(0.0f, style.ItemInnerSpacing.x);
				ImGui::TextUnformatted(name);
				ImGui::PopID();
			}

			// should fix this... by own struct
			for (size_t i = 0; i < vars::styling->groupPanelBackground.size(); i++)
			{
				constexpr std::array names = { "Groupleft_up", "Groupright_up", "Groupright_down", "Groupleft_down" };
				const char* name = names[i];
				if (!filter.PassFilter(name))
					continue;
				ImGui::PushID(names[i]);

				ImGui::ColorEdit4("##color2", vars::styling->groupPanelBackground[i].getColorRef().data(), ImGuiColorEditFlags_AlphaBar | alpha_flags);
				if (memcmp(vars::styling->groupPanelBackground[i].getColorRef().data(), ref_saved_gradient[i].getColorRef().data(), sizeof(ImVec4)) != 0)
				{
					// Tips: in a real user application, you may want to merge and use an icon font into the main font,
					// so instead of "Save"/"Revert" you'd use icons!
					// Read the FAQ and docs/FONTS.md about using icon fonts. It's really easy and super convenient!
					ImGui::SameLine(0.0f, style.ItemInnerSpacing.x); if (ImGui::Button("Save"))
					{
						ref_saved_gradient[i] = vars::styling->groupPanelBackground[i];
					}
					ImGui::SameLine(0.0f, style.ItemInnerSpacing.x); if (ImGui::Button("Revert")) { vars::styling->groupPanelBackground[i] = ref_saved_gradient[i]; }
				}
				ImGui::SameLine(0.0f, style.ItemInnerSpacing.x);
				ImGui::TextUnformatted(name);
				ImGui::PopID();
			}

			const char* name = "Groupline";
			if (filter.PassFilter(name))
			{
				ImGui::PushID(name);
				ImGui::ColorEdit4("##color3", vars::styling->groupPanelLines.getColorRef().data(), ImGuiColorEditFlags_AlphaBar | alpha_flags);

				if (memcmp(vars::styling->groupPanelLines.getColorRef().data(), ref_saved_color_panel_line.getColorRef().data(), sizeof(ImVec4)) != 0)
				{
					// Tips: in a real user application, you may want to merge and use an icon font into the main font,
					// so instead of "Save"/"Revert" you'd use icons!
					// Read the FAQ and docs/FONTS.md about using icon fonts. It's really easy and super convenient!
					ImGui::SameLine(0.0f, style.ItemInnerSpacing.x); if (ImGui::Button("Save"))
					{
						ref_saved_color_panel_line = vars::styling->groupPanelLines;
					}
					ImGui::SameLine(0.0f, style.ItemInnerSpacing.x); if (ImGui::Button("Revert")) { vars::styling->groupPanelLines = ref_saved_color_panel_line; }
				}

				ImGui::SameLine(0.0f, style.ItemInnerSpacing.x);
				ImGui::TextUnformatted(name);
				ImGui::PopID();
			}

			ImGui::PopItemWidth();
			ImGui::EndChild();

			ImGui::EndTabItem();
		}

		if (ImGui::BeginTabItem("Fonts"))
		{
			ImGuiIO& io = ImGui::GetIO();
			ImFontAtlas* atlas = io.Fonts;
			HelpMarker("Read FAQ and docs/FONTS.md for details on font loading.");
			ImGui::ShowFontAtlas(atlas);

			// Post-baking font scaling. Note that this is NOT the nice way of scaling fonts, read below.
			// (we enforce hard clamping manually as by default DragFloat/SliderFloat allows CTRL+Click text to get out of bounds).
			const float MIN_SCALE = 0.3f;
			const float MAX_SCALE = 2.0f;
			HelpMarker(
				"Those are old settings provided for convenience.\n"
				"However, the _correct_ way of scaling your UI is currently to reload your font at the designed size, "
				"rebuild the font atlas, and call style.ScaleAllSizes() on a reference ImGuiStyle structure.\n"
				"Using those settings here will give you poor quality results.");
			static float window_scale = 1.0f;
			ImGui::PushItemWidth(ImGui::GetFontSize() * 8);
			if (ImGui::DragFloat("window scale", &window_scale, 0.005f, MIN_SCALE, MAX_SCALE, "%.2f", ImGuiSliderFlags_AlwaysClamp)) // Scale only this window
				ImGui::SetWindowFontScale(window_scale);
			ImGui::DragFloat("global scale", &io.FontGlobalScale, 0.005f, MIN_SCALE, MAX_SCALE, "%.2f", ImGuiSliderFlags_AlwaysClamp); // Scale everything
			ImGui::PopItemWidth();

			ImGui::EndTabItem();
		}

		if (ImGui::BeginTabItem("Rendering"))
		{
			ImGui::Checkbox("Anti-aliased lines", &style.AntiAliasedLines);
			ImGui::SameLine();
			HelpMarker("When disabling anti-aliasing lines, you'll probably want to disable borders in your style as well.");

			ImGui::Checkbox("Anti-aliased lines use texture", &style.AntiAliasedLinesUseTex);
			ImGui::SameLine();
			HelpMarker("Faster lines using texture data. Require backend to render with bilinear filtering (not point/nearest filtering).");

			ImGui::Checkbox("Anti-aliased fill", &style.AntiAliasedFill);
			ImGui::PushItemWidth(ImGui::GetFontSize() * 8);
			ImGui::DragFloat("Curve Tessellation Tolerance", &style.CurveTessellationTol, 0.02f, 0.10f, 10.0f, "%.2f");
			if (style.CurveTessellationTol < 0.10f) style.CurveTessellationTol = 0.10f;

			// When editing the "Circle Segment Max Error" value, draw a preview of its effect on auto-tessellated circles.
			ImGui::DragFloat("Circle Tessellation Max Error", &style.CircleTessellationMaxError, 0.005f, 0.10f, 5.0f, "%.2f", ImGuiSliderFlags_AlwaysClamp);
			if (ImGui::IsItemActive())
			{
				ImGui::SetNextWindowPos(ImGui::GetCursorScreenPos());
				ImGui::BeginTooltip();
				ImGui::TextUnformatted("(R = radius, N = number of segments)");
				ImGui::Spacing();
				ImDrawList* draw_list = ImGui::GetWindowDrawList();
				const float min_widget_width = ImGui::CalcTextSize("N: MMM\nR: MMM").x;
				for (int n = 0; n < 8; n++)
				{
					const float RAD_MIN = 5.0f;
					const float RAD_MAX = 70.0f;
					const float rad = RAD_MIN + (RAD_MAX - RAD_MIN) * (float)n / (8.0f - 1.0f);

					ImGui::BeginGroup();

					ImGui::Text("R: %.f\nN: %d", rad, draw_list->_CalcCircleAutoSegmentCount(rad));

					const float canvas_width = ImMax(min_widget_width, rad * 2.0f);
					const float offset_x = floorf(canvas_width * 0.5f);
					const float offset_y = floorf(RAD_MAX);

					const ImVec2 p1 = ImGui::GetCursorScreenPos();
					draw_list->AddCircle(ImVec2(p1.x + offset_x, p1.y + offset_y), rad, ImGui::GetColorU32(ImGuiCol_Text));
					ImGui::Dummy(ImVec2(canvas_width, RAD_MAX * 2));

					/*
					const ImVec2 p2 = ImGui::GetCursorScreenPos();
					draw_list->AddCircleFilled(ImVec2(p2.x + offset_x, p2.y + offset_y), rad, ImGui::GetColorU32(ImGuiCol_Text));
					ImGui::Dummy(ImVec2(canvas_width, RAD_MAX * 2));
					*/

					ImGui::EndGroup();
					ImGui::SameLine();
				}
				ImGui::EndTooltip();
			}
			ImGui::SameLine();
			HelpMarker("When drawing circle primitives with \"num_segments == 0\" tesselation will be calculated automatically.");

			ImGui::DragFloat("Global Alpha", &style.Alpha, 0.005f, 0.20f, 1.0f, "%.2f"); // Not exposing zero here so user doesn't "lose" the UI (zero alpha clips all widgets). But application code could have a toggle to switch between zero and non-zero.
			ImGui::DragFloat("Disabled Alpha", &style.DisabledAlpha, 0.005f, 0.0f, 1.0f, "%.2f"); ImGui::SameLine(); HelpMarker("Additional alpha multiplier for disabled items (multiply over current value of Alpha).");
			ImGui::PopItemWidth();

			ImGui::EndTabItem();
		}

		ImGui::EndTabBar();
	}

	ImGui::PopItemWidth();
}

#include <d3d9.h>

#ifdef IMGUI_USE_BGRA_PACKED_COLOR
#define IMGUI_COL_TO_DX9_ARGB(_COL)     (_COL)
#else
#define IMGUI_COL_TO_DX9_ARGB(_COL)     (((_COL) & 0xFF00FF00) | (((_COL) & 0xFF0000) >> 16) | (((_COL) & 0xFF) << 16))
#endif

struct ImGui_ImplDX9_Data
{
	LPDIRECT3DDEVICE9           pd3dDevice;
	LPDIRECT3DVERTEXBUFFER9     pVB;
	LPDIRECT3DINDEXBUFFER9      pIB;
	LPDIRECT3DTEXTURE9          FontTexture;
	int                         VertexBufferSize;
	int                         IndexBufferSize;

	ImGui_ImplDX9_Data() { memset(this, 0, sizeof(*this)); VertexBufferSize = 5000; IndexBufferSize = 10000; }
};

static ImGui_ImplDX9_Data* ImGui_ImplDX9_GetBackendData()
{
	return ImGui::GetCurrentContext() ? (ImGui_ImplDX9_Data*)ImGui::GetIO().BackendRendererUserData : NULL;
}

void* ImGui_CreateTexture(const void* data, int width, int height)
{
	ImGui_ImplDX9_Data* bd = ImGui_ImplDX9_GetBackendData();
	unsigned char* pixels;

	if (!bd || !bd->pd3dDevice || !data)
		return NULL;

	// Convert RGBA32 to BGRA32 (because RGBA32 is not well supported by DX9 devices)
#ifndef IMGUI_USE_BGRA_PACKED_COLOR
	ImU32* dst_start = (ImU32*)ImGui::MemAlloc((size_t)width * height * 4);
	for (ImU32* src = (ImU32*)data, *dst = dst_start, *dst_end = dst_start + (size_t)width * height; dst < dst_end; src++, dst++)
		*dst = IMGUI_COL_TO_DX9_ARGB(*src);
	pixels = (unsigned char*)dst_start;
#endif

	LPDIRECT3DTEXTURE9 temp;
	if (bd->pd3dDevice->CreateTexture(width, height, 1, D3DUSAGE_DYNAMIC, D3DFMT_A8R8G8B8, D3DPOOL_SYSTEMMEM, &temp, NULL) < 0)
		return NULL;
	D3DLOCKED_RECT tex_locked_rect;
	if (temp->LockRect(0, &tex_locked_rect, NULL, D3DLOCK_DISCARD) != D3D_OK)
	{
		temp->Release();
		return NULL;
	}
	for (int y = 0; y < height; ++y)
		memcpy((unsigned char*)tex_locked_rect.pBits + tex_locked_rect.Pitch * y, pixels + (width * 4) * y, (width * 4));
	temp->UnlockRect(0);

	LPDIRECT3DTEXTURE9 texture;
	if (bd->pd3dDevice->CreateTexture(width, height, 1, D3DUSAGE_DYNAMIC, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &texture, NULL) != D3D_OK)
	{
		temp->Release();
		return NULL;
	}
	bd->pd3dDevice->UpdateTexture(temp, texture);
	temp->Release();

#ifndef IMGUI_USE_BGRA_PACKED_COLOR
	ImGui::MemFree(pixels);
#endif

	return texture;
}

void ImGui_DestroyTexture(void* texture)
{
	IM_ASSERT(texture != NULL && "passed texture to destroy was null!");
	reinterpret_cast<IDirect3DTexture9*>(texture)->Release();
}
```

`hack/menu/GUI-ImGui/imguiaddons.hpp`:

```hpp
#pragma once

#include <span>
#include <string>
#include <vector>
#include <format>
#include <functional>
#include <unordered_map>

#include <imgui.h>

class CfgColor;
class Color;
class Key;
using ImGuiColorEditFlags = int;

namespace ImGui
{
	// from demo
	void HelpMarker(const char* desc);
	// from widgets, https://github.com/ocornut/imgui/issues/1496#issuecomment-569892444
	void BeginGroupPanel(const char* name, const ImVec2& size = { 0.0f, 0.0f });
	void EndGroupPanel();
	// from demo with slight changes
	void ShowStyleEditorCfg(ImGuiStyle* ref);
}

IMGUI_IMPL_API void* ImGui_CreateTexture(const void* data, int width, int height);
IMGUI_IMPL_API void ImGui_DestroyTexture(void* texture);
```

`hack/menu/GUI-ImGui/menu.cpp`:

```cpp
#include "menu.hpp"

#include "animations.hpp"

#include <imgui.h>
#include <imgui_impl_win32.h>
#include <imgui_impl_dx9.h>
#include <imgui_internal.h>
#include <imgui_stdlib.h>
#include <magic_enum.hpp>
#include <deps/magic_enum/prettyNames.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <render/render.hpp>
#include <utilities/console/console.hpp>
#include <cheats/features/visuals/chams/editor.hpp>
#include <config/vars.hpp>

// see the code of dear imgui lib or demo window to change it.
void ImGuiMenu::init()
{
	ImGuiIO& io = ImGui::GetIO();
	ImGuiStyle& style = ImGui::GetStyle();
	style = vars::styling->imStyle;

	// NEED static here
	static auto p = (config.getHackPath() / XOR("window.ini")).string();

	io.IniFilename = p.c_str();
	io.LogFilename = nullptr;

	try
	{
		imRender.init(io);
	}
	catch (const std::runtime_error& err)
	{
		LOG_ERR(err.what());
	}
}

void ImGuiMenu::shutdown()
{
	ImGui_ImplDX9_Shutdown();
	ImGui_ImplWin32_Shutdown();
	ImGui::DestroyContext();
}

void ImGuiMenu::example()
{
	if (isMenuActive())
	{
		ImGui::ShowDemoWindow(&m_active);
	}
}

#pragma region menu_functionalities
#include "imguiaddons.hpp"
#include "selections.hpp"

static ImVec2 availRegion()
{
	// we could manually count the difference between columns
	ImVec2 avail = ImGui::GetContentRegionAvail();
	return avail;
}

static ImVec2 getChildSize(size_t numOfChilds = 1) // num of childs in single column
{
	// x is always corresponding to avail region
	float x = ImGui::GetContentRegionAvail().x;
	return ImVec2{ x, ImGui::GetContentRegionAvail().y / numOfChilds };
}

static ImVec2 getChildSizeCustom(float y)
{
	// x is always corresponding to avail region
	float x = ImGui::GetContentRegionAvail().x;
	return ImVec2{ x, y };
}

static void renderAimbot()
{
	// using columns, it will be easier, imgui by default recommends begintable(), but in this case columns do stuff like padding each column for us.
	static int index = 0;

	auto& vec = vars::aim->weapons;
	auto& cfg = vec.at(index);

	ImGui::Columns(2, nullptr, false);
	{
		if (ImGui::BeginChild(XOR("aim main"), {}, true))
		{
			ImGui::BeginGroupPanel(XOR("Aimbot"), availRegion());
			{
				ImGui::Animations::ListBox(XOR("Weapon selection"), &index, magic_enum::enum_names_pretty<AimbotWeapon>());
				ImGui::Animations::Checkbox(XOR("Enabled##aim"), &cfg.enabled);
				ImGui::SameLine();
				ImGui::Animations::Checkbox(XOR("Use key##aimbot"), &vars::aim->useKey);
				ImGui::SameLine();
				ImGui::Animations::Hotkey("", &vars::keys->aimbot);
				ImGui::Animations::SliderFloat(XOR("Fov##aim"), &cfg.fov, 0.0f, 50.0f);
				ImGui::Animations::Combo(XOR("Method##Aim"), &cfg.methodAim, magic_enum::enum_names_pretty<AimbotMethod>());
				ImGui::Animations::Combo(XOR("Hitboxes##aim"), &cfg.aimSelection, magic_enum::enum_names_pretty<AimbotHitboxes>());
				ImGui::Animations::SliderFloat(XOR("Smooth##aim"), &cfg.smooth, 0.0f, 1.0f);
				ImGui::Animations::Combo(XOR("Smooth method##aim"), &cfg.smoothMode, magic_enum::enum_names_pretty<SmoothMode>());
				ImGui::Animations::Checkbox(XOR("Randomization##aim"), &cfg.randomization);
				if (cfg.randomization)
					ImGui::Animations::SliderFloat(XOR("Ratio##aim"), &cfg.randomizationRatio, 0.0f, cfg.smooth / 5.0f);
				ImGui::Animations::Checkbox(XOR("Curved##aim"), &cfg.curveAim);
				ImGui::Animations::SliderFloat(XOR("Curve X##aim"), &cfg.curveX, 0.0f, 1.0f);
				ImGui::Animations::SliderFloat(XOR("Curve Y##aim"), &cfg.curveY, 0.0f, 1.0f);
				ImGui::Animations::Checkbox(XOR("Delay##aim"), &cfg.aimDelay);
				ImGui::Animations::SliderFloat(XOR("Delay ms##aim"), &cfg.aimDelayVal, 0.0f, 800.0f);
				ImGui::Animations::Checkbox(XOR("Aim at Backtrack"), &cfg.aimBacktrack);
				ImGui::SameLine();
				ImGui::HelpMarker(XOR("Will aim at middle of records!"));
				ImGui::Animations::Checkbox(XOR("Smoke check##Aimbot"), &cfg.smokeCheck);
				ImGui::Animations::SliderFloat(XOR("Flash limit##Aimbot"), &cfg.flashLimit, 0.0f, 255.0f);

				ImGui::EndGroupPanel();
			}
		}
		ImGui::EndChild();
	}

	ImGui::NextColumn();

	if (ImGui::BeginChild(XOR("aim extra"), {}, true), ImGuiWindowFlags_AlwaysAutoResize)
	{
		ImGui::BeginGroupPanel(XOR("Backtracking & Latency"), availRegion());
		{
			ImGui::Animations::Checkbox(XOR("Backtrack##enabled"), &vars::backtrack->enabled);
			ImGui::Animations::SliderFloat(XOR("Backtrack ms"), &vars::backtrack->time, 0.0f, 200.0f);
			ImGui::Animations::Checkbox(XOR("Smoke check##Backtrack"), &vars::backtrack->smoke);
			ImGui::Animations::SliderFloat(XOR("Flash limit##Backtrack"), &vars::backtrack->flashLimit, 0.0f, 255.0f);
			ImGui::Animations::Checkbox(XOR("Latency##enabled"), &vars::misc->fakeLatency->enabled);
			ImGui::Animations::SliderFloat(XOR("Fake latency ms"), &vars::misc->fakeLatency->amount, 0.0f, 200.0f);

			ImGui::EndGroupPanel();
		}

		ImGui::BeginGroupPanel(XOR("Triggerbot"), availRegion());
		{
			ImGui::Animations::Checkbox(XOR("Triggerbot enabled"), &cfg.triggerbot);
			ImGui::Animations::SliderFloat(XOR("Triggerbot ms"), &cfg.triggerbotDelay, 0.0f, 200.0f);

			ImGui::EndGroupPanel();
		}

		ImGui::BeginGroupPanel(XOR("RCS"), availRegion());
		{
			ImGui::Animations::Checkbox(XOR("Enabled##RCS"), &cfg.rcs);
			ImGui::Animations::SliderFloat(XOR("X%##Rcsx"), &cfg.rcsX, 0.0f, 1.0f);
			ImGui::Animations::SliderFloat(XOR("Y%##Rcsy"), &cfg.rcsY, 0.0f, 1.0f);

			ImGui::EndGroupPanel();
		}

		ImGui::BeginGroupPanel(XOR("Drawing"), availRegion());
		{
			ImGui::Animations::Checkbox(XOR("Draw fov"), &vars::aimPaint->enabledFov);
			ImGui::SameLine();
			ImGui::Animations::ColorPicker(XOR("Fov circle color"), &vars::aimPaint->colorFov);
			ImGui::SameLine();
			ImGui::HelpMarker(XOR("Draws a circle representing your aimbot FOV"));
			ImGui::Animations::Checkbox(XOR("Draw aimbot point"), &vars::aimPaint->enabledPoint);
			ImGui::SameLine();
			ImGui::Animations::ColorPicker(XOR("Color##bestpoint"), &vars::aimPaint->colorPoint);

			ImGui::EndGroupPanel();
		}
	}
	ImGui::EndChild();

	ImGui::Columns();
}

static void renderVisuals()
{
	ImGui::Columns(2, nullptr, false);
	{
		if (ImGui::BeginChild(XOR("visuals"), {}, true))
		{
			ImGui::BeginGroupPanel(XOR("Players"), availRegion());
			{
				ImGui::Animations::Checkbox(XOR("Enabled"), &vars::visuals->esp->boxes->enabled);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##Player boxes"), []()
					{
						ImGui::Animations::Combo(XOR("Boxes mode"), &vars::visuals->esp->boxes->mode, magic_enum::enum_names_pretty<BoxTypes>(), 40);
						ImGui::Animations::ColorPicker(XOR("color##box"), &vars::visuals->esp->boxes->color);
						ImGui::Animations::ColorPicker(XOR("filled##box"), &vars::visuals->esp->boxes->fill);
						ImGui::Animations::Checkbox(XOR("Outlined"), &vars::visuals->esp->boxes->outline);
						if (auto type = vars::visuals->esp->boxes->mode; type == E2T(BoxTypes::FILLED2D) || type == E2T(BoxTypes::FILLED3D))
						{
							ImGui::Animations::Checkbox(XOR("Multi color rect fill"), &vars::visuals->esp->boxes->multiColor);
							ImGui::Animations::SliderFloat(XOR("Rect fill multigradient speed"), &vars::visuals->esp->boxes->multiColorSpeed, 0.0f, 15.0f);
						}
					}
				);

				ImGui::Animations::Checkbox(XOR("Health"), &vars::visuals->esp->healthBar->enabled);
				ImGui::Animations::Checkbox(XOR("Armor"), &vars::visuals->esp->armorBar->enabled);
				ImGui::Animations::Checkbox(XOR("Name"), &vars::visuals->esp->nameBar->enabled);
				ImGui::Animations::Checkbox(XOR("Enemy aiming warn"), &vars::misc->aimWarn->enabled);
				ImGui::Animations::Checkbox(XOR("Skeleton"), &vars::visuals->esp->skeleton->enabled);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##Skeleton ESP options"), []()
					{
						ImGui::Animations::ColorPicker(XOR("Skeleton color"), &vars::visuals->esp->skeleton->color);
						ImGui::Animations::Checkbox(XOR("Draw debug points##skelet"), &vars::visuals->esp->skeleton->showDebug);
					}
				);

				ImGui::Animations::Checkbox(XOR("Sound ESP"), &vars::visuals->sound->enabled);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##Sound ESP options"), []()
					{
						ImGui::Animations::ColorPicker(XOR("Circles color"), &vars::visuals->sound->color);
						ImGui::Animations::SliderFloat(XOR("Step time"), &vars::visuals->sound->time, 1.0f, 20.0f);
						ImGui::Animations::SliderFloat(XOR("Step max distance"), &vars::visuals->sound->maxDist, 5.0f, 500.0f);
						ImGui::Animations::SliderFloat(XOR("Lines info distance"), &vars::visuals->sound->maxDistLine, 2.0f, 200.0f);
						ImGui::HelpMarker(XOR("Max pixels to decide to draw info from centre of screen to the best point"));
						ImGui::Animations::ColorPicker(XOR("Lines info color"), &vars::visuals->sound->colorLine);
					}
				);
				ImGui::Animations::Checkbox(XOR("Dlight"), &vars::visuals->esp->dlight->enabled);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##Dlight options"), []()
					{
						ImGui::Animations::ColorPicker(XOR("Dlight color"), &vars::visuals->esp->dlight->color);
						ImGui::Animations::SliderFloat(XOR("Dlight radius"), &vars::visuals->esp->dlight->radius, 0.0f, 300.0f);
						ImGui::Animations::SliderFloat(XOR("Dlight exponent"), &vars::visuals->esp->dlight->exponent, 0.0f, 12.0f);
						ImGui::Animations::SliderFloat(XOR("Dlight decay"), &vars::visuals->esp->dlight->decay, 0.0f, 100.0f);
					}
				);
				ImGui::Animations::MultiCombo(XOR("Esp flags"), magic_enum::enum_names_pretty<EspFlags>(), &vars::visuals->esp->flags->flags);
				ImGui::Animations::Checkbox(XOR("Visible only##Visuals"), &vars::visuals->esp->checks->visible);
				ImGui::Animations::Checkbox(XOR("Dead only ##Visuals"), &vars::visuals->esp->checks->dead);
				ImGui::Animations::Checkbox(XOR("Smoke check##Visuals"), &vars::visuals->esp->checks->smoke);
				ImGui::Animations::SliderFloat(XOR("Flash limit##Visuals"), &vars::visuals->esp->checks->flashLimit, 0.0f, 255.0f);
				ImGui::Animations::SliderFloat(XOR("Dormacy time##Visuals"), &vars::visuals->dormacy->time, 0.0f, 15.0f);
				ImGui::Animations::SliderFloat(XOR("Dormacy time box##Visuals"), &vars::visuals->dormacy->limit, 0.0f, 15.0f);

				ImGui::EndGroupPanel();
			}

			ImGui::BeginGroupPanel(XOR("Chams"), availRegion());
			{
				const auto materials = g_Chams->getMaterials();
				std::vector<std::string> names;
				std::vector<std::string> matNames(materials.size());
				for (size_t i = 0; const auto& mat : materials)
					matNames[i++] = mat.data.name;

				ImGui::Animations::Checkbox(XOR("Chams enabled Players"), &vars::visuals->chams->players);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##Chams options players"), [matNames]()
					{
						ImGui::Animations::Combo(XOR("Chams type Players"), &vars::visuals->chams->indexPlayers, matNames);
						ImGui::Animations::ColorPicker(XOR("Chams color Players"), &vars::visuals->chams->colorPlayers);
						ImGui::Animations::Checkbox(XOR("Chams XQZ"), &vars::visuals->chams->enabledXQZPlayers);
						ImGui::Animations::ColorPicker(XOR("Chams XQZ color"), &vars::visuals->chams->colorXQZPlayers);
					});
				ImGui::Animations::Checkbox(XOR("Chams enabled Weapons"), &vars::visuals->chams->enabledWeapons);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##Chams options weapons"), [matNames]()
					{
						ImGui::Animations::Combo(XOR("Chams type Weapons"), &vars::visuals->chams->indexWeapons, matNames);
						ImGui::Animations::ColorPicker(XOR("Chams color Weapons"), &vars::visuals->chams->colorWeapons);
						ImGui::Animations::Checkbox(XOR("Disable weapon"), &vars::visuals->chams->weaponHide);
					});
				ImGui::Animations::Checkbox(XOR("Chams enabled Arms"), &vars::visuals->chams->enabledArms);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##Chams options arms"), [matNames]()
					{
						ImGui::Animations::Combo(XOR("Chams type Arms"), &vars::visuals->chams->indexArms, matNames);
						ImGui::Animations::ColorPicker(XOR("Chams color Arms"), &vars::visuals->chams->colorArms);
						ImGui::Animations::Checkbox(XOR("Disable arms"), &vars::visuals->chams->armsHide);
					});
				ImGui::Animations::Checkbox(XOR("Chams enabled Backtrack"), &vars::visuals->chams->enabledBacktrack);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##Chams options backtrack"), [matNames]()
					{
						ImGui::Animations::Combo(XOR("Chams type Backtrack"), &vars::visuals->chams->modeBacktrack, matNames);
						ImGui::Animations::ColorPicker(XOR("Backtrack chams col"), &vars::visuals->chams->colorBacktrack);
						ImGui::Animations::Combo(XOR("Chams style Backtrack"), &vars::visuals->chams->indexBacktrack, magic_enum::enum_names_pretty<BTChamsType>());
					});
				ImGui::Animations::Checkbox(XOR("Enabled glow"), &vars::visuals->glow->enabled);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##Chams options"), []()
					{
						ImGui::Animations::ColorPicker(XOR("Glow color"), &vars::visuals->glow->colorPlayer);
					});
				if (ImGui::Animations::Button(XOR("Open editor##mat")))
				{
					g_MaterialEditor->changeState();
				}

				ImGui::EndGroupPanel();
			}
		}
		ImGui::EndChild();
	}
	ImGui::NextColumn();
	{
		if (ImGui::BeginChild("wpns", {}, true))
		{
			ImGui::BeginGroupPanel(XOR("Weapons"), availRegion());
			{
				ImGui::Animations::Checkbox(XOR("Enabled##weapons"), &vars::visuals->esp->weaponBar->enabled);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##Weapons text and bar"), []()
					{
						ImGui::Animations::Checkbox(XOR("Translate name"), &vars::visuals->esp->weaponBar->translate);
						ImGui::Animations::ColorPicker(XOR("Color for text"), &vars::visuals->esp->weaponBar->text);
						ImGui::Animations::ColorPicker(XOR("Reload bar color"), &vars::visuals->esp->weaponBar->bar);
					}
				);

				ImGui::EndGroupPanel();
			}

			ImGui::BeginGroupPanel(XOR("Bomb"), availRegion());
			{
				ImGui::Animations::Checkbox(XOR("Bomb info"), &vars::visuals->world->bomb->enabled);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##Bomb info draw"), []()
					{
						ImGui::Animations::ColorPicker(XOR("C4 info"), &vars::visuals->world->bomb->background);
					}
				);

				ImGui::EndGroupPanel();
			}

			ImGui::BeginGroupPanel(XOR("Nades"), availRegion());
			{
				ImGui::Animations::Checkbox(XOR("Enabled##nades"), &vars::visuals->world->projectiles->enabled);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##Nades drawing"), []()
					{
						ImGui::Animations::ColorPicker(XOR("Flashbang color"), &vars::visuals->world->projectiles->flash);
						ImGui::Animations::ColorPicker(XOR("Granede color"), &vars::visuals->world->projectiles->nade);
						ImGui::Animations::ColorPicker(XOR("Molotov color"), &vars::visuals->world->projectiles->molotov);
						ImGui::Animations::ColorPicker(XOR("Smoke color"), &vars::visuals->world->projectiles->smoke);
						ImGui::Animations::ColorPicker(XOR("Decoy color"), &vars::visuals->world->projectiles->decoy);
					}
				);

				ImGui::EndGroupPanel();
			}

			ImGui::BeginGroupPanel(XOR("Dropped"), availRegion());
			{
				ImGui::Animations::Checkbox(XOR("Enabled##dropped"), &vars::visuals->esp->dropped->enabled);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##Dropped weapons draw"), []()
					{
						ImGui::Animations::MultiCombo(XOR("Dropped flags"), magic_enum::enum_names_pretty<DroppedFlags>(), &vars::visuals->esp->dropped->flags);
						ImGui::Animations::ColorPicker(XOR("Dropped color"), &vars::visuals->esp->dropped->color);
					}
				);

				ImGui::EndGroupPanel();
			}

			ImGui::BeginGroupPanel(XOR("Particles edit"), availRegion());
			{
				ImGui::Animations::Checkbox(XOR("##Edit molotov"), &vars::visuals->world->particles->enabledMolotov);
				ImGui::SameLine();
				ImGui::Animations::ColorPicker(XOR("Molotov##edited"), &vars::visuals->world->particles->colorMolotov);
				ImGui::Animations::Checkbox(XOR("##Edit blood"), &vars::visuals->world->particles->enabledBlood);
				ImGui::SameLine();
				ImGui::Animations::ColorPicker(XOR("Blood##edited"), &vars::visuals->world->particles->colorBlood);
				ImGui::Animations::Checkbox(XOR("##Edit smoke"), &vars::visuals->world->particles->enabledSmoke);
				ImGui::SameLine();
				ImGui::Animations::ColorPicker(XOR("Smoke##edited"), &vars::visuals->world->particles->colorSmoke);

				ImGui::EndGroupPanel();
			}

			ImGui::BeginGroupPanel(XOR("Molotov & Smoke circles"), availRegion());
			{
				ImGui::Animations::Checkbox(XOR("##Enabled molotov circle"), &vars::visuals->world->molotov->enabled);
				ImGui::SameLine();
				ImGui::Animations::ColorPicker(XOR("Draw molotov circle"), &vars::visuals->world->molotov->color);
				ImGui::Animations::Checkbox(XOR("##Enabled smoke circle"), &vars::visuals->world->smoke->enabled);
				ImGui::SameLine();
				ImGui::Animations::ColorPicker(XOR("Draw smoke circle"), &vars::visuals->world->smoke->color);

				ImGui::EndGroupPanel();
			}
		}
		ImGui::EndChild();
	}
	ImGui::Columns();
}

#include <cheats/features/visuals/radar/radar.hpp>
#include <cheats/features/visuals/world/skybox.hpp>
#include <cheats/features/visuals/world/weather.hpp>
#include <cheats/features/visuals/world/ambient.hpp>
#include <cheats/features/visuals/world/tone.hpp>

static void renderMisc()
{
	ImGui::Columns(2, nullptr, false);
	{
		if (ImGui::BeginChild(XOR("Misc"), {}, true))
		{
			ImGui::BeginGroupPanel(XOR("Skybox"), availRegion());
			{
				const auto customsky = g_SkyboxEdit->getAllCustomSkyBoxes();
				bool state;
				state |= ImGui::Animations::Combo(XOR("Normal"), &vars::visuals->world->sky->indexNormal, std::span(selections::skyboxes.data(), selections::skyboxes.size()));
				state |= ImGui::Animations::Combo(XOR("Custom##Skybox"), &vars::visuals->world->sky->indexCustom, customsky);
				g_SkyboxEdit->handleButtonState(state);
				if (ImGui::Animations::Button(XOR("Reload Custom Skybox")))
				{
					g_SkyboxEdit->reloadCustomSkyboxes();
				}

				ImGui::EndGroupPanel();
			}
			ImGui::BeginGroupPanel(XOR("World Modulation"), availRegion());
			{
				ImGui::Animations::Checkbox(XOR("Modulate world"), &vars::visuals->world->modulate->enabled);
				ImGui::Animations::Checkbox(XOR("Remove sky"), &vars::visuals->world->sky->removeSky);
				ImGui::Animations::ColorPicker(XOR("Modulate world texture"), &vars::visuals->world->modulate->texture);
				ImGui::Animations::ColorPicker(XOR("Modulate world prop"), &vars::visuals->world->modulate->prop);
				ImGui::Animations::ColorPicker(XOR("Modulate world sky"), &vars::visuals->world->modulate->sky);
				ImGui::Animations::SliderFloat(XOR("Shader value"), &vars::visuals->world->modulate->shader, 0.0f, 100.0f);

				ImGui::EndGroupPanel();
			}


			/*ImGui::Animations::Checkbox(XOR("Zeus range"), &config.getRef<bool>(vars.bDrawZeusRange));
			ImGui::SameLine();
			ImGui::Animations::ColorPicker(XOR("Zeus color"), &config.getRef<CfgColor>(vars.cZeusRange));
			ImGui::Animations::Checkbox(XOR("Zeus party"), &config.getRef<bool>(vars.bZeusPartyMode));
			ImGui::SameLine();
			ImGui::Animations::Checkbox(XOR("Zeus tracing"), &config.getRef<bool>(vars.bZeusUseTracing));*/

			ImGui::BeginGroupPanel(XOR("View"), availRegion());
			{
				ImGui::Animations::SliderFloat(XOR("FOV local"), &vars::misc->fov->value, -50.0f, 50.0f);
				ImGui::Animations::Checkbox(XOR("Third Person"), &vars::misc->thirdp->enabled);
				ImGui::SameLine();
				ImGui::Animations::Hotkey(XOR(""), &vars::keys->thirdP);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##Third person pop"), []()
					{
						ImGui::Animations::SliderFloat(XOR("Distance##thirdp"), &vars::misc->thirdp->distance, 1.0f, 500.0f);
						ImGui::Animations::SliderFloat(XOR("Extra X##thirdp"), &vars::misc->thirdp->x, -180.0f, 180.0f);
						ImGui::Animations::SliderFloat(XOR("Extra Y##thirdp"), &vars::misc->thirdp->y, -180.0f, 180.0f);
					}
				);
				ImGui::Animations::Combo(XOR("Crosshair type"), &vars::misc->crosshair->index, magic_enum::enum_names_pretty<CrossHairTypes>());

				ImGui::EndGroupPanel();
			}

			ImGui::BeginGroupPanel(XOR("Radar"), availRegion());
			{
				ImGui::Animations::Checkbox(XOR("2D Radar enabled"), &vars::misc->radar->enabled);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##2D Radar pop"), []()
					{
						ImGui::Animations::ColorPicker(XOR("Angle view line"), &vars::misc->radar->colorLine);
						ImGui::Animations::ColorPicker(XOR("Players color"), &vars::misc->radar->colorPlayer);
						ImGui::Animations::SliderFloat(XOR("Thickness"), &vars::misc->radar->thickness, 0.0f, 20.0f);
						ImGui::Animations::SliderFloat(XOR("Length"), &vars::misc->radar->length, 0.0f, 40.0f);
						ImGui::Animations::SliderFloat(XOR("Scale"), &vars::misc->radar->scale, 0.0f, 10.0f);
						ImGui::Animations::SliderFloat(XOR("Radar size"), &vars::misc->radar->size, 10.0f, 500.0f);
						ImGui::Animations::Checkbox(XOR("Draw out of radar"), &vars::misc->radar->ranges);
						ImGui::SameLine();
						ImGui::HelpMarker(XOR("If enemy is out of the radar\nThen icons will still appear but clamped"));
					}
				);
				if (ImGui::Animations::Button(XOR("Refresh texture manually")))
				{
					g_Radar->manuallyInitTexture();
				}
				ImGui::SameLine();
				ImGui::HelpMarker(XOR("Will not for workshop maps\nYou can try forcing the engine to re-render by pressing escape few times"));
			}
			ImGui::EndGroupPanel();
		}
		ImGui::EndChild();
	}
	ImGui::NextColumn();
	{
		if (ImGui::BeginChild(XOR("Miscother"), {}, true))
		{
			ImGui::BeginGroupPanel(XOR("Movement"), availRegion());
			{
				ImGui::Animations::Checkbox(XOR("Bunnyhop"), &vars::misc->bunnyHop->enabled);
				if(vars::misc->bunnyHop->enabled)
				{
					ImGui::SliderInt(XOR("Bunnyhop hitchance"), &vars::misc->bunnyHop->chance, 0, 100, "%i%%");
				}
				ImGui::Animations::Combo(XOR("Autostrafe"), &vars::misc->bunnyHop->indexStrafe, magic_enum::enum_names_pretty<MovementStraferMode>());

				ImGui::EndGroupPanel();
			}
			/*bool& logRef = config.getRef<bool>(vars.bLogEnabled);
			ImGui::Animations::Checkbox(XOR("Log events"), &logRef);
			if (logRef)
			{
				ImGui::Animations::SliderFloat(XOR("Log time"), &config.getRef<float>(vars.fLogMaxTime), 1.0f, 8.0f);
			}*/
			ImGui::BeginGroupPanel(XOR("Hitmarker"), availRegion());
			{
				ImGui::Animations::Checkbox(XOR("Hitmarker"), &vars::misc->hitmarker->enabled);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##hitmarker pop"), []()
					{
						ImGui::Animations::Checkbox(XOR("3D##Hitm"), &vars::misc->hitmarker->enabled3D);
						ImGui::SameLine();
						ImGui::Animations::Checkbox(XOR("Resize##Hitm"), &vars::misc->hitmarker->enabledResize);
						ImGui::Animations::ColorPicker(XOR("Hitmarker normal"), &vars::misc->hitmarker->colorNormal);
						ImGui::Animations::ColorPicker(XOR("Hitmarker hs"), &vars::misc->hitmarker->colorHead);
						ImGui::SameLine();
						ImGui::Text(XOR("Hitmarker hs"));
						ImGui::Animations::ColorPicker(XOR("Hitmarker dead"), &vars::misc->hitmarker->colorDead);
						ImGui::Animations::SliderFloat(XOR("Hitmarker time"), &vars::misc->hitmarker->time, 0.0f, 2.0f);
						ImGui::Animations::Checkbox(XOR("Play hitmarker"), &vars::misc->hitmarker->play);
						ImGui::SameLine();
						ImGui::HelpMarker(XOR("Will play the sound after every kill"));
					}
				);

				ImGui::EndGroupPanel();
			}
			ImGui::BeginGroupPanel(XOR("Misc"), availRegion());
			{
				ImGui::Animations::Checkbox(XOR("No scope"), &vars::misc->scope->enabled);
				
				ImGui::Animations::Checkbox(XOR("FPS Plot"), &vars::misc->plots->enabledFps);
				if (vars::misc->plots->enabledFps)
				{
					ImGui::SameLine();
					ImGui::Animations::Checkbox(XOR("FPS Custom"), &vars::misc->plots->fpsCustom);
				}
				
				ImGui::Animations::Checkbox(XOR("Velocity Plot"), &vars::misc->plots->enabledVelocity);
				if (vars::misc->plots->enabledVelocity)
				{
					ImGui::SameLine();
					ImGui::Animations::Checkbox(XOR("Velocity Custom"), &vars::misc->plots->velocityCustom);
				}
				ImGui::Animations::Checkbox(XOR("Draw misc info"), &vars::misc->info->enabled);
				ImGui::Animations::Checkbox(XOR("Playerlist##checkbox"), &vars::misc->playerList->enabled);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##Playerlist pop"), []()
					{
						ImGui::Animations::Checkbox(XOR("Health##playerlist"), &vars::misc->playerList->health);
						ImGui::Animations::Checkbox(XOR("Money##playerlist"), &vars::misc->playerList->money);
						ImGui::Animations::Checkbox(XOR("Team##playerlist"), &vars::misc->playerList->teamID);
						ImGui::Animations::Checkbox(XOR("Place##playerlist"), &vars::misc->playerList->lastPlace);
					}
				);
				ImGui::Animations::Checkbox(XOR("Hat on local"), &vars::misc->hat->enabled);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##Hat pop"), []()
					{
						ImGui::Animations::Checkbox(XOR("Rainbow hat"), &vars::misc->hat->rainbow);
						if (!vars::misc->hat->rainbow)
						{
							ImGui::Animations::ColorPicker(XOR("Hat triangle color"), &vars::misc->hat->colorTriangle);
							ImGui::Animations::ColorPicker(XOR("Hat lines color"), &vars::misc->hat->colorLine);
						}
						else
						{
							ImGui::Animations::SliderFloat(XOR("Hat rainbow speed"), &vars::misc->hat->rainbowSpeed, 0.2f, 10.0f);
						}
						ImGui::Animations::SliderFloat(XOR("Hat size"), &vars::misc->hat->size, -100.0f, 100.0f);
						ImGui::Animations::SliderFloat(XOR("Hat radius"), &vars::misc->hat->radius, 1.0f, 100.0f);
					}
				);

				ImGui::EndGroupPanel();
			}
			ImGui::BeginGroupPanel(XOR("Nade prediction"), availRegion());
			{
				ImGui::Animations::Checkbox(XOR("Nade pred"), &vars::misc->nade->enabledPred);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##nade pred pop"), []()
					{
						ImGui::Animations::Checkbox(XOR("Show always"), &vars::misc->nade->predAlways);
						ImGui::Animations::ColorPicker(XOR("Nade pred color"), &vars::misc->nade->colorPredLine);
						ImGui::Animations::ColorPicker(XOR("Nade pred color box fill"), &vars::misc->nade->colorPredBoxFill);
						ImGui::Animations::ColorPicker(XOR("Nade pred color box outline"), &vars::misc->nade->colorPredBox);
					}
				);
				ImGui::Animations::Checkbox(XOR("Nade trails"), &vars::misc->nade->enabledTracer);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##nade trails pop"), []()
					{
						ImGui::Animations::ColorPicker(XOR("Nade trail color"), &vars::misc->nade->colorTracer);
						ImGui::Animations::SliderFloat(XOR("Nade trail max dist"), &vars::misc->nade->tracerDist, 1.0f, 100.0f);
						ImGui::Animations::Checkbox(XOR("Nade trail warn"), &vars::misc->nade->tracerWarn);
						ImGui::SameLine();
						ImGui::HelpMarker(XOR("Draws scaled circles behind you where nade is"));
					}
				);

				ImGui::EndGroupPanel();
			}

			ImGui::BeginGroupPanel(XOR("Bullets and trails"), availRegion());
			{
				ImGui::Animations::Checkbox(XOR("Movement trail"), &vars::misc->trail->enabled);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##Movement trails pop"), []()
					{
						ImGui::Animations::Combo(XOR("Trail type"), &vars::misc->trail->mode, magic_enum::enum_names_pretty<MovementTrail>());
						ImGui::Animations::ColorPicker(XOR("Movement trail color"), &vars::misc->trail->color);
						ImGui::Animations::SliderFloat(XOR("Trail speed"), &vars::misc->trail->beamSpeed, 1.0f, 10.0f);
						ImGui::Animations::SliderFloat(XOR("Trail life"), &vars::misc->trail->time, 1.0f, 10.0f);
					}
				);


				//ImGui::Animations::Checkbox(XOR("Remove blood spray"), &config.getRef<bool>(vars.bRemoveBloodSpray));
				ImGui::Animations::Checkbox(XOR("Enable tracers"), &vars::visuals->world->tracer->enabled);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##Bullet tracers"), []()
					{
						ImGui::Animations::Combo(XOR("Beam sprite"), &vars::visuals->world->tracer->beamTracer.index, selections::beamNames);
						/*ImGui::InputTextWithHint(XOR("Beam type"), XOR("Add without spaces! eg: 4|8"), &config.getRef<std::string>(vars.sBulletTracerType));*/
						/*ImGui::SameLine();
						ImGui::HelpMarker(XOR("Types list\n"
							"TE_BEAMPOINTS 0\n"
							"TE_SPRITE 1\n"
							"TE_BEAMDISK 2\n"
							"TE_BEAMCYLINDER 3\n"
							"TE_BEAMFOLLOW 4\n"
							"TE_BEAMRING 5\n"
							"TE_BEAMSPLINE 6\n"
							"TE_BEAMRINGPOINT 7\n"
							"TE_BEAMLASER 8\n"
							"TE_BEAMTESLA 9\n"
						));*/
						ImGui::InputTextWithHint(XOR("Beam flags"), XOR("eg: 4|8, spaces allowed"), &vars::visuals->world->tracer->beamTracer.flags);
						ImGui::SameLine();
						ImGui::HelpMarker(XOR("Flags list\n"
							"FBEAM_STARTENTITY 1\n"
							"FBEAM_ENDENTITY 2\n"
							"FBEAM_FADEIN 4\n"
							"FBEAM_FADEOUT 8\n"
							"FBEAM_SINENOISE 16\n"
							"FBEAM_SOLID 32\n"
							"FBEAM_SHADEIN 64\n"
							"FBEAM_SHADEOUT 128\n"
							"FBEAM_ONLYNOISEONCE 256\n"
							"FBEAM_NOTILE 512\n"
							"FBEAM_USE_HITBOXES 1024\n"
							"FBEAM_STARTVISIBLE 2048\n"
							"FBEAM_ENDVISIBLE 4096\n"
							"FBEAM_ISACTIVE 8192\n"
							"FBEAM_FOREVER 16384\n"
							"FBEAM_HALOBEAM 32768\n"
							"FBEAM_REVERSED 65536\n"
						));
						ImGui::Animations::ColorPicker(XOR("Tracers color"), &vars::visuals->world->tracer->beamTracer.color);
						ImGui::Animations::SliderFloat(XOR("Tracers life"), &vars::visuals->world->tracer->beamTracer.life, 0.0f, 10.0f);
						ImGui::Animations::SliderFloat(XOR("Tracers width"), &vars::visuals->world->tracer->beamTracer.width, 0.0f, 20.0f);
						ImGui::Animations::SliderFloat(XOR("Tracers fadeLenght"), &vars::visuals->world->tracer->beamTracer.fadeLength, 0.0f, 20.0f);
						ImGui::Animations::SliderFloat(XOR("Tracers amplitude"), &vars::visuals->world->tracer->beamTracer.amplitude, 0.0f, 20.0f);
						ImGui::Animations::SliderFloat(XOR("Tracers speed"), &vars::visuals->world->tracer->beamTracer.speed, 0.0f, 200.0f);
						ImGui::Animations::SliderFloat(XOR("Tracers startFrame"), &vars::visuals->world->tracer->beamTracer.startFrame, 0.0f, 300.0f);
						ImGui::Animations::SliderFloat(XOR("Tracers frameRate"), &vars::visuals->world->tracer->beamTracer.frameRate, 0.0f, 200.0f);
						ImGui::SliderInt(XOR("Tracers segmnets"), &vars::visuals->world->tracer->beamTracer.segments, 0, 30);
					}
				);	
				ImGui::Animations::Checkbox(XOR("Enable client bullets"), &vars::visuals->world->impacts->enabledClient);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##client bullets pop"), []()
					{
						ImGui::Animations::ColorPicker(XOR("Outline##Client bullets"), &vars::visuals->world->impacts->colorClient);
						ImGui::Animations::ColorPicker(XOR("Fill##Client bullets"), &vars::visuals->world->impacts->colorClientFill);
						ImGui::Animations::SliderFloat(XOR("Time##Client bullets"), &vars::visuals->world->impacts->timeClient, 0.0f, 5.0f);
					}
				);			

				ImGui::EndGroupPanel();
			}

			ImGui::BeginGroupPanel(XOR("Misc other"), availRegion());
			{
				ImGui::Animations::Checkbox(XOR("Game logs"), &vars::misc->logs->enabled);
				ImGui::SameLine();
				ImGui::Animations::SliderFloat(XOR("Time##Gamelogs"), &vars::misc->logs->time, 1.0f, 10.0f);
				ImGui::Animations::Checkbox(XOR("Freelook"), &vars::misc->freeLook->enabled);
				ImGui::SameLine();
				ImGui::Animations::Hotkey(XOR("##fl"), &vars::keys->freeLook);
				ImGui::Animations::Checkbox(XOR("FreeCam"), &vars::misc->freeCam->enabled);
				ImGui::SameLine();
				ImGui::Animations::Hotkey("##fc", &vars::keys->freeCam);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##freecam pop"), []()
					{
						ImGui::Animations::SliderFloat(XOR("Speed##fc"), &vars::misc->freeCam->speed, 1.0f, 20.0f);
					}
				);
				ImGui::Animations::Checkbox(XOR("MirrorCam"), &vars::misc->mirrorCam->enabled);
				ImGui::SameLine();
				ImGui::Animations::Checkbox(XOR("On key##mcam"), &vars::misc->mirrorCam->onKey);
				ImGui::SameLine();
				ImGui::Animations::Hotkey(XOR("##mcam"), &vars::keys->mirrorCam);
				ImGui::Animations::Checkbox(XOR("Flashlight"), &vars::misc->flashLight->enabled);
				ImGui::SameLine();
				ImGui::Animations::Hotkey(XOR("##flashl key"), &vars::keys->flashLight);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##flashlight pop"), []()
					{
						ImGui::Animations::Checkbox(XOR("Big mode"), &vars::misc->flashLight->bigMode);
						ImGui::Animations::SliderFloat(XOR("Flashlight FOV"), &vars::misc->flashLight->fov, 1.0f, 100.0f);
					}
				);
				ImGui::Animations::Checkbox(XOR("Fog enabled"), &vars::visuals->world->fog->enabled);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##fog pop"), []()
					{
						ImGui::Animations::SliderFloat(XOR("Fog distance"), &vars::visuals->world->fog->distance, 1.0f, 1000.0f);
						ImGui::Animations::ColorPicker(XOR("Fog color"), &vars::visuals->world->fog->color);
					}
				);
				ImGui::Animations::Combo(XOR("Screen effect"), &vars::visuals->world->screenEffect->index, selections::screenEffects);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##screneffect pop"), []()
					{
						ImGui::Animations::SliderFloat(XOR("Param##Screen effect"), &vars::visuals->world->screenEffect->param, 0.0f, 1.0f);
						ImGui::Animations::ColorPicker(XOR("Color##Screen effect"), &vars::visuals->world->screenEffect->color);
					}
				);
				bool changedbut = false;
				changedbut |= ImGui::Animations::Checkbox(XOR("ControlTone enabled"), &vars::visuals->world->tone->enabled);
				g_ToneController->setStateButton(changedbut);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##Tone control pop"), []()
					{
						bool changed = false;
						changed |= ImGui::Animations::SliderFloat(XOR("Tone min"), &vars::visuals->world->tone->min, 0.0f, 1.0f);
						changed |= ImGui::Animations::SliderFloat(XOR("Tone max"), &vars::visuals->world->tone->max, 0.0f, 1.0f);
						changed |= ImGui::Animations::SliderFloat(XOR("Tone bloom scale"), &vars::visuals->world->tone->bloom, 0.0f, 16.0f);
						g_ToneController->setStateSlider(changed);
					}
				);
				ImGui::Animations::Checkbox(XOR("Weather"), &vars::visuals->world->weather->enabled);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##Weather control pop"), []()
					{
						g_WeatherController->implMenu();
					}
				);				
				ImGui::Animations::Checkbox(XOR("Motion blur"), &vars::misc->motionBlur->enabled);
				ImGui::SameLine();
				ImGui::Animations::PopupButton(XOR("##Motion blur pop"), []()
					{
						ImGui::Animations::Checkbox(XOR("Forward##Motion Blur"), &vars::misc->motionBlur->forward);
						ImGui::Animations::SliderFloat(XOR("Failling intensity##Motion Blur"), &vars::misc->motionBlur->fallingIntensity, 0.0f, 5.0f);
						ImGui::Animations::SliderFloat(XOR("Falling max##Motion Blur"), &vars::misc->motionBlur->fallingMax, 0.0f, 30.0f);
						ImGui::Animations::SliderFloat(XOR("Falling min##Motion Blur"), &vars::misc->motionBlur->fallingMin, 0.0f, 30.0f);
						ImGui::Animations::SliderFloat(XOR("Strength##Motion Blur"), &vars::misc->motionBlur->strength, 0.0f, 20.0f);
						ImGui::Animations::SliderFloat(XOR("Roll intensity##Motion Blur"), &vars::misc->motionBlur->rollIntensity, 0.0f, 1.0f);
					}
				);
				bool changedbut2 = false;
				changedbut2 |= ImGui::Animations::Checkbox(XOR("Ambient"), &vars::visuals->world->ambient->enabled);
				g_AmbientLight->setButtonState(changedbut2);
				ImGui::SameLine();
				bool changed = false;
				changed |= ImGui::Animations::ColorPicker(XOR("Color##ambient col"), &vars::visuals->world->ambient->color);
				g_AmbientLight->setPickerState(changed);
				ImGui::Animations::Checkbox(XOR("Disable Interpolation"), &vars::misc->disableItems->interpolate);
				
				ImGui::EndGroupPanel();
			}
		}
		ImGui::EndChild();
	}
	ImGui::Columns();
}

static void renderConfig()
{
	static std::string text = XOR("Your new config name");
	static int currentcfg = 0;

	static auto initIndexOnce = []()
	{
		for (size_t i = 0; const auto & el : config.getAllConfigFiles())
		{
			if (el == config.getCfgToLoad())
				currentcfg = i;

			i++;
		}

		return true;
	} ();

	ImGui::Columns(2, nullptr, false);
	{
		if (ImGui::BeginChild(XOR("cfg"), {}, true))
		{
			const auto allcfg = config.getAllConfigFiles();

			ImGui::BeginGroupPanel(XOR("Config"), availRegion());
			{
				if (ImGui::InputText(XOR("Config name"), &text, ImGuiInputTextFlags_EnterReturnsTrue))
				{
					if (utilities::toLowerCase(text) != config.getDefaultConfigName())
					{
						config.save(text);
						text.clear();
						config.reload();
					}
					else
						LOG_ERR(XOR("provided config name was same as default"));
				}
				ImGui::SameLine();
				ImGui::HelpMarker(XOR("Press enter to create new config"));
				ImGui::Animations::ListBox(XOR("All configs"), &currentcfg, std::span(allcfg.data(), allcfg.size()));

				static bool dontAskMe = false;
				static bool delayedClose = false; // not instant close for modal 
				if (ImGui::Animations::Button(XOR("Delete")))
				{
					if (dontAskMe && delayedClose)
					{
						config.deleteCfg(allcfg.at(currentcfg));
						config.reload();
					}
					else
						ImGui::OpenPopup(XOR("Delete?"));
				}

				if (ImGui::BeginPopupContextItem())
				{
					if (ImGui::Animations::Button(XOR("Reset asking")))
					{
						dontAskMe = false;
						delayedClose = false;
						ImGui::CloseCurrentPopup();
					}

					ImGui::EndPopup();
				}

				if (ImGui::BeginPopupModal(XOR("Delete?"), nullptr, ImGuiWindowFlags_AlwaysAutoResize))
				{
					ImGui::TextUnformatted(FORMAT(XOR("Are you sure you want to delete {} file?"), allcfg.at(currentcfg)).c_str());
					ImGui::Separator();
					ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, { 0.0f, 0.0f });
					ImGui::Animations::Checkbox(XOR("Don't ask again"), &dontAskMe);
					ImGui::PopStyleVar();

					if (ImGui::Animations::Button(XOR("OK"), { 120.0f, 0.0f }))
					{
						config.deleteCfg(allcfg.at(currentcfg));
						config.reload();
						ImGui::CloseCurrentPopup();

						if (dontAskMe)
							delayedClose = true;
						else
							delayedClose = false;
					}
					ImGui::SameLine();
					if (ImGui::Animations::Button(XOR("Cancel"), { 120.0f, 0.0f }))
					{
						ImGui::CloseCurrentPopup();

						if (dontAskMe)
							delayedClose = true;
						else
							delayedClose = false;
					}

					ImGui::EndPopup();
				}

				ImGui::SameLine();
				if (ImGui::Animations::Button(XOR("Save")))
				{
					config.save(allcfg.at(currentcfg));
				}
				ImGui::SameLine();
				if (ImGui::Animations::Button(XOR("Load")))
				{
					config.load(allcfg.at(currentcfg));
				}
				if (ImGui::Animations::Button(XOR("Load on start")))
				{
					// this is only saving the load name, nothing more
					config.startSave(allcfg.at(currentcfg));
					LOG_INFO(XOR("{} will be now loaded config on the start"), allcfg.at(currentcfg));
				}
				ImGui::SameLine();
				ImGui::HelpMarker(XOR("This config will load on the start"));
			}
			ImGui::EndGroupPanel();
		}
		ImGui::EndChild();
	}
	ImGui::NextColumn();
	if (ImGui::BeginChild(XOR("cfgkeys"), {}, true))
	{
		ImGui::BeginGroupPanel(XOR("Config keys"), availRegion());
		{
			ImGui::Animations::Hotkey(XOR("Menu key"), &vars::keys->menu, false);
			ImGui::Animations::Hotkey(XOR("Console key"), &vars::keys->console, false);
			ImGui::Animations::Hotkey(XOR("Panic key"), &vars::keys->panic, false);
			ImGui::Animations::Checkbox(XOR("Enable x88 menu"), &vars::keys->enabledX88Menu);
		}
		ImGui::EndGroupPanel();
	}
	ImGui::EndChild();

	ImGui::Columns();
}

#include "background.hpp"

static bool editorOpened = false;

static void renderStyles()
{
	ImGui::Columns(1, nullptr, false);
	{
		if (ImGui::BeginChild(XOR("style"), {}, true))
		{
			ImGui::BeginGroupPanel(XOR("Style"), availRegion());
			{
				ImGui::Animations::Checkbox(XOR("Background"), &vars::styling->background);
				ImGui::Animations::SliderFloat(XOR("Background speed"), &vars::styling->speed, 1.0f, 8.0f);
				ImGui::Animations::SliderFloat(XOR("Background max dist"), &vars::styling->distance, 10.0f, 400.0f);
				ImGui::SliderInt(XOR("Background amount of records"), &vars::styling->size, 20, 400);
				ImGui::Text(XOR("They are temp limited with dynamic size + saving!"));
				ImGui::Animations::ColorPicker(XOR("Background color1"), &vars::styling->color1);
				ImGui::SameLine();
				ImGui::Animations::ColorPicker(XOR("Background color2"), &vars::styling->color2);
				ImGui::SameLine();
				ImGui::Animations::ColorPicker(XOR("Background color3"), &vars::styling->color3);
				if (ImGui::Animations::Button(XOR("Refresh background")))
					background.init();
				ImGui::Animations::Checkbox(XOR("Discord RPC"), &vars::misc->discord->enabled);
				ImGui::Animations::Checkbox(XOR("Show editor"), &editorOpened);
			}
			ImGui::EndGroupPanel();	
		}
		ImGui::EndChild();
	}
}

#include "tabrender.hpp"

std::array tabs =
{
	TabRender{ "Aimbot", &renderAimbot },
	TabRender{ "Visuals", &renderVisuals },
	TabRender{ "Misc", &renderMisc },
	TabRender{ "Config", &renderConfig },
	TabRender{ "Style", &renderStyles }
};
#pragma endregion


void ImGuiMenu::renderAll()
{
	if(ImGui::Begin(XOR("csgo legit"), &m_active, ImGuiWindowFlags_NoCollapse))
	{
		ImGuiStyle& style = ImGui::GetStyle();
		ImVec2 backupPadding = style.FramePadding;
		float width = ImGui::GetContentRegionAvail().x;

		// remove tab underline
		ImGui::PushStyleColor(ImGuiCol_TabActive, Color::U32(Colors::Blank));
		ImGui::PushStyleColor(ImGuiCol_TabUnfocusedActive, Color::U32(Colors::Blank));

		if (ImGui::BeginTabBar(XOR("tabbar"), ImGuiTabBarFlags_Reorderable))
		{
			style.FramePadding = { width / tabs.size(), backupPadding.y }; // still this is clamped by imgui in tabs
			ImGui::PopStyleColor(2);
			for (const auto& el : tabs)
			{
				if (ImGui::BeginTabItem(el.m_name))
				{
					style.FramePadding = backupPadding;
					if (el.funcExist())
						el.m_func();

					ImGui::EndTabItem();
				}
			}
			ImGui::EndTabBar();
		}
	}
	ImGui::End();
}

bool ImGuiMenu::inTransmission()
{
	constexpr float ratio = 1.0f / 0.5f;
	float step = ratio * ImGui::GetIO().DeltaTime;
	const auto bgAlpha = ImGui::ColorConvertU32ToFloat4(ImGui::GetColorU32(ImGuiCol_WindowBg)).w;

	sharedAlpha = std::clamp(sharedAlpha + (m_active ? step : -step), 0.0f, bgAlpha);

	if (sharedAlpha == bgAlpha)
		return false;

	if (sharedAlpha == 0.0f)
		return false;

	return true;
}

void ImGuiMenu::draw()
{
	ImGui::Animations::setAnimationSpeeds();

	if (editorOpened)
	{
		if (ImGui::Begin(XOR("Style editor"), &editorOpened))
		{
			ImGui::ShowStyleEditorCfg(nullptr);

			ImGui::End();
		}
	}

	if (inTransmission())
	{
		ImGui::PushStyleColor(ImGuiStyleVar_Alpha, ImGui::GetColorU32(ImGuiStyleVar_Alpha, sharedAlpha));
		ImGui::SetNextWindowBgAlpha(sharedAlpha);
		renderAll();
		ImGui::PopStyleColor();

		return;
	}
	if (m_active)
		renderAll();
}
```

`hack/menu/GUI-ImGui/menu.hpp`:

```hpp
#pragma once

#include <render/Color.hpp>

class ImGuiMenu final
{
public:
	ImGuiMenu() = default;

	void init();
	void shutdown();
	void example();
	void draw();
	[[nodiscard]] constexpr bool isMenuActive() const { return m_active; }
	constexpr void changeActive() { m_active = !m_active; }
	bool inTransmission();
private:
	bool m_active = true;
	float sharedAlpha = 0.0f;
	void renderAll();
};

inline ImGuiMenu menu;
```

`hack/menu/GUI-ImGui/selections.hpp`:

```hpp
#pragma once

#include <array>

namespace selections
{
	// https://developer.valvesoftware.com/wiki/Counter-Strike:_Global_Offensive_Sky_List - i did not check if they are up to date
	// to use custom skybox, you need to first load it in root folder and then to actually force the sky you should bypass file checks.
	inline constexpr std::array skyboxes =
	{
		"none",
		"cs_baggage_skybox_",
		"cs_tibet",
		"vietnam",
		"sky_lunacy",
		"embassy",
		"italy",
		"jungle",
		"office",
		"sky_cs15_daylight01_hdr",
		"sky_cs15_daylight02_hdr",
		"sky_day02_05",
		"nukeblank",
		"dustblank",
		"sky_venice",
		"sky_cs15_daylight03_hdr",
		"sky_cs15_daylight04_hdr",
		"sky_csgo_cloudy01",
		"sky_csgo_night02",
		"sky_csgo_night02b",
		"vertigo",
		"vertigoblue_hdr",
		"sky_dust",
		"sky_hr_aztec"
	};

	inline constexpr std::array screenEffects =
	{
		"none",
		"effects/healthboost",
		"effects/parachute",
		"effects/screentear",
		"effects/dronecam",
		"effects/nightvision",
		"effects/dangerzone_screen",
		"effects/underwater_overlay",
		"effects/survival_zone_projection_distancefield_inv",
		"dev/screenhighlight_pulse",
	};

	inline constexpr std::array beamNames =
	{
		"sprites/blueglow1.vmt",
		"sprites/bubble.vmt",
		"sprites/glow01.vmt",
		"sprites/physbeam.vmt",
		"sprites/purpleglow1.vmt",
		"sprites/purplelaser1.vmt",
		"sprites/radio.vmt",
		"sprites/white.vmt",
	};
}
```

`hack/menu/GUI-ImGui/tabrender.hpp`:

```hpp
#pragma once

#include <functional>

struct TabRender
{
	TabRender() = default;
	TabRender(const char* name, const std::function<void()>& func)
		: m_name{ name }, m_func{ func }
	{}
	TabRender(const char* name)
		: m_name{ name }, m_func{ nullptr }
	{}

	[[nodiscard]] bool funcExist() const
	{
		return m_func != nullptr;
	}

	const char* m_name;
	std::function<void()> m_func;
};
```

`hack/menu/x88Menu/x88menu.cpp`:

```cpp
#include "x88menu.hpp"

#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <SDK/structs/Entity.hpp>
#include <config/vars.hpp>
#include <render/render.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <utilities/inputSystem.hpp>
#include <magic_enum.hpp>

void X88Menu::draw()
{
	if (!vars::keys->enabledX88Menu)
		return;

	if (!m_inited)
		return;

	const static Color highlight = Colors::Grey.getColorEditAlpha(0.85f);
	const static Color normal = Colors::White;
	const static auto font = fonts::tahoma;

	int x = static_cast<int>(globals::screenX * 0.2f);
	int y = 20;

	// start
	if (!game::localPlayer)
	{
		surfaceRender.text(x, y, font, XOR("Hello undefined :)"), false, Colors::Yellow);
		// going to hardcode the padding for this
		y += 15;
	}
	else
	{
		surfaceRender.text(x, y, font,
			FORMAT(XOR("Hello {} :) Local Player {:#0x}"), game::localPlayer->getName(), game::localPlayer->getLiteralAddress()),
			false, Colors::Yellow);
		y += 15;
	}

	int yBackup = y;
	
	for (size_t i = 0; const auto& [x88p, limits] : x88types.getVars())
	{
		Color color = index == i ? highlight : normal;

		if (!(i % 10) && i != 0)
		{
			x += 150; // hardcode
			y = yBackup;
		}

		auto value = x88p.second;
		auto name = x88p.first;

		auto vecSize = surfaceRender.getTextSizeXY(font, name);
		auto vecX = static_cast<int>(vecSize[Coord::X]);
		auto vecY = static_cast<int>(vecSize[Coord::Y]);

		if (std::holds_alternative<bool*>(value))
		{
			auto val = *std::get<bool*>(value);
			Color active = val ? Colors::LightBlue : Colors::White;

			surfaceRender.text(x, y, font, name, false, color);
			surfaceRender.text(x + addSpaces(name) + vecX, y, font,
				FORMAT(XOR("{}"), val), false, active);
			y += vecY;
		}
		else if(std::holds_alternative<int*>(value))
		{
			surfaceRender.text(x, y, font, name, false, color);
			surfaceRender.text(x + addSpaces(name) + vecX, y, font,
				FORMAT(XOR("{}"), *std::get<int*>(value)), false, color);
			y += vecY;
		}
		else if (std::holds_alternative<float*>(value))
		{
			surfaceRender.text(x, y, font, name, false, color);
			surfaceRender.text(x + addSpaces(name) + vecX, y, font,
				FORMAT(XOR("{:.2f}"), *std::get<float*>(value)), false, color);
			y += vecY;
		}

		i++;
	}

}

void X88Menu::init()
{
	x88types.push(XOR("Chams"), &vars::visuals->chams->indexPlayers, magic_enum::enum_count<ChamsType>() - 1);
	x88types.push(XOR("ESP"), &vars::visuals->esp->boxes->enabled);
	x88types.push(XOR("FOV"), &vars::misc->fov->value, { -50.0f, 50.0f} );
	x88types.push(XOR("Backtrack"), &vars::backtrack->enabled);
	x88types.push(XOR("Backtrack MS"), &vars::backtrack->time, { 0.0f, 200.0f });
	x88types.push(XOR("No Sky"), &vars::visuals->world->sky->removeSky);
	x88types.push(XOR("2D Radar"), &vars::misc->radar->enabled);
	x88types.push(XOR("Bunnyhop"), &vars::misc->bunnyHop->enabled);
	x88types.push(XOR("Autostrafe"), &vars::misc->bunnyHop->indexStrafe, magic_enum::enum_count<MovementStraferMode>() - 1);
	x88types.push(XOR("ThirdP"), &vars::misc->thirdp->enabled);
	x88types.push(XOR("Draw Info"), &vars::misc->info->enabled);

	size_t longest = 0;
	for (const auto& [x88p, limits] : x88types.getVars())
	{
		if (auto size = static_cast<size_t>(surfaceRender.getTextSizeXY(fonts::tahoma, x88p.first)[Coord::X]); size > longest)
			longest = size;
	}
	m_longestNameSize = longest;

	m_inited = true;
}

size_t X88Menu::addSpaces(const std::string& text)
{
	// 5px added to align them well for max size
	auto size = (m_longestNameSize + 5) - surfaceRender.getTextSizeXY(fonts::tahoma, text)[Coord::X];
	return static_cast<size_t>(size);
}

void X88Menu::handleKeys()
{
	if (!vars::keys->enabledX88Menu)
		return;

	if (!m_inited)
		return;

	if (inputHandler.isKeyPressed(VK_DOWN))
	{
		if (index != x88types.getVars().size() - 1)
			index++;
		else
			index = 0;
	}

	if (inputHandler.isKeyPressed(VK_UP))
	{
		if (index != 0)
			index--;
		else
			index = x88types.getVars().size() - 1;
	}

	auto current = x88types.getVars().at(index);
	auto& value = current.first.second;
	auto limits = current.second;

	if (std::holds_alternative<bool*>(value))
	{
		// don't care, bools have 0 or 1
		if (inputHandler.isKeyPressed(VK_RIGHT) || inputHandler.isKeyPressed(VK_LEFT))
		{
			*std::get<bool*>(value) = !*std::get<bool*>(value);
		}
	}
	else if (std::holds_alternative<int*>(value)) // no passed limits in negative, since I throw only indexes
	{
		// run on stack to make it safe for values changed by
		auto valNow = *std::get<int*>(value);

		if (inputHandler.isKeyPressed(VK_RIGHT))
		{
			valNow++;
			if (valNow > limits.m_intLimtis)
				valNow = 0;

			*std::get<int*>(value) = valNow;
		}
		if (inputHandler.isKeyPressed(VK_LEFT))
		{
			valNow--;
			if (valNow < 0)
				valNow = limits.m_intLimtis;

			*std::get<int*>(value) = valNow;
		}
	}
	else if (std::holds_alternative<float*>(value)) // passed both limits
	{
		auto valNow = *std::get<float*>(value);

		if (inputHandler.isKeyDown(VK_RIGHT))
		{
			valNow += 0.5f;
			if (valNow > limits.m_floatLimits.second) // max
				valNow = limits.m_floatLimits.first; // min

			*std::get<float*>(value) = valNow;
		}
		if (inputHandler.isKeyDown(VK_LEFT))
		{
			valNow -= 0.5f;
			if (valNow < limits.m_floatLimits.first)
				valNow = limits.m_floatLimits.second;

			*std::get<float*>(value) = valNow;
		}
	}
}
```

`hack/menu/x88Menu/x88menu.hpp`:

```hpp
#pragma once

#include <string>

#include "x88types.hpp"

class X88Menu
{
public:
	void draw();
	void init();
	void handleKeys();
private:
	// in pixels, padding for X
	[[nodiscard]] size_t addSpaces(const std::string& text);
	size_t index = 0;
	size_t m_longestNameSize;
	bool m_inited = false;
	X88Types x88types;
};

inline X88Menu x88menu;
```

`hack/menu/x88Menu/x88types.hpp`:

```hpp
#pragma once

#pragma warning(disable: 26495)

#include <variant>
#include <string>
#include <vector>
#include <utility>
#include <type_traits>

// pair in pair
class X88Types
{
private:
	// ptr to get actual config vars updated
	using Types = std::variant<bool*, int*, float*>;
	using X88Pair = std::pair<std::string, Types>;

	struct Limits
	{
		Limits() = default;
		constexpr Limits(const std::pair<float, float>& limits)
			: m_floatLimits{ limits }
		{}
		constexpr Limits(int limits)
			: m_intLimtis{ limits }
		{}

		std::pair<float, float> m_floatLimits;
		int m_intLimtis;
	};
public:
	template<typename T>
	constexpr void push(const std::string& name, const T& var)
	{
		m_vars.emplace_back(std::make_pair(X88Pair{ name, var }, Limits{}));
	}
	template<typename T>
	constexpr void push(const std::string& name, const T& var, const std::pair<float, float>& limits)
	{
		m_vars.emplace_back(std::make_pair(X88Pair{ name, var }, Limits{ limits }));
		return;
	}
	template<typename T>
	constexpr void push(const std::string& name, const T& var, int limits)
	{
		m_vars.emplace_back(std::make_pair(X88Pair{ name, var }, Limits{ limits }));
	}
	constexpr std::vector<std::pair<X88Pair, Limits>> getVars() const { return m_vars; }
private:
	std::vector<std::pair<X88Pair, Limits>> m_vars;
};
```

`hack/render/BBox.cpp`:

```cpp
#include "BBox.hpp"

#include "render.hpp"

#include <SDK/ICollideable.hpp>
#include <SDK/structs/Entity.hpp>
#include <utilities/math/math.hpp>

Box::Box(Entity_t* ent)
{
	const auto col = ent->collideable();
	if (!col)
	{
		m_isValid = false;
		return;
	}
	const auto& min = col->OBBMins();
	const auto& max = col->OBBMaxs();
	const auto& matrixWorld = ent->renderableToWorldTransform();

	float left = std::numeric_limits<float>::max();
	float top = std::numeric_limits<float>::max();
	float right = -std::numeric_limits<float>::max();
	float bottom = -std::numeric_limits<float>::max();

	const auto points = buildAABB(min, max);

	std::array<ImVec2, 8> screen = {};
	for (size_t i = 0; auto & el : screen)
	{
		if (!imRender.worldToScreen(math::transformVector(points.at(i), matrixWorld), el))
		{
			m_isValid = false;
			return;
		}

		left = std::min(left, el.x);
		top = std::min(top, el.y);
		right = std::max(right, el.x);
		bottom = std::max(bottom, el.y);

		this->points.at(i) = el;

		i++;
	}

	this->x = left;
	this->y = top;
	this->w = right - left;
	this->h = bottom - top;

	// get important points, eg: if you use 3d box, you want to render health by quads, not rects

	this->topleft = screen.at(7);
	this->topright = screen.at(6);
	this->bottomleft = screen.at(3);
	this->bottomright = screen.at(2);

	m_isValid = true;
}

std::array<Vec3, 8> Box::buildAABB(const Vec3& min, const Vec3& max)
{
	std::array points =
	{
		Vec3{ min[Coord::X], min[Coord::Y], min[Coord::Z] },
		Vec3{ min[Coord::X], max[Coord::Y], min[Coord::Z] },
		Vec3{ max[Coord::X], max[Coord::Y], min[Coord::Z] },
		Vec3{ max[Coord::X], min[Coord::Y], min[Coord::Z] },
		Vec3{ min[Coord::X], min[Coord::Y], max[Coord::Z] },
		Vec3{ min[Coord::X], max[Coord::Y], max[Coord::Z] },
		Vec3{ max[Coord::X], max[Coord::Y], max[Coord::Z] },
		Vec3{ max[Coord::X], min[Coord::Y], max[Coord::Z] }
	};

	return points;
}
```

`hack/render/BBox.hpp`:

```hpp
#pragma once
#pragma warning(disable:26495)

#include <SDK/math/Vector.hpp>
#include <imgui.h>

#include <array>
#include <utility>

class Entity_t;

struct Box final
{
	Box() = default;
	constexpr Box(float x, float y, float w, float h) :
		x{ x }, y{ y }, w{ w }, h{ h }
	{}
	constexpr Box(const std::array<ImVec2, 8>& arr) :
		points{ arr }
	{}
	Box(Entity_t* ent);

	constexpr bool isValid() const { return m_isValid; }

	std::array<ImVec2, 8> points;
	float x, y, w, h;
	ImVec2 topleft;
	ImVec2 topright;
	ImVec2 bottomleft;
	ImVec2 bottomright;
private:
	std::array<Vec3, 8> buildAABB(const Vec3& min, const Vec3& max);
	bool m_isValid;
};
```

`hack/render/Color.cpp`:

```cpp
#include "Color.hpp"

#include <imgui_impl_dx9.h>

ImVec4 Color::getImguiColor(const Color& color)
{
	return ImVec4{ color.r(), color.g(), color.b(), color.a() };
}

Color Color::getColorEditAlpha(const float amount) const
{
	Color clr = *this;
	clr.at(3) = amount;
	return clr;
}

Color Color::getColorEditAlphaInt(const int amount) const
{
	Color clr = *this;
	clr.at(3) = amount / 255.0f;
	return clr;
}

Color Color::fromHSB(float hue, float saturation, float brightness)
{
	float h = hue == 1.0f ? 0.0f : hue * 6.0f;
	float f = h - h;
	float p = brightness * (1.0f - saturation);
	float q = brightness * (1.0f - saturation * f);
	float t = brightness * (1.0f - (saturation * (1.0f - f)));

	if (h < 1.0f)
	{
		return Color{ brightness, t, p };
	}
	else if (h < 2.0f)
	{
		return Color{ q, brightness, p };
	}
	else if (h < 3.0f)
	{
		return Color{ p, brightness, t };
	}
	else if (h < 4.0f)
	{
		return Color{ p, q, brightness };
	}
	else if (h < 5.0f)
	{
		return Color{ t, p, brightness };
	}
	else
	{
		return Color{ brightness, p, q };
	}
}

Color Color::hslToRGB(float hue, float saturation, float lightness)
{
	auto huetoRGB = [](float p, float q, float t)
	{
		if (t < 0.0f)
			t += 1.0f;
		if (t > 1.0f)
			t -= 1.0f;
		if (t < 1.0f / 6.0f)
			return p + (q - p) * 6.0f * t;
		if (t < 1.0f / 2.0f)
			return q;
		if (t < 2.0f / 3.0f)
			return p + (q - p) * (2.0f / 3.0f - t) * 6.0f;
		return p;
	};

	float r, g, b;

	if (saturation == 0.0f)
		r = g = b = lightness;
	else
	{
		float q = lightness < 0.5f ? lightness * (1.0f + saturation) : lightness + saturation - lightness * saturation;
		float p = 2.0f * lightness - q;
		r = huetoRGB(p, q, hue + 1.0f / 3.0f);
		g = huetoRGB(p, q, hue);
		b = huetoRGB(p, q, hue - 1.0f / 3.0f);
	}

	return Color{ r, g, b };
}

ImU32 Color::U32(const Color& color)
{
	return ImGui::GetColorU32(Color::getImguiColor(color));
}

#include <cmath>
#include <numbers>

Color Color::rainbowColor(const float gameTime, const float multiply)
{
	return Color(
		std::cos(gameTime * multiply) * 0.5f + 0.5f,
		std::cos(gameTime * multiply - 2.0f * std::numbers::pi_v<float> / 3.0f) * 0.5f + 0.5f,
		std::cos(gameTime * multiply - 4.0f * std::numbers::pi_v<float> / 3.0f) * 0.5f + 0.5f);
}

Color Color::healthBased(uint8_t health, uint8_t alpha)
{
	int g = static_cast<int>(health * 2.55f);
	int r = 255 - g;
	return Color(r, g, 0, alpha);
}

```

`hack/render/Color.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <array>
#include <stdexcept>

using ImU32 = unsigned int;
struct ImVec4;

// 0.0 - 1.0, you can pass ints as 0-255 though
class Color
{
public:
	Color() = default;
	constexpr Color(float r, float g, float b, float a = 1.0f)
	{
		setColor(r, g, b, a);
	}
	constexpr Color(int r, int g, int b, int a = 255)
	{
		setColor(r / 255.0f, g / 255.0f, b / 255.0f, a / 255.0f);
	}
	constexpr Color(const std::array<float, 4>& colArr)
	{
		setColor(colArr.at(0), colArr.at(1), colArr.at(2), colArr.at(3));
	}
	constexpr Color(float colArr[4])
	{
		setColor(colArr[0], colArr[1], colArr[2], colArr[3]);
	}
	constexpr Color(const Color& col, float alpha)
	{
		setColor(col.r(), col.g(), col.b(), alpha);
	}

	constexpr void setColor(float r, float g, float b, float a = 1.0f)
	{
		m_color.at(0) = r; m_color.at(1) = g; m_color.at(2) = b; m_color.at(3) = a;
	}

	constexpr void setAlpha(float a) { m_color.at(3) = a; }
	constexpr void setAlphaInt(int a) { m_color.at(3) = a / 255.0f; }

	constexpr auto get() const { return m_color; }
	constexpr auto& getRef() { return m_color; }
	constexpr auto data() { return m_color.data(); }

	[[nodiscard]] constexpr float r() const { return m_color.at(0); }
	[[nodiscard]] constexpr float g() const { return m_color.at(1); }
	[[nodiscard]] constexpr float b() const { return m_color.at(2); }
	[[nodiscard]] constexpr float a() const { return m_color.at(3); }

	[[nodiscard]] static ImVec4 getImguiColor(const Color& color);
	// edits alpha
	[[nodiscard]] Color getColorEditAlpha(const float amount) const;
	[[nodiscard]] Color getColorEditAlphaInt(const int amount) const;

	[[nodiscard]] constexpr uint8_t rMultiplied() const { return static_cast<uint8_t>(m_color.at(0) * 255.0f); }
	[[nodiscard]] constexpr uint8_t gMultiplied() const { return static_cast<uint8_t>(m_color.at(1) * 255.0f); }
	[[nodiscard]] constexpr uint8_t bMultiplied() const { return static_cast<uint8_t>(m_color.at(2) * 255.0f); }
	[[nodiscard]] constexpr uint8_t aMultiplied() const { return static_cast<uint8_t>(m_color.at(3) * 255.0f); }

	constexpr const float operator[](size_t index) const { return m_color.at(index); }
	constexpr float& operator[](size_t index) { return m_color.at(index); }
	constexpr const float at(size_t index) const { if (index >= m_color.size()) throw std::runtime_error("Out of range!"); return m_color.at(index); } // as std, at() is safe
	constexpr float& at(size_t index) { if (index >= m_color.size()) throw std::runtime_error("Out of range!"); return m_color.at(index); }
	constexpr bool operator==(const Color& rhs) const { return (*((uintptr_t*)this) == *((uintptr_t*)&rhs)); }
	constexpr bool operator!=(const Color& rhs) const { return !(operator==(rhs)); }
	[[nodiscard]] static Color fromHSB(float hue, float saturation, float brightness);
	//https://gist.github.com/mjackson/5311256
	[[nodiscard]] static Color hslToRGB(float hue, float saturation, float lightness);
	[[nodiscard]] static Color rainbowColor(const float gameTime, const float multiply = 0.5f); // http://basecase.org/env/on-rainbows
	// health 0-100
	[[nodiscard]] static Color healthBased(uint8_t health, uint8_t alpha = 255);
	[[nodiscard]] static ImU32 U32(const Color& color);
private:
	std::array<float, 4> m_color;
};

// 0-255 & 1byte type
struct SDKColor
{
	SDKColor() = default;
	constexpr SDKColor(uint8_t r, uint8_t g, uint8_t b, uint8_t a = 255)
		: r{ r }, g{ g }, b{ b }, a{ a }
	{}
	constexpr SDKColor(const Color& color)
		: r{ color.rMultiplied() }, g{ color.gMultiplied() }, b{ color.bMultiplied() }, a{ color.aMultiplied() }
	{}

	uint8_t r, g, b, a;
};

namespace Colors
{
	inline Color White = Color(255, 255, 255, 255);
	inline Color Black = Color(0, 0, 0, 255);
	inline Color Red = Color(255, 0, 0, 255);
	inline Color Green = Color(0, 255, 0, 255);
	inline Color DarkBlue = Color(0, 0, 255, 255);
	inline Color LightBlue = Color(0, 140, 250, 255);
	inline Color Grey = Color(128, 128, 128, 128);
	inline Color Yellow = Color(255, 255, 0, 255);
	inline Color Purple = Color(140, 20, 252, 255);
	inline Color Turquoise = Color(60, 210, 200, 255);
	inline Color Palevioletred = Color(220, 110, 150, 255);
	inline Color Pink = Color(255, 100, 180, 255);
	inline Color Coral = Color(255, 127, 80, 255);
	inline Color Cyan = Color(0, 255, 255, 255);
	inline Color Blank = Color(0, 0, 0, 0);
	inline Color Orange = Color(255, 125, 0, 255);
}
```

`hack/render/iconfont.hpp`:

```hpp
#pragma once

constexpr size_t iconFontSize = 38581;
constexpr size_t iconFont[38584 / 4] =
{
    0x0000bc57, 0x00000000, 0xdca20000, 0x00000400, 0x00010037, 0x000b0000, 0x00030080, 0x2f534f30, 0x24de1132, 0x010000f6, 0x2c158238, 0x616d6360,
    0x4f884d70, 0x02000089, 0x240382d0, 0x73616724, 0x24178270, 0xa2000010, 0x380782d4, 0x796c6708, 0x69fa9066, 0x05000031, 0x99000094, 0x61656878,
    0x7b532164, 0x201b828b, 0x210382bc, 0x10826836, 0x0df01023, 0x200b82a5, 0x280382f4, 0x746d6824, 0x19613978, 0x205f821c, 0x2b038298, 0x636f6c36,
    0x34165a61, 0x04000056, 0x9e281f83, 0x7078616d, 0x51025f00, 0x18201b82, 0x202c2f82, 0x656d616e, 0xe3257a0e, 0x0c9f0000, 0xfa300f82, 0x74736f70,
    0x84bc539f, 0x08a00000, 0xcc020000, 0x012dbb84, 0xa2759a19, 0x0f5f8770, 0x0900f53c, 0x24268204, 0x00da0000, 0x2cbf8349, 0xd406db00, 0xff02001e,
    0x032d0df4, 0x221882aa, 0x82020008, 0x30028305, 0x03000001, 0x00c0ffc0, 0x009a0d00, 0x0dfdff00, 0x8349842d, 0x20038719, 0x2411844d, 0x0050024e,
    0x82128410, 0x89078431, 0x07032a04, 0x0090019a, 0x02000005, 0x22898299, 0x858f0000, 0xeb012507, 0x09013300, 0x09852689, 0x0b854485, 0x00822020,
    0xe0400025, 0x8412e200, 0x03402483, 0x824000c0, 0x82012019, 0x02002403, 0x83cd0200, 0x08038907, 0x0080062b, 0x00000a60, 0x004d0550, 0x00e60559,
    0x001a0b50, 0x00660956, 0x009a0d54, 0x001a0962, 0x004d0b5c, 0x00160c4d, 0x00b30a54, 0x20138265, 0x0827825b, 0x00056024, 0xb3095700, 0xe60a5c00,
    0x9a0a6200, 0xe6075e00, 0x66096300, 0x660a5600, 0x66066100, 0x33056500, 0x23825b00, 0x1a065928, 0x4d086200, 0x43824f00, 0x63200783, 0x4e2e0782,
    0x5400800a, 0x5600800c, 0x5400cd08, 0x03820002, 0x5900e626, 0x5b001a02, 0x58249782, 0x61009a03, 0x592c0b82, 0x9300a602, 0x08000004, 0x2300a606,
    0x63822783, 0x5f825320, 0x05532408, 0x075c009a, 0x035d004d, 0x04340032, 0x065300da, 0x03770095, 0x06580076, 0x071d003c, 0x030e00c1, 0x82440000,
    0x03022403, 0x823b00e6, 0x82252007, 0x091d2d03, 0x095e004d, 0x0850004c, 0x085300cd, 0x8f82d782, 0x4d095422, 0x0f830b82, 0x08208382, 0x53200785,
    0x54280782, 0x7000fe08, 0x73000209, 0x43200b82, 0x93240382, 0x85009608, 0x3b830782, 0x6c09be27, 0xcc007a00, 0x82008300, 0x83002056, 0x001c2203,
    0x210e8301, 0x0d821e01, 0x46080983, 0x0104001c, 0x00000002, 0x0020002e, 0xe00e0004, 0xe00be004, 0xe011e00e, 0xe024e013, 0xe030e028, 0xe039e031,
    0xe040e03d, 0xe048e045, 0xe14ee04c, 0xe1f7e1f4, 0xe200e2fd, 0xff12e20b, 0xe00000ff, 0xe007e000, 0x8210e00d, 0xe017242f, 0x842ae026, 0xe03b242f,
    0x8244e03f, 0x864a202f, 0x82f9202f, 0xe202272f, 0x20ffff0d, 0x33821f01, 0x20000029, 0x1f000009, 0x82f61ff7, 0x82f02003, 0x82ee2009, 0x1fe82d03,
    0x1ee61fe7, 0x1e441e46, 0x1e411e43, 0x2308fb41, 0x2c002a00, 0x03839d82, 0x02820682, 0x03823e20, 0x06821d83, 0x3220028a, 0x22080b82, 0x002b000b,
    0x000e000c, 0x0010004d, 0x00120011, 0x00140013, 0x00160015, 0x000f0017, 0x001a0019, 0x8218001b, 0x000d364d, 0x0027002c, 0x004c002f, 0x00370036,
    0x00380035, 0x01000039, 0x103f8206, 0x01010200, 0x00089e08, 0x02f40008, 0x032c037a, 0x055604ba, 0x076006a2, 0x0af0084a, 0x0de20b4a, 0x0f4e0e4c,
    0x12321100, 0x154014a0, 0x18381726, 0x1aa61914, 0x1c9a1b60, 0x1f321ef2, 0x23fa209a, 0x27de25d6, 0x29ec2892, 0x2aec293a, 0x2b342ba2, 0x2d902cd2,
    0x2e982e50, 0x31b42ff4, 0x33dc3126, 0x35463412, 0x360c367a, 0x36b2366c, 0x38b037fc, 0x397a3850, 0x395a3924, 0x3a6e3ab0, 0x3ce23bfc, 0x3fb03dd0,
    0x41984030, 0x44c24260, 0x47e44562, 0x49604858, 0x4ad44972, 0x4bb24a62, 0x4cf44b4e, 0x000000bc, 0x85038201, 0x02280802, 0x02390000, 0x60000200,
    0x14062700, 0x93005a03, 0x0000af00, 0x013e3225, 0x26272633, 0x37023e35, 0x3637013e, 0x33163233, 0x3e250782, 0x37343503, 0x21118236, 0x06822033,
    0x3637363c, 0x35263435, 0x2e233437, 0x23262701, 0x010e0722, 0x23272223, 0x07010e22, 0x16832223, 0x06222526, 0x23262223, 0x26351a82, 0x06220723,
    0x012e2207, 0x15222722, 0x14151614, 0x06070607, 0x290d822b, 0x010e2326, 0x1e14011d, 0x14821701, 0x0e07062d, 0x15060703, 0x1e173314, 0x82141501,
    0x2a258308, 0x16171415, 0x23220601, 0x82270622, 0x012e2a66, 0x35013c35, 0x3a333634, 0x82938201, 0x076a084a, 0x46225701, 0x0904254a, 0x0d0b0707,
    0x180b0405, 0x1f080a07, 0x1428150f, 0x0b17150b, 0x0c13150d, 0x2b02111b, 0x04170d07, 0x02040608, 0x0115040d, 0x0f0b0c04, 0x0813140a, 0x07080614,
    0x050e0202, 0xc4fe0601, 0x07030305, 0x28eb060c, 0xc70a0a0c, 0x0728180f, 0x1e081409, 0x2a03040f, 0x1c07060e, 0x02040806, 0x090c1304, 0x07820905,
    0x24211738, 0x4b14080b, 0x04022937, 0x18132b28, 0x082e021e, 0x250d1122, 0x1c820b0d, 0x28017208, 0x11211111, 0x0702021c, 0x0a0d0427, 0x21090e12,
    0x1b1f3d3f, 0x0d06112e, 0x02030102, 0x0d020502, 0x0c342036, 0x02011609, 0x0f141057, 0x0b170e0d, 0x04020612, 0x060a1604, 0x0a04020c, 0x04070502,
    0x05050d03, 0x020a010f, 0x0a031808, 0x06040c04, 0x0c181602, 0x02010306, 0x13081106, 0x100c060f, 0x110a0e03, 0x0f100a07, 0x0108060b, 0x03242b02,
    0x089f820f, 0x38875043, 0x04032d3f, 0x04129401, 0x0b050404, 0x13070906, 0x031a1225, 0x1f0f1331, 0x0000000d, 0x00500004, 0x038f0927, 0x0078005a,
    0x010401f2, 0x2500001b, 0x07232622, 0x26012f22, 0x34272635, 0x35263427, 0x07cb4134, 0x27012e22, 0x263b0d87, 0x33013e35, 0x37361732, 0x011e3735,
    0x33363217, 0x1f323316, 0x23352101, 0x82363736, 0x20138217, 0x05b14116, 0x2315062a, 0x0607010e, 0x22272223, 0x2206ad41, 0x84061507, 0x2326240f,
    0x83010f22, 0x06072c1b, 0x14171415, 0x27050607, 0x82262723, 0x35362161, 0x79826882, 0x33236c84, 0x8237013e, 0x87272002, 0x3633257b, 0x012e3435,
    0x16217d84, 0x21838217, 0x68823735, 0x83371721, 0x023e217b, 0x49827b84, 0x23011d22, 0x61826283, 0x06222723, 0x20638207, 0x22628314, 0x82141516,
    0x8289827b, 0x0e072417, 0x83140703, 0x060724a1, 0x82023e01, 0x2a9d82e9, 0x1f161415, 0x16171601, 0x823f3605, 0x832720e8, 0x824682b1, 0x339c089b,
    0x01031e17, 0x1a260569, 0x0c181a47, 0x04163002, 0x01040803, 0x151f3321, 0x0408143a, 0x0f26190a, 0x0d050207, 0x112a220a, 0x0403270c, 0x121f3d1f,
    0x080d5413, 0x05011102, 0x060e080c, 0x010b041a, 0x06070402, 0x02510503, 0x0b090203, 0x1b29617d, 0x03151010, 0x261f1c0a, 0x0d3c2929, 0x170b0b0c,
    0x1305080a, 0x03080a0f, 0x377b0409, 0x090c0277, 0x23130411, 0x02020212, 0x2108020e, 0x06260f0d, 0x143a0a0d, 0x11110609, 0x02030333, 0x11071008,
    0x101e0f0e, 0x08180c0c, 0x0955aa03, 0x05252482, 0x0d0d0209, 0x08448230, 0x120455af, 0x17210614, 0x33213d35, 0x02180c1a, 0x0d020402, 0x2b233b56,
    0x161e1011, 0x0d0f0c11, 0x1002090b, 0x2f64fc12, 0x2a020633, 0x03351982, 0x0f0f1802, 0x5de90415, 0x0a090406, 0x1013711a, 0x15190409, 0x0f140305,
    0x291e201d, 0x0f0a0103, 0x0c051416, 0x14150406, 0x121d1309, 0x3f7b4112, 0x07271111, 0x07090804, 0x24030a11, 0x06082e35, 0x01120709, 0x0305011b,
    0x0301041a, 0x090b030d, 0x04060709, 0x1c0c0d08, 0x24190606, 0x0603212f, 0x14030402, 0x19130f0d, 0x020a2610, 0x0b0d0a0b, 0x0d0d0303, 0x30411019,
    0x351a1425, 0x02210c11, 0x08a18201, 0x0820094b, 0x09040309, 0x0d0e0506, 0x361d0a09, 0x221e4121, 0x1425244a, 0x11070209, 0x2f0e070b, 0x0f130b29,
    0x04090708, 0x19100302, 0x07040101, 0x0a010117, 0x07050301, 0x0f5c0b05, 0x14145008, 0x02020609, 0x180a1709, 0x070d0611, 0x08ac8206, 0x040e0438,
    0x10040b21, 0x38333514, 0x0b292319, 0x09171d0a, 0x17079e01, 0x17220c1e, 0x04270a04, 0x04170c11, 0x0c060a06, 0x12201324, 0x0d04020c, 0x090a2a0b,
    0x010d0614, 0x00820001, 0x59000234, 0xd4042700, 0x6d005a03, 0x00008200, 0x013e013f, 0xc3443237, 0x37362306, 0x0e823736, 0x34353625, 0x821f3336,
    0x16172e16, 0x013e3233, 0x35273435, 0x33363734, 0x200d8232, 0x20078336, 0x2f208317, 0x34373437, 0x012f2627, 0x23062206, 0x26272221, 0xd7440485,
    0x05f14205, 0x43141521, 0x0f22051d, 0x14430601, 0x1e100905, 0x35220101, 0x3b343537, 0x16173201, 0x14150715, 0x23262223, 0x31a50722, 0x11274d27,
    0x020e1117, 0x0c0b0704, 0x08050303, 0x170e1122, 0x111e1f25, 0x06363311, 0x1b192704, 0x0fd61405, 0x15020309, 0x0b030e1f, 0x08060102, 0x09050a12,
    0xd7fe070c, 0x05060103, 0x0606cffd, 0x02074025, 0x12181404, 0x1c460609, 0x08030812, 0x0e160f0f, 0x01190d0b, 0x13011c85, 0x09045b77, 0x17011401,
    0x27164444, 0x01050103, 0x0c0f0508, 0x0907010e, 0x0a273321, 0x330c0812, 0x01011a1c, 0x21020301, 0x1212054b, 0x0e170803, 0x050c1f01, 0x12060605,
    0x0b0c1d05, 0x03261e46, 0x01230101, 0x04170406, 0x06030502, 0x64130e03, 0x2713131f, 0x0b090d21, 0x17081224, 0x4a48352a, 0x19102d33, 0x16980118,
    0x01142d19, 0x291b1205, 0x00020112, 0x00500002, 0x03730526, 0x0057005a, 0x25000064, 0x22373621, 0x35262726, 0x3e153734, 0x033e3701, 0x34353637,
    0x26012f26, 0x3b057744, 0x3233023e, 0x33161716, 0x1e373620, 0x1d323301, 0x14171401, 0x010e0706, 0x15020e07, 0x2605bd43, 0x2e222327, 0x41222303,
    0x1a820648, 0x35320130, 0x012b3437, 0x07150622, 0xac013314, 0xfe82f0fe, 0x0d288b08, 0x2b190e09, 0x17180b16, 0x020f080f, 0x030e2a28, 0x0c211405,
    0x07180b0d, 0x03040102, 0x0d1803e9, 0x07072601, 0x4f28210a, 0x04365e7a, 0x288d0309, 0x16191031, 0x16060a15, 0x2d20160f, 0x020b0919, 0xb0011001,
    0x9e11021c, 0x10010d11, 0x07110e26, 0x0c110f14, 0x44200339, 0x21201122, 0x28211229, 0x14173205, 0x09792108, 0x02010e03, 0x0d0a1704, 0x07070702,
    0x0c0a0a03, 0x034c1865, 0x04040304, 0x270f1f04, 0x2008091c, 0x0d820101, 0x21180634, 0x14447d31, 0x130e1619, 0x2e1db301, 0x2b12101f, 0x0082001d,
    0x00022408, 0x0a400056, 0x004003a0, 0x00650055, 0x37362500, 0x35262726, 0x17161733, 0x3721013f, 0x21371733, 0x82323717, 0x012f2d0b, 0x0f142335,
    0x26272302, 0x25272327, 0x0726f382, 0x06072721, 0x04832607, 0x13320383, 0x32332425, 0x16070617, 0x013f3233, 0x37363736, 0x04821716, 0x16283882,
    0x22011617, 0x3435022e, 0x32220e82, 0x39821516, 0x1a06c008, 0x399b1953, 0x020f9a1a, 0x0145151d, 0x12d80353, 0x242e010f, 0x130d0d13, 0x2e2b0d05,
    0xb00d2c03, 0xc81b1e16, 0x1b20fe46, 0xfd0a0504, 0x5a660991, 0xa2272831, 0x313a316e, 0x01160e1b, 0x1096010a, 0x4126210a, 0x2e053a0a, 0x27140914,
    0x351e1f43, 0x09211a1c, 0x428a400c, 0x102872fe, 0x081a060c, 0x0b160f46, 0x86400d05, 0x3c8b6c20, 0x05040a39, 0x0e132505, 0x03210e13, 0x051f0b07,
    0x600c0d79, 0x221f0e05, 0x02020516, 0x57090802, 0x0c080b1b, 0x0101090a, 0xfe0c090c, 0x189658c3, 0x0a418733, 0x451e2409, 0x03021937, 0x07050e06,
    0x4490bb02, 0x0b068c01, 0x091e070d, 0x14160102, 0x41060619, 0x542d0537, 0xfc08f4ff, 0x1e008d03, 0x0000f500, 0x2ed78201, 0x010f1715, 0x0f230727,
    0x17010e02, 0x4617011e, 0x36390644, 0x01232726, 0x013d2223, 0x2f262726, 0x26220701, 0x06070623, 0x1716010f, 0x05904614, 0x35262737, 0x36023f34,
    0x36352533, 0x3517013f, 0x23141523, 0x0723012f, 0x3e168223, 0x37173337, 0x3233013e, 0x37353715, 0x33361517, 0x33353317, 0x07153315, 0x23352315,
    0x85163217, 0x8b12830e, 0x15172303, 0x38822117, 0x17373322, 0x16243a82, 0x16333733, 0x23269682, 0x010e2726, 0x01822723, 0x05210683, 0x24088207,
    0x14072307, 0x20a78207, 0x05a54615, 0x011f1624, 0xa3820f14, 0x36373428, 0x34273435, 0xa4832737, 0x0624a782, 0x012f2207, 0x20078644, 0x09ba8627,
    0x16171635, 0x04071415, 0x0404078b, 0x0e160503, 0x06081b06, 0x04010537, 0x4b060903, 0x080b2015, 0x08032f36, 0x38fe5e0a, 0x13200902, 0x34210e2b,
    0x1c030d03, 0x08073d34, 0x06120b0e, 0x16064749, 0x0e033d0c, 0x020d1c24, 0x1f1716bb, 0x0e10112a, 0x0e052702, 0x070a090a, 0x0d040126, 0x17150b0e,
    0x0f103ba9, 0x0c16160d, 0x0a140937, 0x26112406, 0x27102610, 0x1e10270f, 0x5901144e, 0x140a290f, 0x06012b0a, 0x0f0b0a1f, 0x05050537, 0x0a0a3107,
    0x051f0d07, 0x01180431, 0xfe0c3105, 0x060811be, 0x09430507, 0x081a080e, 0x02010104, 0x2a110118, 0x16062627, 0x61532613, 0x1a473223, 0x5e5e4014,
    0x0202040a, 0x1b0b1d0a, 0x05a21c10, 0x0703130c, 0x07242d1c, 0x05f9010a, 0x17060b05, 0x0e010106, 0x0a640702, 0x08060812, 0x080b0202, 0x054d5307,
    0xfbfd1016, 0x3d460a1e, 0x2902ae85, 0x2a240a0f, 0x110f1b18, 0x03020715, 0x32fd2109, 0x1d150c10, 0x10080f11, 0x3901050f, 0x07050a02, 0x21230e06,
    0x04020504, 0x13010d0a, 0x190e0203, 0x6d04060c, 0x0d070501, 0x88041805, 0x27800800, 0x09090b1a, 0x03050206, 0x1a0a0703, 0x01030a19, 0x04030301,
    0x08050304, 0x44060612, 0x0308040c, 0x0f1b0507, 0x37360608, 0x06032623, 0x09070707, 0x084f1e3c, 0x13092910, 0x47180404, 0x0b09256b, 0x17070205,
    0x1037162f, 0x201d1417, 0x0e0d0506, 0x5f422807, 0x06092ea0, 0x02000609, 0x8d006200, 0xf3022b0d, 0x89007f00, 0x3f250000, 0x16373304, 0x36023f17,
    0x35251533, 0x06173736, 0x22232623, 0x3305f341, 0x26373317, 0x37213727, 0x34373634, 0x23352726, 0x35362135, 0x2c080782, 0x17373521, 0x022f1735,
    0x35230706, 0x07273732, 0x06151615, 0x06072723, 0x16150623, 0x3736011f, 0x06231533, 0x14070607, 0x012e2107, 0x2f098321, 0x15060722, 0x1f140714,
    0x013f3201, 0x32371733, 0xbb082282, 0x16011f16, 0x35222325, 0x32013b34, 0x3a031415, 0x080e1036, 0x26050901, 0x1322351e, 0x08011504, 0x16dfa202,
    0x101f0610, 0x050f0603, 0x0706052f, 0x06d90105, 0x13040103, 0x12c8045a, 0x92f80608, 0x02e72137, 0x64642605, 0x0b0605a7, 0x8b2b0261, 0x0618782e,
    0x38050106, 0x61244a4b, 0x4d120403, 0x25c8fe0f, 0x07e9fe08, 0x1e020308, 0x03061767, 0x3a3b0e03, 0x030d284c, 0x20970d03, 0x01502b39, 0x1b1b4030,
    0x068d1b40, 0x232f2b17, 0x05021803, 0x53060f12, 0x2d03501c, 0x0e080903, 0x0d0f0906, 0x07110623, 0x040d0c05, 0x0c0a0408, 0x1b154e13, 0x050c1b0b,
    0x0405011a, 0x0503840e, 0x083c2182, 0x06120620, 0x07040413, 0x4c090603, 0x0a07030e, 0x0504011d, 0x2530100d, 0x02040604, 0x34080e82, 0x84595a09,
    0x0a0d0314, 0x50030808, 0x0d0f3b17, 0x18181da7, 0x0200001d, 0x40005c00, 0x4003a608, 0xa6009600, 0x27250000, 0x07062726, 0x0e23010e, 0x2f260701,
    0x35058301, 0x34352627, 0x37013e37, 0x16153335, 0x32373617, 0x32331617, 0x11823637, 0x33363524, 0x0e821704, 0x07141724, 0x07820706, 0x17321522,
    0x33221882, 0x2782011f, 0x1506142e, 0x22230622, 0x22012b26, 0x23270706, 0x21245283, 0x07222722, 0x25054144, 0x0727022e, 0x5d831d06, 0x17011e2b,
    0x17150623, 0x26272622, 0x82158227, 0x24028266, 0x23262734, 0x28538222, 0x16142306, 0x06151615, 0x09568201, 0x23263527, 0x011d2221, 0x32213314,
    0x043e0217, 0x3c3c0308, 0x0d090301, 0x07080c1d, 0x386a3202, 0x122c0502, 0xd01f1109, 0x281d190f, 0x2f2f7829, 0x06082122, 0x4f1b0902, 0x08aba802,
    0x06021407, 0x26140204, 0x131f6a02, 0x353e2c0b, 0x07010608, 0x101c3318, 0x18871423, 0x050a1729, 0x22141508, 0x1366f6fe, 0x0d011413, 0x2206130d,
    0x14112527, 0x050b0a0d, 0x06070101, 0x25110417, 0x0c070811, 0x03070918, 0x250b1109, 0x11131202, 0x20401a19, 0x07041b09, 0x16de0344, 0x27010e0a,
    0x25253ffd, 0x1cb2e601, 0x7e7f5540, 0x1b070e0a, 0x0a010903, 0x0f1a0a07, 0x80030303, 0x0c192688, 0x06062d14, 0x210d1b16, 0x16040206, 0x0a190918,
    0x0c041519, 0x1d482216, 0x04081413, 0x0c030105, 0x14050401, 0x0c0f0607, 0x01110805, 0x071c2d07, 0x2e060101, 0x04091218, 0x0d060504, 0x041f110a,
    0x0d040916, 0x06261c0a, 0x0301030a, 0x05100705, 0x17225225, 0x0a0a1923, 0x4e150a03, 0x18301816, 0x02312353, 0x220b0c33, 0x25232737, 0x05e74501,
    0x59004d3e, 0x2703e20a, 0x3f012f01, 0x22250000, 0x2726012f, 0x07222726, 0x37362306, 0x07061422, 0x2b230182, 0x82222601, 0x012e2213, 0x05594c23,
    0x0d832320, 0x82373621, 0x34352101, 0x8305b541, 0x2e232717, 0x36343501, 0x61452735, 0x35262105, 0x26055c4c, 0x33363736, 0x85323732, 0x07114206,
    0x33013e22, 0x13841582, 0x45171621, 0x1721056c, 0x284b8232, 0x06352627, 0x27222723, 0x82058222, 0x34352185, 0x17232882, 0x82323316, 0x226d8203,
    0x82373233, 0x1632220f, 0x06564217, 0x1e323325, 0x82141501, 0x022e28a8, 0x22072223, 0x84222326, 0x210722ad, 0x28738432, 0x16013b36, 0x33011e17,
    0x84468426, 0x8216202b, 0x8232202e, 0x25528279, 0x14163237, 0xd04c1516, 0x83062006, 0x203e84d1, 0x22468323, 0x4a171415, 0x2722052b, 0x58831422,
    0x27262226, 0x23343536, 0x2f842582, 0x85233421, 0x216d82b2, 0x4a820625, 0x96823620, 0x010e0722, 0x8f083f83, 0x020c2505, 0x01080608, 0x09010909,
    0x1704050a, 0x0f0e0e01, 0x08091923, 0x15090619, 0x04020902, 0x15100106, 0x3d0f1220, 0x070b0625, 0x05261a12, 0x1e0fa41a, 0xd8774e0e, 0x0c1c3b49,
    0x06010109, 0x04020103, 0x08120302, 0x10351312, 0x0c040707, 0x747a3918, 0x06120a17, 0x1136130a, 0x46111629, 0x10050d08, 0x0f130513, 0x07050b07,
    0x030a0505, 0x0e09570f, 0x17112b66, 0x0205360c, 0x13030803, 0x561e5970, 0x0b0b0c2e, 0x0b0804b0, 0x0a150104, 0x04352a82, 0x2a450802, 0x0e252480,
    0x0d04122f, 0x1e50461f, 0x06130b0b, 0x083c820d, 0x310305e5, 0x64020716, 0x1e1c1616, 0x09100a12, 0x0907041d, 0x0b0bdb07, 0x14050a0f, 0x0403090f,
    0x030c0a09, 0x0707b77e, 0x02010206, 0x8e0e5446, 0x04081808, 0x09060905, 0x0302070c, 0x04020703, 0x19081801, 0x0c0d1f28, 0x0e050702, 0x02020217,
    0xcdbf0c0c, 0x0907093e, 0x080e930d, 0x4e460703, 0x10ebfe1f, 0x2a13093e, 0x0f080307, 0x140c110b, 0x0b591328, 0x01683f48, 0x0c120201, 0x2a030407,
    0x01090322, 0x010a0704, 0x020d0106, 0x30472f21, 0x120d021b, 0x1e22172c, 0x040c2207, 0x194e2e1b, 0x11121e01, 0x060e0c1c, 0x231c1005, 0x0c060515,
    0x150e0304, 0x0502040a, 0x0b051b02, 0x1d010203, 0x1a0b200b, 0x10061001, 0x0c010406, 0x02050405, 0x07060e01, 0x0d111b05, 0x04030201, 0x0d271a01,
    0x03111019, 0x82030a04, 0x0b29085f, 0x02050805, 0x020d1204, 0x17171a02, 0x06012a0e, 0x05030305, 0x0b1a040f, 0x07050416, 0x0d08010b, 0x08032803,
    0x4703100b, 0x081a8221, 0x05040653, 0x13090105, 0x0f0e0509, 0x04020d09, 0x05040e16, 0x0f0a0b0a, 0x010f0107, 0x02060702, 0x0d010201, 0xa5090c03,
    0x160e183a, 0x070b1102, 0x011210f8, 0x03160a16, 0x05060502, 0x5b000300, 0x960b2600, 0xe2005a03, 0xfd00f100, 0x27250000, 0x2f262726, 0x2b028201,
    0x06070607, 0x27262223, 0x2223012e, 0x0f260a82, 0x14150601, 0x804f2223, 0x37362b06, 0x36013f36, 0x022e3435, 0x744b0623, 0x232d8207, 0x34352627,
    0x06833f82, 0x32213322, 0x37202482, 0x3005304d, 0x16173233, 0x3336013b, 0x17021e32, 0x3e323314, 0x26108301, 0x27262133, 0x82141532, 0x21332656,
    0x012f3427, 0x28168234, 0x3237013e, 0x1d06011d, 0x05a94f01, 0x33161725, 0x82323637, 0x242f8269, 0x14071532, 0x23928223, 0x22072307, 0x09821f82,
    0x012f2224, 0xab82012e, 0x0e211082, 0x201c8203, 0x82898420, 0x0e3522b3, 0x201e8201, 0x23b58214, 0x17161415, 0x1e220183, 0x13821701, 0x03010e23,
    0x2ab48232, 0x22012b26, 0x16171415, 0x82251732, 0x36728217, 0x1e23012a, 0x046c0501, 0x09120709, 0x2314200c, 0x11071110, 0x82210f3a, 0x023e0940,
    0x11050703, 0x08151704, 0x2a2a1708, 0x03070613, 0x030c1428, 0x1f0a0c0e, 0x42578b65, 0x31594639, 0x070d0b0c, 0x01030d04, 0x28080706, 0x08105202,
    0x3014140d, 0x0302101a, 0x060d1c06, 0x0f040915, 0x0b06050c, 0x09090204, 0x0e040a35, 0x01131b10, 0x37050226, 0xe0020e04, 0x03010301, 0x170b060b,
    0x0a01080c, 0x28130e22, 0x2f17bb7a, 0x090b3317, 0x020e0713, 0x2b7ed403, 0x140b3146, 0x0f0b0e1c, 0x16031312, 0x33181404, 0x04020b6c, 0x1c050212,
    0x1438e0fe, 0x060b101a, 0x371c0112, 0x040f0c1b, 0x02040201, 0x2a170c03, 0x280e130a, 0x0c042650, 0x03091ce2, 0x1b1b531d, 0xfc25160a, 0x06070518,
    0x45407e3a, 0x03014487, 0x100b0126, 0x5e281d24, 0x07078851, 0x0a091107, 0x02060503, 0x433f0e06, 0x130a1254, 0x04030917, 0x5f060c03, 0x0607213c,
    0x0c0d0f0b, 0x02040603, 0x284b2c24, 0x1e0a1013, 0x1425121e, 0x0e3c2e48, 0x05031c1f, 0x0d170603, 0x0629171c, 0x12040317, 0x04010914, 0x13060301,
    0x0401030b, 0x0e0a0802, 0x07030708, 0x0202011a, 0x3c040406, 0x0303010e, 0x030b1108, 0xe3820208, 0x1c0a0224, 0xed820638, 0x02016c08, 0x08121303,
    0x04031111, 0x05060602, 0x0401120b, 0x0307012e, 0x46040502, 0x0609060b, 0x02150102, 0x1b070907, 0x592d200d, 0x1735196d, 0x0214290e, 0x1bc40107,
    0x24190510, 0x02010121, 0x2449244b, 0x0b2e5e33, 0x00000017, 0x00650003, 0x03420a26, 0x0017005a, 0x00390127, 0x013e0100, 0x23263437, 0x17141522,
    0x2e272207, 0x82062701, 0x011e2f09, 0x3d320133, 0x22373401, 0x0e22012f, 0x0f830701, 0x27262238, 0x3f342726, 0x022e3401, 0x010e013d, 0x2722012b,
    0x06072223, 0x3c822223, 0x010e0725, 0x821e1415, 0x84062003, 0x15162709, 0x27222314, 0x2d823526, 0x34353623, 0x82208227, 0x82352026, 0x4713824d,
    0x3f4505bd, 0x22468406, 0x83343735, 0x067f424a, 0x6e822720, 0x5c820620, 0x3d012e23, 0x06195001, 0x1732212c, 0x32013b16, 0x37342735, 0x06833336,
    0x1f210582, 0x053a5001, 0x0d826482, 0x7b831720, 0x83331621, 0x173328b2, 0x21011d32, 0x82171632, 0x013e230e, 0x06853233, 0x37322128, 0x36173233,
    0x2c82013f, 0x14011d26, 0x36023a33, 0x15211a82, 0x46698214, 0x23290547, 0x23012e22, 0x27230622, 0x22148222, 0x8221010f, 0x010e24ed, 0x5523010f,
    0x15200648, 0x02856182, 0x07141522, 0x2d08f582, 0x2e050607, 0x40030814, 0x040b0818, 0x02120905, 0x09071c01, 0x21043e1d, 0x10080206, 0x0b0b090a,
    0x05030104, 0x040da1fc, 0x02021c0e, 0x23830301, 0x244d072d, 0x06110609, 0x0a040201, 0x82110705, 0x0472083f, 0x12091028, 0x1e474a0a, 0x0e8f060c,
    0x06080713, 0x0318040b, 0xba050a08, 0x24030108, 0x08040b14, 0x0908110a, 0x370b0505, 0x0f0a0207, 0x26040907, 0x07161a1b, 0x20a7010a, 0x0d130504,
    0x01031a0b, 0x0264111c, 0x0202080a, 0x013d7303, 0x051d0e04, 0x19172603, 0x0708070e, 0x17140d15, 0x1008070c, 0x09050106, 0x010a190c, 0x0509095e,
    0x07020202, 0x48820407, 0x0203c908, 0x98010c05, 0x16031865, 0x0a230f0b, 0x08033a0a, 0x080b1103, 0x1d347b07, 0x0e078115, 0x0308081a, 0x090f0405,
    0x08120408, 0x100b1012, 0xf4aafe0a, 0x06030915, 0x09010a02, 0x01010a03, 0x1b060301, 0x0406010c, 0x0d7e2704, 0x03710108, 0x01240f1d, 0x01280b0c,
    0x0a14170b, 0x0d0a1513, 0x4c010312, 0x1b180e09, 0x1f070102, 0xfd1c0407, 0x682d2d69, 0x080d064f, 0x02020405, 0x0b050a03, 0x11020b01, 0x04090b19,
    0x01050d05, 0x14260f04, 0x12060524, 0x06110a05, 0xf70a080b, 0x0c210e17, 0x1a2a0404, 0x06020511, 0x0c161a0a, 0x05120915, 0x05050b0e, 0x0202040a,
    0x1115131d, 0x0e116b12, 0x3f181715, 0x06107da0, 0x0c030624, 0x4a08f982, 0x06050202, 0x01070c10, 0x0a160b01, 0x1508060a, 0x0703150e, 0x011f291b,
    0x01060c03, 0x070b1604, 0x01040603, 0x10020508, 0x0f0d2e15, 0x0b029509, 0x0a1b2002, 0x040b0907, 0x0103040d, 0x07101202, 0x05130301, 0x8a040509,
    0x82030607, 0x180a319e, 0x27142b15, 0x01042650, 0x0d040202, 0x00030628, 0x45080082, 0x005b0007, 0x032d0d26, 0x00ab005a, 0x00bb00b6, 0x00d800cd,
    0x00f900df, 0x35232500, 0x27262726, 0x06232607, 0x07060722, 0x0f060717, 0x07011f02, 0x37361327, 0x0715032f, 0x0f23022f, 0x17071501, 0x35231523,
    0x1c823507, 0x26013308, 0x1f331327, 0x17160501, 0x35332705, 0x35371737, 0x37361733, 0x04333736, 0x1716011f, 0x17013f07, 0x36353735, 0x15170537,
    0x011f1617, 0x013e3733, 0x4f823233, 0x83331721, 0x21352d29, 0x25071517, 0x27013f27, 0x27010f35, 0x27200b82, 0x33235682, 0x82062735, 0x37272279,
    0x226a8227, 0x82050723, 0x0727238c, 0x20820617, 0x15209083, 0x22083c82, 0x17161714, 0x07032f01, 0x35373317, 0x37330723, 0x27251523, 0x17030f21,
    0x3e013f25, 0x26343501, 0x8305012f, 0x2e6e823b, 0x012f013f, 0x022f3315, 0x37350107, 0x82263536, 0x070625bd, 0x2e071714, 0x37242582, 0x14150607,
    0x6008b582, 0x1e150698, 0x130e0508, 0x060f297b, 0x040f1d08, 0x013b0f0d, 0xb9050507, 0x090304a6, 0x0b2a100f, 0x84012102, 0x026d7d20, 0x9c7c254c,
    0x04070101, 0x058b0303, 0x05670104, 0x01220101, 0x23010c22, 0x04580222, 0x01080d0b, 0x0a160db5, 0x02090309, 0x0504091b, 0x0e05e601, 0x11030204,
    0x050f5001, 0x08098213, 0x128b0269, 0x4c02c14f, 0xa7fd0405, 0xc1010c01, 0x1c8b1050, 0x06171e07, 0x04020356, 0x02010c05, 0x090a0211, 0x0a1bfe08,
    0x1803180b, 0x0c020402, 0x05020603, 0x11010803, 0x02082b0c, 0x010507b4, 0x59072f1f, 0x54530c07, 0x6efd5804, 0x0f88fe04, 0x0815050c, 0x0b05a301,
    0x07070807, 0x05acfa0b, 0x05040561, 0x04036304, 0x827d6f04, 0x04723b50, 0x01030ac5, 0x320a1704, 0x05150315, 0x160a0a19, 0x26150c15, 0x38754506,
    0x23820339, 0x37082308, 0x0c030311, 0x030b0a73, 0x21012b0c, 0x1018170c, 0x02050108, 0x180c0248, 0x44020b03, 0x3f4e1b1c, 0x4e821a47, 0x01053d08,
    0x0412055d, 0x0c010604, 0x02090109, 0x058c020f, 0x02300608, 0x5512110d, 0x09052601, 0x02050202, 0x010e0a08, 0x33200402, 0x0a0f0d71, 0x01069404,
    0x7c062405, 0x01180107, 0x01050309, 0x3b080182, 0x0b020818, 0x0d020528, 0x0702050e, 0x091d0812, 0x03050411, 0x15022109, 0x01040504, 0x70070605,
    0x4f070902, 0x020b9832, 0x0d110782, 0x08054a03, 0x0d0d4d1f, 0x0c060281, 0x03083307, 0x2f082082, 0x10090c11, 0x01f40706, 0x03070801, 0x9a070704,
    0x0205090e, 0x0fa9fe02, 0x0a0b0910, 0x1504150b, 0x04121517, 0x0b0c1413, 0x190e0819, 0x000f140f, 0x2a080082, 0x00600003, 0x03e30426, 0x00a8005a,
    0x00c500b5, 0x22232500, 0x2634013d, 0x2622012b, 0x3634012f, 0x35373637, 0x23022e34, 0x45020e07, 0x2b240616, 0x06141501, 0x22820b83, 0x3526272c,
    0x3f363734, 0x35013e01, 0x01821716, 0x954b3320, 0x213b8306, 0x28822f22, 0x17013b2b, 0x32213316, 0x37343635, 0x21208232, 0xb345011e, 0x21618205,
    0xab45013f, 0x14072706, 0x17163233, 0x3e461415, 0x15062206, 0x820c8214, 0x1415225b, 0x21688216, 0xe7581715, 0x26108205, 0x14152726, 0x83222723,
    0x14172717, 0x34353213, 0x0d830723, 0x01266082, 0x1c150622, 0x83481501, 0x2ed10805, 0xc3022301, 0x100f028c, 0x06090a33, 0x13200401, 0x140d0c02,
    0x0a083613, 0x0a040409, 0x0e020707, 0x041b1a40, 0x0711110b, 0x0f0b1109, 0x07020804, 0x4f501d01, 0x08072f7f, 0x10080107, 0x12243914, 0x01011837,
    0x20370505, 0x059c0132, 0x10122e02, 0x0305060b, 0x03010b6f, 0x0a112705, 0x01110408, 0x073a1101, 0x0d050c07, 0x100a1804, 0x8b0b0201, 0x050b040c,
    0x100d0344, 0x23170e12, 0x04182915, 0x01010907, 0x36233382, 0x170b251d, 0x099afd17, 0x02020108, 0x04080d06, 0x10260407, 0x0e03119b, 0x0c040308,
    0x0205578a, 0x141b1505, 0x09090105, 0x5902050d, 0x05020702, 0x070e100d, 0xa854160a, 0x050e140e, 0x02090b07, 0x06030308, 0x01030a05, 0x2e028204,
    0x17030507, 0x04020c0b, 0x02091204, 0x82010201, 0x046d08c6, 0x04081102, 0x21151c0e, 0x1c0b0213, 0x02050c0b, 0x0d0b0d12, 0x01050a03, 0x0406090c,
    0x18011c06, 0x060e121f, 0x0218c70f, 0x1d0a020a, 0xb101058b, 0x0101281e, 0x08081026, 0x0b013b01, 0x10080f07, 0x321a101e, 0x00020119, 0x00020000,
    0x04260057, 0x005a0397, 0x00820051, 0x37322500, 0x27343536, 0x26012f26, 0x3e373435, 0x011f3301, 0x20068232, 0x310d8235, 0x32371733, 0x2737013e,
    0x1d042326, 0x22231401, 0x29823435, 0x26222123, 0x05d64722, 0x2407fd47, 0x16171617, 0x05904d15, 0x14150626, 0x2201011e, 0x48823b82, 0x42321721,
    0x32200525, 0xff4a3582, 0x16332407, 0x83333633, 0x14152117, 0xc8082b82, 0x012f2223, 0x01060722, 0x0d120ab0, 0x01010d1b, 0x1c033104, 0x44951005,
    0x0b1c0848, 0x13af1d3f, 0x05020528, 0xa5fe2002, 0xfe029c01, 0x19020298, 0x06070309, 0x040a050e, 0x07261916, 0x1c121638, 0x1e0d1301, 0x1d17141a,
    0x10900180, 0x1c1a0144, 0x01030310, 0x09182b02, 0x06160e05, 0x090d1809, 0x0149180e, 0x02130402, 0x0f19020b, 0x16152b0a, 0x0304260f, 0x060f0605,
    0x09361a06, 0x57088318, 0x010d0401, 0x0c5b0904, 0x0102012b, 0x187c362e, 0x05060101, 0x01040202, 0x15031003, 0x2e342603, 0x060e3424, 0x1a17120c,
    0x3744222e, 0x201d4a4a, 0x78011a04, 0x22112602, 0x0428011f, 0x040e1815, 0x02070203, 0x140f1e06, 0x0876820b, 0x12030f22, 0x0b12081c, 0x02020114,
    0x00050002, 0x0926005c, 0x015a033a, 0x0176016c, 0x01980187, 0x250000b3, 0x2306784b, 0x012b012e, 0x0724f582, 0x2307010e, 0x2105844f, 0x45492223,
    0x0e332505, 0x26222301, 0x26068f57, 0x011f1415, 0x41012b14, 0x3f240598, 0x36373601, 0x8406244c, 0x010f211f, 0x2e055849, 0x2e273435, 0x34352701,
    0x3f32013e, 0x4c331601, 0x0228093c, 0x37023e37, 0x33363217, 0x27054249, 0x3532011d, 0x32333427, 0x07842282, 0x14011d30, 0x013d3233, 0x32013b34,
    0x33140715, 0x1582023a, 0x17333624, 0x18833237, 0x2b831720, 0x06211983, 0x20258515, 0x20248433, 0x25308337, 0x37331633, 0x33821632, 0x33173222,
    0x32242683, 0x14323337, 0x84068049, 0x079b4c25, 0x3e373229, 0x37343701, 0x82323336, 0x1617302f, 0x011e1415, 0x32013f33, 0x14011f16, 0x8207020e,
    0x0e2727bd, 0x22012b02, 0xf4831415, 0x4c422720, 0x2e278206, 0x06071407, 0x23020e07, 0x3d262722, 0x83363701, 0x23e283f6, 0x27072326, 0x21051e41,
    0x1d823536, 0x47822720, 0x0e255382, 0x1e171502, 0x20528203, 0x27348323, 0x35320301, 0x17213526, 0x1320d082, 0x36247783, 0x012e3435, 0x20053744,
    0x05e74233, 0x27232624, 0xd5820722, 0x05238b82, 0x82033e32, 0x0562525c, 0x012f2623, 0x097b8416, 0x06011f6c, 0x19040472, 0x08071108, 0x260b0303,
    0x0f080b31, 0x19142713, 0x100c1b31, 0x0502030c, 0x07031007, 0x02090304, 0x03010302, 0x08090c0c, 0x1301020d, 0x42230b09, 0x21110e1c, 0x0b0f0431,
    0x1f4b3919, 0x9f2c2431, 0x2d14a4c8, 0x0503022a, 0x29290302, 0x4fa01428, 0x0d1f0dec, 0x1110162c, 0x10071e15, 0x180b0611, 0x03210d1c, 0x05060106,
    0x130c0309, 0x030d0105, 0x020d0f13, 0x04121809, 0x01041804, 0x050b0204, 0x09080202, 0x0f070508, 0x17010105, 0x08120107, 0x05010e12, 0x0404070e,
    0x03070906, 0x04080402, 0x0d0a0206, 0x08010a03, 0x02091809, 0x2b02081b, 0x0f0a7e01, 0x02010d13, 0x0f071807, 0x1a051e04, 0x29080209, 0x05071018,
    0x1a1b0f01, 0x0705040a, 0x10040209, 0x03030203, 0x1417070a, 0x02040507, 0x02011c11, 0x04040201, 0x1b050503, 0x061c140c, 0x02030605, 0x0613140f,
    0x08100f07, 0x1b070b13, 0x190d0312, 0x08220c19, 0x01020506, 0x0903050f, 0x09111012, 0x191e0601, 0x1c251219, 0x2afe0107, 0x90020201, 0x070d3a16,
    0x0b15160d, 0x28273d16, 0x0a1160fd, 0x24160505, 0x0b03081f, 0xcbfe080f, 0x23221f0d, 0x01090c24, 0x03050405, 0x465d1121, 0x0503010e, 0x261b1e01,
    0x44236a13, 0x110a2522, 0x0403131e, 0x99820203, 0x020b3908, 0x0207170b, 0x0a031206, 0x0e121502, 0x05101a12, 0x01110507, 0x0a0f2614, 0x3c1e1909,
    0x0a090655, 0x0c140825, 0x37110f0d, 0x1a073b47, 0x1e102825, 0x274d261e, 0x01071704, 0x0b3e0082, 0x0b110c03, 0x01060706, 0x0b051405, 0x05010520,
    0x12050303, 0x0811072d, 0x04090302, 0x53820a03, 0x09050329, 0x02090301, 0x82010102, 0x0401250e, 0x04030309, 0x1f826d82, 0xfe820b20, 0x44820720,
    0x0902022d, 0x0a040103, 0x020e0102, 0x82030b02, 0x093f0808, 0x01070c01, 0x040b1610, 0x06200a0e, 0x4627201f, 0x01050f12, 0x080e1501, 0x0304110a,
    0x0c020103, 0x070d0f0a, 0x02080411, 0x100a0a01, 0x67341b0f, 0x0d251212, 0x020a1108, 0x510b4d04, 0x820f1d56, 0x1d06238d, 0x00820103, 0x02045b08,
    0x0e070915, 0x2222010a, 0x03050a14, 0x03020502, 0x4c4e280d, 0x0605254a, 0x02010504, 0x03c10206, 0x09010703, 0x0184fe03, 0x080d0f07, 0x0101030f,
    0x099a1b23, 0x12050b0b, 0x05061201, 0x79050d07, 0x120f0b0c, 0x0b0f070a, 0x0b0e0919, 0x061b0505, 0x39252601, 0x05110f1a, 0x00820006, 0x6200053c,
    0x6a0aa600, 0xd200da02, 0x0201e500, 0x0e010801, 0x32250000, 0x012e3435, 0x43503435, 0x32332506, 0x32333637, 0x33230c82, 0x55161732, 0x332505a2,
    0x3f011f32, 0x05585301, 0x013e3224, 0x23821633, 0x82013e21, 0x46212026, 0x23290608, 0x22230622, 0x3b34012f, 0x44108201, 0x27220874, 0xbf4d012e,
    0x012b2205, 0x20218226, 0x05034e29, 0x20052448, 0x82308207, 0x34353172, 0x17152227, 0x012b0614, 0x17150622, 0x34013d26, 0x07252982, 0x26272227,
    0x22088222, 0x8307020e, 0x012e3058, 0x0e05013d, 0x0f060701, 0x15010e01, 0x82140713, 0x013f217f, 0x2209f250, 0x82150637, 0x151623a0, 0x1e820714,
    0x011f1626, 0x26061316, 0x7e824082, 0x16363732, 0x17013a17, 0x25070616, 0x06232722, 0x26012a27, 0x77826982, 0x16323323, 0x27bc8233, 0x33011e32,
    0x25171637, 0x74080d82, 0x2a232706, 0x16362301, 0x10237f02, 0x161a0909, 0x180e0608, 0x08101740, 0x1a170e08, 0x201c230c, 0x07060d1b, 0x22110d11,
    0x1212320a, 0x130d0d09, 0x81141616, 0x2c2c595a, 0x0936232d, 0x0b180914, 0x090c7502, 0x1708050b, 0x0a040d07, 0x0e090104, 0x041c0d0d, 0x13080301,
    0x06261408, 0x0109070d, 0x0d060d08, 0x0b2b2b08, 0xfe92fe42, 0x152a8499, 0x0c04201f, 0x082a8206, 0x070a0538, 0x1104020b, 0xf01b0201, 0x08010433,
    0x080b0b0b, 0x01021817, 0x040b0605, 0x07110a0c, 0x02060202, 0x46fe0b08, 0x0a060c15, 0x27092a2d, 0x070f0104, 0x133d0b09, 0x3782070b, 0x1d114908,
    0x032a532a, 0x15140f1a, 0x021a1d21, 0xef312148, 0x0a0d2c0a, 0x03060815, 0x12340502, 0x08061609, 0x7a060304, 0x3b9c4d4f, 0x2024133b, 0x090f0410,
    0x500c0108, 0x05781201, 0x05040305, 0xf906050f, 0x0102016a, 0x01420103, 0xa6390083, 0x130f040c, 0x36150809, 0x0413182c, 0x16020506, 0x06060f1e,
    0x0f0b0306, 0x211d8205, 0x04820605, 0x01070122, 0x3008d282, 0x0b100e0b, 0x0903140d, 0x04020403, 0x250b0104, 0x0b060209, 0x07031516, 0x070f2507,
    0x02010203, 0x0402180d, 0x02060307, 0x07050103, 0x06010403, 0x084c8215, 0x01100729, 0x04050e01, 0x011e0e03, 0x05100315, 0x0b032802, 0x06050503,
    0xfe0c0201, 0x06132ef5, 0x0c071a06, 0x15101b08, 0x8209071b, 0x030c38bd, 0x11190202, 0x1024353e, 0x0a070e19, 0x030d1601, 0x05080101, 0x82180810,
    0x160a2d06, 0x0201810b, 0x04070101, 0x0601010a, 0x08210882, 0x39bc8486, 0x00030000, 0x0a40005e, 0x0041032b, 0x011401fb, 0x65000042, 0x35013e32,
    0xd6422726, 0x011e2208, 0x07de5533, 0x32333632, 0x15060715, 0x3e323314, 0x35363402, 0x34352634, 0x22052f56, 0x82373233, 0x36372614, 0x37203734,
    0x291f8332, 0x27353217, 0x34353734, 0x0682012e, 0x36273425, 0x82321733, 0x23308312, 0x17273437, 0x2006d448, 0x220b8235, 0x46373435, 0x222c053a,
    0x14151615, 0x22230623, 0x022e2207, 0x2005f350, 0x825f8227, 0x820e2009, 0x0596460e, 0x07010e2b, 0x0607020e, 0x23272023, 0x220b8322, 0x82060703,
    0x05b16307, 0x82272321, 0x82378447, 0x0579465d, 0x1e140723, 0x05b06301, 0x82141521, 0x22b5825c, 0x49363705, 0x07200612, 0x82057557, 0x011e221e,
    0x82f08225, 0x2337259a, 0x36013d22, 0x3321b782, 0x251c8221, 0x04052233, 0x4b822725, 0x22230728, 0x3d363435, 0x3a853401, 0x2305da43, 0x26273435,
    0xd8829e83, 0x32373408, 0x14071516, 0x0414011f, 0x0d1b0c4f, 0x03090d01, 0x05060f05, 0x0a051220, 0x1904100c, 0x1224370b, 0x0b120c0e, 0x1b030108,
    0x07010909, 0x06090307, 0x8208020f, 0x0f9d0823, 0x02030a06, 0x102224b0, 0x011e1515, 0x05050303, 0x100f0d04, 0x1521072d, 0x02060302, 0x1a041306,
    0x02102725, 0x04030104, 0x033c1309, 0x7cfe1418, 0x08070e13, 0x08030708, 0x05081210, 0x1605050a, 0x10011609, 0x11020a1f, 0x0c150a05, 0x0506130d,
    0x05040812, 0x0a2287fe, 0x0e1d1f13, 0x1921150a, 0x15100710, 0x36488d19, 0x04060f29, 0x07070704, 0x5022130d, 0x161414c6, 0x0b010409, 0x0c040205,
    0x15061103, 0xdcb20a88, 0x1e1b14c2, 0x161b2704, 0x0f100a0f, 0x10030812, 0x80fc4415, 0x08248202, 0x030e026e, 0x75020c02, 0x02050604, 0xfecefe05,
    0x15bd04ed, 0x0e2c1e22, 0x0e051203, 0x04060603, 0x0a0d1707, 0x06030706, 0x1f07100a, 0x0c281e0f, 0x01020205, 0x13130340, 0x100a0412, 0x12102518,
    0x020c106d, 0x050d0804, 0x11050a07, 0x0f0d0c0c, 0x0c05090d, 0x0b1f1005, 0x0b03121a, 0x01170201, 0x020b0f02, 0x0d3b3316, 0x0e070505, 0x0a100b01,
    0x5908eb83, 0x0b0f0119, 0x070f130a, 0x01020a03, 0x17142a0b, 0x12050607, 0x170e050b, 0x21071b18, 0x090a0101, 0x06020209, 0x0f070f09, 0x140b0706,
    0x0a050b06, 0x040c1a01, 0x070e0108, 0x0d230602, 0x1b02180a, 0x03030508, 0x01030601, 0x0b070503, 0x15020410, 0x131f0c0a, 0x49060a0e, 0xb282111e,
    0x2605162e, 0x280a2e0f, 0x3d453904, 0x12020705, 0x2d085582, 0x17361b26, 0x0a0a231c, 0x0d1d1417, 0x050303dc, 0x03020302, 0x123c0722, 0x07021631,
    0x30596201, 0x24010201, 0x080a0e08, 0x0c1b0c0b, 0x5c820e15, 0x04023008, 0x0b1b0705, 0x01020b06, 0x1a090803, 0x1e090d09, 0x63000300, 0x72077400,
    0x99000d03, 0xad00a600, 0x22250000, 0x34352627, 0x36373437, 0x67032e37, 0x272205e9, 0x1383072e, 0x12823620, 0x34353624, 0x07823436, 0x3336202e,
    0x32211632, 0x15331617, 0x17321523, 0x17360d82, 0x33071516, 0x14153237, 0x14071417, 0x1415012b, 0x22232623, 0x07821607, 0x07212182, 0x05335a06,
    0x22272228, 0x07222306, 0xfb56020e, 0x34352105, 0x27276a82, 0x0f140722, 0x82230601, 0x25318218, 0x14233735, 0x20821406, 0x15020e29, 0x22231417,
    0x82363201, 0x3480086e, 0x14073527, 0x34231617, 0x06013d26, 0x14640115, 0x0d6a0e09, 0x1d061117, 0x150c1613, 0x2710142d, 0x11110810, 0x0b0e0f0f,
    0x02060811, 0x0c070101, 0x0b070105, 0x06139f01, 0xcb030503, 0x0b020506, 0x03040404, 0x09040707, 0x1748bc01, 0x800c0101, 0x0e3b2816, 0x25120307,
    0x0a100c0a, 0x26190604, 0x42210f22, 0x020c0520, 0x14040202, 0x321b0916, 0x24870204, 0x01251705, 0x1f04130e, 0x05010f53, 0x68084382, 0x01040170,
    0xab0d0208, 0x1a09b601, 0x02060c05, 0x34081261, 0x07741008, 0xd114050e, 0x1a2d1902, 0x05020305, 0x07080401, 0x060a0806, 0x090e0907, 0x0f0b080e,
    0x0b070f09, 0x0c071207, 0x0f0a060c, 0x03011605, 0x2a040703, 0x01030202, 0x02100901, 0x0706071d, 0x0e061406, 0x03030401, 0x01150306, 0x07070d23,
    0x0803130d, 0x08678202, 0x14310525, 0x060b061a, 0x07030a0d, 0x07251b02, 0x04040602, 0x070b0808, 0x070901e2, 0x09060201, 0x0a025601, 0x82030119,
    0x052429e9, 0x060a0602, 0x000b1005, 0x02300082, 0x0d005600, 0x7403fd08, 0xa6019701, 0x23250000, 0x3e05874d, 0x35263426, 0x013e3411, 0x34353734,
    0x26072223, 0x26373435, 0x23262734, 0x0e141522, 0x82012b01, 0x27232606, 0x22230722, 0x201e8227, 0x27068206, 0x14011d22, 0x1632013b, 0x17210682,
    0x82088216, 0x15062407, 0x82222314, 0x20258331, 0x20328226, 0x824c843d, 0x37362230, 0x213f8206, 0x4a831617, 0x82010f21, 0x0e0724d0, 0x4f141502,
    0x142105a0, 0x824d8222, 0x023e216d, 0x27237983, 0x832e2726, 0x012e2a6d, 0x22072334, 0x3522010f, 0x23088337, 0x06222327, 0x23076d58, 0x07010e07,
    0x2e2a3282, 0x032e3402, 0x33363735, 0x975b1732, 0x33362905, 0x33363427, 0x32363436, 0x2405b445, 0x3233023e, 0x05b6551e, 0x37333629, 0x32371732,
    0x87321715, 0x2033852f, 0x06f34537, 0x83013f21, 0x8216201e, 0x37362125, 0x35250186, 0x2e012f34, 0x21c48202, 0x7d4e2726, 0x16322105, 0x1e226884,
    0x34841702, 0x15071523, 0x82858214, 0x173229f5, 0x27373233, 0x3d363734, 0x23069e4c, 0x013b1415, 0x15267982, 0x36323314, 0xf15b0129, 0x14172705,
    0x2205012b, 0xdb562207, 0x17152906, 0x27222314, 0x16071417, 0x15214582, 0x820d8314, 0x82172012, 0x0122210d, 0x24059d5e, 0x23013f36, 0x083b8217,
    0x03610625, 0x1301070c, 0x07010703, 0x04040402, 0x0202040d, 0x03050401, 0x14150304, 0x0802170c, 0x4e0c0b06, 0x82313152, 0x08062315, 0x06820302,
    0x12010c29, 0x04115c5c, 0x8203070e, 0x02560823, 0x13080a04, 0x0b020920, 0x0a0e060f, 0x01060902, 0x07020703, 0x130c0901, 0x08103f12, 0x1a26020d,
    0x01070102, 0x050a0201, 0x24111a17, 0x0f022811, 0x020a0c22, 0x5f0a0603, 0x03070a5a, 0x0e070602, 0x1411040d, 0x010c090e, 0x12010104, 0x0e040605,
    0x83591402, 0x34826b60, 0x0e0c0333, 0x0e0a0708, 0x0d09070c, 0x080e0906, 0x0e170518, 0x24a08212, 0x1722400d, 0x089e8205, 0x060a0ba6, 0x2b180505,
    0x080d0507, 0x081d2211, 0x03070403, 0x020a0104, 0x12110808, 0x06071104, 0x0c040b10, 0x083b0705, 0x05100424, 0x10090c0d, 0x04050b06, 0x040e0c0a,
    0x18490f0d, 0x06020625, 0x01050302, 0xa0260c17, 0x010e040d, 0x030b0501, 0x1111110c, 0x08020202, 0x22021d02, 0x0c012301, 0x0c08110b, 0xfe452401,
    0x053aade0, 0x0102050f, 0x0105040a, 0x01030e02, 0x05011101, 0x67fa0d01, 0x080d1c11, 0x172b0816, 0x0203d508, 0x070d070c, 0x100e0303, 0x0a0d0a11,
    0x09041701, 0x03171409, 0x1806020d, 0x09070217, 0x07211882, 0x08d68203, 0x0b030128, 0x0101020f, 0x0f0a0b02, 0x09080208, 0x8b8b0f03, 0x010f0812,
    0x0e030701, 0x16425019, 0x0d093537, 0x0e010e0e, 0x98820912, 0x27820a20, 0x21070e3e, 0x0816070e, 0x03060404, 0x05020606, 0x1d060604, 0x231b2010,
    0x11030518, 0x04150e13, 0x072f5382, 0x17010301, 0x03010508, 0x08020106, 0x5d0a4448, 0xa4080573, 0x1927192a, 0x19111924, 0x0105021b, 0x0a010107,
    0x05070306, 0x060c0304, 0x1009040d, 0x03120d02, 0x24010b01, 0x08041301, 0x0a090408, 0x05060101, 0x02010901, 0x01040701, 0x01030703, 0x03020206,
    0x09021502, 0x07040c12, 0x0e090410, 0x1a070710, 0x030b0b06, 0x420a0505, 0x040b040e, 0x06070103, 0x07030204, 0x0c010718, 0x0e080f0b, 0x021c0b0c,
    0x070c1a03, 0x0c040108, 0x0b210102, 0x040a0e03, 0x0d210b14, 0x0b0d2b02, 0x3b052a02, 0x1b1b4752, 0x05012a11, 0x01020201, 0x0a0d0df0, 0x1f060b07,
    0x1a150412, 0x05d35103, 0xc0006130, 0xc102e809, 0xa4008900, 0x32370000, 0x01823637, 0x36371522, 0x8209f74b, 0x023e260f, 0x32331633, 0x05f14f3f,
    0x35173228, 0x35323334, 0x0f833427, 0x32331423, 0x20198436, 0x05054f17, 0x08463320, 0x31168306, 0x07273517, 0x17373522, 0x22212535, 0x0722012f,
    0x204c2326, 0x06f04505, 0x43030e21, 0x272206e0, 0xaf53012e, 0x0f142306, 0x47821401, 0x2622252b, 0x14373435, 0x35223316, 0x218e8234, 0xf7511733,
    0x07bb0805, 0xe7060706, 0x15070c12, 0x0f026947, 0x220c130b, 0x413d200e, 0x25493d3b, 0x151d0618, 0x4c450c0c, 0x011a0e16, 0x050b2004, 0x1628020e,
    0x3504280c, 0x2239320f, 0x0a091844, 0x02300104, 0x015e0c35, 0x08267105, 0x22191930, 0x06061924, 0xfe6cfc3d, 0x0e114b67, 0x2f070306, 0x3f144d09,
    0x2a2d2943, 0x0f1f2a14, 0x190d1a1f, 0x150c1918, 0x1c212a44, 0x012a0f12, 0x02111509, 0x16240103, 0x22e40125, 0x16011231, 0x09031301, 0x2215210b,
    0x0a080308, 0x20c02513, 0x2f691f10, 0x12050108, 0x29241034, 0x020a142c, 0x010b1701, 0x06050102, 0x07050103, 0x05030303, 0x03180402, 0x820d0105,
    0x033f080f, 0x040b0304, 0x60013401, 0x0d030101, 0x03015e01, 0x07190202, 0x09060104, 0x0d06100b, 0x160c0810, 0x19110905, 0x14070b0e, 0x32030107,
    0x27221931, 0x17281f0c, 0x1b208228, 0x31130d11, 0x833d0702, 0x08143542, 0x0e0a0b07, 0x02001109, 0x27006500, 0x5a03f605, 0x34010501, 0x2608db45,
    0x2223010e, 0x823d2634, 0x15270805, 0x27222617, 0x06230622, 0x07060714, 0x0607020e, 0x0706010f, 0x32141506, 0x14151617, 0x23262223, 0x2726012f,
    0x83222326, 0x47352003, 0x3e2805cd, 0x023e3701, 0x37343637, 0x26061845, 0x3634023f, 0x52013e37, 0x352e063b, 0x22072334, 0x34042e27, 0x36343526,
    0x2c823435, 0x033e3424, 0x0a82013f, 0x1732332c, 0x1e333435, 0x011e1401, 0x3d840533, 0x27053b42, 0x011d1617, 0x27353221, 0x27232e82, 0x6133033e,
    0x1425054d, 0x14011f16, 0x25858333, 0x15161407, 0x8d833235, 0x32373227, 0x3316011f, 0x829e8217, 0x07222790, 0x0e140614, 0xa5820703, 0x2320a084,
    0x1d25c482, 0x012b1401, 0x82c08222, 0x82328208, 0x820120d1, 0x303b82cc, 0x35031417, 0x3f323734, 0x34373401, 0x2e35012e, 0x352d8202, 0x011e1716,
    0x23061415, 0x2e272627, 0x35273401, 0x0e07010e, 0x5c821401, 0x32163608, 0xbbaa0316, 0x05050208, 0x87032a09, 0x29140108, 0x02070514, 0x04070208,
    0x02010503, 0x0503070b, 0x05040502, 0x0f050e02, 0x3f381202, 0x0513100a, 0x0b120c05, 0x08188209, 0x0206024a, 0x01020101, 0x090b0204, 0x070b0819,
    0x040a0302, 0x05070110, 0x0403040a, 0x22170908, 0x09060405, 0x02020704, 0x03040908, 0x0c040509, 0x0502200c, 0x11051402, 0x01100303, 0x0e1101d8,
    0x09090706, 0x030d0705, 0x50b40101, 0x48824682, 0x12030d2e, 0x01080f09, 0x03080404, 0x07020102, 0x09240182, 0x03060c0b, 0x013f2182, 0x0d0c1106,
    0x04070304, 0x05060402, 0x4c260a04, 0x03632f55, 0x20170310, 0x07130f0c, 0x8201050c, 0x044b0858, 0xfc010101, 0x04040105, 0x04040201, 0x0b0a0e05,
    0x110a0237, 0x06050c16, 0x0e02111c, 0x07030d0b, 0x32090703, 0x1127393e, 0x03ed1505, 0x0b1a100d, 0x01140719, 0x0c082001, 0x08100703, 0x1005060c,
    0x0907071d, 0x0f01060c, 0x82121806, 0x02032146, 0x09290082, 0x1b0b0503, 0x0e07101b, 0x28538208, 0x020d0401, 0x0b35110b, 0x3288820e, 0x0d09070f,
    0x0505130e, 0x05090f05, 0x070d0804, 0x82050a01, 0x0a0925fd, 0x15282615, 0x073ed282, 0x06020402, 0x07080502, 0x01020b0e, 0x01011103, 0x01040f08,
    0x0909031b, 0x03040604, 0xe6820708, 0x0221ac82, 0x08e58203, 0x010f042a, 0x0803050d, 0x03030103, 0x03010507, 0x1501040c, 0x01010602, 0x02030202,
    0x07150817, 0x0b040302, 0x09010c04, 0x02070804, 0x6c083282, 0x093c0a01, 0x0806131e, 0x1309014a, 0x0a051309, 0x0b1a090f, 0x0a08616c, 0x04038701,
    0x04060707, 0x06080203, 0x06140804, 0x140a0c01, 0x07070609, 0x03110801, 0x05100a0b, 0x03071b02, 0x050c0911, 0x00010202, 0x005b0002, 0x03cb0426,
    0x000d005a, 0x01000085, 0x3f363732, 0x012b3401, 0x14011d22, 0x26270333, 0x22230723, 0x26272627, 0x08687135, 0x21080b83, 0x34273536, 0x1e37013e,
    0x17161701, 0x36011f16, 0x32371733, 0x35342617, 0x3736013c, 0x3f013e17, 0x17823201, 0x36321724, 0x22833233, 0x26823b20, 0x17161522, 0x1f240d82,
    0x07010e01, 0x23250284, 0x17152227, 0x05ee5014, 0x07222325, 0x82063526, 0x82062073, 0x15d0081b, 0x02141714, 0x07101535, 0x54120208, 0x05761010,
    0x0814080b, 0x5e195e06, 0x0f0d0725, 0x161a1117, 0x0b01022c, 0x2f0c0e22, 0x215a2608, 0x201f0622, 0x2021424e, 0x140a0a01, 0x12040d04, 0x0a26190c,
    0x070e0808, 0x132b2f16, 0x0f0a0807, 0x0a1d2c07, 0x08100907, 0x05060f03, 0x240e1335, 0x013c5a10, 0x19180210, 0x1d572305, 0x140f0a1d, 0x060c1175,
    0x01042712, 0x1e070eed, 0x3010120c, 0x0139fe11, 0x04140202, 0x11320a1a, 0x613f2f1a, 0x18115539, 0x04241d0f, 0x1433111e, 0x020b1b22, 0x01100a02,
    0x080e0501, 0x03080101, 0x06010204, 0x05040206, 0x0601011a, 0x0601040e, 0x020e090d, 0x0d080301, 0x0406020e, 0x162c572c, 0x0d04050f, 0x1c2e0d01,
    0x082b1a82, 0x0d281d0d, 0x1d3ba324, 0x82000d20, 0x032b0800, 0x26005900, 0x59038d04, 0xb500b000, 0x0000f500, 0x33363225, 0x32331732, 0x26273435,
    0x033e3435, 0x3d053e37, 0x37363401, 0x83013b36, 0x050a4a16, 0x27373524, 0xdc493734, 0x011f2305, 0xd6493732, 0x35373005, 0x22072334, 0x26343735,
    0x14250723, 0x4c141517, 0x07220511, 0x40822223, 0x0c822320, 0x252a0683, 0x14232615, 0x0607010e, 0x0682011d, 0x1506142a, 0x15163214, 0x17161714,
    0x13830582, 0x0e140623, 0x291a8402, 0x0e070607, 0x15060703, 0x0e82010e, 0x8205dd52, 0x85288308, 0x22272503, 0x01323727, 0x2e275b84, 0x36343501,
    0x83013e34, 0x07152191, 0x2105d062, 0x14823a33, 0x27218e83, 0x82768226, 0x16172119, 0x1e21c083, 0x236c8201, 0x27231415, 0xcf089c83, 0x8c012227,
    0x060a140a, 0x0b060309, 0x0304081e, 0x0b040208, 0x07040a08, 0x0b040104, 0x0f1849e3, 0x03060206, 0x10060202, 0x79150410, 0x150c2140, 0x03020202,
    0x0103030a, 0xfe1d0821, 0x080402d9, 0x39330e02, 0x06080108, 0x04040803, 0x19086afe, 0x16070a14, 0x07030c03, 0x1d171307, 0x0b080421, 0x060b0905,
    0x03140b03, 0x02020504, 0x1105010c, 0x0a0f0705, 0x06071515, 0x460d120c, 0x5a07172d, 0x04030405, 0x0c032101, 0x120c0b02, 0x05070b07, 0x0711050d,
    0x140a1b0b, 0x09060e05, 0x042b0c05, 0x11111f06, 0x0d191410, 0x08010f04, 0x4532080e, 0x03262020, 0x04040902, 0x120e3509, 0x080f1218, 0x191c1b0f,
    0x050a1817, 0x0b091307, 0x030a0c01, 0x0b34b882, 0x0810242b, 0x01020318, 0x0614130a, 0x0f216120, 0x03010d03, 0x4b081d82, 0x0c060101, 0x01080806,
    0x050a0b01, 0x06040401, 0x0c011601, 0x220a1511, 0x04050b18, 0x080d1909, 0x06020416, 0x1b170504, 0x0707020d, 0x0a0b0507, 0x030f0817, 0x09180301,
    0x05252008, 0x07100d0f, 0x04052720, 0x02133f04, 0x08040c04, 0x2e081882, 0x08030407, 0x16030a05, 0x76010102, 0x17050508, 0x11090e14, 0x050c0c15,
    0x0d2c1103, 0x0d100b10, 0x01070e04, 0x1c180502, 0x0b070621, 0x820e0201, 0x11352833, 0x0e021710, 0x82000102, 0x00043700, 0x05260062, 0x005a039c,
    0x00e600e1, 0x000901f1, 0x37322500, 0x04773233, 0x34262505, 0x27012e27, 0x42062465, 0x05820559, 0x37323322, 0x362c0582, 0x34013f34, 0x32333627,
    0x14011d16, 0x2005b35e, 0x42378416, 0x372005a2, 0x17291982, 0x3233021e, 0x3e273536, 0x06c64201, 0xaf4c2620, 0x012f2106, 0x37224c84, 0xf1512334,
    0x22072105, 0x2005b462, 0x07e84821, 0x83059858, 0x54172055, 0x638205c6, 0x36295d82, 0x34033e37, 0x14153736, 0x2451821e, 0x013f3236, 0x82148332,
    0x8307838f, 0x28268365, 0x15061415, 0x15020e14, 0x26258217, 0x17161415, 0x4214011e, 0xab8206d6, 0x82350121, 0x2205210b, 0x3d23d282, 0x82031e01,
    0x23e0825c, 0x17333635, 0x1522f383, 0x37821707, 0x0e073708, 0x109c0201, 0x03112616, 0x07030b02, 0x05040204, 0x07040704, 0x55090209, 0x0214183a,
    0x54030301, 0x01030d58, 0x0c322604, 0x070a0314, 0x0303090b, 0x11020606, 0x25820309, 0x14022408, 0x030e2922, 0x160a0413, 0x1a10270d, 0x06010c06,
    0x0a020c01, 0x140f0b14, 0x061b0610, 0xfafc0d15, 0x82031120, 0x05250842, 0x08051207, 0x0201060b, 0x033e0507, 0x07160509, 0x191f0406, 0x08050916,
    0x06080f08, 0x02070a09, 0x0b12590b, 0x08158210, 0x20060b28, 0x02080620, 0x01020602, 0x0e0a0505, 0x16020102, 0x01040904, 0x0b050705, 0x090f0910,
    0x03dffd13, 0x020f7902, 0xa5820104, 0x42060609, 0x0306020c, 0x27140116, 0x0a021007, 0x05060101, 0x12050303, 0x02070526, 0x0b0c0407, 0x0d050a03,
    0x2713070f, 0x0f122118, 0x0d101a0d, 0x1d101e2b, 0x03090a20, 0x0d0c0920, 0x05050508, 0x3b100101, 0x11102d4a, 0x130c3610, 0x0c17051e, 0x04090bed,
    0x0c020807, 0x0a051404, 0x05041009, 0x1c061901, 0x01030114, 0x04030609, 0x0d080d04, 0x07060506, 0x18010a14, 0x03210209, 0x090d0904, 0x0b070203,
    0x07070607, 0x880b090f, 0x14161d8f, 0x1c12160b, 0x02042b10, 0x01051204, 0x04110102, 0x08030202, 0x0302030a, 0x05230607, 0x1d1c1c0c, 0x061a3b10,
    0x38200d05, 0x0f10071e, 0x120d070d, 0x06010228, 0x0a337202, 0x0273100f, 0x0407060a, 0x09070704, 0x03060802, 0x02070321, 0x04050702, 0x0c090604,
    0x00010804, 0x004f0004, 0x03d50740, 0x00d20040, 0x00ed00de, 0x250000ee, 0x37232622, 0x34372734, 0x2a072326, 0x05624401, 0x013e3722, 0x2905176d,
    0x012e2734, 0x2f220723, 0x79822201, 0x1c832220, 0x272a0d82, 0x22012b26, 0x2635012e, 0x08820623, 0x3a05634f, 0x010e010f, 0x07220607, 0x17333411,
    0x37203316, 0x34353632, 0x3734012f, 0x82323336, 0x3532300f, 0x36373634, 0x32332735, 0x32213316, 0x4232013f, 0x1b8205da, 0x15011e2d, 0x2b141707,
    0x1d161701, 0x47061401, 0x23230514, 0x82061422, 0x064a4555, 0x06207882, 0x88820382, 0x68012f21, 0x35200572, 0x34200683, 0x4905d354, 0x2325058f,
    0x0e27012a, 0x29418201, 0x17152223, 0x27261314, 0x33822726, 0x41831520, 0x36373226, 0x2326013f, 0x0720bf82, 0x48080e82, 0x05d00401, 0x01017d25,
    0x19080301, 0x02080f06, 0x02060d02, 0x0703050a, 0x0e03070f, 0x1713d806, 0x040f150e, 0x06100603, 0x0104060c, 0x03020103, 0x05040303, 0x020eeef9,
    0x010b0207, 0x14040206, 0x0e06030f, 0x2a9e017f, 0x081d823c, 0x29070499, 0x12261510, 0x04040613, 0x13130701, 0x96560215, 0x06170c22, 0x110f0909,
    0x140f1e05, 0x01033416, 0x2b660d01, 0x05250302, 0x03091808, 0x07022012, 0x13081507, 0x150f252f, 0x04050912, 0x0705080f, 0x05020609, 0x05010405,
    0x1618142e, 0x17201009, 0x19240638, 0x03080d20, 0x03088a02, 0x0e05041b, 0x401e020b, 0x0f1b0d0b, 0x14242515, 0x0f010612, 0x407afe0a, 0x01070602,
    0x01040304, 0x21290f1b, 0x08113722, 0x08080e13, 0x0b152411, 0x011a0510, 0x02080102, 0x8250080f, 0x012608a9, 0x01010603, 0x10010b01, 0x162e150a,
    0x060e077e, 0x60010210, 0x0109020f, 0x161e1804, 0x0f070d0d, 0x0a040402, 0x48820803, 0x01032226, 0x2129110b, 0x5f088982, 0x09540b07, 0x05036108,
    0x0e081108, 0x1e050f2d, 0x21121122, 0x2b351121, 0x06281051, 0x03050106, 0x0d0a0601, 0x0e081012, 0x10120505, 0x11071928, 0x2d280810, 0x050a2b3d,
    0x180b0f10, 0x2346843b, 0x0c0a030d, 0x02086501, 0x0f04251b, 0x0103060b, 0x0b06031e, 0x06251a13, 0x1c1c1402, 0x00d0fe0f, 0x02340082, 0xa7006200,
    0xda02d70a, 0x0d01fa00, 0x32770000, 0x3637023e, 0x24084a59, 0x33163233, 0x270d8432, 0x16173233, 0x32331417, 0x2105104c, 0x194c2735, 0x21228208,
    0x17841617, 0x37013e25, 0x84353632, 0x3233290b, 0x17163237, 0x013b011e, 0x33233082, 0x82373217, 0x8236201b, 0x3735290c, 0x35262734, 0x33013e34,
    0x27058d73, 0x34353227, 0x17271727, 0x36201382, 0x26360982, 0x35220723, 0x0e012b34, 0x012e1501, 0x21171423, 0x06222725, 0x16832223, 0x04822720,
    0x2b300a83, 0x22273501, 0x27261715, 0x22010f22, 0x2334013d, 0x12840484, 0x07142326, 0x010e0706, 0x8205f842, 0x82388408, 0x82032011, 0x2223232a,
    0x3e850706, 0x0b834d82, 0x1e141527, 0x031e1702, 0x21058217, 0xf7492201, 0x17272705, 0x17333435, 0x46821732, 0x09b02209, 0x0c04130d, 0x13133921,
    0x240b0913, 0x03060e22, 0x0d080407, 0x2b2f260f, 0x130b0a0c, 0x1c080e02, 0x10110908, 0x050b011a, 0x161c0802, 0x110d1827, 0x32160b0e, 0x0e0c252d,
    0x01060a06, 0x37100e11, 0x242f2e19, 0x080e0717, 0x18213c15, 0x5da16d16, 0x0c3d4b94, 0x0d090b1b, 0x04010a08, 0x080e0602, 0x0e1a0e0e, 0x0d03a938,
    0x03030104, 0x070d0502, 0x15071a09, 0x0a0b2008, 0xfe020a14, 0x1e47fe02, 0x09050903, 0x050d0b08, 0x0a0e0a02, 0x1632261a, 0x04070613, 0x18181702,
    0x07134217, 0x0e1b0610, 0x0d070301, 0x10082832, 0x2a15121b, 0x091a0c14, 0x06150d12, 0x5b571d09, 0x2d2a2814, 0x0c181229, 0x06030811, 0x0a121506,
    0x070b0503, 0x020a1f15, 0x01010203, 0x04030103, 0x11010202, 0x0db70314, 0x0303060f, 0x31110101, 0x0602020a, 0x0f0302a7, 0x08200603, 0x04050b06,
    0x0309160f, 0x170f0708, 0x10120a14, 0x01040f06, 0x120d0802, 0x040a160e, 0x090c1306, 0x0f1c0306, 0x090b221c, 0x0a030c03, 0x291a8201, 0x15080f02,
    0x01161009, 0x6582030a, 0x0c180f39, 0x04030408, 0x01010509, 0x06080103, 0x07020b16, 0x06040507, 0x82060209, 0x1509247a, 0x830f0a03, 0x0101267d,
    0x02020902, 0x20228208, 0x20008201, 0x820e8204, 0x02062933, 0x04080104, 0x1d080e01, 0x0a2e5882, 0x09100908, 0x07030505, 0x020a050f, 0x1a820701,
    0x04012108, 0x04020205, 0x0505140a, 0x13130c04, 0x2d2e170a, 0x2d11162b, 0x21010320, 0x04070f06, 0x05050105, 0x13235082, 0x5c0e040a, 0x633105cf,
    0xdc074000, 0x1b004103, 0x3e003000, 0x08015400, 0x069d6200, 0x27012e38, 0x2223012e, 0x16141506, 0x32373233, 0x1714011d, 0x05161716, 0x956c3732,
    0x05c86906, 0x14171527, 0x3201011e, 0x2f158436, 0x27262223, 0x32053314, 0x35373435, 0x22232734, 0x1e363382, 0x07141501, 0x16171506, 0x26272201,
    0x013d2627, 0x2f262734, 0xc95c2e01, 0x23062305, 0x766a2221, 0x33362705, 0x011f3221, 0x07833732, 0x82082d43, 0x33362246, 0x25618232, 0x0714010e,
    0x22821415, 0x67843720, 0x22072329, 0x3e023c35, 0x4a333701, 0x332007b0, 0x8205f964, 0x1415246a, 0x6416013b, 0xa38208e9, 0x16170725, 0x82060715,
    0x24868282, 0x23072223, 0x83d78222, 0x83d88216, 0x22072c16, 0x23010f06, 0x3435012e, 0x82013f36, 0x23342102, 0x2e822282, 0x0e07e508, 0xba050701,
    0x11270a08, 0x06070b1d, 0x01460a06, 0x07071f01, 0x080d1302, 0x290efcfd, 0x6c110d6f, 0x09020719, 0x03100c16, 0xce02220c, 0x02040109, 0x4f5d6a13,
    0x76010127, 0x0e0a0306, 0x08090a04, 0xfd010404, 0x0c3e3333, 0x1e070a24, 0x0904610a, 0x070a1007, 0xfe111101, 0x0d051f4d, 0x7f57012b, 0x0f101019,
    0x68013e34, 0x10020104, 0x0c10090e, 0x14050517, 0x01050201, 0x05450103, 0x07110f09, 0x0a030301, 0x08040c0f, 0x09010102, 0x07100b04, 0x1b0d0c17,
    0x109b0401, 0x030b0a13, 0x020d6d14, 0x0f040702, 0x0304020d, 0x09070c04, 0x13041711, 0x02050108, 0x06111a19, 0x3707050e, 0x1a0d4930, 0x0a07160e,
    0x0c02060f, 0x1e010301, 0x0a0b0c20, 0x3d080506, 0x03e53d74, 0x1f0d240f, 0x060a0e12, 0x2014250c, 0x3e087a82, 0x0a060105, 0x29101206, 0x012a0e31,
    0x0d0d0a1a, 0x1820131a, 0x08047c01, 0x04040303, 0x53220206, 0x071a3503, 0x090b0613, 0x04060102, 0x07060b06, 0x44fe052e, 0x01030205, 0x02021e06,
    0x8225030c, 0x01620874, 0xd6432a1e, 0x060e0466, 0x09030101, 0x04091710, 0x07182626, 0x10210e05, 0x05083203, 0x0a080406, 0x0c070704, 0x080d0307,
    0x09020601, 0x0201100b, 0x071e0a12, 0x0703071a, 0x1c0d0f17, 0x03096514, 0x1d280e06, 0x07010204, 0x10101108, 0x261c1a0b, 0x01021b12, 0x12252602,
    0x0517020a, 0x262b4f30, 0x59820205, 0x07090332, 0x06330714, 0x01160708, 0x06060a05, 0x0002432f, 0x30080082, 0x004e0008, 0x03d40a5a, 0x00010026,
    0x02090203, 0x0235021b, 0x024c0247, 0x4100004f, 0x01371727, 0x37352223, 0x06222334, 0x1d062307, 0x15161401, 0x210a8214, 0x07820706, 0x2e222323,
    0x05586702, 0x2008326d, 0x202d822e, 0x05864e06, 0x23060734, 0x22232622, 0x2722010f, 0x3435012e, 0x2234013f, 0x675f2327, 0x14172506, 0x15322723,
    0x2f087d5f, 0x34262726, 0x3234012f, 0x14153237, 0x32331707, 0x25063d4d, 0x34353217, 0x114b3233, 0x22232405, 0x45222307, 0x252106c8, 0x21238232,
    0x2c823337, 0x08514018, 0x08541520, 0x37362905, 0x1733013e, 0x34013d32, 0xbf4d0582, 0x4f342005, 0xb982052a, 0x63373321, 0x362105e6, 0x21ce8433,
    0x9b84012b, 0x37352623, 0x22658527, 0x8332011f, 0x05066408, 0x35206283, 0x17281882, 0x3b343526, 0x36342701, 0x07286e82, 0x33161714, 0x34013f32,
    0x4c851384, 0x023e3722, 0x334b5782, 0x012b2108, 0x2720f288, 0x2306dc43, 0x2133011c, 0x33829182, 0x50833620, 0x32163224, 0xd7831716, 0x82161721,
    0x05f87d35, 0x16071423, 0x05234415, 0x65832184, 0x011e3724, 0x994b3517, 0x32332a06, 0x2314011f, 0x27222622, 0x05dc4b23, 0xc0840720, 0x41055b41,
    0x27260565, 0x07141715, 0x0c823334, 0x23823420, 0x33224b82, 0x2d822622, 0x33070622, 0x15230f82, 0x82012e33, 0x231582ed, 0x013d2617, 0x23242084,
    0x07233422, 0x15290982, 0x27012e17, 0x3522010f, 0x820c8223, 0x8335203d, 0x82072006, 0x15162229, 0x210e8214, 0x07821415, 0x14010f2d, 0x26373225,
    0x26343735, 0x82222723, 0x22b8830d, 0x84363205, 0x1415222b, 0x06d75917, 0x36832320, 0x1322ba82, 0x28823537, 0x1506222d, 0x26272627, 0x17152223,
    0x83350507, 0x37cf0836, 0x02a40623, 0x7cfe030f, 0x0a020cb7, 0x76050907, 0x0a170323, 0x0604080e, 0x213d080f, 0x04060a12, 0x0d071849, 0x171f021c,
    0x1b162215, 0x0b06132a, 0x06090f06, 0x22031806, 0x17254e57, 0x07030523, 0x11140102, 0x0a021504, 0x0d011508, 0x05070207, 0x02010a0e, 0x01040202,
    0x030c120f, 0x05080914, 0x132f0202, 0x0c230c14, 0x170e0b18, 0x05100413, 0x0c100204, 0x13141201, 0x0419120c, 0x25161917, 0x0c1c1229, 0x07241f09,
    0x0d07153d, 0x15360e04, 0x150f1e31, 0x0c190e14, 0x0410271c, 0x210e0a09, 0x091c0113, 0x0f041229, 0x160d1104, 0x1f202422, 0x0201071c, 0x07300914,
    0x04031a79, 0x161e0415, 0x080c1604, 0x09040112, 0x01020802, 0x82160e09, 0x0949082d, 0x03010c0a, 0x020e3609, 0x192a2413, 0x970f3134, 0x0803040f,
    0x280f0505, 0x2531182b, 0x250e1c0f, 0x04023916, 0x37010f02, 0x01030156, 0x141c0518, 0x03080610, 0xf118170a, 0x0c030a09, 0x84090109, 0x03090272,
    0x0502040c, 0x08078201, 0x03241631, 0x2128362b, 0x01031709, 0x2522051b, 0x013c114d, 0x0813090a, 0x051f010c, 0x29240e33, 0x05191d16, 0x13580d2b,
    0x060136a2, 0x07050b01, 0x82040304, 0x04300841, 0x020a0f0a, 0x0a090108, 0x0a020801, 0x040f010e, 0x06010b0a, 0x04020202, 0x04090d12, 0x100c040a,
    0x0549040d, 0x07061906, 0x19120302, 0x0a030b11, 0x6f086a82, 0x0ca5fb01, 0x05010108, 0x060e1811, 0x93030301, 0x11211515, 0x16030425, 0x06080b04,
    0xef1f0d11, 0x0a0a0702, 0x21012a2c, 0x02140a10, 0x1b050301, 0x03f0040b, 0x01a90102, 0xb0fe0101, 0x08355835, 0x01240301, 0x07020701, 0x0b0c1818,
    0x0e0a070a, 0x0f09040a, 0x74060509, 0x0a090625, 0x0b010213, 0x0c040c02, 0x150f1006, 0x01040319, 0x0205060d, 0x01343882, 0x19241002, 0x010e0601,
    0x050e0202, 0x17850b29, 0x0c0a112e, 0x0122c282, 0x23830205, 0x0f030833, 0x0c052508, 0x08180c14, 0x0c100102, 0x0c390a1a, 0x08328202, 0x1e190f6d,
    0x15020532, 0x04100412, 0x14014f0f, 0x08010b03, 0x0c090104, 0x02040206, 0x09010303, 0x3b04080b, 0x01021015, 0x2a110104, 0x0d050a18, 0x05031901,
    0x05020602, 0x02060701, 0x0a050601, 0x03060809, 0x040e1e05, 0x04030205, 0x06060301, 0x0b060c06, 0x0403010a, 0x060d1304, 0x0110361c, 0x050f0102,
    0x010a0407, 0x050f0b11, 0x8201031a, 0x0c430819, 0x020b0703, 0x0d020606, 0x05130a05, 0x02020707, 0x0b080304, 0x071a110b, 0x09030404, 0x04020c03,
    0x010c0b04, 0x14160a03, 0x070d0303, 0x0f040107, 0x06010304, 0x0801050c, 0x02040a13, 0x07030d02, 0x82060101, 0x0101229c, 0x82748202, 0x82032005,
    0x0a032f76, 0x01010107, 0x03020302, 0x0c040101, 0x95820308, 0x1c145c08, 0x0b040b11, 0x270e0108, 0x18152442, 0x0a0906de, 0x01040f2a, 0x140a2905,
    0x2f030305, 0x1b271a11, 0x160f0d13, 0x10071307, 0x161b0e01, 0x61010609, 0x080b0817, 0x07010410, 0x16110408, 0x01061f0a, 0x0001b607, 0x54000300,
    0x0f0a0d00, 0x80017303, 0xa1019601, 0x22250000, 0x50262726, 0x2e29056d, 0x22072301, 0x0614010e, 0x4d018407, 0x804d0553, 0x27342305, 0xba432226,
    0x07143507, 0x06222722, 0x012b1415, 0x030e1522, 0x35262223, 0x0607030e, 0x37210783, 0x22398522, 0x4b222307, 0x5a830541, 0x37342408, 0x32333427,
    0x011d011e, 0x36013b14, 0x32173233, 0x3e37013e, 0x16013b01, 0x27353233, 0x22232637, 0x84141715, 0x21098230, 0x0a831516, 0x34373425, 0x44373427,
    0x152105f9, 0x246a8214, 0x33343233, 0x252f8232, 0x32373634, 0xb6450717, 0x32172105, 0x162e5883, 0x37363233, 0x17163334, 0x32331415, 0x7f831415,
    0x37200982, 0x33230a82, 0x82323336, 0x14072307, 0x34822021, 0x42831620, 0x35321722, 0x17825882, 0x84331621, 0x208c8219, 0x834d8214, 0x0535450b,
    0x7f821720, 0x07012b22, 0x8d6d1082, 0x82418205, 0x3233255b, 0x17071516, 0x07231183, 0x82343522, 0x2ca882e8, 0x14152214, 0x0714011f, 0x3435022e,
    0x22558236, 0x5a342207, 0x8383052a, 0x20231425, 0x58062227, 0x076305a8, 0x288c8305, 0x06221415, 0x1e171615, 0x05e95301, 0x06010f28, 0x27323603,
    0xe9833526, 0x86273421, 0x1417263d, 0x2e342733, 0x080e8302, 0x041415c1, 0x05070e70, 0x0b040b0e, 0x0406040b, 0x066e4d01, 0x020c0c08, 0x06141105,
    0x2e0b0902, 0x483c1817, 0x03491b0d, 0x0f030505, 0x10281602, 0x1c170806, 0x0e030106, 0x0109050b, 0x13141a0a, 0x07100508, 0x100f010a, 0x061a1f1c,
    0x12160b01, 0x03030501, 0x05040e05, 0x0b031101, 0x07090c0e, 0x1a2a96fe, 0x0a111922, 0x2e0c0703, 0x01013254, 0x01040502, 0x0e010c0a, 0x09100222,
    0x08040201, 0x050c1801, 0x0a04061a, 0x09040407, 0x01011012, 0x2b13040f, 0x01050a21, 0x0e180b02, 0x09010223, 0x040a0108, 0x100d070c, 0x0b091a04,
    0x1718411a, 0x52010217, 0x211c4601, 0x0202050d, 0x02020304, 0x820e0e05, 0x01052346, 0x4c820803, 0x010c0639, 0x14070b01, 0x02020b07, 0x11031702,
    0x0d210d09, 0x080205ec, 0x82294008, 0x11240820, 0x091e1d55, 0x03089f27, 0x01031308, 0x02180d06, 0x05050203, 0x01050205, 0x060c1405, 0x2632fe10,
    0x0f050515, 0x8708a082, 0x212a6033, 0x03010310, 0x06011305, 0x18040703, 0x11080511, 0x09d3187c, 0x1702012b, 0x1211070e, 0x170c1c05, 0x0b210a03,
    0x04020904, 0x390d0602, 0x113b1e0a, 0x16173f20, 0x0e010b10, 0x05110c14, 0x2c21170b, 0x090a1709, 0x57131415, 0x2b171e0d, 0x0b280504, 0x210d0506,
    0x0202010b, 0x080e071a, 0x07010105, 0x130b0a08, 0x04060b0c, 0x1d10200c, 0x051d1d23, 0x080a0c01, 0x2309060d, 0x0d5d5b23, 0x020b123c, 0x0d070501,
    0x24292682, 0x020f0508, 0x050f0c03, 0x21c58208, 0x94820204, 0x0b085a08, 0x1c1d0a10, 0x0707100f, 0x060e1607, 0x0c0d0510, 0x0101130b, 0x02070f01,
    0x05090201, 0x030c0403, 0x050b0501, 0x0b141408, 0x0507221b, 0x010b0201, 0x04050503, 0x07020501, 0x31201e01, 0x020c0315, 0x11060d0b, 0x0113240c,
    0x070c0c0b, 0x050b0209, 0x0b08010a, 0x07020201, 0x26408203, 0x01061725, 0x82080402, 0x090f2ed5, 0x010d0e0e, 0x0a0a0201, 0x0a060e09, 0x088f8201,
    0x071a2e22, 0x03050204, 0x03040a08, 0x1a0f0b15, 0x030d0402, 0x0e065a0e, 0x0933411d, 0x030f050c, 0x64010929, 0x31088882, 0x070c0601, 0x1308080d,
    0x082c1405, 0x0d0d0401, 0x1906080e, 0x04000021, 0x40005600, 0x40030f0c, 0x40012e01, 0x54014a01, 0x37250000, 0x35363732, 0x03822734, 0x84042e21,
    0x35012605, 0x27013f34, 0x34108234, 0x17273536, 0x16211632, 0x3d32013b, 0x23263401, 0x35262221, 0x06bb4734, 0x27222324, 0xd5762223, 0x82268205,
    0x61342031, 0x2b250617, 0x013d2201, 0x280d8437, 0x16171415, 0x27231415, 0x2c298226, 0x14010f02, 0x16333733, 0x0e153233, 0x232a8201, 0x0706010f,
    0x0f210883, 0x05f36101, 0x26353622, 0x2f223982, 0x15822201, 0x1e141525, 0x82261701, 0x0738520b, 0x3b14112a, 0x14153701, 0x34353233, 0x36228182,
    0xd9693233, 0x060a7706, 0x3e343627, 0x1f373202, 0x24178201, 0x15061415, 0x21968214, 0x0983020e, 0x47821720, 0x36222a82, 0xd4823e37, 0x3a822720,
    0x82013f21, 0x21118309, 0x14833233, 0x3736372c, 0x32053336, 0x1614011d, 0xa0823733, 0x874d1720, 0x20428205, 0x056c4907, 0x83373621, 0x22172707,
    0x01161415, 0x44822e22, 0x17232f82, 0x82323732, 0x0622235c, 0x51822225, 0x17229682, 0x97823706, 0x013d3c08, 0x06173334, 0x0e251509, 0x03050c07,
    0x09070a09, 0x09030d11, 0x01010201, 0x6c010305, 0x2e016ca1, 0x051d210b, 0x8dfb6708, 0x19040228, 0x1321070f, 0x1308190d, 0x200a170f, 0x8203e11c,
    0x1cdb0826, 0x04172405, 0x1c0107b5, 0x02182004, 0x12111703, 0x0c0f090c, 0x18010101, 0x6a280b22, 0x07030102, 0x1b1d3c10, 0x34232916, 0x121f0b1d,
    0x03040a15, 0x1457c31d, 0x02041d0b, 0x01090404, 0x0b14100d, 0x10681008, 0x67051b02, 0x05092d38, 0x0105070d, 0x793c0503, 0x2107243c, 0x05040414,
    0x070b0613, 0x0e0d020f, 0x0e0b041d, 0x0a05080c, 0x010c050d, 0x04133a09, 0x0a190705, 0x0502041b, 0x0c090909, 0x6ba17304, 0x11120535, 0x12090a07,
    0x020a050a, 0x08080ab5, 0x03010105, 0x130b0612, 0x01140a01, 0x111d091e, 0x12021d02, 0x0385f806, 0x0503041b, 0x0809280f, 0x070b1d06, 0x0e054802,
    0x2d040b10, 0x092f1508, 0x0f080240, 0x0602060b, 0x0e090504, 0x02341411, 0x0e070e0c, 0x831b1e0e, 0x07102549, 0x44152414, 0x2608d082, 0x01073a07,
    0x061c6c04, 0x04080502, 0x050a0f03, 0x220c0c10, 0x0e070906, 0x0b3d1303, 0x13141107, 0x07050b03, 0x8213080d, 0x0b2208bf, 0x210e1617, 0x03020201,
    0x13150503, 0x1310120e, 0x03080104, 0x15120a0a, 0x01021607, 0x03160a12, 0xe7830802, 0x13050139, 0xfe091503, 0x03021ce6, 0x0c0a1511, 0x01041714,
    0x1a321a02, 0x82090e0e, 0x0a3c0834, 0x01030102, 0x0e08081e, 0x04140307, 0x0d0d140a, 0x08110b1c, 0x07111407, 0x05010702, 0x0c060910, 0x160b0c15,
    0x07101612, 0x16220102, 0x140b140a, 0x0601060e, 0x01150f07, 0x0a0c0d25, 0x2b080d82, 0x030d0509, 0x1e100201, 0x0301030f, 0x0c340b05, 0x010d0e30,
    0x04060107, 0x02050614, 0x0f0a0701, 0x0c093807, 0x0c160d08, 0x03020206, 0x2808ce82, 0x28020a0c, 0x00010000, 0x08d50054, 0x01ab0254, 0x2500000a,
    0x013f3632, 0x023e3436, 0x33163233, 0x34013d32, 0x17323336, 0x06f15433, 0x8207f954, 0x1716230e, 0x2282013e, 0x9e421520, 0x821e2005, 0x831c840b,
    0x011f2129, 0x5a05a24c, 0x3c860515, 0x013b1423, 0x24588232, 0x26373637, 0x26018227, 0x2306012b, 0x46232722, 0xf34b0688, 0x84072005, 0x23142112,
    0x2406067a, 0x23262722, 0x20138422, 0x22058306, 0x8423012e, 0x2514820c, 0x2223010e, 0x15862335, 0x22012b22, 0x2e233782, 0x46363503, 0x2e2205ac,
    0xe8432701, 0x2f262105, 0x07201982, 0x08822588, 0x1406072d, 0x14152207, 0x1433011f, 0x8317021e, 0x43b384b9, 0xe7820676, 0x15220983, 0x06820714,
    0x04b40338, 0x02230203, 0x050e1004, 0x24220b08, 0x05040306, 0x06070301, 0x00820203, 0x0f0c0723, 0x3f088203, 0x06020308, 0x05030102, 0x02020505,
    0x06090a04, 0x03040509, 0x08050201, 0x07020202, 0x05040207, 0x08231282, 0x85040405, 0x06043812, 0x04010303, 0x3e349f8b, 0x2c3b5d54, 0x354f4926,
    0x04f73499, 0x82030506, 0x03082b40, 0x08050302, 0x05090909, 0x3f820302, 0x09020324, 0x08820404, 0x12820920, 0x02230782, 0x82070303, 0x82558259,
    0x0705261e, 0x0208080c, 0x08798205, 0x02090132, 0x02020501, 0x09020603, 0x070c0935, 0x0b0a0803, 0x090d0102, 0x0b160a05, 0x261e1906, 0x44c6051e,
    0x32552222, 0x05371d1d, 0x1119110a, 0x0d19150f, 0x46085582, 0x0302080b, 0x01030101, 0x24133810, 0x05080710, 0x11231014, 0x3557b854, 0x081a1923,
    0x0f181014, 0xd50c170b, 0x0466040e, 0x0902010d, 0x03010206, 0x0f0f120c, 0x110f0402, 0x040e1402, 0x030e0e03, 0x0b071302, 0x82100b06, 0x08132214,
    0x2e08820a, 0x05040912, 0x1a040403, 0x14202611, 0x830f0516, 0x13023100, 0x0f0f0213, 0x13040e11, 0x0c07060e, 0x040a0311, 0x22087482, 0x05060d12,
    0x0807110d, 0x0a011103, 0x02050303, 0x24140a06, 0x0114071c, 0x20030403, 0x0614113f, 0x82070103, 0x0741086d, 0x1c01090e, 0x1110170e, 0x020f1403,
    0x0d090401, 0x1f490810, 0x0405060e, 0x0d050202, 0x0e020103, 0x171b1e15, 0x00040603, 0x00010000, 0x015a0054, 0x00260380, 0x2500003c, 0x013d2223,
    0x35333537, 0x2f038823, 0x36343527, 0x26353733, 0x36373435, 0x07111733, 0x27054e45, 0x07152711, 0x33152315, 0x17280388, 0x2d011415, 0x0c1a10c9,
    0x1a300084, 0x1b221708, 0x697c170a, 0x12021135, 0x0b1b2e20, 0x26080084, 0x270f5a1b, 0x3936342e, 0x35363836, 0x08074919, 0x16042d1e, 0xa803040f,
    0x031a9dfe, 0x0c0a0303, 0x1a3d0111, 0x82351935, 0x3639251e, 0x0f272e34, 0x59249b82, 0x72025a00, 0x80209b82, 0x26259b84, 0x27022e27, 0x0b195f26,
    0x32173334, 0x22343536, 0x22233735, 0x013f3635, 0x36323336, 0x1282013b, 0x3334272b, 0x06141516, 0x1e171415, 0x20028301, 0x054b5d16, 0x1407152a,
    0x14171516, 0x012a2306, 0x3521d682, 0x21d58334, 0x55883427, 0x2b262727, 0x15222701, 0x20258217, 0x05c14933, 0x0805c549, 0x070607d8, 0x0b490106,
    0x2e122210, 0x09041114, 0x2805060e, 0x102c0e3b, 0x10080610, 0x0110040a, 0x05011919, 0x09130503, 0x08850909, 0x0f130101, 0x050a0703, 0x0e0a0a04,
    0x20150b03, 0x010f0c13, 0x0a0a0104, 0x020e0d02, 0x07120101, 0x0c05010a, 0x04160d07, 0x10140201, 0x01011323, 0x150b1110, 0x260e130a, 0x0e07050a,
    0x59462b16, 0x0e060a5a, 0x0a060a10, 0x4608040b, 0x0e37604f, 0x0206040c, 0x14151202, 0x0410632a, 0x09110507, 0x050a0606, 0x03031102, 0x07050401,
    0x2b100715, 0x1e0f110f, 0x19132b51, 0x4617371b, 0x0f203b2e, 0x10070608, 0x1a070a02, 0x45663219, 0x030d0917, 0x1b1a0f0b, 0x010c0604, 0x0914140e,
    0x02050107, 0x21170805, 0x1c281413, 0x135e3031, 0x00820019, 0x5b000330, 0xa3015a00, 0x60002603, 0x86007300, 0x54570000, 0x32332505, 0x021e1135,
    0x0621fe85, 0x05a5621d, 0x3732332a, 0x3411013e, 0x022e3437, 0x2405a375, 0x2627012e, 0x2e048234, 0x012b3435, 0x34373522, 0x35070623, 0x44222334,
    0xad4b0784, 0x15062505, 0x010f0614, 0x17300582, 0x16171411, 0x27233733, 0x17013d26, 0x37023e32, 0x07241882, 0x03060706, 0x1f211184, 0x08128901,
    0x2a16e951, 0x01041622, 0x08060601, 0x09070603, 0x07010604, 0x010a0104, 0x06070501, 0x03040208, 0x03080107, 0x010c0909, 0x0c010402, 0x02130d07,
    0x081e1f1e, 0x04060f02, 0x17061a01, 0x03122205, 0x1b273911, 0x87413a05, 0x1e1d1908, 0x360d0410, 0x82051710, 0x453e230e, 0x0f821b0a, 0x2e053e08,
    0x015a0a2a, 0x03100509, 0x04ff0103, 0x0c05090c, 0x04100c07, 0x3ba47a17, 0x02070705, 0x01130401, 0x0f0f441c, 0x0e0b0a15, 0x0d050803, 0x08190704,
    0x180a1003, 0x0602031e, 0x17030306, 0x08228201, 0x050e1822, 0x0b2f0102, 0x01030409, 0x050b0203, 0x0701fe06, 0x087e1807, 0x0d240307, 0x01040305,
    0x0202190d, 0x01212a82, 0x08118231, 0x06072528, 0x02030305, 0x0504180e, 0x00000205, 0x00580002, 0x0361023f, 0x00430040, 0x01000061, 0x012f023f,
    0x07012f26, 0x07530733, 0x35362505, 0x16172734, 0x08830182, 0x34352623, 0x250b8337, 0x1e17011e, 0x04733301, 0x1e373f06, 0x0f011f01, 0x011e1402,
    0x010f1415, 0x37320106, 0x3f013e13, 0x012e2703, 0x15330727, 0x01820607, 0x14150222, 0x1e224182, 0xdb820201, 0x07242c08, 0x160e0d19, 0x0617042c,
    0x040c020c, 0x060d0c04, 0x240f0203, 0x11020a05, 0x09072706, 0x040a060a, 0x0a0c0304, 0x01042f02, 0x82010b08, 0x227f08e1, 0x06c3fe0c, 0x0c10b60c,
    0x1f054404, 0x12131905, 0x1853011f, 0xb70f301a, 0x1a170703, 0x101e023d, 0x18123201, 0x3d020509, 0x101c0e1c, 0x07170708, 0x050d0a0a, 0x14131106,
    0x2e0d0223, 0x0a2e1908, 0x0d061116, 0x081c0902, 0x0902040e, 0x0f0c0a13, 0x15152d09, 0x02041119, 0x09050907, 0xfe0e280a, 0x0001041d, 0x6f066618,
    0x160e2b01, 0x062b010b, 0x160c0f65, 0x04fffe17, 0x17160705, 0x82001d1a, 0x04200800, 0x5a006100, 0x8c031d03, 0x23001100, 0x73003500, 0x23130000,
    0x37270735, 0x35173727, 0x17371533, 0x27237582, 0x82173537, 0x0727250f, 0x27152335, 0x17230f82, 0x90051537, 0x32032411, 0x44273536, 0x332e0ac8,
    0x17353735, 0x06070611, 0x011f1415, 0xb24d1137, 0x15172705, 0x1d222307, 0xc9441701, 0x15233f0a, 0x33141507, 0x123025c8, 0x2e142f2f, 0x2d122d25,
    0x4c2d132e, 0x37371635, 0x382d3516, 0x02823816, 0x2df60124, 0x18822e13, 0x19822520, 0x2f122d25, 0x44070888, 0x2e2d07e1, 0x02070922, 0x7c693511,
    0x211b0a17, 0x080e4510, 0xac01103c, 0x1a201b35, 0x361b211b, 0x1b211a35, 0xe11a201a, 0x20261e3e, 0x3e1f2620, 0x07832140, 0x19402023, 0x24158234,
    0x351a211b, 0x27258236, 0x351b201a, 0x2e08b2fd, 0x37082d45, 0xc3fe1a35, 0x08050911, 0x1a030303, 0x03a86301, 0x04160f04, 0x490f1e2d, 0x080b2d45,
    0x03000024, 0x5a005900, 0x2603a101, 0x7a005a00, 0x00008d00, 0x27222337, 0x26113526, 0x36373435, 0x013d3634, 0x52182234, 0x3724089d, 0x011d3233,
    0x2805bb54, 0x1532013b, 0x1e011f16, 0x072d4501, 0x15161422, 0x15260a83, 0x06011d06, 0x3d822223, 0x3f2d3a83, 0x27263401, 0x1127022e, 0x07222307,
    0x23568206, 0x06373634, 0x2405ea4b, 0x32331607, 0x05cb7937, 0x07225f82, 0x1682010e, 0x36373408, 0x3d013e37, 0x07020e01, 0x15272306, 0xd5011f14,
    0x27262408, 0x073a1503, 0x1005051c, 0x1e1e0802, 0x0b14051b, 0x0401060e, 0x05030202, 0x0407020c, 0x82080107, 0x0a0730de, 0x01010504, 0x06010610,
    0x04110102, 0x82070803, 0x01c7080d, 0x205c2b03, 0x17031e01, 0x04050623, 0x2f140e10, 0x3c120c1b, 0x0d621d20, 0x052e151d, 0x0f1d1f0f, 0x41870909,
    0x0d0f5a3b, 0x06ff010a, 0x06020b05, 0x28070b0e, 0x11050201, 0x07020115, 0x06041a01, 0x0a0a0505, 0x1007071e, 0x07190803, 0x01050d04, 0x0d110208,
    0x0f0f1505, 0x021080e8, 0x3b050707, 0x0b127aa4, 0x050b1210, 0xfe040c09, 0x1d038785, 0x032714d1, 0x0708162c, 0x10231916, 0x19020407, 0x44261a20,
    0x1813142d, 0x521c3016, 0x015a7727, 0x03050205, 0x04010d19, 0x0d020303, 0x08070423, 0x07000000, 0x09009300, 0xf8028402, 0x76002a00, 0x84008000,
    0x9c008700, 0x0000a000, 0x23352101, 0x37352334, 0x82233527, 0x15332101, 0x37280183, 0x35173331, 0x35333433, 0x142e0c82, 0x15311531, 0x17231523,
    0x23132315, 0xb1422235, 0x82142005, 0x84152010, 0x201a830d, 0x82288235, 0x201b8303, 0x204b8337, 0x20108523, 0x20068427, 0x26518221, 0x23153307,
    0x8223011f, 0x82508235, 0x1530234e, 0x6d840123, 0x132d2183, 0x07273537, 0x27050735, 0x26022f37, 0x263b8227, 0x07011f15, 0x8203051f, 0x022b0809,
    0x019ffe07, 0x03120702, 0x01035f01, 0x010ba90b, 0x03065803, 0x0b030712, 0x01010358, 0xb7010202, 0x5f030203, 0x02100301, 0x82130501, 0x1501340e,
    0x01010207, 0x1a060161, 0x0101051a, 0x06030f01, 0x822fc2fe, 0x2e2c0817, 0xa23131d5, 0x17950138, 0x06070e04, 0x33490b0b, 0x1201161c, 0x080b0706,
    0xdfdfbf17, 0x01017302, 0x01020a18, 0x02015a04, 0x15080613, 0x012f4182, 0x09010458, 0x0295fd1c, 0x01050902, 0x82020202, 0x045b3560, 0xc3030101,
    0x41010108, 0x7c070102, 0x7c020203, 0xc308460a, 0x73085b82, 0x02015804, 0x01360114, 0x30d2fe02, 0x60653205, 0x0649a52d, 0x1c863225, 0x01143a1c,
    0x863d0b14, 0x47022232, 0x003a5a01, 0x00080010, 0x02f1036b, 0x000b00de, 0x0031001f, 0x004f0043, 0x0068005c, 0x00810075, 0x009f008d, 0x00b200a6,
    0x00c900be, 0x010000df, 0x34353632, 0x07062023, 0x01161715, 0x26272221, 0x34112627, 0x17203336, 0x11161716, 0x03060710, 0x20096f44, 0x056f4407,
    0x11900720, 0x3637132c, 0x22012f35, 0x1f15010e, 0x0b843301, 0x84072321, 0x3f27380c, 0x26273501, 0x15010f23, 0x3f331716, 0x012f3401, 0x15020e23,
    0x82011f16, 0x200b8317, 0x21748201, 0x3b83023f, 0x1f222282, 0x59902701, 0x3f230726, 0x17063302, 0x22202e85, 0x2e84a383, 0x1e335183, 0x33350701,
    0x23352335, 0x15331507, 0x07273707, 0x59262223, 0x5c080566, 0x27263717, 0x14150622, 0x0a8a0316, 0x85fe1208, 0x0c080907, 0x86fca701, 0x0a16090b,
    0x03162204, 0x08140a87, 0xe80e0404, 0x0d05100c, 0x0c10050d, 0x11051003, 0x49100511, 0x0f070d0e, 0x0e0d070f, 0x0f061104, 0x0911060f, 0x0c04040c,
    0x05050634, 0x030a9d0a, 0x0a320a03, 0x0a060204, 0x2414833b, 0x06050a30, 0x21148509, 0x14820905, 0x050c9a27, 0x0f2f0c05, 0x84048202, 0x20048309,
    0x215d82f6, 0x5d820e0e, 0x0413042e, 0x13041010, 0x0f1e37f8, 0xe004040a, 0x05242084, 0x2f0b070d, 0x45080984, 0x060a070b, 0x48212177, 0x36b87060,
    0x13131106, 0x12090321, 0x160a2116, 0x33373716, 0xf8098701, 0xf0100313, 0xe4fe040d, 0x09140b05, 0x22190b02, 0x0a170904, 0xf5fef3fe, 0x87012409,
    0x090a0911, 0x10090908, 0x06820910, 0x11090a22, 0xfe290f8e, 0x300c04a4, 0x0905070a, 0x31b38533, 0x06020707, 0x6f040c32, 0x0d2f0a08, 0x2f0d0303,
    0x0984070b, 0x06050226, 0x6f080a32, 0x09212b84, 0x882b8205, 0x080a2220, 0x25528edc, 0x191938f0, 0x2a84b026, 0x8a301121, 0x040e3c4a, 0x962c3c6b,
    0x043c279b, 0x1a072e09, 0x150a0b1a, 0x2b050408, 0x2a390105, 0x8200362d, 0x06410800, 0xe0002300, 0xb6027f06, 0x11000600, 0x26001800, 0x3e003200,
    0x3f010000, 0x07022f02, 0x2f373337, 0x15162101, 0x26050714, 0x27373435, 0x23372707, 0x23352315, 0x33171507, 0x05073337, 0x34353632, 0x051d5e26,
    0xc7433720, 0x155c0806, 0x05231533, 0x0311bbb0, 0x5dbe1003, 0x23012213, 0x167cfe15, 0x10bbfd0f, 0x24027c19, 0x0f842102, 0x010c241f, 0xdd010182,
    0x62898a61, 0x978a8961, 0x71707071, 0x83016b6b, 0x28272602, 0x16b60821, 0x341802a0, 0x012e303e, 0x373f352a, 0xd401d601, 0x493a1727, 0x8d211636,
    0x8b605f8c, 0x8a373182, 0x66727445, 0x01007266, 0xdb005400, 0xa6025308, 0x00008900, 0x59272225, 0x0f2205dd, 0x004e0601, 0x6d2f2005, 0x474e059d,
    0x601c8205, 0x362f05ad, 0x3734013d, 0x32333634, 0x013b1617, 0x82373637, 0x17162409, 0x5e1f031e, 0x272105ba, 0x26108334, 0x0e071417, 0x82141501,
    0x15022517, 0x32331407, 0x17202d84, 0x3f24ea82, 0x37013e01, 0x20825e84, 0x22212322, 0xb04e5282, 0x4b072005, 0x4c0805bf, 0x00041415, 0x0111141d,
    0x271a0a04, 0x6e311d37, 0x18192021, 0x1f58497c, 0x0b16190c, 0x020c050a, 0x06040201, 0x0205110b, 0x0e08060e, 0x4d061a16, 0x16973e3e, 0x16395a20,
    0x13272a2d, 0x01030618, 0x12160101, 0x0b011717, 0x08071307, 0x080f8202, 0x0c02089a, 0xac3a7c96, 0x1102013a, 0x10721628, 0x334a0f20, 0x202f4d2b,
    0xfe386f37, 0x0204058c, 0x28170c06, 0x1f27190c, 0x0e081007, 0x1c1418db, 0x031e101f, 0x02010906, 0x06010208, 0x27030a02, 0x08130c11, 0x06092020,
    0x0e1c1508, 0x140a0b05, 0x16111314, 0x03060723, 0x02030707, 0x03060602, 0x09050f03, 0x171b290b, 0x060c0f13, 0x09140405, 0x04030a1c, 0x06090606,
    0x020f0501, 0x0901040b, 0x60020501, 0x0f182126, 0x030d0403, 0x1e10150a, 0x0e390b07, 0x0204140b, 0x00100a08, 0x022f0082, 0x5a005300, 0x2603320a,
    0x15010801, 0x56250000, 0x262e0532, 0x37352635, 0x06222334, 0x14171415, 0x03821506, 0x010e0727, 0x0e272223, 0x41078201, 0x15230557, 0x41230614,
    0x352f053b, 0x37363734, 0x012e3536, 0x012f2627, 0x47222726, 0x222805a4, 0x22052306, 0x34352627, 0x26059e41, 0x011e3233, 0x4b331617, 0xb24105ed,
    0x2d188405, 0x3b011e17, 0x27353201, 0x15163334, 0x2d631407, 0x27352706, 0x032e2726, 0x3f840723, 0x16285a82, 0x17323717, 0x33143216, 0x2607e956,
    0x0e151617, 0x82320702, 0x16142115, 0x32235582, 0x8237023e, 0x22438267, 0x82061532, 0x331622af, 0x22498225, 0x82163336, 0x14172435, 0x82212623,
    0x06b85793, 0x2620c482, 0xc382d782, 0x2227072a, 0x23020e07, 0x27022e22, 0x22202382, 0x27291582, 0x011f1607, 0x35322514, 0x201a8234, 0x08fb8323,
    0xea05168e, 0x29071a1b, 0x02163145, 0x0b040a01, 0x01030903, 0x0b230603, 0x0e062036, 0x03080406, 0x13070501, 0x0d1c0b0f, 0x121a1012, 0x01041325,
    0x0a0d0b03, 0xd48e2d7c, 0x1a190512, 0x1dedfe0c, 0x0c030303, 0x0e030503, 0x2da10810, 0x1719101b, 0x1918856f, 0x1819392b, 0x1101162b, 0x22100c06,
    0x04020a41, 0x51010592, 0x3a5f0201, 0x0c222e3e, 0x21200110, 0x030c311a, 0x04061a07, 0x1a060a0a, 0x070a1413, 0x0b130a05, 0x09100818, 0x03040718,
    0x39087082, 0x11dc0d10, 0x192e0116, 0x0509142c, 0x02011104, 0x080c0c01, 0x25030101, 0x17451501, 0x07080717, 0x05020110, 0xd0fe7821, 0x0f070715,
    0x0f06011f, 0x21120a03, 0x2a162244, 0x6b820d16, 0x0f0a4e08, 0x10100505, 0x0e03090c, 0x14050b09, 0x020be707, 0x18b4fe02, 0x190a1d03, 0x5a101609,
    0x0f030203, 0x12128e90, 0x0b070707, 0x13050308, 0x0a051406, 0x23120f0f, 0x0a130a11, 0x08040904, 0x160b0307, 0x08060409, 0x200c090a, 0x05061b46,
    0x081f820b, 0x03090285, 0x151b3802, 0x02080606, 0x34121c0d, 0x010907da, 0x1f051702, 0x39040114, 0x0410090a, 0x32050401, 0x04170b04, 0x01070425,
    0x03070201, 0x02040601, 0x0203180c, 0x09050815, 0x0202010c, 0x0e0c0e0c, 0x13020709, 0x04030801, 0x01050c01, 0x04070603, 0x0913120c, 0x02012512,
    0x0509060b, 0x171b0c0c, 0x080f080f, 0x1c1c0104, 0x0506092c, 0x01030103, 0x100f0801, 0x09070613, 0x02211c02, 0x01050502, 0x82010401, 0x0710385a,
    0x04050f06, 0x0107291f, 0x91272901, 0x0a19f93a, 0x0b010109, 0x4202011c, 0x210806e3, 0x03fb0826, 0x005d005a, 0x2500007d, 0x17133727, 0x16173736,
    0x3e023f17, 0x3f213701, 0x35273501, 0x01821533, 0x20371732, 0x36211737, 0x2327013f, 0x0721012f, 0x07272126, 0x35051849, 0x27350727, 0x15211523,
    0x2f213523, 0x010f1502, 0x22270727, 0x41821407, 0x1f150622, 0x4406ef76, 0x01230551, 0x4326022f, 0x3720050f, 0x24057d44, 0x34012f37, 0x82518237,
    0x08378226, 0x10b901f9, 0x180a4903, 0x1d1d1618, 0x3c0e1796, 0x46010708, 0x1e070703, 0x090d9131, 0x06095701, 0x0608bf01, 0x08010204, 0x0a46fe07,
    0x0da9fe0a, 0x1c2b960a, 0x48080a0b, 0xfeafd2fe, 0x175c09c7, 0x072b131e, 0x09040f10, 0x0b04350a, 0x08061f26, 0x1910210b, 0x02040a0e, 0x19259059,
    0x110b0904, 0x0d18220b, 0x060a1104, 0x23110b02, 0x02100aa4, 0x17261d15, 0x03360123, 0x09030503, 0x1005050b, 0x31030b91, 0x32061806, 0x06051a15,
    0x16150403, 0x091e3538, 0x06060104, 0x0d17142a, 0x270a1a01, 0x02070605, 0x5e39190d, 0x0f02261c, 0x0603050d, 0x0d0c1b1b, 0x0907080b, 0x2d441d08,
    0x613a524a, 0x10076f01, 0x10100a1d, 0x06081511, 0x10201c09, 0x07251307, 0x12121d0e, 0x01012417, 0x3c0c0b09, 0x03000041, 0x27005c00, 0x5a032d05,
    0xb500a700, 0x0000df00, 0x012e2325, 0x69052e27, 0x16370502, 0x06071715, 0x26230607, 0x22232627, 0x0f010e07, 0x17150601, 0x8217011e, 0x012b2a13,
    0x27222306, 0x012f2635, 0x07244434, 0x27343523, 0x23168226, 0x3d26012b, 0x22052378, 0x6a34013f, 0x33270512, 0x3e171632, 0x85013f01, 0x17162f04,
    0x33161732, 0x21163336, 0x1737013e, 0x0e83031e, 0x07141524, 0x5c822722, 0x2b061425, 0x83072201, 0x1516252f, 0x010f0607, 0x6f821d82, 0x82140721,
    0x010e2186, 0x06201a82, 0x3d205982, 0x27275682, 0x07020e22, 0x84320116, 0x05395b7b, 0x0e010f2f, 0x16141502, 0x22151617, 0x3735012e, 0x09268436,
    0x0622370b, 0x011e1415, 0x0643fe03, 0x1e0f0206, 0x1c1c1f1e, 0x0905070e, 0x0b010103, 0x193d450d, 0x2b0c1d24, 0x08140712, 0x08010d0e, 0x140a0311,
    0x5e030403, 0x310e055d, 0x03020109, 0x1309171b, 0x0f1a1912, 0x0f100612, 0x2a14070a, 0x0101060f, 0x06132001, 0x060a0407, 0x18050c05, 0x02040317,
    0x05050c0c, 0x511b42c6, 0x01292114, 0x0402021f, 0x0b070425, 0x54550402, 0x2b810707, 0x2c120103, 0x03271e31, 0x070c130b, 0x2c130801, 0x21222112,
    0x050f0611, 0x0705020c, 0x02050612, 0xbcfc0d08, 0x03080603, 0x03030502, 0xa4010401, 0x0c10262d, 0x101d010f, 0x101a0d0f, 0x030d0401, 0x10071707,
    0x03011017, 0x14010205, 0x27291f2e, 0x2f081006, 0x5d5e5f5f, 0x08062d5b, 0x0e040c0e, 0x091e1d0a, 0x0c011e05, 0x381c350a, 0x1b252b1c, 0x09080428,
    0x02020d0e, 0x1a061a07, 0x1a130d19, 0x2a144751, 0x251c2418, 0x04020911, 0x06061208, 0x26408210, 0x081e1207, 0x820a1006, 0x0d0721b9, 0x0627ce82,
    0x0101050c, 0x82010e09, 0x052f0880, 0x0603040a, 0x030b070d, 0x12110f02, 0x0c0b0110, 0x02061f12, 0x0305040f, 0x01080704, 0x6c6b6c36, 0x162a1636,
    0x050a0d0a, 0x060a0301, 0x8203dd02, 0x04042318, 0x9d820202, 0xfe0b5408, 0x0f0813d9, 0x10291913, 0x0b010d08, 0x07100e08, 0x06121c09, 0x0c171709,
    0x090e0e0a, 0x0a030403, 0x2217192b, 0x0500000b, 0x27005d00, 0x5903e206, 0xaa009e00, 0xc200b500, 0x0000e700, 0x2e272625, 0x36343502, 0x34373637,
    0x36323336, 0x37033e37, 0x48373217, 0x072405e1, 0x27222306, 0x172b1582, 0x34323316, 0x013b3637, 0x83352627, 0x32162925, 0x33140715, 0x33141632,
    0x2005d65d, 0x200b8216, 0x21348221, 0x29823233, 0x17143728, 0x14171516, 0x04820607, 0x20230624, 0x09820607, 0x2306142c, 0x010e2227, 0x07061415,
    0x8666010e, 0x05ea7a07, 0x23210d83, 0x20258222, 0x05ec4222, 0x85161521, 0x5a288225, 0x398205b0, 0x3b141530, 0x37333601, 0x23062334, 0x21331415,
    0xc6523532, 0x82272005, 0x32012432, 0x4834013f, 0xc7750c93, 0x26780807, 0x23263427, 0x011e1707, 0x19011617, 0x28153330, 0x1755481c, 0x0d050902,
    0x0a261a11, 0x0b280f12, 0x140e0303, 0x050b0912, 0x1a040705, 0x0c170a0a, 0x120e0b0e, 0x12141c0f, 0x0c020503, 0x09030208, 0x0f2d0302, 0x29040205,
    0x0b7b8325, 0x0f0d5c02, 0x02021827, 0x0e050402, 0x08030111, 0xfd060502, 0x0e08022e, 0x1d120a08, 0x0847170e, 0x41361317, 0x0e1b2217, 0x06050404,
    0x5d081b82, 0x07061111, 0x060c0c18, 0x08020602, 0x090c041c, 0x0204070c, 0x01760339, 0x2118030c, 0xeb330b2b, 0x0f01500d, 0x01104728, 0x0207105a,
    0x1c211b0c, 0x95fc0114, 0x04010472, 0x06110a12, 0x1c040905, 0x08070c17, 0x03060702, 0x021f0d22, 0x120e0a2d, 0x02271810, 0x28010104, 0x92b25c16,
    0x73821929, 0x05035c08, 0x070f110a, 0x0a060202, 0x02041905, 0x03060c06, 0x0a120e04, 0x03230b08, 0x02040201, 0x09030e01, 0x07060306, 0x010d0612,
    0x26120f15, 0x1808071d, 0x1f081805, 0x1b2d0602, 0x02111120, 0x1c0e1107, 0x0810133b, 0x0c2d1e1c, 0x0a1c060a, 0x05070604, 0x07010305, 0x0a083417,
    0x82321020, 0x0b082fae, 0x01150e0d, 0x0805e402, 0x05070102, 0x06820401, 0x030a5508, 0x07020106, 0x4a15fe03, 0x07040928, 0x0a030904, 0x1b020311,
    0x030e1308, 0x06010206, 0x0802331c, 0x1227180c, 0x0a00110b, 0x21003400, 0x6003cd02, 0x71003800, 0x95008d00, 0xa800a000, 0xbf00b300, 0xce00ca00,
    0x21650000, 0x022f3736, 0x3f343526, 0x36373501, 0x27290182, 0x3f363734, 0x021f1601, 0x200c8227, 0x8285821f, 0x0715250c, 0x37013e17, 0x16201382,
    0x21055060, 0x2646011d, 0x34352105, 0x273b3a82, 0x2707010e, 0x0f273437, 0x2f372701, 0x010f0601, 0x26012f17, 0x07060727, 0x82171506, 0x010f2204,
    0x27098215, 0x06031f14, 0x34212507, 0x37206b85, 0x24243e82, 0x021f3233, 0x15294f86, 0x33272503, 0x2705031f, 0x207a8534, 0x28428206, 0x011f023f,
    0x012f2613, 0x2d7f8434, 0x35263706, 0x37363736, 0x010f1716, 0xa3832506, 0x63820a82, 0x37274108, 0x85022317, 0x080186fe, 0x52770e09, 0x04030605,
    0x121f040a, 0x3e07100d, 0x0b0b021b, 0x1e1e1908, 0x12021018, 0x02313901, 0x31050216, 0x3f200b1c, 0x09130707, 0x13091717, 0x203f0707, 0x05311c0b,
    0x31341882, 0x02120139, 0x1e1e1810, 0x0b0b0819, 0x073e1b02, 0x1f120d10, 0x2c084882, 0x52050603, 0x08090e77, 0xfe880101, 0x10080886, 0x330d9137,
    0x18625001, 0x083f310a, 0x17081308, 0x41cdfe6d, 0x3d36515a, 0x1d5cfe52, 0x2d71841d, 0x5f800303, 0x201c191e, 0x2f471018, 0x76820107, 0x1d0cb108,
    0x0b0d315a, 0x05293103, 0xfe020d08, 0x06117264, 0x01021fd5, 0x21730c04, 0x3c214827, 0x78292d28, 0x170a064e, 0x2c067e28, 0x4e0d050c, 0x0418190b,
    0x3510160a, 0x06223d02, 0x401c1802, 0x280a3101, 0x08021709, 0x1412040d, 0x2b084e09, 0x08e24e2a, 0x97970d1e, 0xe2081e0d, 0x082b2a4e, 0x1214094e,
    0x02080d04, 0x0a280917, 0x1d3f0131, 0x22060218, 0x1035023d, 0x18040a16, 0x0d4e0b19, 0x062c0c05, 0x0a17287e, 0x29784e06, 0x023c282d, 0x282e283c,
    0x07048d3b, 0x3d0c7f43, 0x4d0c021b, 0x4d2b2b08, 0x0d1d09e3, 0x8537bd01, 0x141f100d, 0x300c784f, 0x11268082, 0x77103936, 0x8384ec11, 0x0be9fe26,
    0x0d3da70b, 0x35088782, 0x0d0b16ca, 0x05149615, 0x4e101f04, 0x260a0845, 0x5b081248, 0x282e0a06, 0x0809390c, 0x0a000000, 0x13005300, 0x1703a504,
    0x10000400, 0x30002400, 0x4a003500, 0x15824f00, 0x00572c08, 0x2500005c, 0x37343526, 0x11353203, 0x22212334, 0x33141115, 0x27222105, 0x2f343536,
    0x21333601, 0x15061732, 0x06011f14, 0x82222127, 0x820f8220, 0x27013520, 0x03173736, 0x35372437, 0x06272427, 0x07231507, 0x16171506, 0x37200183,
    0x37241983, 0x05173727, 0xd4080382, 0x15161101, 0x22a50414, 0x50509d22, 0x5151e1fc, 0x2cfc7d03, 0x262e023d, 0x03390406, 0x300a34d4, 0x9309062a,
    0x3030e1fc, 0xfe311f03, 0x39386f37, 0x010a706e, 0xfe080540, 0x8e0604bd, 0x0109b102, 0x01038806, 0x4d9909b4, 0x951b9a4c, 0x2afe9170, 0xfe72936e,
    0x927d1d01, 0xfd888d8d, 0xb50151c4, 0x4bfe5151, 0xb03c6251, 0x1b9196a1, 0xa4aa2c35, 0x2c19a5a0, 0xb5013182, 0x4bfe3030, 0x41450131, 0xfe361b1d,
    0x08f604a7, 0x019c070a, 0x55014502, 0x09040409, 0x89020169, 0x2d2c761f, 0x44561559, 0x46545446, 0x02cefe44, 0x83837f0c, 0x77000400, 0x2f066300,
    0x13007903, 0x2a001f00, 0x00003500, 0x05071301, 0x1705012f, 0x37260507, 0x25173725, 0x17253727, 0x33108207, 0x17150722, 0x35372533, 0x0f052317,
    0x25011f01, 0x1727013f, 0x1e820987, 0x75ba6b08, 0x305bfe1d, 0x067ffe29, 0x4789fe64, 0x6973010a, 0x25800127, 0x32950114, 0xfe0a074a, 0x080305dd,
    0x07260107, 0xd3fe0b1e, 0x0a070209, 0x02082e01, 0xd7fe1506, 0x0a08020b, 0x03062a01, 0x5c030a05, 0x3f34a8fe, 0x399b670a, 0x624a8d3e, 0x9b2e159b,
    0x1dbd315f, 0x6c02086c, 0x69070c06, 0x585b0a08, 0x03070a07, 0x070a065c, 0x04824561, 0x05480435, 0x0002060b, 0x00580003, 0x03540313, 0x0008004c,
    0x8227001d, 0x337608bd, 0x27071637, 0x07273635, 0x2f260716, 0x22072603, 0x06170607, 0x04372607, 0x36011525, 0x23130617, 0x33372726, 0x2303e602,
    0x4b205b48, 0x4a3b143e, 0x03515d2d, 0x0555aa08, 0x33010203, 0x01101b2f, 0xfe260144, 0x177d7e0e, 0x4704bc14, 0x4303020d, 0x0ac1eb09, 0x06d5c202,
    0x1210bcce, 0x08050611, 0x0503050d, 0xa09f0d07, 0xfe01410d, 0xa30c13a2, 0xc3ddd0fe, 0x0082002c, 0x81820320, 0x22063b2a, 0x1b00aa03, 0x2a002200,
    0x25088b82, 0x34353627, 0x07012f26, 0x34373627, 0x1617012f, 0x17011e17, 0x17141506, 0x05011f16, 0x07172527, 0x26010706, 0x0883013d, 0x8e058008,
    0x2b170419, 0x6836362a, 0x6b7c7c04, 0x4d464975, 0x15061001, 0xa9fc1a2b, 0x36ea0135, 0xfc446651, 0x5a023395, 0x01a08835, 0x11114432, 0x14183c1e,
    0x22339016, 0x11515418, 0x9f262519, 0x13153033, 0x3e233011, 0x8db4a032, 0xfe20231c, 0x11613f9c, 0x4839a1df, 0x00050000, 0x0726000e, 0x00760396,
    0x003f0033, 0x00650057, 0x37000074, 0x35262722, 0x25013f34, 0x3f363724, 0x07371702, 0x82023f17, 0x07272392, 0x9282011f, 0x2723062c, 0x37272607,
    0x26230727, 0x02822223, 0x07040524, 0x28820106, 0x022f0123, 0x20c3820f, 0x200b8209, 0x24d48235, 0x22072726, 0x22108305, 0x83071415, 0x013f28d3,
    0x37242734, 0x83231732, 0x013523d6, 0xfb823732, 0x27262724, 0xef83010e, 0x4e980e09, 0x2d150e2e, 0x41024002, 0x5f653638, 0x180d0126, 0x6a0e181e,
    0x9c354450, 0x05ab2a4d, 0x3856400c, 0x362f1110, 0x01051e05, 0xad010907, 0xf9fd6a06, 0x0c240ffe, 0x07070c05, 0x09070e05, 0x0209094a, 0x0394fb0c,
    0x041314e9, 0x1d12020f, 0x12fc0c0d, 0x32050409, 0x190b0203, 0xc9032601, 0x010a0a1f, 0x0606070c, 0x1420a2fb, 0x1e151412, 0x1216251d, 0x1a1f5e26,
    0x8f1e1b21, 0x70141d94, 0x07031c6a, 0x06e903e2, 0x5f5b0807, 0x20525c20, 0x3025281e, 0x0e134901, 0x072e012a, 0x1491961f, 0x01790106, 0x0da60805,
    0xa50d0505, 0xc2fe0310, 0x130e2601, 0x0112171e, 0xf4050512, 0x240a0b08, 0x03100e3b, 0x24090203, 0xe9273910, 0x16160b04, 0xfe020503, 0x1f1513b3,
    0x03131519, 0x201c2605, 0x07001113, 0x1f004400, 0x0c03fd02, 0x3e003000, 0x5a004c00, 0x6c005b00, 0x00007a00, 0x34112125, 0x012b2627, 0x3e373435,
    0x36262701, 0x1636013f, 0x20018217, 0x240e8236, 0x1e173117, 0x05fe4f01, 0x15161731, 0x22231533, 0x25150607, 0x14150622, 0x52213316, 0x05200544,
    0x372b0d9a, 0x22231121, 0x33013d26, 0x83023930, 0x33212702, 0x2b061415, 0x0b831101, 0x02313708, 0x0c5afe73, 0x0c5e120d, 0x102a0638, 0x08a8180e,
    0x1b0e040e, 0x04185c2b, 0x18ab070e, 0x15130f0d, 0x010a1e1e, 0x0e0c125e, 0x0d099cfe, 0x2301090d, 0x090c0c09, 0x0b95ddfe, 0xfe6d4308, 0x0c0a4803,
    0x5efd015e, 0x1f48090d, 0x0d120701, 0x070d4d0c, 0x13348927, 0x022d082c, 0x111b0707, 0x062d1918, 0x082d0206, 0x3515132c, 0x1244251f, 0x0c4e0c07,
    0x0c2b120d, 0x0d0d080a, 0x570c0a08, 0x5983090d, 0x580d0922, 0x842b1187, 0x0a0cf9fe, 0x0c0af1f1, 0x82000701, 0x00013f00, 0x03840002, 0x004c0203,
    0x25000018, 0x26271035, 0x06030f23, 0x32070607, 0x1f373237, 0x02821601, 0x03333b08, 0x4c3d9703, 0x32389497, 0x0b0e0b28, 0x334b1c1c, 0x322f3b2a,
    0x84d41f22, 0x591e011e, 0x382d0633, 0x0b146a51, 0x0606080e, 0x14151d19, 0x01000005, 0x20003b00, 0xe7025903, 0x53827700, 0x69055c51, 0x26210545,
    0x26018327, 0x17323336, 0x6417011e, 0x324a0595, 0x012f2906, 0x3435022e, 0x011f3233, 0x17291983, 0x3233021e, 0x36333637, 0x20298237, 0x05eb4502,
    0x010e1524, 0x026d2223, 0x23062505, 0x27012e22, 0x8205fb64, 0x09f47b2a, 0x14155d08, 0x02030e07, 0x050a0617, 0x0d850d0f, 0x21030a0c, 0x0d063e14,
    0x06033e39, 0x57370504, 0x09010209, 0x1002020b, 0x02050209, 0x03540408, 0x060e0505, 0x0a670d04, 0x0a0d0c11, 0x080d3517, 0x25341c0c, 0x0b1b2626,
    0x330d1618, 0x06151411, 0x0b0a1801, 0x3e361e0c, 0x1a50382e, 0x040a1e19, 0x8d083682, 0x0603080a, 0x06060212, 0x1b070604, 0x060a4625, 0x08090302,
    0x09020620, 0x7482680a, 0x083b0408, 0x2d0d051a, 0x160d0532, 0x080f0621, 0x0413030a, 0x6f060206, 0x02070803, 0x48090605, 0x11121803, 0x0310040d,
    0x07020104, 0x080c0503, 0x0e0f0d1b, 0x0d100f08, 0x1c181709, 0x02030c0e, 0x01080309, 0x0a040b04, 0x17150c13, 0x3335300f, 0x09062e44, 0x0b020518,
    0x00000403, 0x25000300, 0xf2022200, 0x0f00ef02, 0x1f001700, 0x22250000, 0x6218012e, 0x0e2309e5, 0x54012501, 0x053005f9, 0x34353632, 0x01160127,
    0x61a3628b, 0x6362a361, 0xfe300583, 0x426601c9, 0x01976a50, 0x2d956c01, 0x22419bfe, 0x63201887, 0xd5392482, 0x962d6601, 0x96b1506c, 0xfe42506b,
    0x00002d9a, 0x001d0002, 0x02e80220, 0x286b82eb, 0x0100003b, 0x15011e32, 0x051e4c14, 0x13317183, 0x2337013e, 0x34352622, 0x2e013b36, 0x14152701,
    0x270d8206, 0x010e013d, 0x16323307, 0x2b240d82, 0x17011e01, 0x0d831d82, 0x63830128, 0xa16161a1, 0x05836463, 0x936b8228, 0x110d930c, 0x06820d11,
    0x0c126b24, 0x0f8c120d, 0x120c0d24, 0x2a87eb02, 0x36826420, 0x0c72fd25, 0x82126b93, 0x8a268c16, 0x82002036, 0x00023700, 0x08d7005e, 0x00a902de,
    0x00930084, 0x24372500, 0x37323337, 0x98823736, 0x22232631, 0x06222325, 0x3522012b, 0x15222334, 0x82141714, 0x6aab820a, 0x2622064e, 0x715f012b,
    0x22272105, 0x2e210782, 0x202a8202, 0x08a67607, 0x154d2220, 0x17162405, 0x82013b16, 0x1733244e, 0x82013e32, 0x331421cf, 0x32200c83, 0x36201483,
    0x33210e82, 0x24058232, 0x32331617, 0x22168817, 0x82161415, 0x058d4d74, 0x32376408, 0x14151617, 0x0201ae03, 0xca7f2dcf, 0x373f2e7d, 0x14e1366d,
    0xe8c0fec5, 0x50070c0e, 0x011b0603, 0x04055e06, 0x03060909, 0x06080742, 0x47030906, 0x07060b07, 0x04063708, 0x08020b02, 0x281d0304, 0x09051105,
    0x1f0f1406, 0x60170705, 0x04100a20, 0x02030807, 0x0b1008ac, 0x060e0d0b, 0x0604040a, 0x82012824, 0x063e0807, 0x07064107, 0x06080604, 0x07080844,
    0x34050306, 0x0501070a, 0x080f0708, 0x0402015a, 0x09063011, 0x07200508, 0xd70c0305, 0x3c010161, 0x10093816, 0x0a032209, 0xa20202a6, 0x080b0608,
    0x00820a03, 0x040a013e, 0x06040501, 0x020b0109, 0x13100101, 0x100b413a, 0x01050908, 0x02060302, 0x090a0802, 0x2208a283, 0x07070201, 0xca014134,
    0x13030511, 0x0c060201, 0x02000019, 0x8b015000, 0x94020e09, 0x64005c00, 0x41010000, 0x362c060c, 0x2726013f, 0x07222126, 0x23272306, 0x07200384,
    0x23210786, 0x2d138327, 0x27353707, 0x0706040f, 0x07052735, 0x02872315, 0x08832720, 0x2537172c, 0x1733013e, 0x07141516, 0x5d553617, 0x17220805,
    0x2517011e, 0x33343522, 0x04141532, 0x55ee7e1a, 0x86738e76, 0x3a3132d3, 0xb0fee6ea, 0x0703a431, 0x03850d0a, 0x0e095208, 0x0e0a0801, 0x0d090802,
    0x800a0804, 0x16071912, 0x072e1915, 0xbcfd0509, 0x0a0b0a10, 0x090a0b0c, 0x1f0d0a0c, 0x35c1018b, 0x37090208, 0x0f12190a, 0x0d0c260d, 0x231f100f,
    0x1878fc02, 0x8b011818, 0x2f09072c, 0x1f1d1817, 0x0707041d, 0x01070708, 0x38008307, 0x02080701, 0x030e052b, 0x01080d26, 0x05040407, 0x070a0b0a,
    0x06090808, 0x36188209, 0x230f360b, 0x06060801, 0x0b13112b, 0x0b091f15, 0x23080604, 0x8212320d, 0x02003100, 0x01015300, 0x7f025308, 0xa600a000,
    0x32130000, 0x0382cd83, 0x16173223, 0x850b8333, 0x20ec8207, 0x25e08232, 0x013f3233, 0x6942021e, 0x83322005, 0x05494108, 0x37013e25, 0x42331632,
    0x37240568, 0x011e3336, 0x56066642, 0x0720057d, 0x310a886e, 0x23062223, 0x23260717, 0x07142715, 0x07222726, 0x11832622, 0x06142725, 0x82072715,
    0x2726280e, 0x26272306, 0x83230623, 0x020e2132, 0x0e243984, 0x16140701, 0x08051949, 0x342516ea, 0x2217013b, 0x181209ab, 0x16304708, 0x0751482a,
    0x24070809, 0x07202739, 0x0b040907, 0x242c142b, 0x0c120a07, 0x0302200a, 0x05460203, 0x020a0a05, 0x02050c0a, 0x090a0f03, 0x0502060d, 0x0c0e060c,
    0x100b1104, 0x05030207, 0x08110d0a, 0x10020203, 0x050e090e, 0x44b2fd41, 0x4da6346e, 0x616e30a9, 0x105a6053, 0x0a040406, 0x0601010c, 0x06020803,
    0x01030201, 0x03010103, 0x04020602, 0x05010706, 0x04040402, 0x0b2b1a0b, 0x5e2b9474, 0x2e30181d, 0x31234c42, 0x010f0721, 0x0104081b, 0x11050c02,
    0x3f01b102, 0x01013001, 0x39060807, 0x1b03040d, 0x03200703, 0x0b040512, 0x0d0a360f, 0x0d06200a, 0x040a050b, 0x06090304, 0x01080303, 0x04080c0a,
    0x0105020a, 0x0a0c1002, 0x5a2e7c26, 0x160a300e, 0x0d100602, 0x030a0208, 0x04252382, 0x01020403, 0x822d8206, 0x3b868282, 0x06020405, 0x01010d07,
    0x02010603, 0x19150809, 0x0b30271b, 0x0e0c0d15, 0x11070204, 0xdf331a82, 0x02000f10, 0x09015400, 0x7802ed07, 0xad009e00, 0x41010000, 0x262606ca,
    0x22272627, 0x26580607, 0x010e2205, 0x230e8207, 0x22012f26, 0x24056144, 0x23262207, 0x055f4407, 0x1b751085, 0x82232005, 0x4435821e, 0x82680a85,
    0x22072306, 0x0a832627, 0x48820720, 0x06070622, 0x23250682, 0x2b142722, 0x82368201, 0x2263830e, 0x86363233, 0x013e2978, 0x1732013f, 0x3f323316,
    0x25057243, 0x011f1617, 0x0b853b16, 0x6b141521, 0x36210567, 0x08218233, 0x0e1415b2, 0x99ec0401, 0x42669ad6, 0x58582828, 0x0a09167f, 0x14541003,
    0xba07090f, 0x2e1c1d5e, 0x08040904, 0x12040101, 0x03040d03, 0x0a04030a, 0x03070203, 0x02080203, 0x03050902, 0x02020905, 0x030d0308, 0x02030b03,
    0x0303020a, 0x0902030c, 0x03020b03, 0x12020804, 0x0a040103, 0x62611e04, 0x973a773a, 0x07132c58, 0x0a04030d, 0x0a180e0a, 0x0307370d, 0x050a1320,
    0x1d1d070c, 0x52381e3a, 0x3a387038, 0x0b071c06, 0x201f0a0d, 0x0f2b0c2e, 0x050b241f, 0x07010a04, 0x02080608, 0x150c26fc, 0x09080912, 0x12060b08,
    0x01030901, 0x2137263a, 0x271c2824, 0x40087e83, 0x211a0504, 0x01020214, 0x05124301, 0x08080806, 0x01090604, 0x02070d05, 0x03010407, 0x01080807,
    0x08020907, 0x0503090c, 0x01080407, 0x07030404, 0x010a1514, 0x0d030a01, 0x1b621a14, 0x0f25110c, 0x24ab8207, 0x0a071d0f, 0x08d2830a, 0x08051432,
    0x01061817, 0x1b341513, 0x040e0903, 0x1527020a, 0x0407100f, 0x06090f06, 0x00000d0e, 0x00540002, 0x03d30759, 0x00900029, 0x250000a4, 0x35363732,
    0x2605a143, 0x37363217, 0x43323336, 0x362306af, 0x59171633, 0x012705a2, 0x35263435, 0x85013e34, 0x4814821c, 0x262405d4, 0x22272227, 0x23260a82,
    0x22070622, 0xfb410607, 0x032e2708, 0x0e070623, 0x76430701, 0x26232905, 0x011d2223, 0x2223010e, 0x23830882, 0x0e822720, 0x012b1422, 0x23054742,
    0x010f030e, 0x2705ed41, 0x1617011e, 0x032e2237, 0x8205a65e, 0x173d0884, 0x06141516, 0x35482901, 0x0302032a, 0x3a3b1c03, 0x37040606, 0x0c17174c,
    0x10060303, 0x37261e22, 0x060a1628, 0x082d080a, 0x060d0e02, 0xa2a8638e, 0x27443b4c, 0xcb6e3006, 0x4419a59a, 0x087f820e, 0x0c050272, 0x050c1f06,
    0x37291607, 0x0623124a, 0x04040809, 0x03050b09, 0x013e76c3, 0x07091503, 0x01030718, 0x19060402, 0x04090403, 0x04100508, 0x08050d01, 0x110a0e07,
    0x060a0708, 0x0205040f, 0x081d0a14, 0x2112261a, 0x1a0b2c33, 0x2a0e1729, 0x0f1f191a, 0x21161c0f, 0x313d5940, 0x4a08024b, 0x060a0104, 0x0b040750,
    0x01151721, 0x141e1b31, 0x02040a12, 0x052da982, 0x53290205, 0x3f3d3427, 0x6ed2603a, 0x08dd8254, 0x03110274, 0x08020807, 0x05160f19, 0x04060105,
    0x22412c03, 0x0d090107, 0x0e020508, 0x030d0108, 0x1a070b07, 0x07060207, 0x0514190d, 0x06030a04, 0x4708100f, 0x09092329, 0x0f04040c, 0x04261f12,
    0x13282119, 0x0217263e, 0x190a0501, 0x47313027, 0x53000200, 0xd3089400, 0x1601ec02, 0x00002c01, 0x35363225, 0x33343537, 0x17163237, 0x3733011e,
    0x36373225, 0xd05b013f, 0x23263305, 0x23141716, 0x0623022e, 0x15162723, 0x2e222314, 0x07852304, 0x09861283, 0x82012b21, 0x22072408, 0x84012e27,
    0x06714a09, 0x2f2b1c84, 0x07232601, 0x15011e27, 0x82060714, 0x032e2117, 0x2405b143, 0x34273526, 0x06c54123, 0x07140622, 0x0e272382, 0x2a230701,
    0x82012e02, 0x0622212d, 0x1e824b82, 0x0e243082, 0x26222301, 0x82058148, 0x06222123, 0x11820183, 0x22224482, 0x5183012f, 0x8206cf4d, 0x4233206b,
    0x3e270878, 0x16323301, 0x82011f33, 0x323321c6, 0x3223d083, 0x8334013d, 0x17322212, 0x06e46c33, 0x08823620, 0x1e211585, 0x2a2b8501, 0x16143736,
    0x14011f15, 0x833a0116, 0x1617283e, 0x26060706, 0x84012a23, 0x368e086d, 0x01950337, 0x860a0110, 0x0408130a, 0x01b30502, 0x9a20a695, 0x3451398b,
    0x2163809d, 0x01063813, 0x0606070c, 0x1f070504, 0x08080c0b, 0x10110308, 0x040e0b08, 0x0804050b, 0x09081a08, 0x0508080b, 0x0d09210a, 0x050a0309,
    0x09072209, 0x0608040b, 0x0b0a121b, 0x0108070d, 0x04261310, 0x03040908, 0x07030103, 0x01050905, 0x2c440404, 0x0f150204, 0x01020302, 0x5e050201,
    0x01030106, 0x01040601, 0x3e090604, 0x06060502, 0x0d060403, 0x1c821f23, 0x020a2508, 0x09094106, 0x06060103, 0x10130a0e, 0x05030b0d, 0x08100607,
    0x13232b22, 0x0a170d35, 0x02050304, 0x0903110b, 0x282a1e82, 0x19077018, 0x04030308, 0x47821040, 0x08020236, 0x07410704, 0x04020309, 0x09050e39,
    0x04030508, 0x1e1c0602, 0x03290982, 0x05020208, 0x163e0408, 0x2b238203, 0x03100101, 0x0e1a0d69, 0x03020806, 0x0d339e82, 0x070f0804, 0x05020c06,
    0x0494090c, 0x02227002, 0x82050701, 0x02023883, 0x1423530c, 0x12171b0d, 0x0b060405, 0x0b0e010b, 0x0d070101, 0x820f0d0a, 0x090e3fb3, 0x0c0d070a,
    0x090e0801, 0x0b01100e, 0x0801080c, 0x0c0c0315, 0x01150a09, 0x090e0a04, 0x22821110, 0x050c0526, 0x03030608, 0x08302682, 0x01010105, 0x080ab709,
    0x0a060ebf, 0x01020a06, 0x0331ee82, 0x010a0201, 0x06010605, 0x0c0b0b05, 0x0b010102, 0x38c48202, 0x0f010401, 0x11101825, 0x180c1515, 0x0601010e,
    0x0e010403, 0x0b02020c, 0x2e798203, 0x0c060104, 0x04080d01, 0x04040102, 0x82060403, 0x06280851, 0x01021403, 0x04027224, 0x06093501, 0x0206130b,
    0x0c040b01, 0x00000712, 0x00530002, 0x025308ea, 0x01050196, 0x77000015, 0x25062246, 0x013e3736, 0xbb441633, 0x32332205, 0x074f4d16, 0x1e173230,
    0x35323301, 0x14011d32, 0x16150607, 0x26823233, 0x33363724, 0x21820516, 0x37330123, 0x213d8332, 0x1d43013f, 0x26272105, 0x06240782, 0x2e272223,
    0x07871086, 0x0e251086, 0x07220701, 0x22258222, 0x420e1417, 0x3786055a, 0x23022e23, 0x05234316, 0x06210982, 0x20428307, 0x07584b26, 0x06072228,
    0x0e22012b, 0xa1482303, 0x27352305, 0x0a841422, 0x06821520, 0x2337352a, 0x14171522, 0x013d2207, 0x88055043, 0x84262019, 0x37352126, 0x14841e83,
    0x7c5b2482, 0x052c4707, 0xee500720, 0x16172105, 0x2008fd46, 0x08958215, 0x063707b6, 0x0a1807c7, 0x122d282c, 0x0d061517, 0x07132d06, 0x16200c06,
    0x0c2f0f18, 0x050e0d07, 0x3a191005, 0x1f240f0c, 0x29020101, 0x21340207, 0x050d0606, 0x01351003, 0x09192368, 0xa5290705, 0x072d19ab, 0x08dd9805,
    0x07080f0c, 0x0d03090b, 0x05040f08, 0x0b0e0509, 0x07090e0a, 0x030a130c, 0x03080805, 0x040e0401, 0x09070709, 0x02070606, 0x03060d0a, 0x110d0509,
    0x03030805, 0x07020208, 0x06090507, 0x0d150708, 0xa2526540, 0x08170910, 0x0e08090e, 0x1107070a, 0x06040502, 0x01080707, 0x01010202, 0x04030305,
    0x04030103, 0x02050301, 0x02010502, 0x04010504, 0x022a0d82, 0x03010206, 0x01060403, 0x09820107, 0x4f820220, 0x252c243c, 0x2416163f, 0x3c6f342e,
    0x14130e30, 0x0d1b2110, 0xf102053f, 0x050a0d07, 0x42821405, 0x07022908, 0x100502ea, 0x12050646, 0x05010517, 0x1a040804, 0x0c161412, 0x46201416,
    0x01290c06, 0x2d16110a, 0x170b0907, 0x0c1b361b, 0x60087582, 0x02110919, 0x020c0932, 0x051c9f05, 0x0c130f08, 0x0b0b0903, 0x02060914, 0x070f0908,
    0x060b011c, 0x0407190d, 0x02090801, 0x01010306, 0x12010e12, 0x18040602, 0x06010408, 0x0e0b0d0d, 0x05040803, 0x09090406, 0x08020c10, 0x1303222a,
    0x04080501, 0x03050509, 0x06090403, 0x02070901, 0x01030309, 0x23638204, 0x03020302, 0x01232982, 0x82070104, 0x82ce82bf, 0x070226e3, 0x300c0a03,
    0x085b821b, 0x2713202b, 0x131e0d0d, 0x10160866, 0x03060806, 0x06070212, 0x00070201, 0x54000100, 0x5308dc00, 0x8f00a502, 0x23370000, 0x3d262722,
    0x05f74801, 0x013e2408, 0x013f3637, 0x33011e32, 0x33363217, 0x16173732, 0x021e011f, 0x34353233, 0x15323327, 0x16012b14, 0x82013f33, 0x011f2221,
    0x051b4916, 0x82061942, 0x22232c06, 0x26022f07, 0x07232627, 0x61262223, 0xd8450535, 0x49222006, 0x2625076a, 0x0e22022f, 0x06d05d03, 0x0f223282,
    0x62610601, 0x20208205, 0x200c8206, 0x08c38263, 0x1d0207a8, 0x7d42872d, 0x78172c16, 0x0704091a, 0x0386030a, 0x07120d04, 0x86282a0e, 0x01081609,
    0x034f0201, 0x0d0b1701, 0x1160430d, 0x5c3b090a, 0x1035c237, 0x04015f47, 0x1e0e100d, 0x7c694853, 0x49161721, 0x20483a0e, 0x112a1940, 0x02020510,
    0x1d2f1f08, 0x0d040b0e, 0x3428141d, 0x03060810, 0x0b0b0c06, 0x16322021, 0x17191a0e, 0x0c0b0b1a, 0x100b0619, 0x0705081c, 0x08160505, 0x11150d19,
    0x40281f10, 0xdc0f0b0a, 0x25100d06, 0x4f624030, 0x09041728, 0x01060b02, 0x04050402, 0x02040101, 0x1201010a, 0x08040506, 0x0d821905, 0x4f085f82,
    0x14051e13, 0x03050903, 0x1b0e130c, 0x0f0c292f, 0x0a010201, 0x0110080b, 0x110c0509, 0x38260f0d, 0x0c0a1b24, 0x08030807, 0x04010503, 0x01070504,
    0x140a0a05, 0x0a0c0e1b, 0x0a0e1d0a, 0x094d3015, 0x00000d0a, 0x53000100, 0x53080901, 0x02017702, 0x322d0c82, 0x36273437, 0x34353637, 0x17011e37,
    0x063d4437, 0x16173226, 0x32373233, 0x37261782, 0x2737013e, 0x10492722, 0x06222205, 0x34028223, 0x07222326, 0x06272617, 0x07232623, 0x27262326,
    0x23171416, 0x820e8207, 0x17232825, 0x2e152227, 0x82072701, 0x27222316, 0x25821506, 0x27072223, 0x82128416, 0x82172016, 0x22152a3a, 0x23142326,
    0x23141727, 0x223a8222, 0x82152217, 0x27222145, 0x14241c82, 0x27070617, 0x06224785, 0x10820722, 0x35362329, 0x0f010e27, 0x82171401, 0x05734436,
    0x54822320, 0x80823782, 0x8c821f82, 0x06220725, 0x82070607, 0x28888251, 0x0e272207, 0x0e071402, 0x820b8201, 0x17162392, 0xc4821416, 0x3f21c285,
    0x059e5201, 0x094ad682, 0x37362205, 0x08ee8232, 0x06071446, 0xd6031415, 0x10010c18, 0x1204061b, 0x073a1120, 0x1c371b04, 0x907d3f3e, 0x133f5325,
    0x4b101d12, 0x04120734, 0x23655733, 0x04010911, 0x070c0a06, 0x0415160d, 0x011a1a06, 0x030b0402, 0x040b0504, 0x010d0708, 0xd8080082, 0x0807040b,
    0x01050410, 0x01030102, 0x06100701, 0x02040706, 0x0d040203, 0x08011906, 0x09130101, 0x0c06090d, 0x0e140204, 0x010a0509, 0x09150a05, 0x06020205,
    0x040a080e, 0x02040903, 0x0e0e0916, 0x04040406, 0x02020103, 0x31020408, 0x0b061807, 0x0c021c07, 0x16040303, 0x160b0c20, 0x0a111b16, 0x070d070a,
    0x743a0a0a, 0x331a193a, 0x14251723, 0x0a05200b, 0x0b0a0406, 0x080f1a14, 0x05010614, 0x07060308, 0x08060201, 0x0502310e, 0x030a090f, 0x240b1e0d,
    0x371b1212, 0x181c1c1b, 0x1a3d3d20, 0x1730231a, 0x1e18131b, 0x010a023d, 0x06070409, 0x08041720, 0x11041128, 0x030f0104, 0x1c020302, 0x030a0506,
    0x0e092b16, 0x0c23010b, 0x0501030b, 0x06060301, 0x04010302, 0x28ce8204, 0x06010305, 0x080b0402, 0x82ca8309, 0x020430e1, 0x07060204, 0x01040603,
    0x0209020b, 0x82080105, 0x040c3653, 0x05050803, 0x03090503, 0x0401020a, 0x04030101, 0x03040502, 0x23088205, 0x01010202, 0x1e2e1182, 0x130a0427,
    0x08071409, 0x020a0205, 0x00830203, 0x02010726, 0x01010905, 0x01200383, 0x16295182, 0x09040c18, 0x0e070106, 0x083b8207, 0x080d623f, 0x0a052204,
    0x02030b0b, 0x02060504, 0x02050505, 0x04091608, 0x08370706, 0x15190f06, 0x53000a00, 0x54080f01, 0xb1007102, 0xcb00bf00, 0xec00da00, 0x0901fc00,
    0x24011801, 0x00002b01, 0x07ba4253, 0x22056744, 0x4b323736, 0x373205e9, 0x16171632, 0x06070615, 0x32331415, 0x34353637, 0x07821627, 0x37023e29,
    0x3233013e, 0x4c360715, 0x3424061b, 0x1e053233, 0x67081366, 0x23250593, 0x022e2722, 0x05054c23, 0x27262729, 0x010e0722, 0x4c230607, 0x0882051e,
    0x27032e26, 0x2223012e, 0x4e065a44, 0x5a820542, 0x84057e42, 0x1e17215e, 0x16216383, 0x05c65217, 0x40832882, 0x82141521, 0x6a272090, 0x818205bb,
    0x37071424, 0x0d893706, 0x83250621, 0x8336200b, 0x222c8218, 0x87170637, 0x26c4821a, 0x010f0614, 0x87050637, 0x011e2211, 0x823c8815, 0x82162030,
    0x203d850d, 0x200d8437, 0x24588206, 0x26272217, 0x250d8435, 0x012d0614, 0x90821627, 0x0bda8108, 0x06050c05, 0x3020431e, 0x2f1f7532, 0x137a3b2b,
    0x1b442a16, 0x0d070f06, 0x070a0206, 0x0705020a, 0x0806170b, 0x170d0709, 0x0501010a, 0x010b080a, 0x06110a08, 0x022b0603, 0x3a011e03, 0x13183017,
    0x4c293e13, 0x1c0e1920, 0x67201b0d, 0x06615416, 0x37020a0b, 0x11623917, 0x0d1a8f33, 0x0e070305, 0x090a091b, 0x18120507, 0x1a143407, 0x20252719,
    0x19301913, 0x7a3482b1, 0x1137273a, 0x2e0c0b12, 0x4f087e82, 0x3b86322b, 0x3a1b371b, 0x6a283e71, 0x040a1624, 0x29180309, 0x33427b17, 0x2570b740,
    0x1b222d4b, 0x07281a04, 0x03040c0c, 0x06010611, 0x0a0c0741, 0x0c120405, 0x0d07fd01, 0x0311060f, 0x07020103, 0x090d0742, 0x040c0605, 0x01020402,
    0xf0fd0601, 0x05200e83, 0x0729be82, 0x07340601, 0x06070d0e, 0x20c9820e, 0x8238840d, 0x064208c0, 0x0a3d0c03, 0x0c030305, 0x030c1106, 0x0e8afe4d,
    0x131ec584, 0x08120f01, 0x19130503, 0x210e130d, 0x06040201, 0x06080303, 0x030f0104, 0x0a2d1112, 0x0b050202, 0x0d0f2217, 0x100c0707, 0x0803010b,
    0x02820509, 0x29070635, 0x03030404, 0x0f250202, 0x1120111d, 0x38080604, 0x82070604, 0x1607219a, 0x082c1782, 0x0802070a, 0x07111907, 0x0f0b0101,
    0x42083f82, 0x13280a1a, 0x160a2016, 0x0f02020e, 0x171f0433, 0x0d060d3c, 0x060f0804, 0x13120302, 0x03170203, 0x3016080d, 0x151e2110, 0x051f0607,
    0x0511931d, 0x11020409, 0x07020c03, 0x08061019, 0x07100206, 0x82107c0f, 0x0211235c, 0xee820608, 0x060f0426, 0x0c040607, 0x07217c82, 0x20ef8205,
    0x320e83cd, 0x040a0303, 0x06020c04, 0x06060d19, 0x05070c0c, 0x82520607, 0x02052231, 0x2109820c, 0x4f820802, 0x12053d08, 0x0b06070c, 0x05080a3a,
    0x00010103, 0x00080000, 0x088f0054, 0x00f10254, 0x0063004e, 0x00870074, 0x01f100dc, 0x00140100, 0x37327700, 0x35363736, 0x35262734, 0x16323334,
    0x17031e17, 0x0a7a6a18, 0x26373629, 0x2617012f, 0x47262225, 0x2321094b, 0x05fa6422, 0x33823720, 0x17822720, 0xa0820720, 0x17141528, 0x16011f16,
    0x46832213, 0x35013e26, 0x33363707, 0x21057456, 0xc5420302, 0x011e2308, 0x2b821417, 0x24842720, 0x17282083, 0x07141516, 0x06071437, 0x8205f256,
    0x82158481, 0x20828227, 0x07a5513e, 0x27012e22, 0x03200286, 0x83053c58, 0x05204670, 0x37343522, 0x35202683, 0x5c828986, 0x3a6b0720, 0x8a172005,
    0x013e218a, 0x6a83d783, 0x89030621, 0x8289857a, 0x82438258, 0x088a88ab, 0x100bc93a, 0x05060a1e, 0x1c104916, 0x031c090e, 0x04040701, 0x0c040d05,
    0x27653612, 0x13b09e28, 0x96131323, 0x040ba2fe, 0x13030710, 0x0f010506, 0x1c272316, 0x0116092f, 0x1a1d0e05, 0x9808c782, 0x06252f0e, 0x17261a03,
    0x1c20061d, 0x0509080f, 0x130b0d0e, 0x06040b0e, 0x04250c0c, 0x050c092f, 0x0f030401, 0x1d3f0805, 0x080d0304, 0x4d2c070d, 0x0c421132, 0x38135c04,
    0x0d311506, 0x1b22240b, 0x04030801, 0x03070803, 0x7ef35204, 0x0a06543e, 0x375f2f05, 0x211c371c, 0x1d464242, 0x05050808, 0x02060403, 0x0e0d400b,
    0x0f0b152e, 0x03060704, 0x200e1002, 0x040c0b13, 0x05030946, 0x0c2b2303, 0x0d2c081b, 0x0909080e, 0x130b090e, 0x030d0509, 0x08190f11, 0x0e091023,
    0x2575830a, 0x02021010, 0x7687070e, 0x118fc208, 0x0d0b101e, 0x2b230806, 0x090c0c4d, 0x0b261b1d, 0x08032608, 0x050d0301, 0x10641004, 0x640d0d15,
    0x22070607, 0x24185409, 0x131a1f24, 0x07092d12, 0x14181b09, 0x485b0e05, 0x223b5355, 0x012e4a2f, 0x0c0c12be, 0x020f1806, 0x0f240913, 0x2a080c0c,
    0x73fe0515, 0x0304053e, 0x0f091b1f, 0x040b0717, 0x2e3f8c08, 0x0a0f4d0e, 0x060e3f27, 0x38041131, 0x173dbc0b, 0x27240b08, 0x24030e3b, 0x0e1d261d,
    0x0d090c0e, 0x19321106, 0x0409042d, 0x060c2f1c, 0x0803030c, 0x030c0104, 0x0c090d18, 0x061b5610, 0x221a1221, 0x0b10091d, 0x03040406, 0x16240d1d,
    0x234b7705, 0x2a353321, 0x01164d49, 0x0b0519bc, 0x327b8307, 0x070f1d10, 0x300e0c04, 0x3173fe0f, 0x1607060b, 0x83064b0a, 0x2e282579, 0x114b0f16,
    0x09217a83, 0x087a832e, 0x0500002e, 0x5b017000, 0x57029b08, 0x13010900, 0x28011c01, 0x00003001, 0x35262101, 0x32213334, 0x37051415, 0x21173335,
    0x2721012d, 0x34270721, 0x2a05d742, 0x22233415, 0x26341506, 0x6e072223, 0x09820595, 0x15200f85, 0x1f832184, 0x10820720, 0x8a222321, 0x2033880f,
    0x822d8415, 0x85088304, 0x832c8620, 0x20408413, 0x2a2c8e07, 0x1f15010f, 0x33161401, 0x89353632, 0x14372105, 0x35200f87, 0x04821984, 0x1d863720,
    0x0b831720, 0x25892b85, 0x4f882f93, 0x0c883183, 0x4e845787, 0x172d3685, 0x22371715, 0x32333435, 0x33141516, 0x20098223, 0x05865437, 0x14843320,
    0x14153e08, 0xf3fd4606, 0x0b020e0e, 0x0316fd10, 0xa2030e31, 0x06fe4d01, 0xfe4367fe, 0x050643d7, 0x04060603, 0x08060e05, 0x030c0509, 0x08060608,
    0x08060c03, 0x050e0608, 0x0f0e0604, 0x0e050306, 0x2621820e, 0x030c0e0f, 0x8209050e, 0x241d8316, 0x020d0c03, 0x8420830d, 0x0c02221e, 0x8221820f,
    0x2042831f, 0x221f830e, 0x82424c06, 0x83062041, 0x8d328203, 0x840b2039, 0x03052263, 0x253b8207, 0x030c0608, 0x2285060d, 0x40823c88, 0x09050325,
    0x83080605, 0x20428423, 0x8349830e, 0x2b63849b, 0x0f5b0704, 0xc409050f, 0x970d0d97, 0x1c254382, 0x010e0e0e, 0x2d8e82f8, 0x049f0d0e, 0x2ea02630,
    0x05062220, 0x91820504, 0x05090e24, 0xb4820905, 0x85050921, 0x83ac8409, 0x840e2017, 0x850e2009, 0x82058215, 0x84128341, 0x850e201a, 0x823a841c,
    0x2f0b261a, 0x05153139, 0x870e8309, 0x84538212, 0x82158433, 0x20028268, 0x864b8909, 0x8381831d, 0x82042035, 0x852883c9, 0x081c856b, 0x0c14072c,
    0x090f0ed1, 0x0c0e0e06, 0x06040503, 0x0f0f0e0e, 0x0500000e, 0x13017300, 0x73029a08, 0x13000b00, 0x2b001f00, 0x0000c500, 0xd05a2213, 0x15162405,
    0x41270614, 0x052006ca, 0x2520138a, 0x37221e82, 0x1e821704, 0x05060730, 0x33363734, 0x35371732, 0x34173334, 0x03821633, 0x36173224, 0x07843237,
    0x19823520, 0x84011e21, 0x8234200a, 0x15162323, 0x0682013e, 0x03823620, 0x32331624, 0x7050013f, 0x22052307, 0x4b820727, 0x06822320, 0x83061721,
    0x83142005, 0x20098304, 0x25048223, 0x2306012f, 0x2c822f26, 0x0623262b, 0x06150607, 0x031f1415, 0xdf601832, 0x2152850b, 0x5782011f, 0x172e0489,
    0x13130de8, 0x12120e0d, 0x0c0c0c68, 0x0c830003, 0x130d8808, 0x1a610112, 0x0685011a, 0xfe060404, 0x13080305, 0x10071715, 0x0304070c, 0x04030507,
    0x07070a09, 0x04020306, 0x01020504, 0x08090a0b, 0x01020304, 0x04080403, 0x0a070a06, 0xafbd5457, 0x23dadac2, 0x7a281c05, 0x112646fe, 0x050a0219,
    0x01010b06, 0x0b080408, 0x0d0a0309, 0x07060804, 0x0507040e, 0x09020f06, 0x282a0607, 0xc934224e, 0x164055b1, 0x150a1205, 0x414f8c75, 0x15300640,
    0x3d2f080b, 0x0746352b, 0x82010805, 0x02082d72, 0x0905070a, 0x05060b01, 0x83010207, 0x1326a882, 0x130d0e13, 0x00820d50, 0x0d872720, 0x19032b38,
    0x040c0319, 0x05050605, 0x0c0ad304, 0x0204211d, 0x010b030f, 0x38820903, 0x82070721, 0x01053ab6, 0x06090701, 0x01020105, 0x0a060905, 0x23c1410d,
    0x140b2306, 0x0c220a45, 0x08568205, 0x0a060646, 0x07100304, 0x09090b03, 0x010b010a, 0x0312030c, 0x13290201, 0x222c080f, 0x011b4c29, 0x01112621,
    0x1413070f, 0x030e041d, 0x05040f05, 0x10060410, 0x02000000, 0x0b014300, 0x85029208, 0xd9000900, 0x22130000, 0x2806dd43, 0x37360506, 0x36333736,
    0x05d94133, 0x03970783, 0x32333424, 0x03853615, 0x07821720, 0x04831620, 0x37051726, 0x25262726, 0x23210382, 0x06eb4122, 0x07860620, 0x23140725,
    0x84063522, 0x14232205, 0x200b8206, 0x83228226, 0x82128613, 0x84222011, 0x2b04880a, 0x06070627, 0x17072315, 0x14150633, 0x2106ba4b, 0xa783012e,
    0x013e1725, 0x42342737, 0x3222068d, 0x0c843215, 0x33361522, 0x15201282, 0xb85d0484, 0x3b348306, 0x09141482, 0x9e030c0c, 0x01060b13, 0x040b075b,
    0x05040a04, 0x0a0e0d0a, 0x05050405, 0x12210384, 0x82088612, 0x0d122706, 0x05090a0a, 0x20840905, 0x82030521, 0x05800811, 0x78010509, 0xa8cdbae8,
    0x0501ecfd, 0x1011160a, 0x02040b05, 0x0c020a07, 0x0b110407, 0x0b0a090c, 0x0408120c, 0x3e88a60b, 0x0f0c0b6e, 0x0b0e0c0b, 0x0c050c0c, 0x0b0c0e0b,
    0x03090b0f, 0x0a0d0623, 0x020f2929, 0x170b1e2a, 0x010b1814, 0x02030803, 0x01030802, 0x0d020608, 0x06090808, 0x07080901, 0x13080809, 0x7d2f0908,
    0x253c4276, 0x120f2244, 0x13c6010b, 0x07090c15, 0x1f02bb0c, 0x02110c13, 0x03928383, 0x03030430, 0x29b2040c, 0x1004090d, 0x051b2510, 0x54830b05,
    0x070b0439, 0x020b0e04, 0x040b0c01, 0x060c0d07, 0x0c010a0b, 0x020b0d0a, 0x82010a0c, 0x0d220805, 0x0603050a, 0x032f3611, 0x26340a03, 0x0114170c,
    0x02090303, 0x03020402, 0x03040508, 0x01020607, 0x8f820708, 0x0208083e, 0x0d1a0405, 0x0000111a, 0x93000100, 0x78082601, 0x4400bb02, 0x36130000,
    0x33213637, 0x090c8618, 0xca611520, 0x36372a05, 0x23062537, 0x23152722, 0x2d038335, 0x012e2223, 0x36373435, 0x22232635, 0x01832707, 0x82010f21,
    0x0c86081a, 0x15060701, 0x86b73314, 0x39016580, 0xacbc0844, 0x070c0612, 0x7be6570c, 0x6a141439, 0xfe214e40, 0x45786b97, 0x054c054a, 0x040e0703,
    0x0e010712, 0x1b092115, 0x19071c08, 0x60fe07f4, 0x163eebfe, 0x5e26011e, 0x04052228, 0x2e182504, 0x02090804, 0x0e02213a, 0x9219291f, 0x0e100715,
    0x09130e09, 0x0910040a, 0x1a060604, 0x11061006, 0x06060f06, 0x557d1506, 0x00201c34, 0x85000200, 0x4b080701, 0x6000a102, 0xd2826500, 0xb0823220,
    0x2007d042, 0x069b4d16, 0x2005d750, 0x089c4426, 0x22231425, 0x87170735, 0x06272205, 0x06d75023, 0x4205cc59, 0x3b8405e7, 0x4e0a455a, 0x3721055b,
    0x05324516, 0x0f4fb608, 0x0a05091a, 0x360a080c, 0x656d2e24, 0x60486451, 0x432b3e7d, 0xdb92c160, 0x0f61362b, 0x04070b01, 0x0c0b0a0c, 0x0d0b0b01,
    0x190a1301, 0x7786171a, 0x25263032, 0x2335b9c2, 0x6345190c, 0x07072b2e, 0x4b2c0909, 0x06073543, 0x2a180406, 0x333a1d19, 0x0c061326, 0x74fc0c05,
    0x0701190f, 0x130a1b47, 0x06060506, 0x22430d09, 0x2915131e, 0x06050809, 0x02010422, 0x0d02070a, 0x0a030108, 0x0b020209, 0x1b010515, 0x18650405,
    0x52231b22, 0x04124504, 0x052b2a08, 0x090e2305, 0x0e231920, 0x0dbc4801, 0x000c0e0b, 0x01500002, 0x027a0851, 0x000a0050, 0x01000037, 0x06dc6122,
    0x07061429, 0x35263732, 0x82333734, 0x37202701, 0x27232124, 0xcf432623, 0x82072005, 0x0f7d0807, 0x06272201, 0x36171415, 0x3316013b, 0x05163732,
    0x080a1200, 0xb50b0b08, 0x0712100d, 0x06730a3a, 0xfebb9d02, 0x2297fdba, 0x2810360a, 0x0a0c0908, 0xe1dca5a2, 0x20464b1d, 0x1151491f, 0xbac2c1c9,
    0x139e0112, 0x070b0b07, 0x094d0b08, 0x07080f14, 0x462c0605, 0x11023a0d, 0x050b0c0e, 0x2e160109, 0x1a302e2f, 0x00370707, 0x00be0005, 0x031f088a,
    0x000b001a, 0x00230017, 0x006a002f, 0x070d4f00, 0x14151624, 0xbf460106, 0x0bcb460c, 0x01220b89, 0x68543f32, 0x36200806, 0x36173233, 0x32373637,
    0x32171617, 0x0104023f, 0x27152502, 0x27072715, 0x2f222307, 0x14011f02, 0x06220982, 0x2e4c010f, 0x01162606, 0x3f3f2c52, 0x3503822c, 0x0d0a9704,
    0x0d090a0d, 0x100b510d, 0x0f0b0b10, 0x130e5b0f, 0x03820e13, 0xc9fb4408, 0x1c092b3e, 0x0703060a, 0x117e4b0c, 0x5e2f2010, 0x121e3649, 0x304b4d15,
    0x01820107, 0x3afe316b, 0x30042d31, 0x05050305, 0x01174615, 0x732e4107, 0xd0fa5184, 0x58345473, 0x2c2d3eb3, 0x2d2c3e3e, 0x84b2013e, 0x09092359,
    0x5a84130e, 0x100b0b23, 0x825b840d, 0xfe41085f, 0x1c092c05, 0x130a1e3a, 0x1a023909, 0x1901331a, 0x0651280e, 0xbdfe0b09, 0x1cae7301, 0x1f2d1e2e,
    0x2005202d, 0x07071d09, 0x441a3004, 0x6e0e050f, 0x3d385a3d, 0x0000583e, 0x017b0007, 0x020c0926, 0x083741b4, 0x69003724, 0xef477600, 0x0b47410d,
    0x47413720, 0x370b8d0a, 0x32333435, 0x36051415, 0x33361733, 0x25203316, 0x07222124, 0x23062722, 0x07200382, 0x08535418, 0x1d200983, 0x47059d55,
    0x272007af, 0x072f5189, 0x160fce06, 0x15100f16, 0x0d1e0415, 0x820d1212, 0x0a4c2403, 0x820a0d0d, 0x4a4d0803, 0x080b0b08, 0x420b0b07, 0xfe0e0e0e,
    0x102e2a45, 0x474b260d, 0x44015602, 0xa9fdbcfe, 0x0d264b46, 0x292d0909, 0x41422014, 0x5e2f2018, 0x3a3541b3, 0x06224584, 0x31796873, 0x1e2f62c3,
    0x20424116, 0x46463106, 0x22453131, 0x15c60125, 0x2b658510, 0x0c0d1207, 0x0d0c1212, 0x090e0912, 0x0a256282, 0x0b010e09, 0x08678308, 0x050b0828,
    0x0e0f0f0e, 0x0f012cb6, 0x02908f02, 0x142c020f, 0x03082b16, 0x1509140a, 0x02181b34, 0x14262a33, 0x2b08030a, 0x51823716, 0x23225583, 0x00820023,
    0xcd000232, 0x95083b00, 0x7b006303, 0x00008c00, 0x26273725, 0x37360182, 0x35262327, 0x15333734, 0x21353721, 0x27263736, 0x35333521, 0x02822327,
    0x82150721, 0x21263414, 0x07273727, 0x06072227, 0x2723010f, 0x07060723, 0x84012f23, 0x0706220d, 0x0690421f, 0x17023f2e, 0x37331707, 0x011f3727,
    0x16013b16, 0x32056449, 0x3617020f, 0x3736053f, 0x3f363317, 0x33073302, 0x82373237, 0x23252619, 0x37352726, 0x09098233, 0x27011f12, 0x07173337,
    0x37538804, 0x030d3268, 0x1108020d, 0x24021603, 0x055a0207, 0xfd060306, 0x0a0807a2, 0x0705130f, 0xfe0907fe, 0x2f0a0a5c, 0x0c0d0409, 0x27010406,
    0x10095507, 0x2c221e04, 0x01020608, 0x0701080a, 0x09071211, 0x0a020d10, 0x1601090f, 0x0e072208, 0x060e0502, 0x0804540c, 0x11201021, 0x0984061b,
    0x0713060b, 0x05070711, 0x030c7a1a, 0x07200827, 0x071e0907, 0xfe324215, 0x090f70e5, 0x03011614, 0x08090a03, 0x17085a0b, 0x994d3f3b, 0x060c2183,
    0x05033708, 0x12091802, 0x1f1f2b15, 0x1b0b260c, 0x0b36052b, 0x14121101, 0x04031016, 0x06041f0c, 0x04081f27, 0x45931805, 0x080a0b32, 0x4d4d0802,
    0x04141909, 0x0c0f2c0a, 0x41010830, 0x10040710, 0x2a1e1d1b, 0x491a4422, 0x25231007, 0x0b1e1d22, 0x09010804, 0x2f2c074e, 0x638d3302, 0x140903cc,
    0x0e151432, 0x1a30040f, 0x00004207, 0x4e000600, 0x01000300, 0x01000904, 0x0e001200, 0x02200b86, 0x00200982, 0x03220b86, 0x17882c00, 0x238a0420,
    0x72000524, 0x23863a00, 0x17840620, 0x6500522a, 0x75006700, 0x61006c00, 0x712a1b82, 0x30006f00, 0x69005f00, 0x09826300, 0x73006e22, 0x56202d82,
    0x72202182, 0x69200982, 0x20241184, 0x2e003100, 0x30210382, 0x22179700, 0x824a003b, 0x826e204f, 0x202b8335, 0x22898230, 0x82320020, 0x22038355,
    0x8446003b, 0x00742245, 0x206d8243, 0x20738265, 0x210f8274, 0x29830072, 0x57823320, 0x03863020, 0x36003222, 0x32206382, 0x36261782, 0x2d003400,
    0x91826200, 0xf9827420, 0x87000221, 0x87012000, 0x08078c08, 0x01004ee5, 0x03010201, 0x05010401, 0x07010601, 0x09010801, 0x0b010a01, 0x0d010c01,
    0x0f010e01, 0x11011001, 0x13011201, 0x15011401, 0x17011601, 0x19011801, 0x1b011a01, 0x1d011c01, 0x1f011e01, 0x21012001, 0x23012201, 0x25012401,
    0x27012601, 0x29012801, 0x2b012a01, 0x2d012c01, 0x2f012e01, 0x31013001, 0x33013201, 0x35013401, 0x37013601, 0x39013801, 0x3b013a01, 0x3d013c01,
    0x3f013e01, 0x41014001, 0x43014201, 0x45014401, 0x47014601, 0x49014801, 0x4b014a01, 0x4d014c01, 0x6e044e01, 0x06656e6f, 0x67616564, 0x6505656c,
    0x6574696c, 0x76696609, 0x76657365, 0x67056e65, 0x6b636f6c, 0x346b6104, 0x75610337, 0x77610367, 0x61660570, 0x0573616d, 0x67733367, 0x61670731,
    0x616c696c, 0x346d0472, 0x83053161, 0x73490804, 0x63616d05, 0x68073031, 0x3032706b, 0x75053030, 0x3534706d, 0x316d7806, 0x05343130, 0x6f7a6962,
    0x616d046e, 0x6e053767, 0x76656765, 0x77617308, 0x666f6465, 0x65740466, 0x74053963, 0x72657361, 0x35327004, 0x706d0330, 0x20038237, 0x089a8239,
    0x03617658, 0x06303970, 0x72616373, 0x73053032, 0x36353567, 0x67737305, 0x6b083830, 0x6566696e, 0x0974635f, 0x73616c66, 0x6e616268, 0x65680967,
    0x6e657267, 0x05656461, 0x6b6f6d73, 0x6f6d0765, 0x6f746f6c, 0x65640576, 0x0a796f63, 0x65636e69, 0x6169646e, 0x740a7972, 0x29866761, 0x3463022e,
    0x6165680a, 0x7368746c, 0x07746f68, 0x52085485, 0x326d0474, 0x75043934, 0x05737073, 0x35377a63, 0x65720861, 0x766c6f76, 0x66057265, 0x73747369,
    0x62617406, 0x0574656c, 0x656c656d, 0x78610365, 0x61680665, 0x72656d6d, 0x61707307, 0x72656e6e, 0x76656b06, 0x0672616c, 0x6d6c6568, 0x6b037465,
    0x82067469, 0x2b18839f, 0x67726174, 0x62077465, 0x6e6f7961, 0x63200782, 0x7338ba82, 0x66046369, 0x0370696c, 0x08747567, 0x6172616b, 0x7469626d,
    0x5f396d0a, 0x23082486, 0x63617408, 0x61636974, 0x6166086c, 0x6968636c, 0x62056e6f, 0x6569776f, 0x74756209, 0x66726574, 0x6407796c, 0x3608ce82,
    0x04737265, 0x64726f63, 0x6e616305, 0x75057369, 0x73757372, 0x76616e06, 0x07616a61, 0x6474756f, 0x08726f6f, 0x6c697473, 0x6f747465, 0x6e69770b,
    0x6d776f64, 0x82656b61, 0x826b2014, 0x827420c5, 0x706d2c55, 0x00647335, 0xff010001, 0x050f00ff, 0xe9ba49fa, 0x00000040,
};
```

`hack/render/render.cpp`:

```cpp
#include "render.hpp"

#include <utilities/math/math.hpp>
#include <utilities/console/console.hpp>
#include <utilities/tools/tools.hpp>

#include <SDK/interfaces/interfaces.hpp>
#include <SDK/ISurface.hpp>
#include <SDk/math/matrix.hpp>
#include <utilities/res.hpp>

#include <ranges>

#define BUFFER_SIZE 256

enum FontFlags
{
	FONTFLAG_NONE,
	FONTFLAG_ITALIC = 0x001,
	FONTFLAG_UNDERLINE = 0x002,
	FONTFLAG_STRIKEOUT = 0x004,
	FONTFLAG_SYMBOL = 0x008,
	FONTFLAG_ANTIALIAS = 0x010,
	FONTFLAG_GAUSSIANBLUR = 0x020,
	FONTFLAG_ROTARY = 0x040,
	FONTFLAG_DROPSHADOW = 0x080,
	FONTFLAG_ADDITIVE = 0x100,
	FONTFLAG_OUTLINE = 0x200,
	FONTFLAG_CUSTOM = 0x400,
	FONTFLAG_BITMAP = 0x800,
};

unsigned long SurfaceRender::__createFont(const char* fontName, const int size, const int weight, const unsigned long flags)
{
	auto result = memory::interfaces::surface->fontCreate();
	memory::interfaces::surface->setFontGlyph(result, fontName, size, weight, 0, 0, flags);
	return result;
}

void SurfaceRender::init()
{
	fonts::tahoma = __createFont(XOR("Tahoma"), 14, 800, FONTFLAG_OUTLINE);
	fonts::franklinGothic = __createFont(XOR("Franklin Gothic"), 10, 300, FONTFLAG_ANTIALIAS | FONTFLAG_DROPSHADOW);
	fonts::verdana = __createFont(XOR("Verdana"), 12, 350, FONTFLAG_ANTIALIAS | FONTFLAG_DROPSHADOW);

	LOG_INFO(XOR("render init success"));
}

void SurfaceRender::drawLine(const int x, const int y, const int x2, const int y2, const Color& color)
{
	memory::interfaces::surface->drawSetColor(color);
	memory::interfaces::surface->drawLine(x, y, x2, y2);
}

void SurfaceRender::drawLine(const Vec2& start, const Vec2& end, const Color& color)
{
	drawLine(static_cast<int>(start[Coord::X]), static_cast<int>(start[Coord::Y]),
		static_cast<int>(end[Coord::X]), static_cast<int>(end[Coord::Y]), color);
}

void SurfaceRender::drawRect(const int x, const int y, const int w, const int h, const Color& color)
{
	memory::interfaces::surface->drawSetColor(color);
	memory::interfaces::surface->drawOutlinedRect(x, y, w, h);
}

void SurfaceRender::drawRect(const Vec2& start, const Vec2& end, const Color& color)
{
	drawRect(static_cast<int>(start[Coord::X]), static_cast<int>(start[Coord::Y]),
		static_cast<int>(end[Coord::X]), static_cast<int>(end[Coord::Y]), color);
}

void SurfaceRender::drawRectFilled(const int x, const int y, const int w, const int h, const Color& color)
{
	memory::interfaces::surface->drawSetColor(color);
	memory::interfaces::surface->drawFilledRectangle(x, y, w, h);
}

void SurfaceRender::drawRoundedRect(const int x, const int y, const int w, const int h, const int radius, const int numberOfVertices, const Color& color)
{
	if (numberOfVertices < 2)
		return;

	auto roundV = std::make_unique<Vertex_t[]>(4 * numberOfVertices);

	for (int i = 0; i < 4; i++)
	{
		int _x = x + ((i < 2) ? (w - radius) : radius);
		int _y = y + ((i % 3) ? (h - radius) : radius);

		for (int j = 0; j < numberOfVertices; j++)
		{
			float rad = math::DEG2RAD((90.f * i) + (j / static_cast<float>(numberOfVertices - 1)) * 90.f);

			roundV[(i * numberOfVertices) + j] = Vertex_t{ Vec2{_x + radius * std::sin(rad), _y - radius * std::cos(rad)} };
		}
	}

	drawPolyLine(4 * numberOfVertices, roundV.get(), color);
}

void SurfaceRender::drawRoundedRectFilled(const int x, const int y, const int w, const int h, const int radius, const int numberOfVertices, const Color& color)
{
	if (numberOfVertices < 2)
		return;

	auto roundV = std::make_unique<Vertex_t[]>(4 * numberOfVertices);

	for (int i = 0; i < 4; i++)
	{
		int _x = x + ((i < 2) ? (w - radius) : radius);
		int _y = y + ((i % 3) ? (h - radius) : radius);

		for (int j = 0; j < numberOfVertices; j++)
		{
			float rad = math::DEG2RAD((90.f * i) + (j / static_cast<float>(numberOfVertices - 1)) * 90.f);

			roundV[(i * numberOfVertices) + j] = Vertex_t{ Vec2{_x + radius * std::sin(rad), _y - radius * std::cos(rad)} };
		}
	}

	drawPolyGon(4 * numberOfVertices, roundV.get(), color);
}

void SurfaceRender::drawCircle(const int x, const int y, const int radius, const int points, const Color& color)
{
	memory::interfaces::surface->drawSetColor(color);
	memory::interfaces::surface->drawOutlinedCircle(x, y, radius, points);
}

void SurfaceRender::drawCircleFilled(const int x, const int y, const int radius, const int points, const Color& color)
{
	std::vector<Vertex_t> verts = {};

	float step = math::PI_2 / points;
	for (float angle = 0.0f; angle < math::PI_2; angle += step)
	{
		verts.emplace_back(Vec2{ x + (radius * std::cos(angle)), y + (radius * std::sin(angle)) });
	}

	drawPolyGon(verts.size(), verts.data(), color);
}

void SurfaceRender::drawCircle3D(const Vec3& pos, const int radius, const int points, const Color& color)
{
	float step = math::PI_2 / points;
	for (float angle = 0.0f; angle < math::PI_2; angle += step)
	{
		Vec3 worldStart = Vec3{ radius * std::cos(angle) + pos[Coord::X], radius * std::sin(angle) + pos[Coord::Y], pos[Coord::Z] };
		Vec3 worldEnd = Vec3{ radius * std::cos(angle + step) + pos[Coord::X], radius * std::sin(angle + step) + pos[Coord::Y], pos[Coord::Z] };

		if (Vec2 start, end; worldToScreen(worldStart, start) && worldToScreen(worldEnd, end))
			drawLine(start, end, color);
	}
}

void SurfaceRender::drawFilledCircle3D(const Vec3& pos, const int radius, const int points, const Color& color)
{
	Vec2 orignalW2S = {};
	if (!worldToScreen(pos, orignalW2S))
		return;

	float step = math::PI_2 / points;
	for (float angle = 0.0f; angle < math::PI_2; angle += step)
	{
		Vec3 worldStart = Vec3{ radius * std::cos(angle) + pos[Coord::X], radius * std::sin(angle) + pos[Coord::Y], pos[Coord::Z] };
		Vec3 worldEnd = Vec3{ radius * std::cos(angle + step) + pos[Coord::X], radius * std::sin(angle + step) + pos[Coord::Y], pos[Coord::Z] };

		if (Vec2 start, end; worldToScreen(worldStart, start) && worldToScreen(worldEnd, end))
		{
			drawLine(start, end, color);
			drawTriangle(orignalW2S, start, end, Color(color.r(), color.g(), color.b(), color.a() / 4.0f));
		}
	}
}

void SurfaceRender::drawTriangle(const Vec2& p1, const Vec2& p2, const Vec2& p3, const Color& color)
{
	std::array verts =
	{
		Vertex_t{ p1 },
		Vertex_t{ p2 },
		Vertex_t{ p3 }
	};

	drawPolyLine(verts.size(), verts.data(), color);
}

void SurfaceRender::drawTriangleFilled(const Vec2& p1, const Vec2& p2, const Vec2& p3, const Color& color)
{
	std::array verts =
	{
		Vertex_t{ p1 },
		Vertex_t{ p2 },
		Vertex_t{ p3 }
	};

	drawPolyGon(verts.size(), verts.data(), color);
}

void SurfaceRender::drawQuadFilled(const Vec2& p1, const Vec2& p2, const Vec2& p3, const Vec2& p4, const Color& color)
{
	std::array verts =
	{
		Vertex_t{ p1 },
		Vertex_t{ p2 },
		Vertex_t{ p3 },
		Vertex_t{ p4 }
	};

	drawPolyGon(verts.size(), verts.data(), color);
}

void SurfaceRender::drawQuad(const Vec2& p1, const Vec2& p2, const Vec2& p3, const Vec2& p4, const Color& color)
{
	std::array verts =
	{
		Vertex_t{ p1 },
		Vertex_t{ p2 },
		Vertex_t{ p3 },
		Vertex_t{ p4 }
	};

	drawPolyLine(verts.size(), verts.data(), color);
}

void SurfaceRender::drawPolyLine(int* x, int* y, const int count, const Color& color)
{
	memory::interfaces::surface->drawSetColor(color);
	memory::interfaces::surface->drawPolyLine(x, y, count);
}

void SurfaceRender::drawPolyLine(const int count, Vertex_t* verts, const Color& color)
{
	auto x = std::make_unique<int[]>(count);
	auto y = std::make_unique<int[]>(count);

	for (auto i : std::views::iota(0, count))
	{
		x[i] = static_cast<int>(verts[i].m_Position[Coord::X]);
		y[i] = static_cast<int>(verts[i].m_Position[Coord::Y]);
	}

	drawPolyLine(x.get(), y.get(), count, color);
}

void SurfaceRender::drawPolyGon(const int count, Vertex_t* verts, const Color& color, const bool clipped)
{
	memory::interfaces::surface->drawSetColor(color);
	memory::interfaces::surface->drawTexturedPolygon(count, verts, clipped);
}

// https://www.unknowncheats.me/forum/counterstrike-global-offensive/189418-medical-attention-gradients-surface.html got fixed gradient blend from there
void SurfaceRender::drawGradient(const int x, const int y, const int w, const int h, const Color& first, const Color& second, bool horizontal, bool blend)
{
	auto gradient = [=](const Color& clr, bool reversed)
	{
		memory::interfaces::surface->drawSetColor(clr);
		memory::interfaces::surface->drawFilledFadeRect(
			x, y, w, h,
			reversed ? clr.aMultiplied() : 0,
			reversed ? 0 : clr.aMultiplied(),
			horizontal ? true : false);
	};

	auto blendColor = [](const Color& first, const Color& second, float t)
	{
		return Color(
			first.r() + t * (second.r() - first.r()),
			first.g() + t * (second.g() - first.g()),
			first.b() + t * (second.b() - first.b()),
			first.a() + t * (second.a() - first.a()));
	};

	if (blend)
		drawRectFilled(x, y, w, h, blendColor(first, second, 0.5f));
	gradient(first, true);
	gradient(second, false);
}

void SurfaceRender::drawGradient(const int x, const int y, const int w, const int h, const Color& first, const Color& second, const Color& third, bool horizontal, bool blend)
{
	auto gradient = [=](const Color& clr, bool reversed)
	{
		memory::interfaces::surface->drawSetColor(clr);
		memory::interfaces::surface->drawFilledFadeRect(
			x, y, w, h,
			reversed ? clr.aMultiplied() : 0,
			reversed ? 0 : clr.aMultiplied(),
			horizontal ? true : false);
	};

	auto blendColor = [](const Color& first, const Color& second, const Color& third, float t)
	{
		return Color(
			first.r() + t * (second.r() - third.r()),
			first.g() + t * (second.g() - third.g()),
			first.b() + t * (second.b() - third.b()),
			first.a() + t * (second.a() - third.a()));
	};

	if (blend)
		drawRectFilled(x, y, w, h, blendColor(first, second, third, 0.5f));
	gradient(first, true);
	gradient(second, false);
	gradient(third, false);
}

void SurfaceRender::text(const int x, const int y, const unsigned long font, const wchar_t* text, const bool centered, const Color& color)
{
	memory::interfaces::surface->drawTextFont(font);
	int width, height;

	memory::interfaces::surface->getTextSize(font, text, width, height);
	memory::interfaces::surface->setTextColor(color);
	memory::interfaces::surface->drawTextPos(centered ? (x - (width / 2)) : x, y);
	memory::interfaces::surface->drawRenderText(text, std::char_traits<wchar_t>::length(text));
}

void SurfaceRender::text(const int x, const int y, const unsigned long font, const std::string& text, const bool centered, const Color& color)
{
	if (text.empty())
		return;

	const auto converted = std::wstring(text.cbegin(), text.cend());
	int width, height;

	memory::interfaces::surface->drawTextFont(font);
	memory::interfaces::surface->getTextSize(font, converted.c_str(), width, height);
	memory::interfaces::surface->setTextColor(color);
	memory::interfaces::surface->drawTextPos(centered ? (x - (width / 2)) : x, y);
	memory::interfaces::surface->drawRenderText(converted.c_str(), converted.size());
}

void SurfaceRender::textf(const int x, const int y, const unsigned long font, const bool centered, const Color& color, const char* fmt, ...)
{
	if (!fmt)
		return;

	if (strlen(fmt) < 2)
		return;

	if (strlen(fmt) > BUFFER_SIZE)
		return; // maybe throw warn

	va_list args;

	std::array<char, BUFFER_SIZE> buf;

	std::fill(buf.begin(), buf.end(), 0);

	va_start(args, fmt);
	vsnprintf(buf.data(), sizeof(buf), fmt, args);
	va_end(args);

	text(x, y, font, buf.data(), centered, color);
}

int SurfaceRender::getTextSize(const unsigned long font, const std::string& text)
{
	std::wstring wtext(text.begin(), text.end());

	int width, height;
	memory::interfaces::surface->getTextSize(font, wtext.c_str(), width, height);

	return width;
}

Vec2 SurfaceRender::getTextSizeXY(const unsigned long font, const std::string& text)
{
	std::wstring wtext(text.begin(), text.end());

	int width, height;
	memory::interfaces::surface->getTextSize(font, wtext.c_str(), width, height);

	return Vec2{ (float)width, (float)height };
}

#include <gamememory/memory.hpp>
#include <cheats/game/globals.hpp>

bool SurfaceRender::worldToScreen(const Vec3& in, Vec2& out)
{
	auto screenMatrix = memory::viewMatrixAddr();

	float w = screenMatrix[3][0] * in[Coord::X] + screenMatrix[3][1] * in[Coord::Y] + screenMatrix[3][2] * in[Coord::Z] + screenMatrix[3][3];

	if (w < 0.001f)
		return false;

	Vec2 viewport = Vec2{ (float)globals::screenX, (float)globals::screenY };

	float inversed = 1.0f / w;
	out[Coord::X] = (viewport[Coord::X] / 2.0f) +
		(0.5f * ((screenMatrix[0][0] * in[Coord::X] + screenMatrix[0][1] * in[Coord::Y] + screenMatrix[0][2] * in[Coord::Z] + screenMatrix[0][3]) * inversed) * viewport[Coord::X] + 0.5f);
	out[Coord::Y] = (viewport[Coord::Y] / 2.0f) -
		(0.5f * ((screenMatrix[1][0] * in[Coord::X] + screenMatrix[1][1] * in[Coord::Y] + screenMatrix[1][2] * in[Coord::Z] + screenMatrix[1][3]) * inversed) * viewport[Coord::Y] + 0.5f);

	return true;
}

// cs engine lines are not anti aliased :(

void SurfaceRender::drawBox3D(const std::array<Vec3, 8>& box, const Color& color, bool filled)
{
	// transormed points to get pos.x/.y
	std::array<Vec2, 8> lines = {};

	for (size_t i = 0; auto& el : lines)
	{
		if (!worldToScreen(box.at(i), el))
			return;

#ifdef DEBUG_RENDER
		textf(points.at(i).x, points.at(i).y, fonts::tahoma, false, Color(100, 20, 100, 255), "[%i] posX: %0.2f, posY: %0.2f", i, points.at(i).x, points.at(i).y);
#endif // DEBUG_RENDER

		i++;
	}

	// anything with low alpha
	Color fill{ color.rMultiplied(), color.gMultiplied(), color.bMultiplied(), 30 };

	// first fill then draw lines
	if (filled)
	{
		// auto points = math::grahamScan(box.points); -> overload this function, I dont use surface for this
		// std::reverse(points.begin(), points.end()); -> don't use in surface.
		// drawPolyGon(points.size(), points.data(), fill);
	}
	for (size_t i = 1; i < 5; i++)
	{
		// BOTTOM 0,1,2,3
		drawLine(lines.at(i - 1), lines.at(i % 4), color);
		// TOP 4,5,6,7
		drawLine(lines.at(i + 3), lines.at(i % 4 + 4), color);
		// MISSING TOP
		drawLine(lines.at(i - 1), lines.at(i + 3), color);
	}
}

void SurfaceRender::initNewTexture(int& id, Color* RGBA, const int w, const int h)
{
	id = memory::interfaces::surface->createNewTextureID(true);
	if (id)
		memory::interfaces::surface->setTextureRGBA(id, RGBA, w, h);
	else
		throw std::runtime_error(FORMAT(XOR("setTextureRGBA failed to create new texture, ID was: {}"), id));
}
void SurfaceRender::initNewTexture(int& id, unsigned char* RGBA, const int w, const int h)
{
	id = memory::interfaces::surface->createNewTextureID(true);
	if (id)
		memory::interfaces::surface->setTextureRGBA(id, RGBA, w, h);
	else
		throw std::runtime_error(FORMAT(XOR("setTextureRGBA failed to create new texture, ID was: {}"), id));
}

void SurfaceRender::drawImage(const Resource& res, const int x, const int y, const int w, const int h, const Color& color)
{
	if (!memory::interfaces::surface->isTextureValid(res.getTextureID()))
		return;

	memory::interfaces::surface->drawSetColor(color);
	memory::interfaces::surface->drawSetTexture(res.getTextureID());
	memory::interfaces::surface->drawTexturedRect(x, y, x + w, y + h);
}

void SurfaceRender::drawProgressRing(const int x, const int y, float radius, const int points, float percent, const float thickness, const Color& color)
{
	// basically telling how precision will be
	float step = math::PI_2 / points;

	// limit angle, based on percentage passed
	float maxAngle = math::PI_2 * percent;

	for (float angle = 0.0f; angle < maxAngle; angle += step)
	{
		float ax = x + (radius * std::cos(angle)); // - (math::PI / 2.0f)) - will make clock like turning order
		float ay = y + (radius * std::sin(angle));

		float bx = x + (radius + thickness) * std::cos(angle);
		float by = y + (radius + thickness) * std::sin(angle);

		float cx = x + (radius * std::cos(angle + step));
		float cy = y + (radius * std::sin(angle + step));

		float dx = x + (radius + thickness) * std::cos(angle + step);
		float dy = y + (radius + thickness) * std::sin(angle + step);

		// aswell you can pass triangles with a bit higher precision in drawing

		// somethign brokey in this function, that's why this order
		drawQuadFilled(
			Vec2{ cx, cy },
			Vec2{ dx, dy },
			Vec2{ bx, by },
			Vec2{ ax, ay },
			color);
	}
}

/*


		IMGUI DRAWING

*/

#include <ShlObj.h>
#include <filesystem>
#include <imgui_freetype.h>
#include "iconfont.hpp"

void ImGuiRender::init(ImGuiIO& io)
{
	if (CHAR fontsPath[MAX_PATH]; SUCCEEDED(LI_FN_CACHED(SHGetFolderPathA)(NULL, CSIDL_FONTS, NULL, SHGFP_TYPE_CURRENT, fontsPath)))
	{
		const std::filesystem::path path{ fontsPath };

		ImFontConfig cfg;
		cfg.OversampleH = 3;
		cfg.OversampleV = 3;
		cfg.FontBuilderFlags = ImGuiFreeTypeBuilderFlags_LightHinting;

		ImVector<ImWchar> range;
		ImFontGlyphRangesBuilder textBuilder;
		constexpr ImWchar textRanges[] =
		{
			0x0020, 0x00FF, // Basic Latin
			0x0100, 0x024F, // Latin Extended-A + Latin Extended-B
			0x0600, 0x06FF, // Arabic
			0x0E00, 0x0E7F, // Thai
			0
		};
		textBuilder.AddRanges(textRanges);
		textBuilder.AddRanges(io.Fonts->GetGlyphRangesCyrillic());
		textBuilder.AddRanges(io.Fonts->GetGlyphRangesDefault());
		textBuilder.BuildRanges(&range);

		ImFonts::tahoma14 = io.Fonts->AddFontFromFileTTF(std::filesystem::path{ path / XOR("tahoma.ttf") }.string().c_str(), 14.0f, &cfg, textRanges);
		ImFonts::tahoma20 = io.Fonts->AddFontFromFileTTF(std::filesystem::path{ path / XOR("tahoma.ttf") }.string().c_str(), 20.0f, &cfg, textRanges);
		ImFonts::franklinGothic12 = io.Fonts->AddFontFromFileTTF(std::filesystem::path{ path / XOR("framd.ttf") }.string().c_str(), 12.0f, &cfg, textRanges);
		ImFonts::franklinGothic30 = io.Fonts->AddFontFromFileTTF(std::filesystem::path{ path / XOR("framd.ttf") }.string().c_str(), 30.0f, &cfg, textRanges);
		ImFonts::verdana12 = io.Fonts->AddFontFromFileTTF(std::filesystem::path{ path / XOR("Verdana.ttf") }.string().c_str(), 12.0f, &cfg, textRanges);

		constexpr ImWchar ranges[] =
		{
			0xE000, 0xF8FF,
			0,
		};
		ImFonts::icon = io.Fonts->AddFontFromMemoryCompressedTTF(iconFont, iconFontSize, 80.0f, &cfg, ranges);

		if (!ImGuiFreeType::BuildFontAtlas(io.Fonts))
			throw std::runtime_error(XOR("ImGuiFreeType::BuildFontAtlas returned false"));
	}
	else
		throw std::runtime_error(XOR("could not reach windows path"));

	LOG_INFO(XOR("init imgui fonts success"));
}

void ImGuiRender::drawLine(const float x, const float y, const float x2, const float y2, const Color& color, const float thickness)
{
	m_drawData.emplace_back(std::make_unique<drawing::Line>(ImVec2{ x, y }, ImVec2{ x2, y2 }, Color::U32(color), thickness));
}

void ImGuiRender::drawLine(const ImVec2& start, const ImVec2& end, const Color& color, const float thickness)
{
	m_drawData.emplace_back(std::make_unique<drawing::Line>(start, end, Color::U32(color), thickness));
}

void ImGuiRender::drawRect(const float x, const float y, const float w, const float h, const Color& color, const ImDrawFlags flags, const float thickness)
{
	m_drawData.emplace_back(std::make_unique<drawing::Rectangle>(ImVec2{ x, y }, ImVec2{ x + w, y + h }, Color::U32(color), 0.0f, flags, thickness));
}

void ImGuiRender::drawRectFilled(const float x, const float y, const float w, const float h, const Color& color, const ImDrawFlags flags)
{
	m_drawData.emplace_back(std::make_unique<drawing::RectangleFilled>(ImVec2{ x, y }, ImVec2{ x + w, y + h }, Color::U32(color), 0.0f, flags));
}

void ImGuiRender::drawRoundedRect(const float x, const float y, const float w, const float h, const float rounding, const Color& color, const ImDrawFlags flags, const float thickness)
{
	m_drawData.emplace_back(std::make_unique<drawing::Rectangle>(ImVec2{ x, y }, ImVec2{ x + w, y + h }, Color::U32(color), rounding, flags, thickness));
}

void ImGuiRender::drawRoundedRectFilled(const float x, const float y, const float w, const float h, const float rounding, const Color& color, const ImDrawFlags flags)
{
	m_drawData.emplace_back(std::make_unique<drawing::RectangleFilled>(ImVec2{ x, y }, ImVec2{ x + w, y + h }, Color::U32(color), rounding, flags));
}

void ImGuiRender::drawRectFilledMultiColor(const float x, const float y, const float w, const float h,
	const Color& colUprLeft, const Color& colUprRight, const Color& colBotRight, const Color& colBotLeft)
{
	m_drawData.emplace_back(std::make_unique<drawing::RectangleMultiColor>(ImVec2{ x, y }, ImVec2{ x + w, y + h },
		Color::U32(colUprLeft), Color::U32(colUprRight), Color::U32(colBotRight), Color::U32(colBotLeft)));
}

void ImGuiRender::drawTrianglePoly(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const Color& color)
{
	std::vector verts =
	{
		p1,
		p2,
		p3
	};

	imRender.drawPolyGon(verts, color);
}

static ImVec2 operator-(const ImVec2& v, float val)
{
	return ImVec2{ v.x - val, v.y - val };
}

static ImVec2 operator+(const ImVec2& v, float val)
{
	return ImVec2{ v.x + val, v.y + val };
}

void ImGuiRender::drawBox3D(const Vec3& pos, const float width, const float height, const Color& color, bool outlined, const float thickness)
{
	// dividing to get a centre to world position
	float boxW = width / 2.0f;
	float boxH = height / 2.0f;

	outlined = false; // looks bad

	std::array box =
	{
		Vec3{ pos[Coord::X] - boxW, pos[Coord::Y] - boxH, pos[Coord::Z] - boxW},
		Vec3{ pos[Coord::X] - boxW, pos[Coord::Y] - boxH, pos[Coord::Z] + boxW },
		Vec3{ pos[Coord::X] + boxW, pos[Coord::Y] - boxH, pos[Coord::Z] + boxW },
		Vec3{ pos[Coord::X] + boxW, pos[Coord::Y] - boxH, pos[Coord::Z] - boxW},
		Vec3{ pos[Coord::X] - boxW, pos[Coord::Y] + boxH, pos[Coord::Z] - boxW},
		Vec3{ pos[Coord::X] - boxW, pos[Coord::Y] + boxH, pos[Coord::Z] + boxW },
		Vec3{ pos[Coord::X] + boxW, pos[Coord::Y] + boxH, pos[Coord::Z] + boxW },
		Vec3{ pos[Coord::X] + boxW, pos[Coord::Y] + boxH, pos[Coord::Z] - boxW},
	};

	std::array<ImVec2, box.size()> lines = {};
	
	for (size_t i = 0; auto& el : lines)
	{
		if (!worldToScreen(box.at(i), el))
			return;

		i++;
	}

	Color outlineCol = Colors::Black.getColorEditAlpha(color.a());

	for (size_t i = 1; i < 5; i++)
	{
		// BOTTOM 0,1,2,3
		drawLine(lines.at(i - 1), lines.at(i % 4), color, thickness);
		if (outlined)
			drawLine(lines.at(i - 1) + 1.0f - thickness, lines.at(i % 4) + 1.0f - thickness, outlineCol);
		// TOP 4,5,6,7
		drawLine(lines.at(i + 3), lines.at(i % 4 + 4), color, thickness);
		if (outlined)
			drawLine(lines.at(i + 3) + 1.0f - thickness, lines.at(i % 4 + 4) + 1.0f - thickness, outlineCol);
		// MISSING TOP
		drawLine(lines.at(i - 1), lines.at(i + 3), color, thickness);
		if (outlined)
			drawLine(lines.at(i - 1) + 1.0f - thickness, lines.at(i + 3) + 1.0f - thickness, outlineCol);
	}
}

void ImGuiRender::drawBox3DFilled(const Vec3& pos, const float width, const float height, const Color& color, const Color& filling, bool outlined, const float thickness)
{
	// dividing to get a centre to world position
	float boxW = width / 2.0f;
	float boxH = height / 2.0f;

	outlined = false; // looks bad

	std::array box =
	{
		Vec3{ pos[Coord::X] - boxW, pos[Coord::Y] - boxH, pos[Coord::Z] - boxW},
		Vec3{ pos[Coord::X] - boxW, pos[Coord::Y] - boxH, pos[Coord::Z] + boxW },
		Vec3{ pos[Coord::X] + boxW, pos[Coord::Y] - boxH, pos[Coord::Z] + boxW },
		Vec3{ pos[Coord::X] + boxW, pos[Coord::Y] - boxH, pos[Coord::Z] - boxW},
		Vec3{ pos[Coord::X] - boxW, pos[Coord::Y] + boxH, pos[Coord::Z] - boxW},
		Vec3{ pos[Coord::X] - boxW, pos[Coord::Y] + boxH, pos[Coord::Z] + boxW },
		Vec3{ pos[Coord::X] + boxW, pos[Coord::Y] + boxH, pos[Coord::Z] + boxW },
		Vec3{ pos[Coord::X] + boxW, pos[Coord::Y] + boxH, pos[Coord::Z] - boxW},
	};

	// transormed points to get pos.x/.y
	std::array<ImVec2, box.size()> lines = {};

	for (size_t i = 0; auto & el : lines)
	{
		if (!worldToScreen(box.at(i), el))
			return;

		i++;
	}

	auto maybeScanned = math::grahamScan(lines);
	if (!maybeScanned.has_value())
		return;

	auto points = maybeScanned.value();

	std::reverse(points.begin(), points.end());
	drawPolyGon(points, filling);

	Color outlineCol = Colors::Black.getColorEditAlpha(color.a());

	for (size_t i = 1; i < 5; i++)
	{
		// BOTTOM 0,1,2,3
		drawLine(lines.at(i - 1), lines.at(i % 4), color, thickness);
		if (outlined)
			drawLine(lines.at(i - 1) + 1.0f - thickness, lines.at(i % 4) + 1.0f - thickness, outlineCol);
		// TOP 4,5,6,7
		drawLine(lines.at(i + 3), lines.at(i % 4 + 4), color, thickness);
		if (outlined)
			drawLine(lines.at(i + 3) + 1.0f - thickness, lines.at(i % 4 + 4) + 1.0f - thickness, outlineCol);
		// MISSING TOP
		drawLine(lines.at(i - 1), lines.at(i + 3), color, thickness);
		if (outlined)
			drawLine(lines.at(i - 1) + 1.0f - thickness, lines.at(i + 3) + 1.0f - thickness, outlineCol);
	}
}

void ImGuiRender::drawCircle(const float x, const float y, const float radius, const int points, const Color& color, const float thickness)
{
	m_drawData.emplace_back(std::make_unique<drawing::Circle>(ImVec2{ x, y }, radius, points, Color::U32(color), thickness));
}

void ImGuiRender::drawCircleFilled(const float x, const float y, const float radius, const int points, const Color& color)
{
	m_drawData.emplace_back(std::make_unique<drawing::CircleFilled>(ImVec2{ x, y }, radius, points, Color::U32(color)));
}

void ImGuiRender::drawCircle3D(const Vec3& pos, const float radius, const int points, const Color& color, const ImDrawFlags flags, const float thickness)
{
	float step = math::PI_2 / points;

	std::vector<ImVec2> pointsVec = {};
	for (float angle = 0.0f; angle < math::PI_2; angle += step)
	{
		Vec3 worldStart = Vec3{ radius * std::cos(angle) + pos[Coord::X], radius * std::sin(angle) + pos[Coord::Y], pos[Coord::Z] };
		if (ImVec2 screenStart; worldToScreen(worldStart, screenStart))
			pointsVec.push_back(screenStart);
	}

	drawPolyLine(pointsVec, color, flags, thickness);
}

#include <SDK/IEngineTrace.hpp>
#include <SDK/vars.hpp>

void ImGuiRender::drawCircle3DTraced(const Vec3& pos, const float radius, const int points, void* skip, const Color& color, const ImDrawFlags flags, const float thickness)
{
	float step = math::PI_2 / points;

	std::vector<ImVec2> pointsVec = {};
	for (float angle = 0.0f; angle < math::PI_2; angle += step)
	{
		Vec3 worldStart = Vec3{ radius * std::cos(angle) + pos[Coord::X], radius * std::sin(angle) + pos[Coord::Y], pos[Coord::Z] };

		Trace_t trace;
		TraceFilter filter;
		filter.m_skip = skip;

		memory::interfaces::trace->traceRay({ pos, worldStart }, MASK_SHOT_BRUSHONLY, &filter, &trace);

		if (ImVec2 screenStart; worldToScreen(trace.m_end, screenStart))
			pointsVec.push_back(screenStart);
	}

	drawPolyLine(pointsVec, color, flags, thickness);
}

void ImGuiRender::drawCircle3DFilled(const Vec3& pos, const float radius, const int points, const Color& color, const Color& outline, const ImDrawFlags flags, const float thickness)
{
	float step = math::PI_2 / points;

	std::vector<ImVec2> pointsVec = {};
	for (float angle = 0.0f; angle < math::PI_2; angle += step)
	{
		Vec3 worldStart = Vec3{ radius * std::cos(angle) + pos[Coord::X], radius * std::sin(angle) + pos[Coord::Y], pos[Coord::Z] };
		if (ImVec2 screenStart; worldToScreen(worldStart, screenStart))
			pointsVec.push_back(screenStart);
	}

	drawPolyGon(pointsVec, color);
	drawPolyLine(pointsVec, color, flags, thickness);
}

void ImGuiRender::drawCircle3DFilledTraced(const Vec3& pos, const float radius, const int points, void* skip, const Color& color, const Color& outline, const ImDrawFlags flags, const float thickness)
{
	float step = math::PI *2.0f / points;

	std::vector<ImVec2> pointsVec = {};
	for (float angle = 0.0f; angle < math::PI_2; angle += step)
	{
		Vec3 worldStart = Vec3{ radius * std::cos(angle) + pos[Coord::X], radius * std::sin(angle) + pos[Coord::Y], pos[Coord::Z] };

		Trace_t trace;
		TraceFilter filter;
		filter.m_skip = skip;

		memory::interfaces::trace->traceRay({ pos, worldStart }, MASK_SHOT_BRUSHONLY, &filter, &trace);

		if (ImVec2 screenStart; worldToScreen(trace.m_end, screenStart))
			pointsVec.push_back(screenStart);
	}

	drawPolyGon(pointsVec, color);
	drawPolyLine(pointsVec, color, flags, thickness);
}

void ImGuiRender::drawTriangle(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const Color& color, const float thickness)
{
	m_drawData.emplace_back(std::make_unique<drawing::Triangle>(p1, p2, p3, Color::U32(color), thickness));
}

void ImGuiRender::drawTriangle(const float x, const float y, const float w, const float h, const Color& color, const float angle, const float thickness)
{
	float radian = math::DEG2RAD(angle);
	float radian90 = math::DEG2RAD(angle + 90);

	const ImVec2 p1 = ImVec2{ (w / 2.0f) * std::cos(radian90) + x, (w / 2.0f) * std::sin(radian90) + y };
	const ImVec2 p2 = ImVec2{ (-w / 2.0f) * std::cos(radian90) + x, (-w / 2.0f) * std::sin(radian90) + y };
	const ImVec2 p3 = ImVec2{ h * std::cos(radian) + x, h * std::sin(radian) + y };

	m_drawData.emplace_back(std::make_unique<drawing::Triangle>(p1, p2, p3, Color::U32(color), thickness));
}

void ImGuiRender::drawTriangleFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const Color& color)
{
	m_drawData.emplace_back(std::make_unique<drawing::TriangleFilled>(p1, p2, p3, Color::U32(color)));
}

void ImGuiRender::drawTriangleFilled(const float x, const float y, const float w, const float h, const float angle, const Color& color)
{
	float radian = math::DEG2RAD(angle);
	float radian90 = math::DEG2RAD(angle + 90);

	const ImVec2 p1 = ImVec2{ (w / 2.0f) * std::cos(radian90) + x, (w / 2.0f) * std::sin(radian90) + y };
	const ImVec2 p2 = ImVec2{ (-w / 2.0f) * std::cos(radian90) + x, (-w / 2.0f) * std::sin(radian90) + y };
	const ImVec2 p3 = ImVec2{ h * std::cos(radian) + x, h * std::sin(radian) + y };

	m_drawData.emplace_back(std::make_unique<drawing::TriangleFilled>(p1, p2, p3, Color::U32(color)));
}

void ImGuiRender::drawQuad(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const Color& color, const float thickness)
{
	m_drawData.emplace_back(std::make_unique<drawing::Quad>(p1, p2, p3, p4, Color::U32(color), thickness));
}

void ImGuiRender::drawQuadFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const Color& color)
{
	m_drawData.emplace_back(std::make_unique<drawing::QuadFilled>(p1, p2, p3, p4, Color::U32(color)));
}

void ImGuiRender::drawQuadFilledMultiColor(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4,
	const Color& colUprLeft, const Color& colUprRight, const Color& colBotRight, const Color& colBotLeft)
{
	m_drawData.emplace_back(std::make_unique<drawing::QuadMultiColor>(p1, p2, p3, p4,
		Color::U32(colUprLeft), Color::U32(colUprRight), Color::U32(colBotRight), Color::U32(colBotLeft)));
}

void ImGuiRender::drawPolyLine(const std::vector<ImVec2>& verts, const Color& color, const ImDrawFlags flags, const float thickness)
{
	m_drawData.emplace_back(std::make_unique<drawing::Polyline>(verts, Color::U32(color), flags, thickness));
}

void ImGuiRender::drawPolyGon(const std::vector<ImVec2>& verts, const Color& color)
{
	m_drawData.emplace_back(std::make_unique<drawing::Polygon>(verts, Color::U32(color)));
}

void ImGuiRender::drawPolyGonMultiColor(const std::vector<ImVec2>& verts, const std::vector<ImU32>& colors)
{
	m_drawData.emplace_back(std::make_unique<drawing::PolygonMultiColor>(verts, colors));
}

void ImGuiRender::drawGradient(const float x, const float y, const float w, const float h, const Color& first, const Color& second, bool horizontal)
{
	m_drawData.emplace_back(std::make_unique<drawing::RectangleGradient>(ImVec2{ x, y }, ImVec2{ x + w, y + h }, Color::U32(first), Color::U32(second), horizontal));
}

void ImGuiRender::text(const float x, const float y, ImFont* font, const std::string& text, const bool centered, const Color& color, const bool dropShadow)
{
	m_drawData.emplace_back(std::make_unique<drawing::Text>(font, ImVec2{ x, y }, Color::U32(color), text, dropShadow, centered));
}

void ImGuiRender::text(const float x, const float y, ImFont* font, const std::wstring& text, const bool centered, const Color& color, const bool dropShadow)
{
	std::string _text(text.length(), 0);
	// because warning
	std::transform(text.begin(), text.end(), _text.begin(), [](wchar_t wc)
		{
			return static_cast<char>(wc);
		});

	m_drawData.emplace_back(std::make_unique<drawing::Text>(font, ImVec2{ x, y }, Color::U32(color), _text, dropShadow, centered));
}

void ImGuiRender::text(const float x, const float y, const float fontSize, ImFont* font, const std::string& text, const bool centered, const Color& color, const bool dropShadow)
{
	m_drawData.emplace_back(std::make_unique<drawing::TextSize>(fontSize, font, ImVec2{ x, y }, Color::U32(color), text, dropShadow, centered));
}

void ImGuiRender::textf(const float x, const float y, ImFont* font, const bool centered, const Color& color, const bool dropShadow, const char* fmt, ...)
{
	if (!fmt)
		return;

	if (strlen(fmt) < 2)
		return;

	if (strlen(fmt) > BUFFER_SIZE)
		return; // maybe throw warn

	va_list args;

	std::array<char, BUFFER_SIZE> buf;

	std::fill(buf.begin(), buf.end(), 0);

	va_start(args, fmt);
	vsnprintf(buf.data(), sizeof(buf), fmt, args);
	va_end(args);

	text(x, y, font, buf.data(), centered, color, dropShadow);
}

ImVec2 ImGuiRender::getTextSize(ImFont* font, const std::string& text)
{
	auto ret = ImGui::CalcTextSize(text.c_str());
	return ret;
}

bool ImGuiRender::worldToScreen(const Vec3& in, ImVec2& out)
{
	auto screenMatrix = memory::viewMatrixAddr();

	float w = screenMatrix[3][0] * in[Coord::X] + screenMatrix[3][1] * in[Coord::Y] + screenMatrix[3][2] * in[Coord::Z] + screenMatrix[3][3];

	if (w < 0.001f)
		return false;

	ImVec2 viewport = ImGui::GetIO().DisplaySize;

	float inversed = 1.0f / w;
	out.x = (viewport.x / 2.0f) +
		(0.5f * ((screenMatrix[0][0] * in[Coord::X] + screenMatrix[0][1] * in[Coord::Y] + screenMatrix[0][2] * in[Coord::Z] + screenMatrix[0][3]) * inversed) * viewport.x + 0.5f);
	out.y = (viewport.y / 2.0f) -
		(0.5f * ((screenMatrix[1][0] * in[Coord::X] + screenMatrix[1][1] * in[Coord::Y] + screenMatrix[1][2] * in[Coord::Z] + screenMatrix[1][3]) * inversed) * viewport.y + 0.5f);

	return true;
}

void ImGuiRender::drawArc(const float x, const float y, float radius, const int points, float angleMin, float angleMax, const float thickness, const Color& color, const ImDrawFlags flags)
{
	m_drawData.emplace_back(std::make_unique<drawing::Arc>(ImVec2{ x, y }, radius, math::DEG2RAD(angleMin), math::DEG2RAD(angleMax), points, Color::U32(color), flags, thickness));
}

void ImGuiRender::drawProgressRing(const float x, const float y, const float radius, const int points, const float angleMin, float percent, const float thickness, const Color& color, const ImDrawFlags flags)
{
	float maxAngle = math::RAD2DEG(math::PI *2.0f * percent) + angleMin;
	m_drawData.emplace_back(std::make_unique<drawing::Arc>(ImVec2{ x, y }, radius, math::DEG2RAD(angleMin), math::DEG2RAD(maxAngle), points, Color::U32(color), flags, thickness));
}

void ImGuiRender::drawSphere(const Vec3& pos, float radius, float angleSphere, const Color& color)
{
	std::vector<ImVec2> verts = {};

	float step = (1.0f / radius) + math::DEG2RAD(angleSphere);
	for (float angle = 0.0f; angle < math::PI; angle += step)
	{
		verts.clear();
		for (float angleBetween = 0.0f; angleBetween < math::PI_2; angleBetween += step)
		{
			Vec3 worldStart = Vec3
			{
				radius * std::sin(angle) * std::cos(angleBetween) + pos[Coord::X],
				radius * std::sin(angle) * std::sin(angleBetween) + pos[Coord::Y],
				radius * std::cos(angle) + pos[Coord::Z]
			};

			if (ImVec2 screenStart; imRender.worldToScreen(worldStart, screenStart))
				verts.push_back(screenStart);
		}

		if (verts.empty())
			continue;

		imRender.drawPolyLine(verts, color);
	}
}

void ImGuiRender::drawCone(const Vec3& pos, const float radius, const int points, const float size, const Color& colCircle, const Color& colCone, const ImDrawFlags flags, const float thickness)
{
	ImVec2 orignalW2S = {};
	if (!worldToScreen(pos, orignalW2S))
		return;

	float step = math::PI_2 / points;

	for (float angle = 0.0f; angle < math::PI_2; angle += step)
	{
		Vec3 worldStart = Vec3{ radius * std::cos(angle) + pos[Coord::X], radius * std::sin(angle) + pos[Coord::Y], pos[Coord::Z] };
		Vec3 worldEnd = Vec3{ radius * std::cos(angle + step) + pos[Coord::X], radius * std::sin(angle + step) + pos[Coord::Y], pos[Coord::Z] };

		if (ImVec2 start, end; worldToScreen(worldStart, start) && worldToScreen(worldEnd, end))
		{
			drawLine(start, end, colCircle);
			// using surface because it does not add outlines
			drawTrianglePoly({ orignalW2S.x, orignalW2S.y + size /*- std::abs(size)*/ }, start, end, colCone);
		}
	}
}

void ImGuiRender::renderPresent(ImDrawList* draw)
{
	std::unique_lock<std::shared_mutex> lock{ m_mutex };

	if (m_drawDataSafe.empty())
		return;

	for (const auto& data : m_drawDataSafe)
		data->draw(draw);
}

void ImGuiRender::clearData()
{
	if (!m_drawData.empty())
		m_drawData.clear();
}

void ImGuiRender::swapData()
{
	std::unique_lock<std::shared_mutex> lock{ m_mutex };
	m_drawData.swap(m_drawDataSafe);
}

void ImGuiRender::addToRender(const std::function<void()>& fun)
{
	clearData();
	fun();
	swapData();
}

#undef BUFFER_SIZE
```

`hack/render/render.hpp`:

```hpp
#pragma once

#include "BBox.hpp"

#include <string>
#include <mutex>
#include <shared_mutex>
#include <functional>
#include <any>
#include <deque>
#include <array>

#include <SDK/math/Vector.hpp>
#include <imgui.h>
#include "Color.hpp"

class Color;
class Resource;
class Entity_t;
struct Vertex_t;

namespace fonts
{
	inline unsigned long tahoma;
	inline unsigned long franklinGothic;
	inline unsigned long verdana;
}

// rendering with game's engine
class SurfaceRender
{
public:
	void init();

	[[nodiscard]] unsigned long  __createFont(const char* fontName, const int size, const int weight, const unsigned long flags);

	void drawLine(const int x, const int y, const int x2, const int y2, const Color& color);
	void drawLine(const Vec2& start, const Vec2& end, const Color& color);
	void drawRect(const int x, const int y, const int w, const int h, const Color& color);
	void drawRect(const Vec2& start, const Vec2& end, const Color& color);
	void drawRectFilled(const int x, const int y, const int w, const int h, const Color& color);
	// https://www.unknowncheats.me/forum/counterstrike-global-offensive/181578-draw-rounded-box-static-dynamic.html
	void drawRoundedRect(const int x, const int y, const int w, const int h, const int radius, const int numberOfVertices, const Color& color);
	void drawRoundedRectFilled(const int x, const int y, const int w, const int h, const int radius, const int numberOfVertices, const Color& color);
	void drawCircle(const int x, const int y, const int radius, const int points, const Color& color);
	void drawCircleFilled(const int x, const int y, const int radius, const int points, const Color& color);
	void drawCircle3D(const Vec3& pos, const int radius, const int points, const Color& color);
	void drawFilledCircle3D(const Vec3& pos, const int radius, const int points, const Color& color);
	void drawTriangle(const Vec2& p1, const Vec2& p2, const Vec2& p3, const Color& color);
	void drawTriangleFilled(const Vec2& p1, const Vec2& p2, const Vec2& p3, const Color& color);
	void drawQuad(const Vec2& p1, const Vec2& p2, const Vec2& p3, const Vec2& p4, const Color& color);
	void drawQuadFilled(const Vec2& p1, const Vec2& p2, const Vec2& p3, const Vec2& p4, const Color& color);
	void drawPolyLine(int* x, int* y, const int count, const Color& color);
	void drawPolyLine(const int count, Vertex_t* verts, const Color& color);
	void drawPolyGon(const int count, Vertex_t* verts, const Color& color, const bool clipped = true);
	void drawGradient(const int x, const int y, const int w, const int h, const Color& first, const Color& second, bool horizontal, bool blend = true);
	void drawGradient(const int x, const int y, const int w, const int h, const Color& first, const Color& second, const Color& third, bool horizontal, bool blend = true);
	void text(const int x, const int y, const unsigned long font, const wchar_t* text, const bool centered, const Color& color);
	void text(const int x, const int y, const unsigned long font, const std::string& text, const bool centered, const Color& color);
	void textf(const int x, const int y, const unsigned long font, const bool centered, const Color& color, const char* fmt, ...);
	[[deprecated("You should only read comments from there, better results are with ImGuiRender class")]]
	void drawBox3D(const std::array<Vec3, 8>& box, const Color& color, bool filled = false);
	// percent should be passed in 0.0-1.0 range, credits for helping Carlos1216
	void drawProgressRing(const int x, const int y, float radius, const int points, float percent, const float thickness, const Color& color);
	// width only
	[[nodiscard]] int getTextSize(const unsigned long font, const std::string& text);
	// width and height
	[[nodiscard]] Vec2 getTextSizeXY(const unsigned long font, const std::string& text);
	[[nodiscard]] bool worldToScreen(const Vec3& in, Vec2& out);
	void initNewTexture(int& id, Color* RGBA, const int w, const int h);
	void initNewTexture(int& id, unsigned char* RGBA, const int w, const int h);
	void drawImage(const Resource& res, const int x, const int y, const int w, const int h, const Color& color);
};

inline SurfaceRender surfaceRender;

struct ImGuiIO;
struct ImFont;

namespace ImFonts
{
	inline ImFont* tahoma14;
	inline ImFont* tahoma20;
	inline ImFont* franklinGothic30;
	inline ImFont* franklinGothic12;
	inline ImFont* verdana12;
	inline ImFont* icon;
}

#include <memory>
#include "structures.hpp"

// rendering supported by dear ImGui, few changes and new functions comparing to surface draw
// thread safe idea - full credits to qo0' as I couldn't really rebuild manually w2s with any success removing this weird stutter
class ImGuiRender
{
public:
	void init(ImGuiIO& io);

	void drawLine(const float x, const float y, const float x2, const float y2, const Color& color, const float thickness = 1.0f);
	void drawLine(const ImVec2& start, const ImVec2& end, const Color& color, const float thickness = 1.0f);
	void drawRect(const float x, const float y, const float w, const float h, const Color& color, const ImDrawFlags flags = 0, const float thickness = 1.0f);
	void drawRectFilled(const float x, const float y, const float w, const float h, const Color& color, const ImDrawFlags flags = 0);
	void drawRoundedRect(const float x, const float y, const float w, const float h, const float rounding, const Color& color, const ImDrawFlags flags = 0, const float thickness = 1.0f);
	void drawRoundedRectFilled(const float x, const float y, const float w, const float h, const float rounding, const Color& color, const ImDrawFlags flags = 0);
	void drawRectFilledMultiColor(const float x, const float y, const float w, const float h,
		const Color& colUprLeft, const Color& colUprRight, const Color& colBotRight, const Color& colBotLeft);
	void drawCircle(const float x, const float y, const float radius, const int points, const Color& color, const float thickness = 1.0f);
	void drawCircleFilled(const float x, const float y, const float radius, const int points, const Color& color);
	void drawCircle3D(const Vec3& pos, const float radius, const int points, const Color& color, const ImDrawFlags flags = 1, const float thickness = 1.0f);
	void drawCircle3DTraced(const Vec3& pos, const float radius, const int points, void* skip, const Color& outline, const ImDrawFlags flags = 1, const float thickness = 1.0f);
	void drawCircle3DFilled(const Vec3& pos, const float radius, const int points, const Color& color, const Color& outline, const ImDrawFlags flags = 1, const float thickness = 1.0f);
	void drawCircle3DFilledTraced(const Vec3& pos, const float radius, const int points, void* skip, const Color& color, const Color& outline, const ImDrawFlags flags = 1, const float thickness = 1.0f);
	void drawTriangle(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const Color& color, const float thickness = 1.0f);
	void drawTriangle(const float x, const float y, const float w, const float h, const Color& color, const float angle, const float thickness = 1.0f);
	void drawTriangleFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const Color& color);
	void drawTriangleFilled(const float x, const float y, const float w, const float h, const float angle, const Color& color);
	void drawTrianglePoly(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const Color& color);
	void drawQuad(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const Color& color, const float thickness = 1.0f);
	void drawQuadFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const Color& color);
	void drawQuadFilledMultiColor(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4,
		const Color& colUprLeft, const Color& colUprRight, const Color& colBotRight, const Color& colBotLeft);
	void drawPolyLine(const std::vector<ImVec2>& verts, const Color& color, const ImDrawFlags flags = 0, const float thickness = 1.0f);
	void drawPolyGon(const std::vector<ImVec2>& verts, const Color& color);
	// for performace and reduce looping pass by using U32()
	void drawPolyGonMultiColor(const std::vector<ImVec2>& verts, const std::vector<ImU32>& colors);
	void drawGradient(const float x, const float y, const float w, const float h, const Color& first, const Color& second, bool horizontal);
	void text(const float x, const float y, ImFont* font, const std::string& text, const bool centered, const Color& color, const bool dropShadow = true);
	void text(const float x, const float y, const float fontSize, ImFont* font, const std::string& text, const bool centered, const Color& color, const bool dropShadow = true);
	void text(const float x, const float y, ImFont* font, const std::wstring& text, const bool centered, const Color& color, const bool dropShadow = true);
	void textf(const float x, const float y, ImFont* font, const bool centered, const Color& color, const bool dropShadow, const char* fmt, ...);
	void drawBox3D(const Vec3& pos, const float width, const float height, const Color& color, bool outlined = false, const float thickness = 2.0f);
	void drawBox3DFilled(const Vec3& pos, const float width, const float height, const Color& color, const Color& filling, bool outlined = false, const float thickness = 2.0f);
	void drawCone(const Vec3& pos, const float radius, const int points, const float size, const Color& colCircle, const Color& colCone, const ImDrawFlags flags = 1, const float thickness = 1.0f);

	/*
	* arcs - there are few problems with them. Especially you can see it when trying to do arc that is a full circle.
	* You will see that they infact are maybe filled, but few pixels are missing.
	* 1st fix - ghetto, but will maybe behave better for performance, when delta is 360 deg or for progress - percent is 100
	* then we make delta - 0.1f, same thing for percent. And then call ImDrawFlags_Closed.
	* No ghetto fix, is just to call it with many segments.
	* Correct me if you found any better solution, or explain it why.
	*/

	void drawArc(const float x, const float y, float radius, const int points, float angleMin, float angleMax, const float thickness, const Color& color, const ImDrawFlags flags = 0);
	void drawProgressRing(const float x, const float y, const float radius, const int points, const float angleMin, float percent, const float thickness, const Color& color, const ImDrawFlags flags = 0);
	void drawSphere(const Vec3& pos, float radius, float angleSphere, const Color& color);
	[[nodiscard]] ImVec2 getTextSize(ImFont* font, const std::string& text);
	[[nodiscard]] bool worldToScreen(const Vec3& in, ImVec2& out);

	// add to present
	void renderPresent(ImDrawList* draw);
	// add to surface
	void addToRender(const std::function<void()>& fun);
private:
	// add to surface
	void clearData();
	// add to surface
	void swapData();
	std::deque<std::unique_ptr<drawing::Draw>> m_drawData;
	std::deque<std::unique_ptr<drawing::Draw>> m_drawDataSafe;
	std::shared_mutex m_mutex;
};

inline ImGuiRender imRender;
```

`hack/render/structures.cpp`:

```cpp
#include "structures.hpp"

#include <imgui.h>
#include <SDK/math/Vector.hpp>
#include <render/Color.hpp>
#include <deps/ImGui/extraDraw.hpp>

#include <numeric>

using namespace drawing;

void Line::draw(ImDrawList* draw) const
{
	draw->AddLine(m_start, m_end, m_color, m_thickness);
}

void Rectangle::draw(ImDrawList* draw) const
{
	draw->AddRect(m_min, m_max, m_color, m_rounding, m_flags, m_thickness);
}

void RectangleFilled::draw(ImDrawList* draw) const
{
	draw->AddRectFilled(m_min, m_max, m_color, m_rounding, m_flags);
}

void RectangleGradient::draw(ImDrawList* draw) const
{
	if (!m_horizontal)
		draw->AddRectFilledMultiColor(m_min, m_max, m_color1, m_color2, m_color2, m_color1);
	else
		draw->AddRectFilledMultiColor(m_min, m_max, m_color1, m_color1, m_color2, m_color2);
}

void RectangleMultiColor::draw(ImDrawList* draw) const
{
	ImGui::ExtraDrawlist::AddRectFilledMultiColor(draw, m_min, m_max, m_color1, m_color2, m_color3, m_color4, m_rounding);
}

void Circle::draw(ImDrawList* draw) const
{
	draw->AddCircle(m_centre, m_radius, m_color, m_segments, m_thickness);
}

void CircleFilled::draw(ImDrawList* draw) const
{
	draw->AddCircleFilled(m_centre, m_radius, m_color, m_segments);
}

void Triangle::draw(ImDrawList* draw) const
{
	draw->AddTriangle(m_p1, m_p2, m_p3, m_color, m_thickness);
}

void TriangleFilled::draw(ImDrawList* draw) const
{
	draw->AddTriangleFilled(m_p1, m_p2, m_p3, m_color);
}

void Quad::draw(ImDrawList* draw) const
{
	draw->AddQuad(m_p1, m_p2, m_p3, m_p4, m_color, m_thickness);
}

void QuadFilled::draw(ImDrawList* draw) const
{
	draw->AddQuadFilled(m_p1, m_p2, m_p3, m_p4, m_color);
}

void QuadMultiColor::draw(ImDrawList* draw) const
{
	if (((m_color1 | m_color2 | m_color3 | m_color4) & IM_COL32_A_MASK) == 0)
		return;

	ImVec2 verts[] = { m_p1, m_p2, m_p3, m_p4 };
	ImU32 colors[] = { m_color1, m_color2, m_color3, m_color4 };

	ImGui::ExtraDrawlist::AddConvexPolyFilledMultiColor(draw, verts, colors, IM_ARRAYSIZE(verts));
}

void Polyline::draw(ImDrawList* draw) const
{
	draw->AddPolyline(m_verts.data(), m_verts.size(), m_color, m_flags, m_thickness);
}

void Polygon::draw(ImDrawList* draw) const
{
	draw->AddConvexPolyFilled(m_verts.data(), m_verts.size(), m_color);
}

void PolygonMultiColor::draw(ImDrawList* draw) const
{
	ImGui::ExtraDrawlist::AddConvexPolyFilledMultiColor(draw, m_verts.data(), m_colors.data(), m_verts.size());
}

void Text::draw(ImDrawList* draw) const
{
	ImGui::PushFont(m_font);
	ImVec2 pos = m_pos;

	if (auto tsize = ImGui::CalcTextSize(m_text.c_str()); m_centred)
		pos.x -= tsize.x / 2.0f;

	if (m_dropShadow)
	{
		const auto alpha = ImGui::ColorConvertU32ToFloat4(m_color).w;
		draw->AddText({ pos.x + 1.0f, pos.y + 1.0f }, Color::U32(Colors::Black.getColorEditAlpha(alpha)), m_text.c_str());
	}

	draw->AddText(pos, m_color, m_text.c_str());

	ImGui::PopFont();
}

void TextSize::draw(ImDrawList* draw) const
{
	ImGui::PushFont(m_font);
	ImVec2 pos = m_pos;

	if (auto tsize = m_font->CalcTextSizeA(m_size, std::numeric_limits<float>::max(), 0.0f, m_text.c_str()); m_centred)
		pos.x -= tsize.x / 2.0f;

	if (m_dropShadow)
	{
		const auto alpha = ImGui::ColorConvertU32ToFloat4(m_color).w;
		draw->AddText(m_font, m_size, { pos.x + 1.0f, pos.y + 1.0f }, Color::U32(Colors::Black.getColorEditAlpha(alpha)), m_text.c_str());
	}

	draw->AddText(m_font, m_size, pos, m_color, m_text.c_str());

	ImGui::PopFont();
}

void Arc::draw(ImDrawList* draw) const
{
	draw->PathArcTo(m_centre, m_radius, m_aMin, m_aMax, m_segments);
	draw->PathStroke(m_color, m_flags, m_thickness);
}

```

`hack/render/structures.hpp`:

```hpp
#pragma once

#include <vector>
#include <string>

#include <imgui.h>

// raw drawing
namespace drawing
{
	// base class, no fields. Use for any geometric structure.
	class Draw
	{
	public:
		virtual void draw(ImDrawList* draw) const = 0;
	};

	class Line : public Draw
	{
	public:
		constexpr Line(const ImVec2& min, const ImVec2& max, ImU32 color, float thickness)
			: m_start{ min }, m_end{ max }, m_color{ color }, m_thickness{ thickness }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_start;
		ImVec2 m_end;
		ImU32 m_color;
		float m_thickness;
	};

	class Rectangle : public Draw
	{
	public:
		constexpr Rectangle(const ImVec2& min, const ImVec2& max, ImU32 color, float rounding, ImDrawFlags flags, float thickness)
			: m_min{ min }, m_max{ max }, m_color{ color }, m_rounding{ rounding }, m_flags{ flags }, m_thickness{ thickness }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_min;
		ImVec2 m_max;
		ImU32 m_color;
		ImDrawFlags m_flags;
		float m_thickness;
		float m_rounding;
	};

	class RectangleFilled : public Draw
	{
	public:
		constexpr RectangleFilled(const ImVec2& min, const ImVec2& max, ImU32 color, float rounding, ImDrawFlags flags)
			: m_min{ min }, m_max{ max }, m_color{ color }, m_rounding{ rounding }, m_flags{ flags }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_min;
		ImVec2 m_max;
		ImU32 m_color;
		float m_rounding;
		ImDrawFlags m_flags;
	};

	class RectangleGradient : public Draw
	{
	public:
		constexpr RectangleGradient(const ImVec2& min, const ImVec2& max, ImU32 color1, ImU32 color2, bool horizontal)
			: m_min{ min }, m_max{ max }, m_color1{ color1 }, m_color2{ color2 }, m_horizontal{ horizontal }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_min;
		ImVec2 m_max;
		ImU32 m_color1; // left up / normal color
		ImU32 m_color2; // right up
		ImDrawFlags m_flags;
		bool m_horizontal;
	};

	class RectangleMultiColor : public Draw
	{
	public:
		constexpr RectangleMultiColor(const ImVec2& min, const ImVec2& max, ImU32 color1, ImU32 color2, ImU32 color3, ImU32 color4)
			: m_min{ min }, m_max{ max }, m_color1{ color1 }, m_color2{ color2 }, m_color3{ color3 }, m_color4{ color4 }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_min;
		ImVec2 m_max;
		ImU32 m_color1; // left up / normal color
		ImU32 m_color2; // right up
		ImU32 m_color3; // right bottom
		ImU32 m_color4; // left bottom
		ImDrawFlags m_flags;
		bool m_horizontal;
		float m_rounding;
	};

	class Circle : public Draw
	{
	public:
		constexpr Circle(const ImVec2& centre, float radius, int segments, ImU32 color, float thickness)
			: m_centre{ centre }, m_radius{ radius }, m_segments{ segments }, m_color{ color }, m_thickness{ thickness }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_centre;
		float m_radius;
		ImU32 m_color;
		int m_segments;
		float m_thickness;
	};

	class CircleFilled : public Draw
	{
	public:
		constexpr CircleFilled(const ImVec2& centre, float radius, int segments, ImU32 color)
			: m_centre{ centre }, m_radius{ radius }, m_segments{ segments }, m_color{ color }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_centre;
		float m_radius;
		ImU32 m_color;
		int m_segments;
	};

	class Triangle : public Draw
	{
	public:
		constexpr Triangle(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 color, float thickness)
			: m_p1{ p1 }, m_p2{ p2 }, m_p3{ p3 }, m_color{ color }, m_thickness{ thickness }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_p1;
		ImVec2 m_p2;
		ImVec2 m_p3;
		ImU32 m_color;
		float m_thickness;
	};

	class TriangleFilled : public Draw
	{
	public:
		constexpr TriangleFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 color)
			: m_p1{ p1 }, m_p2{ p2 }, m_p3{ p3 }, m_color{ color }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_p1;
		ImVec2 m_p2;
		ImVec2 m_p3;
		ImU32 m_color;
	};

	class Quad : public Draw
	{
	public:
		constexpr Quad(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 color, float thickness)
			: m_p1{ p1 }, m_p2{ p2 }, m_p3{ p3 }, m_p4{ p4 }, m_color{ color }, m_thickness{ thickness }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_p1;
		ImVec2 m_p2;
		ImVec2 m_p3;
		ImVec2 m_p4;
		ImU32 m_color;
		float m_thickness;
	};

	class QuadFilled : public Draw
	{
	public:
		constexpr QuadFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 color)
			: m_p1{ p1 }, m_p2{ p2 }, m_p3{ p3 }, m_p4{ p4 }, m_color{ color }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_p1;
		ImVec2 m_p2;
		ImVec2 m_p3;
		ImVec2 m_p4;
		ImU32 m_color;
	};

	class QuadMultiColor : public Draw
	{
	public:
		constexpr QuadMultiColor(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 color1, ImU32 color2, ImU32 color3, ImU32 color4)
			: m_p1{ p1 }, m_p2{ p2 }, m_p3{ p3 }, m_p4{ p4 }, m_color1{ color1 }, m_color2{ color2 }, m_color3{ color3 }, m_color4{ color4 }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_p1;
		ImVec2 m_p2;
		ImVec2 m_p3;
		ImVec2 m_p4;
		ImU32 m_color1; // left up / normal color
		ImU32 m_color2; // right up
		ImU32 m_color3; // right bottom
		ImU32 m_color4; // left bottom
	};

	class Polyline : public Draw
	{
	public:
		constexpr Polyline(const std::vector<ImVec2>& verts, ImU32 color, ImDrawFlags flags, float thickness)
			: m_count{ verts.size() }, m_verts{ verts }, m_color{ color }, m_flags{ flags }, m_thickness{ thickness }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		size_t m_count;
		std::vector<ImVec2> m_verts;
		ImU32 m_color;
		ImDrawFlags m_flags;
		float m_thickness;
	};

	class Polygon : public Draw
	{
	public:
		constexpr Polygon(const std::vector<ImVec2>& verts, ImU32 color)
			: m_count{ verts.size() }, m_verts{ verts }, m_color{ color }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		size_t m_count;
		std::vector<ImVec2> m_verts;
		ImU32 m_color;
	};

	class PolygonMultiColor : public Draw
	{
	public:
		constexpr PolygonMultiColor(const std::vector<ImVec2>& verts, const std::vector<ImU32>& colors)
			: m_count{ verts.size() }, m_verts{ verts }, m_colors{ colors }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		size_t m_count;
		std::vector<ImVec2> m_verts;
		std::vector<ImU32> m_colors;
	};

	class Text : public Draw
	{
	public:
		constexpr Text(ImFont* font, const ImVec2& pos, ImU32 color, const std::string& text, bool dropShadow, bool centered)
			: m_font{ font }, m_pos{ pos }, m_color{ color }, m_text{ text }, m_dropShadow{ dropShadow }, m_centred{ centered }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_pos;
		ImFont* m_font;
		std::string m_text;
		ImU32 m_color;
		bool m_dropShadow;
		bool m_centred;
	};

	class TextSize : public Draw
	{
	public:
		constexpr TextSize(float fontSize, ImFont* font, const ImVec2& pos, ImU32 color, const std::string& text, bool dropShadow, bool centered)
			: m_size{ fontSize }, m_font{ font }, m_pos{ pos }, m_color{ color }, m_text{ text }, m_dropShadow{ dropShadow }, m_centred{ centered }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_pos;
		ImFont* m_font;
		std::string m_text;
		ImU32 m_color;
		bool m_dropShadow;
		bool m_centred;
		float m_size;
	};

	class Arc : public Draw
	{
	public:
		constexpr Arc(const ImVec2& centre, float radius, float aMin, float aMax, int segments, ImU32 color, ImDrawFlags flags, float thickness)
			: m_centre{ centre }, m_radius{ radius }, m_aMin{ aMin }, m_aMax{ aMax }, m_segments{ segments }, m_color{ color }, m_flags{ flags }, m_thickness{ thickness }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_centre;
		float m_radius;
		float m_aMin;
		float m_aMax;
		int m_segments;
		ImU32 m_color;
		ImDrawFlags m_flags;
		float m_thickness;
	};
}
```

`hack/resources/csgo-legit.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Polish (Poland) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_PLK)
LANGUAGE LANG_POLISH, SUBLANG_DEFAULT

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// PNG
//

IDB_PNG1                PNG                     "hack\\deps\\images\\fatchad.png"

#endif    // Polish (Poland) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`hack/resources/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by csgo-legit.rc
//
#define IDB_PNG1                        101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`hack/setup/SEHcatch.cpp`:

```cpp
#include "SEHcatch.hpp"

#include <utilities/console/console.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>

#include <DbgHelp.h>
#include <unordered_map>

// exception to string
#define E2S(e) { e, #e }

#pragma region crash_map
const std::unordered_map<DWORD, const char*> crashNames
{
	E2S(EXCEPTION_ACCESS_VIOLATION),
	E2S(EXCEPTION_READ_FAULT),
	E2S(EXCEPTION_DATATYPE_MISALIGNMENT),
	E2S(EXCEPTION_BREAKPOINT),
	E2S(EXCEPTION_SINGLE_STEP),
	E2S(EXCEPTION_ARRAY_BOUNDS_EXCEEDED),
	E2S(EXCEPTION_FLT_DENORMAL_OPERAND),
	E2S(EXCEPTION_FLT_DIVIDE_BY_ZERO),
	E2S(EXCEPTION_FLT_INEXACT_RESULT),
	E2S(EXCEPTION_FLT_INVALID_OPERATION),
	E2S(EXCEPTION_FLT_OVERFLOW),
	E2S(EXCEPTION_FLT_STACK_CHECK),
	E2S(EXCEPTION_FLT_UNDERFLOW),
	E2S(EXCEPTION_INT_DIVIDE_BY_ZERO),
	E2S(EXCEPTION_INT_OVERFLOW),
	E2S(EXCEPTION_PRIV_INSTRUCTION),
	E2S(EXCEPTION_NONCONTINUABLE_EXCEPTION),
	E2S(EXCEPTION_STACK_OVERFLOW),
	E2S(EXCEPTION_INVALID_DISPOSITION),
	E2S(EXCEPTION_GUARD_PAGE),
	E2S(EXCEPTION_INVALID_HANDLE)
};
#pragma endregion

#undef E2S

void SEHcatch::printStack()
{
	void* stack[MAX_LENGTH];
	const auto process = LI_FN_CACHED(GetCurrentProcess)();
	LI_FN_CACHED(SymInitialize)(process, NULL, TRUE);

	const auto frames = LI_FN_CACHED(CaptureStackBackTrace)(NULL, MAX_FRAMES, stack, nullptr);
	const auto symbol = (SYMBOL_INFO*)calloc(sizeof(SYMBOL_INFO) + 256 * sizeof(CHAR), 1);
	symbol->MaxNameLen = MAX_LENGTH;
	symbol->SizeOfStruct = sizeof(SYMBOL_INFO);

	for (int i = 3; i < frames; i++) // skip 3 records which are useless to print, you might call some other walkstack functions to get more info
	{
		LI_FN_CACHED(SymFromAddr)(process, reinterpret_cast<DWORD64>(stack[i]), NULL, symbol);
		LOG_ERR(XOR("{}: {} - 0x{:X}"), frames - i - 1, symbol->Name, symbol->Address);
	}
	free(symbol);
}

LONG WINAPI SEHcatch::memErrorCatch(EXCEPTION_POINTERS* pExceptionInfo)
{
	const auto code = pExceptionInfo->ExceptionRecord->ExceptionCode;

	for (const auto& [crashCode, crashName] : crashNames)
	{
		if (code == crashCode)
		{
			static bool bOnce = [=]()
			{
				const auto symbol = (SYMBOL_INFO*)calloc(sizeof(SYMBOL_INFO) + 256 * sizeof(CHAR), 1);
				symbol->MaxNameLen = MAX_LENGTH;
				symbol->SizeOfStruct = sizeof(SYMBOL_INFO);

				const auto addr = pExceptionInfo->ExceptionRecord->ExceptionAddress;
				const auto name = symbol->Name;
				const auto flag = pExceptionInfo->ExceptionRecord->ExceptionFlags;
				const auto params = pExceptionInfo->ExceptionRecord->NumberParameters;

				const auto info = FORMAT(XOR("Exception (fatal) {} at address {} ({}), flags - {}, params - {}"), crashName, addr, name, flag, params);
				// x86
				LOG_ERR(XOR("EAX - 0x{:X}"), pExceptionInfo->ContextRecord->Eax);
				LOG_ERR(XOR("EBP - 0x{:X}"), pExceptionInfo->ContextRecord->Ebp);
				LOG_ERR(XOR("EBX - 0x{:X}"), pExceptionInfo->ContextRecord->Ebx);
				LOG_ERR(XOR("ECX - 0x{:X}"), pExceptionInfo->ContextRecord->Ecx);
				LOG_ERR(XOR("EDI - 0x{:X}"), pExceptionInfo->ContextRecord->Edi);
				LOG_ERR(XOR("EDX - 0x{:X}"), pExceptionInfo->ContextRecord->Edx);
				LOG_ERR(XOR("EIP - 0x{:X}"), pExceptionInfo->ContextRecord->Eip);
				LOG_ERR(XOR("ESI - 0x{:X}"), pExceptionInfo->ContextRecord->Esi);
				LOG_ERR(XOR("ESP - 0x{:X}"), pExceptionInfo->ContextRecord->Esp);

				LOG_ERR(info);
				printStack();
				LI_FN(MessageBoxA)(nullptr, info.c_str(), XOR("Fatal error!"), MB_ICONERROR | MB_OK);
				free(symbol);
				return true;
			} ();

			return EXCEPTION_EXECUTE_HANDLER;
		}
	}

	return EXCEPTION_CONTINUE_SEARCH;
}
```

`hack/setup/SEHcatch.hpp`:

```hpp
#pragma once

#include <Windows.h>

class SEHcatch
{
public:
	SEHcatch() = delete;
	static LONG WINAPI memErrorCatch(EXCEPTION_POINTERS* pExceptionInfo);
private:
	static void printStack();
	static constexpr uint32_t MAX_FRAMES = 1024;
	static constexpr uint32_t MAX_LENGTH = 1024;
};
```

`hack/setup/setup.cpp`:

```cpp
#include "setup.hpp"

#include "SEHcatch.hpp"

#include <config/vars.hpp>
#include <utilities/console/console.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <utilities/simpleTimer.hpp>
#include <SDK/helpers/netvars.hpp>
#include <render/render.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <menu/x88Menu/x88menu.hpp>
#include <menu/GUI-ImGui/menu.hpp>
#include <cheats/hooks/hooks.hpp>
#include <cheats/classes/base.hpp>
#include <cheats/features/events/events.hpp>
#include <cheats/features/discord/discord.hpp>
#include <cheats/features/cache/cache.hpp>
#include <cheats/game/globals.hpp>
#include <cheats/game/game.hpp>
#include <gamememory/memory.hpp>
#include <utilities/res.hpp>
#include <cheats/hooks/wndProc.hpp>

#include <discord_register.h>

#include <chrono>
#include <Windows.h>

DiscordPresence Setup::m_dc;

bool Setup::init(void* instance)
{
	// pass custom handler
	// commented due to false-positives thrown by steam server
	// they handle it somehow to prevent such crash, but exception pointers report it
	//AddVectoredExceptionHandler(TRUE, SEHcatch::memErrorCatch);

	TimeCount initTimer{};
	// might need to rewrite this later with setting those names
	config.setFolder(std::filesystem::path{ XOR("Bartis_internal") } / XOR("csgo"));
	console::setLogger(XOR("CSGO DEBUG"), XOR("hack.log"));
	try
	{
		config.init(
			XOR("default.cfg"), XOR("load.LOAD"),
			XOR("utility"));
		g_Memory.init();
		netvarMan.init();
		wndProcSys::init();
		BaseHack::initAll();
		surfaceRender.init();
		x88menu.init();
		hooks::init();
		EntityCache::init();
	}
	catch (const std::exception& err)
	{
		LI_FN(MessageBoxA)(nullptr, err.what(), XOR("Runtime hack error"), MB_OK | MB_ICONERROR);
		LOG_ERR(XOR("Runtime hack error {}"), err.what());
		LI_FN(FreeLibraryAndExitThread)(static_cast<HMODULE>(instance), EXIT_FAILURE);
	}

	initTimer.end();
	LOG_INFO(XOR("main thread took {:.5f}s"), initTimer.getTime());
	m_inited = true;

	return true;
}

void Setup::shutdown(void* instance)
{
	globals::isShutdown = true;

	//RemoveVectoredExceptionHandler(globals::instance);
	wndProcSys::shutdown();
	BaseHack::shutdownAll();
	Resource::destroyAll();
	events::shutdown();
	hooks::shutdown();
	menu.shutdown();
	LOG_INFO(XOR("Hack shutdown"));
	console::shutdown();
	m_dc.shutdown();

	LI_FN(FreeLibraryAndExitThread)(static_cast<HMODULE>(instance), EXIT_SUCCESS);
}

void Setup::looper(void* instance)
{
	using namespace std::chrono_literals;

	m_dc.init();
	while (!vars::keys->panic.isPressed())
	{
		if (m_inited)
		{
			m_dc.run();
			std::this_thread::sleep_for(1s);
		}
	}

	shutdown(instance);
}
```

`hack/setup/setup.hpp`:

```hpp
#pragma once

class DiscordPresence;

struct Setup
{
public:
	static bool init([[maybe_unused]] void* instance);
	static void looper([[maybe_unused]] void* instance);
	static void shutdown([[maybe_unused]] void* instance);
private:
	inline static bool m_inited = false;

	// specific for looper
	static DiscordPresence m_dc;
};
```

`hack/utilities/console/console.cpp`:

```cpp
#include "console.hpp"

#include <menu/GUI-ImGui/imguiaddons.hpp>
#include <utilities/utilities.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <render/Color.hpp>

#include <Windows.h>

void console::setLogger(const std::string_view title, const std::string_view logName)
{
	detail::m_logName = logName;
	assert(title.empty() == false); // not needed in release, will make code ugly if we add #idfefs everywhere
	assert(logName.empty() == false);

	detail::m_fileStream = std::ofstream{ config.getHackPath() / detail::m_logName, std::ofstream::out | std::ofstream::app };

#ifdef _DEBUG
	AllocConsole();
	freopen_s(reinterpret_cast<FILE**>(stdout), "CONOUT$", "w", stdout);
	SetConsoleTitleA(title.data());
#endif
}

void console::detail::setColor(ColorsConsole color)
{
#ifdef _DEBUG
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), E2T(color));
#endif
	return;
}

void console::detail::reset()
{
#ifdef _DEBUG
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), E2T(ColorsConsole::CONSOLE_WHITE));
#endif
	return;
}

void console::shutdown() 
{
#ifdef _DEBUG
	fclose(stdout);
	FreeConsole();
#endif

	detail::m_fileStream.close();
	return;
}

void console::detail::addLogToStream(TypeLogs type, const std::string& buf)
{
#ifdef _DEBUG
	std::cout << buf;
#endif

	m_fileStream << buf;
	g_LogDrawer->log.add(type, buf);
}

bool console::detail::isPossibleToLog(TypeLogs type)
{
#ifndef _DEBUG
	if (type == TypeLogs::LOG_ERR || type == TypeLogs::LOG_INFO)
		return true;

	return false;
#else
	return true;
#endif
}

std::string console::detail::generateTimeLog()
{
	return FORMAT(XOR("[{}] "), utilities::getTime());
}

void console::detail::addSigns(TypeLogs type)
{
#ifdef _DEBUG
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), E2T(colorsForConsole[type]));
	std::cout << FORMAT(XOR("{} {}"), signs[type], consoleStrings[type]);
	reset();
#endif
}
```

`hack/utilities/console/console.hpp`:

```hpp
#pragma once

#include "consoleUtils.hpp"

#include <config/config.hpp>
#include <render/Color.hpp>

#include <string>
#include <unordered_map>
#include <iostream>
#include <fstream>
#include <mutex>
#include <cassert>
#include "consoleDraw.hpp"

struct SDKColor;

namespace console
{
	void setLogger(const std::string_view title, const std::string_view logName);
	void shutdown();
	template<typename... Args_t>
	inline void log(TypeLogs type, const std::string_view fmt, Args_t&&... args);

	namespace detail
	{
		void setColor(ColorsConsole color);
		void reset();
		void addSigns(TypeLogs type);
		void addLogToStream(TypeLogs type, const std::string& buf);
		bool isPossibleToLog(TypeLogs type);
		std::string generateTimeLog();

		inline std::ofstream m_fileStream;
		inline std::string m_logName;
		inline std::mutex m_mutex;

		inline std::unordered_map<TypeLogs, ColorsConsole> colorsForConsole
		{
			{ TypeLogs::LOG_ERR, ColorsConsole::CONSOLE_DARKRED },
			{ TypeLogs::LOG_WARN, ColorsConsole::CONSOLE_YELLOW },
			{ TypeLogs::LOG_INFO, ColorsConsole::CONSOLE_WHITE },
			{ TypeLogs::LOG_DEBUG, ColorsConsole::CONSOLE_CYAN },
		};
		inline std::unordered_map<TypeLogs, std::string_view> consoleStrings
		{
			{ TypeLogs::LOG_ERR, "[err]"},
			{ TypeLogs::LOG_WARN, "[warn]"},
			{ TypeLogs::LOG_INFO, "[info]"},
			{ TypeLogs::LOG_DEBUG, "[debug]"},
		};
		inline std::unordered_map<TypeLogs, Color> colorsForView
		{
			{ TypeLogs::LOG_ERR, Colors::Red },
			{ TypeLogs::LOG_WARN, Colors::Yellow },
			{ TypeLogs::LOG_INFO, Colors::White },
			{ TypeLogs::LOG_DEBUG, Colors::Cyan },
		};
		inline std::unordered_map<TypeLogs, char> signs
		{
			{ TypeLogs::LOG_ERR, '!'},
			{ TypeLogs::LOG_WARN, '^'},
			{ TypeLogs::LOG_INFO, '+'},
			{ TypeLogs::LOG_DEBUG, '*'},
		};
	}
};

// sorry for using cout
// https://youtu.be/TxhQQLGafZ4?t=78
// :D

template<typename... Args_t>
inline void console::log(TypeLogs type, const std::string_view fmt, Args_t&&... args)
{
	std::scoped_lock lock{ detail::m_mutex };

	if (!detail::isPossibleToLog(type))
		return;

	if (fmt.empty())
		return;

	detail::addSigns(type);
	std::string buffer = detail::generateTimeLog();
	if constexpr (sizeof...(args) > 0)
		buffer += std::vformat(fmt, std::make_format_args(args...));
	else
		buffer += fmt;

	buffer += '\n';

	detail::addLogToStream(type, buffer);
}

#define LOG_INFO(fmt, ...) console::log(TypeLogs::LOG_INFO, fmt, __VA_ARGS__)
#define LOG_ERR(fmt, ...) console::log(TypeLogs::LOG_ERR, fmt, __VA_ARGS__)
#define LOG_WARN(fmt, ...) console::log(TypeLogs::LOG_WARN, fmt, __VA_ARGS__)
#define LOG_DEBUG(fmt, ...) console::log(TypeLogs::LOG_DEBUG, fmt, __VA_ARGS__)
```

`hack/utilities/console/consoleDraw.cpp`:

```cpp
#include "consoleDraw.hpp"
#include "console.hpp"

#include <render/Color.hpp>
#include <utilities/tools/tools.hpp>
#include <menu/GUI-ImGui/animations.hpp>

void LogDrawer::ExampleAppLog::draw(const char* title, bool* p_open)
{
	if (!ImGui::Begin(title, p_open))
	{
		ImGui::End();
		return;
	}

	filter.Draw("Filter");

	ImGui::SameLine();
	bool clear = ImGui::Animations::Button("Clear");
	ImGui::SameLine();
	bool copy = ImGui::Animations::Button("Copy");
	ImGui::SameLine();
	if (ImGui::Animations::Button("Wrap"))
		wrap = !wrap;

	ImGui::Spacing();

	ImGui::BeginChild("scrolling", ImVec2(0, 0), false, wrap ? ImGuiWindowFlags_AlwaysHorizontalScrollbar : ImGuiWindowFlags_HorizontalScrollbar);

	if (clear)
		buffer.clear();
	if (copy)
		ImGui::LogToClipboard();

	ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));
	if (filter.IsActive())
	{
		for (const auto [text, color] : buffer)
		{
			if (filter.PassFilter(text.data()))
			{
				if (wrap)
					ImGui::PushTextWrapPos();
				ImGui::PushStyleColor(ImGuiCol_Text, Color::U32(console::detail::colorsForView.at(color)));
				ImGui::TextUnformatted(text.data());
				ImGui::PopStyleColor();
				if (wrap)
					ImGui::PopTextWrapPos();
			}
		}
	}
	else
	{
		ImGuiListClipper clipper;
		clipper.Begin(buffer.size());
		while (clipper.Step())
		{
			for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
			{
				const auto [text, color] = buffer.at(i);

				if (wrap)
					ImGui::PushTextWrapPos();
				ImGui::PushStyleColor(ImGuiCol_Text, Color::U32(console::detail::colorsForView.at(color)));
				ImGui::TextUnformatted(text.data());
				ImGui::PopStyleColor();
				if (wrap)
					ImGui::PopTextWrapPos();
			}
		}
		clipper.End();
	}
	ImGui::PopStyleVar();

	if (ImGui::GetScrollY() >= ImGui::GetScrollMaxY())
		ImGui::SetScrollHereY(1.0f);

	ImGui::EndChild();
	ImGui::End();
}

void LogDrawer::draw()
{
	if (m_opened)
		log.draw(XOR("Logging Console"), &m_opened);
}
```

`hack/utilities/console/consoleDraw.hpp`:

```hpp
#pragma once

#include "consoleUtils.hpp"

#include <menu/GUI-ImGui/imguiaddons.hpp>
#include <cheats/classes/renderableToPresent.hpp>

#include <vector>
#include <string>

class LogDrawer : protected  RenderablePresentType
{
public:
	LogDrawer()
		: RenderablePresentType{}
	{}

	void handleKeys() { m_opened = !m_opened; };
protected:
	virtual void draw() override;
public:
	// from demo, slight edit, usage same as normal console.log
	struct ExampleAppLog
	{
		template<typename... Args_t>
		void add(TypeLogs type, const std::string_view fmt, Args_t&&... args);
		void draw(const char* title, bool* p_open = NULL);
	private:
		bool wrap = false;
		ImGuiTextFilter filter;
		std::vector<std::pair<std::string, TypeLogs>> buffer;
	} log;
private:
	bool m_opened = false;
};

GLOBAL_FEATURE(LogDrawer);

template<typename... Args_t>
void LogDrawer::ExampleAppLog::add(TypeLogs logs, const std::string_view fmt, Args_t&&... args)
{
	std::string text{ };
	if constexpr (sizeof...(args) > 0)
		text += std::vformat(fmt, std::make_format_args(args...));
	else
		text += fmt;

	this->buffer.emplace_back(std::make_pair(text, logs));
}
```

`hack/utilities/console/consoleUtils.hpp`:

```hpp
#pragma once

#include <consoleapi2.h>

enum class TypeLogs
{
	LOG_ERR,
	LOG_WARN,
	LOG_INFO,
	LOG_DEBUG
};

enum class ColorsConsole
{
	CONSOLE_WHITE = FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE,
	CONSOLE_BLACK = NULL,
	CONSOLE_DARKBLUE = FOREGROUND_BLUE,
	CONSOLE_DARKGREEN = FOREGROUND_GREEN,
	CONSOLE_DARKCYAN = FOREGROUND_GREEN | FOREGROUND_BLUE,
	CONSOLE_DARKRED = FOREGROUND_RED,
	CONSOLE_DARKMAGENTA = FOREGROUND_RED | FOREGROUND_BLUE,
	CONSOLE_DARKYELLOW = FOREGROUND_RED | FOREGROUND_GREEN,
	CONSOLE_DARKGRAY = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE,
	CONSOLE_GRAY = FOREGROUND_INTENSITY,
	CONSOLE_BLUE = FOREGROUND_INTENSITY | FOREGROUND_BLUE,
	CONSOLE_GREEN = FOREGROUND_INTENSITY | FOREGROUND_GREEN,
	CONSOLE_CYAN = FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_BLUE,
	CONSOLE_RED = FOREGROUND_INTENSITY | FOREGROUND_RED,
	CONSOLE_MAGENTA = FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_BLUE,
	CONSOLE_YELLOW = FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN,
};
```

`hack/utilities/inputSystem.cpp`:

```cpp
#include "inputSystem.hpp"

#include <cheats/game/globals.hpp>
#include <cheats/game/game.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/interfaces/interfaces.hpp>

enum class KeyState
{
	OFF,
	DOWN,
	UP,
	PRESS
};

void KeysHandler::run(UINT message, WPARAM wparam)
{
	if (game::isChatOpen() || memory::interfaces::engine->isConsoleVisible())
		return;

	// init starting keys, undefined
	m_vKey = 0;
	auto state = KeyState::OFF;

	switch (message)
	{
	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
	{
		if (wparam < KEYS_SIZE)
		{
			m_vKey = wparam;
			state = KeyState::DOWN;
		}
	}
	break;
	case WM_KEYUP:
	case WM_SYSKEYUP:
	{
		if (wparam < KEYS_SIZE)
		{
			m_vKey = wparam;
			state = KeyState::UP;
		}
	}
	break;
	case WM_LBUTTONDOWN:
	case WM_LBUTTONUP:
	case WM_LBUTTONDBLCLK:
	{
		m_vKey = VK_LBUTTON;
		state = message == WM_LBUTTONUP ? KeyState::UP : KeyState::DOWN;
	}
	break;
	case WM_RBUTTONDOWN:
	case WM_RBUTTONUP:
	case WM_RBUTTONDBLCLK:
	{
		m_vKey = VK_RBUTTON;
		state = message == WM_RBUTTONUP ? KeyState::UP : KeyState::DOWN;
	}
	break;
	case WM_MBUTTONDOWN:
	case WM_MBUTTONUP:
	case WM_MBUTTONDBLCLK:
	{
		m_vKey = VK_MBUTTON;
		state = message == WM_MBUTTONUP ? KeyState::UP : KeyState::DOWN;
	}
	break;
	case WM_XBUTTONDOWN:
	case WM_XBUTTONUP:
	case WM_XBUTTONDBLCLK:
	{
		m_vKey = (GET_XBUTTON_WPARAM(wparam) == XBUTTON1 ? VK_XBUTTON1 : VK_XBUTTON2);
		state = message == WM_XBUTTONUP ? KeyState::UP : KeyState::DOWN;
	}
	break;
	default:
		break;
	}

	// save the key
	if (state == KeyState::DOWN)
	{
		m_keyStates.set(m_vKey);
	}
	else if (state == KeyState::UP)
	{
		m_keyStates.reset(m_vKey);
		m_keyPressStates.set(m_vKey);
	}
}

bool KeysHandler::isKeyDown(UINT vKey) const
{
	return m_keyStates[vKey];
}

bool KeysHandler::isKeyPressed(UINT vKey) const
{
	// trick to allow method to be const
	auto* temp = const_cast<KeysHandler*>(this);

	if (temp->m_keyPressStates[vKey])
	{
		temp->m_keyPressStates.reset(vKey);
		return true;
	}
	return false;
}

bool KeysHandler::isKeyDown(const std::initializer_list<UINT>& vKeys) const
{
	for (const auto vKey : vKeys)
	{
		if (!m_keyStates[vKey])
			return false;
	}
	return true;
}

bool KeysHandler::isKeyPressed(const std::initializer_list<UINT>& vKeys) const
{
	// trick to allow method to be const
	auto* temp = const_cast<KeysHandler*>(this);

	for (const auto vKey : vKeys)
	{
		if (!temp->m_keyPressStates[vKey])
			return false;
	}

	for (const auto vKey : vKeys)
	{
		temp->m_keyPressStates.reset(vKey);
	}
	return true;
}
```

`hack/utilities/inputSystem.hpp`:

```hpp
#pragma once

#include <array>
#include <unordered_set>
#include <Windows.h>
#include <initializer_list>
#include <bitset>

class KeysHandler
{
public:
    KeysHandler() = default;
    void run(UINT message, WPARAM wparam);
    [[nodiscard]] bool isKeyDown(UINT vKey) const;
    [[nodiscard]] bool isKeyPressed(UINT vKey) const;
    [[nodiscard]] bool isKeyPressed(const std::initializer_list<UINT>& vKeys) const;
    [[nodiscard]] bool isKeyDown(const std::initializer_list<UINT>& vKeys) const;
private:
    inline constexpr static size_t KEYS_SIZE = 256;
    std::bitset<KEYS_SIZE> m_keyStates;
    std::bitset<KEYS_SIZE> m_keyPressStates;
    int m_vKey = 0;
};

inline KeysHandler inputHandler;
```

`hack/utilities/math/math.cpp`:

```cpp
#include "math.hpp"

Vec3 math::calcAngleRelative(const Vec3& source, const Vec3& destination, const Vec3& viewAngles)
{
	const auto delta = destination - source;

	Vec3 angles
	{
		RAD2DEG(std::atan2(-delta[2], std::hypot(delta[0], delta[1]))) - viewAngles[0],
		RAD2DEG(std::atan2(delta[1], delta[0])) - viewAngles[1],
		0.0f
	};

	return angles.normalize();
}

Vec3 math::calcAngle(const Vec3& source, const Vec3& destination)
{
	const auto delta = destination - source;

	Vec3 angles
	{
		RAD2DEG(std::atan2(-delta[2], std::hypot(delta[0], delta[1]))),
		RAD2DEG(std::atan2(delta[1], delta[0])),
		0.0f
	};

	return angles.normalize();
}

float math::calcFov(const Vec3& source, const Vec3& destination, const Vec3& viewAngles)
{
	const auto angle = calcAngleRelative(source, destination, viewAngles);
	const auto fov = std::hypot(angle[0], angle[1]);
	return fov;
}

float math::calcFovReal(const Vec3& source, const Vec3& destination, const Vec3& viewAngles)
{
	float dist = source.distTo(destination);
	float realDist = dist / 10.0f;

	auto start = angleVec(viewAngles) * realDist;
	auto end = angleVec(calcAngle(source, destination)) * realDist;

	return start.distTo(end);
}

Vec3 math::transformVector(const Vec3& in, const Matrix3x4& matrix)
{
	return Vec3(in.dot(Vec3{ matrix[0].data() }) + matrix[0][3], in.dot(Vec3{ matrix[1].data() }) + matrix[1][3],
		in.dot(Vec3{ matrix[2].data() }) + matrix[2][3]);
}

Vec3 math::angleVec(const Vec3& angle)
{
	auto sy = std::sin(DEG2RAD(angle[1]));
	auto cy = std::cos(DEG2RAD(angle[1]));

	auto sp = std::sin(DEG2RAD(angle[0]));
	auto cp = std::cos(DEG2RAD(angle[0]));

	return Vec3{ cp * cy, cp * sy, -sp };
}

std::tuple<Vec3, Vec3, Vec3> math::angleVectors(const Vec3& angle)
{
	auto sy = std::sin(DEG2RAD(angle[1]));
	auto cy = std::cos(DEG2RAD(angle[1]));

	auto sp = std::sin(DEG2RAD(angle[0]));
	auto cp = std::cos(DEG2RAD(angle[0]));

	auto sr = std::sin(DEG2RAD(angle[2]));
	auto cr = std::cos(DEG2RAD(angle[2]));

	Vec3 forward
	{
		cp * cy,
		cp * sy,
		-sp
	};

	Vec3 right
	{
		-1.0f * sr * sp * cy + -1.0f * cr * -sy,
		-1.0f * sr * sp * sy + -1.0f * cr * cy,
		-1.0f * sr * cp
	};	

	Vec3 up
	{
		cr * sp * cy + -sr * -sy,
		cr * sp * sy + -sr * cy,
		cr * cp
	};

	return { forward, right, up };
}

float math::normalizeYaw(float yaw)
{
	while (yaw > 180.0f)
		yaw -= 360.0f;

	while (yaw < -180.0f)
		yaw += 360.0f;

	return yaw;
}

float math::normalizePitch(float pitch)
{
	while (pitch > 89.0f)
		pitch -= 180.0f;

	while (pitch < -89.0f)
		pitch += 180.0f;

	return pitch;
}

Vec3 math::vectorToAngle(const Vec3& vec)
{
	Vec3 angle;
	if (vec[0] == 0.0f && vec[1] == 0.0f)
	{
		angle[0] = (vec[2] > 0.0f) ? 270.0f : 90.0f;
		angle[1] = 0.0f;
	}
	else
	{
		angle[0] = RAD2DEG(std::atan2(-vec[2], std::hypot(vec[0], vec[1])));
		angle[1] = RAD2DEG(std::atan2(vec[1], vec[0]));

		if (angle[1] > 90.0f)
			angle[1] -= 180.0f;
		else if (angle[1] < 90.0f)
			angle[1] += 180.0f;
		else if (angle[1] == 90.0f)
			angle[1] = 0.0f;
	}
	angle[2] = 0.0f;
	return angle;
}

std::pair<Vec3, Vec3> math::transformAABB(const Matrix3x4& transform, const Vec3& mins, const Vec3& maxs)
{
	Vec3 localCenter = mins + maxs;
	localCenter *= 0.5f;

	Vec3 localExtents = maxs - localCenter;

	Vec3 worldCenter = transformVector(localCenter, transform);

	Vec3 worldExtents;

	worldExtents[0] = localExtents.dot(Vec3{ transform[0].data() });
	worldExtents[1] = localExtents.dot(Vec3{ transform[1].data() });
	worldExtents[2] = localExtents.dot(Vec3{ transform[2].data() });

	return {
		worldCenter - worldExtents,
		worldCenter + worldExtents
	};
}

#include <imgui_internal.h>
#include <algorithm>

static constexpr float orient(const ImVec2& a, const ImVec2& b, const ImVec2& c)
{
	return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
}

std::optional<std::vector<ImVec2>> math::grahamScan(std::span<const ImVec2> points)
{
	// case when it's impossible
	if (points.size() < 3)
		std::nullopt;

	// make a temp copy to allow use swap
	std::vector<ImVec2> v{ points.begin(), points.end() };

	// now at index 0 we have most left point
	std::swap(v.at(0), *std::min_element(v.begin(), v.end(),
		// is left? a lexicographically before b
		[](const ImVec2& a, const ImVec2& b) constexpr
		{
			return (a.x < b.x || (a.x == b.x && a.y < b.y));
		}
	));

	std::sort(v.begin() + 1, v.end(),
		[p0 = v.at(0)](const ImVec2& a, const ImVec2& b) constexpr
		{
			auto _orient = orient(p0, a, b);
			return _orient == 0.0f ? ImLengthSqr(p0 - a) < ImLengthSqr(p0 - b) : _orient < 0.0f;
		}
	);

	std::vector<ImVec2> hull;

	for (const auto& el : v)
	{
		while (hull.size() > 1 && orient(hull[hull.size() - 2], hull[hull.size() - 1], el) >= 0.0f)
			hull.pop_back();

		hull.push_back(el);
	}

	return hull;
}

std::optional<std::vector<ImVec2>> math::giftWrap(std::span<const ImVec2> points)
{
	// case when it's impossible
	if (points.size() < 3)
		return std::nullopt;

	// make a temp copy to allow use swap
	std::vector<ImVec2> v{ points.begin(), points.end() };

	// now at index 0 we have most left point
	std::swap(v.at(0), *std::min_element(v.begin(), v.end(),
		// is left? a lexicographically before b
		[](const ImVec2& a, const ImVec2& b) constexpr
		{
			return (a.x < b.x || (a.x == b.x && a.y < b.y));
		}
	));
	
	std::vector<ImVec2> hull;

	auto p0 = v.at(0);
	auto h0 = hull.at(0);
	do {
		hull.push_back(p0);
		std::swap(p0, *std::min_element(v.begin() + 1, v.end(),
			[p0](const ImVec2& a, const ImVec2& b) constexpr
			{
				return orient(p0, a, b) < 0.0f;
			}
		));
	} while (p0.x != h0.x && p0.y != h0.y); // when it is point[0]

	return hull;
}
```

`hack/utilities/math/math.hpp`:

```hpp
#pragma once

#include <SDK/math/matrix.hpp>
#include <SDK/math/Vector.hpp>

#include <numbers>
#include <span>
#include <vector>
#include <utility>
#include <tuple>
#include <optional>

struct ImVec2;

// read: https://www.unknowncheats.me/forum/counterstrike-global-offensive/137492-math-behind-hack-1-coding-better-aimbot-stop-using-calcangle.html
namespace math
{
	constexpr static float PI = std::numbers::pi_v<float>;
	constexpr static float PI_2 = std::numbers::pi_v<float> * 2.0f;

	[[nodiscard]] constexpr static float DEG2RAD(float degrees) { return degrees * (PI / 180.0f); }
	[[nodiscard]] constexpr static float RAD2DEG(float radians) { return radians * (180.0f / PI); }

	[[nodiscard]] Vec3 calcAngleRelative(const Vec3& src, const Vec3& dest, const Vec3& viewAngles);
	// classic
	[[nodiscard]] Vec3 calcAngle(const Vec3& src, const Vec3& dest);
	[[nodiscard]] float calcFov(const Vec3& source, const Vec3& destination, const Vec3& viewAngles);
	// based on distance, difference is that we dont have same fov everytime, since this is dynamic	
	[[nodiscard]] float calcFovReal(const Vec3& src, const Vec3& dest, const Vec3& viewAngles);
	[[nodiscard]] Vec3 transformVector(const Vec3& in, const Matrix3x4& matrix);
	[[nodiscard]] Vec3 angleVec(const Vec3& angle);
	[[nodiscard]] std::tuple<Vec3, Vec3, Vec3> angleVectors(const Vec3& angle);
	[[nodiscard]] float normalizeYaw(float yaw);
	[[nodiscard]] float normalizePitch(float pitch);
	// direction vector based on euler dimension
	[[nodiscard]] Vec3 vectorToAngle(const Vec3& vec);
	[[nodiscard]] std::optional<std::vector<ImVec2>> grahamScan(std::span<const ImVec2> points);
	[[nodiscard]] std::optional<std::vector<ImVec2>> giftWrap(std::span<const ImVec2> points);
	[[nodiscard]] std::pair<Vec3, Vec3> transformAABB(const Matrix3x4& transform, const Vec3& mins, const Vec3& maxs);
}
```

`hack/utilities/rand.hpp`:

```hpp
#pragma once

#include <random>
#include <type_traits>

#include <random>
#include <type_traits>

class Random // sfinae rule simple template static class
{
public:
    template<typename T>
    [[nodiscard]] static std::enable_if_t<std::is_arithmetic_v<T>, T> getRandom(T min, T max)
    {
        if constexpr (std::is_integral_v<T>)
        {
            return std::uniform_int_distribution<T>{min, max}(rng);
        }
        else
        {
            return std::uniform_real_distribution<T>{min, max}(rng);
        }
    }

private:
    inline static std::mt19937 rng{ std::random_device{}() };
};
```

`hack/utilities/res.cpp`:

```cpp
#include "res.hpp"

#include "tools/tools.hpp"
#include <render/render.hpp>
#include "../utilities/console/console.hpp"

#define STB_IMAGE_IMPLEMENTATION
#include <stb_image.h>
#include <imgui_impl_dx9.h>
#include <cheats/game/globals.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <SDK/ISurface.hpp>
#include <menu/GUI-ImGui/imguiaddons.hpp>

#include <Windows.h>
#include <d3dx9.h>

// not going to use D3DXCreateTextureFromFileA or D3DXCreateTextureFromResourceA
// first - this API is very old and second D3DXCreateTextureFromResourceA had problems and my resource was forced to be RCDATA type instead of generated one to work.

Resource::Resource(const std::string& path)
{
	if (path.empty())
		return;

	stbi_set_flip_vertically_on_load_thread(false);
	m_buffer = stbi_load(path.c_str(), &m_width, &m_height, nullptr, 4);
	if (!m_buffer)
	{
		LOG_ERR(XOR("Creating resource from path failed, reason: {}"), stbi_failure_reason());
		return;
	}
	m_texture = reinterpret_cast<IDirect3DTexture9*>(ImGui_CreateTexture(m_buffer, m_width, m_height));
	surfaceRender.initNewTexture(m_textureID, m_buffer, m_width, m_height);
	stbi_image_free(m_buffer);

	m_resBuf.push_back(*this);

	LOG_INFO(XOR("Image with path {} loaded!"), path);
}

Resource::Resource(int resID, const std::string_view type)
{
	HRSRC hResInfo = LI_FN_CACHED(FindResourceA)(globals::instance, MAKEINTRESOURCEA(resID), type.data());
	if (!hResInfo)
		throw std::runtime_error(XOR("Recource could not be found"));

	HGLOBAL hResData = LI_FN_CACHED(LoadResource)(globals::instance, hResInfo);
	if(!hResData)
		throw std::runtime_error(XOR("Recource data could not be found"));

	unsigned char* hResPtr = reinterpret_cast<unsigned char*>(LI_FN_CACHED(LockResource)(hResData));
	size_t size = LI_FN_CACHED(SizeofResource)(globals::instance, hResInfo);

	stbi_set_flip_vertically_on_load_thread(false);
	m_buffer = stbi_load_from_memory(hResPtr, size, &m_width, &m_height, nullptr, 4);
	if (!m_buffer)
	{
		LOG_ERR(XOR("Creating resource from resources file failed, reason: {}"), stbi_failure_reason());
		return;
	}
	m_texture = reinterpret_cast<IDirect3DTexture9*>(ImGui_CreateTexture(m_buffer, m_width, m_height));
	surfaceRender.initNewTexture(m_textureID, m_buffer, m_width, m_height);
	stbi_image_free(m_buffer);
	LI_FN_CACHED(FreeResource)(hResData);

	m_resBuf.push_back(*this);

	LOG_INFO(XOR("Resource ID {}:{} image loaded!"), resID, type);
}

Resource::Resource(void* data, size_t size)
{
	stbi_set_flip_vertically_on_load_thread(false);
	m_buffer = stbi_load_from_memory(reinterpret_cast<unsigned char*>(data), size, &m_width, &m_height, nullptr, 4);
	if (!m_buffer)
	{
		LOG_ERR(XOR("Creating resource from memory failed, reason: {}"), stbi_failure_reason());
		return;
	}
	m_texture = reinterpret_cast<IDirect3DTexture9*>(ImGui_CreateTexture(m_buffer, m_width, m_height));
	stbi_image_free(m_buffer);

	m_resBuf.push_back(*this);

	LOG_INFO(XOR("Image from memory loaded!"));
}

void Resource::destroyAll()
{
	for (const auto& el : m_resBuf)
	{
		if (el.getTexture() && el.getTextureID())
		{
			ImGui_DestroyTexture(el.getTexture());
			memory::interfaces::surface->deleteTextureID(el.getTextureID());
		}
	}
}

```

`hack/utilities/res.hpp`:

```hpp
#pragma once

#include <resources/resource.h>

#include <string>
#include <vector>

struct IDirect3DTexture9;

class Resource final
{
public:
	Resource(const std::string& path);
	Resource(int resID, const std::string_view type);
	Resource(void* data, size_t size);
	static void destroyAll();
	// imgui
	IDirect3DTexture9* getTexture() const { return m_texture; }
	// surface
	constexpr int getTextureID() const { return m_textureID; }
	constexpr int getWidth() const { return m_width; }
	constexpr int getHeight() const { return m_height; }
private:
	IDirect3DTexture9* m_texture;
	unsigned char* m_buffer;
	// surface
	int m_textureID = -1;
	int m_width;
	int m_height;

	inline static std::vector<Resource> m_resBuf;
};
```

`hack/utilities/simpleTimer.hpp`:

```hpp
#pragma once

#include <chrono>

struct TimeCount
{
    using steady_clock = std::chrono::steady_clock;
public:
    explicit TimeCount()
        : m_Start{ steady_clock::now() }
    {}
   
    void end() { m_End = steady_clock::now(); }
    constexpr auto elapsed() const { return m_End - m_Start; }
    template<typename T = float, typename period = std::chrono::seconds::period>
    constexpr auto getTime() const { return std::chrono::duration<T, period>(this->elapsed()).count(); }
private:
    steady_clock::time_point m_Start;
    steady_clock::time_point m_End;
};
```

`hack/utilities/tools/tools.cpp`:

```cpp
#include "tools.hpp"

#include <gamememory/memory.hpp>

uintptr_t spoof::getGadget(const std::string_view moduleName, const std::initializer_list<uint8_t>& jmpRbxBytes)
{
    static std::unordered_map<std::string_view, void*> modulesPassed;

    if (const auto itr = modulesPassed.find(moduleName); itr == modulesPassed.end())
    {
        const auto _module = g_Memory.getModule(moduleName);
        const auto dosHeader = reinterpret_cast<PIMAGE_DOS_HEADER>(_module);
        const auto ntHeaders = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<uint8_t*>(_module) + dosHeader->e_lfanew);
        const auto section = IMAGE_FIRST_SECTION(ntHeaders);

        const auto addrStart = reinterpret_cast<uint8_t*>(_module) + section->VirtualAddress;
        const auto addrEnd = addrStart + section->Misc.VirtualSize;
        const auto jumpRBXaddr = std::ranges::search(addrStart, addrEnd, jmpRbxBytes.begin(), jmpRbxBytes.end());

        modulesPassed.emplace(std::make_pair(moduleName, jumpRBXaddr.data()));

        return reinterpret_cast<uintptr_t>(jumpRBXaddr.data());
    }
    else
    {
        return reinterpret_cast<uintptr_t>(itr->second);
    }
}
```

`hack/utilities/tools/tools.hpp`:

```hpp
#pragma once

#include <lazy_importer.hpp>
#include <xorstr.hpp>

#include <string_view>
#include <initializer_list>

#if _DEBUG
#define XOR(s) (s)
#else
#define XOR(s) xorstr_(s)
#endif

#define LI_FN_CACHED(name) \
    LI_FN(name).cached()

#define EXPORT(var, __hash, _module) \
	var = ::li::detail::lazy_function<__hash, decltype(var)>().in(g_Memory.getModule(_module));

namespace spoof
{
    uintptr_t getGadget(const std::string_view moduleName, const std::initializer_list<uint8_t>& jmpRbxBytes = { 0xFF, 0x23 });
}
```

`hack/utilities/tools/wrappers.hpp`:

```hpp
#pragma once

#include <lazy_importer.hpp>

#include <type_traits>
#include <string>
#include <format>

template<typename T>
[[nodiscard]] inline constexpr auto E2T(T en)
{ 
    return static_cast<std::underlying_type_t<T>>(en);
}

[[nodiscard]] inline constexpr auto hasher(const std::string_view str)
{
    constexpr auto hashBasis = 2166136261U;
    return li::detail::khash(str.data(), hashBasis);
}

[[nodiscard]] inline constexpr auto operator"" _u8str(const char8_t* str, size_t s)
{
    return std::string{ str, str + s };
}

[[nodiscard]] inline constexpr auto operator"" _hasher(const char* str, size_t s)
{
    return hasher(str);
}

// format string at runtime
template<typename... Args_t>
[[nodiscard]] inline constexpr std::string FORMAT(const std::string_view fmt, Args_t&&... args)
{
    return std::vformat(fmt, std::make_format_args(args...));
}

```

`hack/utilities/utilities.cpp`:

```cpp
#include "utilities.hpp"

#include "tools/tools.hpp"

#include <Windows.h>
#include <chrono>

#pragma warning(disable: 6001) // memory unallocated
#pragma warning(disable: 6054) // string terminated

std::string utilities::getTime()
{
	const auto now = std::chrono::system_clock::now();
	auto time = std::chrono::system_clock::to_time_t(now);
	std::stringstream ss;

	std::tm bt = {};
	localtime_s(&bt, &time);

	ss << std::put_time(&bt, XOR("%d:%m:%Y-%X")); 
	return ss.str();
}

std::string utilities::getKeyName(const uint32_t virtualKey)
{
	uint32_t scanCode = LI_FN(MapVirtualKeyA).cached()(virtualKey, MAPVK_VK_TO_VSC);

	// because MapVirtualKey strips the extended bit for some keys
	switch (virtualKey)
	{
	case VK_LEFT: case VK_UP: case VK_RIGHT: case VK_DOWN: // arrow keys
	case VK_PRIOR: case VK_NEXT: // page up and page down
	case VK_END: case VK_HOME:
	case VK_INSERT: case VK_DELETE:
	case VK_DIVIDE: // numpad slash
	case VK_NUMLOCK:
	{
		scanCode |= 0x100; // set extended bit
		break;
	}
	case 1:
		return XOR("LMB");
		break;
	case 2:
		return XOR("RMB");
		break;
	case 4:
		return XOR("MMB");
		break;
	case 5:
		return XOR("Side 1");
		break;
	case 6:
		return XOR("Side 2");
		break;
	}

	if (char keyName[50]; LI_FN_CACHED(GetKeyNameTextA)(scanCode << 16, keyName, sizeof(keyName)) != 0)
		return keyName;
	else
		return XOR("[None]");
}

std::string utilities::toLowerCase(const std::string& str)
{
	std::string result = str;
	std::for_each(result.begin(), result.end(), [](char& el)
		{
			el = ::tolower(el);
		});
	return result;
}

std::string utilities::toUpperCase(const std::string& str)
{
	std::string result = str;
	std::for_each(result.begin(), result.end(), [](char& el)
		{
			el = ::toupper(el);
		});
	return result;
}

std::vector<std::string> utilities::splitStr(const std::string& str, char limit)
{
	std::vector<std::string> res;
	std::stringstream content{ str };
	std::string word;
	while (std::getline(content, word, limit))
	{
		res.push_back(word);
	}
	return res;
}

uint32_t utilities::getKey(const uint32_t vKey)
{
	return LI_FN_CACHED(GetAsyncKeyState)(vKey);
}

std::string utilities::u8toStr(const std::u8string& u8str)
{
	return std::string{ u8str.cbegin(), u8str.cend() };
}
```

`hack/utilities/utilities.hpp`:

```hpp
#pragma once

#include <string>
#include <vector>
#include <array>
#include <ranges>

namespace utilities
{
    [[nodiscard]] std::string getTime();
    [[nodiscard]] std::string getKeyName(const uint32_t virtualKey);
    [[nodiscard]] std::string toLowerCase(const std::string& str);
    [[nodiscard]] std::string toUpperCase(const std::string& str);
    template<typename T, size_t SIZE>
    [[nodiscard]] constexpr std::array<T, SIZE> getFilledArray(const T& val)
    {
        std::array<T, SIZE> arr;
        std::ranges::fill(arr, val);
        return arr;
    }
    // deprecated, https://www.youtube.com/watch?v=V14xGZAyVKI
    [[deprecated("use std::views::split")]]
    std::vector<std::string> splitStr(const std::string& str, char limit = ' ');
    [[deprecated("use key classes")]]
    uint32_t getKey(const uint32_t vKey);
    [[nodiscard]] std::string u8toStr(const std::u8string& u8str);
}
```

`pch.cpp`:

```cpp
#include "pch.h"
```

`pch.h`:

```h
#pragma once

#include <Windows.h>
#include <ShlObj.h>

#include <filesystem>
#include <format>

#define IMGUI_DEFINE_MATH_OPERATORS
```

`source.cpp`:

```cpp
#include "setup/setup.hpp"

#include <cheats/game/globals.hpp>
#include <utilities/tools/tools.hpp>

BOOL WINAPI DllMain(CONST HMODULE instance, CONST ULONG reason, CONST PVOID reserved)
{
    if (reason == DLL_PROCESS_ATTACH)
    {
        // here this sometimes throw null on mm
        if (instance)
            LI_FN(DisableThreadLibraryCalls)(instance);

        globals::instance = instance;

        if (auto initThread = LI_FN(CreateThread)(nullptr, NULL, reinterpret_cast<LPTHREAD_START_ROUTINE>(Setup::init), instance, NULL, nullptr))
            LI_FN(CloseHandle)(initThread);

        if (auto looperThread = LI_FN(CreateThread)(nullptr, NULL, reinterpret_cast<LPTHREAD_START_ROUTINE>(Setup::looper), instance, NULL, nullptr))
            LI_FN(CloseHandle)(looperThread);

        return TRUE;
    }
    else if (reason == DLL_PROCESS_DETACH)
    {
        if (!globals::isShutdown) // then panic key forced shutdown
        {
            if (auto shutdownThread = LI_FN(CreateThread)(nullptr, NULL, reinterpret_cast<LPTHREAD_START_ROUTINE>(Setup::shutdown), instance, NULL, nullptr))
                LI_FN(CloseHandle)(shutdownThread);
        }
    }

    return FALSE;
}
```

`vcpkg.json`:

```json
{
  "dependencies": [
    "xorstr",
    "lazy-importer",
    "minhook",
    "nlohmann-json",
    {
      "name": "imgui",
      "features": [ "dx9-binding", "win32-binding", "freetype" ]
    },
    "stb",
    "magic-enum",
    "discord-rpc",
    "freetype"
  ]
}
```