Project Path: arc_gmh5225_gvmp-anticheat_62sn9nj8

Source Tree:

```txt
arc_gmh5225_gvmp-anticheat_62sn9nj8
├── CMakeLists.txt
├── README.md
├── generate.bat
├── include
│   ├── anticheat
│   │   ├── anticheat.hpp
│   │   ├── detections.hpp
│   │   └── tracking.hpp
│   ├── gta
│   │   └── game_classes.hpp
│   ├── imports.hpp
│   ├── nemo.hpp
│   ├── networking
│   │   ├── data
│   │   │   ├── data.hpp
│   │   │   └── packet.h
│   │   ├── enet.h
│   │   └── networking.hpp
│   ├── pointers
│   │   ├── module.hpp
│   │   ├── pointers.hpp
│   │   └── scanner.hpp
│   ├── renderer
│   │   └── renderer.hpp
│   ├── utilities
│   │   └── security.hpp
│   └── vendor
│       ├── alt
│       │   └── alt-log.hpp
│       ├── fontwrapper
│       │   ├── CFW1ColorRGBA.h
│       │   ├── CFW1DWriteRenderTarget.h
│       │   ├── CFW1Factory.h
│       │   ├── CFW1FontWrapper.h
│       │   ├── CFW1GlyphAtlas.h
│       │   ├── CFW1GlyphProvider.h
│       │   ├── CFW1GlyphRenderStates.h
│       │   ├── CFW1GlyphSheet.h
│       │   ├── CFW1GlyphVertexDrawer.h
│       │   ├── CFW1Object.h
│       │   ├── CFW1StateSaver.h
│       │   ├── CFW1TextGeometry.h
│       │   ├── CFW1TextRenderer.h
│       │   ├── FW1CompileSettings.h
│       │   ├── FW1FontWrapper.h
│       │   └── FW1Precompiled.h
│       ├── math
│       │   ├── SimpleMath.h
│       │   └── SimpleMath.inl
│       ├── minhook.hpp
│       ├── nlohmann
│       │   └── json.hpp
│       ├── singleton.hpp
│       └── xor.hpp
├── libs
│   ├── enet_static.lib
│   └── libMinHook.x64.lib
└── src
    ├── anticheat
    │   ├── anticheat.cpp
    │   ├── detections.cpp
    │   └── tracking.cpp
    ├── inject.cpp
    ├── nemo.cpp
    ├── networking
    │   ├── data
    │   │   └── packet.cpp
    │   └── networking.cpp
    ├── pointers
    │   └── pointers.cpp
    ├── renderer
    │   └── renderer.cpp
    ├── utilities
    │   └── security.cpp
    └── vendor
        └── fontwrapper
            ├── CFW1ColorRGBA.cpp
            ├── CFW1ColorRGBAInterface.cpp
            ├── CFW1DWriteRenderTarget.cpp
            ├── CFW1DWriteRenderTargetInterface.cpp
            ├── CFW1Factory.cpp
            ├── CFW1FactoryInterface.cpp
            ├── CFW1FontWrapper.cpp
            ├── CFW1FontWrapperInterface.cpp
            ├── CFW1GlyphAtlas.cpp
            ├── CFW1GlyphAtlasInterface.cpp
            ├── CFW1GlyphProvider.cpp
            ├── CFW1GlyphProviderInterface.cpp
            ├── CFW1GlyphRenderStates.cpp
            ├── CFW1GlyphRenderStatesInterface.cpp
            ├── CFW1GlyphSheet.cpp
            ├── CFW1GlyphSheetInterface.cpp
            ├── CFW1GlyphVertexDrawer.cpp
            ├── CFW1GlyphVertexDrawerInterface.cpp
            ├── CFW1StateSaver.cpp
            ├── CFW1TextGeometry.cpp
            ├── CFW1TextGeometryInterface.cpp
            ├── CFW1TextRenderer.cpp
            ├── CFW1TextRendererInterface.cpp
            ├── FW1FontWrapper.cpp
            └── FW1Precompiled.cpp

```

`CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 2.8)

project(NEMO_AC)

set(PROJECT_NAME NEMO_AC)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

add_definitions(-DALT_CLIENT)
add_definitions(-DALT_CLIENT_API)

file(GLOB_RECURSE PROJECT_SOURCE_FILES "src/*.h" "src/*.hpp" "src/*.cpp" "include/*.h" "include/*.hpp" "include/*.cpp")

macro(GroupSources curdir groupindex)
  file(GLOB children RELATIVE ${curdir} ${curdir}/*)

  foreach(child ${children})
    if(IS_DIRECTORY ${curdir}/${child})
      GroupSources(${curdir}/${child} ${groupindex}/${child})
    else()

      string(REPLACE "/" "\\" groupname ${groupindex})

      source_group(${groupname} FILES ${curdir}/${child})
    endif()
  endforeach()
endmacro()

GroupSources(${PROJECT_SOURCE_DIR}/src "Source Files")
GroupSources(${PROJECT_SOURCE_DIR}/include "Include Files")

include_directories(
  ${PROJECT_SOURCE_DIR}/src
  ${PROJECT_SOURCE_DIR}/include
  $ENV{DXSDK_DIR}/Include
)

if (CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  target_compile_options(${PROJECT_NAME} PRIVATE
    -Wno-deprecated-declarations
    -Wno-switch-enum
    -Wno-unused-command-line-argument
    -Wno-macro-redefined
    -Wno-inconsistent-missing-override
    -Wno-deprecated-declarations
    -Wno-return-type
    -Wno-switch-enum
    -Wno-switch
    -Wno-parentheses
    -Wno-unused-private-field
    -Wno-unused-variable
    -Wno-format
    -Wno-reorder
    -Wno-delete-non-virtual-dtor
    -Wno-microsoft-cast
    -Wno-unused-function
    -Wno-unused-lambda-capture
    -Wno-missing-braces
    -Wno-unused-local-typedef
    -Wno-tautological-constant-out-of-range-compare
    -Wno-delete-incomplete
    -Wno-c++11-narrowing
    -Wno-comment
  )

    target_compile_options(${PROJECT_NAME} PRIVATE
      -fms-compatibility
      -fms-extensions
      /EHsc
	  /FORCE
    )
    set_target_properties(${PROJECT_NAME} PROPERTIES
      COTIRE_ENABLE_PRECOMPILED_HEADER FALSE
      COTIRE_ADD_UNITY_BUILD FALSE
    )
endif()

link_directories(
  $ENV{DXSDK_DIR}/Lib/x64
  ${PROJECT_SOURCE_DIR}/libs
)

add_library(
  ${PROJECT_NAME} SHARED
  ${PROJECT_SOURCE_FILES}
)

if (WIN32)
  target_link_libraries(${PROJECT_NAME} libMinHook.x64.lib d3d11.lib D3dcompiler.lib)
endif (WIN32)
```

`README.md`:

```md
# Anti-Cheat

## Contributing
Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.

```

`generate.bat`:

```bat
@echo off
if not exist build mkdir build
cd build
cmake -G "Visual Studio 16" -A x64 ..
cd ../
```

`include/anticheat/anticheat.hpp`:

```hpp
#pragma once
#include "imports.hpp"

#define ANTICHEAT
using namespace std;

class anticheat_main : public c_singleton<anticheat_main>
{
public:
	void run_service();
};
```

`include/anticheat/detections.hpp`:

```hpp
#pragma once
#include "imports.hpp"
#include "pointers/pointers.hpp"

#define ANTICHEAT
using namespace std;

class anticheat_detections : public c_singleton<anticheat_detections>
{
private:
	typedef NTSTATUS(NTAPI* pldr_manifest_prober_routine_t)(IN HMODULE dll_base, IN PCWSTR full_dll_path, OUT PHANDLE activation_context);
	typedef NTSTATUS(NTAPI* pldr_actx_language_rourine_t)(IN HANDLE unk, IN USHORT lang_id, OUT PHANDLE activation_context);
	typedef void(NTAPI* pldr_release_act_routine_t)(IN HANDLE activation_context);
	typedef VOID(NTAPI* ldr_set_dll_manifest_prober_t)(IN pldr_manifest_prober_routine_t ManifestProberRoutine, IN pldr_actx_language_rourine_t CreateActCtxLanguageRoutine, IN pldr_release_act_routine_t ReleaseActCtxRoutine);

	/* detection hooks */
	typedef LONG(WINAPI* nt_protect_virtual_memory_t)(IN HANDLE process_handle, IN OUT PVOID* base_address, IN OUT PULONG number_of_bytes_to_protect, IN ULONG new_access_protection, OUT PULONG old_access_protection);
	typedef BOOL(WINAPI* disable_thread_library_calls_t)(_In_ HMODULE lib_module);
	typedef HANDLE(WINAPI* create_file_t)(_In_ LPCWSTR lpFileName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwShareMode, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, _In_ DWORD dwCreationDisposition, _In_ DWORD dwFlagsAndAttributes, _In_opt_ HANDLE hTemplateFile);
	typedef FILE* (__cdecl* fs_open_t)(_In_z_ char const* _FileName, _In_z_ char const* _Mode, _In_ int _ShFlag);
	typedef BOOL(WINAPI* flush_instruction_cache_t)(_In_ HANDLE process, _In_reads_bytes_opt_(size) LPCVOID base_address, _In_ SIZE_T size);
	typedef HWND(WINAPI* create_window_t)(_In_ DWORD ex_style, _In_opt_ LPCSTR class_name, _In_opt_ LPCSTR window_name, _In_ DWORD style, _In_ int x, _In_ int y, _In_ int width, _In_ int height, _In_opt_ HWND parent, _In_opt_ HMENU menu, _In_opt_ HINSTANCE instance, _In_opt_ LPVOID param);
public:
	typedef enum _DetectionTypes {
		DETECTION_UNKNOWN = 1,
		DETECTION_DISABLE_THREAD_LIBRARY_CALLS,
		DETECTION_CREATE_FILE,
		DETECTION_FS_OPEN,
		DETECTION_DLL_MANIFEST_PROBER_CALLBACK,
		DETECTION_MINHOOK_FLUSH_CACHE,
		DETECTION_CREATE_WINDOW,
		DETECTION_WORLD_TO_SCREEN,
		DETECTION_ANTICHEAT_SECURITY
	};

	nt_protect_virtual_memory_t o_nt_protect_virtual_memory = nullptr;
	disable_thread_library_calls_t o_disable_thread_library_calls = nullptr;
	create_file_t o_create_file = nullptr;
	fs_open_t o_fs_open = nullptr;
	flush_instruction_cache_t o_flush_instruction_cache = nullptr;
	create_window_t o_create_window = nullptr;

	pointers::get_bone_position_t o_get_bone_position = nullptr;
	pointers::world_to_screen_t o_world_to_screen = nullptr;

	void run_service();
	const char* detection_to_string(_DetectionTypes detection_type);

	void detect_by_type(_DetectionTypes detection_type);
	void detect_by_type(_DetectionTypes detection_type, std::string optional_information);
};
```

`include/anticheat/tracking.hpp`:

```hpp
#pragma once
#include "imports.hpp"

class tracking : public c_singleton<tracking>
{
private:
	uint32_t get_tracking_id_by_file();
public:
	
};
```

`include/gta/game_classes.hpp`:

```hpp
#include <vendor/math/SimpleMath.h>
#include <Windows.h>
#include <stdio.h> 
#include <string> 
#include <sstream> 
#include <iostream>

using namespace DirectX::SimpleMath;


static std::wstring asciiDecode(const std::string& s)
{
	std::wostringstream    w;
	wchar_t                c;

	for (size_t i = 0; i < s.length(); i++) {
		mbtowc(&c, &s[i], 1);
		w << c;
	}
	return w.str();
}

class CViewPort
{
public:
	char pad_0x0000[0x100]; //0x0000

	Matrix m_viewMatrix; //0x0100 
	Matrix m_projectionMatrix; //0x0140 
	char pad_0x0180[0xCC]; //0x0180
	Matrix m_viewProj; //0x024C 
	char pad_0x028C[0x1F8]; //0x028C

}; //Size=0x0484
static CViewPort* m_viewPort;
class GameViewMatrices;
class CPlayerInfo;
class CPlayers;
class CInventory;
class CWeaponManager;
class CObjectWrapper;
class CObject;
class CVehicleManager;
class CAttacker;
class CVehicleHandling;
class CVehicleColorOptions;
class CVehicleColors;
class CBoneManager;
class CModelInfo;
class CPedClothing;
class CNetGamePlayer;

inline unsigned int hash_string(std::string str)
{
	size_t len = str.size();
	unsigned int hash, i;
	for (hash = i = 0; i < len; ++i)
	{
		hash += tolower(str[i]);
		hash += (hash << 10);
		hash ^= (hash >> 6);
	}
	hash += (hash << 3);
	hash ^= (hash >> 11);
	hash += (hash << 15);
	return hash;
}
/*
typedef struct PVector3
{
	float x;
	DWORD _paddingx;
	float y;
	DWORD _paddingy;
	float z;
	DWORD _paddingz;

	PVector3(float x, float y, float z) :
		x(x), y(y), z(z),
		_paddingx(0), _paddingy(0), _paddingz(0)
	{
	}
	PVector3() noexcept : PVector3(0.f, 0.f, 0.f) {}
};
*/

/* CLASSES USED FROM PHANTOMCHEATS */

class CNetGamePlayer
{
public:
	char pad_0000[16]; //0x0000
	void* pCNonPhysicalPlayerData; //0x0010
	char pad_0018[21]; //0x0018
	int8_t m_PlayerID; //0x002D
	char pad_002E[122]; //0x002E
	CPlayerInfo* pCPlayerInfo; //0x00A8
}; //Size: 0x00B0

#include <string>
using namespace std;

class CRagePool;
class CRagePlayerPool;
class CRemotePlayer;

class CRagePool
{
public:
	CRagePlayerPool* PlayerPool; //0x0000 
	char pad_0x0008[0x38]; //0x0008

}; //Size=0x0040

class CRagePlayerPool
{
public:
	CRemotePlayer* N0000000B; //0x0000 
	char pad_0x0008[0x10]; //0x0008

}; //Size=0x0018


class CPedLink
{
public:
	char pad_0x0000[0x18]; //0x0000
	CObject* pPed; //0x0018 
	char pad_0x0020[0x28]; //0x0020

}; //Size=0x0048

class CRemotePlayer
{
public:
	char pad_0x0000[0x8]; //0x0000
	WORD Id; //0x0008 
	char pad_0x000A[0x7E]; //0x000A
	CPedLink* pPedLink; //0x0088 
	char pad_0x0090[0x378]; //0x0090

}; //Size=0x0408

class CObjectNavigation
{
public:
	char pad_0x0000[0x30]; //0x0000
	Vector3 Rotation; //0x0030 
	char pad_0x003C[0x14]; //0x003C
	Vector3 Position; //0x0050 
	char pad_0x005C[0x24]; //0x005C
}; //Size=0x0080


enum Bones {
	HEAD = 0x796E,
	NECK = 0x9995,
	RIGHT_HAND = 0xDEAD,
	RIGHT_FOREARM = 0x6E5C,
	RIGHT_UPPER_ARM = 0x9D4D,
	RIGHT_CLAVICLE = 0x29D2,

	LEFT_HAND = 0x49D9,
	LEFT_FOREARM = 0xEEEB,
	LEFT_UPPER_ARM = 0xB1C5,
	LEFT_CLAVICLE = 0xFCD9,

	PELVIS = 0x2E28,
	SPINE_ROOT = 0xE0FD,
	SPINE0 = 0x60F2,
	SPINE1 = 0x60F0,
	SPINE2 = 0x60F1,
	SPINE3 = 0x60F2,

	RIGHT_TOE = 0x512D,
	RIGHT_FOOT = 0xCC4D,
	RIGHT_CALF = 0x9000,
	RIGHT_THIGH = 0xCA72,
	LEFT_TOE = 0x083C,
	LEFT_FOOT = 0x3779,
	LEFT_CALF = 0xF9BB,
	LEFT_THIGH = 0xE39F
};

#define IsValidPtr(x) (x && !IsBadReadPtr(&x, sizeof(void*) && x != nullptr && x > nullptr))

class CReplayInterfaceVehicle
{
private:
	class VehicleHandle
	{
	public:
		CVehicleManager* vehicle; //0x0000 
		__int32 handle; //0x0008
		char _pad0[0x4];
	};//Size=0x0588

	class CVehicleList
	{
	public:
		VehicleHandle vehicles[0x100];//0x0000 
	};//Size=0x0490

public:
	char _0x0000[0x180];
	CVehicleList* vehicle_list; //0x0180
	__int32 max_vehicles; //0x0188 
	char _0x010C[0x4];
	__int32 number_of_vehicles; //0x0190 
	char _0x0114[0x34];

	CVehicleManager* get_vehicle(int index)
	{
		if (index <= 0xFF && IsValidPtr(vehicle_list) && IsValidPtr(vehicle_list->vehicles[index].vehicle))
			return (vehicle_list->vehicles[index].vehicle);
		else
			return nullptr;
	}
};

class CPickup
{
public:
	char pad_0x0000[0x30]; //0x0000
	CObjectNavigation* pCNavigation; //0x0030 
	char pad_0x0038[0x58]; //0x0038
	Vector3 v3VisualPos; //0x0090 
	char pad_0x009C[0x3F4]; //0x009C
	__int32 iValue; //0x0490 
	char pad_0x0494[0xC4]; //0x0494

}; //Size=0x0558

class CPickupHandle
{
public:
	CPickup* pCPickup; //0x0000 
	__int32 iHandle; //0x0008 
	char pad_0x000C[0x4]; //0x000C

}; //Size=0x0010

class CPickupList
{
public:
	CPickupHandle pickups[73]; //0x0000 

}; //Size=0x0490

class CPickupInterface
{
public:
	char pad_0x0000[0x100]; //0x0000
	CPickupList* pCPickupList; //0x0100 
	__int32 iMaxPickups; //0x0108 
	char pad_0x010C[0x4]; //0x010C
	__int32 iCurPickups; //0x0110 

	CPickup* get_pickup(int index)
	{
		if (IsValidPtr(pCPickupList) && IsValidPtr(pCPickupList->pickups[index].pCPickup) && pCPickupList->pickups[index].iHandle)
			return (pCPickupList->pickups[index].pCPickup);
		else
			return nullptr;
	}
}; //Size=0x0114

class CObjectInterface
{
private:
	class CObjectHandle
	{
	public:
		CObject* pCObject; //0x0000 
		__int32 iHandle; //0x0008 
		char pad_0x000C[0x4]; //0x000C

	}; //Size=0x0010

	class CObjectList
	{
	public:
		CObjectHandle ObjectList[3200]; //0x0000 

	}; //Size=0x8FC0

public:
	char pad_0x0000[0x158]; //0x0000
	CObjectList* pCObjectList; //0x0158 
	__int32 iMaxObjects; //0x0160 
	char pad_0x0164[0x4]; //0x0164
	__int32 iCurObjects; //0x0168 
	char pad_0x016C[0x5C]; //0x016C

	CObject* get_object(int index)
	{
		if (IsValidPtr(pCObjectList) && IsValidPtr(pCObjectList->ObjectList[index].pCObject) && pCObjectList->ObjectList[index].iHandle)
			return (pCObjectList->ObjectList[index].pCObject);
		else
			return nullptr;
	}


}; //Size=0x01C8

class CVehicleColors
{
public:
	char pad_0x0000[0xA4]; //0x0000
	BYTE btPrimaryBlue; //0x00A4 
	BYTE btPrimaryGreen; //0x00A5 
	BYTE btPrimaryRed; //0x00A6 
	BYTE btPrimaryAlpha; //0x00A7 
	BYTE btSecondaryBlue; //0x00A8 
	BYTE btSecondaryGreen; //0x00A9 
	BYTE btSecondaryRed; //0x00AA 
	BYTE btSecondaryAlpha; //0x00AB 

	void SetColor(BYTE p1, BYTE p2, BYTE p3, BYTE p5, BYTE p6, BYTE p7) {
		btPrimaryRed = p1;
		btPrimaryGreen = p2;
		btPrimaryBlue = p3;

		btSecondaryRed = p5;
		btSecondaryGreen = p6;
		btSecondaryBlue = p7;
	}

}; //Size=0x00AC

class CVehicleColorOptions
{
public:
	char pad_0x0000[0x20]; //0x0000
	CVehicleColors* CVehicleColor; //0x0020 

}; //Size=0x0028

class CCameraInterface
{
public:
	char pad_0x0000[0x248]; //0x0000

}; //Size=0x0248


static DWORD OFFvehSpeed = 0xB30;

class CModelInfo
{
public:
	char pad_0000[24]; //0x0000
	uint32_t Hash; //0x0018
	char pad_001C[20]; //0x001C
	Vector3 MinDim; //0x0030
	char pad_003C[4]; //0x003C
	Vector3 MaxDim; //0x0040
	char pad_004C[588]; //0x004C
	char Name[24]; //0x0298
	char pad_02A0[688]; //0x02A0
}; //Size: 0x0550

class CVehicleManager
{
public:
	char pad_0x0000[0x20]; //0x0000
	CModelInfo* ModelInfo; //0x0020 
	char pad_0x0028[0x8]; //0x0028
	CObjectNavigation* _ObjectNavigation; //0x0030 
	char pad_0x0038[0x10]; //0x0038
	CVehicleColorOptions* VehicleColorOptions; //0x0048 
	char pad_0x0050[0x40]; //0x0050
	Vector3 fPosition; //0x0090 
	char pad_0x009C[0x1E4]; //0x009C
	float fHealth; //0x0280 
	char pad_0x0284[0x1C]; //0x0284
	float fHealthMax; //0x02A0 
	char pad_0x02A4[0x4]; //0x02A4
	char pad_0x02F0[0x648]; //0x02F0
	CVehicleHandling* VehicleHandling; //0x0938 
	char pad_0x0940[0x31C]; //0x0940
	float fGravity; //0x0C5C 
	char pad_0x0C60[0x3EC]; //0x0C60
}; //Size=0x104C

class CWeaponName
{
public:
	char Name[20];
};

static DWORD OFFrecoil = 0x2E8;
static DWORD OFFspread = 0x84;
static DWORD OFFspread2 = 0x124;

class CWeaponInfo
{
public:
	char pad_0000[96]; //0x0000
	void* _AmmoInfo; //0x0060 //70
	char pad_0068[12]; //0x0068
	float Spread; //0x0074 //84
	char pad_0078[56]; //0x0078
	float Damage; //0x00B0 
	char pad_00B4[36]; //0x00B4
	float MinImpulse; //0x00D8 
	float MaxImpulse; //0x00DC
	char pad_00E0[52]; //0x00E0F
	float Velocity; //0x0114 
	int32_t BulitsPerShoot; //0x0118 
	float MultiBulitSpread; //0x011C 
	char pad_0120[12]; //0x0120
	float ReloadTimeMultiplier; //0x012C
	char pad_0130[4]; //0x0130
	float TimeToShoot; //0x0134 //144
	char pad_0138[404]; //0x0138
	//float RecoilFirstPerson; //0x02CC 
	char pad_02D0[8]; //0x02D0
	float RecoilThirdPerson; //0x02D8 //2E8
	char pad_02DC[772]; //0x02DC
	char* szWeaponName; //0x05E0 //5F0
	char pad_05E8[40]; //0x05E8


	//void SetCurrentAmmo(int32_t ammo) {
	//	if (IsValidPtr(_AmmoInfo)) {
	//	const DWORD64 ptr1 = reinterpret_cast<DWORD64>(_AmmoInfo);
	//		const DWORD64 ptr2 = *reinterpret_cast<DWORD64*>(ptr1 + 0x8);
	//		if (ptr2) {
	//			const DWORD64 ptr3 = *reinterpret_cast<DWORD64*>(ptr2 + 0x0);
	//			if (ptr3) {
	//				*(int32_t*)(ptr3 + 0x18) = 9999;
	//			}
	//		}
	//	}
	//}

	float get_spread() {
		return (*reinterpret_cast<float*>((char*)this + 0x88));
	}

	float get_velocity() {
		return (*reinterpret_cast<float*>((char*)this + 0x118));
	}
	float get_range() {
		return (*reinterpret_cast<float*>((char*)this + 0x28C));
	}

	std::string get_weapon_name() {
		CWeaponName* WeaponName = *reinterpret_cast<CWeaponName**>((char*)this + 0x5F0);
		if (IsValidPtr(WeaponName) && WeaponName->Name && *WeaponName->Name)
			return &WeaponName->Name[0];
		else
			return "UNARMED"; //Doing Animation...
	}

	//0x1D4 = Visual shoot animation radius
}; //Size: 0x0610
static CWeaponInfo* m_pCWeaponInfo = nullptr;
static CWeaponInfo m_CWeapon;

class CWeaponManager
{
public:
	char pad_0000[32]; //0x0000
	CWeaponInfo* _WeaponInfo; //0x0020
	char pad_0028[96]; //0x0028
	void* _CurrentWeapon; //0x0088
	char pad_0090[272]; //0x0090
	Vector3 Aiming_at_Cord; //0x01A0
	char pad_01AC[4]; //0x01AC
	Vector3 Last_Impact_Cord; //0x01B0
	char pad_01BC[44]; //0x01BC

	DWORD get_hash() {
		return (*reinterpret_cast<DWORD*>((char*)this + 0x18));
	}
}; //Size: 0x01E8

static DWORD64 Inf_Ammo = 0x0;
static DWORD InsideVehOffset = 0x14F3;


static DWORD OFFinVeh = 0xE52;
static DWORD OFFvehMgr = 0xD30;
static DWORD OFFweaponMgr = 0x10D8;
static DWORD OFFplayerInfoMgr = 0x10C8;
static DWORD OFFarmour = 0x14E0;
static DWORD OFFnoGravity = 0x1100;
static DWORD OFFpedType = 0x10B8;

class CPlayerBones {
public:
	Vector3 HEAD;
	Vector3 NECK;

	Vector3 RIGHT_HAND;
	Vector3 RIGHT_FOREARM;
	Vector3 RIGHT_UPPER_ARM;
	Vector3 RIGHT_CLAVICLE;

	Vector3 LEFT_HAND;
	Vector3 LEFT_FOREARM;
	Vector3 LEFT_UPPER_ARM;
	Vector3 LEFT_CLAVICLE;

	Vector3 PELVIS;
	Vector3 SPINE_ROOT;
	Vector3 SPINE0;
	Vector3 SPINE1;
	Vector3 SPINE2;
	Vector3 SPINE3;

	Vector3 RIGHT_TOE;
	Vector3	RIGHT_FOOT;
	Vector3	RIGHT_CALF;
	Vector3	RIGHT_THIGH;

	Vector3	LEFT_TOE;
	Vector3	LEFT_FOOT;
	Vector3	LEFT_CALF;
	Vector3	LEFT_THIGH;
};

/*
LineOneBegin = GetOffsetFromEntityInWorldCoords(pPed, -0.3, -0.3, -0.9)
			LineOneEnd = GetOffsetFromEntityInWorldCoords(pPed, 0.3, -0.3, -0.9)
			LineTwoBegin = GetOffsetFromEntityInWorldCoords(pPed, 0.3, -0.3, -0.9)
			LineTwoEnd = GetOffsetFromEntityInWorldCoords(pPed, 0.3, 0.3, -0.9)
			LineThreeBegin = GetOffsetFromEntityInWorldCoords(pPed, 0.3, 0.3, -0.9)
			LineThreeEnd = GetOffsetFromEntityInWorldCoords(pPed, -0.3, 0.3, -0.9)
			LineFourBegin = GetOffsetFromEntityInWorldCoords(pPed, -0.3, -0.3, -0.9)

			TLineOneBegin = GetOffsetFromEntityInWorldCoords(pPed, -0.3, -0.3, 0.8)
			TLineOneEnd = GetOffsetFromEntityInWorldCoords(pPed, 0.3, -0.3, 0.8)
			TLineTwoBegin = GetOffsetFromEntityInWorldCoords(pPed, 0.3, -0.3, 0.8)
			TLineTwoEnd = GetOffsetFromEntityInWorldCoords(pPed, 0.3, 0.3, 0.8)
			TLineThreeBegin = GetOffsetFromEntityInWorldCoords(pPed, 0.3, 0.3, 0.8)
			TLineThreeEnd = GetOffsetFromEntityInWorldCoords(pPed, -0.3, 0.3, 0.8)
			TLineFourBegin = GetOffsetFromEntityInWorldCoords(pPed, -0.3, -0.3, 0.8)

			ConnectorOneBegin = GetOffsetFromEntityInWorldCoords(pPed, -0.3, 0.3, 0.8)
			ConnectorOneEnd = GetOffsetFromEntityInWorldCoords(pPed, -0.3, 0.3, -0.9)
			ConnectorTwoBegin = GetOffsetFromEntityInWorldCoords(pPed, 0.3, 0.3, 0.8)
			ConnectorTwoEnd = GetOffsetFromEntityInWorldCoords(pPed, 0.3, 0.3, -0.9)
			ConnectorThreeBegin = GetOffsetFromEntityInWorldCoords(pPed, -0.3, -0.3, 0.8)
			ConnectorThreeEnd = GetOffsetFromEntityInWorldCoords(pPed, -0.3, -0.3, -0.9)
			ConnectorFourBegin = GetOffsetFromEntityInWorldCoords(pPed, 0.3, -0.3, 0.8)
			ConnectorFourEnd = GetOffsetFromEntityInWorldCoords(pPed, 0.3, -0.3, -0.9)
			*/


class CPlayerOffsets {

public:
	Vector3 left_bottom;
	Vector3 right_bottom;
	Vector3 left_top;
	Vector3 right_top;

	Vector3 line_three_start;
	Vector3 line_three_end;
	Vector3 line_four_start;
	Vector3 tline_one_start;
	Vector3 tline_one_end;
	Vector3 tline_two_start;
	Vector3 tline_two_end;
	Vector3 tline_three_start;
	Vector3 tline_three_end;
	Vector3 tline_four_start;
	Vector3 connector_one_start;
	Vector3 connector_one_end;
	Vector3 connector_two_start;
	Vector3 connector_two_end;
	Vector3 connector_three_start;
	Vector3 connector_three_end;
	Vector3 connector_four_start;
	Vector3 connector_four_end;
};

class CObject
{
public:
	char pad_0x0000[0x2C]; //0x0000
	BYTE btInvisibleSP; //0x002C 
	char pad_0x002D[0x1]; //0x002D
	BYTE btFreezeMomentum; //0x002E 
	char pad_0x002F[0x1]; //0x002F
	CObjectNavigation* _ObjectNavigation; //0x0030 
	char pad_0x0038[0x58]; //0x0038
	Vector3 fPosition; //0x0090 
	char pad_0x009C[0xED]; //0x009C
	BYTE GodModeToggle; //0x0189 
	char pad_0x018A[0xF6]; //0x018A
	float HP; //0x0280 
	char pad_0x0284[0x1C]; //0x0284
	float MaxHP; //0x02A0 
	char pad_0x02A4[0x4]; //0x02A4
	CAttacker* CAttacker; //0x02A8 
	char pad_0x02B0[0x70]; //0x02B0
	Vector3 v3Velocity; //0x0320 
	char pad_0x032C[0x9FC]; //0x032C
	CVehicleManager* VehicleManager; //0x0D28 
	char pad_0x0D30[0x378]; //0x0D30
	BYTE btNoRagdoll; //0x10A8 
	char pad_0x10A9[0xF]; //0x10A9
	CPlayerInfo* PlayerInfo; //0x10B8 
	char pad_0x10C0[0x8]; //0x10C0
	CWeaponManager* WeaponManager; //0x10C8 
	char pad_0x10D0[0x31C]; //0x10D0
	BYTE btSeatBelt; //0x13EC 
	char pad_0x13ED[0xB]; //0x13ED
	BYTE btSeatbeltWindshield; //0x13F8 
	char pad_0x13F9[0x72]; //0x13F9
	BYTE btIsInVehicle; //0x146B 
	char pad_0x146C[0x44]; //0x146C
	float Armor; //0x14B0 
	char pad_0x14B4[0x3C]; //0x14B4
	CVehicleManager* VehicleManager2; //0x14F0 

	bool is_ped() {
		return get_model_info()->Hash == hash_string("mp_m_freemode_01") || get_model_info()->Hash == hash_string("mp_m_freemode_01");
	}

	CPlayerInfo* get_player_info() {
		return *reinterpret_cast<CPlayerInfo**>((char*)this + OFFplayerInfoMgr);
	}

	CWeaponManager* get_weapon_manager() {
		return *reinterpret_cast<CWeaponManager**>((char*)this + OFFweaponMgr);
	}

	CVehicleManager* get_vehicle_manager() {
		return *reinterpret_cast<CVehicleManager**>((char*)this + OFFvehMgr);
	}

	float get_health() {
		return std::abs(*reinterpret_cast<float*>((char*)this + 0x280) - 100);
	}

	float get_armor() {
		return (*(float*)((char*)this + 0x14E0));
	}

	unsigned int get_pedtype()
	{
		__int32 ped_type = *(__int32*)((char*)this + OFFpedType);

		return (ped_type << 11 >> 25);
	}

	CModelInfo* get_model_info() {
		return (*reinterpret_cast<CModelInfo**>((char*)this + 0x20));
	}

	CBoneManager* get_bone_manager() {
		return (*(CBoneManager**)((char*)this + 0x180));
	}

	__m128i get_head_pos() {
		return (*(__m128i*)((char*)this + 0x430));
	}

	__m128i get_neck_pos() {
		return (*(__m128i*)((char*)this + 0x4A0));
	}

	__m128i get_stomach_pos() {
		return (*(__m128i*)((char*)this + 0x4B0));
	}

	__m128i get_head_above() {
		return (*(__m128i*)((char*)this + 0x4E0));
	}

}; //Size=0x14F8

class CBoneManager
{
public:
	Vector4 vecTrans1; //0x0000 
	Vector4 vecTrans2; //0x0010 
	Vector4 vecTrans3; //0x0020 
	Vector4 fPosition; //0x0030 

};//Size=0x0040

class CAttacker
{
public:
	CObject* CPed0; //0x0000 
	char pad_0x0008[0x10]; //0x0008
	CObject* CPed1; //0x0018 
	char pad_0x0020[0x10]; //0x0020
	CObject* CPed2; //0x0030 

}; //Size=0x0038

class CWantedData
{
public:
	char pad_0x0000[0x1C]; //0x0000
	float fWantedCanChange; //0x001C 
	char pad_0x0020[0x10]; //0x0020
	Vector3 v3WantedCenterPos; //0x0030 
	char pad_0x003C[0x4]; //0x003C
	Vector3 v3WantedCenterPos2; //0x0040 
	char pad_0x004C[0x38]; //0x004C
	BYTE btFlag0; //0x0084 
	BYTE btFlag1; //0x0085 
	BYTE btFlag2; //0x0086 
	BYTE btFlag3; //0x0087 
	char pad_0x0088[0xC]; //0x0088
	DWORD dwWantedLevelFake; //0x0094 
	DWORD dwWantedLevel; //0x0098 

}; //Size=0x00AC

class CPlayerInfo
{
public:
	char pad_0x0000[0xA4]; //0x0000
	char N00000382[32]; //0x2A1AE9C0 
	char pad_0x00C4[0x7C0]; //0x00C4
	__int32 FakeWanted; //0x0884 
	__int32 RealWanted; //0x0888 
	char pad_0x088C[0x7C]; //0x088C

	std::string GetPlayerName() {
		return N00000382;
	}
	std::string GetPlayerName2() {
		return N00000382;
	}

	void SetWanted(int lvl) {
		FakeWanted = lvl; //Dirt
		RealWanted = lvl; //Dirt
	}
	__int32 GetWanted() {
		return RealWanted;
	}

}; //Size=0x0908


class CReplayInterfacePed
{
private:
	class CPedList
	{
	private:
		struct Ped
		{
			CObject* ped;
			char _pad0[0x8];

			__int32 get_handle() {
				return *reinterpret_cast<__int32*>((char*)this + 0x8);
			}
		};

	public:
		Ped peds[0x100];
	};

public:
	char _pad0[0x100];			// 0000 - 0100
	CPedList* ped_list;			// 0100 - 0108
	int max_peds;				// 0108 - 010C
	char _pad1[0x4];			// 010C - 0110
	int number_of_peds;		// 0110 - 0114

	void for_each_player(const std::function<void(CObject*, int)> fn)
	{
		for (auto index = 0; index < 0x100; ++index) {
			if (IsValidPtr(ped_list) && IsValidPtr(ped_list->peds[index].ped)) {
				auto entity = (ped_list->peds[index].ped);

				if (IsValidPtr(entity) && IsValidPtr(entity->_ObjectNavigation))
					fn(entity, index);
			}
		}
	}


	CObject* get_ped(int index)
	{
		if (IsValidPtr(ped_list) && IsValidPtr(ped_list->peds[index].ped))
			return (ped_list->peds[index].ped);
		else
			return NULL;
	}

	__int32 get_ped_handle(int index)
	{
		if (IsValidPtr(ped_list) && IsValidPtr(ped_list->peds[index].ped))
			return (ped_list->peds[index].get_handle());
		else
			return NULL;
	}
};

class CReplayInterface
{
public:
	void* game_interface;
	CCameraInterface* camera_interface;
	CReplayInterfaceVehicle* vehicle_interface;
	CReplayInterfacePed* ped_interface;
	CPickupInterface* pickup_interface;
	CObjectInterface* object_interface;
};

class CPrimaryAmmoCount
{
public:
	char pad_0x0000[0x18]; //0x0000
	__int32 AmmoCount; //0x0018 
};//Size=0x0040

class CAmmoCount
{
public:
	CPrimaryAmmoCount* _PrimaryAmmoCount; //0x0000 
	char pad_0x0008[0x38]; //0x0008

};//Size=0x0040

class CAmmoInfo
{
public:
	char pad_0x0000[0x8]; //0x0000
	CAmmoCount* _AmmoCount; //0x0008 
	char pad_0x0010[0x18]; //0x0010
	__int32 AmmoMax; //0x0028 
	char pad_0x002C[0x40C]; //0x002C

}; //Size=0x0438

class CWeaponObject
{
public:
	char _0x0000[8];
	CAmmoInfo* m_pAmmoInfo; //0x0008 
	char _0x0010[16];
	__int32 m_iAmmo; //0x0020 
	char _0x0024[20];

};//Size=0x0038

class CInventory
{
public:
	char _0x0000[72];
	CWeaponObject** WeaponList; //0x0048 

	CWeaponObject* getWeapon(int index) {
		return (CWeaponObject*)WeaponList[index];
	}
};//Size=0x0050

class CObjectWrapper
{
public:
	char _0x0000[60];
	__int16 TeamId; //0x003C 
	char _0x0040[104];
	CPlayerInfo* playerInfo; //0x00A8 
	char _0x00B0[64];

	__int16 GetTeamId() {
		return TeamId;
	}

};//Size=0x00F0

class CPlayers
{
public:
	char _0x0000[376];
	__int32 numPlayersOnline; //0x0178 
	char _0x017C[4];
	CObjectWrapper* ObjectWrapperList[600]; //0x0180 

	CObject* getPlayer(int index) {
		//if (IsValidPtr(ObjectWrapperList[index]) && IsValidPtr(ObjectWrapperList[index]->playerInfo) && IsValidPtr(ObjectWrapperList[index]->playerInfo->pCPed))
		//	return ObjectWrapperList[index]->playerInfo->pCPed;
		//else
		return 0;
	}

	CPlayerInfo* getPlayerInfo(int index) {
		if (IsValidPtr(ObjectWrapperList[index]) && IsValidPtr(ObjectWrapperList[index]->playerInfo))
			return ObjectWrapperList[index]->playerInfo;
		return 0;
	}

	int GetNumPlayersOnline() {
		if (numPlayersOnline > 1 && numPlayersOnline <= 0x20)
			return numPlayersOnline;
		else
			return 0;
	}
};

class CWorld
{
public:
	char _0x0000[8];
	CObject* pLocalPlayer; //0x0008 

	CObject* get_local_player()
	{
		return IsValidPtr(pLocalPlayer) ? pLocalPlayer : nullptr;
	}

	bool is_main_menu_active()
	{
		return *reinterpret_cast<BYTE*>((char*)this + 0x238) ? true : false;
	}
};//Size=0x0016

class CWorldFactory {
public:
	CWorld* world;
};

class CGameCameraAngles;
class CCameraManagerAngles;
class CCameraAngles;
class CPlayerAngles;
class CPlayerCameraData;

class CCameraAngles
{
public:
	char pad_0x0000[0x2C0]; //0x0000
	CPlayerAngles* VehiclePointer1; //0x02C0 
	CPlayerAngles* VehiclePointer2; //0x02C8 
	char pad_0x02D0[0xF0]; //0x02D0
	CPlayerAngles* pMyFPSAngles; //0x03C0 
	char pad_0x03C8[0x10]; //0x03C8
	__int64 pTPSCamEDX; //0x03D8 
	char pad_0x03E0[0x60]; //0x03E0

}; //Size=0x0440

class CPlayerAngles
{
public:
	char pad_0x0000[0x10]; //0x0000
	CPlayerCameraData* CamData; //0x0010 
	char pad_0x0018[0x28]; //0x0018
	Vector3 CamRotFPS; //0x0040 
	char pad_0x004C[0x14]; //0x004C
	Vector3 CrosshairLocation; //0x0060 
	char pad_0x006C[0x24]; //0x006C
	float FOV; //0x0090 
	char pad_0x0094[0x33C]; //0x0094
	Vector3 CamRot; //0x03D0 
	char pad_0x03DC[0x64]; //0x03DC

	void SetRot(Vector3 set) {
		CamRot = set;
	}
	void SetRot2(Vector3 set) {
		CamRotFPS = set;
	}
}; //Size=0x0440

class CGameCameraAngles
{
public:
	CCameraManagerAngles* pMyCameraManagerAngles; //0x0000  
	char _0x0008[56];

};//Size=0x0040 

class CCameraManagerAngles
{
public:
	CCameraAngles* pMyCameraAngles; //0x0000  

	//void SetAim(Vector3 SetRot1, Vector3 SetRot2) {
	//	pMyCameraAngles->VehiclePointer1->CamRot = SetRot1;
	//	pMyCameraAngles->VehiclePointer2->CamRot = SetRot2;
	//}

};//Size=0x0008 


class CPlayerAnglesVehicle
{
public:
	char pad_0x0000[0x10]; //0x0000
	CPlayerCameraData* CamData; //0x0010 
	char pad_0x0018[0x48]; //0x0018
	Vector3 CrosshairLocation; //0x0060 
	char pad_0x006C[0x24]; //0x006C
	float FOV; //0x0090 
	char pad_0x0094[0x33C]; //0x0094
	Vector3 CamRot; //0x03D0 
	char pad_0x03DC[0x64]; //0x03DC

}; //Size=0x0440
static DWORD OffsetPadd = 0x60;


class CPlayerCameraData
{
public:
	char _0x0000[48];
	float Fov_Zoom; //0x0030 
	char _0x0034[36];
	__int32 m_ZoomState; //0x0058 1 = Normal, 0 = Zoom, 10000+ = FPS

};//Size=0x0548

class CVehicleHandling
{
public:
	char pad_0x0000[0xC]; //0x0000
	float fMass; //0x000C 
	char pad_0x0010[0x10]; //0x0010
	Vector3 v3CentreOfMassOffset; //0x0020 
	char pad_0x002C[0x4]; //0x002C
	Vector3 v3InertiaMult; //0x0030 
	char pad_0x003C[0x4]; //0x003C
	float fPercentSubmerged; //0x0040 
	char pad_0x0044[0x8]; //0x0044
	float fAcceleration; //0x004C 
	BYTE btInitialDriveGears; //0x0050 
	char pad_0x0051[0x3]; //0x0051
	float fDriveInertia; //0x0054 
	float fClutchChangeRateScaleUpShift; //0x0058 
	float fClutchChangeRateScaleDownShift; //0x005C 
	float fInitialDriveForce; //0x0060 
	char pad_0x0064[0x8]; //0x0064
	float fBrakeForce; //0x006C 
	char pad_0x0070[0x4]; //0x0070
	float fBrakeBiasFront; //0x0074 
	char pad_0x0078[0x4]; //0x0078
	float fHandBrakeForce; //0x007C 
	char pad_0x0080[0x8]; //0x0080
	float fTractionCurveMax; //0x0088 
	char pad_0x008C[0x4]; //0x008C
	float fTractionCurveMin; //0x0090 
	char pad_0x0094[0xC]; //0x0094
	float fTractionSpringDeltaMax; //0x00A0 
	char pad_0x00A4[0x4]; //0x00A4
	float fLowSpeedTractionLossMult; //0x00A8 
	float fCamberStiffnesss; //0x00AC 
	float fTractionBiasFront; //0x00B0 
	float fTwoMinus_fTractionBiasFront; //0x00B4 
	float fTractionLossMult; //0x00B8 
	float fSuspensionForce; //0x00BC 
	float fSuspensionCompDamp; //0x00C0 
	float fSuspensionReboundDamp; //0x00C4 
	float fSuspensionUpperLimit; //0x00C8 
	float fSuspensionLowerLimit; //0x00CC 
	char pad_0x00D0[0xC]; //0x00D0
	float fAntiRollBarForce; //0x00DC 
	char pad_0x00E0[0x8]; //0x00E0
	float fRollCentreHeightFront; //0x00E8 
	float fRollCentreHeightRear; //0x00EC 
	float fCollisionDamageMult; //0x00F0 
	float fWeaponDamageMult; //0x00F4 
	float fDeformationDamageMult; //0x00F8 
	float fEngineDamageMult; //0x00FC 
	float fPetrolTankVolume; //0x0100 
	float fOilVolume; //0x0104 
}; //Size=0x0108

enum ePedType
{
	PEDTYPE_PLAYER_0,                // michael 
	PEDTYPE_PLAYER_1,                // franklin 
	PEDTYPE_NETWORK_PLAYER,            // mp character 
	PEDTYPE_PLAYER_2,                // trevor 
	PEDTYPE_CIVMALE,
	PEDTYPE_CIVFEMALE,
	PEDTYPE_COP,
	PEDTYPE_GANG_ALBANIAN,
	PEDTYPE_GANG_BIKER_1,
	PEDTYPE_GANG_BIKER_2,
	PEDTYPE_GANG_ITALIAN,
	PEDTYPE_GANG_RUSSIAN,
	PEDTYPE_GANG_RUSSIAN_2,
	PEDTYPE_GANG_IRISH,
	PEDTYPE_GANG_JAMAICAN,
	PEDTYPE_GANG_AFRICAN_AMERICAN,
	PEDTYPE_GANG_KOREAN,
	PEDTYPE_GANG_CHINESE_JAPANESE,
	PEDTYPE_GANG_PUERTO_RICAN,
	PEDTYPE_DEALER,
	PEDTYPE_MEDIC,
	PEDTYPE_FIREMAN,
	PEDTYPE_CRIMINAL,
	PEDTYPE_BUM,
	PEDTYPE_PROSTITUTE,
	PEDTYPE_SPECIAL,
	PEDTYPE_MISSION,
	PEDTYPE_SWAT,
	PEDTYPE_ANIMAL,
	PEDTYPE_ARMY
};

enum ExplosionTypes
{
	EXPLOSION_GRENADE,
	EXPLOSION_GRENADELAUNCHER,
	EXPLOSION_STICKYBOMB,
	EXPLOSION_MOLOTOV,
	EXPLOSION_ROCKET,
	EXPLOSION_TANKSHELL,
	EXPLOSION_HI_OCTANE,
	EXPLOSION_CAR,
	EXPLOSION_PLANE,
	EXPLOSION_PETROL_PUMP,
	EXPLOSION_BIKE,
	EXPLOSION_DIR_STEAM,
	EXPLOSION_DIR_FLAME,
	EXPLOSION_DIR_WATER_HYDRANT,
	EXPLOSION_DIR_GAS_CANISTER,
	EXPLOSION_BOAT,
	EXPLOSION_SHIP_DESTROY,
	EXPLOSION_TRUCK,
	EXPLOSION_BULLET,
	EXPLOSION_SMOKEGRENADELAUNCHER,
	EXPLOSION_SMOKEGRENADE,
	EXPLOSION_BZGAS,
	EXPLOSION_FLARE,
	EXPLOSION_GAS_CANISTER,
	EXPLOSION_EXTINGUISHER,
	EXPLOSION_PROGRAMMABLEAR,
	EXPLOSION_TRAIN,
	EXPLOSION_BARREL,
	EXPLOSION_PROPANE,
	EXPLOSION_BLIMP,
	EXPLOSION_DIR_FLAME_EXPLODE,
	EXPLOSION_TANKER,
	EXPLOSION_PLANE_ROCKET,
	EXPLOSION_VEHICLE_BULLET,
	EXPLOSION_GAS_TANK,
	EXPLOSION_BIRD_CRAP
};

enum WeaponHashes
{
	WEAPON_ADVANCEDRIFLE = 0xAF113F99,
	WEAPON_AIRSTRIKE_ROCKET = 0x13579279,
	WEAPON_ANIMAL = 0xF9FBAEBE,
	WEAPON_APPISTOL = 0x22D8FE39,
	WEAPON_ASSAULTRIFLE = 0xBFEFFF6D,
	WEAPON_ASSAULTSHOTGUN = 0xE284C527,
	WEAPON_ASSAULTSMG = 0xEFE7E2DF,
	WEAPON_TEC9 = 0xDB1AA450,
	WEAPON_DOUBLEBARRELED = 0xDB1AA450,
	WEAPON_BALL = 0x23C9F95C,
	WEAPON_BARBED_WIRE = 0x48E7B178,
	WEAPON_BAT = 0x958A4A8F,
	WEAPON_BLEEDING = 0x8B7333FB,
	WEAPON_BOTTLE = 0xF9E6AA4B,
	WEAPON_BRIEFCASE = 0x88C78EB7,
	WEAPON_BRIEFCASE_02 = 0x01B79F17,
	WEAPON_BULLPUPRIFLE = 0x7F229F94,
	WEAPON_COMPACTRIFLE = 0x624FE830,
	WEAPON_BULLPUPSHOTGUN = 0x9D61E50F,
	WEAPON_BZGAS = 0xA0973D5E,
	WEAPON_CARBINERIFLE = 0x83BF0278,
	WEAPON_COMBATMG = 0x7FD62962,
	WEAPON_PARACHUTE = 0xFBAB5776,
	WEAPON_COMBATPDW = 0xA3D4D34,
	WEAPON_COMBATPISTOL = 0x5EF9FEC4,
	WEAPON_COUGAR = 0x08D4BE52,
	WEAPON_CROWBAR = 0x84BD7BFD,
	WEAPON_DAGGER = 0x92A27487,
	WEAPON_DIGISCANNER = 0xFDBADCED,
	WEAPON_DROWNING = 0xFF58C4FB,
	WEAPON_DROWNING_IN_VEHICLE = 0x736F5990,
	WEAPON_ELECTRIC_FENCE = 0x92BD4EBB,
	WEAPON_EXHAUSTION = 0x364A29EC,
	WEAPON_EXPLOSION = 0x2024F4E8,
	WEAPON_FALL = 0xCDC174B0,
	WEAPON_FIRE = 0xDF8E89EB,
	WEAPON_FIREEXTINGUISHER = 0x060EC506,
	WEAPON_FIREWORK = 0x7F7497E5,
	WEAPON_FLARE = 0x497FACC3,
	WEAPON_FLAREGUN = 0x47757124,
	WEAPON_GARBAGEBAG = 0xE232C28C,
	WEAPON_GOLFCLUB = 0x440E4788,
	WEAPON_GRENADE = 0x93E220BD,
	WEAPON_GRENADELAUNCHER = 0xA284510B,
	WEAPON_GRENADELAUNCHER_SMOKE = 0x4DD2DC56,
	WEAPON_GUSENBERG = 0x61012683,
	WEAPON_HAMMER = 0x4E875F73,
	WEAPON_HANDCUFFS = 0xD04C944D,
	WEAPON_HEAVYPISTOL = 0xD205520E,
	WEAPON_HEAVYSHOTGUN = 0x3AABBBAA,
	WEAPON_HEAVYSNIPER = 0x0C472FE2,
	WEAPON_HELI_CRASH = 0x145F1012,
	WEAPON_HIT_BY_WATER_CANNON = 0xCC34325E,
	WEAPON_HOMINGLAUNCHER = 0x63AB0442,
	WEAPON_KNIFE = 0x99B507EA,
	WEAPON_KNUCKLE = 0xD8DF3C3C,
	WEAPON_MARKSMANPISTOL = 0xDC4DB296,
	WEAPON_MARKSMANRIFLE = 0xC734385A,
	WEAPON_MG = 0x9D07F764,
	WEAPON_HATCHET = 0xF9DCBF2D,
	WEAPON_FLASHLIGHT = 0x8BB05FD7,
	WEAPON_MACHINEPISTOL = 0xDB1AA450,
	WEAPON_MACHETE = 0xDD5DF8D9,
	WEAPON_SWITCHBLADE = 0xDFE37640,
	WEAPON_REVOLVER = 0xC1B3C3D1,
	WEAPON_MICROSMG = 0x13532244,
	WEAPON_MINIGUN = 0x42BF8A85,
	WEAPON_MOLOTOV = 0x24B17070,
	WEAPON_MUSKET = 0xA89CB99E,
	WEAPON_NIGHTSTICK = 0x678B81B1,
	WEAPON_PASSENGER_ROCKET = 0x166218FF,
	WEAPON_PETROLCAN = 0x34A67B97,
	WEAPON_PISTOL = 0x1B06D571,
	WEAPON_PISTOL50 = 0x99AEEB3B,
	WEAPON_PROXMINE = 0xAB564B93,
	WEAPON_PUMPSHOTGUN = 0x1D073A89,
	WEAPON_RAILGUN = 0x6D544C99,
	WEAPON_RAMMED_BY_CAR = 0x07FC7D7A,
	WEAPON_REMOTESNIPER = 0x33058E22,
	WEAPON_RPG = 0xB1CA77B1,
	WEAPON_RUN_OVER_BY_CAR = 0xA36D413E,
	WEAPON_SAWNOFFSHOTGUN = 0x7846A318,
	WEAPON_SMG = 0x2BE6766B,
	WEAPON_SMOKEGRENADE = 0xFDBC8A50,
	WEAPON_SNIPERRIFLE = 0x05FC3C11,
	WEAPON_SNOWBALL = 0x787F0BB,
	WEAPON_SNSPISTOL = 0xBFD21232,
	WEAPON_SPECIALCARBINE = 0xC0A3098D,
	WEAPON_STICKYBOMB = 0x2C3731D9,
	WEAPON_STINGER = 0x687652CE,
	WEAPON_STUNGUN = 0x3656C8C1,
	WEAPON_UNARMED = 0xA2719263,
	WEAPON_VEHICLE_ROCKET = 0xBEFDC581,
	WEAPON_VINTAGEPISTOL = 0x083839C4
};

class CBlip
{
public:
	__int32 iID; //0x0000 
	__int8 iID2; //0x0004 
	char _0x0005[3];
	BYTE N000010FB; //0x0008 (80 = moves with player, some values will turn icon into map cursor and break it)
	char _0x0009[7];
	Vector3 v3Pos;
	char _0x001C[6];
	BYTE btFocused; //0x0022   (Focused? 0100 0000)
	char _0x0023[5];
	char* szMessage; //0x0028 If not null, contains the string of whatever the blip says when selected.
	char _0x0030[16];
	int iIcon; //0x0040
	char _0x0044[4];
	DWORD dwColor; //0x0048 (Sometimes works?)
	char _0x004C[4];
	float fScale; //0x0050 
	__int16 iRotation; //0x0054 Heading
	BYTE btInfoIDType; //0x0056 GET_BLIP_INFO_ID_TYPE
	BYTE btZIndex; //0x0057 
	BYTE btDisplay; //0x0058  Also Visibility 0010
	BYTE btAlpha; //0x0059
};//Size=0x005A

class CBlipList
{
public:
	CBlip* m_Blips[1500]; //0x0000 

};//Size=0x2F18

enum eBlipColor
{
	ColorWhite = 0,
	ColorRed = 1,
	ColorGreen = 2,
	ColorBlue = 3,
	ColorPlayer = 4,
	ColorYellow = 5,
	ColorPurple = 7,
	ColorVehicle = 38,
	ColorMichael = 42,
	ColorFranklin = 43,
	ColorTrevor = 44,
	ColorMissionRed = 49,
	ColorMissionVehicle = 54,
	ColorYellowMission = 66,
	ColorYellowMission2 = 60,
	ColorWaypoint = 84
};

enum eBlipSprite
{
	SpriteStandard = 1,
	SpriteBig = 2,
	SpritePoliceOfficer = 3,
	SpritePoliceArea = 4,
	SpriteSquare = 5,
	SpritePlayer = 6,
	SpriteNorth = 7,
	SpriteWaypoint = 8,
	SpriteBigCircle = 9,
	SpriteBigCircleOutline = 10,
	SpriteArrowUpOutlined = 11,
	SpriteArrowDownOutlined = 12,
	SpriteArrowUp = 13,
	SpriteArrowDown = 14,
	SpritePoliceHelicopterAnimated = 15,
	SpriteJet = 16,
	SpriteNumber1 = 17,
	SpriteNumber2 = 18,
	SpriteNumber3 = 19,
	SpriteNumber4 = 20,
	SpriteNumber5 = 21,
	SpriteNumber6 = 22,
	SpriteNumber7 = 23,
	SpriteNumber8 = 24,
	SpriteNumber9 = 25,
	SpriteNumber10 = 26,
	SpriteGTAOCrew = 27,
	SpriteGTAOFriendly = 28,
	SpriteLift = 36,
	SpriteRaceFinish = 38,
	SpriteSafehouse = 40,
	SpritePoliceOfficer2 = 41,
	SpritePoliceCarDot = 42,
	SpritePoliceHelicopter = 43,
	SpriteChatBubble = 47,
	SpriteGarage2 = 50,
	SpriteDrugs = 51,
	SpriteStore = 52,
	SpritePoliceCar = 56,
	SpritePolicePlayer = 58,
	SpritePoliceStation = 60,
	SpriteHospital = 61,
	SpriteHelicopter = 64,
	SpriteStrangersAndFreaks = 65,
	SpriteArmoredTruck = 66,
	SpriteTowTruck = 68,
	SpriteBarber = 71,
	SpriteLosSantosCustoms = 72,
	SpriteClothes = 73,
	SpriteTattooParlor = 75,
	SpriteSimeon = 76,
	SpriteLester = 77,
	SpriteMichael = 78,
	SpriteTrevor = 79,
	SpriteRampage = 84,
	SpriteVinewoodTours = 85,
	SpriteLamar = 86,
	SpriteFranklin = 88,
	SpriteChinese = 89,
	SpriteAirport = 90,
	SpriteBar = 93,
	SpriteBaseJump = 94,
	SpriteCarWash = 100,
	SpriteComedyClub = 102,
	SpriteDart = 103,
	SpriteFIB = 106,
	SpriteDollarSign = 108,
	SpriteGolf = 109,
	SpriteAmmuNation = 110,
	SpriteExile = 112,
	SpriteShootingRange = 119,
	SpriteSolomon = 120,
	SpriteStripClub = 121,
	SpriteTennis = 122,
	SpriteTriathlon = 126,
	SpriteOffRoadRaceFinish = 127,
	SpriteKey = 134,
	SpriteMovieTheater = 135,
	SpriteMusic = 136,
	SpriteMarijuana = 140,
	SpriteHunting = 141,
	SpriteArmsTraffickingGround = 147,
	SpriteNigel = 149,
	SpriteAssaultRifle = 150,
	SpriteBat = 151,
	SpriteGrenade = 152,
	SpriteHealth = 153,
	SpriteKnife = 154,
	SpriteMolotov = 155,
	SpritePistol = 156,
	SpriteRPG = 157,
	SpriteShotgun = 158,
	SpriteSMG = 159,
	SpriteSniper = 160,
	SpriteSonicWave = 161,
	SpritePointOfInterest = 162,
	SpriteGTAOPassive = 163,
	SpriteGTAOUsingMenu = 164,
	SpriteLink = 171,
	SpriteMinigun = 173,
	SpriteGrenadeLauncher = 174,
	SpriteArmor = 175,
	SpriteCastle = 176,
	SpriteCamera = 184,
	SpriteHandcuffs = 188,
	SpriteYoga = 197,
	SpriteCab = 198,
	SpriteNumber11 = 199,
	SpriteNumber12 = 200,
	SpriteNumber13 = 201,
	SpriteNumber14 = 202,
	SpriteNumber15 = 203,
	SpriteNumber16 = 204,
	SpriteShrink = 205,
	SpriteEpsilon = 206,
	SpritePersonalVehicleCar = 225,
	SpritePersonalVehicleBike = 226,
	SpriteCustody = 237,
	SpriteArmsTraffickingAir = 251,
	SpriteFairground = 266,
	SpritePropertyManagement = 267,
	SpriteAltruist = 269,
	SpriteEnemy = 270,
	SpriteChop = 273,
	SpriteDead = 274,
	SpriteHooker = 279,
	SpriteFriend = 280,
	SpriteBountyHit = 303,
	SpriteGTAOMission = 304,
	SpriteGTAOSurvival = 305,
	SpriteCrateDrop = 306,
	SpritePlaneDrop = 307,
	SpriteSub = 308,
	SpriteRace = 309,
	SpriteDeathmatch = 310,
	SpriteArmWrestling = 311,
	SpriteAmmuNationShootingRange = 313,
	SpriteRaceAir = 314,
	SpriteRaceCar = 315,
	SpriteRaceSea = 316,
	SpriteGarbageTruck = 318,
	SpriteMotorCycle = 348,
	SpriteSafehouseForSale = 350,
	SpritePackage = 351,
	SpriteMartinMadrazo = 352,
	SpriteEnemyHelicopter = 353,
	SpriteBoost = 354,
	SpriteDevin = 355,
	SpriteMarina = 356,
	SpriteGarage = 357,
	SpriteGolfFlag = 358,
	SpriteHangar = 359,
	SpriteHelipad = 360,
	SpriteJerryCan = 361,
	SpriteMasks = 362,
	SpriteHeistSetup = 363,
	SpriteIncapacitated = 364,
	SpritePickupSpawn = 365,
	SpriteBoilerSuit = 366,
	SpriteCompleted = 367,
	SpriteRockets = 368,
	SpriteGarageForSale = 369,
	SpriteHelipadForSale = 370,
	SpriteMarinaForSale = 371,
	SpriteHangarForSale = 372,
	SpriteBusiness = 374,
	SpriteBusinessForSale = 375,
	SpriteRaceBike = 376,
	SpriteParachute = 377,
	SpriteTeamDeathmatch = 378,
	SpriteRaceFoot = 379,
	SpriteVehicleDeathmatch = 380,
	SpriteBarry = 381,
	SpriteDom = 382,
	SpriteMaryAnn = 383,
	SpriteCletus = 384,
	SpriteJosh = 385,
	SpriteMinute = 386,
	SpriteOmega = 387,
	SpriteTonya = 388,
	SpritePaparazzo = 389,
	SpriteCrosshair = 390,
	SpriteCreator = 398,
	SpriteCreatorDirection = 399,
	SpriteAbigail = 400,
	SpriteBlimp = 401,
	SpriteRepair = 402,
	SpriteTestosterone = 403,
	SpriteDinghy = 404,
	SpriteFanatic = 405,
	SpriteInformation = 407,
	SpriteCaptureBriefcase = 408,
	SpriteLastTeamStanding = 409,
	SpriteBoat = 410,
	SpriteCaptureHouse = 411,
	SpriteJerryCan2 = 415,
	SpriteRP = 416,
	SpriteGTAOPlayerSafehouse = 417,
	SpriteGTAOPlayerSafehouseDead = 418,
	SpriteCaptureAmericanFlag = 419,
	SpriteCaptureFlag = 420,
	SpriteTank = 421,
	SpriteHelicopterAnimated = 422,
	SpritePlane = 423,
	SpriteJet2 = 424,
	SpritePlayerNoColor = 425,
	SpriteGunCar = 426,
	SpriteSpeedboat = 427,
	SpriteHeist = 428,
	SpriteStopwatch = 430,
	SpriteDollarSignCircled = 431,
	SpriteCrosshair2 = 432,
	SpriteDollarSignSquared = 434,
};



enum IntersectOptions {
	IntersectEverything = -1,
	IntersectMap = 1,
	IntersectMissionEntityAndTrain = 2,
	IntersectPeds1 = 4,
	IntersectPeds2 = 8,
	IntersectVehicles = 10,
	IntersectObjects = 16,
	IntersectVegetation = 256
};

enum eRockstarEvent
{
	REVENT_SCRIPT_ARRAY_DATA_VERIFY_EVENT,
	REVENT_REQUEST_CONTROL_EVENT,
	REVENT_GIVE_CONTROL_EVENT,
	REVENT_WEAPON_DAMAGE_EVENT,
	REVENT_REQUEST_PICKUP_EVENT,
	REVENT_REQUEST_MAP_PICKUP_EVENT,
	REVENT_GAME_CLOCK_EVENT,
	REVENT_GAME_WEATHER_EVENT,
	REVENT_RESPAWN_PLAYER_PED_EVENT,
	REVENT_GIVE_WEAPON_EVENT,
	REVENT_REMOVE_WEAPON_EVENT,
	REVENT_REMOVE_ALL_WEAPONS_EVENT,
	REVENT_VEHICLE_COMPONENT_CONTROL_EVENT,
	REVENT_FIRE_EVENT,
	REVENT_EXPLOSION_EVENT,
	REVENT_START_PROJECTILE_EVENT,
	REVENT_ALTER_WANTED_LEVEL_EVENT,
	REVENT_CHANGE_RADIO_STATION_EVENT,
	REVENT_RAGDOLL_REQUEST_EVENT,
	REVENT_PLAYER_TAUNT_EVENT,
	REVENT_PLAYER_CARD_STAT_EVENT,
	REVENT_DOOR_BREAK_EVENT,
	REVENT_SCRIPTED_GAME_EVENT,
	REVENT_REMOTE_SCRIPT_INFO_EVENT,
	REVENT_REMOTE_SCRIPT_LEAVE_EVENT,
	REVENT_MARK_AS_NO_LONGER_NEEDED_EVENT,
	REVENT_CONVERT_TO_SCRIPT_ENTITY_EVENT,
	REVENT_SCRIPT_WORLD_STATE_EVENT,
	REVENT_INCIDENT_ENTITY_EVENT,
	REVENT_CLEAR_AREA_EVENT,
	REVENT_CLEAR_RECTANGLE_AREA_EVENT,
	REVENT_NETWORK_REQUEST_SYNCED_SCENE_EVENT,
	REVENT_NETWORK_START_SYNCED_SCENE_EVENT,
	REVENT_NETWORK_UPDATE_SYNCED_SCENE_EVENT,
	REVENT_NETWORK_STOP_SYNCED_SCENE_EVENT,
	REVENT_GIVE_PED_SCRIPTED_TASK_EVENT,
	REVENT_GIVE_PED_SEQUENCE_TASK_EVENT,
	REVENT_NETWORK_CLEAR_PED_TASKS_EVENT,
	REVENT_NETWORK_START_PED_ARREST_EVENT,
	REVENT_NETWORK_START_PED_UNCUFF_EVENT,
	REVENT_NETWORK_SOUND_CAR_HORN_EVENT,
	REVENT_NETWORK_ENTITY_AREA_STATUS_EVENT,
	REVENT_NETWORK_GARAGE_OCCUPIED_STATUS_EVENT,
	REVENT_PED_CONVERSATION_LINE_EVENT,
	REVENT_SCRIPT_ENTITY_STATE_CHANGE_EVENT,
	REVENT_NETWORK_PLAY_SOUND_EVENT,
	REVENT_NETWORK_STOP_SOUND_EVENT,
	REVENT_NETWORK_PLAY_AIRDEFENSE_FIRE_EVENT,
	REVENT_NETWORK_BANK_REQUEST_EVENT,
	REVENT_REQUEST_DOOR_EVENT,
	REVENT_NETWORK_TRAIN_REQUEST_EVENT,
	REVENT_NETWORK_TRAIN_REPORT_EVENT,
	REVENT_NETWORK_INCREMENT_STAT_EVENT,
	REVENT_MODIFY_VEHICLE_LOCK_WORD_STATE_DATA,
	REVENT_REQUEST_PHONE_EXPLOSION_EVENT,
	REVENT_REQUEST_DETACHMENT_EVENT,
	REVENT_KICK_VOTES_EVENT,
	REVENT_GIVE_PICKUP_REWARDS_EVENT,
	REVENT_NETWORK_CRC_HASH_CHECK_EVENT,
	REVENT_BLOW_UP_VEHICLE_EVENT,
	REVENT_NETWORK_SPECIAL_FIRE_EQUIPPED_WEAPON,
	REVENT_NETWORK_RESPONDED_TO_THREAT_EVENT,
	REVENT_NETWORK_SHOUT_TARGET_POSITION,
	REVENT_VOICE_DRIVEN_MOUTH_MOVEMENT_FINISHED_EVENT,
	REVENT_PICKUP_DESTROYED_EVENT,
	REVENT_UPDATE_PLAYER_SCARS_EVENT,
	REVENT_NETWORK_CHECK_EXE_SIZE_EVENT,
	REVENT_NETWORK_PTFX_EVENT,
	REVENT_NETWORK_PED_SEEN_DEAD_PED_EVENT,
	REVENT_REMOVE_STICKY_BOMB_EVENT,
	REVENT_NETWORK_CHECK_CODE_CRCS_EVENT,
	REVENT_INFORM_SILENCED_GUNSHOT_EVENT,
	REVENT_PED_PLAY_PAIN_EVENT,
	REVENT_CACHE_PLAYER_HEAD_BLEND_DATA_EVENT,
	REVENT_REMOVE_PED_FROM_PEDGROUP_EVENT,
	REVENT_REPORT_MYSELF_EVENT,
	REVENT_REPORT_CASH_SPAWN_EVENT,
	REVENT_ACTIVATE_VEHICLE_SPECIAL_ABILITY_EVENT,
	REVENT_BLOCK_WEAPON_SELECTION,
	REVENT_NETWORK_CHECK_CATALOG_CRC,
	REVENT_END
};

enum eExplosionTag
{
	EXP_TAG_DONTCARE = -1,
	EXP_TAG_GRENADE,
	EXP_TAG_GRENADELAUNCHER,
	EXP_TAG_STICKYBOMB,
	EXP_TAG_MOLOTOV,
	EXP_TAG_ROCKET,
	EXP_TAG_TANKSHELL,
	EXP_TAG_HI_OCTANE,
	EXP_TAG_CAR,
	EXP_TAG_PLANE,
	EXP_TAG_PETROL_PUMP,
	EXP_TAG_BIKE,
	EXP_TAG_DIR_STEAM,
	EXP_TAG_DIR_FLAME,
	EXP_TAG_DIR_WATER_HYDRANT,
	EXP_TAG_DIR_GAS_CANISTER,
	EXP_TAG_BOAT,
	EXP_TAG_SHIP_DESTROY,
	EXP_TAG_TRUCK,
	EXP_TAG_BULLET,
	EXP_TAG_SMOKEGRENADELAUNCHER,
	EXP_TAG_SMOKEGRENADE,
	EXP_TAG_BZGAS,
	EXP_TAG_FLARE,
	EXP_TAG_GAS_CANISTER,
	EXP_TAG_EXTINGUISHER,
	EXP_TAG_PROGRAMMABLEAR,
	EXP_TAG_TRAIN,
	EXP_TAG_BARREL,
	EXP_TAG_PROPANE,
	EXP_TAG_BLIMP,
	EXP_TAG_DIR_FLAME_EXPLODE,
	EXP_TAG_TANKER,
	EXP_TAG_PLANE_ROCKET,
	EXP_TAG_VEHICLE_BULLET,
	EXP_TAG_GAS_TANK,
	EXP_TAG_BIRD_CRAP,
	EXP_TAG_RAILGUN,
	EXP_TAG_BLIMP2,
	EXP_TAG_FIREWORK,
	EXP_TAG_SNOWBALL,
	EXP_TAG_PROXMINE,
	EXP_TAG_VALKYRIE_CANNON,
	EXP_TAG_AIR_DEFENCE,
	EXP_TAG_PIPEBOMB,
	EXP_TAG_VEHICLEMINE,
	EXP_TAG_EXPLOSIVEAMMO,
	EXP_TAG_APCSHELL,
	EXP_TAG_BOMB_CLUSTER,
	EXP_TAG_BOMB_GAS,
	EXP_TAG_BOMB_INCENDIARY,
	EXP_TAG_BOMB_STANDARD,
	EXP_TAG_TORPEDO,
	EXP_TAG_TORPEDO_UNDERWATER,
	EXP_TAG_BOMBUSHKA_CANNON,
	EXP_TAG_BOMB_CLUSTER_SECONDARY,
	EXP_TAG_HUNTER_BARRAGE,
	EXP_TAG_HUNTER_CANNON,
	EXP_TAG_ROGUE_CANNON,
	EXP_TAG_MINE_UNDERWATER,
	EXP_TAG_ORBITAL_CANNON,
	EXP_TAG_BOMB_STANDARD_WIDE,
	EXP_TAG_EXPLOSIVEAMMO_SHOTGUN,
	EXP_TAG_OPPRESSOR2_CANNON,
	EXP_TAG_MORTAR_KINETIC,
	EXP_TAG_VEHICLEMINE_KINETIC,
	EXP_TAG_VEHICLEMINE_EMP,
	EXP_TAG_VEHICLEMINE_SPIKE,
	EXP_TAG_VEHICLEMINE_SLICK,
	EXP_TAG_VEHICLEMINE_TAR,
	EXP_TAG_SCRIPT_DRONE,
	EXP_TAG_RAYGUN,
	EXP_TAG_BURIEDMINE,
	EXP_TAG_SCRIPT_MISSILE
};

enum PlateTextIndexs
{
	PLATE_BLUEONWHITE1,
	PLATE_YELLOWONBLACK,
	PLATE_YELLOWONBLUE,
	PLATE_BLUEONWHITE2,
	PLATE_BLUEONWHITE3,
	PLATE_YANKTON
};

enum VehicleModTypes
{
	MOD_SPOILER,
	MOD_FRONTBUMPER,
	MOD_REARBUMPER,
	MOD_SIDESKIRT,
	MOD_EXHAUST,
	MOD_CHASSIS, //Or roll cage
	MOD_GRILLE,
	MOD_HOOD,
	MOD_FENDER,
	MOD_RIGHTFENDER,
	MOD_ROOF,
	MOD_ENGINE,
	MOD_BRAKES,
	MOD_TRANSMISSION,
	MOD_HORNS,
	MOD_SUSPENSION,
	MOD_ARMOR,
	MOD_UNK17 = 17,
	MOD_TURBO = 18,
	MOD_UNK19 = 19,
	MOD_TIRESMOKE = 20,
	MOD_UNK21 = 21,
	MOD_XENONLIGHTS = 22,
	MOD_FRONTWHEELS = 23,
	MOD_BACKWHEELS = 24, //Bikes only

	// Benny's
	MOD_PLATEHOLDER = 25,
	MOD_VANITY_PLATES = 26,
	MOD_TRIM = 27,
	MOD_ORNAMENTS = 28,
	MOD_DASHBOARD = 29,
	MOD_DIAL = 30,
	MOD_DOOR_SPEAKER = 31,
	MOD_SEATS = 32,
	MOD_STEERINGWHEEL = 33,
	MOD_SHIFTER_LEAVERS = 34,
	MOD_PLAQUES = 35,
	MOD_SPEAKERS = 36,
	MOD_TRUNK = 37,
	MOD_HYDRULICS = 38,
	MOD_ENGINE_BLOCK = 39,
	MOD_AIR_FILTER = 40,
	MOD_STRUTS = 41,
	MOD_ARCH_COVER = 42,
	MOD_AERIALS = 43,
	//MOD_TRIM = 44,
	MOD_TANK = 45,
	MOD_WINDOWS = 46,
	MOD_UNK47 = 47,
	MOD_LIVERY = 48
};

enum HighEndWheels
{
	WHEEL_HIGHEND_STOCK = -1,
	WHEEL_HIGHEND_SHADOW,
	WHEEL_HIGHEND_HYPHER,
	WHEEL_HIGHEND_BLADE,
	WHEEL_HIGHEND_DIAMOND,
	WHEEL_HIGHEND_SUPAGEE,
	WHEEL_HIGHEND_CHROMATICZ,
	WHEEL_HIGHEND_MERCIECHLIP,
	WHEEL_HIGHEND_OBEYRS,
	WHEEL_HIGHEND_GTCHROME,
	WHEEL_HIGHEND_CHEETAHR,
	WHEEL_HIGHEND_SOLAR,
	WHEEL_HIGHEND_SPLITTEN,
	WHEEL_HIGHEND_DASHVIP,
	WHEEL_HIGHEND_LOZSPEEDTEN,
	WHEEL_HIGHEND_CARBONINFERNO,
	WHEEL_HIGHEND_CARBONSHADOW,
	WHEEL_HIGHEND_CARBONZ,
	WHEEL_HIGHEND_CARBONSOLAR,
	WHEEL_HIGHEND_CARBONCHEETAHR,
	WHEEL_HIGHEND_CARBONSRACER
};


class CWaterDataItem
{
public:
	__int16 iMinX; //0x0000 X Coord 1
	__int16 iMinY; //0x0002  Y Coord 1
	__int16 iMaxX; //0x0004 X Coord 2
	__int16 iMaxY; //0x0006 Y Coord 2
	__int8 iAlphaSW; //0x0008  (South West, default 26)
	__int8 iAlphaSE; //0x0009  (South East, default 26)
	__int8 iAlphaNW; //0x000A  (North West, default 26)
	__int8 iAlphaNE; //0x000B  (North East, default 26)
	char _0x000C[8]; // (Unknown, appear to be two floats?)
	float fHeight; //0x0014 (Z-Height, default 0.0)
	BYTE bHasLimitedDepth; //0x0018  (Second bit [binary 10] = On, gives the water quad an effective range of 6 z-points)
	char _0x0019[3]; // (Unknown)
};//Size=0x001C

class CWaterTune
{
public:
	DWORD dwWaterColor; //0x0000  Default: 0x1A00191C
	float fRippleScale; //0x0004  Default: 0.040000f
	float fOceanFoamScale; //0x0008  Default: 0.050000f
	float fSpecularFalloff; //0x000C  Default: 1118.000000f
	float fFodPierceIntensity; //0x0010  Default: 1.100000f
	float fRefractionBlend; //0x0014  Default: 0.700000f
	float fRefractionExponent; //0x0018  Default: 0.250000f
	float fWaterCycleDepth; //0x001C  Default: 10.000000f
	float fWaterCycleFade; //0x0020  Default: 50.000000f
	float fWaterLightningDepth; //0x0024  Default: 0.000000f
	float fWaterLightningFade; //0x0028  Default: 10.000000f
	float fDeepWaterModDepth; //0x002C  Default: 90.000000f
	float fDeepWaterModFade; //0x0030  Default: 80.000000f
	float fGodRaysLerpStart; //0x0034  Default: 0.000000f
	float fGodRaysLerpEnd; //0x0038  Default: 200.000000f
	float fDisturbFoamScale; //0x003C  Default: 0.050000f
	Vector2 vec2FogMin; //0x0040  Default: x = -4000.000000 y = -4000.000000
	Vector2 vec2FogMax; //0x0048  Default: x = 4500.000000 y= 8000.000000
};//Size=0x0050

struct n_ped_t {
	int32_t index;

	CObject* ped;
	CPlayerBones ped_bones;
	CPlayerOffsets ped_offsets;

	bool is_visible;
};

enum class game_state_t : std::uint32_t
{
	playing,
	intro,
	unk,
	license,
	main_menu,
	load_online
};

enum class thread_state_t : std::uint32_t
{
	idle,
	running,
	killed,
	unk_3,
	unk_4,
};

class thread_context_t
{
public:
	std::uint32_t m_thread_id;
	std::uint32_t m_script_hash; // + 4 (program id)
	thread_state_t m_state; // + 8
	std::uint32_t m_instruction_pointer; // 0x0C
	std::uint32_t m_frame_pointer;       // 0x10
	std::uint32_t m_stack_pointer;       // 0x14
	float m_timer_a;                     // 0x18
	float m_timer_b;                     // 0x1C
	float m_timer_c;                     // 0x20
	char m_padding1[0x2C];               // 0x24
	std::uint32_t m_stack_size;          // 0x50
	char m_padding2[0x54];               // 0x54
};

template<typename type>
class array_collection
{
private:
	type* data;
	uint16_t	count;
	uint16_t	size;

public:
	type* begin()
	{
		return data;
	}

	type* end()
	{
		return (data + count);
	}

	type* at(uint16_t index)
	{
		return &data[index];
	}
};

```

`include/imports.hpp`:

```hpp
#pragma once
#define WIN32_LEAN_AND_MEAN

#ifndef ENET_DEBUG
#define ENET_DEBUG
#endif

#include <windows.h>
#include <string>
#include <thread>
#include <optional>
#include <vector>
#include <sstream>
#include <d3d11.h>
#include <functional>
#include <xmmintrin.h>
#include <iostream>
#include <thread>
#include <map>
#include <Winternl.h>
#include <memory>
#include <mutex> 

// nlohmann
#include <vendor/nlohmann/json.hpp>

// min_hook
#include <vendor/minhook.hpp>

// fontwrapper
#include <vendor/fontwrapper/FW1FontWrapper.h>
#include <vendor/fontwrapper/FW1CompileSettings.h>
#include <vendor/fontwrapper/FW1Precompiled.h>
#include <vendor/fontwrapper/CFW1TextRenderer.h>
#include <vendor/fontwrapper/CFW1TextGeometry.h>
#include <vendor/fontwrapper/CFW1StateSaver.h>
#include <vendor/fontwrapper/CFW1Object.h>
#include <vendor/fontwrapper/CFW1GlyphVertexDrawer.h>
#include <vendor/fontwrapper/CFW1GlyphSheet.h>
#include <vendor/fontwrapper/CFW1GlyphRenderStates.h>
#include <vendor/fontwrapper/CFW1GlyphProvider.h>
#include <vendor/fontwrapper/CFW1GlyphAtlas.h>
#include <vendor/fontwrapper/CFW1FontWrapper.h>
#include <vendor/fontwrapper/CFW1Factory.h>
#include <vendor/fontwrapper/CFW1DWriteRenderTarget.h>
#include <vendor/fontwrapper/CFW1ColorRGBA.h>

//alt
#include <vendor/alt/alt-log.hpp>
using namespace alt;

#include <vendor/singleton.hpp>
#include <vendor/xor.hpp>

#define _WINSOCK_DEPRECATED_NO_WARNINGS
#include "networking/enet.h"


```

`include/nemo.hpp`:

```hpp
#pragma once
#include "imports.hpp"

#define NETWORKING
using namespace std;

class nemo_ac : public c_singleton<nemo_ac>
{
public:
	struct nemo_local_player_t {
		std::string ingame_character_name;
		std::string ip_address;
	};

	nemo_local_player_t local_player;

	void run_service(HMODULE module);
	void shutdown_service();
};
```

`include/networking/data/data.hpp`:

```hpp
#pragma once
#include <string>
class UserData
{
public:
    UserData(int id) : m_id(id) {}

    int m_id;
    std::string m_username;
};
```

`include/networking/data/packet.h`:

```h
// Copyright 2017 Citra Emulator Project
// Licensed under GPLv2 or any later version
// Refer to the license.txt file included.

#pragma once

#include <array>
#include <vector>

typedef std::uint8_t u8;   ///< 8-bit unsigned byte
typedef std::uint16_t u16; ///< 16-bit unsigned short
typedef std::uint32_t u32; ///< 32-bit unsigned word
typedef std::uint64_t u64; ///< 64-bit unsigned int

typedef std::int8_t s8;   ///< 8-bit signed byte
typedef std::int16_t s16; ///< 16-bit signed short
typedef std::int32_t s32; ///< 32-bit signed word
typedef std::int64_t s64; ///< 64-bit signed int

typedef float f32;  ///< 32-bit floating point
typedef double f64; ///< 64-bit floating point

// TODO: It would be nice to eventually replace these with strong types that prevent accidental
// conversion between each other.
typedef u32 VAddr; ///< Represents a pointer in the userspace virtual address space.
typedef u32 PAddr; ///< Represents a pointer in the ARM11 physical address space.

namespace Network {

    /// A class that serializes data for network transfer. It also handles endianess
    class Packet {
    public:
        Packet() = default;
        ~Packet() = default;

        /**
         * Append data to the end of the packet
         * @param data        Pointer to the sequence of bytes to append
         * @param size_in_bytes Number of bytes to append
         */
        void Append(const void* data, std::size_t size_in_bytes);

        /**
         * Reads data from the current read position of the packet
         * @param out_data        Pointer where the data should get written to
         * @param size_in_bytes Number of bytes to read
         */
        void Read(void* out_data, std::size_t size_in_bytes);

        /**
         * Clear the packet
         * After calling Clear, the packet is empty.
         */
        void Clear();

        /**
         * Ignores bytes while reading
         * @param length THe number of bytes to ignore
         */
        void IgnoreBytes(u32 length);

        /**
         * Get a pointer to the data contained in the packet
         * @return Pointer to the data
         */
        const void* GetData() const;

        /**
         * This function returns the number of bytes pointed to by
         * what getData returns.
         * @return Data size, in bytes
         */
        std::size_t GetDataSize() const;

        /**
         * This function is useful to know if there is some data
         * left to be read, without actually reading it.
         * @return True if all data was read, false otherwise
         */
        bool EndOfPacket() const;

        explicit operator bool() const;

        /// Overloads of operator >> to read data from the packet
        Packet& operator>>(bool& out_data);
        Packet& operator>>(s8& out_data);
        Packet& operator>>(u8& out_data);
        Packet& operator>>(s16& out_data);
        Packet& operator>>(u16& out_data);
        Packet& operator>>(s32& out_data);
        Packet& operator>>(u32& out_data);
        Packet& operator>>(s64& out_data);
        Packet& operator>>(u64& out_data);
        Packet& operator>>(float& out_data);
        Packet& operator>>(double& out_data);
        Packet& operator>>(char* out_data);
        Packet& operator>>(std::string& out_data);
        template <typename T>
        Packet& operator>>(std::vector<T>& out_data);
        template <typename T, std::size_t S>
        Packet& operator>>(std::array<T, S>& out_data);

        /// Overloads of operator << to write data into the packet
        Packet& operator<<(bool in_data);
        Packet& operator<<(s8 in_data);
        Packet& operator<<(u8 in_data);
        Packet& operator<<(s16 in_data);
        Packet& operator<<(u16 in_data);
        Packet& operator<<(s32 in_data);
        Packet& operator<<(u32 in_data);
        Packet& operator<<(s64 in_data);
        Packet& operator<<(u64 in_data);
        Packet& operator<<(float in_data);
        Packet& operator<<(double in_data);
        Packet& operator<<(const char* in_data);
        Packet& operator<<(const std::string& in_data);
        template <typename T>
        Packet& operator<<(const std::vector<T>& in_data);
        template <typename T, std::size_t S>
        Packet& operator<<(const std::array<T, S>& data);

    private:
        /**
         * Check if the packet can extract a given number of bytes
         * This function updates accordingly the state of the packet.
         * @param size Size to check
         * @return True if size bytes can be read from the packet
         */
        bool CheckSize(std::size_t size);

        // Member data
        std::vector<char> data;   ///< Data stored in the packet
        std::size_t read_pos = 0; ///< Current reading position in the packet
        bool is_valid = true;     ///< Reading state of the packet
    };

    template <typename T>
    Packet& Packet::operator>>(std::vector<T>& out_data) {
        // First extract the size
        u32 size = 0;
        *this >> size;
        out_data.resize(size);

        // Then extract the data
        for (std::size_t i = 0; i < out_data.size(); ++i) {
            T character;
            *this >> character;
            out_data[i] = character;
        }
        return *this;
    }

    template <typename T, std::size_t S>
    Packet& Packet::operator>>(std::array<T, S>& out_data) {
        for (std::size_t i = 0; i < out_data.size(); ++i) {
            T character;
            *this >> character;
            out_data[i] = character;
        }
        return *this;
    }

    template <typename T>
    Packet& Packet::operator<<(const std::vector<T>& in_data) {
        // First insert the size
        *this << static_cast<u32>(in_data.size());

        // Then insert the data
        for (std::size_t i = 0; i < in_data.size(); ++i) {
            *this << in_data[i];
        }
        return *this;
    }

    template <typename T, std::size_t S>
    Packet& Packet::operator<<(const std::array<T, S>& in_data) {
        for (std::size_t i = 0; i < in_data.size(); ++i) {
            *this << in_data[i];
        }
        return *this;
    }

} // namespace Network
```

`include/networking/enet.h`:

```h
/**
 * include/enet.h - a Single-Header auto-generated variant of enet.h library.
 *
 * Usage:
 * #define ENET_IMPLEMENTATION exactly in ONE source file right BEFORE including the library, like:
 *
 * #define ENET_IMPLEMENTATION
 * #include <enet.h>
 *
 * License:
 * The MIT License (MIT)
 *
 * Copyright (c) 2002-2016 Lee Salzman
 * Copyright (c) 2017-2021 Vladyslav Hrytsenko, Dominik Madarász
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */
#ifndef ENET_INCLUDE_H
#define ENET_INCLUDE_H

#define ENET_DEBUG

#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>
#include <time.h>

#define ENET_VERSION_MAJOR 2
#define ENET_VERSION_MINOR 3
#define ENET_VERSION_PATCH 0
#define ENET_VERSION_CREATE(major, minor, patch) (((major)<<16) | ((minor)<<8) | (patch))
#define ENET_VERSION_GET_MAJOR(version) (((version)>>16)&0xFF)
#define ENET_VERSION_GET_MINOR(version) (((version)>>8)&0xFF)
#define ENET_VERSION_GET_PATCH(version) ((version)&0xFF)
#define ENET_VERSION ENET_VERSION_CREATE(ENET_VERSION_MAJOR, ENET_VERSION_MINOR, ENET_VERSION_PATCH)

#define ENET_TIME_OVERFLOW 86400000
#define ENET_TIME_LESS(a, b) ((a) - (b) >= ENET_TIME_OVERFLOW)
#define ENET_TIME_GREATER(a, b) ((b) - (a) >= ENET_TIME_OVERFLOW)
#define ENET_TIME_LESS_EQUAL(a, b) (! ENET_TIME_GREATER (a, b))
#define ENET_TIME_GREATER_EQUAL(a, b) (! ENET_TIME_LESS (a, b))
#define ENET_TIME_DIFFERENCE(a, b) ((a) - (b) >= ENET_TIME_OVERFLOW ? (b) - (a) : (a) - (b))

// =======================================================================//
// !
// ! System differences
// !
// =======================================================================//

#if defined(_WIN32)
    #if defined(_MSC_VER) && defined(ENET_IMPLEMENTATION)
        #pragma warning (disable: 4267) // size_t to int conversion
        #pragma warning (disable: 4244) // 64bit to 32bit int
        #pragma warning (disable: 4018) // signed/unsigned mismatch
        #pragma warning (disable: 4146) // unary minus operator applied to unsigned type
    #endif

    #ifndef ENET_NO_PRAGMA_LINK
    #pragma comment(lib, "ws2_32.lib")
    #pragma comment(lib, "winmm.lib")
    #endif

    #if _MSC_VER >= 1910
    /* It looks like there were changes as of Visual Studio 2017 and there are no 32/64 bit
       versions of _InterlockedExchange[operation], only InterlockedExchange[operation]
       (without leading underscore), so we have to distinguish between compiler versions */
    #define NOT_UNDERSCORED_INTERLOCKED_EXCHANGE
    #endif

    #ifdef __GNUC__
    #if (_WIN32_WINNT < 0x0501)
    #undef _WIN32_WINNT
    #define _WIN32_WINNT 0x0501
    #endif
    #endif

    #include <winsock2.h>
    #include <ws2tcpip.h>
    #include <mmsystem.h>

    #include <intrin.h>

    #if defined(_WIN32) && defined(_MSC_VER)
    #if _MSC_VER < 1900
    typedef struct timespec {
        long tv_sec;
        long tv_nsec;
    };
    #endif
    #define CLOCK_MONOTONIC 0
    #endif

    typedef SOCKET ENetSocket;
    #define ENET_SOCKET_NULL INVALID_SOCKET

    #define ENET_HOST_TO_NET_16(value) (htons(value))
    #define ENET_HOST_TO_NET_32(value) (htonl(value))

    #define ENET_NET_TO_HOST_16(value) (ntohs(value))
    #define ENET_NET_TO_HOST_32(value) (ntohl(value))

    typedef struct {
        size_t dataLength;
        void * data;
    } ENetBuffer;

    #define ENET_CALLBACK __cdecl

    #ifdef ENET_DLL
    #ifdef ENET_IMPLEMENTATION
    #define ENET_API __declspec( dllexport )
    #else
    #define ENET_API __declspec( dllimport )
    #endif // ENET_IMPLEMENTATION
    #else
    #define ENET_API extern
    #endif // ENET_DLL

    typedef fd_set ENetSocketSet;

    #define ENET_SOCKETSET_EMPTY(sockset)          FD_ZERO(&(sockset))
    #define ENET_SOCKETSET_ADD(sockset, socket)    FD_SET(socket, &(sockset))
    #define ENET_SOCKETSET_REMOVE(sockset, socket) FD_CLR(socket, &(sockset))
    #define ENET_SOCKETSET_CHECK(sockset, socket)  FD_ISSET(socket, &(sockset))
#else
    #include <sys/types.h>
    #include <sys/ioctl.h>
    #include <sys/time.h>
    #include <sys/socket.h>
    #include <poll.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netinet/tcp.h>
    #include <netdb.h>
    #include <unistd.h>
    #include <string.h>
    #include <errno.h>
    #include <fcntl.h>

    #ifdef __APPLE__
    #include <mach/clock.h>
    #include <mach/mach.h>
    #include <Availability.h>
    #endif

    #ifndef MSG_NOSIGNAL
    #define MSG_NOSIGNAL 0
    #endif

    #ifdef MSG_MAXIOVLEN
    #define ENET_BUFFER_MAXIMUM MSG_MAXIOVLEN
    #endif

    typedef int ENetSocket;

    #define ENET_SOCKET_NULL -1

    #define ENET_HOST_TO_NET_16(value) (htons(value)) /**< macro that converts host to net byte-order of a 16-bit value */
    #define ENET_HOST_TO_NET_32(value) (htonl(value)) /**< macro that converts host to net byte-order of a 32-bit value */

    #define ENET_NET_TO_HOST_16(value) (ntohs(value)) /**< macro that converts net to host byte-order of a 16-bit value */
    #define ENET_NET_TO_HOST_32(value) (ntohl(value)) /**< macro that converts net to host byte-order of a 32-bit value */

    typedef struct {
        void * data;
        size_t dataLength;
    } ENetBuffer;

    #define ENET_CALLBACK
    #define ENET_API extern

    typedef fd_set ENetSocketSet;

    #define ENET_SOCKETSET_EMPTY(sockset)          FD_ZERO(&(sockset))
    #define ENET_SOCKETSET_ADD(sockset, socket)    FD_SET(socket, &(sockset))
    #define ENET_SOCKETSET_REMOVE(sockset, socket) FD_CLR(socket, &(sockset))
    #define ENET_SOCKETSET_CHECK(sockset, socket)  FD_ISSET(socket, &(sockset))
#endif

#ifdef __GNUC__
#define ENET_DEPRECATED(func) func __attribute__ ((deprecated))
#elif defined(_MSC_VER)
#define ENET_DEPRECATED(func) __declspec(deprecated) func
#else
#pragma message("WARNING: Please ENET_DEPRECATED for this compiler")
#define ENET_DEPRECATED(func) func
#endif

#ifndef ENET_BUFFER_MAXIMUM
#define ENET_BUFFER_MAXIMUM (1 + 2 * ENET_PROTOCOL_MAXIMUM_PACKET_COMMANDS)
#endif

#define ENET_UNUSED(x) (void)x;

#define ENET_MAX(x, y) ((x) > (y) ? (x) : (y))
#define ENET_MIN(x, y) ((x) < (y) ? (x) : (y))

#define ENET_IPV6           1
const struct in6_addr enet_v4_anyaddr   = {{{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00 }}};
const struct in6_addr enet_v4_noaddr    = {{{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }}};
const struct in6_addr enet_v4_localhost = {{{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x01 }}};
const struct in6_addr enet_v6_anyaddr   = {{{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }}};
const struct in6_addr enet_v6_noaddr    = {{{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }}};
const struct in6_addr enet_v6_localhost = {{{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }}};
#define ENET_HOST_ANY       in6addr_any
#define ENET_HOST_BROADCAST 0xFFFFFFFFU
#define ENET_PORT_ANY       0

#ifdef __cplusplus
extern "C" {
#endif

// =======================================================================//
// !
// ! Basic stuff
// !
// =======================================================================//

    typedef uint8_t   enet_uint8;   /**< unsigned 8-bit type  */
    typedef uint16_t enet_uint16;   /**< unsigned 16-bit type */
    typedef uint32_t enet_uint32;   /**< unsigned 32-bit type */
    typedef uint64_t enet_uint64;   /**< unsigned 64-bit type */

    typedef enet_uint32 ENetVersion;
    typedef struct _ENetPacket ENetPacket;

    typedef struct _ENetCallbacks {
        void *(ENET_CALLBACK *malloc) (size_t size);
        void (ENET_CALLBACK *free) (void *memory);
        void (ENET_CALLBACK *no_memory) (void);

        ENetPacket *(ENET_CALLBACK *packet_create)        (const void *data, size_t dataLength, enet_uint32 flags);
        void        (ENET_CALLBACK *packet_destroy)       (ENetPacket *packet);
    } ENetCallbacks;

    extern void *enet_malloc(size_t);
    extern void enet_free(void *);
    extern ENetPacket* enet_packet_create(const void*,size_t,enet_uint32);
    extern ENetPacket* enet_packet_copy(ENetPacket*);
    extern void enet_packet_destroy(ENetPacket*);

// =======================================================================//
// !
// ! List
// !
// =======================================================================//

    typedef struct _ENetListNode {
        struct _ENetListNode *next;
        struct _ENetListNode *previous;
    } ENetListNode;

    typedef ENetListNode *ENetListIterator;

    typedef struct _ENetList {
        ENetListNode sentinel;
    } ENetList;

    extern ENetListIterator enet_list_insert(ENetListIterator, void *);
    extern ENetListIterator enet_list_move(ENetListIterator, void *, void *);

    extern void *enet_list_remove(ENetListIterator);
    extern void enet_list_clear(ENetList *);
    extern size_t enet_list_size(ENetList *);

    #define enet_list_begin(list) ((list)->sentinel.next)
    #define enet_list_end(list) (&(list)->sentinel)
    #define enet_list_empty(list) (enet_list_begin(list) == enet_list_end(list))
    #define enet_list_next(iterator) ((iterator)->next)
    #define enet_list_previous(iterator) ((iterator)->previous)
    #define enet_list_front(list) ((void *)(list)->sentinel.next)
    #define enet_list_back(list) ((void *)(list)->sentinel.previous)


// =======================================================================//
// !
// ! Protocol
// !
// =======================================================================//

    enum {
        ENET_PROTOCOL_MINIMUM_MTU             = 576,
        ENET_PROTOCOL_MAXIMUM_MTU             = 4096,
        ENET_PROTOCOL_MAXIMUM_PACKET_COMMANDS = 32,
        ENET_PROTOCOL_MINIMUM_WINDOW_SIZE     = 4096,
        ENET_PROTOCOL_MAXIMUM_WINDOW_SIZE     = 65536,
        ENET_PROTOCOL_MINIMUM_CHANNEL_COUNT   = 1,
        ENET_PROTOCOL_MAXIMUM_CHANNEL_COUNT   = 255,
        ENET_PROTOCOL_MAXIMUM_PEER_ID         = 0xFFF,
        ENET_PROTOCOL_MAXIMUM_FRAGMENT_COUNT  = 1024 * 1024
    };

    typedef enum _ENetProtocolCommand {
        ENET_PROTOCOL_COMMAND_NONE                     = 0,
        ENET_PROTOCOL_COMMAND_ACKNOWLEDGE              = 1,
        ENET_PROTOCOL_COMMAND_CONNECT                  = 2,
        ENET_PROTOCOL_COMMAND_VERIFY_CONNECT           = 3,
        ENET_PROTOCOL_COMMAND_DISCONNECT               = 4,
        ENET_PROTOCOL_COMMAND_PING                     = 5,
        ENET_PROTOCOL_COMMAND_SEND_RELIABLE            = 6,
        ENET_PROTOCOL_COMMAND_SEND_UNRELIABLE          = 7,
        ENET_PROTOCOL_COMMAND_SEND_FRAGMENT            = 8,
        ENET_PROTOCOL_COMMAND_SEND_UNSEQUENCED         = 9,
        ENET_PROTOCOL_COMMAND_BANDWIDTH_LIMIT          = 10,
        ENET_PROTOCOL_COMMAND_THROTTLE_CONFIGURE       = 11,
        ENET_PROTOCOL_COMMAND_SEND_UNRELIABLE_FRAGMENT = 12,
        ENET_PROTOCOL_COMMAND_COUNT                    = 13,

        ENET_PROTOCOL_COMMAND_MASK                     = 0x0F
    } ENetProtocolCommand;

    typedef enum _ENetProtocolFlag {
        ENET_PROTOCOL_COMMAND_FLAG_ACKNOWLEDGE = (1 << 7),
        ENET_PROTOCOL_COMMAND_FLAG_UNSEQUENCED = (1 << 6),

        ENET_PROTOCOL_HEADER_FLAG_COMPRESSED   = (1 << 14),
        ENET_PROTOCOL_HEADER_FLAG_SENT_TIME    = (1 << 15),
        ENET_PROTOCOL_HEADER_FLAG_MASK         = ENET_PROTOCOL_HEADER_FLAG_COMPRESSED | ENET_PROTOCOL_HEADER_FLAG_SENT_TIME,

        ENET_PROTOCOL_HEADER_SESSION_MASK      = (3 << 12),
        ENET_PROTOCOL_HEADER_SESSION_SHIFT     = 12
    } ENetProtocolFlag;

    #ifdef _MSC_VER
    #pragma pack(push, 1)
    #define ENET_PACKED
    #elif defined(__GNUC__) || defined(__clang__)
    #define ENET_PACKED __attribute__ ((packed))
    #else
    #define ENET_PACKED
    #endif

    typedef struct _ENetProtocolHeader {
        enet_uint16 peerID;
        enet_uint16 sentTime;
    } ENET_PACKED ENetProtocolHeader;

    typedef struct _ENetProtocolCommandHeader {
        enet_uint8  command;
        enet_uint8  channelID;
        enet_uint16 reliableSequenceNumber;
    } ENET_PACKED ENetProtocolCommandHeader;

    typedef struct _ENetProtocolAcknowledge {
        ENetProtocolCommandHeader header;
        enet_uint16               receivedReliableSequenceNumber;
        enet_uint16               receivedSentTime;
    } ENET_PACKED ENetProtocolAcknowledge;

    typedef struct _ENetProtocolConnect {
        ENetProtocolCommandHeader header;
        enet_uint16               outgoingPeerID;
        enet_uint8                incomingSessionID;
        enet_uint8                outgoingSessionID;
        enet_uint32               mtu;
        enet_uint32               windowSize;
        enet_uint32               channelCount;
        enet_uint32               incomingBandwidth;
        enet_uint32               outgoingBandwidth;
        enet_uint32               packetThrottleInterval;
        enet_uint32               packetThrottleAcceleration;
        enet_uint32               packetThrottleDeceleration;
        enet_uint32               connectID;
        enet_uint32               data;
    } ENET_PACKED ENetProtocolConnect;

    typedef struct _ENetProtocolVerifyConnect {
        ENetProtocolCommandHeader header;
        enet_uint16               outgoingPeerID;
        enet_uint8                incomingSessionID;
        enet_uint8                outgoingSessionID;
        enet_uint32               mtu;
        enet_uint32               windowSize;
        enet_uint32               channelCount;
        enet_uint32               incomingBandwidth;
        enet_uint32               outgoingBandwidth;
        enet_uint32               packetThrottleInterval;
        enet_uint32               packetThrottleAcceleration;
        enet_uint32               packetThrottleDeceleration;
        enet_uint32               connectID;
    } ENET_PACKED ENetProtocolVerifyConnect;

    typedef struct _ENetProtocolBandwidthLimit {
        ENetProtocolCommandHeader header;
        enet_uint32               incomingBandwidth;
        enet_uint32               outgoingBandwidth;
    } ENET_PACKED ENetProtocolBandwidthLimit;

    typedef struct _ENetProtocolThrottleConfigure {
        ENetProtocolCommandHeader header;
        enet_uint32               packetThrottleInterval;
        enet_uint32               packetThrottleAcceleration;
        enet_uint32               packetThrottleDeceleration;
    } ENET_PACKED ENetProtocolThrottleConfigure;

    typedef struct _ENetProtocolDisconnect {
        ENetProtocolCommandHeader header;
        enet_uint32               data;
    } ENET_PACKED ENetProtocolDisconnect;

    typedef struct _ENetProtocolPing {
        ENetProtocolCommandHeader header;
    } ENET_PACKED ENetProtocolPing;

    typedef struct _ENetProtocolSendReliable {
        ENetProtocolCommandHeader header;
        enet_uint16               dataLength;
    } ENET_PACKED ENetProtocolSendReliable;

    typedef struct _ENetProtocolSendUnreliable {
        ENetProtocolCommandHeader header;
        enet_uint16               unreliableSequenceNumber;
        enet_uint16               dataLength;
    } ENET_PACKED ENetProtocolSendUnreliable;

    typedef struct _ENetProtocolSendUnsequenced {
        ENetProtocolCommandHeader header;
        enet_uint16               unsequencedGroup;
        enet_uint16               dataLength;
    } ENET_PACKED ENetProtocolSendUnsequenced;

    typedef struct _ENetProtocolSendFragment {
        ENetProtocolCommandHeader header;
        enet_uint16               startSequenceNumber;
        enet_uint16               dataLength;
        enet_uint32               fragmentCount;
        enet_uint32               fragmentNumber;
        enet_uint32               totalLength;
        enet_uint32               fragmentOffset;
    } ENET_PACKED ENetProtocolSendFragment;

    typedef union _ENetProtocol {
        ENetProtocolCommandHeader     header;
        ENetProtocolAcknowledge       acknowledge;
        ENetProtocolConnect           connect;
        ENetProtocolVerifyConnect     verifyConnect;
        ENetProtocolDisconnect        disconnect;
        ENetProtocolPing              ping;
        ENetProtocolSendReliable      sendReliable;
        ENetProtocolSendUnreliable    sendUnreliable;
        ENetProtocolSendUnsequenced   sendUnsequenced;
        ENetProtocolSendFragment      sendFragment;
        ENetProtocolBandwidthLimit    bandwidthLimit;
        ENetProtocolThrottleConfigure throttleConfigure;
    } ENET_PACKED ENetProtocol;

    #ifdef _MSC_VER
    #pragma pack(pop)
    #endif

// =======================================================================//
// !
// ! General ENet structs/enums
// !
// =======================================================================//

    typedef enum _ENetSocketType {
        ENET_SOCKET_TYPE_STREAM   = 1,
        ENET_SOCKET_TYPE_DATAGRAM = 2
    } ENetSocketType;

    typedef enum _ENetSocketWait {
        ENET_SOCKET_WAIT_NONE      = 0,
        ENET_SOCKET_WAIT_SEND      = (1 << 0),
        ENET_SOCKET_WAIT_RECEIVE   = (1 << 1),
        ENET_SOCKET_WAIT_INTERRUPT = (1 << 2)
    } ENetSocketWait;

    typedef enum _ENetSocketOption {
        ENET_SOCKOPT_NONBLOCK  = 1,
        ENET_SOCKOPT_BROADCAST = 2,
        ENET_SOCKOPT_RCVBUF    = 3,
        ENET_SOCKOPT_SNDBUF    = 4,
        ENET_SOCKOPT_REUSEADDR = 5,
        ENET_SOCKOPT_RCVTIMEO  = 6,
        ENET_SOCKOPT_SNDTIMEO  = 7,
        ENET_SOCKOPT_ERROR     = 8,
        ENET_SOCKOPT_NODELAY   = 9,
        ENET_SOCKOPT_IPV6_V6ONLY = 10,
    } ENetSocketOption;

    typedef enum _ENetSocketShutdown {
        ENET_SOCKET_SHUTDOWN_READ       = 0,
        ENET_SOCKET_SHUTDOWN_WRITE      = 1,
        ENET_SOCKET_SHUTDOWN_READ_WRITE = 2
    } ENetSocketShutdown;

    /**
     * Portable internet address structure.
     *
     * The host must be specified in network byte-order, and the port must be in host
     * byte-order. The constant ENET_HOST_ANY may be used to specify the default
     * server host. The constant ENET_HOST_BROADCAST may be used to specify the
     * broadcast address (255.255.255.255).  This makes sense for enet_host_connect,
     * but not for enet_host_create.  Once a server responds to a broadcast, the
     * address is updated from ENET_HOST_BROADCAST to the server's actual IP address.
     */
    typedef struct _ENetAddress {
        struct in6_addr host;
        enet_uint16 port;
        enet_uint16 sin6_scope_id;
    } ENetAddress;

    #define in6_equal(in6_addr_a, in6_addr_b) (memcmp(&in6_addr_a, &in6_addr_b, sizeof(struct in6_addr)) == 0)

    /**
     * Packet flag bit constants.
     *
     * The host must be specified in network byte-order, and the port must be in
     * host byte-order. The constant ENET_HOST_ANY may be used to specify the
     * default server host.
     *
     * @sa ENetPacket
     */
    typedef enum _ENetPacketFlag {
        ENET_PACKET_FLAG_RELIABLE            = (1 << 0), /** packet must be received by the target peer and resend attempts should be made until the packet is delivered */
        ENET_PACKET_FLAG_UNSEQUENCED         = (1 << 1), /** packet will not be sequenced with other packets not supported for reliable packets */
        ENET_PACKET_FLAG_NO_ALLOCATE         = (1 << 2), /** packet will not allocate data, and user must supply it instead */
        ENET_PACKET_FLAG_UNRELIABLE_FRAGMENT = (1 << 3), /** packet will be fragmented using unreliable (instead of reliable) sends if it exceeds the MTU */
        ENET_PACKET_FLAG_SENT                = (1 << 8), /** whether the packet has been sent from all queues it has been entered into */
    } ENetPacketFlag;

    typedef void (ENET_CALLBACK *ENetPacketFreeCallback)(void *);

    /**
     * ENet packet structure.
     *
     * An ENet data packet that may be sent to or received from a peer. The shown
     * fields should only be read and never modified. The data field contains the
     * allocated data for the packet. The dataLength fields specifies the length
     * of the allocated data.  The flags field is either 0 (specifying no flags),
     * or a bitwise-or of any combination of the following flags:
     *
     *    ENET_PACKET_FLAG_RELIABLE - packet must be received by the target peer and resend attempts should be made until the packet is delivered
     *    ENET_PACKET_FLAG_UNSEQUENCED - packet will not be sequenced with other packets (not supported for reliable packets)
     *    ENET_PACKET_FLAG_NO_ALLOCATE - packet will not allocate data, and user must supply it instead
     *    ENET_PACKET_FLAG_UNRELIABLE_FRAGMENT - packet will be fragmented using unreliable (instead of reliable) sends if it exceeds the MTU
     *    ENET_PACKET_FLAG_SENT - whether the packet has been sent from all queues it has been entered into
     * @sa ENetPacketFlag
     */
    typedef struct _ENetPacket {
        size_t                 referenceCount; /**< internal use only */
        enet_uint32            flags;          /**< bitwise-or of ENetPacketFlag constants */
        enet_uint8 *           data;           /**< allocated data for packet */
        size_t                 dataLength;     /**< length of data */
        ENetPacketFreeCallback freeCallback;   /**< function to be called when the packet is no longer in use */
        void *                 userData;       /**< application private data, may be freely modified */
    } ENetPacket;

    typedef struct _ENetAcknowledgement {
        ENetListNode acknowledgementList;
        enet_uint32  sentTime;
        ENetProtocol command;
    } ENetAcknowledgement;

    typedef struct _ENetOutgoingCommand {
        ENetListNode outgoingCommandList;
        enet_uint16  reliableSequenceNumber;
        enet_uint16  unreliableSequenceNumber;
        enet_uint32  sentTime;
        enet_uint32  roundTripTimeout;
        enet_uint32  roundTripTimeoutLimit;
        enet_uint32  fragmentOffset;
        enet_uint16  fragmentLength;
        enet_uint16  sendAttempts;
        ENetProtocol command;
        ENetPacket * packet;
    } ENetOutgoingCommand;

    typedef struct _ENetIncomingCommand {
        ENetListNode incomingCommandList;
        enet_uint16  reliableSequenceNumber;
        enet_uint16  unreliableSequenceNumber;
        ENetProtocol command;
        enet_uint32  fragmentCount;
        enet_uint32  fragmentsRemaining;
        enet_uint32 *fragments;
        ENetPacket * packet;
    } ENetIncomingCommand;

    typedef enum _ENetPeerState {
        ENET_PEER_STATE_DISCONNECTED             = 0,
        ENET_PEER_STATE_CONNECTING               = 1,
        ENET_PEER_STATE_ACKNOWLEDGING_CONNECT    = 2,
        ENET_PEER_STATE_CONNECTION_PENDING       = 3,
        ENET_PEER_STATE_CONNECTION_SUCCEEDED     = 4,
        ENET_PEER_STATE_CONNECTED                = 5,
        ENET_PEER_STATE_DISCONNECT_LATER         = 6,
        ENET_PEER_STATE_DISCONNECTING            = 7,
        ENET_PEER_STATE_ACKNOWLEDGING_DISCONNECT = 8,
        ENET_PEER_STATE_ZOMBIE                   = 9
    } ENetPeerState;

    enum {
        ENET_HOST_RECEIVE_BUFFER_SIZE          = 256 * 1024,
        ENET_HOST_SEND_BUFFER_SIZE             = 256 * 1024,
        ENET_HOST_BANDWIDTH_THROTTLE_INTERVAL  = 1000,
        ENET_HOST_DEFAULT_MTU                  = 1400,
        ENET_HOST_DEFAULT_MAXIMUM_PACKET_SIZE  = 32 * 1024 * 1024,
        ENET_HOST_DEFAULT_MAXIMUM_WAITING_DATA = 32 * 1024 * 1024,

        ENET_PEER_DEFAULT_ROUND_TRIP_TIME      = 500,
        ENET_PEER_DEFAULT_PACKET_THROTTLE      = 32,
        ENET_PEER_PACKET_THROTTLE_SCALE        = 32,
        ENET_PEER_PACKET_THROTTLE_COUNTER      = 7,
        ENET_PEER_PACKET_THROTTLE_ACCELERATION = 2,
        ENET_PEER_PACKET_THROTTLE_DECELERATION = 2,
        ENET_PEER_PACKET_THROTTLE_INTERVAL     = 5000,
        ENET_PEER_PACKET_LOSS_SCALE            = (1 << 16),
        ENET_PEER_PACKET_LOSS_INTERVAL         = 10000,
        ENET_PEER_WINDOW_SIZE_SCALE            = 64 * 1024,
        ENET_PEER_TIMEOUT_LIMIT                = 32,
        ENET_PEER_TIMEOUT_MINIMUM              = 5000,
        ENET_PEER_TIMEOUT_MAXIMUM              = 30000,
        ENET_PEER_PING_INTERVAL                = 500,
        ENET_PEER_UNSEQUENCED_WINDOWS          = 64,
        ENET_PEER_UNSEQUENCED_WINDOW_SIZE      = 1024,
        ENET_PEER_FREE_UNSEQUENCED_WINDOWS     = 32,
        ENET_PEER_RELIABLE_WINDOWS             = 16,
        ENET_PEER_RELIABLE_WINDOW_SIZE         = 0x1000,
        ENET_PEER_FREE_RELIABLE_WINDOWS        = 8
    };

    typedef struct _ENetChannel {
        enet_uint16 outgoingReliableSequenceNumber;
        enet_uint16 outgoingUnreliableSequenceNumber;
        enet_uint16 usedReliableWindows;
        enet_uint16 reliableWindows[ENET_PEER_RELIABLE_WINDOWS];
        enet_uint16 incomingReliableSequenceNumber;
        enet_uint16 incomingUnreliableSequenceNumber;
        ENetList    incomingReliableCommands;
        ENetList    incomingUnreliableCommands;
    } ENetChannel;

    /**
     * An ENet peer which data packets may be sent or received from.
     *
     * No fields should be modified unless otherwise specified.
     */
    typedef struct _ENetPeer {
        ENetListNode      dispatchList;
        struct _ENetHost *host;
        enet_uint16       outgoingPeerID;
        enet_uint16       incomingPeerID;
        enet_uint32       connectID;
        enet_uint8        outgoingSessionID;
        enet_uint8        incomingSessionID;
        ENetAddress       address; /**< Internet address of the peer */
        void *            data;    /**< Application private data, may be freely modified */
        ENetPeerState     state;
        ENetChannel *     channels;
        size_t            channelCount;      /**< Number of channels allocated for communication with peer */
        enet_uint32       incomingBandwidth; /**< Downstream bandwidth of the client in bytes/second */
        enet_uint32       outgoingBandwidth; /**< Upstream bandwidth of the client in bytes/second */
        enet_uint32       incomingBandwidthThrottleEpoch;
        enet_uint32       outgoingBandwidthThrottleEpoch;
        enet_uint32       incomingDataTotal;
        enet_uint64       totalDataReceived;
        enet_uint32       outgoingDataTotal;
        enet_uint64       totalDataSent;
        enet_uint32       lastSendTime;
        enet_uint32       lastReceiveTime;
        enet_uint32       nextTimeout;
        enet_uint32       earliestTimeout;
        enet_uint32       packetLossEpoch;
        enet_uint32       packetsSent;
        enet_uint64       totalPacketsSent; /**< total number of packets sent during a session */
        enet_uint32       packetsLost;
        enet_uint32       totalPacketsLost;     /**< total number of packets lost during a session */
        enet_uint32       packetLoss; /**< mean packet loss of reliable packets as a ratio with respect to the constant ENET_PEER_PACKET_LOSS_SCALE */
        enet_uint32       packetLossVariance;
        enet_uint32       packetThrottle;
        enet_uint32       packetThrottleLimit;
        enet_uint32       packetThrottleCounter;
        enet_uint32       packetThrottleEpoch;
        enet_uint32       packetThrottleAcceleration;
        enet_uint32       packetThrottleDeceleration;
        enet_uint32       packetThrottleInterval;
        enet_uint32       pingInterval;
        enet_uint32       timeoutLimit;
        enet_uint32       timeoutMinimum;
        enet_uint32       timeoutMaximum;
        enet_uint32       lastRoundTripTime;
        enet_uint32       lowestRoundTripTime;
        enet_uint32       lastRoundTripTimeVariance;
        enet_uint32       highestRoundTripTimeVariance;
        enet_uint32       roundTripTime; /**< mean round trip time (RTT), in milliseconds, between sending a reliable packet and receiving its acknowledgement */
        enet_uint32       roundTripTimeVariance;
        enet_uint32       mtu;
        enet_uint32       windowSize;
        enet_uint32       reliableDataInTransit;
        enet_uint16       outgoingReliableSequenceNumber;
        ENetList          acknowledgements;
        ENetList          sentReliableCommands;
        ENetList          sentUnreliableCommands;
        ENetList          outgoingReliableCommands;
        ENetList          outgoingUnreliableCommands;
        ENetList          dispatchedCommands;
        int               needsDispatch;
        enet_uint16       incomingUnsequencedGroup;
        enet_uint16       outgoingUnsequencedGroup;
        enet_uint32       unsequencedWindow[ENET_PEER_UNSEQUENCED_WINDOW_SIZE / 32];
        enet_uint32       eventData;
        size_t            totalWaitingData;
    } ENetPeer;

    /** An ENet packet compressor for compressing UDP packets before socket sends or receives. */
    typedef struct _ENetCompressor {
        /** Context data for the compressor. Must be non-NULL. */
        void *context;

        /** Compresses from inBuffers[0:inBufferCount-1], containing inLimit bytes, to outData, outputting at most outLimit bytes. Should return 0 on failure. */
        size_t(ENET_CALLBACK * compress) (void *context, const ENetBuffer * inBuffers, size_t inBufferCount, size_t inLimit, enet_uint8 * outData, size_t outLimit);

        /** Decompresses from inData, containing inLimit bytes, to outData, outputting at most outLimit bytes. Should return 0 on failure. */
        size_t(ENET_CALLBACK * decompress) (void *context, const enet_uint8 * inData, size_t inLimit, enet_uint8 * outData, size_t outLimit);

        /** Destroys the context when compression is disabled or the host is destroyed. May be NULL. */
        void (ENET_CALLBACK * destroy)(void *context);
    } ENetCompressor;

    /** Callback that computes the checksum of the data held in buffers[0:bufferCount-1] */
    typedef enet_uint32 (ENET_CALLBACK * ENetChecksumCallback)(const ENetBuffer *buffers, size_t bufferCount);

    /** Callback for intercepting received raw UDP packets. Should return 1 to intercept, 0 to ignore, or -1 to propagate an error. */
    typedef int (ENET_CALLBACK * ENetInterceptCallback)(struct _ENetHost *host, void *event);

    /** An ENet host for communicating with peers.
     *
     * No fields should be modified unless otherwise stated.
     *
     *  @sa enet_host_create()
     *  @sa enet_host_destroy()
     *  @sa enet_host_connect()
     *  @sa enet_host_service()
     *  @sa enet_host_flush()
     *  @sa enet_host_broadcast()
     *  @sa enet_host_compress()
     *  @sa enet_host_channel_limit()
     *  @sa enet_host_bandwidth_limit()
     *  @sa enet_host_bandwidth_throttle()
     */
    typedef struct _ENetHost {
        ENetSocket            socket;
        ENetAddress           address;           /**< Internet address of the host */
        enet_uint32           incomingBandwidth; /**< downstream bandwidth of the host */
        enet_uint32           outgoingBandwidth; /**< upstream bandwidth of the host */
        enet_uint32           bandwidthThrottleEpoch;
        enet_uint32           mtu;
        enet_uint32           randomSeed;
        int                   recalculateBandwidthLimits;
        ENetPeer *            peers;        /**< array of peers allocated for this host */
        size_t                peerCount;    /**< number of peers allocated for this host */
        size_t                channelLimit; /**< maximum number of channels allowed for connected peers */
        enet_uint32           serviceTime;
        ENetList              dispatchQueue;
        int                   continueSending;
        size_t                packetSize;
        enet_uint16           headerFlags;
        ENetProtocol          commands[ENET_PROTOCOL_MAXIMUM_PACKET_COMMANDS];
        size_t                commandCount;
        ENetBuffer            buffers[ENET_BUFFER_MAXIMUM];
        size_t                bufferCount;
        ENetChecksumCallback  checksum; /**< callback the user can set to enable packet checksums for this host */
        ENetCompressor        compressor;
        enet_uint8            packetData[2][ENET_PROTOCOL_MAXIMUM_MTU];
        ENetAddress           receivedAddress;
        enet_uint8 *          receivedData;
        size_t                receivedDataLength;
        enet_uint32           totalSentData;        /**< total data sent, user should reset to 0 as needed to prevent overflow */
        enet_uint32           totalSentPackets;     /**< total UDP packets sent, user should reset to 0 as needed to prevent overflow */
        enet_uint32           totalReceivedData;    /**< total data received, user should reset to 0 as needed to prevent overflow */
        enet_uint32           totalReceivedPackets; /**< total UDP packets received, user should reset to 0 as needed to prevent overflow */
        ENetInterceptCallback intercept;            /**< callback the user can set to intercept received raw UDP packets */
        size_t                connectedPeers;
        size_t                bandwidthLimitedPeers;
        size_t                duplicatePeers;     /**< optional number of allowed peers from duplicate IPs, defaults to ENET_PROTOCOL_MAXIMUM_PEER_ID */
        size_t                maximumPacketSize;  /**< the maximum allowable packet size that may be sent or received on a peer */
        size_t                maximumWaitingData; /**< the maximum aggregate amount of buffer space a peer may use waiting for packets to be delivered */
    } ENetHost;

    /**
     * An ENet event type, as specified in @ref ENetEvent.
     */
    typedef enum _ENetEventType {
        /** no event occurred within the specified time limit */
        ENET_EVENT_TYPE_NONE       = 0,

        /** a connection request initiated by enet_host_connect has completed.
         * The peer field contains the peer which successfully connected.
         */
        ENET_EVENT_TYPE_CONNECT    = 1,

        /** a peer has disconnected.  This event is generated on a successful
         * completion of a disconnect initiated by enet_peer_disconnect, if
         * a peer has timed out.  The peer field contains the peer
         * which disconnected. The data field contains user supplied data
         * describing the disconnection, or 0, if none is available.
         */
        ENET_EVENT_TYPE_DISCONNECT = 2,

        /** a packet has been received from a peer.  The peer field specifies the
         * peer which sent the packet.  The channelID field specifies the channel
         * number upon which the packet was received.  The packet field contains
         * the packet that was received; this packet must be destroyed with
         * enet_packet_destroy after use.
         */
        ENET_EVENT_TYPE_RECEIVE    = 3,

        /** a peer is disconnected because the host didn't receive the acknowledgment
         * packet within certain maximum time out. The reason could be because of bad
         * network connection or  host crashed.
         */
        ENET_EVENT_TYPE_DISCONNECT_TIMEOUT = 4,
    } ENetEventType;

    /**
     * An ENet event as returned by enet_host_service().
     *
     * @sa enet_host_service
     */
    typedef struct _ENetEvent {
        ENetEventType type;      /**< type of the event */
        ENetPeer *    peer;      /**< peer that generated a connect, disconnect or receive event */
        enet_uint8    channelID; /**< channel on the peer that generated the event, if appropriate */
        enet_uint32   data;      /**< data associated with the event, if appropriate */
        ENetPacket *  packet;    /**< packet associated with the event, if appropriate */
    } ENetEvent;

// =======================================================================//
// !
// ! Public API
// !
// =======================================================================//

    /**
     * Initializes ENet globally.  Must be called prior to using any functions in ENet.
     * @returns 0 on success, < 0 on failure
     */
    ENET_API int enet_initialize(void);

    /**
     * Initializes ENet globally and supplies user-overridden callbacks. Must be called prior to using any functions in ENet. Do not use enet_initialize() if you use this variant. Make sure the ENetCallbacks structure is zeroed out so that any additional callbacks added in future versions will be properly ignored.
     *
     * @param version the constant ENET_VERSION should be supplied so ENet knows which version of ENetCallbacks struct to use
     * @param inits user-overridden callbacks where any NULL callbacks will use ENet's defaults
     * @returns 0 on success, < 0 on failure
     */
    ENET_API int enet_initialize_with_callbacks(ENetVersion version, const ENetCallbacks * inits);

    /**
     * Shuts down ENet globally.  Should be called when a program that has initialized ENet exits.
     */
    ENET_API void enet_deinitialize(void);

    /**
     * Gives the linked version of the ENet library.
     * @returns the version number
     */
    ENET_API ENetVersion enet_linked_version(void);

    /** Returns the monotonic time in milliseconds. Its initial value is unspecified unless otherwise set. */
    ENET_API enet_uint32 enet_time_get(void);

    /** ENet socket functions */
    ENET_API ENetSocket enet_socket_create(ENetSocketType);
    ENET_API int        enet_socket_bind(ENetSocket, const ENetAddress *);
    ENET_API int        enet_socket_get_address(ENetSocket, ENetAddress *);
    ENET_API int        enet_socket_listen(ENetSocket, int);
    ENET_API ENetSocket enet_socket_accept(ENetSocket, ENetAddress *);
    ENET_API int        enet_socket_connect(ENetSocket, const ENetAddress *);
    ENET_API int        enet_socket_send(ENetSocket, const ENetAddress *, const ENetBuffer *, size_t);
    ENET_API int        enet_socket_receive(ENetSocket, ENetAddress *, ENetBuffer *, size_t);
    ENET_API int        enet_socket_wait(ENetSocket, enet_uint32 *, enet_uint64);
    ENET_API int        enet_socket_set_option(ENetSocket, ENetSocketOption, int);
    ENET_API int        enet_socket_get_option(ENetSocket, ENetSocketOption, int *);
    ENET_API int        enet_socket_shutdown(ENetSocket, ENetSocketShutdown);
    ENET_API void       enet_socket_destroy(ENetSocket);
    ENET_API int        enet_socketset_select(ENetSocket, ENetSocketSet *, ENetSocketSet *, enet_uint32);

    /** Attempts to parse the printable form of the IP address in the parameter hostName
        and sets the host field in the address parameter if successful.
        @param address destination to store the parsed IP address
        @param hostName IP address to parse
        @retval 0 on success
        @retval < 0 on failure
        @returns the address of the given hostName in address on success
    */
    ENET_API int enet_address_set_host_ip_old(ENetAddress * address, const char * hostName);

    /** Attempts to resolve the host named by the parameter hostName and sets
        the host field in the address parameter if successful.
        @param address destination to store resolved address
        @param hostName host name to lookup
        @retval 0 on success
        @retval < 0 on failure
        @returns the address of the given hostName in address on success
    */
    ENET_API int enet_address_set_host_old(ENetAddress * address, const char * hostName);

    /** Gives the printable form of the IP address specified in the address parameter.
        @param address    address printed
        @param hostName   destination for name, must not be NULL
        @param nameLength maximum length of hostName.
        @returns the null-terminated name of the host in hostName on success
        @retval 0 on success
        @retval < 0 on failure
    */
    ENET_API int enet_address_get_host_ip_old(const ENetAddress * address, char * hostName, size_t nameLength);

    /** Attempts to do a reverse lookup of the host field in the address parameter.
        @param address    address used for reverse lookup
        @param hostName   destination for name, must not be NULL
        @param nameLength maximum length of hostName.
        @returns the null-terminated name of the host in hostName on success
        @retval 0 on success
        @retval < 0 on failure
    */
    ENET_API int enet_address_get_host_old(const ENetAddress * address, char * hostName, size_t nameLength);

    ENET_API int enet_address_set_host_ip_new(ENetAddress * address, const char * hostName);
    ENET_API int enet_address_set_host_new(ENetAddress * address, const char * hostName);
    ENET_API int enet_address_get_host_ip_new(const ENetAddress * address, char * hostName, size_t nameLength);
    ENET_API int enet_address_get_host_new(const ENetAddress * address, char * hostName, size_t nameLength);

#ifdef ENET_FEATURE_ADDRESS_MAPPING
#define enet_address_set_host_ip enet_address_set_host_ip_new
#define enet_address_set_host    enet_address_set_host_new
#define enet_address_get_host_ip enet_address_get_host_ip_new
#define enet_address_get_host    enet_address_get_host_new
#else
#define enet_address_set_host_ip enet_address_set_host_ip_old
#define enet_address_set_host    enet_address_set_host_old
#define enet_address_get_host_ip enet_address_get_host_ip_old
#define enet_address_get_host    enet_address_get_host_old
#endif

    ENET_API enet_uint32 enet_host_get_peers_count(ENetHost *);
    ENET_API enet_uint32 enet_host_get_packets_sent(ENetHost *);
    ENET_API enet_uint32 enet_host_get_packets_received(ENetHost *);
    ENET_API enet_uint32 enet_host_get_bytes_sent(ENetHost *);
    ENET_API enet_uint32 enet_host_get_bytes_received(ENetHost *);
    ENET_API enet_uint32 enet_host_get_received_data(ENetHost *, enet_uint8** data);
    ENET_API enet_uint32 enet_host_get_mtu(ENetHost *);

    ENET_API enet_uint32 enet_peer_get_id(ENetPeer *);
    ENET_API enet_uint32 enet_peer_get_ip(ENetPeer *, char * ip, size_t ipLength);
    ENET_API enet_uint16 enet_peer_get_port(ENetPeer *);
    ENET_API enet_uint32 enet_peer_get_rtt(ENetPeer *);
    ENET_API enet_uint64 enet_peer_get_packets_sent(ENetPeer *);
    ENET_API enet_uint32 enet_peer_get_packets_lost(ENetPeer *);
    ENET_API enet_uint64 enet_peer_get_bytes_sent(ENetPeer *);
    ENET_API enet_uint64 enet_peer_get_bytes_received(ENetPeer *);

    ENET_API ENetPeerState enet_peer_get_state(ENetPeer *);

    ENET_API void * enet_peer_get_data(ENetPeer *);
    ENET_API void   enet_peer_set_data(ENetPeer *, const void *);

    ENET_API void *      enet_packet_get_data(ENetPacket *);
    ENET_API enet_uint32 enet_packet_get_length(ENetPacket *);
    ENET_API void        enet_packet_set_free_callback(ENetPacket *, void *);

    ENET_API ENetPacket * enet_packet_create_offset(const void *, size_t, size_t, enet_uint32);
    ENET_API enet_uint32  enet_crc32(const ENetBuffer *, size_t);

    ENET_API ENetHost * enet_host_create(const ENetAddress *, size_t, size_t, enet_uint32, enet_uint32);
    ENET_API void       enet_host_destroy(ENetHost *);
    ENET_API ENetPeer * enet_host_connect(ENetHost *, const ENetAddress *, size_t, enet_uint32);
    ENET_API int        enet_host_check_events(ENetHost *, ENetEvent *);
    ENET_API int        enet_host_service(ENetHost *, ENetEvent *, enet_uint32);    
    ENET_API int        enet_host_send_raw(ENetHost *, const ENetAddress *, enet_uint8 *, size_t);
    ENET_API int        enet_host_send_raw_ex(ENetHost *host, const ENetAddress* address, enet_uint8* data, size_t skipBytes, size_t bytesToSend);
    ENET_API void       enet_host_set_intercept(ENetHost *, const ENetInterceptCallback);
    ENET_API void       enet_host_flush(ENetHost *);
    ENET_API void       enet_host_broadcast(ENetHost *, enet_uint8, ENetPacket *);    
    ENET_API void       enet_host_compress(ENetHost *, const ENetCompressor *);
    ENET_API void       enet_host_channel_limit(ENetHost *, size_t);
    ENET_API void       enet_host_bandwidth_limit(ENetHost *, enet_uint32, enet_uint32);
    extern   void       enet_host_bandwidth_throttle(ENetHost *);
    extern  enet_uint64 enet_host_random_seed(void);

    ENET_API int                 enet_peer_send(ENetPeer *, enet_uint8, ENetPacket *);
    ENET_API ENetPacket *        enet_peer_receive(ENetPeer *, enet_uint8 * channelID);
    ENET_API void                enet_peer_ping(ENetPeer *);
    ENET_API void                enet_peer_ping_interval(ENetPeer *, enet_uint32);
    ENET_API void                enet_peer_timeout(ENetPeer *, enet_uint32, enet_uint32, enet_uint32);
    ENET_API void                enet_peer_reset(ENetPeer *);
    ENET_API void                enet_peer_disconnect(ENetPeer *, enet_uint32);
    ENET_API void                enet_peer_disconnect_now(ENetPeer *, enet_uint32);
    ENET_API void                enet_peer_disconnect_later(ENetPeer *, enet_uint32);
    ENET_API void                enet_peer_throttle_configure(ENetPeer *, enet_uint32, enet_uint32, enet_uint32);
    extern int                   enet_peer_throttle(ENetPeer *, enet_uint32);
    extern void                  enet_peer_reset_queues(ENetPeer *);
    extern void                  enet_peer_setup_outgoing_command(ENetPeer *, ENetOutgoingCommand *);
    extern ENetOutgoingCommand * enet_peer_queue_outgoing_command(ENetPeer *, const ENetProtocol *, ENetPacket *, enet_uint32, enet_uint16);
    extern ENetIncomingCommand * enet_peer_queue_incoming_command(ENetPeer *, const ENetProtocol *, const void *, size_t, enet_uint32, enet_uint32);
    extern ENetAcknowledgement * enet_peer_queue_acknowledgement(ENetPeer *, const ENetProtocol *, enet_uint16);
    extern void                  enet_peer_dispatch_incoming_unreliable_commands(ENetPeer *, ENetChannel *);
    extern void                  enet_peer_dispatch_incoming_reliable_commands(ENetPeer *, ENetChannel *);
    extern void                  enet_peer_on_connect(ENetPeer *);
    extern void                  enet_peer_on_disconnect(ENetPeer *);

    extern size_t enet_protocol_command_size (enet_uint8);

#ifdef __cplusplus
}
#endif

#if defined(ENET_IMPLEMENTATION) && !defined(ENET_IMPLEMENTATION_DONE)
#define ENET_IMPLEMENTATION_DONE 1

#ifdef __cplusplus
extern "C" {
#endif

// =======================================================================//
// !
// ! Atomics
// !
// =======================================================================//

#if defined(_MSC_VER)

    #define ENET_AT_CASSERT_PRED(predicate) sizeof(char[2 * !!(predicate)-1])
    #define ENET_IS_SUPPORTED_ATOMIC(size) ENET_AT_CASSERT_PRED(size == 1 || size == 2 || size == 4 || size == 8)
    #define ENET_ATOMIC_SIZEOF(variable) (ENET_IS_SUPPORTED_ATOMIC(sizeof(*(variable))), sizeof(*(variable)))

    __inline int64_t enet_at_atomic_read(char *ptr, size_t size)
    {
        switch (size) {
            case 1:
                return _InterlockedExchangeAdd8((volatile char *)ptr, 0);
            case 2:
                return _InterlockedExchangeAdd16((volatile SHORT *)ptr, 0);
            case 4:
    #ifdef NOT_UNDERSCORED_INTERLOCKED_EXCHANGE
                return InterlockedExchangeAdd((volatile LONG *)ptr, 0);
    #else
                return _InterlockedExchangeAdd((volatile LONG *)ptr, 0);
    #endif
            case 8:
    #ifdef NOT_UNDERSCORED_INTERLOCKED_EXCHANGE
                return InterlockedExchangeAdd64((volatile LONGLONG *)ptr, 0);
    #else
                return _InterlockedExchangeAdd64((volatile LONGLONG *)ptr, 0);
    #endif
            default:
                return 0xbad13bad; /* never reached */
        }
    }

    __inline int64_t enet_at_atomic_write(char *ptr, int64_t value, size_t size)
    {
        switch (size) {
            case 1:
                return _InterlockedExchange8((volatile char *)ptr, (char)value);
            case 2:
                return _InterlockedExchange16((volatile SHORT *)ptr, (SHORT)value);
            case 4:
    #ifdef NOT_UNDERSCORED_INTERLOCKED_EXCHANGE
                return InterlockedExchange((volatile LONG *)ptr, (LONG)value);
    #else
                return _InterlockedExchange((volatile LONG *)ptr, (LONG)value);
    #endif
            case 8:
    #ifdef NOT_UNDERSCORED_INTERLOCKED_EXCHANGE
                return InterlockedExchange64((volatile LONGLONG *)ptr, (LONGLONG)value);
    #else
                return _InterlockedExchange64((volatile LONGLONG *)ptr, (LONGLONG)value);
    #endif
            default:
                return 0xbad13bad; /* never reached */
        }
    }

    __inline int64_t enet_at_atomic_cas(char *ptr, int64_t new_val, int64_t old_val, size_t size)
    {
        switch (size) {
            case 1:
                return _InterlockedCompareExchange8((volatile char *)ptr, (char)new_val, (char)old_val);
            case 2:
                return _InterlockedCompareExchange16((volatile SHORT *)ptr, (SHORT)new_val,
                                                     (SHORT)old_val);
            case 4:
    #ifdef NOT_UNDERSCORED_INTERLOCKED_EXCHANGE
                return InterlockedCompareExchange((volatile LONG *)ptr, (LONG)new_val, (LONG)old_val);
    #else
                return _InterlockedCompareExchange((volatile LONG *)ptr, (LONG)new_val, (LONG)old_val);
    #endif
            case 8:
    #ifdef NOT_UNDERSCORED_INTERLOCKED_EXCHANGE
                return InterlockedCompareExchange64((volatile LONGLONG *)ptr, (LONGLONG)new_val,
                                                    (LONGLONG)old_val);
    #else
                return _InterlockedCompareExchange64((volatile LONGLONG *)ptr, (LONGLONG)new_val,
                                                     (LONGLONG)old_val);
    #endif
            default:
                return 0xbad13bad; /* never reached */
        }
    }

    __inline int64_t enet_at_atomic_inc(char *ptr, int64_t delta, size_t data_size)
    {
        switch (data_size) {
            case 1:
                return _InterlockedExchangeAdd8((volatile char *)ptr, (char)delta);
            case 2:
                return _InterlockedExchangeAdd16((volatile SHORT *)ptr, (SHORT)delta);
            case 4:
    #ifdef NOT_UNDERSCORED_INTERLOCKED_EXCHANGE
                return InterlockedExchangeAdd((volatile LONG *)ptr, (LONG)delta);
    #else
                return _InterlockedExchangeAdd((volatile LONG *)ptr, (LONG)delta);
    #endif
            case 8:
    #ifdef NOT_UNDERSCORED_INTERLOCKED_EXCHANGE
                return InterlockedExchangeAdd64((volatile LONGLONG *)ptr, (LONGLONG)delta);
    #else
                return _InterlockedExchangeAdd64((volatile LONGLONG *)ptr, (LONGLONG)delta);
    #endif
            default:
                return 0xbad13bad; /* never reached */
        }
    }

    #define ENET_ATOMIC_READ(variable) enet_at_atomic_read((char *)(variable), ENET_ATOMIC_SIZEOF(variable))
    #define ENET_ATOMIC_WRITE(variable, new_val)                                                            \
        enet_at_atomic_write((char *)(variable), (int64_t)(new_val), ENET_ATOMIC_SIZEOF(variable))
    #define ENET_ATOMIC_CAS(variable, old_value, new_val)                                                   \
        enet_at_atomic_cas((char *)(variable), (int64_t)(new_val), (int64_t)(old_value),                    \
                      ENET_ATOMIC_SIZEOF(variable))
    #define ENET_ATOMIC_INC(variable) enet_at_atomic_inc((char *)(variable), 1, ENET_ATOMIC_SIZEOF(variable))
    #define ENET_ATOMIC_DEC(variable) enet_at_atomic_inc((char *)(variable), -1, ENET_ATOMIC_SIZEOF(variable))
    #define ENET_ATOMIC_INC_BY(variable, delta)                                                             \
        enet_at_atomic_inc((char *)(variable), (delta), ENET_ATOMIC_SIZEOF(variable))
    #define ENET_ATOMIC_DEC_BY(variable, delta)                                                             \
        enet_at_atomic_inc((char *)(variable), -(delta), ENET_ATOMIC_SIZEOF(variable))

#elif defined(__GNUC__) || defined(__clang__)

    #if defined(__clang__) || (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 7))
    #define AT_HAVE_ATOMICS
    #endif

    /* We want to use __atomic built-ins if possible because the __sync primitives are
       deprecated, because the __atomic build-ins allow us to use ENET_ATOMIC_WRITE on
       uninitialized memory without running into undefined behavior, and because the
       __atomic versions generate more efficient code since we don't need to rely on
       CAS when we don't actually want it.

       Note that we use acquire-release memory order (like mutexes do). We could use
       sequentially consistent memory order but that has lower performance and is
       almost always unneeded. */
    #ifdef AT_HAVE_ATOMICS
        #define ENET_ATOMIC_READ(ptr) __atomic_load_n((ptr), __ATOMIC_ACQUIRE)
        #define ENET_ATOMIC_WRITE(ptr, value) __atomic_store_n((ptr), (value), __ATOMIC_RELEASE)

        #ifndef typeof
        #define typeof __typeof__
        #endif

        /* clang_analyzer doesn't know that CAS writes to memory so it complains about
           potentially lost data. Replace the code with the equivalent non-sync code. */
        #ifdef __clang_analyzer__

        #define ENET_ATOMIC_CAS(ptr, old_value, new_value)                                                      \
            ({                                                                                             \
                typeof(*(ptr)) ENET_ATOMIC_CAS_old_actual_ = (*(ptr));                                          \
                if (ATOMIC_CAS_old_actual_ == (old_value)) {                                               \
                    *(ptr) = new_value;                                                                    \
                }                                                                                          \
                ENET_ATOMIC_CAS_old_actual_;                                                                    \
            })

        #else

        /* Could use __auto_type instead of typeof but that shouldn't work in C++.
           The ({ }) syntax is a GCC extension called statement expression. It lets
           us return a value out of the macro.

           TODO We should return bool here instead of the old value to avoid the ABA
           problem. */
        #define ENET_ATOMIC_CAS(ptr, old_value, new_value)                                                      \
            ({                                                                                             \
                typeof(*(ptr)) ENET_ATOMIC_CAS_expected_ = (old_value);                                         \
                __atomic_compare_exchange_n((ptr), &ENET_ATOMIC_CAS_expected_, (new_value), false,              \
                                            __ATOMIC_ACQ_REL, __ATOMIC_ACQUIRE);                           \
                ENET_ATOMIC_CAS_expected_;                                                                      \
            })

        #endif /* __clang_analyzer__ */

        #define ENET_ATOMIC_INC(ptr) __atomic_fetch_add((ptr), 1, __ATOMIC_ACQ_REL)
        #define ENET_ATOMIC_DEC(ptr) __atomic_fetch_sub((ptr), 1, __ATOMIC_ACQ_REL)
        #define ENET_ATOMIC_INC_BY(ptr, delta) __atomic_fetch_add((ptr), (delta), __ATOMIC_ACQ_REL)
        #define ENET_ATOMIC_DEC_BY(ptr, delta) __atomic_fetch_sub((ptr), (delta), __ATOMIC_ACQ_REL)

        #else

        #define ENET_ATOMIC_READ(variable) __sync_fetch_and_add(variable, 0)
        #define ENET_ATOMIC_WRITE(variable, new_val)                                                            \
            (void) __sync_val_compare_and_swap((variable), *(variable), (new_val))
        #define ENET_ATOMIC_CAS(variable, old_value, new_val)                                                   \
            __sync_val_compare_and_swap((variable), (old_value), (new_val))
        #define ENET_ATOMIC_INC(variable) __sync_fetch_and_add((variable), 1)
        #define ENET_ATOMIC_DEC(variable) __sync_fetch_and_sub((variable), 1)
        #define ENET_ATOMIC_INC_BY(variable, delta) __sync_fetch_and_add((variable), (delta), 1)
        #define ENET_ATOMIC_DEC_BY(variable, delta) __sync_fetch_and_sub((variable), (delta), 1)

    #endif /* AT_HAVE_ATOMICS */

    #undef AT_HAVE_ATOMICS

#endif /* defined(_MSC_VER) */

// =======================================================================//
// !
// ! Callbacks
// !
// =======================================================================//

    ENetCallbacks callbacks = { malloc, free, abort, enet_packet_create, enet_packet_destroy };

    int enet_initialize_with_callbacks(ENetVersion version, const ENetCallbacks *inits) {
        if (version < ENET_VERSION_CREATE(1, 3, 0)) {
            return -1;
        }

        if (inits->malloc != NULL || inits->free != NULL) {
            if (inits->malloc == NULL || inits->free == NULL) {
                return -1;
            }

            callbacks.malloc = inits->malloc;
            callbacks.free   = inits->free;
        }

        if (inits->no_memory != NULL) {
            callbacks.no_memory = inits->no_memory;
        }

        if (inits->packet_create != NULL || inits->packet_destroy != NULL) {
            if (inits->packet_create == NULL || inits->packet_destroy == NULL) {
                return -1;
            }

            callbacks.packet_create = inits->packet_create;
            callbacks.packet_destroy = inits->packet_destroy;
        }

        return enet_initialize();
    }

    ENetVersion enet_linked_version(void) {
        return ENET_VERSION;
    }

    void * enet_malloc(size_t size) {
        void *memory = callbacks.malloc(size);

        if (memory == NULL) {
            callbacks.no_memory();
        }

        return memory;
    }

    void enet_free(void *memory) {
        callbacks.free(memory);
    }

// =======================================================================//
// !
// ! List
// !
// =======================================================================//

    void enet_list_clear(ENetList *list) {
        list->sentinel.next     = &list->sentinel;
        list->sentinel.previous = &list->sentinel;
    }

    ENetListIterator enet_list_insert(ENetListIterator position, void *data) {
        ENetListIterator result = (ENetListIterator)data;

        result->previous = position->previous;
        result->next     = position;

        result->previous->next = result;
        position->previous     = result;

        return result;
    }

    void *enet_list_remove(ENetListIterator position) {
        position->previous->next = position->next;
        position->next->previous = position->previous;

        return position;
    }

    ENetListIterator enet_list_move(ENetListIterator position, void *dataFirst, void *dataLast) {
        ENetListIterator first = (ENetListIterator)dataFirst;
        ENetListIterator last  = (ENetListIterator)dataLast;

        first->previous->next = last->next;
        last->next->previous  = first->previous;

        first->previous = position->previous;
        last->next      = position;

        first->previous->next = first;
        position->previous    = last;

        return first;
    }

    size_t enet_list_size(ENetList *list) {
        size_t size = 0;
        ENetListIterator position;

        for (position = enet_list_begin(list); position != enet_list_end(list); position = enet_list_next(position)) {
            ++size;
        }

        return size;
    }

// =======================================================================//
// !
// ! Packet
// !
// =======================================================================//

    /**
     * Creates a packet that may be sent to a peer.
     * @param data         initial contents of the packet's data; the packet's data will remain uninitialized if data is NULL.
     * @param dataLength   size of the data allocated for this packet
     * @param flags        flags for this packet as described for the ENetPacket structure.
     * @returns the packet on success, NULL on failure
     */
    ENetPacket *enet_packet_create(const void *data, size_t dataLength, enet_uint32 flags) {
        ENetPacket *packet;
        if (flags & ENET_PACKET_FLAG_NO_ALLOCATE) {
            packet = (ENetPacket *)enet_malloc(sizeof (ENetPacket));
            if (packet == NULL) {
                return NULL;
            }

            packet->data = (enet_uint8 *)data;
        }
        else {
            packet = (ENetPacket *)enet_malloc(sizeof (ENetPacket) + dataLength);
            if (packet == NULL) {
                return NULL;
            }

            packet->data = (enet_uint8 *)packet + sizeof(ENetPacket);

            if (data != NULL) {
                memcpy(packet->data, data, dataLength);
            }
        }

        packet->referenceCount = 0;
        packet->flags        = flags;
        packet->dataLength   = dataLength;
        packet->freeCallback = NULL;
        packet->userData     = NULL;

        return packet;
    }

    ENetPacket *enet_packet_create_offset(const void *data, size_t dataLength, size_t dataOffset, enet_uint32 flags) {
        ENetPacket *packet;
        if (flags & ENET_PACKET_FLAG_NO_ALLOCATE) {
            packet = (ENetPacket *)enet_malloc(sizeof (ENetPacket));
            if (packet == NULL) {
                return NULL;
            }

            packet->data = (enet_uint8 *)data;
        }
        else {
            packet = (ENetPacket *)enet_malloc(sizeof (ENetPacket) + dataLength + dataOffset);
            if (packet == NULL) {
                return NULL;
            }

            packet->data = (enet_uint8 *)packet + sizeof(ENetPacket);

            if (data != NULL) {
                memcpy(packet->data + dataOffset, data, dataLength);
            }
        }

        packet->referenceCount = 0;
        packet->flags        = flags;
        packet->dataLength   = dataLength + dataOffset;
        packet->freeCallback = NULL;
        packet->userData     = NULL;

        return packet;
    }

    ENetPacket *enet_packet_copy(ENetPacket *packet) {
        return enet_packet_create(packet->data, packet->dataLength, packet->flags);
    }

    /**
     * Destroys the packet and deallocates its data.
     * @param packet packet to be destroyed
     */
    void enet_packet_destroy(ENetPacket *packet) {
        if (packet == NULL) {
            return;
        }

        if (packet->freeCallback != NULL) {
            (*packet->freeCallback)((void *)packet);
        }

        enet_free(packet);
    }

    static int initializedCRC32 = 0;
    static enet_uint32 crcTable[256];

    static enet_uint32 reflect_crc(int val, int bits) {
        int result = 0, bit;

        for (bit = 0; bit < bits; bit++) {
            if (val & 1) { result |= 1 << (bits - 1 - bit); }
            val >>= 1;
        }

        return result;
    }

    static void initialize_crc32(void) {
        int byte;

        for (byte = 0; byte < 256; ++byte) {
            enet_uint32 crc = reflect_crc(byte, 8) << 24;
            int offset;

            for (offset = 0; offset < 8; ++offset) {
                if (crc & 0x80000000) {
                    crc = (crc << 1) ^ 0x04c11db7;
                } else {
                    crc <<= 1;
                }
            }

            crcTable[byte] = reflect_crc(crc, 32);
        }

        initializedCRC32 = 1;
    }

    enet_uint32 enet_crc32(const ENetBuffer *buffers, size_t bufferCount) {
        enet_uint32 crc = 0xFFFFFFFF;

        if (!initializedCRC32) { initialize_crc32(); }

        while (bufferCount-- > 0) {
            const enet_uint8 *data = (const enet_uint8 *)buffers->data;
            const enet_uint8 *dataEnd = &data[buffers->dataLength];

            while (data < dataEnd) {
                crc = (crc >> 8) ^ crcTable[(crc & 0xFF) ^ *data++];
            }

            ++buffers;
        }

        return ENET_HOST_TO_NET_32(~crc);
    }

// =======================================================================//
// !
// ! Protocol
// !
// =======================================================================//

    static size_t commandSizes[ENET_PROTOCOL_COMMAND_COUNT] = {
        0,
        sizeof(ENetProtocolAcknowledge),
        sizeof(ENetProtocolConnect),
        sizeof(ENetProtocolVerifyConnect),
        sizeof(ENetProtocolDisconnect),
        sizeof(ENetProtocolPing),
        sizeof(ENetProtocolSendReliable),
        sizeof(ENetProtocolSendUnreliable),
        sizeof(ENetProtocolSendFragment),
        sizeof(ENetProtocolSendUnsequenced),
        sizeof(ENetProtocolBandwidthLimit),
        sizeof(ENetProtocolThrottleConfigure),
        sizeof(ENetProtocolSendFragment)
    };

    size_t enet_protocol_command_size(enet_uint8 commandNumber) {
        return commandSizes[commandNumber & ENET_PROTOCOL_COMMAND_MASK];
    }

    static void enet_protocol_change_state(ENetHost *host, ENetPeer *peer, ENetPeerState state) {
        ENET_UNUSED(host)

        if (state == ENET_PEER_STATE_CONNECTED || state == ENET_PEER_STATE_DISCONNECT_LATER) {
            enet_peer_on_connect(peer);
        } else {
            enet_peer_on_disconnect(peer);
        }

        peer->state = state;
    }

    static void enet_protocol_dispatch_state(ENetHost *host, ENetPeer *peer, ENetPeerState state) {
        enet_protocol_change_state(host, peer, state);

        if (!peer->needsDispatch) {
            enet_list_insert(enet_list_end(&host->dispatchQueue), &peer->dispatchList);
            peer->needsDispatch = 1;
        }
    }

    static int enet_protocol_dispatch_incoming_commands(ENetHost *host, ENetEvent *event) {
        while (!enet_list_empty(&host->dispatchQueue)) {
            ENetPeer *peer = (ENetPeer *) enet_list_remove(enet_list_begin(&host->dispatchQueue));
            peer->needsDispatch = 0;

            switch (peer->state) {
                case ENET_PEER_STATE_CONNECTION_PENDING:
                case ENET_PEER_STATE_CONNECTION_SUCCEEDED:
                    enet_protocol_change_state(host, peer, ENET_PEER_STATE_CONNECTED);

                    event->type = ENET_EVENT_TYPE_CONNECT;
                    event->peer = peer;
                    event->data = peer->eventData;

                    return 1;

                case ENET_PEER_STATE_ZOMBIE:
                    host->recalculateBandwidthLimits = 1;

                    event->type = ENET_EVENT_TYPE_DISCONNECT;
                    event->peer = peer;
                    event->data = peer->eventData;

                    enet_peer_reset(peer);

                    return 1;

                case ENET_PEER_STATE_CONNECTED:
                    if (enet_list_empty(&peer->dispatchedCommands)) {
                        continue;
                    }

                    event->packet = enet_peer_receive(peer, &event->channelID);
                    if (event->packet == NULL) {
                        continue;
                    }

                    event->type = ENET_EVENT_TYPE_RECEIVE;
                    event->peer = peer;

                    if (!enet_list_empty(&peer->dispatchedCommands)) {
                        peer->needsDispatch = 1;
                        enet_list_insert(enet_list_end(&host->dispatchQueue), &peer->dispatchList);
                    }

                    return 1;

                default:
                    break;
            }
        }

        return 0;
    } /* enet_protocol_dispatch_incoming_commands */

    static void enet_protocol_notify_connect(ENetHost *host, ENetPeer *peer, ENetEvent *event) {
        host->recalculateBandwidthLimits = 1;

        if (event != NULL) {
            enet_protocol_change_state(host, peer, ENET_PEER_STATE_CONNECTED);

            peer->totalDataSent     = 0;
            peer->totalDataReceived = 0;
            peer->totalPacketsSent  = 0;
            peer->totalPacketsLost  = 0;

            event->type = ENET_EVENT_TYPE_CONNECT;
            event->peer = peer;
            event->data = peer->eventData;
        } else {
            enet_protocol_dispatch_state(host, peer, peer->state == ENET_PEER_STATE_CONNECTING ? ENET_PEER_STATE_CONNECTION_SUCCEEDED : ENET_PEER_STATE_CONNECTION_PENDING);
        }
    }

    static void enet_protocol_notify_disconnect(ENetHost *host, ENetPeer *peer, ENetEvent *event) {
        if (peer->state >= ENET_PEER_STATE_CONNECTION_PENDING) {
            host->recalculateBandwidthLimits = 1;
        }

        if (peer->state != ENET_PEER_STATE_CONNECTING && peer->state < ENET_PEER_STATE_CONNECTION_SUCCEEDED) {
            enet_peer_reset(peer);
        } else if (event != NULL) {
            event->type = ENET_EVENT_TYPE_DISCONNECT;
            event->peer = peer;
            event->data = 0;

            enet_peer_reset(peer);
        } else {
            peer->eventData = 0;
            enet_protocol_dispatch_state(host, peer, ENET_PEER_STATE_ZOMBIE);
        }
    }

    static void enet_protocol_notify_disconnect_timeout (ENetHost * host, ENetPeer * peer, ENetEvent * event) {
        if (peer->state >= ENET_PEER_STATE_CONNECTION_PENDING) {
           host->recalculateBandwidthLimits = 1;
        }

        if (peer->state != ENET_PEER_STATE_CONNECTING && peer->state < ENET_PEER_STATE_CONNECTION_SUCCEEDED) {
            enet_peer_reset (peer);
        }
        else if (event != NULL) {
            event->type = ENET_EVENT_TYPE_DISCONNECT_TIMEOUT;
            event->peer = peer;
            event->data = 0;

            enet_peer_reset(peer);
        }
        else {
            peer->eventData = 0;
            enet_protocol_dispatch_state(host, peer, ENET_PEER_STATE_ZOMBIE);
        }
    }

    static void enet_protocol_remove_sent_unreliable_commands(ENetPeer *peer) {
        ENetOutgoingCommand *outgoingCommand;

        while (!enet_list_empty(&peer->sentUnreliableCommands)) {
            outgoingCommand = (ENetOutgoingCommand *) enet_list_front(&peer->sentUnreliableCommands);
            enet_list_remove(&outgoingCommand->outgoingCommandList);

            if (outgoingCommand->packet != NULL) {
                --outgoingCommand->packet->referenceCount;

                if (outgoingCommand->packet->referenceCount == 0) {
                    outgoingCommand->packet->flags |= ENET_PACKET_FLAG_SENT;
                    callbacks.packet_destroy(outgoingCommand->packet);
                }
            }

            enet_free(outgoingCommand);
        }
    }

    static ENetProtocolCommand enet_protocol_remove_sent_reliable_command(ENetPeer *peer, enet_uint16 reliableSequenceNumber, enet_uint8 channelID) {
        ENetOutgoingCommand *outgoingCommand = NULL;
        ENetListIterator currentCommand;
        ENetProtocolCommand commandNumber;
        int wasSent = 1;

        for (currentCommand = enet_list_begin(&peer->sentReliableCommands);
            currentCommand != enet_list_end(&peer->sentReliableCommands);
            currentCommand = enet_list_next(currentCommand)
        ) {
            outgoingCommand = (ENetOutgoingCommand *) currentCommand;

            if (outgoingCommand->reliableSequenceNumber == reliableSequenceNumber && outgoingCommand->command.header.channelID == channelID) {
                break;
            }
        }

        if (currentCommand == enet_list_end(&peer->sentReliableCommands)) {
            for (currentCommand = enet_list_begin(&peer->outgoingReliableCommands);
                currentCommand != enet_list_end(&peer->outgoingReliableCommands);
                currentCommand = enet_list_next(currentCommand)
            ) {
                outgoingCommand = (ENetOutgoingCommand *) currentCommand;

                if (outgoingCommand->sendAttempts < 1) { return ENET_PROTOCOL_COMMAND_NONE; }
                if (outgoingCommand->reliableSequenceNumber == reliableSequenceNumber && outgoingCommand->command.header.channelID == channelID) {
                    break;
                }
            }

            if (currentCommand == enet_list_end(&peer->outgoingReliableCommands)) {
                return ENET_PROTOCOL_COMMAND_NONE;
            }

            wasSent = 0;
        }

        if (outgoingCommand == NULL) {
            return ENET_PROTOCOL_COMMAND_NONE;
        }

        if (channelID < peer->channelCount) {
            ENetChannel *channel       = &peer->channels[channelID];
            enet_uint16 reliableWindow = reliableSequenceNumber / ENET_PEER_RELIABLE_WINDOW_SIZE;
            if (channel->reliableWindows[reliableWindow] > 0) {
                --channel->reliableWindows[reliableWindow];
                if (!channel->reliableWindows[reliableWindow]) {
                    channel->usedReliableWindows &= ~(1 << reliableWindow);
                }
            }
        }

        commandNumber = (ENetProtocolCommand) (outgoingCommand->command.header.command & ENET_PROTOCOL_COMMAND_MASK);
        enet_list_remove(&outgoingCommand->outgoingCommandList);

        if (outgoingCommand->packet != NULL) {
            if (wasSent) {
                peer->reliableDataInTransit -= outgoingCommand->fragmentLength;
            }

            --outgoingCommand->packet->referenceCount;

            if (outgoingCommand->packet->referenceCount == 0) {
                outgoingCommand->packet->flags |= ENET_PACKET_FLAG_SENT;
                callbacks.packet_destroy(outgoingCommand->packet);
            }
        }

        enet_free(outgoingCommand);

        if (enet_list_empty(&peer->sentReliableCommands)) {
            return commandNumber;
        }

        outgoingCommand = (ENetOutgoingCommand *) enet_list_front(&peer->sentReliableCommands);
        peer->nextTimeout = outgoingCommand->sentTime + outgoingCommand->roundTripTimeout;

        return commandNumber;
    } /* enet_protocol_remove_sent_reliable_command */

    static ENetPeer * enet_protocol_handle_connect(ENetHost *host, ENetProtocolHeader *header, ENetProtocol *command) {
        ENET_UNUSED(header)

        enet_uint8 incomingSessionID, outgoingSessionID;
        enet_uint32 mtu, windowSize;
        ENetChannel *channel;
        size_t channelCount, duplicatePeers = 0;
        ENetPeer *currentPeer, *peer = NULL;
        ENetProtocol verifyCommand;

        channelCount = ENET_NET_TO_HOST_32(command->connect.channelCount);

        if (channelCount < ENET_PROTOCOL_MINIMUM_CHANNEL_COUNT || channelCount > ENET_PROTOCOL_MAXIMUM_CHANNEL_COUNT) {
            return NULL;
        }

        for (currentPeer = host->peers; currentPeer < &host->peers[host->peerCount]; ++currentPeer) {
            if (currentPeer->state == ENET_PEER_STATE_DISCONNECTED) {
                if (peer == NULL) {
                    peer = currentPeer;
                }
            } else if (currentPeer->state != ENET_PEER_STATE_CONNECTING && in6_equal(currentPeer->address.host, host->receivedAddress.host)) {
                if (currentPeer->address.port == host->receivedAddress.port && currentPeer->connectID == command->connect.connectID) {
                    return NULL;
                }

                ++duplicatePeers;
            }
        }

        if (peer == NULL || duplicatePeers >= host->duplicatePeers) {
            return NULL;
        }

        if (channelCount > host->channelLimit) {
            channelCount = host->channelLimit;
        }
        peer->channels = (ENetChannel *) enet_malloc(channelCount * sizeof(ENetChannel));
        if (peer->channels == NULL) {
            return NULL;
        }
        peer->channelCount               = channelCount;
        peer->state                      = ENET_PEER_STATE_ACKNOWLEDGING_CONNECT;
        peer->connectID                  = command->connect.connectID;
        peer->address                    = host->receivedAddress;
        peer->outgoingPeerID             = ENET_NET_TO_HOST_16(command->connect.outgoingPeerID);
        peer->incomingBandwidth          = ENET_NET_TO_HOST_32(command->connect.incomingBandwidth);
        peer->outgoingBandwidth          = ENET_NET_TO_HOST_32(command->connect.outgoingBandwidth);
        peer->packetThrottleInterval     = ENET_NET_TO_HOST_32(command->connect.packetThrottleInterval);
        peer->packetThrottleAcceleration = ENET_NET_TO_HOST_32(command->connect.packetThrottleAcceleration);
        peer->packetThrottleDeceleration = ENET_NET_TO_HOST_32(command->connect.packetThrottleDeceleration);
        peer->eventData                  = ENET_NET_TO_HOST_32(command->connect.data);

        incomingSessionID = command->connect.incomingSessionID == 0xFF ? peer->outgoingSessionID : command->connect.incomingSessionID;
        incomingSessionID = (incomingSessionID + 1) & (ENET_PROTOCOL_HEADER_SESSION_MASK >> ENET_PROTOCOL_HEADER_SESSION_SHIFT);
        if (incomingSessionID == peer->outgoingSessionID) {
            incomingSessionID = (incomingSessionID + 1)
              & (ENET_PROTOCOL_HEADER_SESSION_MASK >> ENET_PROTOCOL_HEADER_SESSION_SHIFT);
        }
        peer->outgoingSessionID = incomingSessionID;

        outgoingSessionID = command->connect.outgoingSessionID == 0xFF ? peer->incomingSessionID : command->connect.outgoingSessionID;
        outgoingSessionID = (outgoingSessionID + 1) & (ENET_PROTOCOL_HEADER_SESSION_MASK >> ENET_PROTOCOL_HEADER_SESSION_SHIFT);
        if (outgoingSessionID == peer->incomingSessionID) {
            outgoingSessionID = (outgoingSessionID + 1)
              & (ENET_PROTOCOL_HEADER_SESSION_MASK >> ENET_PROTOCOL_HEADER_SESSION_SHIFT);
        }
        peer->incomingSessionID = outgoingSessionID;

        for (channel = peer->channels; channel < &peer->channels[channelCount]; ++channel) {
            channel->outgoingReliableSequenceNumber   = 0;
            channel->outgoingUnreliableSequenceNumber = 0;
            channel->incomingReliableSequenceNumber   = 0;
            channel->incomingUnreliableSequenceNumber = 0;

            enet_list_clear(&channel->incomingReliableCommands);
            enet_list_clear(&channel->incomingUnreliableCommands);

            channel->usedReliableWindows = 0;
            memset(channel->reliableWindows, 0, sizeof(channel->reliableWindows));
        }

        mtu = ENET_NET_TO_HOST_32(command->connect.mtu);

        if (mtu < ENET_PROTOCOL_MINIMUM_MTU) {
            mtu = ENET_PROTOCOL_MINIMUM_MTU;
        } else if (mtu > ENET_PROTOCOL_MAXIMUM_MTU) {
            mtu = ENET_PROTOCOL_MAXIMUM_MTU;
        }

        peer->mtu = mtu;

        if (host->outgoingBandwidth == 0 && peer->incomingBandwidth == 0) {
            peer->windowSize = ENET_PROTOCOL_MAXIMUM_WINDOW_SIZE;
        } else if (host->outgoingBandwidth == 0 || peer->incomingBandwidth == 0) {
            peer->windowSize = (ENET_MAX(host->outgoingBandwidth, peer->incomingBandwidth) / ENET_PEER_WINDOW_SIZE_SCALE) * ENET_PROTOCOL_MINIMUM_WINDOW_SIZE;
        } else {
            peer->windowSize = (ENET_MIN(host->outgoingBandwidth, peer->incomingBandwidth) / ENET_PEER_WINDOW_SIZE_SCALE) * ENET_PROTOCOL_MINIMUM_WINDOW_SIZE;
        }

        if (peer->windowSize < ENET_PROTOCOL_MINIMUM_WINDOW_SIZE) {
            peer->windowSize = ENET_PROTOCOL_MINIMUM_WINDOW_SIZE;
        } else if (peer->windowSize > ENET_PROTOCOL_MAXIMUM_WINDOW_SIZE) {
            peer->windowSize = ENET_PROTOCOL_MAXIMUM_WINDOW_SIZE;
        }

        if (host->incomingBandwidth == 0) {
            windowSize = ENET_PROTOCOL_MAXIMUM_WINDOW_SIZE;
        } else {
            windowSize = (host->incomingBandwidth / ENET_PEER_WINDOW_SIZE_SCALE) * ENET_PROTOCOL_MINIMUM_WINDOW_SIZE;
        }

        if (windowSize > ENET_NET_TO_HOST_32(command->connect.windowSize)) {
            windowSize = ENET_NET_TO_HOST_32(command->connect.windowSize);
        }

        if (windowSize < ENET_PROTOCOL_MINIMUM_WINDOW_SIZE) {
            windowSize = ENET_PROTOCOL_MINIMUM_WINDOW_SIZE;
        } else if (windowSize > ENET_PROTOCOL_MAXIMUM_WINDOW_SIZE) {
            windowSize = ENET_PROTOCOL_MAXIMUM_WINDOW_SIZE;
        }

        verifyCommand.header.command                            = ENET_PROTOCOL_COMMAND_VERIFY_CONNECT | ENET_PROTOCOL_COMMAND_FLAG_ACKNOWLEDGE;
        verifyCommand.header.channelID                          = 0xFF;
        verifyCommand.verifyConnect.outgoingPeerID              = ENET_HOST_TO_NET_16(peer->incomingPeerID);
        verifyCommand.verifyConnect.incomingSessionID           = incomingSessionID;
        verifyCommand.verifyConnect.outgoingSessionID           = outgoingSessionID;
        verifyCommand.verifyConnect.mtu                         = ENET_HOST_TO_NET_32(peer->mtu);
        verifyCommand.verifyConnect.windowSize                  = ENET_HOST_TO_NET_32(windowSize);
        verifyCommand.verifyConnect.channelCount                = ENET_HOST_TO_NET_32(channelCount);
        verifyCommand.verifyConnect.incomingBandwidth           = ENET_HOST_TO_NET_32(host->incomingBandwidth);
        verifyCommand.verifyConnect.outgoingBandwidth           = ENET_HOST_TO_NET_32(host->outgoingBandwidth);
        verifyCommand.verifyConnect.packetThrottleInterval      = ENET_HOST_TO_NET_32(peer->packetThrottleInterval);
        verifyCommand.verifyConnect.packetThrottleAcceleration  = ENET_HOST_TO_NET_32(peer->packetThrottleAcceleration);
        verifyCommand.verifyConnect.packetThrottleDeceleration  = ENET_HOST_TO_NET_32(peer->packetThrottleDeceleration);
        verifyCommand.verifyConnect.connectID                   = peer->connectID;

        enet_peer_queue_outgoing_command(peer, &verifyCommand, NULL, 0, 0);
        return peer;
    } /* enet_protocol_handle_connect */

    static int enet_protocol_handle_send_reliable(ENetHost *host, ENetPeer *peer, const ENetProtocol *command, enet_uint8 **currentData) {
        size_t dataLength;

        if (command->header.channelID >= peer->channelCount || (peer->state != ENET_PEER_STATE_CONNECTED && peer->state != ENET_PEER_STATE_DISCONNECT_LATER)) {
            return -1;
        }

        dataLength    = ENET_NET_TO_HOST_16(command->sendReliable.dataLength);
        *currentData += dataLength;

        if (dataLength > host->maximumPacketSize || *currentData < host->receivedData || *currentData > &host->receivedData[host->receivedDataLength]) {
            return -1;
        }

        if (enet_peer_queue_incoming_command(peer, command, (const enet_uint8 *) command + sizeof(ENetProtocolSendReliable), dataLength, ENET_PACKET_FLAG_RELIABLE, 0) == NULL) {
            return -1;
        }

        return 0;
    }

    static int enet_protocol_handle_send_unsequenced(ENetHost *host, ENetPeer *peer, const ENetProtocol *command, enet_uint8 **currentData) {
        enet_uint32 unsequencedGroup, index;
        size_t dataLength;

        if (command->header.channelID >= peer->channelCount || (peer->state != ENET_PEER_STATE_CONNECTED && peer->state != ENET_PEER_STATE_DISCONNECT_LATER)) {
            return -1;
        }

        dataLength    = ENET_NET_TO_HOST_16(command->sendUnsequenced.dataLength);
        *currentData += dataLength;
        if (dataLength > host->maximumPacketSize || *currentData < host->receivedData || *currentData > &host->receivedData[host->receivedDataLength]) {
            return -1;
        }

        unsequencedGroup = ENET_NET_TO_HOST_16(command->sendUnsequenced.unsequencedGroup);
        index = unsequencedGroup % ENET_PEER_UNSEQUENCED_WINDOW_SIZE;

        if (unsequencedGroup < peer->incomingUnsequencedGroup) {
            unsequencedGroup += 0x10000;
        }

        if (unsequencedGroup >= (enet_uint32) peer->incomingUnsequencedGroup + ENET_PEER_FREE_UNSEQUENCED_WINDOWS * ENET_PEER_UNSEQUENCED_WINDOW_SIZE) {
            return 0;
        }

        unsequencedGroup &= 0xFFFF;

        if (unsequencedGroup - index != peer->incomingUnsequencedGroup) {
            peer->incomingUnsequencedGroup = unsequencedGroup - index;
            memset(peer->unsequencedWindow, 0, sizeof(peer->unsequencedWindow));
        } else if (peer->unsequencedWindow[index / 32] & (1 << (index % 32))) {
            return 0;
        }

        if (enet_peer_queue_incoming_command(peer, command, (const enet_uint8 *) command + sizeof(ENetProtocolSendUnsequenced), dataLength, ENET_PACKET_FLAG_UNSEQUENCED,0) == NULL) {
            return -1;
        }

        peer->unsequencedWindow[index / 32] |= 1 << (index % 32);

        return 0;
    } /* enet_protocol_handle_send_unsequenced */

    static int enet_protocol_handle_send_unreliable(ENetHost *host, ENetPeer *peer, const ENetProtocol *command,
      enet_uint8 **currentData) {
        size_t dataLength;

        if (command->header.channelID >= peer->channelCount ||
          (peer->state != ENET_PEER_STATE_CONNECTED && peer->state != ENET_PEER_STATE_DISCONNECT_LATER))
        {
            return -1;
        }

        dataLength    = ENET_NET_TO_HOST_16(command->sendUnreliable.dataLength);
        *currentData += dataLength;
        if (dataLength > host->maximumPacketSize || *currentData < host->receivedData || *currentData > &host->receivedData[host->receivedDataLength]) {
            return -1;
        }

        if (enet_peer_queue_incoming_command(peer, command, (const enet_uint8 *) command + sizeof(ENetProtocolSendUnreliable), dataLength, 0, 0) == NULL) {
            return -1;
        }

        return 0;
    }

    static int enet_protocol_handle_send_fragment(ENetHost *host, ENetPeer *peer, const ENetProtocol *command, enet_uint8 **currentData) {
        enet_uint32 fragmentNumber, fragmentCount, fragmentOffset, fragmentLength, startSequenceNumber, totalLength;
        ENetChannel *channel;
        enet_uint16 startWindow, currentWindow;
        ENetListIterator currentCommand;
        ENetIncomingCommand *startCommand = NULL;

        if (command->header.channelID >= peer->channelCount || (peer->state != ENET_PEER_STATE_CONNECTED && peer->state != ENET_PEER_STATE_DISCONNECT_LATER)) {
            return -1;
        }

        fragmentLength = ENET_NET_TO_HOST_16(command->sendFragment.dataLength);
        *currentData  += fragmentLength;
        if (fragmentLength > host->maximumPacketSize || *currentData < host->receivedData || *currentData > &host->receivedData[host->receivedDataLength]) {
            return -1;
        }

        channel = &peer->channels[command->header.channelID];
        startSequenceNumber = ENET_NET_TO_HOST_16(command->sendFragment.startSequenceNumber);
        startWindow         = startSequenceNumber / ENET_PEER_RELIABLE_WINDOW_SIZE;
        currentWindow       = channel->incomingReliableSequenceNumber / ENET_PEER_RELIABLE_WINDOW_SIZE;

        if (startSequenceNumber < channel->incomingReliableSequenceNumber) {
            startWindow += ENET_PEER_RELIABLE_WINDOWS;
        }

        if (startWindow < currentWindow || startWindow >= currentWindow + ENET_PEER_FREE_RELIABLE_WINDOWS - 1) {
            return 0;
        }

        fragmentNumber = ENET_NET_TO_HOST_32(command->sendFragment.fragmentNumber);
        fragmentCount  = ENET_NET_TO_HOST_32(command->sendFragment.fragmentCount);
        fragmentOffset = ENET_NET_TO_HOST_32(command->sendFragment.fragmentOffset);
        totalLength    = ENET_NET_TO_HOST_32(command->sendFragment.totalLength);

        if (fragmentCount > ENET_PROTOCOL_MAXIMUM_FRAGMENT_COUNT ||
            fragmentNumber >= fragmentCount ||
            totalLength > host->maximumPacketSize ||
            fragmentOffset >= totalLength ||
            fragmentLength > totalLength - fragmentOffset
        ) {
            return -1;
        }

        for (currentCommand = enet_list_previous(enet_list_end(&channel->incomingReliableCommands));
            currentCommand != enet_list_end(&channel->incomingReliableCommands);
            currentCommand = enet_list_previous(currentCommand)
        ) {
            ENetIncomingCommand *incomingCommand = (ENetIncomingCommand *) currentCommand;

            if (startSequenceNumber >= channel->incomingReliableSequenceNumber) {
                if (incomingCommand->reliableSequenceNumber < channel->incomingReliableSequenceNumber) {
                    continue;
                }
            } else if (incomingCommand->reliableSequenceNumber >= channel->incomingReliableSequenceNumber) {
                break;
            }

            if (incomingCommand->reliableSequenceNumber <= startSequenceNumber) {
                if (incomingCommand->reliableSequenceNumber < startSequenceNumber) {
                    break;
                }

                if ((incomingCommand->command.header.command & ENET_PROTOCOL_COMMAND_MASK) !=
                    ENET_PROTOCOL_COMMAND_SEND_FRAGMENT ||
                    totalLength != incomingCommand->packet->dataLength ||
                    fragmentCount != incomingCommand->fragmentCount
                ) {
                    return -1;
                }

                startCommand = incomingCommand;
                break;
            }
        }

        if (startCommand == NULL) {
            ENetProtocol hostCommand = *command;
            hostCommand.header.reliableSequenceNumber = startSequenceNumber;
            startCommand = enet_peer_queue_incoming_command(peer, &hostCommand, NULL, totalLength, ENET_PACKET_FLAG_RELIABLE, fragmentCount);
            if (startCommand == NULL) {
                return -1;
            }
        }

        if ((startCommand->fragments[fragmentNumber / 32] & (1 << (fragmentNumber % 32))) == 0) {
            --startCommand->fragmentsRemaining;
            startCommand->fragments[fragmentNumber / 32] |= (1 << (fragmentNumber % 32));

            if (fragmentOffset + fragmentLength > startCommand->packet->dataLength) {
                fragmentLength = startCommand->packet->dataLength - fragmentOffset;
            }

            memcpy(startCommand->packet->data + fragmentOffset, (enet_uint8 *) command + sizeof(ENetProtocolSendFragment), fragmentLength);

            if (startCommand->fragmentsRemaining <= 0) {
                enet_peer_dispatch_incoming_reliable_commands(peer, channel);
            }
        }

        return 0;
    } /* enet_protocol_handle_send_fragment */

    static int enet_protocol_handle_send_unreliable_fragment(ENetHost *host, ENetPeer *peer, const ENetProtocol *command, enet_uint8 **currentData) {
        enet_uint32 fragmentNumber, fragmentCount, fragmentOffset, fragmentLength, reliableSequenceNumber, startSequenceNumber, totalLength;
        enet_uint16 reliableWindow, currentWindow;
        ENetChannel *channel;
        ENetListIterator currentCommand;
        ENetIncomingCommand *startCommand = NULL;

        if (command->header.channelID >= peer->channelCount || (peer->state != ENET_PEER_STATE_CONNECTED && peer->state != ENET_PEER_STATE_DISCONNECT_LATER)) {
            return -1;
        }

        fragmentLength = ENET_NET_TO_HOST_16(command->sendFragment.dataLength);
        *currentData  += fragmentLength;
        if (fragmentLength > host->maximumPacketSize || *currentData < host->receivedData || *currentData > &host->receivedData[host->receivedDataLength]) {
            return -1;
        }

        channel = &peer->channels[command->header.channelID];
        reliableSequenceNumber = command->header.reliableSequenceNumber;
        startSequenceNumber    = ENET_NET_TO_HOST_16(command->sendFragment.startSequenceNumber);

        reliableWindow = reliableSequenceNumber / ENET_PEER_RELIABLE_WINDOW_SIZE;
        currentWindow  = channel->incomingReliableSequenceNumber / ENET_PEER_RELIABLE_WINDOW_SIZE;

        if (reliableSequenceNumber < channel->incomingReliableSequenceNumber) {
            reliableWindow += ENET_PEER_RELIABLE_WINDOWS;
        }

        if (reliableWindow < currentWindow || reliableWindow >= currentWindow + ENET_PEER_FREE_RELIABLE_WINDOWS - 1) {
            return 0;
        }

        if (reliableSequenceNumber == channel->incomingReliableSequenceNumber && startSequenceNumber <= channel->incomingUnreliableSequenceNumber) {
            return 0;
        }

        fragmentNumber = ENET_NET_TO_HOST_32(command->sendFragment.fragmentNumber);
        fragmentCount  = ENET_NET_TO_HOST_32(command->sendFragment.fragmentCount);
        fragmentOffset = ENET_NET_TO_HOST_32(command->sendFragment.fragmentOffset);
        totalLength    = ENET_NET_TO_HOST_32(command->sendFragment.totalLength);

        if (fragmentCount > ENET_PROTOCOL_MAXIMUM_FRAGMENT_COUNT ||
            fragmentNumber >= fragmentCount ||
            totalLength > host->maximumPacketSize ||
            fragmentOffset >= totalLength ||
            fragmentLength > totalLength - fragmentOffset
        ) {
            return -1;
        }

        for (currentCommand = enet_list_previous(enet_list_end(&channel->incomingUnreliableCommands));
            currentCommand != enet_list_end(&channel->incomingUnreliableCommands);
            currentCommand = enet_list_previous(currentCommand)
        ) {
            ENetIncomingCommand *incomingCommand = (ENetIncomingCommand *) currentCommand;

            if (reliableSequenceNumber >= channel->incomingReliableSequenceNumber) {
                if (incomingCommand->reliableSequenceNumber < channel->incomingReliableSequenceNumber) {
                    continue;
                }
            } else if (incomingCommand->reliableSequenceNumber >= channel->incomingReliableSequenceNumber) {
                break;
            }

            if (incomingCommand->reliableSequenceNumber < reliableSequenceNumber) {
                break;
            }

            if (incomingCommand->reliableSequenceNumber > reliableSequenceNumber) {
                continue;
            }

            if (incomingCommand->unreliableSequenceNumber <= startSequenceNumber) {
                if (incomingCommand->unreliableSequenceNumber < startSequenceNumber) {
                    break;
                }

                if ((incomingCommand->command.header.command & ENET_PROTOCOL_COMMAND_MASK) !=
                    ENET_PROTOCOL_COMMAND_SEND_UNRELIABLE_FRAGMENT ||
                    totalLength != incomingCommand->packet->dataLength ||
                    fragmentCount != incomingCommand->fragmentCount
                ) {
                    return -1;
                }

                startCommand = incomingCommand;
                break;
            }
        }

        if (startCommand == NULL) {
            startCommand = enet_peer_queue_incoming_command(peer, command, NULL, totalLength,
                ENET_PACKET_FLAG_UNRELIABLE_FRAGMENT, fragmentCount);
            if (startCommand == NULL) {
                return -1;
            }
        }

        if ((startCommand->fragments[fragmentNumber / 32] & (1 << (fragmentNumber % 32))) == 0) {
            --startCommand->fragmentsRemaining;
            startCommand->fragments[fragmentNumber / 32] |= (1 << (fragmentNumber % 32));

            if (fragmentOffset + fragmentLength > startCommand->packet->dataLength) {
                fragmentLength = startCommand->packet->dataLength - fragmentOffset;
            }

            memcpy(startCommand->packet->data + fragmentOffset, (enet_uint8 *) command + sizeof(ENetProtocolSendFragment), fragmentLength);

            if (startCommand->fragmentsRemaining <= 0) {
                enet_peer_dispatch_incoming_unreliable_commands(peer, channel);
            }
        }

        return 0;
    } /* enet_protocol_handle_send_unreliable_fragment */

    static int enet_protocol_handle_ping(ENetHost *host, ENetPeer *peer, const ENetProtocol *command) {
        ENET_UNUSED(host)
        ENET_UNUSED(command)

        if (peer->state != ENET_PEER_STATE_CONNECTED && peer->state != ENET_PEER_STATE_DISCONNECT_LATER) {
            return -1;
        }

        return 0;
    }

    static int enet_protocol_handle_bandwidth_limit(ENetHost *host, ENetPeer *peer, const ENetProtocol *command) {
        if (peer->state != ENET_PEER_STATE_CONNECTED && peer->state != ENET_PEER_STATE_DISCONNECT_LATER) {
            return -1;
        }

        if (peer->incomingBandwidth != 0) {
            --host->bandwidthLimitedPeers;
        }

        peer->incomingBandwidth = ENET_NET_TO_HOST_32(command->bandwidthLimit.incomingBandwidth);
        peer->outgoingBandwidth = ENET_NET_TO_HOST_32(command->bandwidthLimit.outgoingBandwidth);

        if (peer->incomingBandwidth != 0) {
            ++host->bandwidthLimitedPeers;
        }

        if (peer->incomingBandwidth == 0 && host->outgoingBandwidth == 0) {
            peer->windowSize = ENET_PROTOCOL_MAXIMUM_WINDOW_SIZE;
        } else if (peer->incomingBandwidth == 0 || host->outgoingBandwidth == 0) {
            peer->windowSize = (ENET_MAX(peer->incomingBandwidth, host->outgoingBandwidth)
              / ENET_PEER_WINDOW_SIZE_SCALE) * ENET_PROTOCOL_MINIMUM_WINDOW_SIZE;
        } else {
            peer->windowSize = (ENET_MIN(peer->incomingBandwidth, host->outgoingBandwidth)
              / ENET_PEER_WINDOW_SIZE_SCALE) * ENET_PROTOCOL_MINIMUM_WINDOW_SIZE;
        }

        if (peer->windowSize < ENET_PROTOCOL_MINIMUM_WINDOW_SIZE) {
            peer->windowSize = ENET_PROTOCOL_MINIMUM_WINDOW_SIZE;
        } else if (peer->windowSize > ENET_PROTOCOL_MAXIMUM_WINDOW_SIZE) {
            peer->windowSize = ENET_PROTOCOL_MAXIMUM_WINDOW_SIZE;
        }

        return 0;
    } /* enet_protocol_handle_bandwidth_limit */

    static int enet_protocol_handle_throttle_configure(ENetHost *host, ENetPeer *peer, const ENetProtocol *command) {
        ENET_UNUSED(host)

        if (peer->state != ENET_PEER_STATE_CONNECTED && peer->state != ENET_PEER_STATE_DISCONNECT_LATER) {
            return -1;
        }

        peer->packetThrottleInterval     = ENET_NET_TO_HOST_32(command->throttleConfigure.packetThrottleInterval);
        peer->packetThrottleAcceleration = ENET_NET_TO_HOST_32(command->throttleConfigure.packetThrottleAcceleration);
        peer->packetThrottleDeceleration = ENET_NET_TO_HOST_32(command->throttleConfigure.packetThrottleDeceleration);

        return 0;
    }

    static int enet_protocol_handle_disconnect(ENetHost *host, ENetPeer *peer, const ENetProtocol *command) {
        if (peer->state == ENET_PEER_STATE_DISCONNECTED || peer->state == ENET_PEER_STATE_ZOMBIE ||
            peer->state == ENET_PEER_STATE_ACKNOWLEDGING_DISCONNECT
        ) {
            return 0;
        }

        enet_peer_reset_queues(peer);

        if (peer->state == ENET_PEER_STATE_CONNECTION_SUCCEEDED || peer->state == ENET_PEER_STATE_DISCONNECTING || peer->state == ENET_PEER_STATE_CONNECTING) {
            enet_protocol_dispatch_state(host, peer, ENET_PEER_STATE_ZOMBIE);
        }
        else if (peer->state != ENET_PEER_STATE_CONNECTED && peer->state != ENET_PEER_STATE_DISCONNECT_LATER) {
            if (peer->state == ENET_PEER_STATE_CONNECTION_PENDING) { host->recalculateBandwidthLimits = 1; }
            enet_peer_reset(peer);
        }
        else if (command->header.command & ENET_PROTOCOL_COMMAND_FLAG_ACKNOWLEDGE) {
            enet_protocol_change_state(host, peer, ENET_PEER_STATE_ACKNOWLEDGING_DISCONNECT);
        }
        else {
            enet_protocol_dispatch_state(host, peer, ENET_PEER_STATE_ZOMBIE);
        }

        if (peer->state != ENET_PEER_STATE_DISCONNECTED) {
            peer->eventData = ENET_NET_TO_HOST_32(command->disconnect.data);
        }

        return 0;
    }

    static int enet_protocol_handle_acknowledge(ENetHost *host, ENetEvent *event, ENetPeer *peer, const ENetProtocol *command) {
        enet_uint32 roundTripTime, receivedSentTime, receivedReliableSequenceNumber;
        ENetProtocolCommand commandNumber;

        if (peer->state == ENET_PEER_STATE_DISCONNECTED || peer->state == ENET_PEER_STATE_ZOMBIE) {
            return 0;
        }

        receivedSentTime  = ENET_NET_TO_HOST_16(command->acknowledge.receivedSentTime);
        receivedSentTime |= host->serviceTime & 0xFFFF0000;
        if ((receivedSentTime & 0x8000) > (host->serviceTime & 0x8000)) {
            receivedSentTime -= 0x10000;
        }

        if (ENET_TIME_LESS(host->serviceTime, receivedSentTime)) {
            return 0;
        }

        peer->lastReceiveTime = host->serviceTime;
        peer->earliestTimeout = 0;
        roundTripTime = ENET_TIME_DIFFERENCE(host->serviceTime, receivedSentTime);

        enet_peer_throttle(peer, roundTripTime);
        peer->roundTripTimeVariance -= peer->roundTripTimeVariance / 4;

        if (roundTripTime >= peer->roundTripTime) {
            peer->roundTripTime         += (roundTripTime - peer->roundTripTime) / 8;
            peer->roundTripTimeVariance += (roundTripTime - peer->roundTripTime) / 4;
        } else {
            peer->roundTripTime         -= (peer->roundTripTime - roundTripTime) / 8;
            peer->roundTripTimeVariance += (peer->roundTripTime - roundTripTime) / 4;
        }

        if (peer->roundTripTime < peer->lowestRoundTripTime) {
            peer->lowestRoundTripTime = peer->roundTripTime;
        }

        if (peer->roundTripTimeVariance > peer->highestRoundTripTimeVariance) {
            peer->highestRoundTripTimeVariance = peer->roundTripTimeVariance;
        }

        if (peer->packetThrottleEpoch == 0 ||
            ENET_TIME_DIFFERENCE(host->serviceTime, peer->packetThrottleEpoch) >= peer->packetThrottleInterval
        ) {
            peer->lastRoundTripTime            = peer->lowestRoundTripTime;
            peer->lastRoundTripTimeVariance    = peer->highestRoundTripTimeVariance;
            peer->lowestRoundTripTime          = peer->roundTripTime;
            peer->highestRoundTripTimeVariance = peer->roundTripTimeVariance;
            peer->packetThrottleEpoch          = host->serviceTime;
        }

        receivedReliableSequenceNumber = ENET_NET_TO_HOST_16(command->acknowledge.receivedReliableSequenceNumber);
        commandNumber = enet_protocol_remove_sent_reliable_command(peer, receivedReliableSequenceNumber, command->header.channelID);

        switch (peer->state) {
            case ENET_PEER_STATE_ACKNOWLEDGING_CONNECT:
                if (commandNumber != ENET_PROTOCOL_COMMAND_VERIFY_CONNECT) {
                    return -1;
                }

                enet_protocol_notify_connect(host, peer, event);
                break;

            case ENET_PEER_STATE_DISCONNECTING:
                if (commandNumber != ENET_PROTOCOL_COMMAND_DISCONNECT) {
                    return -1;
                }

                enet_protocol_notify_disconnect(host, peer, event);
                break;

            case ENET_PEER_STATE_DISCONNECT_LATER:
                if (enet_list_empty(&peer->outgoingReliableCommands) &&
                  enet_list_empty(&peer->outgoingUnreliableCommands) &&
                  enet_list_empty(&peer->sentReliableCommands))
                {
                    enet_peer_disconnect(peer, peer->eventData);
                }
                break;

            default:
                break;
        }

        return 0;
    } /* enet_protocol_handle_acknowledge */

    static int enet_protocol_handle_verify_connect(ENetHost *host, ENetEvent *event, ENetPeer *peer, const ENetProtocol *command) {
        enet_uint32 mtu, windowSize;
        size_t channelCount;

        if (peer->state != ENET_PEER_STATE_CONNECTING) {
            return 0;
        }

        channelCount = ENET_NET_TO_HOST_32(command->verifyConnect.channelCount);

        if (channelCount < ENET_PROTOCOL_MINIMUM_CHANNEL_COUNT || channelCount > ENET_PROTOCOL_MAXIMUM_CHANNEL_COUNT ||
            ENET_NET_TO_HOST_32(command->verifyConnect.packetThrottleInterval) != peer->packetThrottleInterval ||
            ENET_NET_TO_HOST_32(command->verifyConnect.packetThrottleAcceleration) != peer->packetThrottleAcceleration ||
            ENET_NET_TO_HOST_32(command->verifyConnect.packetThrottleDeceleration) != peer->packetThrottleDeceleration ||
            command->verifyConnect.connectID != peer->connectID
        ) {
            peer->eventData = 0;
            enet_protocol_dispatch_state(host, peer, ENET_PEER_STATE_ZOMBIE);
            return -1;
        }

        enet_protocol_remove_sent_reliable_command(peer, 1, 0xFF);

        if (channelCount < peer->channelCount) {
            peer->channelCount = channelCount;
        }

        peer->outgoingPeerID    = ENET_NET_TO_HOST_16(command->verifyConnect.outgoingPeerID);
        peer->incomingSessionID = command->verifyConnect.incomingSessionID;
        peer->outgoingSessionID = command->verifyConnect.outgoingSessionID;

        mtu = ENET_NET_TO_HOST_32(command->verifyConnect.mtu);

        if (mtu < ENET_PROTOCOL_MINIMUM_MTU) {
            mtu = ENET_PROTOCOL_MINIMUM_MTU;
        } else if (mtu > ENET_PROTOCOL_MAXIMUM_MTU) {
            mtu = ENET_PROTOCOL_MAXIMUM_MTU;
        }

        if (mtu < peer->mtu) {
            peer->mtu = mtu;
        }

        windowSize = ENET_NET_TO_HOST_32(command->verifyConnect.windowSize);
        if (windowSize < ENET_PROTOCOL_MINIMUM_WINDOW_SIZE) {
            windowSize = ENET_PROTOCOL_MINIMUM_WINDOW_SIZE;
        }

        if (windowSize > ENET_PROTOCOL_MAXIMUM_WINDOW_SIZE) {
            windowSize = ENET_PROTOCOL_MAXIMUM_WINDOW_SIZE;
        }

        if (windowSize < peer->windowSize) {
            peer->windowSize = windowSize;
        }

        peer->incomingBandwidth = ENET_NET_TO_HOST_32(command->verifyConnect.incomingBandwidth);
        peer->outgoingBandwidth = ENET_NET_TO_HOST_32(command->verifyConnect.outgoingBandwidth);

        enet_protocol_notify_connect(host, peer, event);
        return 0;
    } /* enet_protocol_handle_verify_connect */

    static int enet_protocol_handle_incoming_commands(ENetHost *host, ENetEvent *event) {
        ENetProtocolHeader *header;
        ENetProtocol *command;
        ENetPeer *peer;
        enet_uint8 *currentData;
        size_t headerSize;
        enet_uint16 peerID, flags;
        enet_uint8 sessionID;

        if (host->receivedDataLength < (size_t) &((ENetProtocolHeader *) 0)->sentTime) {
            return 0;
        }

        header = (ENetProtocolHeader *) host->receivedData;

        peerID    = ENET_NET_TO_HOST_16(header->peerID);
        sessionID = (peerID & ENET_PROTOCOL_HEADER_SESSION_MASK) >> ENET_PROTOCOL_HEADER_SESSION_SHIFT;
        flags     = peerID & ENET_PROTOCOL_HEADER_FLAG_MASK;
        peerID   &= ~(ENET_PROTOCOL_HEADER_FLAG_MASK | ENET_PROTOCOL_HEADER_SESSION_MASK);

        headerSize = (flags & ENET_PROTOCOL_HEADER_FLAG_SENT_TIME ? sizeof(ENetProtocolHeader) : (size_t) &((ENetProtocolHeader *) 0)->sentTime);
        if (host->checksum != NULL) {
            headerSize += sizeof(enet_uint32);
        }

        if (peerID == ENET_PROTOCOL_MAXIMUM_PEER_ID) {
            peer = NULL;
        } else if (peerID >= host->peerCount) {
            return 0;
        } else {
            peer = &host->peers[peerID];

            if (peer->state == ENET_PEER_STATE_DISCONNECTED ||
                peer->state == ENET_PEER_STATE_ZOMBIE ||
                ((!in6_equal(host->receivedAddress.host , peer->address.host) ||
                host->receivedAddress.port != peer->address.port) &&
                1 /* no broadcast in ipv6  !in6_equal(peer->address.host , ENET_HOST_BROADCAST)*/) ||
                (peer->outgoingPeerID < ENET_PROTOCOL_MAXIMUM_PEER_ID &&
                sessionID != peer->incomingSessionID)
            ) {
                return 0;
            }
        }

        if (flags & ENET_PROTOCOL_HEADER_FLAG_COMPRESSED) {
            size_t originalSize;
            if (host->compressor.context == NULL || host->compressor.decompress == NULL) {
                return 0;
            }

            originalSize = host->compressor.decompress(host->compressor.context,
                host->receivedData + headerSize,
                host->receivedDataLength - headerSize,
                host->packetData[1] + headerSize,
                sizeof(host->packetData[1]) - headerSize
            );

            if (originalSize <= 0 || originalSize > sizeof(host->packetData[1]) - headerSize) {
                return 0;
            }

            memcpy(host->packetData[1], header, headerSize);
            host->receivedData       = host->packetData[1];
            host->receivedDataLength = headerSize + originalSize;
        }

        if (host->checksum != NULL) {
            enet_uint32 *checksum = (enet_uint32 *) &host->receivedData[headerSize - sizeof(enet_uint32)];
            enet_uint32 desiredChecksum = *checksum;
            ENetBuffer buffer;

            *checksum = peer != NULL ? peer->connectID : 0;

            buffer.data       = host->receivedData;
            buffer.dataLength = host->receivedDataLength;

            if (host->checksum(&buffer, 1) != desiredChecksum) {
                return 0;
            }
        }

        if (peer != NULL) {
            peer->address.host       = host->receivedAddress.host;
            peer->address.port       = host->receivedAddress.port;
            peer->incomingDataTotal += host->receivedDataLength;
            peer->totalDataReceived += host->receivedDataLength;
        }

        currentData = host->receivedData + headerSize;

        while (currentData < &host->receivedData[host->receivedDataLength]) {
            enet_uint8 commandNumber;
            size_t commandSize;

            command = (ENetProtocol *) currentData;

            if (currentData + sizeof(ENetProtocolCommandHeader) > &host->receivedData[host->receivedDataLength]) {
                break;
            }

            commandNumber = command->header.command & ENET_PROTOCOL_COMMAND_MASK;
            if (commandNumber >= ENET_PROTOCOL_COMMAND_COUNT) {
                break;
            }

            commandSize = commandSizes[commandNumber];
            if (commandSize == 0 || currentData + commandSize > &host->receivedData[host->receivedDataLength]) {
                break;
            }

            currentData += commandSize;

            if (peer == NULL && (commandNumber != ENET_PROTOCOL_COMMAND_CONNECT || currentData < &host->receivedData[host->receivedDataLength])) {
                break;
            }

            command->header.reliableSequenceNumber = ENET_NET_TO_HOST_16(command->header.reliableSequenceNumber);

            switch (commandNumber) {
                case ENET_PROTOCOL_COMMAND_ACKNOWLEDGE:
                    if (enet_protocol_handle_acknowledge(host, event, peer, command)) {
                        goto commandError;
                    }
                    break;

                case ENET_PROTOCOL_COMMAND_CONNECT:
                    if (peer != NULL) {
                        goto commandError;
                    }
                    peer = enet_protocol_handle_connect(host, header, command);
                    if (peer == NULL) {
                        goto commandError;
                    }
                    break;

                case ENET_PROTOCOL_COMMAND_VERIFY_CONNECT:
                    if (enet_protocol_handle_verify_connect(host, event, peer, command)) {
                        goto commandError;
                    }
                    break;

                case ENET_PROTOCOL_COMMAND_DISCONNECT:
                    if (enet_protocol_handle_disconnect(host, peer, command)) {
                        goto commandError;
                    }
                    break;

                case ENET_PROTOCOL_COMMAND_PING:
                    if (enet_protocol_handle_ping(host, peer, command)) {
                        goto commandError;
                    }
                    break;

                case ENET_PROTOCOL_COMMAND_SEND_RELIABLE:
                    if (enet_protocol_handle_send_reliable(host, peer, command, &currentData)) {
                        goto commandError;
                    }
                    break;

                case ENET_PROTOCOL_COMMAND_SEND_UNRELIABLE:
                    if (enet_protocol_handle_send_unreliable(host, peer, command, &currentData)) {
                        goto commandError;
                    }
                    break;

                case ENET_PROTOCOL_COMMAND_SEND_UNSEQUENCED:
                    if (enet_protocol_handle_send_unsequenced(host, peer, command, &currentData)) {
                        goto commandError;
                    }
                    break;

                case ENET_PROTOCOL_COMMAND_SEND_FRAGMENT:
                    if (enet_protocol_handle_send_fragment(host, peer, command, &currentData)) {
                        goto commandError;
                    }
                    break;

                case ENET_PROTOCOL_COMMAND_BANDWIDTH_LIMIT:
                    if (enet_protocol_handle_bandwidth_limit(host, peer, command)) {
                        goto commandError;
                    }
                    break;

                case ENET_PROTOCOL_COMMAND_THROTTLE_CONFIGURE:
                    if (enet_protocol_handle_throttle_configure(host, peer, command)) {
                        goto commandError;
                    }
                    break;

                case ENET_PROTOCOL_COMMAND_SEND_UNRELIABLE_FRAGMENT:
                    if (enet_protocol_handle_send_unreliable_fragment(host, peer, command, &currentData)) {
                        goto commandError;
                    }
                    break;

                default:
                    goto commandError;
            }

            if (peer != NULL && (command->header.command & ENET_PROTOCOL_COMMAND_FLAG_ACKNOWLEDGE) != 0) {
                enet_uint16 sentTime;

                if (!(flags & ENET_PROTOCOL_HEADER_FLAG_SENT_TIME)) {
                    break;
                }

                sentTime = ENET_NET_TO_HOST_16(header->sentTime);

                switch (peer->state) {
                    case ENET_PEER_STATE_DISCONNECTING:
                    case ENET_PEER_STATE_ACKNOWLEDGING_CONNECT:
                    case ENET_PEER_STATE_DISCONNECTED:
                    case ENET_PEER_STATE_ZOMBIE:
                        break;

                    case ENET_PEER_STATE_ACKNOWLEDGING_DISCONNECT:
                        if ((command->header.command & ENET_PROTOCOL_COMMAND_MASK) == ENET_PROTOCOL_COMMAND_DISCONNECT) {
                            enet_peer_queue_acknowledgement(peer, command, sentTime);
                        }
                        break;

                    default:
                        enet_peer_queue_acknowledgement(peer, command, sentTime);
                        break;
                }
            }
        }

    commandError:
        if (event != NULL && event->type != ENET_EVENT_TYPE_NONE) {
            return 1;
        }

        return 0;
    } /* enet_protocol_handle_incoming_commands */

    static int enet_protocol_receive_incoming_commands(ENetHost *host, ENetEvent *event) {
        int packets;

        for (packets = 0; packets < 256; ++packets) {
            int receivedLength;
            ENetBuffer buffer;

            buffer.data       = host->packetData[0];
            // buffer.dataLength = sizeof (host->packetData[0]);
            buffer.dataLength = host->mtu;

            receivedLength    = enet_socket_receive(host->socket, &host->receivedAddress, &buffer, 1);

            if (receivedLength == -2)
                continue;

            if (receivedLength < 0) {
                return -1;
            }

            if (receivedLength == 0) {
                return 0;
            }

            host->receivedData       = host->packetData[0];
            host->receivedDataLength = receivedLength;

            host->totalReceivedData += receivedLength;
            host->totalReceivedPackets++;

            if (host->intercept != NULL) {
                switch (host->intercept(host, (void *)event)) {
                    case 1:
                        if (event != NULL && event->type != ENET_EVENT_TYPE_NONE) {
                            return 1;
                        }

                        continue;

                    case -1:
                        return -1;

                    default:
                        break;
                }
            }

            switch (enet_protocol_handle_incoming_commands(host, event)) {
                case 1:
                    return 1;

                case -1:
                    return -1;

                default:
                    break;
            }
        }

        return -1;
    } /* enet_protocol_receive_incoming_commands */

    static void enet_protocol_send_acknowledgements(ENetHost *host, ENetPeer *peer) {
        ENetProtocol *command = &host->commands[host->commandCount];
        ENetBuffer *buffer    = &host->buffers[host->bufferCount];
        ENetAcknowledgement *acknowledgement;
        ENetListIterator currentAcknowledgement;
        enet_uint16 reliableSequenceNumber;

        currentAcknowledgement = enet_list_begin(&peer->acknowledgements);

        while (currentAcknowledgement != enet_list_end(&peer->acknowledgements)) {
            if (command >= &host->commands[sizeof(host->commands) / sizeof(ENetProtocol)] ||
                buffer >= &host->buffers[sizeof(host->buffers) / sizeof(ENetBuffer)] ||
                peer->mtu - host->packetSize < sizeof(ENetProtocolAcknowledge)
            ) {
                host->continueSending = 1;
                break;
            }

            acknowledgement = (ENetAcknowledgement *) currentAcknowledgement;
            currentAcknowledgement = enet_list_next(currentAcknowledgement);

            buffer->data       = command;
            buffer->dataLength = sizeof(ENetProtocolAcknowledge);
            host->packetSize += buffer->dataLength;

            reliableSequenceNumber = ENET_HOST_TO_NET_16(acknowledgement->command.header.reliableSequenceNumber);

            command->header.command   = ENET_PROTOCOL_COMMAND_ACKNOWLEDGE;
            command->header.channelID = acknowledgement->command.header.channelID;
            command->header.reliableSequenceNumber = reliableSequenceNumber;
            command->acknowledge.receivedReliableSequenceNumber = reliableSequenceNumber;
            command->acknowledge.receivedSentTime = ENET_HOST_TO_NET_16(acknowledgement->sentTime);

            if ((acknowledgement->command.header.command & ENET_PROTOCOL_COMMAND_MASK) == ENET_PROTOCOL_COMMAND_DISCONNECT) {
                enet_protocol_dispatch_state(host, peer, ENET_PEER_STATE_ZOMBIE);
            }

            enet_list_remove(&acknowledgement->acknowledgementList);
            enet_free(acknowledgement);

            ++command;
            ++buffer;
        }

        host->commandCount = command - host->commands;
        host->bufferCount  = buffer - host->buffers;
    } /* enet_protocol_send_acknowledgements */

    static void enet_protocol_send_unreliable_outgoing_commands(ENetHost *host, ENetPeer *peer) {
        ENetProtocol *command = &host->commands[host->commandCount];
        ENetBuffer *buffer    = &host->buffers[host->bufferCount];
        ENetOutgoingCommand *outgoingCommand;
        ENetListIterator currentCommand;

        currentCommand = enet_list_begin(&peer->outgoingUnreliableCommands);
        while (currentCommand != enet_list_end(&peer->outgoingUnreliableCommands)) {
            size_t commandSize;

            outgoingCommand = (ENetOutgoingCommand *) currentCommand;
            commandSize     = commandSizes[outgoingCommand->command.header.command & ENET_PROTOCOL_COMMAND_MASK];

            if (command >= &host->commands[sizeof(host->commands) / sizeof(ENetProtocol)] ||
                buffer + 1 >= &host->buffers[sizeof(host->buffers) / sizeof(ENetBuffer)] ||
                peer->mtu - host->packetSize < commandSize ||
                (outgoingCommand->packet != NULL &&
                peer->mtu - host->packetSize < commandSize + outgoingCommand->fragmentLength)
            ) {
                host->continueSending = 1;
                break;
            }

            currentCommand = enet_list_next(currentCommand);

            if (outgoingCommand->packet != NULL && outgoingCommand->fragmentOffset == 0) {
                peer->packetThrottleCounter += ENET_PEER_PACKET_THROTTLE_COUNTER;
                peer->packetThrottleCounter %= ENET_PEER_PACKET_THROTTLE_SCALE;

                if (peer->packetThrottleCounter > peer->packetThrottle) {
                    enet_uint16 reliableSequenceNumber = outgoingCommand->reliableSequenceNumber;
                    enet_uint16 unreliableSequenceNumber = outgoingCommand->unreliableSequenceNumber;
                    for (;;) {
                        --outgoingCommand->packet->referenceCount;

                        if (outgoingCommand->packet->referenceCount == 0) {
                            callbacks.packet_destroy(outgoingCommand->packet);
                        }

                        enet_list_remove(&outgoingCommand->outgoingCommandList);
                        enet_free(outgoingCommand);

                        if (currentCommand == enet_list_end(&peer->outgoingUnreliableCommands)) {
                            break;
                        }

                        outgoingCommand = (ENetOutgoingCommand *) currentCommand;
                        if (outgoingCommand->reliableSequenceNumber != reliableSequenceNumber || outgoingCommand->unreliableSequenceNumber != unreliableSequenceNumber) {
                            break;
                        }

                        currentCommand = enet_list_next(currentCommand);
                    }

                    continue;
                }
            }

            buffer->data       = command;
            buffer->dataLength = commandSize;
            host->packetSize += buffer->dataLength;
            *command = outgoingCommand->command;
            enet_list_remove(&outgoingCommand->outgoingCommandList);

            if (outgoingCommand->packet != NULL) {
                ++buffer;

                buffer->data       = outgoingCommand->packet->data + outgoingCommand->fragmentOffset;
                buffer->dataLength = outgoingCommand->fragmentLength;

                host->packetSize += buffer->dataLength;

                enet_list_insert(enet_list_end(&peer->sentUnreliableCommands), outgoingCommand);
            } else {
                enet_free(outgoingCommand);
            }

            ++command;
            ++buffer;
        }

        host->commandCount = command - host->commands;
        host->bufferCount  = buffer - host->buffers;

        if (peer->state == ENET_PEER_STATE_DISCONNECT_LATER &&
          enet_list_empty(&peer->outgoingReliableCommands) &&
          enet_list_empty(&peer->outgoingUnreliableCommands) &&
          enet_list_empty(&peer->sentReliableCommands))
        {
            enet_peer_disconnect(peer, peer->eventData);
        }
    } /* enet_protocol_send_unreliable_outgoing_commands */

    static int enet_protocol_check_timeouts(ENetHost *host, ENetPeer *peer, ENetEvent *event) {
        ENetOutgoingCommand *outgoingCommand;
        ENetListIterator currentCommand, insertPosition;

        currentCommand = enet_list_begin(&peer->sentReliableCommands);
        insertPosition = enet_list_begin(&peer->outgoingReliableCommands);

        while (currentCommand != enet_list_end(&peer->sentReliableCommands)) {
            outgoingCommand = (ENetOutgoingCommand *) currentCommand;

            currentCommand = enet_list_next(currentCommand);

            if (ENET_TIME_DIFFERENCE(host->serviceTime, outgoingCommand->sentTime) < outgoingCommand->roundTripTimeout) {
                continue;
            }

            if (peer->earliestTimeout == 0 || ENET_TIME_LESS(outgoingCommand->sentTime, peer->earliestTimeout)) {
                peer->earliestTimeout = outgoingCommand->sentTime;
            }

            if (peer->earliestTimeout != 0 &&
                (ENET_TIME_DIFFERENCE(host->serviceTime, peer->earliestTimeout) >= peer->timeoutMaximum ||
                (outgoingCommand->roundTripTimeout >= outgoingCommand->roundTripTimeoutLimit &&
                ENET_TIME_DIFFERENCE(host->serviceTime, peer->earliestTimeout) >= peer->timeoutMinimum))
            ) {
                enet_protocol_notify_disconnect_timeout(host, peer, event);
                return 1;
            }

            if (outgoingCommand->packet != NULL) {
                peer->reliableDataInTransit -= outgoingCommand->fragmentLength;
            }

            ++peer->packetsLost;
            ++peer->totalPacketsLost;

            /* Replaced exponential backoff time with something more linear */
            /* Source: http://lists.cubik.org/pipermail/enet-discuss/2014-May/002308.html */
            outgoingCommand->roundTripTimeout = peer->roundTripTime + 4 * peer->roundTripTimeVariance;
            outgoingCommand->roundTripTimeoutLimit = peer->timeoutLimit * outgoingCommand->roundTripTimeout;

            enet_list_insert(insertPosition, enet_list_remove(&outgoingCommand->outgoingCommandList));

            if (currentCommand == enet_list_begin(&peer->sentReliableCommands) && !enet_list_empty(&peer->sentReliableCommands)) {
                outgoingCommand = (ENetOutgoingCommand *) currentCommand;
                peer->nextTimeout = outgoingCommand->sentTime + outgoingCommand->roundTripTimeout;
            }
        }

        return 0;
    } /* enet_protocol_check_timeouts */

    static int enet_protocol_send_reliable_outgoing_commands(ENetHost *host, ENetPeer *peer) {
        ENetProtocol *command = &host->commands[host->commandCount];
        ENetBuffer *buffer    = &host->buffers[host->bufferCount];
        ENetOutgoingCommand *outgoingCommand;
        ENetListIterator currentCommand;
        ENetChannel *channel;
        enet_uint16 reliableWindow;
        size_t commandSize;
        int windowExceeded = 0, windowWrap = 0, canPing = 1;

        currentCommand = enet_list_begin(&peer->outgoingReliableCommands);

        while (currentCommand != enet_list_end(&peer->outgoingReliableCommands)) {
            outgoingCommand = (ENetOutgoingCommand *) currentCommand;

            channel = outgoingCommand->command.header.channelID < peer->channelCount ? &peer->channels[outgoingCommand->command.header.channelID] : NULL;
            reliableWindow = outgoingCommand->reliableSequenceNumber / ENET_PEER_RELIABLE_WINDOW_SIZE;
            if (channel != NULL) {
                if (!windowWrap &&
                    outgoingCommand->sendAttempts < 1 &&
                    !(outgoingCommand->reliableSequenceNumber % ENET_PEER_RELIABLE_WINDOW_SIZE) &&
                    (channel->reliableWindows[(reliableWindow + ENET_PEER_RELIABLE_WINDOWS - 1)
                    % ENET_PEER_RELIABLE_WINDOWS] >= ENET_PEER_RELIABLE_WINDOW_SIZE ||
                    channel->usedReliableWindows & ((((1 << ENET_PEER_FREE_RELIABLE_WINDOWS) - 1) << reliableWindow)
                    | (((1 << ENET_PEER_FREE_RELIABLE_WINDOWS) - 1) >> (ENET_PEER_RELIABLE_WINDOWS - reliableWindow))))
                ) {
                    windowWrap = 1;
                }

                if (windowWrap) {
                    currentCommand = enet_list_next(currentCommand);
                    continue;
                }
            }

            if (outgoingCommand->packet != NULL) {
                if (!windowExceeded) {
                    enet_uint32 windowSize = (peer->packetThrottle * peer->windowSize) / ENET_PEER_PACKET_THROTTLE_SCALE;

                    if (peer->reliableDataInTransit + outgoingCommand->fragmentLength > ENET_MAX(windowSize, peer->mtu)) {
                        windowExceeded = 1;
                    }
                }
                if (windowExceeded) {
                    currentCommand = enet_list_next(currentCommand);

                    continue;
                }
            }

            canPing = 0;

            commandSize = commandSizes[outgoingCommand->command.header.command & ENET_PROTOCOL_COMMAND_MASK];
            if (command >= &host->commands[sizeof(host->commands) / sizeof(ENetProtocol)] ||
                buffer + 1 >= &host->buffers[sizeof(host->buffers) / sizeof(ENetBuffer)] ||
                peer->mtu - host->packetSize < commandSize ||
                (outgoingCommand->packet != NULL &&
                (enet_uint16) (peer->mtu - host->packetSize) < (enet_uint16) (commandSize + outgoingCommand->fragmentLength))
            ) {
                host->continueSending = 1;
                break;
            }

            currentCommand = enet_list_next(currentCommand);

            if (channel != NULL && outgoingCommand->sendAttempts < 1) {
                channel->usedReliableWindows |= 1 << reliableWindow;
                ++channel->reliableWindows[reliableWindow];
            }

            ++outgoingCommand->sendAttempts;

            if (outgoingCommand->roundTripTimeout == 0) {
                outgoingCommand->roundTripTimeout      = peer->roundTripTime + 4 * peer->roundTripTimeVariance;
                outgoingCommand->roundTripTimeoutLimit = peer->timeoutLimit * outgoingCommand->roundTripTimeout;
            }

            if (enet_list_empty(&peer->sentReliableCommands)) {
                peer->nextTimeout = host->serviceTime + outgoingCommand->roundTripTimeout;
            }

            enet_list_insert(enet_list_end(&peer->sentReliableCommands), enet_list_remove(&outgoingCommand->outgoingCommandList));

            outgoingCommand->sentTime = host->serviceTime;

            buffer->data       = command;
            buffer->dataLength = commandSize;

            host->packetSize  += buffer->dataLength;
            host->headerFlags |= ENET_PROTOCOL_HEADER_FLAG_SENT_TIME;

            *command = outgoingCommand->command;

            if (outgoingCommand->packet != NULL) {
                ++buffer;
                buffer->data       = outgoingCommand->packet->data + outgoingCommand->fragmentOffset;
                buffer->dataLength = outgoingCommand->fragmentLength;
                host->packetSize += outgoingCommand->fragmentLength;
                peer->reliableDataInTransit += outgoingCommand->fragmentLength;
            }

            ++peer->packetsSent;
            ++peer->totalPacketsSent;

            ++command;
            ++buffer;
        }

        host->commandCount = command - host->commands;
        host->bufferCount  = buffer - host->buffers;

        return canPing;
    } /* enet_protocol_send_reliable_outgoing_commands */

    static int enet_protocol_send_outgoing_commands(ENetHost *host, ENetEvent *event, int checkForTimeouts) {
        enet_uint8 headerData[sizeof(ENetProtocolHeader) + sizeof(enet_uint32)];
        ENetProtocolHeader *header = (ENetProtocolHeader *) headerData;
        ENetPeer *currentPeer;
        int sentLength;
        size_t shouldCompress = 0;
        host->continueSending = 1;

        while (host->continueSending)
            for (host->continueSending = 0, currentPeer = host->peers; currentPeer < &host->peers[host->peerCount]; ++currentPeer) {
                if (currentPeer->state == ENET_PEER_STATE_DISCONNECTED || currentPeer->state == ENET_PEER_STATE_ZOMBIE) {
                    continue;
                }

                host->headerFlags  = 0;
                host->commandCount = 0;
                host->bufferCount  = 1;
                host->packetSize   = sizeof(ENetProtocolHeader);

                if (!enet_list_empty(&currentPeer->acknowledgements)) {
                    enet_protocol_send_acknowledgements(host, currentPeer);
                }

                if (checkForTimeouts != 0 &&
                    !enet_list_empty(&currentPeer->sentReliableCommands) &&
                    ENET_TIME_GREATER_EQUAL(host->serviceTime, currentPeer->nextTimeout) &&
                    enet_protocol_check_timeouts(host, currentPeer, event) == 1
                ) {
                    if (event != NULL && event->type != ENET_EVENT_TYPE_NONE) {
                        return 1;
                    } else {
                        continue;
                    }
                }

                if ((enet_list_empty(&currentPeer->outgoingReliableCommands) ||
                    enet_protocol_send_reliable_outgoing_commands(host, currentPeer)) &&
                    enet_list_empty(&currentPeer->sentReliableCommands) &&
                    ENET_TIME_DIFFERENCE(host->serviceTime, currentPeer->lastReceiveTime) >= currentPeer->pingInterval &&
                    currentPeer->mtu - host->packetSize >= sizeof(ENetProtocolPing)
                ) {
                    enet_peer_ping(currentPeer);
                    enet_protocol_send_reliable_outgoing_commands(host, currentPeer);
                }

                if (!enet_list_empty(&currentPeer->outgoingUnreliableCommands)) {
                    enet_protocol_send_unreliable_outgoing_commands(host, currentPeer);
                }

                if (host->commandCount == 0) {
                    continue;
                }

                if (currentPeer->packetLossEpoch == 0) {
                    currentPeer->packetLossEpoch = host->serviceTime;
                } else if (ENET_TIME_DIFFERENCE(host->serviceTime, currentPeer->packetLossEpoch) >= ENET_PEER_PACKET_LOSS_INTERVAL && currentPeer->packetsSent > 0) {
                    enet_uint32 packetLoss = currentPeer->packetsLost * ENET_PEER_PACKET_LOSS_SCALE / currentPeer->packetsSent;

                    #ifdef ENET_DEBUG
                    printf(
                        "peer %u: %f%%+-%f%% packet loss, %u+-%u ms round trip time, %f%% throttle, %u/%u outgoing, %u/%u incoming\n", currentPeer->incomingPeerID,
                        currentPeer->packetLoss / (float) ENET_PEER_PACKET_LOSS_SCALE,
                        currentPeer->packetLossVariance / (float) ENET_PEER_PACKET_LOSS_SCALE, currentPeer->roundTripTime, currentPeer->roundTripTimeVariance,
                        currentPeer->packetThrottle / (float) ENET_PEER_PACKET_THROTTLE_SCALE,
                        enet_list_size(&currentPeer->outgoingReliableCommands),
                        enet_list_size(&currentPeer->outgoingUnreliableCommands),
                        currentPeer->channels != NULL ? enet_list_size( &currentPeer->channels->incomingReliableCommands) : 0,
                        currentPeer->channels != NULL ? enet_list_size(&currentPeer->channels->incomingUnreliableCommands) : 0
                    );
                    #endif

                    currentPeer->packetLossVariance -= currentPeer->packetLossVariance / 4;

                    if (packetLoss >= currentPeer->packetLoss) {
                        currentPeer->packetLoss         += (packetLoss - currentPeer->packetLoss) / 8;
                        currentPeer->packetLossVariance += (packetLoss - currentPeer->packetLoss) / 4;
                    } else {
                        currentPeer->packetLoss         -= (currentPeer->packetLoss - packetLoss) / 8;
                        currentPeer->packetLossVariance += (currentPeer->packetLoss - packetLoss) / 4;
                    }

                    currentPeer->packetLossEpoch = host->serviceTime;
                    currentPeer->packetsSent     = 0;
                    currentPeer->packetsLost     = 0;
                }

                host->buffers->data = headerData;
                if (host->headerFlags & ENET_PROTOCOL_HEADER_FLAG_SENT_TIME) {
                    header->sentTime = ENET_HOST_TO_NET_16(host->serviceTime & 0xFFFF);
                    host->buffers->dataLength = sizeof(ENetProtocolHeader);
                } else {
                    host->buffers->dataLength = (size_t) &((ENetProtocolHeader *) 0)->sentTime;
                }

                shouldCompress = 0;
                if (host->compressor.context != NULL && host->compressor.compress != NULL) {
                    size_t originalSize = host->packetSize - sizeof(ENetProtocolHeader),
                      compressedSize    = host->compressor.compress(host->compressor.context, &host->buffers[1], host->bufferCount - 1, originalSize, host->packetData[1], originalSize);
                    if (compressedSize > 0 && compressedSize < originalSize) {
                        host->headerFlags |= ENET_PROTOCOL_HEADER_FLAG_COMPRESSED;
                        shouldCompress     = compressedSize;
                        #ifdef ENET_DEBUG_COMPRESS
                        printf("peer %u: compressed %u->%u (%u%%)\n", currentPeer->incomingPeerID, originalSize, compressedSize, (compressedSize * 100) / originalSize);
                        #endif
                    }
                }

                if (currentPeer->outgoingPeerID < ENET_PROTOCOL_MAXIMUM_PEER_ID) {
                    host->headerFlags |= currentPeer->outgoingSessionID << ENET_PROTOCOL_HEADER_SESSION_SHIFT;
                }
                header->peerID = ENET_HOST_TO_NET_16(currentPeer->outgoingPeerID | host->headerFlags);
                if (host->checksum != NULL) {
                    enet_uint32 *checksum = (enet_uint32 *) &headerData[host->buffers->dataLength];
                    *checksum = currentPeer->outgoingPeerID < ENET_PROTOCOL_MAXIMUM_PEER_ID ? currentPeer->connectID : 0;
                    host->buffers->dataLength += sizeof(enet_uint32);
                    *checksum = host->checksum(host->buffers, host->bufferCount);
                }

                if (shouldCompress > 0) {
                    host->buffers[1].data       = host->packetData[1];
                    host->buffers[1].dataLength = shouldCompress;
                    host->bufferCount = 2;
                }

                currentPeer->lastSendTime = host->serviceTime;
                sentLength = enet_socket_send(host->socket, &currentPeer->address, host->buffers, host->bufferCount);
                enet_protocol_remove_sent_unreliable_commands(currentPeer);

                if (sentLength < 0) {
                    return -1;
                }

                host->totalSentData += sentLength;
                currentPeer->totalDataSent += sentLength;
                host->totalSentPackets++;
            }

        return 0;
    } /* enet_protocol_send_outgoing_commands */

    /** Sends any queued packets on the host specified to its designated peers.
     *
     *  @param host   host to flush
     *  @remarks this function need only be used in circumstances where one wishes to send queued packets earlier than in a call to enet_host_service().
     *  @ingroup host
     */
    void enet_host_flush(ENetHost *host) {
        host->serviceTime = enet_time_get();
        enet_protocol_send_outgoing_commands(host, NULL, 0);
    }

    /** Checks for any queued events on the host and dispatches one if available.
     *
     *  @param host    host to check for events
     *  @param event   an event structure where event details will be placed if available
     *  @retval > 0 if an event was dispatched
     *  @retval 0 if no events are available
     *  @retval < 0 on failure
     *  @ingroup host
     */
    int enet_host_check_events(ENetHost *host, ENetEvent *event) {
        if (event == NULL) { return -1; }

        event->type   = ENET_EVENT_TYPE_NONE;
        event->peer   = NULL;
        event->packet = NULL;

        return enet_protocol_dispatch_incoming_commands(host, event);
    }

    /** Waits for events on the host specified and shuttles packets between
     *  the host and its peers.
     *
     *  @param host    host to service
     *  @param event   an event structure where event details will be placed if one occurs
     *                 if event == NULL then no events will be delivered
     *  @param timeout number of milliseconds that ENet should wait for events
     *  @retval > 0 if an event occurred within the specified time limit
     *  @retval 0 if no event occurred
     *  @retval < 0 on failure
     *  @remarks enet_host_service should be called fairly regularly for adequate performance
     *  @ingroup host
     */
    int enet_host_service(ENetHost *host, ENetEvent *event, enet_uint32 timeout) {
        enet_uint32 waitCondition;

        if (event != NULL) {
            event->type   = ENET_EVENT_TYPE_NONE;
            event->peer   = NULL;
            event->packet = NULL;

            switch (enet_protocol_dispatch_incoming_commands(host, event)) {
                case 1:
                    return 1;

                case -1:
                    #ifdef ENET_DEBUG
                    perror("Error dispatching incoming packets");
                    #endif

                    return -1;

                default:
                    break;
            }
        }

        host->serviceTime = enet_time_get();
        timeout += host->serviceTime;

        do {
            if (ENET_TIME_DIFFERENCE(host->serviceTime, host->bandwidthThrottleEpoch) >= ENET_HOST_BANDWIDTH_THROTTLE_INTERVAL) {
                enet_host_bandwidth_throttle(host);
            }

            switch (enet_protocol_send_outgoing_commands(host, event, 1)) {
                case 1:
                    return 1;

                case -1:
                    #ifdef ENET_DEBUG
                    perror("Error sending outgoing packets");
                    #endif

                    return -1;

                default:
                    break;
            }

            switch (enet_protocol_receive_incoming_commands(host, event)) {
                case 1:
                    return 1;

                case -1:
                    #ifdef ENET_DEBUG
                    perror("Error receiving incoming packets");
                    #endif

                    return -1;

                default:
                    break;
            }

            switch (enet_protocol_send_outgoing_commands(host, event, 1)) {
                case 1:
                    return 1;

                case -1:
                    #ifdef ENET_DEBUG
                    perror("Error sending outgoing packets");
                    #endif

                    return -1;

                default:
                    break;
            }

            if (event != NULL) {
                switch (enet_protocol_dispatch_incoming_commands(host, event)) {
                    case 1:
                        return 1;

                    case -1:
                        #ifdef ENET_DEBUG
                        perror("Error dispatching incoming packets");
                        #endif

                        return -1;

                    default:
                        break;
                }
            }

            if (ENET_TIME_GREATER_EQUAL(host->serviceTime, timeout)) {
                return 0;
            }

            do {
                host->serviceTime = enet_time_get();

                if (ENET_TIME_GREATER_EQUAL(host->serviceTime, timeout)) {
                    return 0;
                }

                waitCondition = ENET_SOCKET_WAIT_RECEIVE | ENET_SOCKET_WAIT_INTERRUPT;
                if (enet_socket_wait(host->socket, &waitCondition, ENET_TIME_DIFFERENCE(timeout, host->serviceTime)) != 0) {
                    return -1;
                }
            } while (waitCondition & ENET_SOCKET_WAIT_INTERRUPT);

            host->serviceTime = enet_time_get();
        } while (waitCondition & ENET_SOCKET_WAIT_RECEIVE);

        return 0;
    } /* enet_host_service */


// =======================================================================//
// !
// ! Peer
// !
// =======================================================================//

    /** Configures throttle parameter for a peer.
     *
     *  Unreliable packets are dropped by ENet in response to the varying conditions
     *  of the Internet connection to the peer.  The throttle represents a probability
     *  that an unreliable packet should not be dropped and thus sent by ENet to the peer.
     *  The lowest mean round trip time from the sending of a reliable packet to the
     *  receipt of its acknowledgement is measured over an amount of time specified by
     *  the interval parameter in milliseconds.  If a measured round trip time happens to
     *  be significantly less than the mean round trip time measured over the interval,
     *  then the throttle probability is increased to allow more traffic by an amount
     *  specified in the acceleration parameter, which is a ratio to the ENET_PEER_PACKET_THROTTLE_SCALE
     *  constant.  If a measured round trip time happens to be significantly greater than
     *  the mean round trip time measured over the interval, then the throttle probability
     *  is decreased to limit traffic by an amount specified in the deceleration parameter, which
     *  is a ratio to the ENET_PEER_PACKET_THROTTLE_SCALE constant.  When the throttle has
     *  a value of ENET_PEER_PACKET_THROTTLE_SCALE, no unreliable packets are dropped by
     *  ENet, and so 100% of all unreliable packets will be sent.  When the throttle has a
     *  value of 0, all unreliable packets are dropped by ENet, and so 0% of all unreliable
     *  packets will be sent.  Intermediate values for the throttle represent intermediate
     *  probabilities between 0% and 100% of unreliable packets being sent.  The bandwidth
     *  limits of the local and foreign hosts are taken into account to determine a
     *  sensible limit for the throttle probability above which it should not raise even in
     *  the best of conditions.
     *
     *  @param peer peer to configure
     *  @param interval interval, in milliseconds, over which to measure lowest mean RTT; the default value is ENET_PEER_PACKET_THROTTLE_INTERVAL.
     *  @param acceleration rate at which to increase the throttle probability as mean RTT declines
     *  @param deceleration rate at which to decrease the throttle probability as mean RTT increases
     */
    void enet_peer_throttle_configure(ENetPeer *peer, enet_uint32 interval, enet_uint32 acceleration, enet_uint32 deceleration) {
        ENetProtocol command;

        peer->packetThrottleInterval     = interval;
        peer->packetThrottleAcceleration = acceleration;
        peer->packetThrottleDeceleration = deceleration;

        command.header.command   = ENET_PROTOCOL_COMMAND_THROTTLE_CONFIGURE | ENET_PROTOCOL_COMMAND_FLAG_ACKNOWLEDGE;
        command.header.channelID = 0xFF;

        command.throttleConfigure.packetThrottleInterval     = ENET_HOST_TO_NET_32(interval);
        command.throttleConfigure.packetThrottleAcceleration = ENET_HOST_TO_NET_32(acceleration);
        command.throttleConfigure.packetThrottleDeceleration = ENET_HOST_TO_NET_32(deceleration);

        enet_peer_queue_outgoing_command(peer, &command, NULL, 0, 0);
    }

    int enet_peer_throttle(ENetPeer *peer, enet_uint32 rtt) {
        if (peer->lastRoundTripTime <= peer->lastRoundTripTimeVariance) {
            peer->packetThrottle = peer->packetThrottleLimit;
        }
        else if (rtt < peer->lastRoundTripTime) {
            peer->packetThrottle += peer->packetThrottleAcceleration;

            if (peer->packetThrottle > peer->packetThrottleLimit) {
                peer->packetThrottle = peer->packetThrottleLimit;
            }

            return 1;
        }
        else if (rtt > peer->lastRoundTripTime + 2 * peer->lastRoundTripTimeVariance) {
            if (peer->packetThrottle > peer->packetThrottleDeceleration) {
                peer->packetThrottle -= peer->packetThrottleDeceleration;
            } else {
                peer->packetThrottle = 0;
            }

            return -1;
        }

        return 0;
    }

    /* Extended functionality for easier binding in other programming languages */
    enet_uint32 enet_host_get_peers_count(ENetHost *host) {
        return host->connectedPeers;
    }

    enet_uint32 enet_host_get_packets_sent(ENetHost *host) {
        return host->totalSentPackets;
    }

    enet_uint32 enet_host_get_packets_received(ENetHost *host) {
        return host->totalReceivedPackets;
    }

    enet_uint32 enet_host_get_bytes_sent(ENetHost *host) {
        return host->totalSentData;
    }

    enet_uint32 enet_host_get_bytes_received(ENetHost *host) {
        return host->totalReceivedData;
    }

    /** Gets received data buffer. Returns buffer length.
     *  @param host host to access recevie buffer
     *  @param data ouput parameter for recevied data
     *  @retval buffer length
     */
    enet_uint32 enet_host_get_received_data(ENetHost *host, /*out*/ enet_uint8** data) {
        *data = host->receivedData;
        return host->receivedDataLength;
    }

    enet_uint32 enet_host_get_mtu(ENetHost *host) {
        return host->mtu;
    }

    enet_uint32 enet_peer_get_id(ENetPeer *peer) {
        return peer->connectID;
    }

    enet_uint32 enet_peer_get_ip(ENetPeer *peer, char *ip, size_t ipLength) {
        return enet_address_get_host_ip(&peer->address, ip, ipLength);
    }

    enet_uint16 enet_peer_get_port(ENetPeer *peer) {
        return peer->address.port;
    }

    ENetPeerState enet_peer_get_state(ENetPeer *peer) {
        return peer->state;
    }

    enet_uint32 enet_peer_get_rtt(ENetPeer *peer) {
        return peer->roundTripTime;
    }

    enet_uint64 enet_peer_get_packets_sent(ENetPeer *peer) {
        return peer->totalPacketsSent;
    }

    enet_uint32 enet_peer_get_packets_lost(ENetPeer *peer) {
        return peer->totalPacketsLost;
    }

    enet_uint64 enet_peer_get_bytes_sent(ENetPeer *peer) {
        return peer->totalDataSent;
    }

    enet_uint64 enet_peer_get_bytes_received(ENetPeer *peer) {
        return peer->totalDataReceived;
    }

    void * enet_peer_get_data(ENetPeer *peer) {
        return (void *) peer->data;
    }

    void enet_peer_set_data(ENetPeer *peer, const void *data) {
        peer->data = (enet_uint32 *) data;
    }

    void * enet_packet_get_data(ENetPacket *packet) {
        return (void *) packet->data;
    }

    enet_uint32 enet_packet_get_length(ENetPacket *packet) {
        return packet->dataLength;
    }

    void enet_packet_set_free_callback(ENetPacket *packet, void *callback) {
        packet->freeCallback = (ENetPacketFreeCallback)callback;
    }

    /** Queues a packet to be sent.
     *  @param peer destination for the packet
     *  @param channelID channel on which to send
     *  @param packet packet to send
     *  @retval 0 on success
     *  @retval < 0 on failure
     */
    int enet_peer_send(ENetPeer *peer, enet_uint8 channelID, ENetPacket *packet) {
        ENetChannel *channel = &peer->channels[channelID];
        ENetProtocol command;
        size_t fragmentLength;

        if (peer->state != ENET_PEER_STATE_CONNECTED || channelID >= peer->channelCount || packet->dataLength > peer->host->maximumPacketSize) {
            return -1;
        }

        fragmentLength = peer->mtu - sizeof(ENetProtocolHeader) - sizeof(ENetProtocolSendFragment);
        if (peer->host->checksum != NULL) {
            fragmentLength -= sizeof(enet_uint32);
        }

        if (packet->dataLength > fragmentLength) {
            enet_uint32 fragmentCount = (packet->dataLength + fragmentLength - 1) / fragmentLength, fragmentNumber, fragmentOffset;
            enet_uint8 commandNumber;
            enet_uint16 startSequenceNumber;
            ENetList fragments;
            ENetOutgoingCommand *fragment;

            if (fragmentCount > ENET_PROTOCOL_MAXIMUM_FRAGMENT_COUNT) {
                return -1;
            }

            if ((packet->flags & (ENET_PACKET_FLAG_RELIABLE | ENET_PACKET_FLAG_UNRELIABLE_FRAGMENT)) ==
                ENET_PACKET_FLAG_UNRELIABLE_FRAGMENT &&
                channel->outgoingUnreliableSequenceNumber < 0xFFFF)
            {
                commandNumber       = ENET_PROTOCOL_COMMAND_SEND_UNRELIABLE_FRAGMENT;
                startSequenceNumber = ENET_HOST_TO_NET_16(channel->outgoingUnreliableSequenceNumber + 1);
            } else {
                commandNumber       = ENET_PROTOCOL_COMMAND_SEND_FRAGMENT | ENET_PROTOCOL_COMMAND_FLAG_ACKNOWLEDGE;
                startSequenceNumber = ENET_HOST_TO_NET_16(channel->outgoingReliableSequenceNumber + 1);
            }

            enet_list_clear(&fragments);

            for (fragmentNumber = 0, fragmentOffset = 0; fragmentOffset < packet->dataLength; ++fragmentNumber, fragmentOffset += fragmentLength) {
                if (packet->dataLength - fragmentOffset < fragmentLength) {
                    fragmentLength = packet->dataLength - fragmentOffset;
                }

                fragment = (ENetOutgoingCommand *) enet_malloc(sizeof(ENetOutgoingCommand));

                if (fragment == NULL) {
                    while (!enet_list_empty(&fragments)) {
                        fragment = (ENetOutgoingCommand *) enet_list_remove(enet_list_begin(&fragments));

                        enet_free(fragment);
                    }

                    return -1;
                }

                fragment->fragmentOffset           = fragmentOffset;
                fragment->fragmentLength           = fragmentLength;
                fragment->packet                   = packet;
                fragment->command.header.command   = commandNumber;
                fragment->command.header.channelID = channelID;

                fragment->command.sendFragment.startSequenceNumber = startSequenceNumber;

                fragment->command.sendFragment.dataLength     = ENET_HOST_TO_NET_16(fragmentLength);
                fragment->command.sendFragment.fragmentCount  = ENET_HOST_TO_NET_32(fragmentCount);
                fragment->command.sendFragment.fragmentNumber = ENET_HOST_TO_NET_32(fragmentNumber);
                fragment->command.sendFragment.totalLength    = ENET_HOST_TO_NET_32(packet->dataLength);
                fragment->command.sendFragment.fragmentOffset = ENET_NET_TO_HOST_32(fragmentOffset);

                enet_list_insert(enet_list_end(&fragments), fragment);
            }

            packet->referenceCount += fragmentNumber;

            while (!enet_list_empty(&fragments)) {
                fragment = (ENetOutgoingCommand *) enet_list_remove(enet_list_begin(&fragments));
                enet_peer_setup_outgoing_command(peer, fragment);
            }

            return 0;
        }

        command.header.channelID = channelID;

        if ((packet->flags & (ENET_PACKET_FLAG_RELIABLE | ENET_PACKET_FLAG_UNSEQUENCED)) == ENET_PACKET_FLAG_UNSEQUENCED) {
            command.header.command = ENET_PROTOCOL_COMMAND_SEND_UNSEQUENCED | ENET_PROTOCOL_COMMAND_FLAG_UNSEQUENCED;
            command.sendUnsequenced.dataLength = ENET_HOST_TO_NET_16(packet->dataLength);
        }
        else if (packet->flags & ENET_PACKET_FLAG_RELIABLE || channel->outgoingUnreliableSequenceNumber >= 0xFFFF) {
            command.header.command = ENET_PROTOCOL_COMMAND_SEND_RELIABLE | ENET_PROTOCOL_COMMAND_FLAG_ACKNOWLEDGE;
            command.sendReliable.dataLength = ENET_HOST_TO_NET_16(packet->dataLength);
        }
        else {
            command.header.command = ENET_PROTOCOL_COMMAND_SEND_UNRELIABLE;
            command.sendUnreliable.dataLength = ENET_HOST_TO_NET_16(packet->dataLength);
        }

        if (enet_peer_queue_outgoing_command(peer, &command, packet, 0, packet->dataLength) == NULL) {
            return -1;
        }

        return 0;
    } // enet_peer_send

    /** Attempts to dequeue any incoming queued packet.
     *  @param peer peer to dequeue packets from
     *  @param channelID holds the channel ID of the channel the packet was received on success
     *  @returns a pointer to the packet, or NULL if there are no available incoming queued packets
     */
    ENetPacket * enet_peer_receive(ENetPeer *peer, enet_uint8 *channelID) {
        ENetIncomingCommand *incomingCommand;
        ENetPacket *packet;

        if (enet_list_empty(&peer->dispatchedCommands)) {
            return NULL;
        }

        incomingCommand = (ENetIncomingCommand *) enet_list_remove(enet_list_begin(&peer->dispatchedCommands));

        if (channelID != NULL) {
            *channelID = incomingCommand->command.header.channelID;
        }

        packet = incomingCommand->packet;
        --packet->referenceCount;

        if (incomingCommand->fragments != NULL) {
            enet_free(incomingCommand->fragments);
        }

        enet_free(incomingCommand);
        peer->totalWaitingData -= packet->dataLength;

        return packet;
    }

    static void enet_peer_reset_outgoing_commands(ENetList *queue) {
        ENetOutgoingCommand *outgoingCommand;

        while (!enet_list_empty(queue)) {
            outgoingCommand = (ENetOutgoingCommand *) enet_list_remove(enet_list_begin(queue));

            if (outgoingCommand->packet != NULL) {
                --outgoingCommand->packet->referenceCount;

                if (outgoingCommand->packet->referenceCount == 0) {
                    callbacks.packet_destroy(outgoingCommand->packet);
                }
            }

            enet_free(outgoingCommand);
        }
    }

    static void enet_peer_remove_incoming_commands(ENetList *queue, ENetListIterator startCommand, ENetListIterator endCommand) {
        ENET_UNUSED(queue)

        ENetListIterator currentCommand;

        for (currentCommand = startCommand; currentCommand != endCommand;) {
            ENetIncomingCommand *incomingCommand = (ENetIncomingCommand *) currentCommand;

            currentCommand = enet_list_next(currentCommand);
            enet_list_remove(&incomingCommand->incomingCommandList);

            if (incomingCommand->packet != NULL) {
                --incomingCommand->packet->referenceCount;

                if (incomingCommand->packet->referenceCount == 0) {
                    callbacks.packet_destroy(incomingCommand->packet);
                }
            }

            if (incomingCommand->fragments != NULL) {
                enet_free(incomingCommand->fragments);
            }

            enet_free(incomingCommand);
        }
    }

    static void enet_peer_reset_incoming_commands(ENetList *queue) {
        enet_peer_remove_incoming_commands(queue, enet_list_begin(queue), enet_list_end(queue));
    }

    void enet_peer_reset_queues(ENetPeer *peer) {
        ENetChannel *channel;

        if (peer->needsDispatch) {
            enet_list_remove(&peer->dispatchList);
            peer->needsDispatch = 0;
        }

        while (!enet_list_empty(&peer->acknowledgements)) {
            enet_free(enet_list_remove(enet_list_begin(&peer->acknowledgements)));
        }

        enet_peer_reset_outgoing_commands(&peer->sentReliableCommands);
        enet_peer_reset_outgoing_commands(&peer->sentUnreliableCommands);
        enet_peer_reset_outgoing_commands(&peer->outgoingReliableCommands);
        enet_peer_reset_outgoing_commands(&peer->outgoingUnreliableCommands);
        enet_peer_reset_incoming_commands(&peer->dispatchedCommands);

        if (peer->channels != NULL && peer->channelCount > 0) {
            for (channel = peer->channels; channel < &peer->channels[peer->channelCount]; ++channel) {
                enet_peer_reset_incoming_commands(&channel->incomingReliableCommands);
                enet_peer_reset_incoming_commands(&channel->incomingUnreliableCommands);
            }

            enet_free(peer->channels);
        }

        peer->channels     = NULL;
        peer->channelCount = 0;
    }

    void enet_peer_on_connect(ENetPeer *peer) {
        if (peer->state != ENET_PEER_STATE_CONNECTED && peer->state != ENET_PEER_STATE_DISCONNECT_LATER) {
            if (peer->incomingBandwidth != 0) {
                ++peer->host->bandwidthLimitedPeers;
            }

            ++peer->host->connectedPeers;
        }
    }

    void enet_peer_on_disconnect(ENetPeer *peer) {
        if (peer->state == ENET_PEER_STATE_CONNECTED || peer->state == ENET_PEER_STATE_DISCONNECT_LATER) {
            if (peer->incomingBandwidth != 0) {
                --peer->host->bandwidthLimitedPeers;
            }

            --peer->host->connectedPeers;
        }
    }

    /** Forcefully disconnects a peer.
     *  @param peer peer to forcefully disconnect
     *  @remarks The foreign host represented by the peer is not notified of the disconnection and will timeout
     *  on its connection to the local host.
     */
    void enet_peer_reset(ENetPeer *peer) {
        enet_peer_on_disconnect(peer);

        // We don't want to reset connectID here, otherwise, we can't get it in the Disconnect event
        // peer->connectID                     = 0;
        peer->outgoingPeerID                = ENET_PROTOCOL_MAXIMUM_PEER_ID;
        peer->state                         = ENET_PEER_STATE_DISCONNECTED;
        peer->incomingBandwidth             = 0;
        peer->outgoingBandwidth             = 0;
        peer->incomingBandwidthThrottleEpoch = 0;
        peer->outgoingBandwidthThrottleEpoch = 0;
        peer->incomingDataTotal             = 0;
        peer->totalDataReceived             = 0;
        peer->outgoingDataTotal             = 0;
        peer->totalDataSent                 = 0;
        peer->lastSendTime                  = 0;
        peer->lastReceiveTime               = 0;
        peer->nextTimeout                   = 0;
        peer->earliestTimeout               = 0;
        peer->packetLossEpoch               = 0;
        peer->packetsSent                   = 0;
        peer->totalPacketsSent              = 0;
        peer->packetsLost                   = 0;
        peer->totalPacketsLost              = 0;
        peer->packetLoss                    = 0;
        peer->packetLossVariance            = 0;
        peer->packetThrottle                = ENET_PEER_DEFAULT_PACKET_THROTTLE;
        peer->packetThrottleLimit           = ENET_PEER_PACKET_THROTTLE_SCALE;
        peer->packetThrottleCounter         = 0;
        peer->packetThrottleEpoch           = 0;
        peer->packetThrottleAcceleration    = ENET_PEER_PACKET_THROTTLE_ACCELERATION;
        peer->packetThrottleDeceleration    = ENET_PEER_PACKET_THROTTLE_DECELERATION;
        peer->packetThrottleInterval        = ENET_PEER_PACKET_THROTTLE_INTERVAL;
        peer->pingInterval                  = ENET_PEER_PING_INTERVAL;
        peer->timeoutLimit                  = ENET_PEER_TIMEOUT_LIMIT;
        peer->timeoutMinimum                = ENET_PEER_TIMEOUT_MINIMUM;
        peer->timeoutMaximum                = ENET_PEER_TIMEOUT_MAXIMUM;
        peer->lastRoundTripTime             = ENET_PEER_DEFAULT_ROUND_TRIP_TIME;
        peer->lowestRoundTripTime           = ENET_PEER_DEFAULT_ROUND_TRIP_TIME;
        peer->lastRoundTripTimeVariance     = 0;
        peer->highestRoundTripTimeVariance  = 0;
        peer->roundTripTime                 = ENET_PEER_DEFAULT_ROUND_TRIP_TIME;
        peer->roundTripTimeVariance         = 0;
        peer->mtu                           = peer->host->mtu;
        peer->reliableDataInTransit         = 0;
        peer->outgoingReliableSequenceNumber = 0;
        peer->windowSize                    = ENET_PROTOCOL_MAXIMUM_WINDOW_SIZE;
        peer->incomingUnsequencedGroup      = 0;
        peer->outgoingUnsequencedGroup      = 0;
        peer->eventData                     = 0;
        peer->totalWaitingData              = 0;

        memset(peer->unsequencedWindow, 0, sizeof(peer->unsequencedWindow));
        enet_peer_reset_queues(peer);
    }

    /** Sends a ping request to a peer.
     *  @param peer destination for the ping request
     *  @remarks ping requests factor into the mean round trip time as designated by the
     *  roundTripTime field in the ENetPeer structure.  ENet automatically pings all connected
     *  peers at regular intervals, however, this function may be called to ensure more
     *  frequent ping requests.
     */
    void enet_peer_ping(ENetPeer *peer) {
        ENetProtocol command;

        if (peer->state != ENET_PEER_STATE_CONNECTED) {
            return;
        }

        command.header.command   = ENET_PROTOCOL_COMMAND_PING | ENET_PROTOCOL_COMMAND_FLAG_ACKNOWLEDGE;
        command.header.channelID = 0xFF;

        enet_peer_queue_outgoing_command(peer, &command, NULL, 0, 0);
    }

    /** Sets the interval at which pings will be sent to a peer.
     *
     *  Pings are used both to monitor the liveness of the connection and also to dynamically
     *  adjust the throttle during periods of low traffic so that the throttle has reasonable
     *  responsiveness during traffic spikes.
     *
     *  @param peer the peer to adjust
     *  @param pingInterval the interval at which to send pings; defaults to ENET_PEER_PING_INTERVAL if 0
     */
    void enet_peer_ping_interval(ENetPeer *peer, enet_uint32 pingInterval) {
        peer->pingInterval = pingInterval ? pingInterval : ENET_PEER_PING_INTERVAL;
    }

    /** Sets the timeout parameters for a peer.
     *
     *  The timeout parameter control how and when a peer will timeout from a failure to acknowledge
     *  reliable traffic. Timeout values use an exponential backoff mechanism, where if a reliable
     *  packet is not acknowledge within some multiple of the average RTT plus a variance tolerance,
     *  the timeout will be doubled until it reaches a set limit. If the timeout is thus at this
     *  limit and reliable packets have been sent but not acknowledged within a certain minimum time
     *  period, the peer will be disconnected. Alternatively, if reliable packets have been sent
     *  but not acknowledged for a certain maximum time period, the peer will be disconnected regardless
     *  of the current timeout limit value.
     *
     *  @param peer the peer to adjust
     *  @param timeoutLimit the timeout limit; defaults to ENET_PEER_TIMEOUT_LIMIT if 0
     *  @param timeoutMinimum the timeout minimum; defaults to ENET_PEER_TIMEOUT_MINIMUM if 0
     *  @param timeoutMaximum the timeout maximum; defaults to ENET_PEER_TIMEOUT_MAXIMUM if 0
     */

    void enet_peer_timeout(ENetPeer *peer, enet_uint32 timeoutLimit, enet_uint32 timeoutMinimum, enet_uint32 timeoutMaximum) {
        peer->timeoutLimit   = timeoutLimit ? timeoutLimit : ENET_PEER_TIMEOUT_LIMIT;
        peer->timeoutMinimum = timeoutMinimum ? timeoutMinimum : ENET_PEER_TIMEOUT_MINIMUM;
        peer->timeoutMaximum = timeoutMaximum ? timeoutMaximum : ENET_PEER_TIMEOUT_MAXIMUM;
    }

    /** Force an immediate disconnection from a peer.
     *  @param peer peer to disconnect
     *  @param data data describing the disconnection
     *  @remarks No ENET_EVENT_DISCONNECT event will be generated. The foreign peer is not
     *  guaranteed to receive the disconnect notification, and is reset immediately upon
     *  return from this function.
     */
    void enet_peer_disconnect_now(ENetPeer *peer, enet_uint32 data) {
        ENetProtocol command;

        if (peer->state == ENET_PEER_STATE_DISCONNECTED) {
            return;
        }

        if (peer->state != ENET_PEER_STATE_ZOMBIE && peer->state != ENET_PEER_STATE_DISCONNECTING) {
            enet_peer_reset_queues(peer);

            command.header.command   = ENET_PROTOCOL_COMMAND_DISCONNECT | ENET_PROTOCOL_COMMAND_FLAG_UNSEQUENCED;
            command.header.channelID = 0xFF;
            command.disconnect.data  = ENET_HOST_TO_NET_32(data);

            enet_peer_queue_outgoing_command(peer, &command, NULL, 0, 0);
            enet_host_flush(peer->host);
        }

        enet_peer_reset(peer);
    }

    /** Request a disconnection from a peer.
     *  @param peer peer to request a disconnection
     *  @param data data describing the disconnection
     *  @remarks An ENET_EVENT_DISCONNECT event will be generated by enet_host_service()
     *  once the disconnection is complete.
     */
    void enet_peer_disconnect(ENetPeer *peer, enet_uint32 data) {
        ENetProtocol command;

        if (peer->state == ENET_PEER_STATE_DISCONNECTING ||
            peer->state == ENET_PEER_STATE_DISCONNECTED ||
            peer->state == ENET_PEER_STATE_ACKNOWLEDGING_DISCONNECT ||
            peer->state == ENET_PEER_STATE_ZOMBIE
        ) {
            return;
        }

        enet_peer_reset_queues(peer);

        command.header.command   = ENET_PROTOCOL_COMMAND_DISCONNECT;
        command.header.channelID = 0xFF;
        command.disconnect.data  = ENET_HOST_TO_NET_32(data);

        if (peer->state == ENET_PEER_STATE_CONNECTED || peer->state == ENET_PEER_STATE_DISCONNECT_LATER) {
            command.header.command |= ENET_PROTOCOL_COMMAND_FLAG_ACKNOWLEDGE;
        } else {
            command.header.command |= ENET_PROTOCOL_COMMAND_FLAG_UNSEQUENCED;
        }

        enet_peer_queue_outgoing_command(peer, &command, NULL, 0, 0);

        if (peer->state == ENET_PEER_STATE_CONNECTED || peer->state == ENET_PEER_STATE_DISCONNECT_LATER) {
            enet_peer_on_disconnect(peer);

            peer->state = ENET_PEER_STATE_DISCONNECTING;
        } else {
            enet_host_flush(peer->host);
            enet_peer_reset(peer);
        }
    }

    /** Request a disconnection from a peer, but only after all queued outgoing packets are sent.
     *  @param peer peer to request a disconnection
     *  @param data data describing the disconnection
     *  @remarks An ENET_EVENT_DISCONNECT event will be generated by enet_host_service()
     *  once the disconnection is complete.
     */
    void enet_peer_disconnect_later(ENetPeer *peer, enet_uint32 data) {
        if ((peer->state == ENET_PEER_STATE_CONNECTED || peer->state == ENET_PEER_STATE_DISCONNECT_LATER) &&
            !(enet_list_empty(&peer->outgoingReliableCommands) &&
            enet_list_empty(&peer->outgoingUnreliableCommands) &&
            enet_list_empty(&peer->sentReliableCommands))
        ) {
            peer->state     = ENET_PEER_STATE_DISCONNECT_LATER;
            peer->eventData = data;
        } else {
            enet_peer_disconnect(peer, data);
        }
    }

    ENetAcknowledgement *enet_peer_queue_acknowledgement(ENetPeer *peer, const ENetProtocol *command, enet_uint16 sentTime) {
        ENetAcknowledgement *acknowledgement;

        if (command->header.channelID < peer->channelCount) {
            ENetChannel *channel       = &peer->channels[command->header.channelID];
            enet_uint16 reliableWindow = command->header.reliableSequenceNumber / ENET_PEER_RELIABLE_WINDOW_SIZE;
            enet_uint16 currentWindow  = channel->incomingReliableSequenceNumber / ENET_PEER_RELIABLE_WINDOW_SIZE;

            if (command->header.reliableSequenceNumber < channel->incomingReliableSequenceNumber) {
                reliableWindow += ENET_PEER_RELIABLE_WINDOWS;
            }

            if (reliableWindow >= currentWindow + ENET_PEER_FREE_RELIABLE_WINDOWS - 1 && reliableWindow <= currentWindow + ENET_PEER_FREE_RELIABLE_WINDOWS) {
                return NULL;
            }
        }

        acknowledgement = (ENetAcknowledgement *) enet_malloc(sizeof(ENetAcknowledgement));
        if (acknowledgement == NULL) {
            return NULL;
        }

        peer->outgoingDataTotal += sizeof(ENetProtocolAcknowledge);

        acknowledgement->sentTime = sentTime;
        acknowledgement->command  = *command;

        enet_list_insert(enet_list_end(&peer->acknowledgements), acknowledgement);
        return acknowledgement;
    }

    void enet_peer_setup_outgoing_command(ENetPeer *peer, ENetOutgoingCommand *outgoingCommand) {
        ENetChannel *channel = &peer->channels[outgoingCommand->command.header.channelID];
        peer->outgoingDataTotal += enet_protocol_command_size(outgoingCommand->command.header.command) + outgoingCommand->fragmentLength;

        if (outgoingCommand->command.header.channelID == 0xFF) {
            ++peer->outgoingReliableSequenceNumber;

            outgoingCommand->reliableSequenceNumber   = peer->outgoingReliableSequenceNumber;
            outgoingCommand->unreliableSequenceNumber = 0;
        }
        else if (outgoingCommand->command.header.command & ENET_PROTOCOL_COMMAND_FLAG_ACKNOWLEDGE) {
            ++channel->outgoingReliableSequenceNumber;
            channel->outgoingUnreliableSequenceNumber = 0;

            outgoingCommand->reliableSequenceNumber   = channel->outgoingReliableSequenceNumber;
            outgoingCommand->unreliableSequenceNumber = 0;
        }
        else if (outgoingCommand->command.header.command & ENET_PROTOCOL_COMMAND_FLAG_UNSEQUENCED) {
            ++peer->outgoingUnsequencedGroup;

            outgoingCommand->reliableSequenceNumber   = 0;
            outgoingCommand->unreliableSequenceNumber = 0;
        }
        else {
            if (outgoingCommand->fragmentOffset == 0) {
                ++channel->outgoingUnreliableSequenceNumber;
            }

            outgoingCommand->reliableSequenceNumber   = channel->outgoingReliableSequenceNumber;
            outgoingCommand->unreliableSequenceNumber = channel->outgoingUnreliableSequenceNumber;
        }

        outgoingCommand->sendAttempts          = 0;
        outgoingCommand->sentTime              = 0;
        outgoingCommand->roundTripTimeout      = 0;
        outgoingCommand->roundTripTimeoutLimit = 0;
        outgoingCommand->command.header.reliableSequenceNumber = ENET_HOST_TO_NET_16(outgoingCommand->reliableSequenceNumber);

        switch (outgoingCommand->command.header.command & ENET_PROTOCOL_COMMAND_MASK) {
            case ENET_PROTOCOL_COMMAND_SEND_UNRELIABLE:
                outgoingCommand->command.sendUnreliable.unreliableSequenceNumber = ENET_HOST_TO_NET_16(outgoingCommand->unreliableSequenceNumber);
                break;

            case ENET_PROTOCOL_COMMAND_SEND_UNSEQUENCED:
                outgoingCommand->command.sendUnsequenced.unsequencedGroup = ENET_HOST_TO_NET_16(peer->outgoingUnsequencedGroup);
                break;

            default:
                break;
        }

        if (outgoingCommand->command.header.command & ENET_PROTOCOL_COMMAND_FLAG_ACKNOWLEDGE) {
            enet_list_insert(enet_list_end(&peer->outgoingReliableCommands), outgoingCommand);
        } else {
            enet_list_insert(enet_list_end(&peer->outgoingUnreliableCommands), outgoingCommand);
        }
    }

    ENetOutgoingCommand * enet_peer_queue_outgoing_command(ENetPeer *peer, const ENetProtocol *command, ENetPacket *packet, enet_uint32 offset, enet_uint16 length) {
        ENetOutgoingCommand *outgoingCommand = (ENetOutgoingCommand *) enet_malloc(sizeof(ENetOutgoingCommand));

        if (outgoingCommand == NULL) {
            return NULL;
        }

        outgoingCommand->command        = *command;
        outgoingCommand->fragmentOffset = offset;
        outgoingCommand->fragmentLength = length;
        outgoingCommand->packet         = packet;
        if (packet != NULL) {
            ++packet->referenceCount;
        }

        enet_peer_setup_outgoing_command(peer, outgoingCommand);
        return outgoingCommand;
    }

    void enet_peer_dispatch_incoming_unreliable_commands(ENetPeer *peer, ENetChannel *channel) {
        ENetListIterator droppedCommand, startCommand, currentCommand;

        for (droppedCommand = startCommand = currentCommand = enet_list_begin(&channel->incomingUnreliableCommands);
            currentCommand != enet_list_end(&channel->incomingUnreliableCommands);
            currentCommand = enet_list_next(currentCommand)
        ) {
            ENetIncomingCommand *incomingCommand = (ENetIncomingCommand *) currentCommand;

            if ((incomingCommand->command.header.command & ENET_PROTOCOL_COMMAND_MASK) == ENET_PROTOCOL_COMMAND_SEND_UNSEQUENCED) {
                continue;
            }

            if (incomingCommand->reliableSequenceNumber == channel->incomingReliableSequenceNumber) {
                if (incomingCommand->fragmentsRemaining <= 0) {
                    channel->incomingUnreliableSequenceNumber = incomingCommand->unreliableSequenceNumber;
                    continue;
                }

                if (startCommand != currentCommand) {
                    enet_list_move(enet_list_end(&peer->dispatchedCommands), startCommand, enet_list_previous(currentCommand));

                    if (!peer->needsDispatch) {
                        enet_list_insert(enet_list_end(&peer->host->dispatchQueue), &peer->dispatchList);
                        peer->needsDispatch = 1;
                    }

                    droppedCommand = currentCommand;
                } else if (droppedCommand != currentCommand) {
                    droppedCommand = enet_list_previous(currentCommand);
                }
            } else {
                enet_uint16 reliableWindow = incomingCommand->reliableSequenceNumber / ENET_PEER_RELIABLE_WINDOW_SIZE;
                enet_uint16 currentWindow  = channel->incomingReliableSequenceNumber / ENET_PEER_RELIABLE_WINDOW_SIZE;

                if (incomingCommand->reliableSequenceNumber < channel->incomingReliableSequenceNumber) {
                    reliableWindow += ENET_PEER_RELIABLE_WINDOWS;
                }

                if (reliableWindow >= currentWindow && reliableWindow < currentWindow + ENET_PEER_FREE_RELIABLE_WINDOWS - 1) {
                    break;
                }

                droppedCommand = enet_list_next(currentCommand);

                if (startCommand != currentCommand) {
                    enet_list_move(enet_list_end(&peer->dispatchedCommands), startCommand, enet_list_previous(currentCommand));

                    if (!peer->needsDispatch) {
                        enet_list_insert(enet_list_end(&peer->host->dispatchQueue), &peer->dispatchList);
                        peer->needsDispatch = 1;
                    }
                }
            }

            startCommand = enet_list_next(currentCommand);
        }

        if (startCommand != currentCommand) {
            enet_list_move(enet_list_end(&peer->dispatchedCommands), startCommand, enet_list_previous(currentCommand));

            if (!peer->needsDispatch) {
                enet_list_insert(enet_list_end(&peer->host->dispatchQueue), &peer->dispatchList);
                peer->needsDispatch = 1;
            }

            droppedCommand = currentCommand;
        }

        enet_peer_remove_incoming_commands(&channel->incomingUnreliableCommands,enet_list_begin(&channel->incomingUnreliableCommands), droppedCommand);
    }

    void enet_peer_dispatch_incoming_reliable_commands(ENetPeer *peer, ENetChannel *channel) {
        ENetListIterator currentCommand;

        for (currentCommand = enet_list_begin(&channel->incomingReliableCommands);
            currentCommand != enet_list_end(&channel->incomingReliableCommands);
            currentCommand = enet_list_next(currentCommand)
        ) {
            ENetIncomingCommand *incomingCommand = (ENetIncomingCommand *) currentCommand;

            if (incomingCommand->fragmentsRemaining > 0 || incomingCommand->reliableSequenceNumber != (enet_uint16) (channel->incomingReliableSequenceNumber + 1)) {
                break;
            }

            channel->incomingReliableSequenceNumber = incomingCommand->reliableSequenceNumber;

            if (incomingCommand->fragmentCount > 0) {
                channel->incomingReliableSequenceNumber += incomingCommand->fragmentCount - 1;
            }
        }

        if (currentCommand == enet_list_begin(&channel->incomingReliableCommands)) {
            return;
        }

        channel->incomingUnreliableSequenceNumber = 0;
        enet_list_move(enet_list_end(&peer->dispatchedCommands), enet_list_begin(&channel->incomingReliableCommands), enet_list_previous(currentCommand));

        if (!peer->needsDispatch) {
            enet_list_insert(enet_list_end(&peer->host->dispatchQueue), &peer->dispatchList);
            peer->needsDispatch = 1;
        }

        if (!enet_list_empty(&channel->incomingUnreliableCommands)) {
            enet_peer_dispatch_incoming_unreliable_commands(peer, channel);
        }
    }

    ENetIncomingCommand * enet_peer_queue_incoming_command(ENetPeer *peer, const ENetProtocol *command, const void *data, size_t dataLength, enet_uint32 flags, enet_uint32 fragmentCount) {
        static ENetIncomingCommand dummyCommand;

        ENetChannel *channel = &peer->channels[command->header.channelID];
        enet_uint32 unreliableSequenceNumber = 0, reliableSequenceNumber = 0;
        enet_uint16 reliableWindow, currentWindow;
        ENetIncomingCommand *incomingCommand;
        ENetListIterator currentCommand;
        ENetPacket *packet = NULL;

        if (peer->state == ENET_PEER_STATE_DISCONNECT_LATER) {
            goto discardCommand;
        }

        if ((command->header.command & ENET_PROTOCOL_COMMAND_MASK) != ENET_PROTOCOL_COMMAND_SEND_UNSEQUENCED) {
            reliableSequenceNumber = command->header.reliableSequenceNumber;
            reliableWindow         = reliableSequenceNumber / ENET_PEER_RELIABLE_WINDOW_SIZE;
            currentWindow = channel->incomingReliableSequenceNumber / ENET_PEER_RELIABLE_WINDOW_SIZE;

            if (reliableSequenceNumber < channel->incomingReliableSequenceNumber) {
                reliableWindow += ENET_PEER_RELIABLE_WINDOWS;
            }

            if (reliableWindow < currentWindow || reliableWindow >= currentWindow + ENET_PEER_FREE_RELIABLE_WINDOWS - 1) {
                goto discardCommand;
            }
        }

        switch (command->header.command & ENET_PROTOCOL_COMMAND_MASK) {
            case ENET_PROTOCOL_COMMAND_SEND_FRAGMENT:
            case ENET_PROTOCOL_COMMAND_SEND_RELIABLE:
                if (reliableSequenceNumber == channel->incomingReliableSequenceNumber) {
                    goto discardCommand;
                }

                for (currentCommand = enet_list_previous(enet_list_end(&channel->incomingReliableCommands));
                    currentCommand != enet_list_end(&channel->incomingReliableCommands);
                    currentCommand = enet_list_previous(currentCommand)
                ) {
                    incomingCommand = (ENetIncomingCommand *) currentCommand;

                    if (reliableSequenceNumber >= channel->incomingReliableSequenceNumber) {
                        if (incomingCommand->reliableSequenceNumber < channel->incomingReliableSequenceNumber) {
                            continue;
                        }
                    } else if (incomingCommand->reliableSequenceNumber >= channel->incomingReliableSequenceNumber) {
                        break;
                    }

                    if (incomingCommand->reliableSequenceNumber <= reliableSequenceNumber) {
                        if (incomingCommand->reliableSequenceNumber < reliableSequenceNumber) {
                            break;
                        }

                        goto discardCommand;
                    }
                }
                break;

            case ENET_PROTOCOL_COMMAND_SEND_UNRELIABLE:
            case ENET_PROTOCOL_COMMAND_SEND_UNRELIABLE_FRAGMENT:
                unreliableSequenceNumber = ENET_NET_TO_HOST_16(command->sendUnreliable.unreliableSequenceNumber);

                if (reliableSequenceNumber == channel->incomingReliableSequenceNumber && unreliableSequenceNumber <= channel->incomingUnreliableSequenceNumber) {
                    goto discardCommand;
                }

                for (currentCommand = enet_list_previous(enet_list_end(&channel->incomingUnreliableCommands));
                    currentCommand != enet_list_end(&channel->incomingUnreliableCommands);
                    currentCommand = enet_list_previous(currentCommand)
                ) {
                    incomingCommand = (ENetIncomingCommand *) currentCommand;

                    if ((command->header.command & ENET_PROTOCOL_COMMAND_MASK) == ENET_PROTOCOL_COMMAND_SEND_UNSEQUENCED) {
                        continue;
                    }

                    if (reliableSequenceNumber >= channel->incomingReliableSequenceNumber) {
                        if (incomingCommand->reliableSequenceNumber < channel->incomingReliableSequenceNumber) {
                            continue;
                        }
                    } else if (incomingCommand->reliableSequenceNumber >= channel->incomingReliableSequenceNumber) {
                        break;
                    }

                    if (incomingCommand->reliableSequenceNumber < reliableSequenceNumber) {
                        break;
                    }

                    if (incomingCommand->reliableSequenceNumber > reliableSequenceNumber) {
                        continue;
                    }

                    if (incomingCommand->unreliableSequenceNumber <= unreliableSequenceNumber) {
                        if (incomingCommand->unreliableSequenceNumber < unreliableSequenceNumber) {
                            break;
                        }

                        goto discardCommand;
                    }
                }
                break;

            case ENET_PROTOCOL_COMMAND_SEND_UNSEQUENCED:
                currentCommand = enet_list_end(&channel->incomingUnreliableCommands);
                break;

            default:
                goto discardCommand;
        }

        if (peer->totalWaitingData >= peer->host->maximumWaitingData) {
            goto notifyError;
        }

        packet = callbacks.packet_create(data, dataLength, flags);
        if (packet == NULL) {
            goto notifyError;
        }

        incomingCommand = (ENetIncomingCommand *) enet_malloc(sizeof(ENetIncomingCommand));
        if (incomingCommand == NULL) {
            goto notifyError;
        }

        incomingCommand->reliableSequenceNumber     = command->header.reliableSequenceNumber;
        incomingCommand->unreliableSequenceNumber   = unreliableSequenceNumber & 0xFFFF;
        incomingCommand->command                    = *command;
        incomingCommand->fragmentCount              = fragmentCount;
        incomingCommand->fragmentsRemaining         = fragmentCount;
        incomingCommand->packet                     = packet;
        incomingCommand->fragments                  = NULL;

        if (fragmentCount > 0) {
            if (fragmentCount <= ENET_PROTOCOL_MAXIMUM_FRAGMENT_COUNT) {
                incomingCommand->fragments = (enet_uint32 *) enet_malloc((fragmentCount + 31) / 32 * sizeof(enet_uint32));
            }

            if (incomingCommand->fragments == NULL) {
                enet_free(incomingCommand);

                goto notifyError;
            }

            memset(incomingCommand->fragments, 0, (fragmentCount + 31) / 32 * sizeof(enet_uint32));
        }

        if (packet != NULL) {
            ++packet->referenceCount;
            peer->totalWaitingData += packet->dataLength;
        }

        enet_list_insert(enet_list_next(currentCommand), incomingCommand);

        switch (command->header.command & ENET_PROTOCOL_COMMAND_MASK) {
            case ENET_PROTOCOL_COMMAND_SEND_FRAGMENT:
            case ENET_PROTOCOL_COMMAND_SEND_RELIABLE:
                enet_peer_dispatch_incoming_reliable_commands(peer, channel);
                break;

            default:
                enet_peer_dispatch_incoming_unreliable_commands(peer, channel);
                break;
        }

        return incomingCommand;

    discardCommand:
        if (fragmentCount > 0) {
            goto notifyError;
        }

        if (packet != NULL && packet->referenceCount == 0) {
            callbacks.packet_destroy(packet);
        }

        return &dummyCommand;

    notifyError:
        if (packet != NULL && packet->referenceCount == 0) {
            callbacks.packet_destroy(packet);
        }

        return NULL;
    } /* enet_peer_queue_incoming_command */

// =======================================================================//
// !
// ! Host
// !
// =======================================================================//

    /** Creates a host for communicating to peers.
     *
     *  @param address   the address at which other peers may connect to this host.  If NULL, then no peers may connect to the host.
     *  @param peerCount the maximum number of peers that should be allocated for the host.
     *  @param channelLimit the maximum number of channels allowed; if 0, then this is equivalent to ENET_PROTOCOL_MAXIMUM_CHANNEL_COUNT
     *  @param incomingBandwidth downstream bandwidth of the host in bytes/second; if 0, ENet will assume unlimited bandwidth.
     *  @param outgoingBandwidth upstream bandwidth of the host in bytes/second; if 0, ENet will assume unlimited bandwidth.
     *
     *  @returns the host on success and NULL on failure
     *
     *  @remarks ENet will strategically drop packets on specific sides of a connection between hosts
     *  to ensure the host's bandwidth is not overwhelmed.  The bandwidth parameters also determine
     *  the window size of a connection which limits the amount of reliable packets that may be in transit
     *  at any given time.
     */
    ENetHost * enet_host_create(const ENetAddress *address, size_t peerCount, size_t channelLimit, enet_uint32 incomingBandwidth, enet_uint32 outgoingBandwidth) {
        ENetHost *host;
        ENetPeer *currentPeer;

        if (peerCount > ENET_PROTOCOL_MAXIMUM_PEER_ID) {
            return NULL;
        }

        host = (ENetHost *) enet_malloc(sizeof(ENetHost));
        if (host == NULL) { return NULL; }
        memset(host, 0, sizeof(ENetHost));

        host->peers = (ENetPeer *) enet_malloc(peerCount * sizeof(ENetPeer));
        if (host->peers == NULL) {
            enet_free(host);
            return NULL;
        }

        memset(host->peers, 0, peerCount * sizeof(ENetPeer));

        host->socket = enet_socket_create(ENET_SOCKET_TYPE_DATAGRAM);
        if (host->socket != ENET_SOCKET_NULL) {
            enet_socket_set_option (host->socket, ENET_SOCKOPT_IPV6_V6ONLY, 0);
        }

        if (host->socket == ENET_SOCKET_NULL || (address != NULL && enet_socket_bind(host->socket, address) < 0)) {
            if (host->socket != ENET_SOCKET_NULL) {
                enet_socket_destroy(host->socket);
            }

            enet_free(host->peers);
            enet_free(host);

            return NULL;
        }

        enet_socket_set_option(host->socket, ENET_SOCKOPT_NONBLOCK, 1);
        enet_socket_set_option(host->socket, ENET_SOCKOPT_BROADCAST, 1);
        enet_socket_set_option(host->socket, ENET_SOCKOPT_RCVBUF, ENET_HOST_RECEIVE_BUFFER_SIZE);
        enet_socket_set_option(host->socket, ENET_SOCKOPT_SNDBUF, ENET_HOST_SEND_BUFFER_SIZE);
        enet_socket_set_option(host->socket, ENET_SOCKOPT_IPV6_V6ONLY, 0);

        if (address != NULL && enet_socket_get_address(host->socket, &host->address) < 0) {
            host->address = *address;
        }

        if (!channelLimit || channelLimit > ENET_PROTOCOL_MAXIMUM_CHANNEL_COUNT) {
            channelLimit = ENET_PROTOCOL_MAXIMUM_CHANNEL_COUNT;
        } else if (channelLimit < ENET_PROTOCOL_MINIMUM_CHANNEL_COUNT) {
            channelLimit = ENET_PROTOCOL_MINIMUM_CHANNEL_COUNT;
        }

        host->randomSeed                    = (enet_uint32) (size_t) host;
        host->randomSeed                    += enet_host_random_seed();
        host->randomSeed                    = (host->randomSeed << 16) | (host->randomSeed >> 16);
        host->channelLimit                  = channelLimit;
        host->incomingBandwidth             = incomingBandwidth;
        host->outgoingBandwidth             = outgoingBandwidth;
        host->bandwidthThrottleEpoch        = 0;
        host->recalculateBandwidthLimits    = 0;
        host->mtu                           = ENET_HOST_DEFAULT_MTU;
        host->peerCount                     = peerCount;
        host->commandCount                  = 0;
        host->bufferCount                   = 0;
        host->checksum                      = NULL;
        host->receivedAddress.host          = ENET_HOST_ANY;
        host->receivedAddress.port          = 0;
        host->receivedData                  = NULL;
        host->receivedDataLength            = 0;
        host->totalSentData                 = 0;
        host->totalSentPackets              = 0;
        host->totalReceivedData             = 0;
        host->totalReceivedPackets          = 0;
        host->connectedPeers                = 0;
        host->bandwidthLimitedPeers         = 0;
        host->duplicatePeers                = ENET_PROTOCOL_MAXIMUM_PEER_ID;
        host->maximumPacketSize             = ENET_HOST_DEFAULT_MAXIMUM_PACKET_SIZE;
        host->maximumWaitingData            = ENET_HOST_DEFAULT_MAXIMUM_WAITING_DATA;
        host->compressor.context            = NULL;
        host->compressor.compress           = NULL;
        host->compressor.decompress         = NULL;
        host->compressor.destroy            = NULL;
        host->intercept                     = NULL;

        enet_list_clear(&host->dispatchQueue);

        for (currentPeer = host->peers; currentPeer < &host->peers[host->peerCount]; ++currentPeer) {
            currentPeer->host = host;
            currentPeer->incomingPeerID    = currentPeer - host->peers;
            currentPeer->outgoingSessionID = currentPeer->incomingSessionID = 0xFF;
            currentPeer->data = NULL;

            enet_list_clear(&currentPeer->acknowledgements);
            enet_list_clear(&currentPeer->sentReliableCommands);
            enet_list_clear(&currentPeer->sentUnreliableCommands);
            enet_list_clear(&currentPeer->outgoingReliableCommands);
            enet_list_clear(&currentPeer->outgoingUnreliableCommands);
            enet_list_clear(&currentPeer->dispatchedCommands);

            enet_peer_reset(currentPeer);
        }

        return host;
    } /* enet_host_create */

    /** Destroys the host and all resources associated with it.
     *  @param host pointer to the host to destroy
     */
    void enet_host_destroy(ENetHost *host) {
        ENetPeer *currentPeer;

        if (host == NULL) {
            return;
        }

        enet_socket_destroy(host->socket);

        for (currentPeer = host->peers; currentPeer < &host->peers[host->peerCount]; ++currentPeer) {
            enet_peer_reset(currentPeer);
        }

        if (host->compressor.context != NULL && host->compressor.destroy) {
            (*host->compressor.destroy)(host->compressor.context);
        }

        enet_free(host->peers);
        enet_free(host);
    }

    /** Initiates a connection to a foreign host.
     *  @param host host seeking the connection
     *  @param address destination for the connection
     *  @param channelCount number of channels to allocate
     *  @param data user data supplied to the receiving host
     *  @returns a peer representing the foreign host on success, NULL on failure
     *  @remarks The peer returned will have not completed the connection until enet_host_service()
     *  notifies of an ENET_EVENT_TYPE_CONNECT event for the peer.
     */
    ENetPeer * enet_host_connect(ENetHost *host, const ENetAddress *address, size_t channelCount, enet_uint32 data) {
        ENetPeer *currentPeer;
        ENetChannel *channel;
        ENetProtocol command;

        if (channelCount < ENET_PROTOCOL_MINIMUM_CHANNEL_COUNT) {
            channelCount = ENET_PROTOCOL_MINIMUM_CHANNEL_COUNT;
        } else if (channelCount > ENET_PROTOCOL_MAXIMUM_CHANNEL_COUNT) {
            channelCount = ENET_PROTOCOL_MAXIMUM_CHANNEL_COUNT;
        }

        for (currentPeer = host->peers; currentPeer < &host->peers[host->peerCount]; ++currentPeer) {
            if (currentPeer->state == ENET_PEER_STATE_DISCONNECTED) {
                break;
            }
        }

        if (currentPeer >= &host->peers[host->peerCount]) {
            return NULL;
        }

        currentPeer->channels = (ENetChannel *) enet_malloc(channelCount * sizeof(ENetChannel));
        if (currentPeer->channels == NULL) {
            return NULL;
        }

        currentPeer->channelCount = channelCount;
        currentPeer->state        = ENET_PEER_STATE_CONNECTING;
        currentPeer->address      = *address;
        currentPeer->connectID    = ++host->randomSeed;

        if (host->outgoingBandwidth == 0) {
            currentPeer->windowSize = ENET_PROTOCOL_MAXIMUM_WINDOW_SIZE;
        } else {
            currentPeer->windowSize = (host->outgoingBandwidth / ENET_PEER_WINDOW_SIZE_SCALE) * ENET_PROTOCOL_MINIMUM_WINDOW_SIZE;
        }

        if (currentPeer->windowSize < ENET_PROTOCOL_MINIMUM_WINDOW_SIZE) {
            currentPeer->windowSize = ENET_PROTOCOL_MINIMUM_WINDOW_SIZE;
        } else if (currentPeer->windowSize > ENET_PROTOCOL_MAXIMUM_WINDOW_SIZE) {
            currentPeer->windowSize = ENET_PROTOCOL_MAXIMUM_WINDOW_SIZE;
        }

        for (channel = currentPeer->channels; channel < &currentPeer->channels[channelCount]; ++channel) {
            channel->outgoingReliableSequenceNumber   = 0;
            channel->outgoingUnreliableSequenceNumber = 0;
            channel->incomingReliableSequenceNumber   = 0;
            channel->incomingUnreliableSequenceNumber = 0;

            enet_list_clear(&channel->incomingReliableCommands);
            enet_list_clear(&channel->incomingUnreliableCommands);

            channel->usedReliableWindows = 0;
            memset(channel->reliableWindows, 0, sizeof(channel->reliableWindows));
        }

        command.header.command                     = ENET_PROTOCOL_COMMAND_CONNECT | ENET_PROTOCOL_COMMAND_FLAG_ACKNOWLEDGE;
        command.header.channelID                   = 0xFF;
        command.connect.outgoingPeerID             = ENET_HOST_TO_NET_16(currentPeer->incomingPeerID);
        command.connect.incomingSessionID          = currentPeer->incomingSessionID;
        command.connect.outgoingSessionID          = currentPeer->outgoingSessionID;
        command.connect.mtu                        = ENET_HOST_TO_NET_32(currentPeer->mtu);
        command.connect.windowSize                 = ENET_HOST_TO_NET_32(currentPeer->windowSize);
        command.connect.channelCount               = ENET_HOST_TO_NET_32(channelCount);
        command.connect.incomingBandwidth          = ENET_HOST_TO_NET_32(host->incomingBandwidth);
        command.connect.outgoingBandwidth          = ENET_HOST_TO_NET_32(host->outgoingBandwidth);
        command.connect.packetThrottleInterval     = ENET_HOST_TO_NET_32(currentPeer->packetThrottleInterval);
        command.connect.packetThrottleAcceleration = ENET_HOST_TO_NET_32(currentPeer->packetThrottleAcceleration);
        command.connect.packetThrottleDeceleration = ENET_HOST_TO_NET_32(currentPeer->packetThrottleDeceleration);
        command.connect.connectID                  = currentPeer->connectID;
        command.connect.data                       = ENET_HOST_TO_NET_32(data);

        enet_peer_queue_outgoing_command(currentPeer, &command, NULL, 0, 0);

        return currentPeer;
    } /* enet_host_connect */

    /** Queues a packet to be sent to all peers associated with the host.
     *  @param host host on which to broadcast the packet
     *  @param channelID channel on which to broadcast
     *  @param packet packet to broadcast
     */
    void enet_host_broadcast(ENetHost *host, enet_uint8 channelID, ENetPacket *packet) {
        ENetPeer *currentPeer;

        for (currentPeer = host->peers; currentPeer < &host->peers[host->peerCount]; ++currentPeer) {
            if (currentPeer->state != ENET_PEER_STATE_CONNECTED) {
                continue;
            }

            enet_peer_send(currentPeer, channelID, packet);
        }

        if (packet->referenceCount == 0) {
            callbacks.packet_destroy(packet);
        }
    }

    /** Sends raw data to specified address. Useful when you want to send unconnected data using host's socket.         
     *  @param host host sending data
     *  @param address destination address
     *  @param data data pointer
     *  @param dataLength length of data to send
     *  @retval >=0 bytes sent
     *  @retval <0 error
     *  @sa enet_socket_send
     */
    int enet_host_send_raw(ENetHost *host, const ENetAddress* address, enet_uint8* data, size_t dataLength) {
        ENetBuffer buffer;
        buffer.data = data;
        buffer.dataLength = dataLength;
        return enet_socket_send(host->socket, address, &buffer, 1);
    }

    /** Sends raw data to specified address with extended arguments. Allows to send only part of data, handy for other programming languages.
     *  I.e. if you have data =- { 0, 1, 2, 3 } and call function as enet_host_send_raw_ex(data, 1, 2) then it will skip 1 byte and send 2 bytes { 1, 2 }.
     *  @param host host sending data
     *  @param address destination address
     *  @param data data pointer
     *  @param skipBytes number of bytes to skip from start of data
     *  @param bytesToSend number of bytes to send
     *  @retval >=0 bytes sent
     *  @retval <0 error
     *  @sa enet_socket_send
     */
    int enet_host_send_raw_ex(ENetHost *host, const ENetAddress* address, enet_uint8* data, size_t skipBytes, size_t bytesToSend) {
        ENetBuffer buffer;
        buffer.data = data + skipBytes;
        buffer.dataLength = bytesToSend;
        return enet_socket_send(host->socket, address, &buffer, 1);
    }

    /** Sets intercept callback for the host.
     *  @param host host to set a callback
     *  @param callback intercept callback
     */
    void enet_host_set_intercept(ENetHost *host, const ENetInterceptCallback callback) {
        host->intercept = callback;
    }

    /** Sets the packet compressor the host should use to compress and decompress packets.
     *  @param host host to enable or disable compression for
     *  @param compressor callbacks for for the packet compressor; if NULL, then compression is disabled
     */
    void enet_host_compress(ENetHost *host, const ENetCompressor *compressor) {
        if (host->compressor.context != NULL && host->compressor.destroy) {
            (*host->compressor.destroy)(host->compressor.context);
        }

        if (compressor) {
            host->compressor = *compressor;
        } else {
            host->compressor.context = NULL;
        }
    }

    /** Limits the maximum allowed channels of future incoming connections.
     *  @param host host to limit
     *  @param channelLimit the maximum number of channels allowed; if 0, then this is equivalent to ENET_PROTOCOL_MAXIMUM_CHANNEL_COUNT
     */
    void enet_host_channel_limit(ENetHost *host, size_t channelLimit) {
        if (!channelLimit || channelLimit > ENET_PROTOCOL_MAXIMUM_CHANNEL_COUNT) {
            channelLimit = ENET_PROTOCOL_MAXIMUM_CHANNEL_COUNT;
        } else if (channelLimit < ENET_PROTOCOL_MINIMUM_CHANNEL_COUNT) {
            channelLimit = ENET_PROTOCOL_MINIMUM_CHANNEL_COUNT;
        }

        host->channelLimit = channelLimit;
    }

    /** Adjusts the bandwidth limits of a host.
     *  @param host host to adjust
     *  @param incomingBandwidth new incoming bandwidth
     *  @param outgoingBandwidth new outgoing bandwidth
     *  @remarks the incoming and outgoing bandwidth parameters are identical in function to those
     *  specified in enet_host_create().
     */
    void enet_host_bandwidth_limit(ENetHost *host, enet_uint32 incomingBandwidth, enet_uint32 outgoingBandwidth) {
        host->incomingBandwidth = incomingBandwidth;
        host->outgoingBandwidth = outgoingBandwidth;
        host->recalculateBandwidthLimits = 1;
    }

    void enet_host_bandwidth_throttle(ENetHost *host) {
        enet_uint32 timeCurrent       = enet_time_get();
        enet_uint32 elapsedTime       = timeCurrent - host->bandwidthThrottleEpoch;
        enet_uint32 peersRemaining    = (enet_uint32) host->connectedPeers;
        enet_uint32 dataTotal         = ~0;
        enet_uint32 bandwidth         = ~0;
        enet_uint32 throttle          = 0;
        enet_uint32 bandwidthLimit    = 0;

        int needsAdjustment = host->bandwidthLimitedPeers > 0 ? 1 : 0;
        ENetPeer *peer;
        ENetProtocol command;

        if (elapsedTime < ENET_HOST_BANDWIDTH_THROTTLE_INTERVAL) {
            return;
        }

        if (host->outgoingBandwidth == 0 && host->incomingBandwidth == 0) {
            return;
        }

        host->bandwidthThrottleEpoch = timeCurrent;

        if (peersRemaining == 0) {
            return;
        }

        if (host->outgoingBandwidth != 0) {
            dataTotal = 0;
            bandwidth = (host->outgoingBandwidth * elapsedTime) / 1000;

            for (peer = host->peers; peer < &host->peers[host->peerCount]; ++peer) {
                if (peer->state != ENET_PEER_STATE_CONNECTED && peer->state != ENET_PEER_STATE_DISCONNECT_LATER) {
                    continue;
                }

                dataTotal += peer->outgoingDataTotal;
            }
        }

        while (peersRemaining > 0 && needsAdjustment != 0) {
            needsAdjustment = 0;

            if (dataTotal <= bandwidth) {
                throttle = ENET_PEER_PACKET_THROTTLE_SCALE;
            } else {
                throttle = (bandwidth * ENET_PEER_PACKET_THROTTLE_SCALE) / dataTotal;
            }

            for (peer = host->peers; peer < &host->peers[host->peerCount]; ++peer) {
                enet_uint32 peerBandwidth;

                if ((peer->state != ENET_PEER_STATE_CONNECTED && peer->state != ENET_PEER_STATE_DISCONNECT_LATER) ||
                    peer->incomingBandwidth == 0 ||
                    peer->outgoingBandwidthThrottleEpoch == timeCurrent
                ) {
                    continue;
                }

                peerBandwidth = (peer->incomingBandwidth * elapsedTime) / 1000;
                if ((throttle * peer->outgoingDataTotal) / ENET_PEER_PACKET_THROTTLE_SCALE <= peerBandwidth) {
                    continue;
                }

                peer->packetThrottleLimit = (peerBandwidth * ENET_PEER_PACKET_THROTTLE_SCALE) / peer->outgoingDataTotal;

                if (peer->packetThrottleLimit == 0) {
                    peer->packetThrottleLimit = 1;
                }

                if (peer->packetThrottle > peer->packetThrottleLimit) {
                    peer->packetThrottle = peer->packetThrottleLimit;
                }

                peer->outgoingBandwidthThrottleEpoch = timeCurrent;

                peer->incomingDataTotal = 0;
                peer->outgoingDataTotal = 0;

                needsAdjustment = 1;
                --peersRemaining;
                bandwidth -= peerBandwidth;
                dataTotal -= peerBandwidth;
            }
        }

        if (peersRemaining > 0) {
            if (dataTotal <= bandwidth) {
                throttle = ENET_PEER_PACKET_THROTTLE_SCALE;
            } else {
                throttle = (bandwidth * ENET_PEER_PACKET_THROTTLE_SCALE) / dataTotal;
            }

            for (peer = host->peers;
              peer < &host->peers[host->peerCount];
              ++peer)
            {
                if ((peer->state != ENET_PEER_STATE_CONNECTED && peer->state != ENET_PEER_STATE_DISCONNECT_LATER) || peer->outgoingBandwidthThrottleEpoch == timeCurrent) {
                    continue;
                }

                peer->packetThrottleLimit = throttle;

                if (peer->packetThrottle > peer->packetThrottleLimit) {
                    peer->packetThrottle = peer->packetThrottleLimit;
                }

                peer->incomingDataTotal = 0;
                peer->outgoingDataTotal = 0;
            }
        }

        if (host->recalculateBandwidthLimits) {
            host->recalculateBandwidthLimits = 0;

            peersRemaining  = (enet_uint32) host->connectedPeers;
            bandwidth       = host->incomingBandwidth;
            needsAdjustment = 1;

            if (bandwidth == 0) {
                bandwidthLimit = 0;
            } else {
                while (peersRemaining > 0 && needsAdjustment != 0) {
                    needsAdjustment = 0;
                    bandwidthLimit  = bandwidth / peersRemaining;

                    for (peer = host->peers; peer < &host->peers[host->peerCount]; ++peer) {
                        if ((peer->state != ENET_PEER_STATE_CONNECTED && peer->state != ENET_PEER_STATE_DISCONNECT_LATER) ||
                            peer->incomingBandwidthThrottleEpoch == timeCurrent
                        ) {
                            continue;
                        }

                        if (peer->outgoingBandwidth > 0 && peer->outgoingBandwidth >= bandwidthLimit) {
                            continue;
                        }

                        peer->incomingBandwidthThrottleEpoch = timeCurrent;

                        needsAdjustment = 1;
                        --peersRemaining;
                        bandwidth -= peer->outgoingBandwidth;
                    }
                }
            }

            for (peer = host->peers; peer < &host->peers[host->peerCount]; ++peer) {
                if (peer->state != ENET_PEER_STATE_CONNECTED && peer->state != ENET_PEER_STATE_DISCONNECT_LATER) {
                    continue;
                }

                command.header.command   = ENET_PROTOCOL_COMMAND_BANDWIDTH_LIMIT | ENET_PROTOCOL_COMMAND_FLAG_ACKNOWLEDGE;
                command.header.channelID = 0xFF;
                command.bandwidthLimit.outgoingBandwidth = ENET_HOST_TO_NET_32(host->outgoingBandwidth);

                if (peer->incomingBandwidthThrottleEpoch == timeCurrent) {
                    command.bandwidthLimit.incomingBandwidth = ENET_HOST_TO_NET_32(peer->outgoingBandwidth);
                } else {
                    command.bandwidthLimit.incomingBandwidth = ENET_HOST_TO_NET_32(bandwidthLimit);
                }

                enet_peer_queue_outgoing_command(peer, &command, NULL, 0, 0);
            }
        }
    } /* enet_host_bandwidth_throttle */

// =======================================================================//
// !
// ! Time
// !
// =======================================================================//

    #ifdef _WIN32
        static LARGE_INTEGER getFILETIMEoffset() {
            SYSTEMTIME s;
            FILETIME f;
            LARGE_INTEGER t;

            s.wYear = 1970;
            s.wMonth = 1;
            s.wDay = 1;
            s.wHour = 0;
            s.wMinute = 0;
            s.wSecond = 0;
            s.wMilliseconds = 0;
            SystemTimeToFileTime(&s, &f);
            t.QuadPart = f.dwHighDateTime;
            t.QuadPart <<= 32;
            t.QuadPart |= f.dwLowDateTime;
            return (t);
        }

        int clock_gettime(int X, struct timespec *tv) {
            LARGE_INTEGER t;
            FILETIME f;
            double microseconds;
            static LARGE_INTEGER offset;
            static double frequencyToMicroseconds;
            static int initialized = 0;
            static BOOL usePerformanceCounter = 0;

            if (!initialized) {
                LARGE_INTEGER performanceFrequency;
                initialized = 1;
                usePerformanceCounter = QueryPerformanceFrequency(&performanceFrequency);
                if (usePerformanceCounter) {
                    QueryPerformanceCounter(&offset);
                    frequencyToMicroseconds = (double)performanceFrequency.QuadPart / 1000000.;
                } else {
                    offset = getFILETIMEoffset();
                    frequencyToMicroseconds = 10.;
                }
            }
            if (usePerformanceCounter) {
                QueryPerformanceCounter(&t);
            } else {
                GetSystemTimeAsFileTime(&f);
                t.QuadPart = f.dwHighDateTime;
                t.QuadPart <<= 32;
                t.QuadPart |= f.dwLowDateTime;
            }

            t.QuadPart -= offset.QuadPart;
            microseconds = (double)t.QuadPart / frequencyToMicroseconds;
            t.QuadPart = (LONGLONG)microseconds;
            tv->tv_sec = (long)(t.QuadPart / 1000000);
            tv->tv_nsec = t.QuadPart % 1000000 * 1000;
            return (0);
        }
    #elif __APPLE__ && __MAC_OS_X_VERSION_MIN_REQUIRED < 101200
        #define CLOCK_MONOTONIC 0

        int clock_gettime(int X, struct timespec *ts) {
            clock_serv_t cclock;
            mach_timespec_t mts;

            host_get_clock_service(mach_host_self(), SYSTEM_CLOCK, &cclock);
            clock_get_time(cclock, &mts);
            mach_port_deallocate(mach_task_self(), cclock);

            ts->tv_sec = mts.tv_sec;
            ts->tv_nsec = mts.tv_nsec;

            return 0;
        }
    #endif

    enet_uint32 enet_time_get() {
        // TODO enet uses 32 bit timestamps. We should modify it to use
        // 64 bit timestamps, but this is not trivial since we'd end up
        // changing half the structs in enet. For now, retain 32 bits, but
        // use an offset so we don't run out of bits. Basically, the first
        // call of enet_time_get() will always return 1, and follow-up calls
        // indicate elapsed time since the first call.
        //
        // Note that we don't want to return 0 from the first call, in case
        // some part of enet uses 0 as a special value (meaning time not set
        // for example).
        static uint64_t start_time_ns = 0;

        struct timespec ts;
    #if defined(CLOCK_MONOTONIC_RAW)
        clock_gettime(CLOCK_MONOTONIC_RAW, &ts);
    #else
        clock_gettime(CLOCK_MONOTONIC, &ts);
    #endif

        static const uint64_t ns_in_s = 1000 * 1000 * 1000;
        static const uint64_t ns_in_ms = 1000 * 1000;
        uint64_t current_time_ns = ts.tv_nsec + (uint64_t)ts.tv_sec * ns_in_s;

        // Most of the time we just want to atomically read the start time. We
        // could just use a single CAS instruction instead of this if, but it
        // would be slower in the average case.
        //
        // Note that statics are auto-initialized to zero, and starting a thread
        // implies a memory barrier. So we know that whatever thread calls this,
        // it correctly sees the start_time_ns as 0 initially.
        uint64_t offset_ns = ENET_ATOMIC_READ(&start_time_ns);
        if (offset_ns == 0) {
            // We still need to CAS, since two different threads can get here
            // at the same time.
            //
            // We assume that current_time_ns is > 1ms.
            //
            // Set the value of the start_time_ns, such that the first timestamp
            // is at 1ms. This ensures 0 remains a special value.
            uint64_t want_value = current_time_ns - 1 * ns_in_ms;
            uint64_t old_value = ENET_ATOMIC_CAS(&start_time_ns, 0, want_value);
            offset_ns = old_value == 0 ? want_value : old_value;
        }

        uint64_t result_in_ns = current_time_ns - offset_ns;
        return (enet_uint32)(result_in_ns / ns_in_ms);
    }

    void enet_inaddr_map4to6(struct in_addr in, struct in6_addr *out)
    {
        if (in.s_addr == 0x00000000) { /* 0.0.0.0 */
            *out = enet_v6_anyaddr;
        } else if (in.s_addr == 0xFFFFFFFF) { /* 255.255.255.255 */
            *out = enet_v6_noaddr;
        } else {
            *out = enet_v4_anyaddr;
            out->s6_addr[10] = 0xFF;
            out->s6_addr[11] = 0xFF;
            out->s6_addr[12] = ((uint8_t *)&in.s_addr)[0];
            out->s6_addr[13] = ((uint8_t *)&in.s_addr)[1];
            out->s6_addr[14] = ((uint8_t *)&in.s_addr)[2];
            out->s6_addr[15] = ((uint8_t *)&in.s_addr)[3];
        }
    }
    void enet_inaddr_map6to4(const struct in6_addr *in, struct in_addr *out)
    {
        memset(out, 0, sizeof(struct in_addr));
        ((uint8_t *)&out->s_addr)[0] = in->s6_addr[12];
        ((uint8_t *)&out->s_addr)[1] = in->s6_addr[13];
        ((uint8_t *)&out->s_addr)[2] = in->s6_addr[14];
        ((uint8_t *)&out->s_addr)[3] = in->s6_addr[15];
    }

    int enet_in6addr_lookup_host(const char *name, bool nodns, struct in6_addr *out) {
        struct addrinfo hints, *resultList = NULL, *result = NULL;

        memset(&hints, 0, sizeof(hints));
        hints.ai_family = AF_UNSPEC;

        if (nodns)
        {
            hints.ai_flags = AI_NUMERICHOST; /* prevent actual DNS lookups! */
        }

        if (getaddrinfo(name, NULL, &hints, &resultList) != 0) {
            if (resultList != NULL) {
                freeaddrinfo(resultList);
            }

            return -1;
        }

        for (result = resultList; result != NULL; result = result->ai_next) {
            if (result->ai_addr != NULL) {
                if (result->ai_family == AF_INET || (result->ai_family == AF_UNSPEC && result->ai_addrlen == sizeof(struct sockaddr_in))) {
                    enet_inaddr_map4to6(((struct sockaddr_in*)result->ai_addr)->sin_addr, out);

                    if (resultList != NULL) {
                        freeaddrinfo(resultList);
                    }

                    return 0;
                } else if (result->ai_family == AF_INET6 || (result->ai_family == AF_UNSPEC && result->ai_addrlen == sizeof(struct sockaddr_in6))) {
                    memcpy(out, &((struct sockaddr_in6*)result->ai_addr)->sin6_addr, sizeof(struct in6_addr));

                    if (resultList != NULL) {
                        freeaddrinfo(resultList);
                    }

                    return 0;
                }
            }
        }

        if (resultList != NULL) {
            freeaddrinfo(resultList);
        }

        return -1;
    }

    int enet_address_set_host_ip_new(ENetAddress *address, const char *name) {
        return enet_in6addr_lookup_host(name, true, &address->host);
    }

    int enet_address_set_host_new(ENetAddress *address, const char *name) {
        return enet_in6addr_lookup_host(name, false, &address->host);
    }

    int enet_address_get_host_ip_new(const ENetAddress *address, char *name, size_t nameLength) {
        if (IN6_IS_ADDR_V4MAPPED(&address->host)) {
            struct in_addr buf;
            enet_inaddr_map6to4(&address->host, &buf);

            if (inet_ntop(AF_INET, &buf, name, nameLength) == NULL) {
                return -1;
            }
        }
        else {
            if (inet_ntop(AF_INET6, &address->host, name, nameLength) == NULL) {
                return -1;
            }
        }

        return 0;
    } /* enet_address_get_host_ip_new */

    int enet_address_get_host_new(const ENetAddress *address, char *name, size_t nameLength) {
        struct sockaddr_in6 sin;
        memset(&sin, 0, sizeof(struct sockaddr_in6));

        int err;


        sin.sin6_family = AF_INET6;
        sin.sin6_port = ENET_HOST_TO_NET_16 (address->port);
        sin.sin6_addr = address->host;
        sin.sin6_scope_id = address->sin6_scope_id;

        err = getnameinfo((struct sockaddr *) &sin, sizeof(sin), name, nameLength, NULL, 0, NI_NAMEREQD);
        if (!err) {
            if (name != NULL && nameLength > 0 && !memchr(name, '\0', nameLength)) {
                return -1;
            }
            return 0;
        }
        if (err != EAI_NONAME) {
            return -1;
        }

        return enet_address_get_host_ip_new(address, name, nameLength);
    } /* enet_address_get_host_new */

// =======================================================================//
// !
// ! Platform Specific (Unix)
// !
// =======================================================================//

    #ifndef _WIN32

        #if defined(__MINGW32__) && defined(ENET_MINGW_COMPAT)
        // inet_ntop/inet_pton for MinGW from http://mingw-users.1079350.n2.nabble.com/IPv6-getaddrinfo-amp-inet-ntop-td5891996.html
        const char *inet_ntop(int af, const void *src, char *dst, socklen_t cnt) {
            if (af == AF_INET) {
                struct sockaddr_in in;
                memset(&in, 0, sizeof(in));
                in.sin_family = AF_INET;
                memcpy(&in.sin_addr, src, sizeof(struct in_addr));
                getnameinfo((struct sockaddr *)&in, sizeof(struct sockaddr_in), dst, cnt, NULL, 0, NI_NUMERICHOST);
                return dst;
            }
            else if (af == AF_INET6) {
                struct sockaddr_in6 in;
                memset(&in, 0, sizeof(in));
                in.sin6_family = AF_INET6;
                memcpy(&in.sin6_addr, src, sizeof(struct in_addr6));
                getnameinfo((struct sockaddr *)&in, sizeof(struct sockaddr_in6), dst, cnt, NULL, 0, NI_NUMERICHOST);
                return dst;
            }

            return NULL;
        }

        #define NS_INADDRSZ  4
        #define NS_IN6ADDRSZ 16
        #define NS_INT16SZ   2

        int inet_pton4(const char *src, char *dst) {
            uint8_t tmp[NS_INADDRSZ], *tp;

            int saw_digit = 0;
            int octets = 0;
            *(tp = tmp) = 0;

            int ch;
            while ((ch = *src++) != '\0')
            {
                if (ch >= '0' && ch <= '9')
                {
                    uint32_t n = *tp * 10 + (ch - '0');

                    if (saw_digit && *tp == 0)
                        return 0;

                    if (n > 255)
                        return 0;

                    *tp = n;
                    if (!saw_digit)
                    {
                        if (++octets > 4)
                            return 0;
                        saw_digit = 1;
                    }
                }
                else if (ch == '.' && saw_digit)
                {
                    if (octets == 4)
                        return 0;
                    *++tp = 0;
                    saw_digit = 0;
                }
                else
                    return 0;
            }
            if (octets < 4)
                return 0;

            memcpy(dst, tmp, NS_INADDRSZ);

            return 1;
        }

        int inet_pton6(const char *src, char *dst) {
            static const char xdigits[] = "0123456789abcdef";
            uint8_t tmp[NS_IN6ADDRSZ];

            uint8_t *tp = (uint8_t*) memset(tmp, '\0', NS_IN6ADDRSZ);
            uint8_t *endp = tp + NS_IN6ADDRSZ;
            uint8_t *colonp = NULL;

            /* Leading :: requires some special handling. */
            if (*src == ':')
            {
                if (*++src != ':')
                    return 0;
            }

            const char *curtok = src;
            int saw_xdigit = 0;
            uint32_t val = 0;
            int ch;
            while ((ch = tolower(*src++)) != '\0')
            {
                const char *pch = strchr(xdigits, ch);
                if (pch != NULL)
                {
                    val <<= 4;
                    val |= (pch - xdigits);
                    if (val > 0xffff)
                        return 0;
                    saw_xdigit = 1;
                    continue;
                }
                if (ch == ':')
                {
                    curtok = src;
                    if (!saw_xdigit)
                    {
                        if (colonp)
                            return 0;
                        colonp = tp;
                        continue;
                    }
                    else if (*src == '\0')
                    {
                        return 0;
                    }
                    if (tp + NS_INT16SZ > endp)
                        return 0;
                    *tp++ = (uint8_t) (val >> 8) & 0xff;
                    *tp++ = (uint8_t) val & 0xff;
                    saw_xdigit = 0;
                    val = 0;
                    continue;
                }
                if (ch == '.' && ((tp + NS_INADDRSZ) <= endp) &&
                        inet_pton4(curtok, (char*) tp) > 0)
                {
                    tp += NS_INADDRSZ;
                    saw_xdigit = 0;
                    break; /* '\0' was seen by inet_pton4(). */
                }
                return 0;
            }
            if (saw_xdigit)
            {
                if (tp + NS_INT16SZ > endp)
                    return 0;
                *tp++ = (uint8_t) (val >> 8) & 0xff;
                *tp++ = (uint8_t) val & 0xff;
            }
            if (colonp != NULL)
            {
                /*
                 * Since some memmove()'s erroneously fail to handle
                 * overlapping regions, we'll do the shift by hand.
                 */
                const int n = tp - colonp;

                if (tp == endp)
                    return 0;

                for (int i = 1; i <= n; i++)
                {
                    endp[-i] = colonp[n - i];
                    colonp[n - i] = 0;
                }
                tp = endp;
            }
            if (tp != endp)
                return 0;

            memcpy(dst, tmp, NS_IN6ADDRSZ);

            return 1;
        }


        int inet_pton(int af, const char *src, struct in6_addr *dst) {
            switch (af)
            {
            case AF_INET:
                return inet_pton4(src, (char *)dst);
            case AF_INET6:
                return inet_pton6(src, (char *)dst);
            default:
                return -1;
            }
        }
    #endif // __MINGW__

    int enet_initialize(void) {
        return 0;
    }

    void enet_deinitialize(void) {}

    enet_uint64 enet_host_random_seed(void) {
        return (enet_uint64) time(NULL);
    }

    int enet_address_set_host_ip_old(ENetAddress *address, const char *name) {
        if (!inet_pton(AF_INET6, name, &address->host)) {
            return -1;
        }

        return 0;
    }

    int enet_address_set_host_old(ENetAddress *address, const char *name) {
        struct addrinfo hints, *resultList = NULL, *result = NULL;

        memset(&hints, 0, sizeof(hints));
        hints.ai_family = AF_UNSPEC;

        if (getaddrinfo(name, NULL, &hints, &resultList) != 0) {
            return -1;
        }

        for (result = resultList; result != NULL; result = result->ai_next) {
            if (result->ai_addr != NULL && result->ai_addrlen >= sizeof(struct sockaddr_in)) {
                if (result->ai_family == AF_INET) {
                    struct sockaddr_in * sin = (struct sockaddr_in *) result->ai_addr;

                    ((uint32_t *)&address->host.s6_addr)[0] = 0;
                    ((uint32_t *)&address->host.s6_addr)[1] = 0;
                    ((uint32_t *)&address->host.s6_addr)[2] = htonl(0xffff);
                    ((uint32_t *)&address->host.s6_addr)[3] = sin->sin_addr.s_addr;

                    freeaddrinfo(resultList);

                    return 0;
                }
                else if(result->ai_family == AF_INET6) {
                    struct sockaddr_in6 * sin = (struct sockaddr_in6 *)result->ai_addr;

                    address->host = sin->sin6_addr;
                    address->sin6_scope_id = sin->sin6_scope_id;

                    freeaddrinfo(resultList);

                    return 0;
                }
            }
        }


        if (resultList != NULL) {
            freeaddrinfo(resultList);
        }

        return enet_address_set_host_ip(address, name);
    } /* enet_address_set_host_old */

    int enet_address_get_host_ip_old(const ENetAddress *address, char *name, size_t nameLength) {
        if (inet_ntop(AF_INET6, &address->host, name, nameLength) == NULL) {
            return -1;
        }

        return 0;
    }

    int enet_address_get_host_old(const ENetAddress *address, char *name, size_t nameLength) {
        struct sockaddr_in6 sin;
        int err;
        memset(&sin, 0, sizeof(struct sockaddr_in6));
        sin.sin6_family = AF_INET6;
        sin.sin6_port = ENET_HOST_TO_NET_16 (address->port);
        sin.sin6_addr = address->host;
        sin.sin6_scope_id = address->sin6_scope_id;
        err = getnameinfo((struct sockaddr *) &sin, sizeof(sin), name, nameLength, NULL, 0, NI_NAMEREQD);
        if (!err) {
            if (name != NULL && nameLength > 0 && !memchr(name, '\0', nameLength)) {
                return -1;
            }
            return 0;
        }
        if (err != EAI_NONAME) {
            return -1;
        }
        return enet_address_get_host_ip(address, name, nameLength);
    } /* enet_address_get_host_old */

    int enet_socket_bind(ENetSocket socket, const ENetAddress *address) {
        struct sockaddr_in6 sin;
        memset(&sin, 0, sizeof(struct sockaddr_in6));
        sin.sin6_family = AF_INET6;

        if (address != NULL) {
            sin.sin6_port       = ENET_HOST_TO_NET_16(address->port);
            sin.sin6_addr       = address->host;
            sin.sin6_scope_id   = address->sin6_scope_id;
        } else {
            sin.sin6_port       = 0;
            sin.sin6_addr       = ENET_HOST_ANY;
            sin.sin6_scope_id   = 0;
        }

        return bind(socket, (struct sockaddr *)&sin, sizeof(struct sockaddr_in6));
    }

    int enet_socket_get_address(ENetSocket socket, ENetAddress *address) {
        struct sockaddr_in6 sin;
        socklen_t sinLength = sizeof(struct sockaddr_in6);

        if (getsockname(socket, (struct sockaddr *) &sin, &sinLength) == -1) {
            return -1;
        }

        address->host           = sin.sin6_addr;
        address->port           = ENET_NET_TO_HOST_16(sin.sin6_port);
        address->sin6_scope_id  = sin.sin6_scope_id;

        return 0;
    }

    int enet_socket_listen(ENetSocket socket, int backlog) {
        return listen(socket, backlog < 0 ? SOMAXCONN : backlog);
    }

    ENetSocket enet_socket_create(ENetSocketType type) {
        return socket(PF_INET6, type == ENET_SOCKET_TYPE_DATAGRAM ? SOCK_DGRAM : SOCK_STREAM, 0);
    }

    int enet_socket_set_option(ENetSocket socket, ENetSocketOption option, int value) {
        int result = -1;

        switch (option) {
            case ENET_SOCKOPT_NONBLOCK:
                result = fcntl(socket, F_SETFL, (value ? O_NONBLOCK : 0) | (fcntl(socket, F_GETFL) & ~O_NONBLOCK));
                break;

            case ENET_SOCKOPT_BROADCAST:
                result = setsockopt(socket, SOL_SOCKET, SO_BROADCAST, (char *)&value, sizeof(int));
                break;

            case ENET_SOCKOPT_REUSEADDR:
                result = setsockopt(socket, SOL_SOCKET, SO_REUSEADDR, (char *)&value, sizeof(int));
                break;

            case ENET_SOCKOPT_RCVBUF:
                result = setsockopt(socket, SOL_SOCKET, SO_RCVBUF, (char *)&value, sizeof(int));
                break;

            case ENET_SOCKOPT_SNDBUF:
                result = setsockopt(socket, SOL_SOCKET, SO_SNDBUF, (char *)&value, sizeof(int));
                break;

            case ENET_SOCKOPT_RCVTIMEO: {
                struct timeval timeVal;
                timeVal.tv_sec  = value / 1000;
                timeVal.tv_usec = (value % 1000) * 1000;
                result = setsockopt(socket, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeVal, sizeof(struct timeval));
                break;
            }

            case ENET_SOCKOPT_SNDTIMEO: {
                struct timeval timeVal;
                timeVal.tv_sec  = value / 1000;
                timeVal.tv_usec = (value % 1000) * 1000;
                result = setsockopt(socket, SOL_SOCKET, SO_SNDTIMEO, (char *)&timeVal, sizeof(struct timeval));
                break;
            }

            case ENET_SOCKOPT_NODELAY:
                result = setsockopt(socket, IPPROTO_TCP, TCP_NODELAY, (char *)&value, sizeof(int));
                break;

            case ENET_SOCKOPT_IPV6_V6ONLY:
                result = setsockopt(socket, IPPROTO_IPV6, IPV6_V6ONLY, (char *)&value, sizeof(int));
                break;

            default:
                break;
        }
        return result == -1 ? -1 : 0;
    } /* enet_socket_set_option */

    int enet_socket_get_option(ENetSocket socket, ENetSocketOption option, int *value) {
        int result = -1;
        socklen_t len;

        switch (option) {
            case ENET_SOCKOPT_ERROR:
                len    = sizeof(int);
                result = getsockopt(socket, SOL_SOCKET, SO_ERROR, value, &len);
                break;

            default:
                break;
        }
        return result == -1 ? -1 : 0;
    }

    int enet_socket_connect(ENetSocket socket, const ENetAddress *address) {
        struct sockaddr_in6 sin;
        int result;

        memset(&sin, 0, sizeof(struct sockaddr_in6));

        sin.sin6_family     = AF_INET6;
        sin.sin6_port       = ENET_HOST_TO_NET_16(address->port);
        sin.sin6_addr       = address->host;
        sin.sin6_scope_id   = address->sin6_scope_id;

        result = connect(socket, (struct sockaddr *)&sin, sizeof(struct sockaddr_in6));
        if (result == -1 && errno == EINPROGRESS) {
            return 0;
        }

        return result;
    }

    ENetSocket enet_socket_accept(ENetSocket socket, ENetAddress *address) {
        int result;
        struct sockaddr_in6 sin;
        socklen_t sinLength = sizeof(struct sockaddr_in6);

        result = accept(socket,address != NULL ? (struct sockaddr *) &sin : NULL, address != NULL ? &sinLength : NULL);

        if (result == -1) {
            return ENET_SOCKET_NULL;
        }

        if (address != NULL) {
            address->host = sin.sin6_addr;
            address->port = ENET_NET_TO_HOST_16 (sin.sin6_port);
            address->sin6_scope_id = sin.sin6_scope_id;
        }

        return result;
    }

    int enet_socket_shutdown(ENetSocket socket, ENetSocketShutdown how) {
        return shutdown(socket, (int) how);
    }

    void enet_socket_destroy(ENetSocket socket) {
        if (socket != -1) {
            close(socket);
        }
    }

    int enet_socket_send(ENetSocket socket, const ENetAddress *address, const ENetBuffer *buffers, size_t bufferCount) {
        struct msghdr msgHdr;
        struct sockaddr_in6 sin;
        int sentLength;

        memset(&msgHdr, 0, sizeof(struct msghdr));

        if (address != NULL) {
            memset(&sin, 0, sizeof(struct sockaddr_in6));

            sin.sin6_family     = AF_INET6;
            sin.sin6_port       = ENET_HOST_TO_NET_16(address->port);
            sin.sin6_addr       = address->host;
            sin.sin6_scope_id   = address->sin6_scope_id;

            msgHdr.msg_name    = &sin;
            msgHdr.msg_namelen = sizeof(struct sockaddr_in6);
        }

        msgHdr.msg_iov    = (struct iovec *) buffers;
        msgHdr.msg_iovlen = bufferCount;

        sentLength = sendmsg(socket, &msgHdr, MSG_NOSIGNAL);

        if (sentLength == -1) {
            if (errno == EWOULDBLOCK) {
                return 0;
            }

            return -1;
        }

        return sentLength;
    } /* enet_socket_send */

    int enet_socket_receive(ENetSocket socket, ENetAddress *address, ENetBuffer *buffers, size_t bufferCount) {
        struct msghdr msgHdr;
        struct sockaddr_in6 sin;
        int recvLength;

        memset(&msgHdr, 0, sizeof(struct msghdr));

        if (address != NULL) {
            msgHdr.msg_name    = &sin;
            msgHdr.msg_namelen = sizeof(struct sockaddr_in6);
        }

        msgHdr.msg_iov    = (struct iovec *) buffers;
        msgHdr.msg_iovlen = bufferCount;

        recvLength = recvmsg(socket, &msgHdr, MSG_NOSIGNAL);

        if (recvLength == -1) {
            if (errno == EWOULDBLOCK) {
                return 0;
            }

            return -1;
        }

        if (msgHdr.msg_flags & MSG_TRUNC) {
            return -1;
        }

        if (address != NULL) {
            address->host           = sin.sin6_addr;
            address->port           = ENET_NET_TO_HOST_16(sin.sin6_port);
            address->sin6_scope_id  = sin.sin6_scope_id;
        }

        return recvLength;
    } /* enet_socket_receive */

    int enet_socketset_select(ENetSocket maxSocket, ENetSocketSet *readSet, ENetSocketSet *writeSet, enet_uint32 timeout) {
        struct timeval timeVal;

        timeVal.tv_sec  = timeout / 1000;
        timeVal.tv_usec = (timeout % 1000) * 1000;

        return select(maxSocket + 1, readSet, writeSet, NULL, &timeVal);
    }

    int enet_socket_wait(ENetSocket socket, enet_uint32 *condition, enet_uint64 timeout) {
        struct pollfd pollSocket;
        int pollCount;

        pollSocket.fd     = socket;
        pollSocket.events = 0;

        if (*condition & ENET_SOCKET_WAIT_SEND) {
            pollSocket.events |= POLLOUT;
        }

        if (*condition & ENET_SOCKET_WAIT_RECEIVE) {
            pollSocket.events |= POLLIN;
        }

        pollCount = poll(&pollSocket, 1, timeout);

        if (pollCount < 0) {
            if (errno == EINTR && *condition & ENET_SOCKET_WAIT_INTERRUPT) {
                *condition = ENET_SOCKET_WAIT_INTERRUPT;

                return 0;
            }

            return -1;
        }

        *condition = ENET_SOCKET_WAIT_NONE;

        if (pollCount == 0) {
            return 0;
        }

        if (pollSocket.revents & POLLOUT) {
            *condition |= ENET_SOCKET_WAIT_SEND;
        }

        if (pollSocket.revents & POLLIN) {
            *condition |= ENET_SOCKET_WAIT_RECEIVE;
        }

        return 0;
    } /* enet_socket_wait */

    #endif // !_WIN32


// =======================================================================//
// !
// ! Platform Specific (Win)
// !
// =======================================================================//

    #ifdef _WIN32

    int enet_initialize(void) {
        WORD versionRequested = MAKEWORD(1, 1);
        WSADATA wsaData;

        if (WSAStartup(versionRequested, &wsaData)) {
            return -1;
        }

        if (LOBYTE(wsaData.wVersion) != 1 || HIBYTE(wsaData.wVersion) != 1) {
            WSACleanup();
            return -1;
        }

        timeBeginPeriod(1);
        return 0;
    }

    void enet_deinitialize(void) {
        timeEndPeriod(1);
        WSACleanup();
    }

    enet_uint64 enet_host_random_seed(void) {
        return (enet_uint64) timeGetTime();
    }

    int enet_address_set_host_ip_old(ENetAddress *address, const char *name) {
        enet_uint8 vals[4] = { 0, 0, 0, 0 };
        int i;

        for (i = 0; i < 4; ++i) {
            const char *next = name + 1;
            if (*name != '0') {
                long val = strtol(name, (char **) &next, 10);
                if (val < 0 || val > 255 || next == name || next - name > 3) {
                    return -1;
                }
                vals[i] = (enet_uint8) val;
            }

            if (*next != (i < 3 ? '.' : '\0')) {
                return -1;
            }
            name = next + 1;
        }

        memcpy(&address->host, vals, sizeof(enet_uint32));
        return 0;
    }

    int enet_address_set_host_old(ENetAddress *address, const char *name) {
        struct hostent *hostEntry = NULL;
        hostEntry = gethostbyname(name);

        if (hostEntry == NULL || hostEntry->h_addrtype != AF_INET) {
            if (!inet_pton(AF_INET6, name, &address->host)) {
                return -1;
            }

            return 0;
        }

        ((enet_uint32 *)&address->host.s6_addr)[0] = 0;
        ((enet_uint32 *)&address->host.s6_addr)[1] = 0;
        ((enet_uint32 *)&address->host.s6_addr)[2] = htonl(0xffff);
        ((enet_uint32 *)&address->host.s6_addr)[3] = *(enet_uint32 *)hostEntry->h_addr_list[0];

        return 0;
    }

    int enet_address_get_host_ip_old(const ENetAddress *address, char *name, size_t nameLength) {
        if (inet_ntop(AF_INET6, (PVOID)&address->host, name, nameLength) == NULL) {
            return -1;
        }

        return 0;
    }

    int enet_address_get_host_old(const ENetAddress *address, char *name, size_t nameLength) {
        struct in6_addr in;
        struct hostent *hostEntry = NULL;
        in = address->host;
        hostEntry = gethostbyaddr((char *)&in, sizeof(struct in6_addr), AF_INET6);
        if (hostEntry == NULL) {
            return enet_address_get_host_ip(address, name, nameLength);
        } else {
            size_t hostLen = strlen(hostEntry->h_name);
            if (hostLen >= nameLength) {
                return -1;
            }
            memcpy(name, hostEntry->h_name, hostLen + 1);
        }
        return 0;
    }

    int enet_socket_bind(ENetSocket socket, const ENetAddress *address) {
        struct sockaddr_in6 sin;
        memset(&sin, 0, sizeof(struct sockaddr_in6));
        sin.sin6_family = AF_INET6;

        if (address != NULL) {
            sin.sin6_port       = ENET_HOST_TO_NET_16 (address->port);
            sin.sin6_addr       = address->host;
            sin.sin6_scope_id   = address->sin6_scope_id;
        } else   {
            sin.sin6_port       = 0;
            sin.sin6_addr       = in6addr_any;
            sin.sin6_scope_id   = 0;
        }

        return 0;
        //return bind(socket, (struct sockaddr *) &sin, sizeof(struct sockaddr_in6)) == SOCKET_ERROR ? -1 : 0;
    }

    int enet_socket_get_address(ENetSocket socket, ENetAddress *address) {
        struct sockaddr_in6 sin;
        int sinLength = sizeof(struct sockaddr_in6);

        if (getsockname(socket, (struct sockaddr *) &sin, &sinLength) == -1) {
            return -1;
        }

        address->host           = sin.sin6_addr;
        address->port           = ENET_NET_TO_HOST_16(sin.sin6_port);
        address->sin6_scope_id  = sin.sin6_scope_id;

        return 0;
    }

    int enet_socket_listen(ENetSocket socket, int backlog) {
        return listen(socket, backlog < 0 ? SOMAXCONN : backlog) == SOCKET_ERROR ? -1 : 0;
    }

    ENetSocket enet_socket_create(ENetSocketType type) {
        return socket(PF_INET6, type == ENET_SOCKET_TYPE_DATAGRAM ? SOCK_DGRAM : SOCK_STREAM, 0);
    }

    int enet_socket_set_option(ENetSocket socket, ENetSocketOption option, int value) {
        int result = SOCKET_ERROR;

        switch (option) {
            case ENET_SOCKOPT_NONBLOCK: {
                u_long nonBlocking = (u_long) value;
                result = ioctlsocket(socket, FIONBIO, &nonBlocking);
                break;
            }

            case ENET_SOCKOPT_BROADCAST:
                result = setsockopt(socket, SOL_SOCKET, SO_BROADCAST, (char *)&value, sizeof(int));
                break;

            case ENET_SOCKOPT_REUSEADDR:
                result = setsockopt(socket, SOL_SOCKET, SO_REUSEADDR, (char *)&value, sizeof(int));
                break;

            case ENET_SOCKOPT_RCVBUF:
                result = setsockopt(socket, SOL_SOCKET, SO_RCVBUF, (char *)&value, sizeof(int));
                break;

            case ENET_SOCKOPT_SNDBUF:
                result = setsockopt(socket, SOL_SOCKET, SO_SNDBUF, (char *)&value, sizeof(int));
                break;

            case ENET_SOCKOPT_RCVTIMEO:
                result = setsockopt(socket, SOL_SOCKET, SO_RCVTIMEO, (char *)&value, sizeof(int));
                break;

            case ENET_SOCKOPT_SNDTIMEO:
                result = setsockopt(socket, SOL_SOCKET, SO_SNDTIMEO, (char *)&value, sizeof(int));
                break;

            case ENET_SOCKOPT_NODELAY:
                result = setsockopt(socket, IPPROTO_TCP, TCP_NODELAY, (char *)&value, sizeof(int));
                break;

            case ENET_SOCKOPT_IPV6_V6ONLY:
                result = setsockopt(socket, IPPROTO_IPV6, IPV6_V6ONLY, (char *)&value, sizeof(int));
                break;

            default:
                break;
        }
        return result == SOCKET_ERROR ? -1 : 0;
    } /* enet_socket_set_option */

    int enet_socket_get_option(ENetSocket socket, ENetSocketOption option, int *value) {
        int result = SOCKET_ERROR, len;

        switch (option) {
            case ENET_SOCKOPT_ERROR:
                len    = sizeof(int);
                result = getsockopt(socket, SOL_SOCKET, SO_ERROR, (char *)value, &len);
                break;

            default:
                break;
        }
        return result == SOCKET_ERROR ? -1 : 0;
    }

    int enet_socket_connect(ENetSocket socket, const ENetAddress *address) {
        struct sockaddr_in6 sin;
        int result;

        memset(&sin, 0, sizeof(struct sockaddr_in6));

        sin.sin6_family     = AF_INET6;
        sin.sin6_port       = ENET_HOST_TO_NET_16(address->port);
        sin.sin6_addr       = address->host;
        sin.sin6_scope_id   = address->sin6_scope_id;

        result = connect(socket, (struct sockaddr *) &sin, sizeof(struct sockaddr_in6));
        if (result == SOCKET_ERROR && WSAGetLastError() != WSAEWOULDBLOCK) {
            return -1;
        }

        return 0;
    }

    ENetSocket enet_socket_accept(ENetSocket socket, ENetAddress *address) {
        SOCKET result;
        struct sockaddr_in6 sin;
        int sinLength = sizeof(struct sockaddr_in6);

        result = accept(socket, address != NULL ? (struct sockaddr *)&sin : NULL, address != NULL ? &sinLength : NULL);

        if (result == INVALID_SOCKET) {
            return ENET_SOCKET_NULL;
        }

        if (address != NULL) {
            address->host           = sin.sin6_addr;
            address->port           = ENET_NET_TO_HOST_16(sin.sin6_port);
            address->sin6_scope_id  = sin.sin6_scope_id;
        }

        return result;
    }

    int enet_socket_shutdown(ENetSocket socket, ENetSocketShutdown how) {
        return shutdown(socket, (int) how) == SOCKET_ERROR ? -1 : 0;
    }

    void enet_socket_destroy(ENetSocket socket) {
        if (socket != INVALID_SOCKET) {
            closesocket(socket);
        }
    }

    int enet_socket_send(ENetSocket socket, const ENetAddress *address, const ENetBuffer *buffers, size_t bufferCount) {
        struct sockaddr_in6 sin;
        DWORD sentLength;

        if (address != NULL) {
            memset(&sin, 0, sizeof(struct sockaddr_in6));

            sin.sin6_family     = AF_INET6;
            sin.sin6_port       = ENET_HOST_TO_NET_16(address->port);
            sin.sin6_addr       = address->host;
            sin.sin6_scope_id   = address->sin6_scope_id;
        }

        if (WSASendTo(socket,
            (LPWSABUF) buffers,
            (DWORD) bufferCount,
            &sentLength,
            0,
            address != NULL ? (struct sockaddr *) &sin : NULL,
            address != NULL ? sizeof(struct sockaddr_in6) : 0,
            NULL,
            NULL) == SOCKET_ERROR
        ) {
            return (WSAGetLastError() == WSAEWOULDBLOCK) ? 0 : -1;
        }

        return (int) sentLength;
    }

    int enet_socket_receive(ENetSocket socket, ENetAddress *address, ENetBuffer *buffers, size_t bufferCount) {
        INT sinLength = sizeof(struct sockaddr_in6);
        DWORD flags   = 0, recvLength;
        struct sockaddr_in6 sin;

        if (WSARecvFrom(socket,
            (LPWSABUF) buffers,
            (DWORD) bufferCount,
            &recvLength,
            &flags,
            address != NULL ? (struct sockaddr *) &sin : NULL,
            address != NULL ? &sinLength : NULL,
            NULL,
            NULL) == SOCKET_ERROR
        ) {
            switch (WSAGetLastError()) {
                case WSAEWOULDBLOCK:
                case WSAECONNRESET:
                    return 0;
            }

            return -1;
        }

        if (flags & MSG_PARTIAL) {
            return -1;
        }

        if (address != NULL) {
            address->host           = sin.sin6_addr;
            address->port           = ENET_NET_TO_HOST_16(sin.sin6_port);
            address->sin6_scope_id  = sin.sin6_scope_id;
        }

        return (int) recvLength;
    } /* enet_socket_receive */

    int enet_socketset_select(ENetSocket maxSocket, ENetSocketSet *readSet, ENetSocketSet *writeSet, enet_uint32 timeout) {
        struct timeval timeVal;

        timeVal.tv_sec  = timeout / 1000;
        timeVal.tv_usec = (timeout % 1000) * 1000;

        return select(maxSocket + 1, readSet, writeSet, NULL, &timeVal);
    }

    int enet_socket_wait(ENetSocket socket, enet_uint32 *condition, enet_uint64 timeout) {
        fd_set readSet, writeSet;
        struct timeval timeVal;
        int selectCount;

        timeVal.tv_sec  = timeout / 1000;
        timeVal.tv_usec = (timeout % 1000) * 1000;

        FD_ZERO(&readSet);
        FD_ZERO(&writeSet);

        if (*condition & ENET_SOCKET_WAIT_SEND) {
            FD_SET(socket, &writeSet);
        }

        if (*condition & ENET_SOCKET_WAIT_RECEIVE) {
            FD_SET(socket, &readSet);
        }

        selectCount = select(socket + 1, &readSet, &writeSet, NULL, &timeVal);

        if (selectCount < 0) {
            return -1;
        }

        *condition = ENET_SOCKET_WAIT_NONE;

        if (selectCount == 0) {
            return 0;
        }

        if (FD_ISSET(socket, &writeSet)) {
            *condition |= ENET_SOCKET_WAIT_SEND;
        }

        if (FD_ISSET(socket, &readSet)) {
            *condition |= ENET_SOCKET_WAIT_RECEIVE;
        }

        return 0;
    } /* enet_socket_wait */

    #endif // _WIN32


#ifdef __cplusplus
}
#endif

#endif // ENET_IMPLEMENTATION
#endif // ENET_INCLUDE_H
```

`include/networking/networking.hpp`:

```hpp
#pragma once
#include "imports.hpp"

#include "networking/data/packet.h"
#include "networking/data/data.hpp"

class networking : public c_singleton<networking>
{
private:
    ENetAddress address;
    ENetEvent event;
    ENetPeer* peer;
    ENetHost* client;

    UserData* client_user_data;

    char* nemo_server_ip = "127.0.0.1";
    int nemo_server_port = 3005;

    // NETWORKING_PROTOCOL_TO_DEFINITION
    typedef enum _NetworkingMessageTypes {
        NETWORKING_ASK_CLIENT_USERNAME = 1,
        NETWORKING_RESPONSE_SERVER_USERNAME,
        NETWORKING_RESPONSE_CLIENT_LOGGED_IN,
        NETWORKING_ASK_SERVER_SEND_CHATMESSAGE,
        NETWORKING_BROADCAST_CHATMESSAGE,
    };
public:
    void start();
    void pulse();

    void send_packet(Network::Packet buffer);
};

```

`include/pointers/module.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <winternl.h>
#include <utility>
#include <optional>
#include <string>
#include <intrin.h>
namespace memory {
	class module_t
	{
	public:
		explicit module_t(HMODULE mod) :
			m_start(reinterpret_cast<uintptr_t>(mod))
		{
			auto module_dos_header = PIMAGE_DOS_HEADER(mod);
			auto nt_file_header = PIMAGE_NT_HEADERS(PBYTE(mod) + module_dos_header->e_lfanew);

			m_end = nt_file_header->OptionalHeader.SizeOfImage;
		}

		explicit module_t(std::pair<HMODULE, size_t> module) :
			m_start(reinterpret_cast<uintptr_t>(module.first)),
			m_end(module.second)
		{}

		explicit module_t(std::string mod) :
			module_t(peb_get_module(std::wstring(mod.begin(), mod.end())))
		{ }

		explicit module_t(const wchar_t* mod) :
			module_t(peb_get_module(mod))
		{ }

		explicit module_t(std::nullptr_t) :
			module_t(GetModuleHandleW(nullptr))
		{ }

		uintptr_t base()
		{
			return m_start;
		}

		std::size_t size()
		{
			return m_end;
		}

		inline static std::pair<HMODULE, size_t> peb_get_module(std::optional<std::wstring> name)
		{
			auto peb = reinterpret_cast<PEB*>(__readgsqword(0x60));

			auto head = peb->Ldr->InMemoryOrderModuleList;
			auto curr = head;

			if (!name)
			{
				wchar_t file_name[MAX_PATH];
				if (GetModuleFileNameW(GetModuleHandleW(nullptr), file_name, MAX_PATH))
					*name = file_name;
			}

			while (curr.Flink != head.Blink)
			{
				auto mod = reinterpret_cast<LDR_DATA_TABLE_ENTRY*>((uintptr_t)curr.Flink - 0x10);
				auto base_dll_name = *reinterpret_cast<UNICODE_STRING*>(&mod->Reserved4);
				if (base_dll_name.Buffer)
				{
					if (base_dll_name.Buffer == *name)
						return { reinterpret_cast<HMODULE>(mod->DllBase), reinterpret_cast<size_t>(mod->Reserved3[1]) };

				}

				curr = *curr.Flink;
			}

			return {};
		}

	private:
		uintptr_t	m_start;
		std::size_t	m_end;
	};
}
```

`include/pointers/pointers.hpp`:

```hpp
#pragma once
#include "imports.hpp"
#include "module.hpp"
#include "scanner.hpp"

#include <gta/game_classes.hpp>

#include <Psapi.h>
#pragma comment (lib,"psapi.lib")

using namespace std;
class pointers : public c_singleton<pointers>
{
public:
	/* typedefs*/
	using event_gun_shot_t = __int64(*)(__int64 a1, __int64* a2);
	using get_bone_position_t = void*(__fastcall*)(__int64 ped, __int64 pos_out, int32_t bone);
	using world_to_screen_t = bool(__fastcall*)(Vector3* world_position, float* out_x, float* out_y);
	using pointer_to_handle_t = int32_t(*)(void* ptr);

	memory::module_t gta5_module = memory::module_t(nullptr);
	memory::module_t ragemp_module = memory::module_t(nullptr);

	game_state_t* ptr_gta_game_state = nullptr;
	CWorldFactory* ptr_gta_world_factory = nullptr;
	CViewPort* ptr_gta_viewport = nullptr;
	uintptr_t ptr_gta_camera = 0;
	get_bone_position_t ptr_gta_get_bone_position = nullptr;
	world_to_screen_t ptr_gta_world_to_screen = nullptr;
	pointer_to_handle_t ptr_gta_pointer_to_handle = nullptr;
	event_gun_shot_t ptr_gta_event_shot = nullptr;
	std::string* ptr_ragemp_get_name = nullptr;

	void initialize();
};

```

`include/pointers/scanner.hpp`:

```hpp
#pragma once
#include "imports.hpp"
#include "module.hpp"
namespace memory {
	inline bool correlate(std::uint8_t* target, const std::optional<std::uint8_t>* sig, std::size_t length)
	{

		for (std::size_t i = 0; i < length; ++i)
		{
			if (sig[i] && *sig[i] != target[i])
				return false;
		}

		return true;
	}

	inline int pattern_id = 0;

	template <typename type = uintptr_t>
	inline type find_pattern(module_t mod, std::string name, std::string pattern, int offset = 0)
	{
		static auto char_to_integer = [](const char c)
		{
			if (c >= '0' && c <= '9')
				return c - '0';
			if (c >= 'A' && c <= 'F')
				return c - 'A' + 10;
			if (c >= 'a' && c <= 'f')
				return c - 'a' + 10;

			return -1;
		};

		std::vector<std::optional<uint8_t>> bytes;

		std::istringstream sigstream(pattern);
		std::vector<std::string> pattern_array
		{
			std::istream_iterator<std::string>(sigstream), {}
		};

		for (auto& byte : pattern_array)
		{
			if (byte == "?")
			{
				bytes.push_back(std::nullopt);
				continue;
			}

			if (auto c1 = char_to_integer(byte[0]); c1 != -1)
			{
				if (auto c2 = char_to_integer(byte[1]); c2 != -1)
				{
					bytes.emplace_back(
						static_cast<uint8_t>(c1 * 0x10 + c2)
					);
				}
			}
		}

		auto data = bytes.data();
		auto length = bytes.size();

		pattern_id++;

		auto base = mod.base();
		for (size_t i = 0; i < mod.size(); i++)
			if (correlate(reinterpret_cast<uint8_t*>(base + i), data, length)) {
				Log::Debug("[+] Memory >>", name, (base + i + offset), "#" + std::to_string(pattern_id));
				return (type)(base + i + offset);
			}

		Log::Error("Failed to find signature pattern:", name);

		return (type)(nullptr);
	}

	inline bool can_read_ptr(void* ptr)
	{
		MEMORY_BASIC_INFORMATION mbi;
		VirtualQuery(ptr, &mbi, sizeof(mbi));

		return (!(mbi.Protect & PAGE_GUARD) && mbi.Protect != PAGE_NOACCESS && mbi.State == MEM_COMMIT &&
			mbi.Protect & (PAGE_READONLY | PAGE_EXECUTE_READ | PAGE_READWRITE | PAGE_EXECUTE_READWRITE));
	}


	template <typename type = uintptr_t>
	inline type find_pattern_outside_module(std::string name, std::string pattern, int offset = 0)
	{
		static auto char_to_integer = [](const char c)
		{
			if (c >= '0' && c <= '9')
				return c - '0';
			if (c >= 'A' && c <= 'F')
				return c - 'A' + 10;
			if (c >= 'a' && c <= 'f')
				return c - 'a' + 10;

			return -1;
		};

		std::vector<std::optional<uint8_t>> bytes;

		std::istringstream sigstream(pattern);
		std::vector<std::string> pattern_array
		{
			std::istream_iterator<std::string>(sigstream), {}
		};

		for (auto& byte : pattern_array)
		{
			if (byte == "?")
			{
				bytes.push_back(std::nullopt);
				continue;
			}

			if (auto c1 = char_to_integer(byte[0]); c1 != -1)
			{
				if (auto c2 = char_to_integer(byte[1]); c2 != -1)
				{
					bytes.emplace_back(
						static_cast<uint8_t>(c1 * 0x10 + c2)
					);
				}
			}
		}

		auto data = bytes.data();
		auto length = bytes.size();

		pattern_id++;

		auto process_handle = GetCurrentProcess();

		HMODULE process_modules[1024];
		MODULEINFO module_information;
		DWORD cb_needed;

		if (K32EnumProcessModules(process_handle, process_modules, sizeof(process_modules), &cb_needed))
		{
			for (int i = 0; i < cb_needed / sizeof(HMODULE); i++)
			{
				if (K32GetModuleInformation(process_handle, process_modules[i], &module_information, sizeof(MODULEINFO))) {
					auto base_address = (uintptr_t)module_information.lpBaseOfDll;
					auto base_size = (uintptr_t)module_information.SizeOfImage;

					for (size_t i = 0; i < base_size; i++)
						if (can_read_ptr(reinterpret_cast<uint8_t*>(base_address + i))) {
							if (correlate(reinterpret_cast<uint8_t*>(base_address + i), data, length)) {
								Log::Debug("[+] Memory >>", name, (base_address + i + offset), "#" + std::to_string(pattern_id));
								return (type)(base_address + i + offset);
							}
						}
				}
			}
		}

		Log::Error("Failed to find signature pattern:", name);

		return (type)(nullptr);
	}

	template <typename type>
	type as_relative(type address, int offset = 3)
	{
		return reinterpret_cast<type>(reinterpret_cast<uintptr_t>(address) + *reinterpret_cast<int*>(reinterpret_cast<uintptr_t>(address) + offset) + (offset + 4i32));
	}

	template <typename type = uintptr_t>
	type as_relative(void* address, int offset = 3)
	{
		return reinterpret_cast<type>(reinterpret_cast<uintptr_t>(address) + *reinterpret_cast<int*>(reinterpret_cast<uintptr_t>(address) + offset) + (offset + 4i32));
	}

	template <typename type = uintptr_t>
	type as_relative(uintptr_t address, int offset = 3)
	{
		return (type)(address + *reinterpret_cast<int*>(address + offset) + (offset + 4i32));
	}
}
```

`include/renderer/renderer.hpp`:

```hpp
#pragma once
#include "imports.hpp"

#define RENDERER
using namespace std;

class renderer : public c_singleton<renderer>
{
private:
	typedef HRESULT(__stdcall* d3d11_present_t) (IDXGISwapChain* swap_chain, UINT sync_interval, UINT flags);

private:
	DWORD_PTR* v_table_swap_chain = nullptr;
	DWORD_PTR* v_table_device = nullptr;
	DWORD_PTR* v_table_device_context = nullptr;

public:
	// needs to be public to get accessed
	d3d11_present_t o_d3d11_present = nullptr;

	std::once_flag already_initialized;

	ID3D11Device* ptr_device = nullptr;
	ID3D11DeviceContext* ptr_device_context = nullptr;
	IDXGISwapChain* ptr_swap_chain = nullptr;

	ID3D11RenderTargetView* target_view;
	IFW1FontWrapper* font_wrapper = NULL;

	bool initialize();
};
```

`include/utilities/security.hpp`:

```hpp
#pragma once
#include "imports.hpp"
#include "anticheat/detections.hpp"

using namespace std;

class security : public c_singleton<security>
{
private:
	enum thread_info_class { thread_hide_from_debugger = 0x11 };
	
	typedef NTSTATUS(__stdcall* nt_query_information_process_t)(_In_ HANDLE, _In_  unsigned int, _Out_ PVOID, _In_ ULONG, _Out_ PULONG);
	typedef NTSTATUS(__stdcall* nt_set_information_thread_t)(_In_ HANDLE, _In_ thread_info_class, _In_ PVOID, _In_ ULONG);

	bool check_debug_string();
	bool check_remote_debugger();
	bool check_registry();
	std::string check_blacklisted_windows();
	void check_heartbeart();
public:
	void initialize();
	void hide_thread();
};
```

`include/vendor/alt/alt-log.hpp`:

```hpp
#pragma once

#include <iostream>
#include <fstream>
#include <string>
#include <iomanip>
#include <codecvt>
#include <vector>
#include <memory>

#define ALT_LOG_IMPL

namespace alt
{
	class Log : protected std::ostream
	{
	public:
		enum Color
		{
			BLACK, LBLACK,
			RED, LRED,
			GREEN, LGREEN,
			BLUE, LBLUE,
			YELLOW, LYELLOW,
			MAGENTA, LMAGENTA,
			CYAN, LCYAN,
			WHITE, LWHITE
		};

		using StdStreamManip = std::ostream& (*)(std::ostream&);
		using LogManip = Log & (*)(Log&);

		Log& Write(const std::string& val)
		{
			for (auto& s : streams)
				s->Put(val);

			return *this;
		}

		template<class T>
		Log& Put(const T& val)
		{
			std::cout << val;
			return *this;
		}

		Log& Put(bool val)
		{
			return Put(val ? "true" : "false");
		}

		Log& Put(LogManip val)
		{
			return val(*this);
		}

		Log& Put(StdStreamManip val)
		{
			std::cout << val;
			return *this;
		}

		template<class... Args>
		Log& Put(LogManip val, const Args&... args)
		{
			return Put(val).Put(args...);
		}

		template<class T, class... Args>
		Log& Put(const T& val, const Args&... args)
		{
			return Put(val).Put(" ").Put(args...);
		}

		Log& PutTime()
		{
			const time_t t = time(nullptr);
			tm tt;

			localtime_s(&tt, &t);

			std::cout << std::put_time(&tt, "[%H:%M:%S]") << std::flush;
			return *this;
		}

		Log& PutColor(Color col)
		{
			*this << std::flush;

			for (auto& s : streams)
				s->PutColor(col);

			return *this;
		}

		template<class T> Log& operator<<(const T& val) { return Put(val); }
		Log& operator<<(StdStreamManip val) { return Put(val); }
		Log& operator<<(LogManip val) { return Put(val); }

		// Manipulators
		static Log& Black(Log& log) { return log.PutColor(BLACK); }
		static Log& LBlack(Log& log) { return log.PutColor(LBLACK); }
		static Log& Red(Log& log) { return log.PutColor(RED); }
		static Log& LRed(Log& log) { return log.PutColor(LRED); }
		static Log& Green(Log& log) { return log.PutColor(GREEN); }
		static Log& LGreen(Log& log) { return log.PutColor(LGREEN); }
		static Log& Blue(Log& log) { return log.PutColor(BLUE); }
		static Log& LBlue(Log& log) { return log.PutColor(LBLUE); }
		static Log& Yellow(Log& log) { return log.PutColor(YELLOW); }
		static Log& LYellow(Log& log) { return log.PutColor(LYELLOW); }
		static Log& Magenta(Log& log) { return log.PutColor(MAGENTA); }
		static Log& LMagenta(Log& log) { return log.PutColor(LMAGENTA); }
		static Log& Cyan(Log& log) { return log.PutColor(CYAN); }
		static Log& LCyan(Log& log) { return log.PutColor(LCYAN); }
		static Log& White(Log& log) { return log.PutColor(WHITE); }
		static Log& LWhite(Log& log) { return log.PutColor(LWHITE); }
		static Log& Endl(Log& log) { return log.Put(std::endl).Put(std::dec).PutColor(WHITE); }
		static Log& Time(Log& log) { return log.PutTime(); }

		struct Log_Base
		{
			virtual Log& Begin() const = 0;
			template<class... Args> Log& operator()(const Args&... args) const { return Begin().Put<Args...>(args...).Put(Endl); }
			template<class T> Log& operator<<(const T& val) const { return Begin().Put<T>(val); }
		};

		static constexpr struct Log_Raw : public Log_Base {
			Log& Begin() const override { return Instance(); }
		} Raw{};

		static constexpr struct Log_Info : public Log_Base {
			Log& Begin() const override { return Instance().Put(LWhite, Time, " "); }
		} Info{};

		static constexpr struct Log_Warning : public Log_Base {
			Log& Begin() const override { return Instance().Put(LYellow, Time, " [Warning] "); }
		} Warning{};

		static constexpr struct Log_Error : public Log_Base {
			Log& Begin() const override { return Instance().Put(Red, Time, " [Error] "); }
		} Error{};

		static constexpr struct Log_Debug : public Log_Base {
		private:
			Log& Begin() const override { return Instance().Put(LCyan, Time, " [Debug] "); }
		} Debug{};

		static Log& Instance() noexcept
		{
			static Log s;
			return s;
		}

		class Stream
		{
		public:
			virtual Stream& Put(const std::string& val) = 0;
			virtual Stream& PutColor(Color color) = 0;
		};

		void AddOut(Stream* stream) { streams.emplace_back(stream); }

		static void Push(Stream* stream) { Instance().AddOut(stream); }

		class ConsoleStream : public Stream
		{
		public:
			Stream& Put(const std::string& val) override
			{
				std::cout << val;

				return *this;
			}

			Stream& PutColor(Color val) override
			{
#ifdef _WIN32
				WORD col = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;

				switch (val)
				{
				case BLACK:
					col = 0;
					break;
				case LBLACK:
					col = FOREGROUND_INTENSITY;
					break;
				case RED:
					col = FOREGROUND_RED;
					break;
				case LRED:
					col = FOREGROUND_RED | FOREGROUND_INTENSITY;
					break;
				case GREEN:
					col = FOREGROUND_GREEN;
					break;
				case LGREEN:
					col = FOREGROUND_GREEN | FOREGROUND_INTENSITY;
					break;
				case BLUE:
					col = FOREGROUND_BLUE;
					break;
				case LBLUE:
					col = FOREGROUND_BLUE | FOREGROUND_INTENSITY;
					break;
				case YELLOW:
					col = FOREGROUND_RED | FOREGROUND_GREEN;
					break;
				case LYELLOW:
					col = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_INTENSITY;
					break;
				case MAGENTA:
					col = FOREGROUND_RED | FOREGROUND_BLUE;
					break;
				case LMAGENTA:
					col = FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY;
					break;
				case CYAN:
					col = FOREGROUND_GREEN | FOREGROUND_BLUE;
					break;
				case LCYAN:
					col = FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY;
					break;
				case WHITE:
					col = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
					break;
				case LWHITE:
					col = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY;
					break;
				}

				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), col);
#else
				switch (val)
				{
				case BLACK:
					std::cout << "\033[30m";
					break;
				case LBLACK:
					std::cout << "\033[90m";
					break;
				case RED:
					std::cout << "\033[31m";
					break;
				case LRED:
					std::cout << "\033[91m";
					break;
				case GREEN:
					std::cout << "\033[32m";
					break;
				case LGREEN:
					std::cout << "\033[92m";
					break;
				case BLUE:
					std::cout << "\033[34m";
					break;
				case LBLUE:
					std::cout << "\033[94m";
					break;
				case YELLOW:
					std::cout << "\033[33m";
					break;
				case LYELLOW:
					std::cout << "\033[93m";
					break;
				case MAGENTA:
					std::cout << "\033[35m";
					break;
				case LMAGENTA:
					std::cout << "\033[95m";
					break;
				case CYAN:
					std::cout << "\033[36m";
					break;
				case LCYAN:
					std::cout << "\033[96m";
					break;
				case WHITE:
					std::cout << "\033[37m";
					break;
				case LWHITE:
					std::cout << "\033[97m";
					break;
				}
#endif // _WIN32

				return *this;
			}

		};

		class FileStream : public Stream
		{
			std::ofstream file;
		public:
			FileStream(const std::string& fileName) : file(fileName) { }
#if _MSC_VER
			FileStream(const std::wstring& fileName) : file(fileName) { }
#endif

			Stream& Put(const std::string& val) override
			{
				//file << val << std::flush;
				return *this;
			}

			Stream& PutColor(Color val) override { return *this; }
		};

	private:
		class Buffer : public std::streambuf
		{
			static const std::size_t BUF_SIZE = 1024;

			char buf[BUF_SIZE];

		public:
			using Traits = std::char_traits<char>;

			Buffer() { setp(buf, buf + BUF_SIZE); }

		protected:
			virtual Traits::int_type overflow(Traits::int_type c = Traits::eof()) override
			{
				put(pbase(), pptr());
				if (c != Traits::eof()) {
					char c2 = c;
					put(&c2, &c2 + 1);
				}
				setp(buf, buf + BUF_SIZE);

				return c;
			}

			virtual int sync() override
			{
				put(pbase(), pptr());
				setp(buf, buf + BUF_SIZE);
				return 0;
			}

		private:
			void put(const char* begin, const char* end) { Log::Instance().Write(std::string(begin, end)); }
		};

		Log() :std::ostream(&buf) { };
		Log(const Log&) = delete;
		Log& operator=(const Log&) = delete;

		Buffer buf;
		std::vector<std::unique_ptr<Stream>> streams;
	};
}

```

`include/vendor/fontwrapper/CFW1ColorRGBA.h`:

```h
// CFW1ColorRGBA.h

#ifndef IncludeGuard__FW1_CFW1ColorRGBA
#define IncludeGuard__FW1_CFW1ColorRGBA

#include "CFW1Object.h"


namespace FW1FontWrapper {


// A color
class CFW1ColorRGBA : public CFW1Object<IFW1ColorRGBA> {
	public:
		// IUnknown
		virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
		
		// IFW1Color32
		virtual void STDMETHODCALLTYPE SetColor(UINT32 Color);
		virtual void STDMETHODCALLTYPE SetColor(FLOAT Red, FLOAT Green, FLOAT Blue, FLOAT Alpha);
		virtual void STDMETHODCALLTYPE SetColor(const FLOAT *pColor);
		virtual void STDMETHODCALLTYPE SetColor(const BYTE *pColor);
		
		virtual UINT32 STDMETHODCALLTYPE GetColor32();
	
	// Public functions
	public:
		CFW1ColorRGBA();
		
		HRESULT initColor(IFW1Factory *pFW1Factory, UINT32 initialColor32);
	
	// Internal functions
	private:
		virtual ~CFW1ColorRGBA();
	
	// Internal data
	private:
		UINT32						m_color32;
};


}// namespace FW1FontWrapper


#endif// IncludeGuard__FW1_CFW1ColorRGBA

```

`include/vendor/fontwrapper/CFW1DWriteRenderTarget.h`:

```h
// CFW1DWriteRenderTarget.h

#ifndef IncludeGuard__FW1_CFW1DWriteRenderTarget
#define IncludeGuard__FW1_CFW1DWriteRenderTarget

#include "CFW1Object.h"


namespace FW1FontWrapper {


// Render target that provides pixels of one glyph-image at a time
class CFW1DWriteRenderTarget : public CFW1Object<IFW1DWriteRenderTarget> {
	public:
		// IUnknown
		virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
		
		// IFW1DWriteRenderTarget
		virtual HRESULT STDMETHODCALLTYPE DrawGlyphTemp(
			IDWriteFontFace *pFontFace,
			UINT16 GlyphIndex,
			FLOAT FontSize,
			DWRITE_RENDERING_MODE RenderingMode,
			DWRITE_MEASURING_MODE MeasuringMode,
			FW1_GLYPHIMAGEDATA *pOutData
		);
	
	// Public functions
	public:
		CFW1DWriteRenderTarget();
		
		HRESULT initRenderTarget(
			IFW1Factory *pFW1Factory,
			IDWriteFactory *pDWriteFactory,
			UINT renderTargetWidth,
			UINT renderTargetHeight
		);
	
	// Internal types
	private:
		struct DWGlyphData {
			FLOAT					offsetX;
			FLOAT					offsetY;
			LONG					maxWidth;
			LONG					maxHeight;
		};
		
		typedef std::map<DWRITE_RENDERING_MODE, IDWriteRenderingParams*> RenderingParamsMap;
	
	// Internal functions
	private:
		virtual ~CFW1DWriteRenderTarget();
		
		HRESULT createRenderTarget(IDWriteFactory *pDWriteFactory);
		
		void initGlyphData(
			const DWRITE_FONT_METRICS *fontMetrics,
			const DWRITE_GLYPH_METRICS *glyphMetrics,
			FLOAT fontSize,
			DWGlyphData *outGlyphData
		);
	
	// Internal data
	private:
		std::wstring				m_lastError;
		
		IDWriteBitmapRenderTarget	*m_pRenderTarget;
		HDC							m_hDC;
		HBRUSH						m_hBlackBrush;
		LPVOID						m_bmBits;
		UINT						m_bmWidthBytes;
		UINT						m_bmBytesPixel;
		UINT						m_renderTargetWidth;
		UINT						m_renderTargetHeight;
		RenderingParamsMap			m_renderingParams;
};


}// namespace FW1FontWrapper


#endif// IncludeGuard__FW1_CFW1DWriteRenderTarget

```

`include/vendor/fontwrapper/CFW1Factory.h`:

```h
// CFW1Factory.h

#ifndef IncludeGuard__FW1_CFW1Factory
#define IncludeGuard__FW1_CFW1Factory


namespace FW1FontWrapper {


// Factory that creates FW1 objects
class CFW1Factory : public IFW1Factory {
	public:
		// IUnknown
		virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
		virtual ULONG STDMETHODCALLTYPE AddRef();
		virtual ULONG STDMETHODCALLTYPE Release();
		
		// IFW1Factory
		virtual HRESULT STDMETHODCALLTYPE CreateFontWrapper(
			ID3D11Device *pDevice,
			LPCWSTR pszFontFamily,
			IFW1FontWrapper **ppFontWrapper
		);
		virtual HRESULT STDMETHODCALLTYPE CreateFontWrapper(
			ID3D11Device *pDevice,
			IDWriteFactory *pDWriteFactory,
			const FW1_FONTWRAPPERCREATEPARAMS *pCreateParams,
			IFW1FontWrapper **ppFontWrapper
		);
		virtual HRESULT STDMETHODCALLTYPE CreateFontWrapper(
			ID3D11Device *pDevice,
			IFW1GlyphAtlas *pGlyphAtlas,
			IFW1GlyphProvider *pGlyphProvider,
			IFW1GlyphVertexDrawer *pGlyphVertexDrawer,
			IFW1GlyphRenderStates *pGlyphRenderStates,
			IDWriteFactory *pDWriteFactory,
			const FW1_DWRITEFONTPARAMS *pDefaultFontParams,
			IFW1FontWrapper **ppFontWrapper
		);
		virtual HRESULT STDMETHODCALLTYPE CreateGlyphVertexDrawer(
			ID3D11Device *pDevice,
			UINT VertexBufferSize,
			IFW1GlyphVertexDrawer **ppGlyphVertexDrawer
		);
		virtual HRESULT STDMETHODCALLTYPE CreateGlyphRenderStates(
			ID3D11Device *pDevice,
			BOOL DisableGeometryShader,
			BOOL AnisotropicFiltering,
			IFW1GlyphRenderStates **ppGlyphRenderStates
		);
		virtual HRESULT STDMETHODCALLTYPE CreateTextRenderer(
			IFW1GlyphProvider *pGlyphProvider,
			IFW1TextRenderer **ppTextRenderer
		);
		virtual HRESULT STDMETHODCALLTYPE CreateTextGeometry(
			IFW1TextGeometry **ppTextGeometry
		);
		virtual HRESULT STDMETHODCALLTYPE CreateGlyphProvider(
			IFW1GlyphAtlas *pGlyphAtlas,
			IDWriteFactory *pDWriteFactory,
			IDWriteFontCollection *pFontCollection,
			UINT MaxGlyphWidth,
			UINT MaxGlyphHeight,
			IFW1GlyphProvider **ppGlyphProvider
		);
		virtual HRESULT STDMETHODCALLTYPE CreateDWriteRenderTarget(
			IDWriteFactory *pDWriteFactory,
			UINT RenderTargetWidth,
			UINT RenderTargetHeight,
			IFW1DWriteRenderTarget **ppRenderTarget
		);
		virtual HRESULT STDMETHODCALLTYPE CreateGlyphAtlas(
			ID3D11Device *pDevice,
			UINT GlyphSheetWidth,
			UINT GlyphSheetHeight,
			BOOL HardwareCoordBuffer,
			BOOL AllowOversizedGlyph,
			UINT MaxGlyphCountPerSheet,
			UINT MipLevels,
			UINT MaxGlyphSheetCount,
			IFW1GlyphAtlas **ppGlyphAtlas
		);
		virtual HRESULT STDMETHODCALLTYPE CreateGlyphSheet(
			ID3D11Device *pDevice,
			UINT GlyphSheetWidth,
			UINT GlyphSheetHeight,
			BOOL HardwareCoordBuffer,
			BOOL AllowOversizedGlyph,
			UINT MaxGlyphCount,
			UINT MipLevels,
			IFW1GlyphSheet **ppGlyphSheet
		);
		virtual HRESULT STDMETHODCALLTYPE CreateColor(
			UINT32 Color,
			IFW1ColorRGBA **ppColor
		);
	
	// Public functions
	public:
		CFW1Factory();
		
		HRESULT initFactory();
	
	// Internal functions
	private:
		virtual ~CFW1Factory();
		
		HRESULT createDWriteFactory(IDWriteFactory **ppDWriteFactory);
		
		void setErrorString(const wchar_t *str);
	
	// Internal data
	private:
		ULONG						m_cRefCount;
		
		std::wstring				m_lastError;
		CRITICAL_SECTION			m_errorStringCriticalSection;
	
	private:
		CFW1Factory(const CFW1Factory&);
		CFW1Factory& operator=(const CFW1Factory&);
};


}// namespace FW1FontWrapper


#endif// IncludeGuard__FW1_CFW1Factory

```

`include/vendor/fontwrapper/CFW1FontWrapper.h`:

```h
// CFW1FontWrapper.h

#ifndef IncludeGuard__FW1_CFW1FontWrapper
#define IncludeGuard__FW1_CFW1FontWrapper

#include "CFW1Object.h"


namespace FW1FontWrapper {


// Font-wrapper simplifying drawing strings and text-layouts
class CFW1FontWrapper : public CFW1Object<IFW1FontWrapper> {
	public:
		// IUnknown
		virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
		
		// IFW1FontWrapper
		virtual HRESULT STDMETHODCALLTYPE GetFactory(IFW1Factory **ppFactory);
		
		virtual HRESULT STDMETHODCALLTYPE GetDevice(ID3D11Device **ppDevice);
		virtual HRESULT STDMETHODCALLTYPE GetDWriteFactory(IDWriteFactory **ppDWriteFactory);
		virtual HRESULT STDMETHODCALLTYPE GetGlyphAtlas(IFW1GlyphAtlas **ppGlyphAtlas);
		virtual HRESULT STDMETHODCALLTYPE GetGlyphProvider(IFW1GlyphProvider **ppGlyphProvider);
		virtual HRESULT STDMETHODCALLTYPE GetRenderStates(IFW1GlyphRenderStates **ppRenderStates);
		virtual HRESULT STDMETHODCALLTYPE GetVertexDrawer(IFW1GlyphVertexDrawer **ppVertexDrawer);
		
		virtual void STDMETHODCALLTYPE DrawTextLayout(
			ID3D11DeviceContext *pContext,
			IDWriteTextLayout *pTextLayout,
			FLOAT OriginX,
			FLOAT OriginY,
			UINT32 Color,
			UINT Flags
		);
		virtual void STDMETHODCALLTYPE DrawTextLayout(
			ID3D11DeviceContext *pContext,
			IDWriteTextLayout *pTextLayout,
			FLOAT OriginX,
			FLOAT OriginY,
			UINT32 Color,
			const FW1_RECTF *pClipRect,
			const FLOAT *pTransformMatrix,
			UINT Flags
		);
		
		virtual void STDMETHODCALLTYPE DrawString(
			ID3D11DeviceContext *pContext,
			const WCHAR *pszString,
			FLOAT FontSize,
			FLOAT X,
			FLOAT Y,
			UINT32 Color,
			UINT Flags
		);
		virtual void STDMETHODCALLTYPE DrawString(
			ID3D11DeviceContext *pContext,
			const WCHAR *pszString,
			const WCHAR *pszFontFamily,
			FLOAT FontSize,
			FLOAT X,
			FLOAT Y,
			UINT32 Color,
			UINT Flags
		);
		virtual void STDMETHODCALLTYPE DrawString(
			ID3D11DeviceContext *pContext,
			const WCHAR *pszString,
			const WCHAR *pszFontFamily,
			FLOAT FontSize,
			const FW1_RECTF *pLayoutRect,
			UINT32 Color,
			const FW1_RECTF *pClipRect,
			const FLOAT *pTransformMatrix,
			UINT Flags
		);
		
		virtual FW1_RECTF STDMETHODCALLTYPE MeasureString(
			const WCHAR *pszString,
			const WCHAR *pszFontFamily,
			FLOAT FontSize,
			const FW1_RECTF *pLayoutRect,
			UINT Flags
		);
		
		virtual void STDMETHODCALLTYPE AnalyzeString(
			ID3D11DeviceContext *pContext,
			const WCHAR *pszString,
			const WCHAR *pszFontFamily,
			FLOAT FontSize,
			const FW1_RECTF *pLayoutRect,
			UINT32 Color,
			UINT Flags,
			IFW1TextGeometry *pTextGeometry
		);
		
		virtual void STDMETHODCALLTYPE AnalyzeTextLayout(
			ID3D11DeviceContext *pContext,
			IDWriteTextLayout *pTextLayout,
			FLOAT OriginX,
			FLOAT OriginY,
			UINT32 Color,
			UINT Flags,
			IFW1TextGeometry *pTextGeometry
		);
		
		virtual void STDMETHODCALLTYPE DrawGeometry(
			ID3D11DeviceContext *pContext,
			IFW1TextGeometry *pGeometry,
			const FW1_RECTF *pClipRect,
			const FLOAT *pTransformMatrix,
			UINT Flags
		);
		
		virtual void STDMETHODCALLTYPE Flush(ID3D11DeviceContext *pContext);
	
	// Public functions
	public:
		CFW1FontWrapper();
		
		HRESULT initFontWrapper(
			IFW1Factory *pFW1Factory,
			ID3D11Device *pDevice,
			IFW1GlyphAtlas *pGlyphAtlas,
			IFW1GlyphProvider *pGlyphProvider,
			IFW1GlyphVertexDrawer *pGlyphVertexDrawer,
			IFW1GlyphRenderStates *pGlyphRenderStates,
			IDWriteFactory *pDWriteFactory,
			const FW1_DWRITEFONTPARAMS *pDefaultFontParams
		);
	
	// Internal functions
	private:
		virtual ~CFW1FontWrapper();
		
		IDWriteTextLayout* createTextLayout(
			const WCHAR *pszString,
			const WCHAR *pszFontFamily,
			FLOAT fontSize,
			const FW1_RECTF *pLayoutRect,
			UINT flags
		);
	
	// Internal data
	private:
		std::wstring					m_lastError;
		
		ID3D11Device					*m_pDevice;
		D3D_FEATURE_LEVEL				m_featureLevel;
		IDWriteFactory					*m_pDWriteFactory;
		
		IFW1GlyphAtlas					*m_pGlyphAtlas;
		IFW1GlyphProvider				*m_pGlyphProvider;
		
		IFW1GlyphRenderStates			*m_pGlyphRenderStates;
		IFW1GlyphVertexDrawer			*m_pGlyphVertexDrawer;
		
		CRITICAL_SECTION				m_textRenderersCriticalSection;
		std::stack<IFW1TextRenderer*>	m_textRenderers;
		CRITICAL_SECTION				m_textGeometriesCriticalSection;
		std::stack<IFW1TextGeometry*>	m_textGeometries;
		
		bool							m_defaultTextInited;
		IDWriteTextFormat				*m_pDefaultTextFormat;
};


}// namespace FW1FontWrapper


#endif// IncludeGuard__FW1_CFW1FontWrapper

```

`include/vendor/fontwrapper/CFW1GlyphAtlas.h`:

```h
// CFW1GlyphAtlas.h

#ifndef IncludeGuard__FW1_CFW1GlyphAtlas
#define IncludeGuard__FW1_CFW1GlyphAtlas

#include "CFW1Object.h"


namespace FW1FontWrapper {


class CFW1GlyphAtlas : public CFW1Object<IFW1GlyphAtlas> {
	// Interface
	public:
		// IUnknown
		virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
		
		// IFW1GlyphAtlas
		virtual HRESULT STDMETHODCALLTYPE GetDevice(ID3D11Device **ppDevice);
		
		virtual UINT STDMETHODCALLTYPE GetTotalGlyphCount();
		virtual UINT STDMETHODCALLTYPE GetSheetCount();
		
		virtual HRESULT STDMETHODCALLTYPE GetSheet(UINT SheetIndex, IFW1GlyphSheet **ppGlyphSheet);
		
		virtual const FW1_GLYPHCOORDS* STDMETHODCALLTYPE GetGlyphCoords(UINT SheetIndex);
		virtual HRESULT STDMETHODCALLTYPE BindSheet(ID3D11DeviceContext *pContext, UINT SheetIndex, UINT Flags);
		
		virtual UINT STDMETHODCALLTYPE InsertGlyph(
			const FW1_GLYPHMETRICS *pGlyphMetrics,
			const void *pGlyphData,
			UINT RowPitch,
			UINT PixelStride
		);
		virtual UINT STDMETHODCALLTYPE InsertSheet(IFW1GlyphSheet *pGlyphSheet);
		virtual void STDMETHODCALLTYPE Flush(ID3D11DeviceContext *pContext);
	
	// Public functions
	public:
		CFW1GlyphAtlas();
		
		HRESULT initGlyphAtlas(
			IFW1Factory *pFW1Factory,
			ID3D11Device *pDevice,
			UINT sheetWidth,
			UINT sheetHeight,
			bool coordBuffer,
			bool allowOversizedTexture,
			UINT maxGlyphCountPerSheet,
			UINT mipLevelCount,
			UINT maxSheetCount
		);
	
	// Internal functions
	private:
		virtual ~CFW1GlyphAtlas();
		
		HRESULT createGlyphSheet(IFW1GlyphSheet **ppGlyphSheet);
	
	// Internal data
	private:
		ID3D11Device				*m_pDevice;
		UINT						m_sheetWidth;
		UINT						m_sheetHeight;
		bool						m_hardwareCoordBuffer;
		bool						m_allowOversizedGlyph;
		UINT						m_maxGlyphCount;
		UINT						m_mipLevelCount;
		
		IFW1GlyphSheet				**m_glyphSheets;
		UINT						m_sheetCount;
		UINT						m_maxSheetCount;
		UINT						m_currentSheetIndex;
		UINT						m_flushedSheetIndex;
		
		CRITICAL_SECTION			m_glyphSheetsCriticalSection;
};


}// namespace FW1FontWrapper


#endif// IncludeGuard__FW1_CFW1GlyphAtlas

```

`include/vendor/fontwrapper/CFW1GlyphProvider.h`:

```h
// CFW1GlyphProvider.h

#ifndef IncludeGuard__FW1_CFW1GlyphProvider
#define IncludeGuard__FW1_CFW1GlyphProvider

#include "CFW1Object.h"


namespace FW1FontWrapper {


// Fonts and glyphs-maps collection to match glyphs to images in a glyph-atlas
class CFW1GlyphProvider : public CFW1Object<IFW1GlyphProvider> {
	public:
		// IUnknown
		virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
		
		// IFW1GlyphProvider
		virtual HRESULT STDMETHODCALLTYPE GetGlyphAtlas(IFW1GlyphAtlas **ppGlyphAtlas);
		virtual HRESULT STDMETHODCALLTYPE GetDWriteFactory(IDWriteFactory **ppDWriteFactory);
		virtual HRESULT STDMETHODCALLTYPE GetDWriteFontCollection(IDWriteFontCollection **ppFontCollection);
		
		virtual const void* STDMETHODCALLTYPE GetGlyphMapFromFont(
			IDWriteFontFace *pFontFace,
			FLOAT FontSize,
			UINT FontFlags
		);
		virtual UINT STDMETHODCALLTYPE GetAtlasIdFromGlyphIndex(
			const void* pGlyphMap,
			UINT16 GlyphIndex,
			IDWriteFontFace *pFontFace,
			UINT FontFlags
		);
	
	// Public functions
	public:
		CFW1GlyphProvider();
		
		HRESULT initGlyphProvider(
			IFW1Factory *pFW1Factory,
			IFW1GlyphAtlas *pGlyphAtlas,
			IDWriteFactory *pDWriteFactory,
			IDWriteFontCollection *pFontCollection,
			UINT maxGlyphWidth,
			UINT maxGlyphHeight
		);
	
	// Internal types
	private:
		struct GlyphMap {
			FLOAT							fontSize;
			UINT							fontFlags;
			
			UINT							*glyphs;
			UINT							glyphCount;
		};
		
		struct FontInfo {
			IDWriteFontFace					*pFontFace;
			std::wstring					uniqueName;
		};
		
		typedef std::pair<UINT, std::pair<UINT, FLOAT> > FontId;
		typedef std::map<FontId, GlyphMap*> FontMap;
		
		FontId makeFontId(UINT fontIndex, UINT fontFlags, FLOAT fontSize) {
			UINT relevantFlags = (fontFlags & (FW1_ALIASED));
			return std::make_pair(fontIndex, std::make_pair(relevantFlags, fontSize));
		}
	
	// Internal functions
	private:
		virtual ~CFW1GlyphProvider();
		
		UINT getFontIndexFromFontFace(IDWriteFontFace *pFontFace);
		std::wstring getUniqueNameFromFontFace(IDWriteFontFace *pFontFace);
		
		UINT insertNewGlyph(GlyphMap *glyphMap, UINT16 glyphIndex, IDWriteFontFace *pFontFace);
	
	// Internal data
	private:
		IFW1GlyphAtlas						*m_pGlyphAtlas;
		
		IDWriteFactory						*m_pDWriteFactory;
		UINT								m_maxGlyphWidth;
		UINT								m_maxGlyphHeight;
		std::stack<IFW1DWriteRenderTarget*>	m_glyphRenderTargets;
		
		IDWriteFontCollection				*m_pFontCollection;
		std::vector<FontInfo>				m_fonts;
		
		FontMap								m_fontMap;
		
		CRITICAL_SECTION					m_renderTargetsCriticalSection;
		CRITICAL_SECTION					m_glyphMapsCriticalSection;
		CRITICAL_SECTION					m_fontsCriticalSection;
		CRITICAL_SECTION					m_insertGlyphCriticalSection;
};


}// namespace FW1FontWrapper


#endif// IncludeGuard__FW1_CFW1GlyphProvider

```

`include/vendor/fontwrapper/CFW1GlyphRenderStates.h`:

```h
// CFW1GlyphRenderStates.h

#ifndef IncludeGuard__FW1_CFW1GlyphRenderStates
#define IncludeGuard__FW1_CFW1GlyphRenderStates

#include "CFW1Object.h"


namespace FW1FontWrapper {


// Shader etc. needed to draw glyphs
class CFW1GlyphRenderStates : public CFW1Object<IFW1GlyphRenderStates> {
	public:
		// IUnknown
		virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
		
		// IFW1GlyphRenderStates
		virtual HRESULT STDMETHODCALLTYPE GetDevice(ID3D11Device **ppDevice);
		
		virtual void STDMETHODCALLTYPE SetStates(ID3D11DeviceContext *pContext, UINT Flags);
		virtual void STDMETHODCALLTYPE UpdateShaderConstants(
			ID3D11DeviceContext *pContext,
			const FW1_RECTF *pClipRect,
			const FLOAT *pTransformMatrix
		);
		virtual BOOL STDMETHODCALLTYPE HasGeometryShader();
	
	// Public functions
	public:
		CFW1GlyphRenderStates();
		
		HRESULT initRenderResources(
			IFW1Factory *pFW1Factory,
			ID3D11Device *pDevice,
			bool wantGeometryShader,
			bool anisotropicFiltering
		);
	
	// Internal types
	private:
		struct ShaderConstants {
			FLOAT					TransformMatrix[16];
			FLOAT					ClipRect[4];
		};
	
	// Internal functions
	private:
		virtual ~CFW1GlyphRenderStates();
		
		HRESULT createQuadShaders();
		HRESULT createGlyphShaders();
		HRESULT createPixelShaders();
		HRESULT createConstantBuffer();
		HRESULT createRenderStates(bool anisotropicFiltering);
	
	// Internal data
	private:
		std::wstring				m_lastError;
		
		pD3DCompile					m_pfnD3DCompile;
		
		ID3D11Device				*m_pDevice;
		D3D_FEATURE_LEVEL			m_featureLevel;
		
		ID3D11VertexShader			*m_pVertexShaderQuad;
		ID3D11VertexShader			*m_pVertexShaderClipQuad;
		ID3D11InputLayout			*m_pQuadInputLayout;
		
		ID3D11VertexShader			*m_pVertexShaderPoint;
		ID3D11InputLayout			*m_pPointInputLayout;
		ID3D11GeometryShader		*m_pGeometryShaderPoint;
		ID3D11GeometryShader		*m_pGeometryShaderClipPoint;
		bool						m_hasGeometryShader;
		
		ID3D11PixelShader			*m_pPixelShader;
		ID3D11PixelShader			*m_pPixelShaderClip;
		
		ID3D11Buffer				*m_pConstantBuffer;
		
		ID3D11BlendState			*m_pBlendState;
		ID3D11SamplerState			*m_pSamplerState;
		ID3D11RasterizerState		*m_pRasterizerState;
		ID3D11DepthStencilState		*m_pDepthStencilState;
};


}// namespace FW1FontWrapper


#endif// IncludeGuard__FW1_CFW1GlyphRenderStates

```

`include/vendor/fontwrapper/CFW1GlyphSheet.h`:

```h
// CFW1GlyphSheet.h

#ifndef IncludeGuard__FW1_CFW1GlyphSheet
#define IncludeGuard__FW1_CFW1GlyphSheet

#include "CFW1Object.h"


namespace FW1FontWrapper {


// A texture containing multiple glyphimages
class CFW1GlyphSheet : public CFW1Object<IFW1GlyphSheet> {
	public:
		// IUnknown
		virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
		
		// IFW1GlyphSheet
		virtual HRESULT STDMETHODCALLTYPE GetDevice(ID3D11Device **ppDevice);
		virtual void STDMETHODCALLTYPE GetDesc(FW1_GLYPHSHEETDESC *pDesc);
		
		virtual HRESULT STDMETHODCALLTYPE GetSheetTexture(ID3D11ShaderResourceView **ppSheetTextureSRV);
		virtual HRESULT STDMETHODCALLTYPE GetCoordBuffer(ID3D11ShaderResourceView **ppCoordBufferSRV);
		
		virtual const FW1_GLYPHCOORDS* STDMETHODCALLTYPE GetGlyphCoords();
		virtual HRESULT STDMETHODCALLTYPE BindSheet(ID3D11DeviceContext *pContext, UINT Flags);
		
		virtual UINT STDMETHODCALLTYPE InsertGlyph(
			const FW1_GLYPHMETRICS *pGlyphMetrics,
			const void *pGlyphData,
			UINT RowPitch,
			UINT PixelStride
		);
		virtual void STDMETHODCALLTYPE CloseSheet();
		virtual void STDMETHODCALLTYPE Flush(ID3D11DeviceContext *pContext);
	
	// Public functions
	public:
		CFW1GlyphSheet();
		
		HRESULT initGlyphSheet(
			IFW1Factory *pFW1Factory,
			ID3D11Device *pDevice,
			UINT sheetWidth,
			UINT sheetHeight,
			bool coordBuffer,
			bool allowOversizedGlyph,
			UINT maxGlyphCount,
			UINT mipLevelCount
		);
	
	// Internal types
	private:
		struct RectUI {
			UINT					left;
			UINT					top;
			UINT					right;
			UINT					bottom;
		};
		
		class HeightRange {
			public:
				HeightRange(UINT totalWidth);
				~HeightRange();
				
				UINT findMin(UINT width, UINT *outMin);
				void update(UINT startX, UINT width, UINT newHeight);
			
			private:
				HeightRange();
				HeightRange(const HeightRange&);
				HeightRange& operator=(const HeightRange&);
				
				UINT findMax(UINT startX, UINT width);
				
				UINT				*m_heights;
				UINT				m_totalWidth;
		};
		
		class CriticalSectionLock {
			public:
				CriticalSectionLock(LPCRITICAL_SECTION pCriticalSection) : m_pCriticalSection(pCriticalSection) {
					EnterCriticalSection(m_pCriticalSection);
				}
				~CriticalSectionLock() {
					LeaveCriticalSection(m_pCriticalSection);
				}
			
			private:
				CriticalSectionLock();
				CriticalSectionLock(const CriticalSectionLock&);
				CriticalSectionLock& operator=(const CriticalSectionLock&);
				
				LPCRITICAL_SECTION	m_pCriticalSection;
		};
	
	// Internal functions
	private:
		virtual ~CFW1GlyphSheet();
		
		HRESULT createDeviceResources();
	
	// Internal data
	private:
		std::wstring				m_lastError;
		
		UINT						m_sheetWidth;
		UINT						m_sheetHeight;
		bool						m_hardwareCoordBuffer;
		bool						m_allowOversizedGlyph;
		UINT						m_mipLevelCount;
		UINT						m_alignWidth;
		
		UINT8						*m_textureData;
		FW1_GLYPHCOORDS				*m_glyphCoords;
		UINT						m_maxGlyphCount;
		UINT						m_glyphCount;
		
		ID3D11Device				*m_pDevice;
		
		ID3D11Texture2D				*m_pTexture;
		ID3D11ShaderResourceView	*m_pTextureSRV;
		ID3D11Buffer				*m_pCoordBuffer;
		ID3D11ShaderResourceView	*m_pCoordBufferSRV;
		
		bool						m_closed;
		bool						m_static;
		
		HeightRange					*m_heightRange;
		
		UINT						m_updatedGlyphCount;
		RectUI						m_dirtyRect;
		CRITICAL_SECTION			m_sheetCriticalSection;
		CRITICAL_SECTION			m_flushCriticalSection;
};


}// namespace FW1FontWrapper


#endif// IncludeGuard__FW1_CFW1GlyphSheet

```

`include/vendor/fontwrapper/CFW1GlyphVertexDrawer.h`:

```h
// CFW1GlyphVertexDrawer.h

#ifndef IncludeGuard__FW1_CFW1GlyphVertexDrawer
#define IncludeGuard__FW1_CFW1GlyphVertexDrawer

#include "CFW1Object.h"


namespace FW1FontWrapper {


// Draws glyph-vertices from system memory using a dynamic vertex buffer
class CFW1GlyphVertexDrawer : public CFW1Object<IFW1GlyphVertexDrawer> {
	public:
		// IUnknown
		virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
		
		// IFW1GlyphVertexDrawer
		virtual HRESULT STDMETHODCALLTYPE GetDevice(ID3D11Device **ppDevice);
		
		virtual UINT STDMETHODCALLTYPE DrawVertices(
			ID3D11DeviceContext *pContext,
			IFW1GlyphAtlas *pGlyphAtlas,
			const FW1_VERTEXDATA *pVertexData,
			UINT Flags,
			UINT PreboundSheet
		);
	
	// Public functions
	public:
		CFW1GlyphVertexDrawer();
		
		HRESULT initVertexDrawer(IFW1Factory *pFW1Factory, ID3D11Device *pDevice, UINT vertexBufferSize);
	
	// Internal types
	private:
		struct QuadVertex {
			FLOAT						positionX;
			FLOAT						positionY;
			FLOAT						texCoordX;
			FLOAT						texCoordY;
			UINT32						color;
		};
	
	// Internal functions
	private:
		virtual ~CFW1GlyphVertexDrawer();
		
		HRESULT createBuffers();
		
		UINT drawVertices(
			ID3D11DeviceContext *pContext,
			IFW1GlyphAtlas *pGlyphAtlas,
			const FW1_VERTEXDATA *vertexData,
			UINT preboundSheet
		);
		UINT drawGlyphsAsQuads(
			ID3D11DeviceContext *pContext,
			IFW1GlyphAtlas *pGlyphAtlas,
			const FW1_VERTEXDATA *vertexData,
			UINT preboundSheet
		);
	
	// Internal data
	private:
		std::wstring					m_lastError;
		
		ID3D11Device					*m_pDevice;
		
		ID3D11Buffer					*m_pVertexBuffer;
		ID3D11Buffer					*m_pIndexBuffer;
		UINT							m_vertexBufferSize;
		UINT							m_maxIndexCount;
};


}// namespace FW1FontWrapper


#endif// IncludeGuard__FW1_CFW1GlyphVertexDrawer

```

`include/vendor/fontwrapper/CFW1Object.h`:

```h
// CFW1Object.h

#ifndef IncludeGuard__FW1_CFW1Object
#define IncludeGuard__FW1_CFW1Object


namespace FW1FontWrapper {


// Helper baseclass to avoid writing IUnknown and IFW1Object implementations once per class
template<class IBase>
class CFW1Object : public IBase {
	public:
		// IUnknown
		virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject) = 0 {
			if(ppvObject == NULL)
				return E_INVALIDARG;
			
			if(IsEqualIID(riid, __uuidof(IUnknown))) {
				*ppvObject = static_cast<IUnknown*>(this);
				AddRef();
				return S_OK;
			}
			else if(IsEqualIID(riid, __uuidof(IFW1Object))) {
				*ppvObject = static_cast<IFW1Object*>(this);
				AddRef();
				return S_OK;
			}
			
			*ppvObject = NULL;
			return E_NOINTERFACE;
		}
		
		virtual ULONG STDMETHODCALLTYPE AddRef() {
			return static_cast<ULONG>(InterlockedIncrement(reinterpret_cast<LONG*>(&m_cRefCount)));
		}
		
		virtual ULONG STDMETHODCALLTYPE Release() {
			ULONG newCount = static_cast<ULONG>(InterlockedDecrement(reinterpret_cast<LONG*>(&m_cRefCount)));
			
			if(newCount == 0)
				delete this;
			
			return newCount;
		}
		
		// IFW1Object
		virtual HRESULT STDMETHODCALLTYPE GetFactory(IFW1Factory **ppFW1Factory) {
			if(ppFW1Factory == NULL)
				return E_INVALIDARG;
			
			m_pFW1Factory->AddRef();
			*ppFW1Factory = m_pFW1Factory;
			
			return S_OK;
		}
	
	// Internal functions
	protected:
		CFW1Object() :
			m_cRefCount(1),
			
			m_pFW1Factory(NULL)
		{
		}
		
		virtual ~CFW1Object() {
			if(m_pFW1Factory != NULL)
				m_pFW1Factory->Release();
		}
		
		HRESULT initBaseObject(IFW1Factory *pFW1Factory) {
			if(pFW1Factory == NULL)
				return E_INVALIDARG;
			
			pFW1Factory->AddRef();
			m_pFW1Factory = pFW1Factory;
			
			return S_OK;
		}
	
	// Internal data
	protected:
		IFW1Factory					*m_pFW1Factory;
	
	private:
		ULONG						m_cRefCount;
	
	private:
		CFW1Object(const CFW1Object&);
		CFW1Object& operator=(const CFW1Object&);
};


}// namespace FW1FontWrapper


#endif// IncludeGuard__FW1_CFW1Object

```

`include/vendor/fontwrapper/CFW1StateSaver.h`:

```h
// CFW1StateSaver.h

#ifndef IncludeGuard__FW1_CFW1StateSaver
#define IncludeGuard__FW1_CFW1StateSaver


namespace FW1FontWrapper {


// Saves all the states that can be changed when drawing a string
class CFW1StateSaver {
	// Public functions
	public:
		CFW1StateSaver();
		~CFW1StateSaver();
		
		HRESULT saveCurrentState(ID3D11DeviceContext *pContext);
		HRESULT restoreSavedState();
		void releaseSavedState();
	
	// Internal data
	private:
		bool						m_savedState;
		D3D_FEATURE_LEVEL			m_featureLevel;
		ID3D11DeviceContext			*m_pContext;
		D3D11_PRIMITIVE_TOPOLOGY	m_primitiveTopology;
		ID3D11InputLayout			*m_pInputLayout;
		ID3D11BlendState			*m_pBlendState;
		FLOAT						m_blendFactor[4];
		UINT						m_sampleMask;
		ID3D11DepthStencilState		*m_pDepthStencilState;
		UINT						m_stencilRef;
		ID3D11RasterizerState		*m_pRasterizerState;
		ID3D11ShaderResourceView	*m_pPSSRV;
		ID3D11SamplerState			*m_pSamplerState;
		ID3D11VertexShader			*m_pVS;
		ID3D11ClassInstance			*m_pVSClassInstances[256];
		UINT						m_numVSClassInstances;
		ID3D11Buffer				*m_pVSConstantBuffer;
		ID3D11GeometryShader		*m_pGS;
		ID3D11ClassInstance			*m_pGSClassInstances[256];
		UINT						m_numGSClassInstances;
		ID3D11Buffer				*m_pGSConstantBuffer;
		ID3D11ShaderResourceView	*m_pGSSRV;
		ID3D11PixelShader			*m_pPS;
		ID3D11ClassInstance			*m_pPSClassInstances[256];
		UINT						m_numPSClassInstances;
		ID3D11HullShader			*m_pHS;
		ID3D11ClassInstance			*m_pHSClassInstances[256];
		UINT						m_numHSClassInstances;
		ID3D11DomainShader			*m_pDS;
		ID3D11ClassInstance			*m_pDSClassInstances[256];
		UINT						m_numDSClassInstances;
		ID3D11Buffer				*m_pVB;
		UINT						m_vertexStride;
		UINT						m_vertexOffset;
		ID3D11Buffer				*m_pIndexBuffer;
		DXGI_FORMAT					m_indexFormat;
		UINT						m_indexOffset;
	
	private:
		CFW1StateSaver(const CFW1StateSaver&);
		CFW1StateSaver& operator=(const CFW1StateSaver&);
};


}// namespace FW1FontWrapper


#endif// IncludeGuard__FW1_CFW1StateSaver

```

`include/vendor/fontwrapper/CFW1TextGeometry.h`:

```h
// CFW1TextGeometry.h

#ifndef IncludeGuard__FW1_CFW1TextGeometry
#define IncludeGuard__FW1_CFW1TextGeometry

#include "CFW1Object.h"


namespace FW1FontWrapper {


// Vector of vertices with sorting per glyph sheet
class CFW1TextGeometry : public CFW1Object<IFW1TextGeometry> {
	public:
		// IUnknown
		virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
		
		// IFW1TextGeometry
		virtual void STDMETHODCALLTYPE Clear();
		virtual void STDMETHODCALLTYPE AddGlyphVertex(const FW1_GLYPHVERTEX *pVertex);
		
		virtual FW1_VERTEXDATA STDMETHODCALLTYPE GetGlyphVerticesTemp();
	
	// Public functions
	public:
		CFW1TextGeometry();
		
		HRESULT initTextGeometry(IFW1Factory *pFW1Factory);
	
	// Internal functions
	private:
		virtual ~CFW1TextGeometry();
	
	// Internal data
	private:
		std::vector<FW1_GLYPHVERTEX>	m_vertices;
		std::vector<FW1_GLYPHVERTEX>	m_sortedVertices;
		
		UINT							m_maxSheetIndex;
		std::vector<UINT>				m_vertexCounts;
		std::vector<UINT>				m_vertexStartIndices;
		bool							m_sorted;
};


}// namespace FW1FontWrapper


#endif// IncludeGuard__FW1_CFW1TextGeometry

```

`include/vendor/fontwrapper/CFW1TextRenderer.h`:

```h
// CFW1TextRenderer.h

#ifndef IncludeGuard__FW1_CFW1TextRenderer
#define IncludeGuard__FW1_CFW1TextRenderer

#include "CFW1Object.h"


namespace FW1FontWrapper {


// Converts a DWrite text layout to vertices
class CFW1TextRenderer : public CFW1Object<IFW1TextRenderer> {
	public:
		// IUnknown
		virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
		
		// IFW1DWriteTextRenderer
		virtual HRESULT STDMETHODCALLTYPE GetGlyphProvider(IFW1GlyphProvider **ppGlyphProvider);
		
		virtual HRESULT STDMETHODCALLTYPE DrawTextLayout(
			IDWriteTextLayout *pTextLayout,
			FLOAT OriginX,
			FLOAT OriginY,
			UINT32 Color,
			UINT Flags,
			IFW1TextGeometry *pTextGeometry
		);
	
	// Public functions
	public:
		CFW1TextRenderer();
		
		HRESULT initTextRenderer(
			IFW1Factory *pFW1Factory,
			IFW1GlyphProvider *pGlyphProvider
		);
	
	// Internal functions
	private:
		virtual ~CFW1TextRenderer();
		
		// IDWritePixelSnapping interface (called via proxy)
		HRESULT IsPixelSnappingDisabled(void *clientDrawingContext, BOOL *isDisabled);
		HRESULT GetCurrentTransform(void *clientDrawingContext, DWRITE_MATRIX *transform);
		HRESULT GetPixelsPerDip(void *clientDrawingContext, FLOAT *pixelsPerDip);
		
		// IDWriteTextRenderer interface (called via proxy)
		HRESULT DrawGlyphRun(
			void *clientDrawingContext,
			FLOAT baselineOriginX,
			FLOAT baselineOriginY,
			DWRITE_MEASURING_MODE measuringMode,
			const DWRITE_GLYPH_RUN *glyphRun,
			const DWRITE_GLYPH_RUN_DESCRIPTION *glyphRunDescription,
			IUnknown *clientDrawingEffect
		);
		HRESULT DrawUnderline(
			void *clientDrawingContext,
			FLOAT baselineOriginX,
			FLOAT baselineOriginY,
			const DWRITE_UNDERLINE *underline,
			IUnknown *clientDrawingEffect
		);
		HRESULT DrawStrikethrough(
			void *clientDrawingContext,
			FLOAT baselineOriginX,
			FLOAT baselineOriginY,
			const DWRITE_STRIKETHROUGH *strikethrough,
			IUnknown *clientDrawingEffect
		);
		HRESULT DrawInlineObject(
			void *clientDrawingContext,
			FLOAT originX,
			FLOAT originY,
			IDWriteInlineObject *inlineObject,
			BOOL isSideways,
			BOOL isRightToLeft,
			IUnknown *clientDrawingEffect
		);
	
	// Internal data
	private:
		IFW1GlyphProvider			*m_pGlyphProvider;
		
		UINT						m_currentFlags;
		UINT32						m_currentColor;
		
		const void					*m_cachedGlyphMap;
		IDWriteFontFace				*m_pCachedGlyphMapFontFace;
		FLOAT						m_cachedGlyphMapFontSize;
	
	
	// Proxy for IDWriteTextRenderer interface
	private:
		class CDWriteTextRendererProxy : public IDWriteTextRenderer {
			public:
				virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject) {
					return m_realObject->QueryInterface(riid, ppvObject);
				}
				virtual ULONG STDMETHODCALLTYPE AddRef() {
					return m_realObject->AddRef();
				}
				virtual ULONG STDMETHODCALLTYPE Release() {
					return m_realObject->Release();
				}
				
				virtual HRESULT STDMETHODCALLTYPE IsPixelSnappingDisabled(void *clientDrawingContext, BOOL *isDisabled) {
					return m_realObject->IsPixelSnappingDisabled(clientDrawingContext, isDisabled);
				}
				virtual HRESULT STDMETHODCALLTYPE GetCurrentTransform(void *clientDrawingContext, DWRITE_MATRIX *transform) {
					return m_realObject->GetCurrentTransform(clientDrawingContext, transform);
				}
				virtual HRESULT STDMETHODCALLTYPE GetPixelsPerDip(void *clientDrawingContext, FLOAT *pixelsPerDip) {
					return m_realObject->GetPixelsPerDip(clientDrawingContext, pixelsPerDip);
				}
				
				virtual HRESULT STDMETHODCALLTYPE DrawGlyphRun(void *clientDrawingContext, FLOAT baselineOriginX, FLOAT baselineOriginY, DWRITE_MEASURING_MODE measuringMode, const DWRITE_GLYPH_RUN *glyphRun, const DWRITE_GLYPH_RUN_DESCRIPTION *glyphRunDescription, IUnknown *clientDrawingEffect) {
					return m_realObject->DrawGlyphRun(clientDrawingContext, baselineOriginX, baselineOriginY, measuringMode, glyphRun, glyphRunDescription, clientDrawingEffect);
				}
				virtual HRESULT STDMETHODCALLTYPE DrawUnderline(void *clientDrawingContext, FLOAT baselineOriginX, FLOAT baselineOriginY, const DWRITE_UNDERLINE *underline, IUnknown *clientDrawingEffect) {
					return m_realObject->DrawUnderline(clientDrawingContext, baselineOriginX, baselineOriginY, underline, clientDrawingEffect);
				}
				virtual HRESULT STDMETHODCALLTYPE DrawStrikethrough(void *clientDrawingContext, FLOAT baselineOriginX, FLOAT baselineOriginY, const DWRITE_STRIKETHROUGH *strikethrough, IUnknown *clientDrawingEffect) {
					return m_realObject->DrawStrikethrough(clientDrawingContext, baselineOriginX, baselineOriginY, strikethrough, clientDrawingEffect);
				}
				virtual HRESULT STDMETHODCALLTYPE DrawInlineObject(void *clientDrawingContext, FLOAT originX, FLOAT originY, IDWriteInlineObject *inlineObject, BOOL isSideways, BOOL isRightToLeft, IUnknown *clientDrawingEffect) {
					return m_realObject->DrawInlineObject(clientDrawingContext, originX, originY, inlineObject, isSideways, isRightToLeft, clientDrawingEffect);
				}
			
			public:
				CDWriteTextRendererProxy(CFW1TextRenderer *realObject) : m_realObject(realObject) {}
			
			private:
				CDWriteTextRendererProxy(const CDWriteTextRendererProxy&);
				CDWriteTextRendererProxy& operator=(const CDWriteTextRendererProxy&);
			
			private:
				CFW1TextRenderer	*m_realObject;
		} *m_pDWriteTextRendererProxy;
};


}// namespace FW1FontWrapper


#endif// IncludeGuard__FW1_CFW1TextRenderer

```

`include/vendor/fontwrapper/FW1CompileSettings.h`:

```h
// FW1CompileSettings.h

#ifndef IncludeGuard__FW1_FW1CompileSettings_h
#define IncludeGuard__FW1_FW1CompileSettings_h


// Define if building a DLL for the font-wrapper

// Define to use LoadLibrary instead of linking to DLLs
#define FW1_DELAYLOAD_DWRITE_DLL
#define FW1_DELAYLOAD_D3DCOMPILER_XX_DLL


#endif// IncludeGuard__FW1_FW1CompileSettings_h

```

`include/vendor/fontwrapper/FW1FontWrapper.h`:

```h
// FW1FontWrapper.h

// v1.1, October 2011
// Written by Erik Rufelt

#ifndef IncludeGuard__FW1_FW1FontWrapper_h
#define IncludeGuard__FW1_FW1FontWrapper_h

#include <D3D11.h>
#include <DWrite.h>


/// <summary>The current FW1 version.</summary>
/// <remarks>This constant should be used when calling FW1CreateFactory to make sure the library version matches the headers.</remarks>
#define FW1_VERSION 0x110f

#define FW1_DLL_W L"FW1FontWrapper.dll"
#define FW1_DLL_A "FW1FontWrapper.dll"

#ifdef UNICODE
	#define FW1_DLL FW1_DLL_W
#else
	#define FW1_DLL FW1_DLL_A
#endif

/// <summary>Describes overrides for how an FW1 operation is performed.</summary>
/// <remarks>These flags can be used for any FW1 methods that take a flags parameter. Not all flags have any meaning for all methods however.
/// Consult the documentation page for a particular method for information on what flags are valid.</remarks>
enum FW1_TEXT_FLAG {
	/// <summary>Text is left-aligned. This is the default.</summary>
	FW1_LEFT = 0x0,
	
	/// <summary>Text is centered horizontally.</summary>
	FW1_CENTER = 0x1,
	
	/// <summary>Text is right-aligned.</summary>
	FW1_RIGHT = 0x2,
	
	/// <summary>Text is aligned at the top of the layout-box. This is the default.</summary>
	FW1_TOP = 0x0,
	
	/// <summary>Text is centered vertically.</summary>
	FW1_VCENTER = 0x4,
	
	/// <summary>Text is aligned at the bottom of the layout-box.</summary>
	FW1_BOTTOM = 0x8,
	
	/// <summary>No automatic wrapping when the text overflows the layout-box.</summary>
	FW1_NOWORDWRAP = 0x10,
	
	/// <summary>Text is drawn without anti-aliasing.</summary>
	FW1_ALIASED = 0x20,
	
	/// <summary>If a clip-rect is specified together with this flag, all text is clipped to inside the specified rectangle.</summary>
	FW1_CLIPRECT = 0x40,
	
	/// <summary>No geometry shader is used when drawing glyphs. Indexed quads are constructed on the CPU instead of in the geometry shader.</summary>
	FW1_NOGEOMETRYSHADER = 0x80,
	
	/// <summary>The transform matrix and the clip-rect is not updated in the internal constant-buffer. Can be used as an optimization when a previous call has already set the correct data.</summary>
	FW1_CONSTANTSPREPARED = 0x100,
	
	/// <summary>The internal vertex and index buffer (if used) are assumed to already be bound. Can be used as an optimization when a previous call has already set the buffers.</summary>
	FW1_BUFFERSPREPARED = 0x200,
	
	/// <summary>The correct shaders/constant-buffer etc. are assumed to already be bound. Can be used as an optimization when a previous call has already set the states, or to override the default states.</summary>
	FW1_STATEPREPARED = 0x400,
	
	/// <summary>Can be used as an optimization on subsequent calls, when drawing several strings with the same settings.</summary>
	FW1_IMMEDIATECALL = FW1_CONSTANTSPREPARED | FW1_BUFFERSPREPARED | FW1_STATEPREPARED,
	
	/// <summary>When a draw method returns, the device-context will have been restored to the same state as before the call.</summary>
	FW1_RESTORESTATE = 0x800,
	
	/// <summary>Any new glyphs added during a call are not flushed to the device-resources.
	/// It is a good idea to use this flag for text-operations on deferred contexts, when drawing text on multiple threads simultaneously, in order to guarantee the proper order of operations.</summary>
	FW1_NOFLUSH = 0x1000,
	
	/// <summary>Any new glyphs will be cached in the atlas and glyph-maps, but no geometry is drawn.</summary>
	FW1_CACHEONLY = 0x2000,
	
	/// <summary>No new glyphs will be added to the atlas or glyph-maps. Any glyphs not already present in the atlas will be replaced with a default fall-back glyph (empty box).</summary>
	FW1_NONEWGLYPHS = 0x4000,
	
	/// <summary>A text-layout will be run through DirectWrite and new fonts will be prepared, but no actual drawing will take place, and no additional glyphs will be cached.</summary>
	FW1_ANALYZEONLY = 0x8000,
	
	/// <summary>Don't use.</summary>
	FW1_UNUSED = 0xffffffff
};

/// <summary>Coordinates for a single glyph in the atlas.</summary>
/// <remarks>Each glyph image inserted in a glyph sheet texture gets a unique index in that sheet, and a corresponding FW1_GLYPHCOORDS entry in the sheet's coord buffer, describing its location in the sheet as well as its dimensions.</remarks>
struct FW1_GLYPHCOORDS {
	/// <summary>The left texture coordinate.</summary>
	FLOAT TexCoordLeft;
	
	/// <summary>The top texture coordinate.</summary>
	FLOAT TexCoordTop;
	
	/// <summary>The right texture coordinate.</summary>
	FLOAT TexCoordRight;
	
	/// <summary>The bottom texture coordinate.</summary>
	FLOAT TexCoordBottom;
	
	/// <summary>The offset of the left edge of the glyph image, relative its offset in the text.</summary>
	FLOAT PositionLeft;
	
	/// <summary>The offset of the top edge of the glyph image, relative its offset in the text.</summary>
	FLOAT PositionTop;
	
	/// <summary>The offset of the right edge of the glyph image, relative its offset in the text.</summary>
	FLOAT PositionRight;
	
	/// <summary>The offset of the bottom edge of the glyph image, relative its offset in the text.</summary>
	FLOAT PositionBottom;
};

/// <summary>Description of a glyph sheet.</summary>
/// <remarks></remarks>
struct FW1_GLYPHSHEETDESC {
	/// <summary>The number of glyphs currently stored in this sheet.</summary>
	UINT GlyphCount;
	
	/// <summary>The width of this sheet's texture, in pixels.</summary>
	UINT Width;
	
	/// <summary>The height of this sheet's texture, in pixels.</summary>
	UINT Height;
	
	/// <summary>The number of mip-levels for this sheet's texture.</summary>
	UINT MipLevels;
};

/// <summary>Metrics for a glyph image.</summary>
/// <remarks>This structure is filled in as part of the FW1_GLYPHIMAGEDATA structure when a glyph-image is rendered by IFW1DWriteRenderTarget::DrawGlyphTemp.</remarks>
struct FW1_GLYPHMETRICS {
	/// <summary>The horizontal offset from a glyph's position in text to the left edge of its image.</summary>
	FLOAT OffsetX;
	
	/// <summary>The vertical offset form a glyph's position in text to the top edge of its image.</summary>
	FLOAT OffsetY;
	
	/// <summary>The width of the glyph image, in pixels.</summary>
	UINT Width;
	
	/// <summary>The height of the glyph image, in pixels.</summary>
	UINT Height;
};

/// <summary>Image data for a glyph.</summary>
/// <remarks>This structure is filled by the IFW1DWriteRenderTarget::DrawGlyphTemp Method.</remarks>
struct FW1_GLYPHIMAGEDATA {
	/// <summary>Metrics for the glyph.</summary>
	FW1_GLYPHMETRICS Metrics;
	
	/// <summary>Pointer to the pixels of the glyph-image.</summary>
	const void *pGlyphPixels;
	
	/// <summary>The number of bytes in a row of the image data.</summary>
	UINT RowPitch;
	
	/// <summary>The number of bytes between the start of one pixel and the next.</summary>
	UINT PixelStride;
};

/// <summary>A vertex corresponding to a single glyph.</summary>
/// <remarks>When an IFW1TextRenderer draws a string, each output glyph is converted to an FW1_GLYPHVERTEX entry in an IFW1TextGeometry object.</remarks>
struct FW1_GLYPHVERTEX {
	/// <summary>The base X position of the glyph.</summary>
	FLOAT PositionX;
	
	/// <summary>The base Y position of the glyph.</summary>
	FLOAT PositionY;
	
	/// <summary>The index of the glyph.</summary>
	UINT32 GlyphIndex;
	
	/// <summary>The color of the glyph, as 0xAaBbGgRr.</summary>
	UINT32 GlyphColor;
};

/// <summary>An array of vertices, sorted by glyph-sheet.</summary>
/// <remarks>This structure is returned by the IFW1TextGeometry::GetGlyphVerticesTemp Method.</remarks>
struct FW1_VERTEXDATA {
	/// <summary>The number of sheets in the glyph-atlas that are used, starting with the first sheet in the atlas.</summary>
	UINT SheetCount;
	
	/// <summary>An array of <i>SheetCount</i> unsigned integers, which specify the number of glyphs using each sheet.
	/// The sum of all counts is <i>TotalVertexCount</i>. Some counts may be zero.</summary>
	const UINT *pVertexCounts;
	
	/// <summary>The total number of vertices.</summary>
	UINT TotalVertexCount;
	
	/// <summary>An array of <i>TotalVertexCount</i> vertices, sorted by sheet.</summary>
	const FW1_GLYPHVERTEX *pVertices;
};

/// <summary>A rectangle.</summary>
/// <remarks></remarks>
struct FW1_RECTF {
	/// <summary>The X coordinate of the left edge of the rectangle.</summary>
	FLOAT Left;
	
	/// <summary>The Y coordinate of the top edge of the rectangle.</summary>
	FLOAT Top;
	
	/// <summary>The X coordinate of the right edge of the rectangle.</summary>
	FLOAT Right;
	
	/// <summary>The Y coordinate of the bottom edge of the rectangle.</summary>
	FLOAT Bottom;
};

/// <summary>Describes a single font. This structure is used in the FW1_FONTWRAPPERCREATEPARAMS structure.</summary>
/// <remarks>If pszFontFamily is NULL when creating an IFW1FontWrapper object, no default font will be set up.
/// This is perfectly valid when drawing text using one of the DrawTextLayout methods.
/// However, the DrawString methods will silently fail if no default font is set up.<br/>
/// If pszFontFamily is not NULL, the FontWeight, FontStyle and FontStretch members must be set to valid values according to the DirectWrite documentation.
/// Zero is not a valid value for these.</remarks>
struct FW1_DWRITEFONTPARAMS {
	/// <summary>The name of the font-family. Valid values include <i>Arial</i>, <i>Courier New</i>, etc. as long as the specified font is installed.
	/// Unavailable fonts will automatically fall back to a different font.
	/// This member can be set to NULL, if no default font is desired when using the structure to create a font-wrapper.</summary>
	LPCWSTR pszFontFamily;
	
	/// <summary>The font weight. See DirectWrite documentation.</summary>
	DWRITE_FONT_WEIGHT FontWeight;
	
	/// <summary>The font style. See DirectWrite documentation.</summary>
	DWRITE_FONT_STYLE FontStyle;
	
	/// <summary>The font stretch. See DirectWrite documentation.</summary>
	DWRITE_FONT_STRETCH FontStretch;
	
	/// <summary>The locale. NULL for default.</summary>
	LPCWSTR pszLocale;
};

/// <summary>The FW1_FONTWRAPPERCREATEPARAMS is used with the IFW1Factory::CreateFontWrapper method, and describes settings for the created IFW1FontWrapper object.</summary>
/// <remarks>If a member has the value zero, the default value will be chosen instead. See FW1_DWRITEFONTPARAMS for requirements for its members.</remarks>
struct FW1_FONTWRAPPERCREATEPARAMS {
	/// <summary>The width of the glyph sheet textures to store glyph images in. 0 defaults to 512.</summary>
	UINT GlyphSheetWidth;
	
	/// <summary>The height of the glyph sheet textures to store glyph images in. 0 defaults to 512.</summary>
	UINT GlyphSheetHeight;
	
	/// <summary>The maximum number of glyphs per texture. A buffer of <i>MaxGlyphCountPerSheet * 32</i> bytes is preallocated for each sheet. 0 defaults to 2048.</summary>
	UINT MaxGlyphCountPerSheet;
	
	/// <summary>The number of mip-levels for the glyph sheet textures. 0 defaults to 1.</summary>
	UINT SheetMipLevels;
	
	/// <summary>If set to TRUE, the sampler-state is created with anisotropic filtering.</summary>
	BOOL AnisotropicFiltering;
	
	/// <summary>The maximum width of a single glyph.
	/// This value is used to decide how large the DirectWrite render target needs to be, which is used when drawing glyph images to put in the atlas.
	/// 0 defaults to 384.</summary>
	UINT MaxGlyphWidth;
	
	/// <summary>The maximum height of a single glyph.
	/// This value is used to decide how large the DirectWrite render target needs to be, which is used when drawing glyph images to put in the atlas.
	/// 0 defaults to 384.</summary>
	UINT MaxGlyphHeight;
	
	/// <summary>If set to TRUE, no geometry shader is used.</summary>
	BOOL DisableGeometryShader;
	
	/// <summary>The size in bytes of the dynamic vertex buffer to upload glyph vertices to when drawing a string. 0 defaults to 4096 * 16.<br/>
	/// Each glyph vertex is either 16 or 20 bytes in size, and each glyph requires either 1 or 4 vertices depending on if the geometry shader is used.</summary>
	UINT VertexBufferSize;
	
	/// <summary>Description of the default font. See FW1_DWRITEFONTPARAMS.</summary>
	FW1_DWRITEFONTPARAMS DefaultFontParams;
};

interface IFW1Factory;
/// <summary>All FW1 interfaces (except for IFW1Factory) inherits from IFW1Object.</summary>
/// <remarks>Since all interfaces inhert from IFW1Object, the factory which created an object can always be queried with its GetFactory method.</remarks>
MIDL_INTERFACE("8D3C3FB1-F2CC-4331-A623-031F74C06617") IFW1Object : public IUnknown {
	public:
		/// <summary>Get the factory that created an object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="ppFactory">Address of a pointer to an IFW1Factory.</param>
		virtual HRESULT STDMETHODCALLTYPE GetFactory(
			__out IFW1Factory **ppFactory
		) = 0;
};

/// <summary>A sheet contains a texture with glyph images, and a coord-buffer with an FW1_GLYPHCOORDS entry for each glyph.</summary>
MIDL_INTERFACE("60CAB266-C805-461d-82C0-392472EECEFA") IFW1GlyphSheet : public IFW1Object {
	public:
		/// <summary>Get the ID3D11Device the sheet is created on.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="ppDevice">Address of a pointer to an ID3D11Device.</param>
		virtual HRESULT STDMETHODCALLTYPE GetDevice(
			__out ID3D11Device **ppDevice
		) = 0;
		
		/// <summary>Get the properties of a glyph sheet.</summary>
		/// <remarks></remarks>
		/// <returns>Returns nothing.</returns>
		/// <param name="pDesc">Pointer to a sheet description.</param>
		virtual void STDMETHODCALLTYPE GetDesc(
			__out FW1_GLYPHSHEETDESC *pDesc
		) = 0;
		
		/// <summary>Get the ID3D11ShaderResourceView for the sheet's texture.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="ppSheetTextureSRV">Address of a pointer to an ID3D11ShaderResourceView.</param>
		virtual HRESULT STDMETHODCALLTYPE GetSheetTexture(
			__out ID3D11ShaderResourceView **ppSheetTextureSRV
		) = 0;
		
		/// <summary>Get the ID3D11ShaderResourceView for the sheet's coord buffer.</summary>
		/// <remarks>The coord buffer contains 32 bytes per glyph, stored as two float4, representing the data in an FW1_GLYPHCOORDS structure.<br/>
		/// If the sheet is created without a hardware coord buffer, the method will return success and set the coord buffer to NULL.
		/// See IFW1Factory::CreateGlyphSheet.</remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="ppCoordBufferSRV">Address of a pointer to an ID3D11ShaderResourceView.</param>
		virtual HRESULT STDMETHODCALLTYPE GetCoordBuffer(
			__out ID3D11ShaderResourceView **ppCoordBufferSRV
		) = 0;
		
		/// <summary>Get a sheet's coord-buffer, as an array of FW1_GLYPHCOORDS.</summary>
		/// <remarks>The returned buffer is valid for the lifetime of the sheet, and may only be read and never altered.
		/// The maximum valid index at any given time is one less than the number of glyphs in the sheet, which can be queried using IFW1GlyphSheet::GetDesc.</remarks>
		/// <returns>Returns a constant pointer to the sheet's coord-buffer.</returns>
		virtual const FW1_GLYPHCOORDS* STDMETHODCALLTYPE GetGlyphCoords(
		) = 0;
		
		/// <summary>Set the sheet shader resources on the provided context.</summary>
		/// <remarks>This method sets the sheet texture as a pixelshader resource for slot 0, and optionally the coord buffer as geometryshader resource for slot 0.</remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pContext">The context to set the sheet shader resources on.</param>
		/// <param name="Flags">This parameter can include zero or more of the following values, ORd together. Any additional values are ignored.<br/>
		/// FW1_NOGEOMETRYSHADER: don't bind the coord buffer as a shader-resource for the geometry shader, even if it's available.
		/// </param>
		virtual HRESULT STDMETHODCALLTYPE BindSheet(
			__in ID3D11DeviceContext *pContext,
			__in UINT Flags
		) = 0;
		
		/// <summary>Insert a glyph into the sheet.</summary>
		/// <remarks>The parameters for this method can be obtained as part of the FW1_GLYPHIMAGEDATA structure filled in by the IFW1DWriteRenderTarget::DrawGlyphTemp method.</remarks>
		/// <returns>If the glyph is inserted, the index of the new glyph in the sheet is returned. This index can be used to get the glyph's coordinates from the sheet coord buffer. See IFW1GlyphSheet::GetCoordBuffer and IFW1GlyphSheet::GetGlyphCoords.<br/>
		/// If the method fails to insert the glyph, the returned value is 0xFFFFFFFF.</returns>
		/// <param name="pGlyphMetrics">A pointer to an FW1_GLYPHMETRICS structure, specifying the metrics of the glyph to be inserted.</param>
		/// <param name="pGlyphData">A pointer to image data.</param>
		/// <param name="RowPitch">The number of bytes in a row of image data.</param>
		/// <param name="PixelStride">The number of bytes between successive pixels.</param>
		virtual UINT STDMETHODCALLTYPE InsertGlyph(
			__in const FW1_GLYPHMETRICS *pGlyphMetrics,
			__in const void *pGlyphData,
			__in UINT RowPitch,
			__in UINT PixelStride
		) = 0;
		
		/// <summary>Close the sheet for additional glyphs.</summary>
		/// <remarks>After calling this method any subsequent attempts to insert new glyphs into the sheet will fail.
		/// Calling this method can save some memory as the RAM copy of the texture can be released after the next call to IFW1GlyphSheet::Flush.</remarks>
		/// <returns>No return value.</returns>
		virtual void STDMETHODCALLTYPE CloseSheet(
		) = 0;
		
		/// <summary>Flush any new glyphs to the internal D3D11 buffers.</summary>
		/// <remarks>When glyphs are inserted into the sheet only the CPU-memory resources are updated.
		/// In order for these to be available for use by the GPU, they must be flushed to the device using a device-context.</remarks>
		/// <returns>No return value.</returns>
		/// <param name="pContext">The context to use when updating device resources.</param>
		virtual void STDMETHODCALLTYPE Flush(
			__in ID3D11DeviceContext *pContext
		) = 0;
};

/// <summary>A glyph-atlas is a collection of glyph-sheets.</summary>
/// <remarks></remarks>
MIDL_INTERFACE("A31EB6A2-7458-4e24-82B3-945A95623B1F") IFW1GlyphAtlas : public IFW1Object {
	/// <summary>Get the ID3D11Device the atlas is created on.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppDevice">Address of a pointer to an ID3D11Device.</param>
	virtual HRESULT STDMETHODCALLTYPE GetDevice(
		__out ID3D11Device **ppDevice
	) = 0;
	
	/// <summary>Get the total number of glyphs in all the atlas' sheets.</summary>
	/// <remarks></remarks>
	/// <returns>The total number of glyphs in the atlas.</returns>
	virtual UINT STDMETHODCALLTYPE GetTotalGlyphCount(
	) = 0;
	
	/// <summary>Get the number of texture sheets in the atlas.</summary>
	/// <remarks></remarks>
	/// <returns>The number of sheets in the atlas.</returns>
	virtual UINT STDMETHODCALLTYPE GetSheetCount(
	) = 0;
	
	/// <summary>Get a pointer to an IFW1GlyphSheet in the atlas.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="SheetIndex">The index of the sheet to be obtained.</param>
	/// <param name="ppGlyphSheet">Address of a pointer to an IFW1GlyphSheet.</param>
	virtual HRESULT STDMETHODCALLTYPE GetSheet(
		__in UINT SheetIndex,
		__out IFW1GlyphSheet **ppGlyphSheet
	) = 0;
	
	/// <summary>Get a pointer to a sheet's glyph-coord buffer.</summary>
	/// <remarks></remarks>
	/// <returns>If <i>SheetIndex</i> is valid, returns a pointer to a coord buffer. See IFW1GlyphSheet::GetGlyphCoords.</returns>
	/// <param name="SheetIndex">The index of the sheet which coord buffer is to be obtained.</param>
	virtual const FW1_GLYPHCOORDS* STDMETHODCALLTYPE GetGlyphCoords(
		__in UINT SheetIndex
	) = 0;
	
	/// <summary>Bind a sheet's shader resources on a device context.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="pContext">The context to set the shader resources on.</param>
	/// <param name="SheetIndex">The index of the sheet to bind.</param>
	/// <param name="Flags">Flags that specify whether to set the geometry shader coord buffer. See IFW1GlyphSheet::BindSheet.</param>
	virtual HRESULT STDMETHODCALLTYPE BindSheet(
		__in ID3D11DeviceContext *pContext,
		__in UINT SheetIndex,
		__in UINT Flags
	) = 0;
	
	/// <summary>Insert a glyph into the atlas.</summary>
	/// <remarks>The parameters for this method can be obtained as part of the FW1_GLYPHIMAGEDATA structure filled in by the IFW1DWriteRenderTarget::DrawGlyphTemp method.</remarks>
	/// <returns>If the glyph is inserted, the ID of the new glyph in the atlas is returned.
	/// The ID is always <tt>((SheetIndex &lt;&lt; 16) | GlyphIndex)</tt>, where <i>SheetIndex</i> is the index of the sheet texture the glyph is place in, and <i>GlyphIndex</i> is the index of the glyph in that sheet.<br/>
	/// If the method fails to insert the glyph, the returned value is 0xFFFFFFFF.</returns>
	/// <param name="pGlyphMetrics">A pointer to an FW1_GLYPHMETRICS structure, specifying the metrics of the glyph to be inserted.</param>
	/// <param name="pGlyphData">A pointer to image data.</param>
	/// <param name="RowPitch">The number of bytes in a row of image data.</param>
	/// <param name="PixelStride">The number of bytes between successive pixels.</param>
	virtual UINT STDMETHODCALLTYPE InsertGlyph(
		__in const FW1_GLYPHMETRICS *pGlyphMetrics,
		__in const void *pGlyphData,
		__in UINT RowPitch,
		__in UINT PixelStride
	) = 0;
	
	/// <summary>Insert a sheet into the atlas.</summary>
	/// <remarks>This method is used internally whenever new glyphs no longer fits in existing sheets. The atlas will hold a reference to the sheet for the remainder of its lifetime.</remarks>
	/// <returns>On success, eturns the index of the sheet in the atlas after insertion.<br/>If the method fails, 0xFFFFFFFF is returned.</returns>
	/// <param name="pGlyphSheet">A pointer ot the glyph sheet to insert.</param>
	virtual UINT STDMETHODCALLTYPE InsertSheet(
		__in IFW1GlyphSheet *pGlyphSheet
	) = 0;
	
	/// <summary>Flush all new or internally updated sheets.</summary>
	/// <remarks>See IFW1GlyphSheet::Flush.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The context to use when updating device resources.</param>
	virtual void STDMETHODCALLTYPE Flush(
		__in ID3D11DeviceContext *pContext
	) = 0;
};

/// <summary>Collection of glyph-maps, mapping font/size/glyph information to an ID in a glyph atlas.</summary>
/// <remarks>Whenever a glyph or glyphmap is queried from the glyph-provider, it will be dynamically inserted if it does not already exist.</remarks>
MIDL_INTERFACE("F8360043-329D-4EC9-B0F8-ACB00FA77420") IFW1GlyphProvider : public IFW1Object {
	/// <summary>Get the IFW1GlyphAtlas this glyph-provider references.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppGlyphAtlas">Address of a pointer to an IFW1GlyphAtlas.</param>
	virtual HRESULT STDMETHODCALLTYPE GetGlyphAtlas(
		__out IFW1GlyphAtlas **ppGlyphAtlas
	) = 0;
	
	/// <summary>Get the DirectWrite factory a glyph-provider references.</summary>
	/// <remarks>The DirectWrite factory is used internally to create render-targets needed to draw glyph-images that are put in the glyph-atlas.</remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppDWriteFactory">Address of a pointer to an IDWriteFactory.</param>
	virtual HRESULT STDMETHODCALLTYPE GetDWriteFactory(
		__out IDWriteFactory **ppDWriteFactory
	) = 0;
	
	/// <summary>Get the DirectWrite font-collection referenced by a glyph-provider.</summary>
	/// <remarks>The DirectWrite font collection is used internally only to match font-faces to unique names.
	/// Since different IDWriteFontFace objects can reference the same font, a reliable method of identifying a font is required.
	/// This is the only function of the font-collection in the scope of the glyph-provider.
	/// A font-face not from the same collection can still be used when requesting glyphs, in which case it will only be identified by its pointer value.</remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppFontCollection">Address of a pointer to an IDWriteFontCollection.</param>
	virtual HRESULT STDMETHODCALLTYPE GetDWriteFontCollection(
		__out IDWriteFontCollection **ppFontCollection
	) = 0;
	
	/// <summary>Get a pointer identifying a glyph-map matching the specified font.</summary>
	/// <remarks>If the FW1_NONEWGLYPHS flag is not specified, new glyph-maps are created on demand.
	/// The glyph-map returned from this method is not meaningful outside of the glyph provider internals, but is needed for subsequent calls to IFW1GlyphProvider::GetAtlasIdFromGlyphIndex.</remarks>
	/// <returns>A constant pointer identifying a glyph-map.
	/// This pointer should only be used in subsequent calls to IFW1GlyphProvider::GetAtlasIdFromGlyphIndex, and remains valid for the lifetime of the IFW1GlyphProvider.<br/>
	/// A NULL pointer may be returned, if using the FW1_NONEWGLYPHS flag and a matching glyph-map does not exist.</returns>
	/// <param name="pFontFace">A DirectWrite font face.</param>
	/// <param name="FontSize">The size of the font.</param>
	/// <param name="FontFlags">Can include zero or more of the following values, ORd together. Any additional values are ignored.<br/>
	/// FW1_ALIASED - No anti-aliasing is used when drawing the glyphs.<br/>
	/// FW1_NONEWGLYPHS - No new glyph-maps are created.</param>
	virtual const void* STDMETHODCALLTYPE GetGlyphMapFromFont(
		__in IDWriteFontFace *pFontFace,
		__in FLOAT FontSize,
		__in UINT FontFlags
	) = 0;
	
	/// <summary>Get the ID of the specified glyph in the glyph-atlas.</summary>
	/// <remarks>If FW1_NONEWGLYPHS is not specified, any glyph not currently in the atlas will be inserted before the method returns.</remarks>
	/// <returns>The ID of the specified glyph in the glyph-atlas.
	/// The ID is always <tt>((SheetIndex &lt;&lt; 16) | GlyphIndex)</tt>, where <i>SheetIndex</i> is the index of the sheet texture the glyph is placed in, and <i>GlyphIndex</i> is the index of the glyph in that sheet.<br/>
	/// If the specified glyph does not exist and can not be inserted on demand, the ID of a fallback glyph is returned.</returns>
	/// <param name="pGlyphMap">A pointer identifying a glyph-map, previously obtained using IFW1GlyphProvider::GetGlyphMapFromFont.
	/// If this parameter is NULL, the ID of the last-resort fallback glyph is returned, which will be zero.</param>
	/// <param name="GlyphIndex">The index of the glyph in the DirectWrite font face.
	/// Glyph indices can be obtained from DirectWrite using IDWriteFontFace::GetGlyphIndices.</param>
	/// <param name="pFontFace">The DirectWrite font face that contains the glyph referenced by GlyphIndex.</param>
	/// <param name="FontFlags">Can include zero or more of the following values, ORd together. Any additional values are ignored.<br/>
	/// FW1_NONEWGLYPHS - No new glyphs are inserted.</param>
	virtual UINT STDMETHODCALLTYPE GetAtlasIdFromGlyphIndex(
		__in const void *pGlyphMap,
		__in UINT16 GlyphIndex,
		__in IDWriteFontFace *pFontFace,
		__in UINT FontFlags
	) = 0;
};

/// <summary>Container for a DirectWrite render-target, used to draw glyph images that are to be inserted in a glyph atlas.</summary>
/// <remarks></remarks>
MIDL_INTERFACE("A1EB4141-9A66-4097-A5B0-6FC84F8B162C") IFW1DWriteRenderTarget : public IFW1Object {
	/// <summary>Draw a glyph-image.</summary>
	/// <remarks>The data returned in the FW1_GLYPHIMAGEDATA should only be read, and is valid until the next call to a method in the IFW1DWriteRenderTarget.<br/>
	/// This method is not thread-safe.</remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="pFontFace">The DirectWrite font face containing the glyph.</param>
	/// <param name="GlyphIndex">The index of the glyph in the font face.</param>
	/// <param name="FontSize">The size of the font.</param>
	/// <param name="RenderingMode">The DirectWrite rendering mode. See DirectWrite documentation.</param>
	/// <param name="MeasuringMode">The DirectWrite measuring mode. See DirectWrite documentation..</param>
	/// <param name="pOutData">A pointer to an FW1_GLYPHIMAGEDATA structure that will be filled in with the glyph image data on success.</param>
	virtual HRESULT STDMETHODCALLTYPE DrawGlyphTemp(
		__in IDWriteFontFace *pFontFace,
		__in UINT16 GlyphIndex,
		__in FLOAT FontSize,
		__in DWRITE_RENDERING_MODE RenderingMode,
		__in DWRITE_MEASURING_MODE MeasuringMode,
		__out FW1_GLYPHIMAGEDATA *pOutData
	) = 0;
};

/// <summary>An RGBA color.</summary>
/// <remarks>An IFW1ColorRGBA object can be set as the drawing effect for a range in an IDWriteTextLayout, to override the default color of the text.</remarks>
MIDL_INTERFACE("A0EA03A0-441D-49BE-9D2C-4AE27BB7A327") IFW1ColorRGBA : public IFW1Object {
	/// <summary>Set the color.</summary>
	/// <remarks></remarks>
	/// <returns>No return value.</returns>
	/// <param name="Color">The color to set, as 0xAaBbGgRr.</param>
	virtual void STDMETHODCALLTYPE SetColor(
		__in UINT32 Color
	) = 0;
	
	/// <summary>Set the color.</summary>
	/// <remarks></remarks>
	/// <returns>No return value.</returns>
	/// <param name="Red">The red component, in [0, 1].</param>
	/// <param name="Green">The green component, in [0, 1].</param>
	/// <param name="Blue">The blue component, in [0, 1].</param>
	/// <param name="Alpha">The alpha component, in [0, 1].</param>
	virtual void STDMETHODCALLTYPE SetColor(
		__in FLOAT Red,
		__in FLOAT Green,
		__in FLOAT Blue,
		__in FLOAT Alpha
	) = 0;
	
	/// <summary>Set the color.</summary>
	/// <remarks></remarks>
	/// <returns>No return value.</returns>
	/// <param name="pColor">Pointer to an array of four floats in [0, 1], specifying the red, green, blue and alpha components at indices 0 to 3.</param>
	virtual void STDMETHODCALLTYPE SetColor(
		__in const FLOAT *pColor
	) = 0;
	
	/// <summary>Set the color.</summary>
	/// <remarks></remarks>
	/// <returns>No return value.</returns>
	/// <param name="pColor">Pointer to an array of four bytes in [0, 255], specifying the red, green, blue and alpha components at indices 0 to 3.</param>
	virtual void STDMETHODCALLTYPE SetColor(
		__in const BYTE *pColor
	) = 0;
	
	/// <summary>Get the color.</summary>
	/// <remarks></remarks>
	/// <returns>Returns the color, as 0xAaBbGgRr.</returns>
	virtual UINT32 STDMETHODCALLTYPE GetColor32(
	) = 0;
};

/// <summary>A dynamic list of vertices. Note that this object is a simple array without synchronization and not safe to use simultaneously on more than one thread.</summary>
/// <remarks>When rendering a string, a vertex is inserted into an IFW1TextGeometry object for each glyph.
/// The vertices in an IFW1TextGeometry can be drawn by the IFW1FontWrapper::DrawGeometry method.<br/>
/// A pointer to the actual vertices can be obtained with the IFW1TextGeometry::GetGlyphVerticesTemp method.</remarks>
MIDL_INTERFACE("51E05736-6AFF-44A8-9745-77605C99E8F2") IFW1TextGeometry : public IFW1Object {
	/// <summary>Clear any vertices currently contained in the geometry object.</summary>
	/// <remarks>This method is not thread-safe.</remarks>
	/// <returns>No return value.</returns>
	virtual void STDMETHODCALLTYPE Clear(
	) = 0;
	
	/// <summary>Adds a vertex to the geometry.</summary>
	/// <remarks>The GlyphIndex member of the FW1_GLYPHVERTEX specified when inserting a vertex should be the atlas ID of the desired glyph, as <tt>((SheetIndex &lt;&lt; 16) | GlyphIndex)</tt>.
	/// See IFW1GlyphAtlas::InsertGlyph.<br/>
	/// This method is not thread-safe.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pVertex">Pointer to an FW1_GLYPHVERTEX structure describing the vertex.</param>
	virtual void STDMETHODCALLTYPE AddGlyphVertex(
		__in const FW1_GLYPHVERTEX *pVertex
	) = 0;
	
	/// <summary>Get the vertices in the geometry, sorted by glyph sheet.</summary>
	/// <remarks>When glyphs are inserted into the geometry they contain their glyph atlas ID.
	/// The glyphs are internally sorted by glyph sheet, and glyphs returned by GetGlyphVerticesTemp contain the index of the glyph in its containing sheet, and not the atlas ID.<br/>
	/// This method is not thread-safe.</remarks>
	/// <returns>An FW1_VERTEXDATA structure containing the glyph vertices.
	/// The pointers in this structure are owned by the geometry object and should not be modified.
	/// They are valid until the next call to a method in the IFW1TextGeometry.</returns>
	virtual FW1_VERTEXDATA STDMETHODCALLTYPE GetGlyphVerticesTemp(
	) = 0;
};

/// <summary>A text-renderer converts DirectWrite text layouts into glyph-vertices.</summary>
/// <remarks></remarks>
MIDL_INTERFACE("51E05736-6AFF-44A8-9745-77605C99E8F2") IFW1TextRenderer : public IFW1Object {
	/// <summary>Get the IFW1GlyphProvider used by a text-renderer.</summary>
	/// <remarks>The glyph provider is used internally to get the atlas IDs for any glyphs needed when drawing a text layout.</remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppGlyphProvider">Address of a pointer to an IFW1GlyphProvider.</param>
	virtual HRESULT STDMETHODCALLTYPE GetGlyphProvider(
		__out IFW1GlyphProvider **ppGlyphProvider
	) = 0;
	
	/// <summary>Convert a text layout to vertices.</summary>
	/// <remarks>This method internally calls the IDWriteTextLayout::Draw method, and handles callbacks to convert the formatted text into vertices, which will be stored in the passed IFW1TextGeometry object.
	/// This method is not thread-safe.</remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="pTextLayout">A DirectWrite text layout. See the DirectWrite documentation.</param>
	/// <param name="OriginX">The X origin of the text.</param>
	/// <param name="OriginY">The Y origin of the text.</param>
	/// <param name="Color">The default text color, as 0xAaGgBbRr.</param>
	/// <param name="Flags">Can include zero or more of the following values, ORd together. Any additional values are ignored.<br/>
	/// FW1_ALIASED - No anti-aliasing is used when drawing the glyphs.<br/>
	/// FW1_NONEWGLYPHS - No new glyphs are inserted into the atlas. Not previously cached glyphs are replaced with a fallback glyph (usually an empty box).<br/>
	/// FW1_CACHEONLY - All glyphs are queried from the glyph-provider and cached in the glyph-atlas, but no geometry is produced.<br/>
	/// FW1_ANALYZEONLY - The text-layout is analyzed and glyph-maps are prepared, but the glyphs in the string are not cached and no geometry is produced.<br/>
	/// </param>
	/// <param name="pTextGeometry">An IFW1TextGeometry object that the output vertices will be appended to.</param>
	virtual HRESULT STDMETHODCALLTYPE DrawTextLayout(
		__in IDWriteTextLayout *pTextLayout,
		__in FLOAT OriginX,
		__in FLOAT OriginY,
		__in UINT32 Color,
		__in UINT Flags,
		__in IFW1TextGeometry *pTextGeometry
	) = 0;
};

/// <summary>This interface contains all render states and shaders needed to draw glyphs.</summary>
/// <remarks></remarks>
MIDL_INTERFACE("906928B6-79D8-4b42-8CE4-DC7D7046F206") IFW1GlyphRenderStates : public IFW1Object {
	/// <summary>Get the ID3D11Device that all render states are created on.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppDevice">Address of a pointer to an ID3D11Device.</param>
	virtual HRESULT STDMETHODCALLTYPE GetDevice(
		__out ID3D11Device **ppDevice
	) = 0;
	
	/// <summary>Set the internal states on a context.</summary>
	/// <remarks></remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The context to set the states on.</param>
	/// <param name="Flags">Can include zero or more of the following values, ORd together. Any additional values are ignored.<br/>
	/// FW1_NOGEOMETRYSHADER - States are set up to draw indexed quads instead of constructing quads in the geometry shader.<br/>
	/// FW1_CLIPRECT - Shaders will be set up to clip any drawn glyphs to the clip-rect set in IFW1GlyphRenderStates::UpdateShaderConstants.
	/// </param>
	virtual void STDMETHODCALLTYPE SetStates(
		__in ID3D11DeviceContext *pContext,
		__in UINT Flags
	) = 0;
	
	/// <summary>Update the internal constant buffer.</summary>
	/// <remarks></remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The context to use to update the constant buffer.</param>
	/// <param name="pClipRect">A pointer to a rectangle to clip drawn glyphs to.</param>
	/// <param name="pTransformMatrix">An array of 16 floats, representing a matrix which all glyph vertices will be multiplied with, in the geometry or vertex shader.</param>
	virtual void STDMETHODCALLTYPE UpdateShaderConstants(
		__in ID3D11DeviceContext *pContext,
		__in const FW1_RECTF *pClipRect,
		__in const FLOAT *pTransformMatrix
	) = 0;
	
	/// <summary>Returns whether a geometry shader is available.</summary>
	/// <remarks>When an IFW1GlyphRenderStates object is created, it may attempt to create a geometry shader, depending on the parameters passed to IFW1Factory::CreateRenderStates.
	/// If a geometry shader is not created, either because of the specified parameters or because the device feature level does not support geometry shaders, this method will return FALSE.</remarks>
	/// <returns>Returns TRUE if a geometry shader is available, and otherwise returns FALSE.</returns>
	virtual BOOL STDMETHODCALLTYPE HasGeometryShader(
	) = 0;
};

/// <summary>A container for a dynamic vertex and index buffer, used to draw glyph vertices.</summary>
/// <remarks></remarks>
MIDL_INTERFACE("E6CD7A32-5B59-463c-9B1B-D44074FF655B") IFW1GlyphVertexDrawer : public IFW1Object {
	/// <summary>Get the ID3D11Device that the buffers are created on.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppDevice">Address of a pointer to an ID3D11Device.</param>
	virtual HRESULT STDMETHODCALLTYPE GetDevice(
		__out ID3D11Device **ppDevice
	) = 0;
	
	/// <summary>Upload the specified vertices to the device buffers and draw them.</summary>
	/// <remarks></remarks>
	/// <returns>Returns the index of the sheet in the atlas that was last bound to the device context during the operation.</returns>
	/// <param name="pContext">The context to use to draw.</param>
	/// <param name="pGlyphAtlas">The glyph atlas containg the glyphs referenced by the vertices.</param>
	/// <param name="pVertexData">Pointer to an FW1_VERTEXDATA structure, containing vertices to be drawn, sorted by glyph sheet.
	/// These are easiest obtained from an IFW1TextGeometry object.</param>
	/// <param name="Flags">Can include zero or more of the following values, ORd together. Any additional values are ignored.<br/>
	/// FW1_NOGEOMETRYSHADER - Vertices are converted to quads on the fly on the CPU, instead of being sent directly to the device for the geometry shader.<br/>
	/// FW1_BUFFERSPREPARED - The internal buffers are assumed to already be set on the device context from a previous call. (Avoids redundant state changes when drawing multiple times).
	/// </param>
	/// <param name="PreboundSheet">If a sheet in the atlas is known to already be correctly set on the device context, specify its index in the atlas with this parameter, to avoid redundant state changes.
	/// If no sheet is known to already be set, specify 0xFFFFFFFF, or another value greater than the number of sheets in the atlas.
	/// </param>
	virtual UINT STDMETHODCALLTYPE DrawVertices(
		__in ID3D11DeviceContext *pContext,
		__in IFW1GlyphAtlas *pGlyphAtlas,
		__in const FW1_VERTEXDATA *pVertexData,
		__in UINT Flags,
		__in UINT PreboundSheet
	) = 0;
};

/// <summary>The IFW1FontWrapper interface is the main interface used to draw text.
/// It holds references to all objects needed to format and convert text to vertices, as well as the D3D11 states and buffers needed to draw them.</summary>
/// <remarks>Create a font-wrapper using IFW1Factory::CreateFontWrapper</remarks>
MIDL_INTERFACE("83347A5C-B0B1-460e-A35C-427E8B85F9F4") IFW1FontWrapper : public IFW1Object {
	/// <summary>Get the ID3D11Device that is used by the font-wrapper.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppDevice">Address of a pointer to an ID3D11Device.</param>
	virtual HRESULT STDMETHODCALLTYPE GetDevice(
		__out ID3D11Device **ppDevice
	) = 0;
	
	/// <summary>Get the DirectWrite factory used by the font-wrapper.</summary>
	/// <remarks>The DirectWrite factory is used internally to create text-layouts when drawing strings using any of the DrawString methods.</remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppDWriteFactory">Address of a pointer to an IDWriteFactory.</param>
	virtual HRESULT STDMETHODCALLTYPE GetDWriteFactory(
		__out IDWriteFactory **ppDWriteFactory
	) = 0;
	
	/// <summary>Get the IFW1GlyphAtlas used to cache glyphs.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppGlyphAtlas">Address of a pointer to an IFW1GlyphAtlas.</param>
	virtual HRESULT STDMETHODCALLTYPE GetGlyphAtlas(
		__out IFW1GlyphAtlas **ppGlyphAtlas
	) = 0;
	
	/// <summary>Get the IFW1GlyphProvider used to map glyphs to atlas IDs.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppGlyphProvider">Address of a pointer to an IFW1GlyphProvider.</param>
	virtual HRESULT STDMETHODCALLTYPE GetGlyphProvider(
		__out IFW1GlyphProvider **ppGlyphProvider
	) = 0;
	
	/// <summary>Get the IFW1GlyphRenderStates containing the render states needed to draw glyphs.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppRenderStates">Address of a pointer to an IFW1GlyphRenderStates.</param>
	virtual HRESULT STDMETHODCALLTYPE GetRenderStates(
		__out IFW1GlyphRenderStates **ppRenderStates
	) = 0;
	
	/// <summary>Get the IFW1GlyphVertexDrawer used to draw glyph vertices.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppVertexDrawer">Address of a pointer to an IFW1GlyphVertexDrawer.</param>
	virtual HRESULT STDMETHODCALLTYPE GetVertexDrawer(
		__out IFW1GlyphVertexDrawer **ppVertexDrawer
	) = 0;
	
	/// <summary>Draw a DirectWrite text layout.</summary>
	/// <remarks>Consult the DirectWrite documentation for details on how to construct a text-layout.<br/>
	/// The pContext parameter can be NULL only if the FW1_NOFLUSH and either the FW1_ANALYZEONLY or the FW1_CACHEONLY flags are specified.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The device context to draw on.</param>
	/// <param name="pTextLayout">The text layout to draw.</param>
	/// <param name="OriginX">The X origin of the text in the layout.</param>
	/// <param name="OriginY">The Y origin of the text in the layout.</param>
	/// <param name="Color">The default color of the text, as 0xAaBbGgRr.</param>
	/// <param name="Flags">See FW1_TEXT_FLAG. The alignment and word-wrapping flags have no meaning when drawing a preconstructed text layout.</param>
	virtual void STDMETHODCALLTYPE DrawTextLayout(
		__in ID3D11DeviceContext *pContext,
		__in IDWriteTextLayout *pTextLayout,
		__in FLOAT OriginX,
		__in FLOAT OriginY,
		__in UINT32 Color,
		__in UINT Flags
	) = 0;
	
	/// <summary>Draw a DirectWrite text layout.</summary>
	/// <remarks>Consult the DirectWrite documentation for details on how to construct a text-layout.<br/>
	/// The pContext parameter can be NULL only if the FW1_NOFLUSH and either the FW1_ANALYZEONLY or the FW1_CACHEONLY flags are specified.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The device context to draw on.</param>
	/// <param name="pTextLayout">The text layout to draw.</param>
	/// <param name="OriginX">The X origin of the text in the layout.</param>
	/// <param name="OriginY">The Y origin of the text in the layout.</param>
	/// <param name="Color">The default color of the text, as 0xAaBbGgRr.</param>
	/// <param name="pClipRect">A pointer to a rectangle to clip the text to if also using the FW1_CLIPRECT flag, or NULL to not clip.</param>
	/// <param name="pTransformMatrix">An array of 16 floats, representing a matrix which the text will be transformed by.</param>
	/// <param name="Flags">See FW1_TEXT_FLAG. The alignment and word-wrapping flags have no meaning when drawing a preconstructed text layout.</param>
	virtual void STDMETHODCALLTYPE DrawTextLayout(
		__in ID3D11DeviceContext *pContext,
		__in IDWriteTextLayout *pTextLayout,
		__in FLOAT OriginX,
		__in FLOAT OriginY,
		__in UINT32 Color,
		__in const FW1_RECTF *pClipRect,
		__in const FLOAT *pTransformMatrix,
		__in UINT Flags
	) = 0;
	
	/// <summary>Draw a string.</summary>
	/// <remarks>The pContext parameter can be NULL only if the FW1_NOFLUSH and either the FW1_ANALYZEONLY or the FW1_CACHEONLY flags are specified.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The device context to draw on.</param>
	/// <param name="pszString">The NULL-terminated string to draw.</param>
	/// <param name="FontSize">The size of the font.</param>
	/// <param name="X">The X origin of the text.</param>
	/// <param name="Y">The Y origin of the text .</param>
	/// <param name="Color">The color of the text, as 0xAaBbGgRr.</param>
	/// <param name="Flags">See the FW1_TEXT_FLAG enumeration.</param>
	virtual void STDMETHODCALLTYPE DrawString(
		__in ID3D11DeviceContext *pContext,
		__in const WCHAR *pszString,
		__in FLOAT FontSize,
		__in FLOAT X,
		__in FLOAT Y,
		__in UINT32 Color,
		__in UINT Flags
	) = 0;
	
	/// <summary>Draw a string.</summary>
	/// <remarks>The pContext parameter can be NULL only if the FW1_NOFLUSH and either the FW1_ANALYZEONLY or the FW1_CACHEONLY flags are specified.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The device context to draw on.</param>
	/// <param name="pszString">The NULL-terminated string to draw.</param>
	/// <param name="pszFontFamily">The font family to use, such as Arial or Courier New.</param>
	/// <param name="FontSize">The size of the font.</param>
	/// <param name="X">The X origin of the text.</param>
	/// <param name="Y">The Y origin of the text .</param>
	/// <param name="Color">The color of the text, as 0xAaBbGgRr.</param>
	/// <param name="Flags">See the FW1_TEXT_FLAG enumeration.</param>
	virtual void STDMETHODCALLTYPE DrawString(
		__in ID3D11DeviceContext *pContext,
		__in const WCHAR *pszString,
		__in const WCHAR *pszFontFamily,
		__in FLOAT FontSize,
		__in FLOAT X,
		__in FLOAT Y,
		__in UINT32 Color,
		__in UINT Flags
	) = 0;
	
	/// <summary>Draw a string.</summary>
	/// <remarks>The pContext parameter can be NULL only if the FW1_NOFLUSH and either the FW1_ANALYZEONLY or the FW1_CACHEONLY flags are specified.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The device context to draw on.</param>
	/// <param name="pszString">The NULL-terminated string to draw.</param>
	/// <param name="pszFontFamily">The font family to use, such as Arial or Courier New.</param>
	/// <param name="FontSize">The size of the font.</param>
	/// <param name="pLayoutRect">A pointer to a rectangle to format the text in.</param>
	/// <param name="Color">The color of the text, as 0xAaBbGgRr.</param>
	/// <param name="pClipRect">A pointer to a rectangle to clip the text to if also using the FW1_CLIPRECT flag, or NULL to not clip.</param>
	/// <param name="pTransformMatrix">An array of 16 floats, representing a matrix which the text will be transformed by, or NULL to draw in screen-space.</param>
	/// <param name="Flags">See the FW1_TEXT_FLAG enumeration.</param>
	virtual void STDMETHODCALLTYPE DrawString(
		__in ID3D11DeviceContext *pContext,
		__in const WCHAR *pszString,
		__in const WCHAR *pszFontFamily,
		__in FLOAT FontSize,
		__in const FW1_RECTF *pLayoutRect,
		__in UINT32 Color,
		__in const FW1_RECTF *pClipRect,
		__in const FLOAT *pTransformMatrix,
		__in UINT Flags
	) = 0;
	
	/// <summary>Measure a string.</summary>
	/// <remarks>This function uses the IDWriteTextLayout::GetOverhangMetrics to obtain the size of the string.</remarks>
	/// <returns>The smallest rectangle that completely contains the string if drawn with DrawString and the same parameters as used with MeasureString.</returns>
	/// <param name="pszString">The NULL-terminated string to measure.</param>
	/// <param name="pszFontFamily">The font family to use, such as Arial or Courier New.</param>
	/// <param name="FontSize">The size of the font.</param>
	/// <param name="pLayoutRect">A pointer to a rectangle to format the text in.</param>
	/// <param name="Flags">See the FW1_TEXT_FLAG enumeration.</param>
	virtual FW1_RECTF STDMETHODCALLTYPE MeasureString(
		__in const WCHAR *pszString,
		__in const WCHAR *pszFontFamily,
		__in FLOAT FontSize,
		__in const FW1_RECTF *pLayoutRect,
		__in UINT Flags
	) = 0;
	
	/// <summary>Analyze a string and generate geometry to draw it.</summary>
	/// <remarks>pTextGeometry can be NULL if the FW1_ANALYZEONLY or FW1_CACHEONLY flags are specified, as no actual geometry will be generated.
	/// pContext can be NULL if the FW1_NOFLUSH flag is used, as any new glyphs will not be flushed to the device buffers.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">A device context to use to update device buffers when new glyphs are added to the glyph-atlas.</param>
	/// <param name="pszString">The NULL-terminated string to create geometry from.</param>
	/// <param name="pszFontFamily">The font family to use, such as Arial or Courier New.</param>
	/// <param name="FontSize">The size of the font.</param>
	/// <param name="pLayoutRect">A pointer to a rectangle to format the text in.</param>
	/// <param name="Color">The color of the text, as 0xAaBbGgRr.</param>
	/// <param name="Flags">See the FW1_TEXT_FLAG enumeration.</param>
	/// <param name="pTextGeometry">An IFW1TextGeometry object that the output vertices will be appended to.</param>
	virtual void STDMETHODCALLTYPE AnalyzeString(
		__in ID3D11DeviceContext *pContext,
		__in const WCHAR *pszString,
		__in const WCHAR *pszFontFamily,
		__in FLOAT FontSize,
		__in const FW1_RECTF *pLayoutRect,
		__in UINT32 Color,
		__in UINT Flags,
		__in IFW1TextGeometry *pTextGeometry
	) = 0;
	
	/// <summary>Analyze a text layout and generate geometry to draw it.</summary>
	/// <remarks>Consult the DirectWrite documentation for details on how to construct a text-layout.
	/// pTextGeometry can be NULL if the FW1_ANALYZEONLY or FW1_CACHEONLY flags are specified, as no actual geometry will be generated.
	/// pContext can be NULL if the FW1_NOFLUSH flag is used, as any new glyphs will not be flushed to the device buffers.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">A device context to use to update device buffers when new glyphs are added to the glyph-atlas.</param>
	/// <param name="pTextLayout">The DirectWrite text layout to create geometry from.</param>
	/// <param name="OriginX">The X origin of the text in the layout.</param>
	/// <param name="OriginY">The Y origin of the text in the layout.</param>
	/// <param name="Color">The default color of the text, as 0xAaBbGgRr.</param>
	/// <param name="Flags">See FW1_TEXT_FLAG. The alignment and word-wrapping flags have no meaning when using a preconstructed text layout.</param>
	/// <param name="pTextGeometry">An IFW1TextGeometry object that the output vertices will be appended to.</param>
	virtual void STDMETHODCALLTYPE AnalyzeTextLayout(
		__in ID3D11DeviceContext *pContext,
		__in IDWriteTextLayout *pTextLayout,
		__in FLOAT OriginX,
		__in FLOAT OriginY,
		__in UINT32 Color,
		__in UINT Flags,
		__in IFW1TextGeometry *pTextGeometry
	) = 0;
	
	/// <summary>Draw geometry.</summary>
	/// <remarks></remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The device context to draw on.</param>
	/// <param name="pGeometry">The geometry to draw.</param>
	/// <param name="pClipRect">A pointer to a rectangle to clip the text to if also using the FW1_CLIPRECT flag, or NULL to not clip. This rect is in text-space, and clipping is performed prior to any transformation.</param>
	/// <param name="pTransformMatrix">An array of 16 floats, representing a matrix which the text will be transformed by, or NULL to draw in screen-space.</param>
	/// <param name="Flags">See the FW1_TEXT_FLAG enumeration.</param>
	virtual void STDMETHODCALLTYPE DrawGeometry(
		__in ID3D11DeviceContext *pContext,
		__in IFW1TextGeometry *pGeometry,
		__in const FW1_RECTF *pClipRect,
		__in const FLOAT *pTransformMatrix,
		__in UINT Flags
	) = 0;
	
	/// <summary>Flush any new glyphs to GPU resources.</summary>
	/// <remarks>This method calls IFW1GlyphAtlas::Flush to flush any newly cached glyphs.
	/// This method is only needed if drawing text using the FW1_NOFLUSH flag and delaying flushing data to the device, as otherwise it is implicitly called whenever a string is drawn. See IFW1GlyphAtlas::Flush.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The device context to use to update device resources.</param>
	virtual void STDMETHODCALLTYPE Flush(
		__in ID3D11DeviceContext *pContext
	) = 0;
};

/// <summary>
/// Used to create all subsequent FW1 objects.
/// An IFW1Factory can be created using FW1CreateFactory.
/// </summary>
/// <remarks>
/// Any and all FW1 objects are always created through a factory. All FW1 objects inherit from IFW1Object, and holds a reference to the factory that created them.
/// If an object in turn creates new objects, it uses the same factory that created the object itself.
/// For example, a glyph-atlas will ask the factory that created it to create new glyph-sheets as glyphs are added to the atlas.
/// </remarks>
MIDL_INTERFACE("8004DB2B-B5F9-4420-A6A2-E17E15E4C336") IFW1Factory : public IUnknown {
	public:
		/// <summary>Create an IFW1FontWrapper object with default settings.</summary>
		/// <returns>Standard HRESULT error code.</returns>
		/// <remarks></remarks>
		/// <param name="pDevice">The ID3D11Device the font-wrapper will be used with.</param>
		/// <param name="pszFontFamily">The default font-family to use when drawing strings.
		/// Valid values include for example L"Arial" and L"Courier New", provided that the fonts are installed on the system.
		/// Font-fallback will automatically choose a different font if the specified one is not available.</param>
		/// <param name="ppFontWrapper">Address of a pointer to a font-wrapper (See IFW1FontWrapper).</param>
		virtual HRESULT STDMETHODCALLTYPE CreateFontWrapper(
			__in ID3D11Device *pDevice,
			__in LPCWSTR pszFontFamily,
			__out IFW1FontWrapper **ppFontWrapper
		) = 0;
		
		/// <summary>Create an IFW1FontWrapper object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pDevice">The ID3D11Device that the font-wrapper will be used with.</param>
		/// <param name="pCreateParams">Pointer to an FW1_FONTWRAPPERCREATEPARAMS structure that describes the settings for the new font-wrapper.</param>
		/// <param name="ppFontWrapper">Address of a pointer to a font-wrapper (See IFW1FontWrapper).</param>
		virtual HRESULT STDMETHODCALLTYPE CreateFontWrapper(
			__in ID3D11Device *pDevice,
			__in IDWriteFactory *pDWriteFactory,
			__in const FW1_FONTWRAPPERCREATEPARAMS *pCreateParams,
			__out IFW1FontWrapper **ppFontWrapper
		) = 0;
		
		/// <summary>Create an IFW1FontWrapper object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pDevice">The ID3D11Device that the font-wrapper will be used with.</param>
		/// <param name="pGlyphAtlas">An IFW1GlyphAtlas that glyph-images will be stored in.</param>
		/// <param name="pGlyphProvider">An IFW1GlyphProvider that handles fonts and glyphmaps.</param>
		/// <param name="pGlyphVertexDrawer">An IFW1GlyphVertexDrawer that handles drawing glyph-vertices.</param>
		/// <param name="pGlyphRenderStates">An IFW1GlyphRenderStates that handles all needed context states when drawing glyphs.</param>
		/// <param name="pDWriteFactory">An IDWriteFactory that is used to create render-targets to draw glyphs with.</param>
		/// <param name="pDefaultFontParams">Pointer to an FW1_DWRITEFONTPARAMS that describes the default font.
		/// Can be NULL if only drawing preconstructed DirectWrite text layouts.</param>
		/// <param name="ppFontWrapper">Address of a pointer to a font-wrapper (See IFW1FontWrapper).</param>
		virtual HRESULT STDMETHODCALLTYPE CreateFontWrapper(
			__in ID3D11Device *pDevice,
			__in IFW1GlyphAtlas *pGlyphAtlas,
			__in IFW1GlyphProvider *pGlyphProvider,
			__in IFW1GlyphVertexDrawer *pGlyphVertexDrawer,
			__in IFW1GlyphRenderStates *pGlyphRenderStates,
			__in IDWriteFactory *pDWriteFactory,
			__in const FW1_DWRITEFONTPARAMS *pDefaultFontParams,
			__out IFW1FontWrapper **ppFontWrapper
		) = 0;
		
		/// <summary>Create an IFW1GlyphVertexDrawer object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pDevice">The ID3D11Device that the vertex drawer will be used with.</param>
		/// <param name="VertexBufferSize">The size in bytes of the dynamic vertex buffer. An index buffer will be created with a matching size.</param>
		/// <param name="ppGlyphVertexDrawer">Address of a pointer to a glyph-vertex drawer (See IFW1GlyphVertexDrawer).</param>
		virtual HRESULT STDMETHODCALLTYPE CreateGlyphVertexDrawer(
			__in ID3D11Device *pDevice,
			__in UINT VertexBufferSize,
			__out IFW1GlyphVertexDrawer **ppGlyphVertexDrawer
		) = 0;
		
		/// <summary>Create an IFW1GlyphRenderStates object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pDevice">The ID3D11Device that the render-states will be used with.</param>
		/// <param name="DisableGeometryShader">If TRUE, no geometry shader will be created.</param>
		/// <param name="AnisotropicFiltering">If TRUE, a sampler state enabling anisotropic filtering will be created.</param>
		/// <param name="ppGlyphRenderStates">Address of a pointer to a glyph render-states object (See IFW1GlyphRenderStates).</param>
		virtual HRESULT STDMETHODCALLTYPE CreateGlyphRenderStates(
			__in ID3D11Device *pDevice,
			__in BOOL DisableGeometryShader,
			__in BOOL AnisotropicFiltering,
			__out IFW1GlyphRenderStates **ppGlyphRenderStates
		) = 0;
		
		/// <summary>Create an IFW1TextRenderer object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pGlyphProvider">The IFW1GlyphProvider that provides glyph-information for the text-renderer.</param>
		/// <param name="ppTextRenderer">Address of a pointer to a IFW1TextRenderer.</param>
		virtual HRESULT STDMETHODCALLTYPE CreateTextRenderer(
			__in IFW1GlyphProvider *pGlyphProvider,
			__out IFW1TextRenderer **ppTextRenderer
		) = 0;
		
		/// <summary>Create an IFW1TextGeometry object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="ppTextGeometry">Address of a pointer to an IFW1TextGeometry.</param>
		virtual HRESULT STDMETHODCALLTYPE CreateTextGeometry(
			__out IFW1TextGeometry **ppTextGeometry
		) = 0;
		
		/// <summary>Create an IFW1GlyphProvider object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pGlyphAtlas">A glyph atlas to store glyph images in.</param>
		/// <param name="pDWriteFactory">A DirectWrite factory, used to create glyph render targets.</param>
		/// <param name="pFontCollection">A font collection used to identify fonts from DirectWrite font-face objects.</param>
		/// <param name="MaxGlyphWidth">The maximum width of a single glyph.</param>
		/// <param name="MaxGlyphHeight">The maximum height of a single glyph.</param>
		/// <param name="ppGlyphProvider">Address of a pointer to an IFW1GlyphProvider.</param>
		virtual HRESULT STDMETHODCALLTYPE CreateGlyphProvider(
			__in IFW1GlyphAtlas *pGlyphAtlas,
			__in IDWriteFactory *pDWriteFactory,
			__in IDWriteFontCollection *pFontCollection,
			__in UINT MaxGlyphWidth,
			__in UINT MaxGlyphHeight,
			__out IFW1GlyphProvider **ppGlyphProvider
		) = 0;
		
		/// <summary>Create an IFW1DWriteRenderTarget object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pDWriteFactory">A DirectWrite factory used to create the internal render target.</param>
		/// <param name="RenderTargetWidth">The width of the render target.</param>
		/// <param name="RenderTargetHeight">The height of the render target.</param>
		/// <param name="ppRenderTarget">Address of a pointer to an IFW1DWriteRenderTarget.</param>
		virtual HRESULT STDMETHODCALLTYPE CreateDWriteRenderTarget(
			__in IDWriteFactory *pDWriteFactory,
			__in UINT RenderTargetWidth,
			__in UINT RenderTargetHeight,
			__out IFW1DWriteRenderTarget **ppRenderTarget
		) = 0;
		
		/// <summary>Create an IFW1GlyphAtlas object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pDevice">A D3D11 device used to create device resources.</param>
		/// <param name="GlyphSheetWidth">Width of the atlas textures.</param>
		/// <param name="GlyphSheetHeight">Height of the atlas textures.</param>
		/// <param name="HardwareCoordBuffer">If TRUE, create a D3D11 buffer with glyph coordinates for each sheet, for use with the geometry shader.</param>
		/// <param name="AllowOversizedGlyph">If FALSE, glyphs that are larger than the atlas textures will be rejected instead of partially inserted.</param>
		/// <param name="MaxGlyphCountPerSheet">The maximum number of glyphs in a single sheet texture.</param>
		/// <param name="MipLevels">The number of mip levels for the textures.</param>
		/// <param name="MaxGlyphSheetCount">The maximum number of sheet textures.</param>
		/// <param name="ppGlyphAtlas">Address of a pointer to an IFW1GlyphAtlas.</param>
		virtual HRESULT STDMETHODCALLTYPE CreateGlyphAtlas(
			__in ID3D11Device *pDevice,
			__in UINT GlyphSheetWidth,
			__in UINT GlyphSheetHeight,
			__in BOOL HardwareCoordBuffer,
			__in BOOL AllowOversizedGlyph,
			__in UINT MaxGlyphCountPerSheet,
			__in UINT MipLevels,
			__in UINT MaxGlyphSheetCount,
			__out IFW1GlyphAtlas **ppGlyphAtlas
		) = 0;
		
		/// <summary>Create an IFW1GlyphSheet object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pDevice">A D3D11 device used to create device resources.</param>
		/// <param name="GlyphSheetWidth">Width of the sheet texture.</param>
		/// <param name="GlyphSheetHeight">Height of the sheet texture.</param>
		/// <param name="HardwareCoordBuffer">If TRUE, create a D3D11 buffer with glyph coordinates, for use with the geometry shader.</param>
		/// <param name="AllowOversizedGlyph">If FALSE, glyphs that are larger than the sheet texture will be rejected instead of partially inserted.</param>
		/// <param name="MaxGlyphCount">The maximum number of glyphs in the sheet.</param>
		/// <param name="MipLevels">The number of mip levels for the texture.</param>
		/// <param name="ppGlyphSheet">Address of a pointer to an IFW1GlyphSheet.</param>
		virtual HRESULT STDMETHODCALLTYPE CreateGlyphSheet(
			__in ID3D11Device *pDevice,
			__in UINT GlyphSheetWidth,
			__in UINT GlyphSheetHeight,
			__in BOOL HardwareCoordBuffer,
			__in BOOL AllowOversizedGlyph,
			__in UINT MaxGlyphCount,
			__in UINT MipLevels,
			__out IFW1GlyphSheet **ppGlyphSheet
		) = 0;
		
		/// <summary>Create an IFW1ColorRGBA object.</summary>
		/// <remarks>An IFW1ColorRGBA can be set as the drawing effect for a range in a DirectWrite text layout to override the default color.</remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="Color">The initial color, as 0xAaBbGgRr.</param>
		/// <param name="ppColor">Address of a pointer to an IFW1ColorRGBA.</param>
		virtual HRESULT STDMETHODCALLTYPE CreateColor(
			__in UINT32 Color,
			__out IFW1ColorRGBA **ppColor
		) = 0;
};

#ifdef FW1_COMPILETODLL
	extern "C" __declspec(dllexport) HRESULT STDMETHODCALLTYPE FW1CreateFactory(
		__in UINT32 Version,
		__out IFW1Factory **ppFactory
	);
#else
	/// <summary>The FW1CreateFactory method creates an IFWFactory object, that can subsequently be used to create any and all FW1 objects.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="Version">Set to FW1_VERSION. Is used to make sure the header matches the library version.</param>
	/// <param name="ppFactory">Address of a pointer to an IFW1Factory.</param>
	extern "C" HRESULT STDMETHODCALLTYPE FW1CreateFactory(
		__in UINT32 Version,
		__out IFW1Factory **ppFactory
	);
#endif

typedef HRESULT (STDMETHODCALLTYPE * PFN_FW1CREATEFACTORY) (UINT32 Version, IFW1Factory **ppFactory);


#endif// IncludeGuard__FW1_FW1FontWrapper_h

```

`include/vendor/fontwrapper/FW1Precompiled.h`:

```h
// FW1Precompiled.h

#ifndef IncludeGuard__FW1_FW1Precompiled_h
#define IncludeGuard__FW1_FW1Precompiled_h


#define NOMINMAX
#include <D3D11.h>
#include <D3DCompiler.h>
#include <DWrite.h>
#include <intrin.h>
#include <string>
#include <vector>
#include <map>
#include <stack>
#include <cfloat>
#include <cmath>
#include <algorithm>

#include "FW1CompileSettings.h"
#include "FW1FontWrapper.h"


#endif// IncludeGuard__FW1_FW1Precompiled_h

```

`include/vendor/math/SimpleMath.h`:

```h
//-------------------------------------------------------------------------------------
// SimpleMath.h -- Simplified C++ Math wrapper for DirectXMath
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//
// http://go.microsoft.com/fwlink/?LinkId=248929
// http://go.microsoft.com/fwlink/?LinkID=615561
//-------------------------------------------------------------------------------------

#pragma once

#if !(defined(_XBOX_ONE) && defined(_TITLE)) && !defined(_GAMING_XBOX)
#include <dxgi1_2.h>
#endif

#include <functional>

#include <assert.h>
#include <memory.h>

#include <DirectXMath.h>
#include <DirectXPackedVector.h>
#include <DirectXCollision.h>

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wfloat-equal"
#endif


namespace DirectX
{
    namespace SimpleMath
    {
        struct Vector2;
        struct Vector4;
        struct Matrix;
        struct Quaternion;
        struct Plane;

        //------------------------------------------------------------------------------
        // 2D rectangle
        struct Rectangle
        {
            long x;
            long y;
            long width;
            long height;

            // Creators
            Rectangle() noexcept : x(0), y(0), width(0), height(0) {}
            constexpr Rectangle(long ix, long iy, long iw, long ih) noexcept : x(ix), y(iy), width(iw), height(ih) {}
            explicit Rectangle(const RECT& rct) noexcept : x(rct.left), y(rct.top), width(rct.right - rct.left), height(rct.bottom - rct.top) {}

            Rectangle(const Rectangle&) = default;
            Rectangle& operator=(const Rectangle&) = default;

            Rectangle(Rectangle&&) = default;
            Rectangle& operator=(Rectangle&&) = default;

            operator RECT() noexcept { RECT rct; rct.left = x; rct.top = y; rct.right = (x + width); rct.bottom = (y + height); return rct; }
        #ifdef __cplusplus_winrt
            operator Windows::Foundation::Rect() noexcept { return Windows::Foundation::Rect(float(x), float(y), float(width), float(height)); }
        #endif

            // Comparison operators
            bool operator == (const Rectangle& r) const noexcept { return (x == r.x) && (y == r.y) && (width == r.width) && (height == r.height); }
            bool operator == (const RECT& rct) const noexcept { return (x == rct.left) && (y == rct.top) && (width == (rct.right - rct.left)) && (height == (rct.bottom - rct.top)); }

            bool operator != (const Rectangle& r) const noexcept { return (x != r.x) || (y != r.y) || (width != r.width) || (height != r.height); }
            bool operator != (const RECT& rct) const noexcept { return (x != rct.left) || (y != rct.top) || (width != (rct.right - rct.left)) || (height != (rct.bottom - rct.top)); }

            // Assignment operators
            Rectangle& operator=(_In_ const RECT& rct) noexcept { x = rct.left; y = rct.top; width = (rct.right - rct.left); height = (rct.bottom - rct.top); return *this; }

            // Rectangle operations
            Vector2 Location() const noexcept;
            Vector2 Center() const noexcept;

            bool IsEmpty() const noexcept { return (width == 0 && height == 0 && x == 0 && y == 0); }

            bool Contains(long ix, long iy) const noexcept { return (x <= ix) && (ix < (x + width)) && (y <= iy) && (iy < (y + height)); }
            bool Contains(const Vector2& point) const noexcept;
            bool Contains(const Rectangle& r) const noexcept { return (x <= r.x) && ((r.x + r.width) <= (x + width)) && (y <= r.y) && ((r.y + r.height) <= (y + height)); }
            bool Contains(const RECT& rct) const noexcept { return (x <= rct.left) && (rct.right <= (x + width)) && (y <= rct.top) && (rct.bottom <= (y + height)); }

            void Inflate(long horizAmount, long vertAmount) noexcept;

            bool Intersects(const Rectangle& r) const noexcept { return (r.x < (x + width)) && (x < (r.x + r.width)) && (r.y < (y + height)) && (y < (r.y + r.height)); }
            bool Intersects(const RECT& rct) const noexcept { return (rct.left < (x + width)) && (x < rct.right) && (rct.top < (y + height)) && (y < rct.bottom); }

            void Offset(long ox, long oy) noexcept { x += ox; y += oy; }

            // Static functions
            static Rectangle Intersect(const Rectangle& ra, const Rectangle& rb) noexcept;
            static RECT Intersect(const RECT& rcta, const RECT& rctb) noexcept;

            static Rectangle Union(const Rectangle& ra, const Rectangle& rb) noexcept;
            static RECT Union(const RECT& rcta, const RECT& rctb) noexcept;
        };

        //------------------------------------------------------------------------------
        // 2D vector
        struct Vector2 : public XMFLOAT2
        {
            Vector2() noexcept : XMFLOAT2(0.f, 0.f) {}
            constexpr explicit Vector2(float ix) noexcept : XMFLOAT2(ix, ix) {}
            constexpr Vector2(float ix, float iy) noexcept : XMFLOAT2(ix, iy) {}
            explicit Vector2(_In_reads_(2) const float *pArray) noexcept : XMFLOAT2(pArray) {}
            Vector2(FXMVECTOR V) noexcept { XMStoreFloat2(this, V); }
            Vector2(const XMFLOAT2& V) noexcept { this->x = V.x; this->y = V.y; }
            explicit Vector2(const XMVECTORF32& F) noexcept { this->x = F.f[0]; this->y = F.f[1]; }

            Vector2(const Vector2&) = default;
            Vector2& operator=(const Vector2&) = default;

            Vector2(Vector2&&) = default;
            Vector2& operator=(Vector2&&) = default;

            operator XMVECTOR() const noexcept { return XMLoadFloat2(this); }

            // Comparison operators
            bool operator == (const Vector2& V) const noexcept;
            bool operator != (const Vector2& V) const noexcept;

            // Assignment operators
            Vector2& operator= (const XMVECTORF32& F) noexcept { x = F.f[0]; y = F.f[1]; return *this; }
            Vector2& operator+= (const Vector2& V) noexcept;
            Vector2& operator-= (const Vector2& V) noexcept;
            Vector2& operator*= (const Vector2& V) noexcept;
            Vector2& operator*= (float S) noexcept;
            Vector2& operator/= (float S) noexcept;

            // Unary operators
            Vector2 operator+ () const noexcept { return *this; }
            Vector2 operator- () const noexcept { return Vector2(-x, -y); }

            // Vector operations
            bool InBounds(const Vector2& Bounds) const noexcept;

            float Length() const noexcept;
            float LengthSquared() const noexcept;

            float Dot(const Vector2& V) const noexcept;
            void Cross(const Vector2& V, Vector2& result) const noexcept;
            Vector2 Cross(const Vector2& V) const noexcept;

            void Normalize() noexcept;
            void Normalize(Vector2& result) const noexcept;

            void Clamp(const Vector2& vmin, const Vector2& vmax) noexcept;
            void Clamp(const Vector2& vmin, const Vector2& vmax, Vector2& result) const noexcept;

            // Static functions
            static float Distance(const Vector2& v1, const Vector2& v2) noexcept;
            static float DistanceSquared(const Vector2& v1, const Vector2& v2) noexcept;

            static void Min(const Vector2& v1, const Vector2& v2, Vector2& result) noexcept;
            static Vector2 Min(const Vector2& v1, const Vector2& v2) noexcept;

            static void Max(const Vector2& v1, const Vector2& v2, Vector2& result) noexcept;
            static Vector2 Max(const Vector2& v1, const Vector2& v2) noexcept;

            static void Lerp(const Vector2& v1, const Vector2& v2, float t, Vector2& result) noexcept;
            static Vector2 Lerp(const Vector2& v1, const Vector2& v2, float t) noexcept;

            static void SmoothStep(const Vector2& v1, const Vector2& v2, float t, Vector2& result) noexcept;
            static Vector2 SmoothStep(const Vector2& v1, const Vector2& v2, float t) noexcept;

            static void Barycentric(const Vector2& v1, const Vector2& v2, const Vector2& v3, float f, float g, Vector2& result) noexcept;
            static Vector2 Barycentric(const Vector2& v1, const Vector2& v2, const Vector2& v3, float f, float g) noexcept;

            static void CatmullRom(const Vector2& v1, const Vector2& v2, const Vector2& v3, const Vector2& v4, float t, Vector2& result) noexcept;
            static Vector2 CatmullRom(const Vector2& v1, const Vector2& v2, const Vector2& v3, const Vector2& v4, float t) noexcept;

            static void Hermite(const Vector2& v1, const Vector2& t1, const Vector2& v2, const Vector2& t2, float t, Vector2& result) noexcept;
            static Vector2 Hermite(const Vector2& v1, const Vector2& t1, const Vector2& v2, const Vector2& t2, float t) noexcept;

            static void Reflect(const Vector2& ivec, const Vector2& nvec, Vector2& result) noexcept;
            static Vector2 Reflect(const Vector2& ivec, const Vector2& nvec) noexcept;

            static void Refract(const Vector2& ivec, const Vector2& nvec, float refractionIndex, Vector2& result) noexcept;
            static Vector2 Refract(const Vector2& ivec, const Vector2& nvec, float refractionIndex) noexcept;

            static void Transform(const Vector2& v, const Quaternion& quat, Vector2& result) noexcept;
            static Vector2 Transform(const Vector2& v, const Quaternion& quat) noexcept;

            static void Transform(const Vector2& v, const Matrix& m, Vector2& result) noexcept;
            static Vector2 Transform(const Vector2& v, const Matrix& m) noexcept;
            static void Transform(_In_reads_(count) const Vector2* varray, size_t count, const Matrix& m, _Out_writes_(count) Vector2* resultArray) noexcept;

            static void Transform(const Vector2& v, const Matrix& m, Vector4& result) noexcept;
            static void Transform(_In_reads_(count) const Vector2* varray, size_t count, const Matrix& m, _Out_writes_(count) Vector4* resultArray) noexcept;

            static void TransformNormal(const Vector2& v, const Matrix& m, Vector2& result) noexcept;
            static Vector2 TransformNormal(const Vector2& v, const Matrix& m) noexcept;
            static void TransformNormal(_In_reads_(count) const Vector2* varray, size_t count, const Matrix& m, _Out_writes_(count) Vector2* resultArray) noexcept;

            // Constants
            static const Vector2 Zero;
            static const Vector2 One;
            static const Vector2 UnitX;
            static const Vector2 UnitY;
        };

        // Binary operators
        Vector2 operator+ (const Vector2& V1, const Vector2& V2) noexcept;
        Vector2 operator- (const Vector2& V1, const Vector2& V2) noexcept;
        Vector2 operator* (const Vector2& V1, const Vector2& V2) noexcept;
        Vector2 operator* (const Vector2& V, float S) noexcept;
        Vector2 operator/ (const Vector2& V1, const Vector2& V2) noexcept;
        Vector2 operator/ (const Vector2& V, float S) noexcept;
        Vector2 operator* (float S, const Vector2& V) noexcept;

        //------------------------------------------------------------------------------
        // 3D vector
        struct Vector3 : public XMFLOAT3
        {
            Vector3() noexcept : XMFLOAT3(0.f, 0.f, 0.f) {}
            constexpr explicit Vector3(float ix) noexcept : XMFLOAT3(ix, ix, ix) {}
            constexpr Vector3(float ix, float iy, float iz) noexcept : XMFLOAT3(ix, iy, iz) {}
            explicit Vector3(_In_reads_(3) const float *pArray) noexcept : XMFLOAT3(pArray) {}
            Vector3(FXMVECTOR V) noexcept { XMStoreFloat3(this, V); }
            Vector3(const XMFLOAT3& V) noexcept { this->x = V.x; this->y = V.y; this->z = V.z; }
            explicit Vector3(const XMVECTORF32& F) noexcept { this->x = F.f[0]; this->y = F.f[1]; this->z = F.f[2]; }

            std::string toString() const {
                return std::string("x: " + std::to_string(x) + ", y: " + std::to_string(y) + ", z: " + std::to_string(z));
            }

            Vector3(const Vector3&) = default;
            Vector3& operator=(const Vector3&) = default;

            Vector3(Vector3&&) = default;
            Vector3& operator=(Vector3&&) = default;

            operator XMVECTOR() const noexcept { return XMLoadFloat3(this); }

            // Comparison operators
            bool operator == (const Vector3& V) const noexcept;
            bool operator != (const Vector3& V) const noexcept;

            // Assignment operators
            Vector3& operator= (const XMVECTORF32& F) noexcept { x = F.f[0]; y = F.f[1]; z = F.f[2]; return *this; }
            Vector3& operator+= (const Vector3& V) noexcept;
            Vector3& operator-= (const Vector3& V) noexcept;
            Vector3& operator*= (const Vector3& V) noexcept;
            Vector3& operator*= (float S) noexcept;
            Vector3& operator/= (float S) noexcept;

            // Unary operators
            Vector3 operator+ () const noexcept { return *this; }
            Vector3 operator- () const noexcept;

            // Vector operations
            bool InBounds(const Vector3& Bounds) const noexcept;

            float Length() const noexcept;
            float LengthSquared() const noexcept;

            float Dot(const Vector3& V) const noexcept;
            void Cross(const Vector3& V, Vector3& result) const noexcept;
            Vector3 Cross(const Vector3& V) const noexcept;

            void Normalize() noexcept;
            void Normalize(Vector3& result) const noexcept;

            void Clamp(const Vector3& vmin, const Vector3& vmax) noexcept;
            void Clamp(const Vector3& vmin, const Vector3& vmax, Vector3& result) const noexcept;

            // Static functions
            static float Distance(const Vector3& v1, const Vector3& v2) noexcept;
            static float DistanceSquared(const Vector3& v1, const Vector3& v2) noexcept;

            static Vector3 FromM128(__m128 in) { return Vector3(in.m128_f32[0], in.m128_f32[1], in.m128_f32[2]); }

            static void Min(const Vector3& v1, const Vector3& v2, Vector3& result) noexcept;
            static Vector3 Min(const Vector3& v1, const Vector3& v2) noexcept;

            static void Max(const Vector3& v1, const Vector3& v2, Vector3& result) noexcept;
            static Vector3 Max(const Vector3& v1, const Vector3& v2) noexcept;

            static void Lerp(const Vector3& v1, const Vector3& v2, float t, Vector3& result) noexcept;
            static Vector3 Lerp(const Vector3& v1, const Vector3& v2, float t) noexcept;

            static void SmoothStep(const Vector3& v1, const Vector3& v2, float t, Vector3& result) noexcept;
            static Vector3 SmoothStep(const Vector3& v1, const Vector3& v2, float t) noexcept;

            static void Barycentric(const Vector3& v1, const Vector3& v2, const Vector3& v3, float f, float g, Vector3& result) noexcept;
            static Vector3 Barycentric(const Vector3& v1, const Vector3& v2, const Vector3& v3, float f, float g) noexcept;

            static void CatmullRom(const Vector3& v1, const Vector3& v2, const Vector3& v3, const Vector3& v4, float t, Vector3& result) noexcept;
            static Vector3 CatmullRom(const Vector3& v1, const Vector3& v2, const Vector3& v3, const Vector3& v4, float t) noexcept;

            static void Hermite(const Vector3& v1, const Vector3& t1, const Vector3& v2, const Vector3& t2, float t, Vector3& result) noexcept;
            static Vector3 Hermite(const Vector3& v1, const Vector3& t1, const Vector3& v2, const Vector3& t2, float t) noexcept;

            static void Reflect(const Vector3& ivec, const Vector3& nvec, Vector3& result) noexcept;
            static Vector3 Reflect(const Vector3& ivec, const Vector3& nvec) noexcept;

            static void Refract(const Vector3& ivec, const Vector3& nvec, float refractionIndex, Vector3& result) noexcept;
            static Vector3 Refract(const Vector3& ivec, const Vector3& nvec, float refractionIndex) noexcept;

            static void Transform(const Vector3& v, const Quaternion& quat, Vector3& result) noexcept;
            static Vector3 Transform(const Vector3& v, const Quaternion& quat) noexcept;

            static void Transform(const Vector3& v, const Matrix& m, Vector3& result) noexcept;
            static Vector3 Transform(const Vector3& v, const Matrix& m) noexcept;
            static void Transform(_In_reads_(count) const Vector3* varray, size_t count, const Matrix& m, _Out_writes_(count) Vector3* resultArray) noexcept;

            static void Transform(const Vector3& v, const Matrix& m, Vector4& result) noexcept;
            static void Transform(_In_reads_(count) const Vector3* varray, size_t count, const Matrix& m, _Out_writes_(count) Vector4* resultArray) noexcept;

            static void TransformNormal(const Vector3& v, const Matrix& m, Vector3& result) noexcept;
            static Vector3 TransformNormal(const Vector3& v, const Matrix& m) noexcept;
            static void TransformNormal(_In_reads_(count) const Vector3* varray, size_t count, const Matrix& m, _Out_writes_(count) Vector3* resultArray) noexcept;

            // Constants
            static const Vector3 Zero;
            static const Vector3 One;
            static const Vector3 UnitX;
            static const Vector3 UnitY;
            static const Vector3 UnitZ;
            static const Vector3 Up;
            static const Vector3 Down;
            static const Vector3 Right;
            static const Vector3 Left;
            static const Vector3 Forward;
            static const Vector3 Backward;
        };

        // Binary operators
        Vector3 operator+ (const Vector3& V1, const Vector3& V2) noexcept;
        Vector3 operator- (const Vector3& V1, const Vector3& V2) noexcept;
        Vector3 operator* (const Vector3& V1, const Vector3& V2) noexcept;
        Vector3 operator* (const Vector3& V, float S) noexcept;
        Vector3 operator/ (const Vector3& V1, const Vector3& V2) noexcept;
        Vector3 operator/ (const Vector3& V, float S) noexcept;
        Vector3 operator* (float S, const Vector3& V) noexcept;

        //------------------------------------------------------------------------------
        // 4D vector
        struct Vector4 : public XMFLOAT4
        {
            Vector4() noexcept : XMFLOAT4(0.f, 0.f, 0.f, 0.f) {}
            constexpr explicit Vector4(float ix) noexcept : XMFLOAT4(ix, ix, ix, ix) {}
            constexpr Vector4(float ix, float iy, float iz, float iw) noexcept : XMFLOAT4(ix, iy, iz, iw) {}
            explicit Vector4(_In_reads_(4) const float *pArray) noexcept : XMFLOAT4(pArray) {}
            Vector4(FXMVECTOR V) noexcept { XMStoreFloat4(this, V); }
            Vector4(const XMFLOAT4& V) noexcept { this->x = V.x; this->y = V.y; this->z = V.z; this->w = V.w; }
            explicit Vector4(const XMVECTORF32& F) noexcept { this->x = F.f[0]; this->y = F.f[1]; this->z = F.f[2]; this->w = F.f[3]; }

            Vector4(const Vector4&) = default;
            Vector4& operator=(const Vector4&) = default;

            Vector4(Vector4&&) = default;
            Vector4& operator=(Vector4&&) = default;

            operator XMVECTOR() const  noexcept { return XMLoadFloat4(this); }

            // Comparison operators
            bool operator == (const Vector4& V) const noexcept;
            bool operator != (const Vector4& V) const noexcept;

            // Assignment operators
            Vector4& operator= (const XMVECTORF32& F) noexcept { x = F.f[0]; y = F.f[1]; z = F.f[2]; w = F.f[3]; return *this; }
            Vector4& operator+= (const Vector4& V) noexcept;
            Vector4& operator-= (const Vector4& V) noexcept;
            Vector4& operator*= (const Vector4& V) noexcept;
            Vector4& operator*= (float S) noexcept;
            Vector4& operator/= (float S) noexcept;

            // Unary operators
            Vector4 operator+ () const noexcept { return *this; }
            Vector4 operator- () const noexcept;

            // Vector operations
            bool InBounds(const Vector4& Bounds) const noexcept;

            float Length() const noexcept;
            float LengthSquared() const noexcept;

            float Dot(const Vector4& V) const noexcept;
            void Cross(const Vector4& v1, const Vector4& v2, Vector4& result) const noexcept;
            Vector4 Cross(const Vector4& v1, const Vector4& v2) const noexcept;

            void Normalize() noexcept;
            void Normalize(Vector4& result) const noexcept;

            void Clamp(const Vector4& vmin, const Vector4& vmax) noexcept;
            void Clamp(const Vector4& vmin, const Vector4& vmax, Vector4& result) const noexcept;

            // Static functions
            static float Distance(const Vector4& v1, const Vector4& v2) noexcept;
            static float DistanceSquared(const Vector4& v1, const Vector4& v2) noexcept;

            static void Min(const Vector4& v1, const Vector4& v2, Vector4& result) noexcept;
            static Vector4 Min(const Vector4& v1, const Vector4& v2) noexcept;

            static void Max(const Vector4& v1, const Vector4& v2, Vector4& result) noexcept;
            static Vector4 Max(const Vector4& v1, const Vector4& v2) noexcept;

            static void Lerp(const Vector4& v1, const Vector4& v2, float t, Vector4& result) noexcept;
            static Vector4 Lerp(const Vector4& v1, const Vector4& v2, float t) noexcept;

            static void SmoothStep(const Vector4& v1, const Vector4& v2, float t, Vector4& result) noexcept;
            static Vector4 SmoothStep(const Vector4& v1, const Vector4& v2, float t) noexcept;

            static void Barycentric(const Vector4& v1, const Vector4& v2, const Vector4& v3, float f, float g, Vector4& result) noexcept;
            static Vector4 Barycentric(const Vector4& v1, const Vector4& v2, const Vector4& v3, float f, float g) noexcept;
             
            static void CatmullRom(const Vector4& v1, const Vector4& v2, const Vector4& v3, const Vector4& v4, float t, Vector4& result) noexcept;
            static Vector4 CatmullRom(const Vector4& v1, const Vector4& v2, const Vector4& v3, const Vector4& v4, float t) noexcept;

            static void Hermite(const Vector4& v1, const Vector4& t1, const Vector4& v2, const Vector4& t2, float t, Vector4& result) noexcept;
            static Vector4 Hermite(const Vector4& v1, const Vector4& t1, const Vector4& v2, const Vector4& t2, float t) noexcept;

            static void Reflect(const Vector4& ivec, const Vector4& nvec, Vector4& result) noexcept;
            static Vector4 Reflect(const Vector4& ivec, const Vector4& nvec) noexcept;

            static void Refract(const Vector4& ivec, const Vector4& nvec, float refractionIndex, Vector4& result) noexcept;
            static Vector4 Refract(const Vector4& ivec, const Vector4& nvec, float refractionIndex) noexcept;

            static void Transform(const Vector2& v, const Quaternion& quat, Vector4& result) noexcept;
            static Vector4 Transform(const Vector2& v, const Quaternion& quat) noexcept;

            static void Transform(const Vector3& v, const Quaternion& quat, Vector4& result) noexcept;
            static Vector4 Transform(const Vector3& v, const Quaternion& quat) noexcept;

            static void Transform(const Vector4& v, const Quaternion& quat, Vector4& result) noexcept;
            static Vector4 Transform(const Vector4& v, const Quaternion& quat) noexcept;

            static void Transform(const Vector4& v, const Matrix& m, Vector4& result) noexcept;
            static Vector4 Transform(const Vector4& v, const Matrix& m) noexcept;
            static void Transform(_In_reads_(count) const Vector4* varray, size_t count, const Matrix& m, _Out_writes_(count) Vector4* resultArray) noexcept;

            // Constants
            static const Vector4 Zero;
            static const Vector4 One;
            static const Vector4 UnitX;
            static const Vector4 UnitY;
            static const Vector4 UnitZ;
            static const Vector4 UnitW;
        };

        // Binary operators
        Vector4 operator+ (const Vector4& V1, const Vector4& V2) noexcept;
        Vector4 operator- (const Vector4& V1, const Vector4& V2) noexcept;
        Vector4 operator* (const Vector4& V1, const Vector4& V2) noexcept;
        Vector4 operator* (const Vector4& V, float S) noexcept;
        Vector4 operator/ (const Vector4& V1, const Vector4& V2) noexcept;
        Vector4 operator/ (const Vector4& V, float S) noexcept;
        Vector4 operator* (float S, const Vector4& V) noexcept;

        //------------------------------------------------------------------------------
        // 4x4 Matrix (assumes right-handed cooordinates)
        struct Matrix : public XMFLOAT4X4
        {
            Matrix() noexcept
                : XMFLOAT4X4(1.f, 0, 0, 0,
                            0, 1.f, 0, 0,
                            0, 0, 1.f, 0,
                            0, 0, 0, 1.f) {}
            constexpr Matrix(float m00, float m01, float m02, float m03,
                             float m10, float m11, float m12, float m13,
                             float m20, float m21, float m22, float m23,
                             float m30, float m31, float m32, float m33) noexcept
                : XMFLOAT4X4(m00, m01, m02, m03,
                             m10, m11, m12, m13,
                             m20, m21, m22, m23,
                             m30, m31, m32, m33) {}
            explicit Matrix(const Vector3& r0, const Vector3& r1, const Vector3& r2) noexcept
                : XMFLOAT4X4(r0.x, r0.y, r0.z, 0,
                             r1.x, r1.y, r1.z, 0,
                             r2.x, r2.y, r2.z, 0,
                             0, 0, 0, 1.f) {}
            explicit Matrix(const Vector4& r0, const Vector4& r1, const Vector4& r2, const Vector4& r3) noexcept
                : XMFLOAT4X4(r0.x, r0.y, r0.z, r0.w,
                             r1.x, r1.y, r1.z, r1.w,
                             r2.x, r2.y, r2.z, r2.w,
                             r3.x, r3.y, r3.z, r3.w) {}
            Matrix(const XMFLOAT4X4& M) noexcept { memcpy_s(this, sizeof(float) * 16, &M, sizeof(XMFLOAT4X4)); }
            Matrix(const XMFLOAT3X3& M) noexcept;
            Matrix(const XMFLOAT4X3& M) noexcept;

            explicit Matrix(_In_reads_(16) const float *pArray) noexcept : XMFLOAT4X4(pArray) {}
            Matrix(CXMMATRIX M) noexcept { XMStoreFloat4x4(this, M); }

            Matrix(const Matrix&) = default;
            Matrix& operator=(const Matrix&) = default;

            Matrix(Matrix&&) = default;
            Matrix& operator=(Matrix&&) = default;

            operator XMMATRIX() const noexcept { return XMLoadFloat4x4(this); }

            // Comparison operators
            bool operator == (const Matrix& M) const noexcept;
            bool operator != (const Matrix& M) const noexcept;

            // Assignment operators
            Matrix& operator= (const XMFLOAT3X3& M) noexcept;
            Matrix& operator= (const XMFLOAT4X3& M) noexcept;
            Matrix& operator+= (const Matrix& M) noexcept;
            Matrix& operator-= (const Matrix& M) noexcept;
            Matrix& operator*= (const Matrix& M) noexcept;
            Matrix& operator*= (float S) noexcept;
            Matrix& operator/= (float S) noexcept;

            Matrix& operator/= (const Matrix& M) noexcept;
                // Element-wise divide

            // Unary operators
            Matrix operator+ () const noexcept { return *this; }
            Matrix operator- () const noexcept;

            // Properties
            Vector3 Up() const noexcept { return Vector3(_21, _22, _23); }
            void Up(const Vector3& v) noexcept { _21 = v.x; _22 = v.y; _23 = v.z; }

            Vector3 Down() const  noexcept { return Vector3(-_21, -_22, -_23); }
            void Down(const Vector3& v) noexcept { _21 = -v.x; _22 = -v.y; _23 = -v.z; }

            Vector3 Right() const noexcept { return Vector3(_11, _12, _13); }
            void Right(const Vector3& v) noexcept { _11 = v.x; _12 = v.y; _13 = v.z; }

            Vector3 Left() const noexcept { return Vector3(-_11, -_12, -_13); }
            void Left(const Vector3& v) noexcept { _11 = -v.x; _12 = -v.y; _13 = -v.z; }

            Vector3 Forward() const noexcept { return Vector3(-_31, -_32, -_33); }
            void Forward(const Vector3& v) noexcept { _31 = -v.x; _32 = -v.y; _33 = -v.z; }

            Vector3 Backward() const noexcept { return Vector3(_31, _32, _33); }
            void Backward(const Vector3& v) noexcept { _31 = v.x; _32 = v.y; _33 = v.z; }

            Vector3 Translation() const  noexcept { return Vector3(_41, _42, _43); }
            void Translation(const Vector3& v) noexcept { _41 = v.x; _42 = v.y; _43 = v.z; }

            // Matrix operations
            bool Decompose(Vector3& scale, Quaternion& rotation, Vector3& translation) noexcept;

            Matrix Transpose() const noexcept;
            void Transpose(Matrix& result) const noexcept;

            Matrix Invert() const noexcept;
            void Invert(Matrix& result) const noexcept;

            float Determinant() const noexcept;

            // Static functions
            static Matrix CreateBillboard(
                const Vector3& object, const Vector3& cameraPosition, const Vector3& cameraUp, _In_opt_ const Vector3* cameraForward = nullptr) noexcept;

            static Matrix CreateConstrainedBillboard(
                const Vector3& object, const Vector3& cameraPosition, const Vector3& rotateAxis,
                _In_opt_ const Vector3* cameraForward = nullptr, _In_opt_ const Vector3* objectForward = nullptr) noexcept;

            static Matrix CreateTranslation(const Vector3& position) noexcept;
            static Matrix CreateTranslation(float x, float y, float z) noexcept;

            static Matrix CreateScale(const Vector3& scales) noexcept;
            static Matrix CreateScale(float xs, float ys, float zs) noexcept;
            static Matrix CreateScale(float scale) noexcept;

            static Matrix CreateRotationX(float radians) noexcept;
            static Matrix CreateRotationY(float radians) noexcept;
            static Matrix CreateRotationZ(float radians) noexcept;

            static Matrix CreateFromAxisAngle(const Vector3& axis, float angle) noexcept;

            static Matrix CreatePerspectiveFieldOfView(float fov, float aspectRatio, float nearPlane, float farPlane) noexcept;
            static Matrix CreatePerspective(float width, float height, float nearPlane, float farPlane) noexcept;
            static Matrix CreatePerspectiveOffCenter(float left, float right, float bottom, float top, float nearPlane, float farPlane) noexcept;
            static Matrix CreateOrthographic(float width, float height, float zNearPlane, float zFarPlane) noexcept;
            static Matrix CreateOrthographicOffCenter(float left, float right, float bottom, float top, float zNearPlane, float zFarPlane) noexcept;

            static Matrix CreateLookAt(const Vector3& position, const Vector3& target, const Vector3& up) noexcept;
            static Matrix CreateWorld(const Vector3& position, const Vector3& forward, const Vector3& up) noexcept;

            static Matrix CreateFromQuaternion(const Quaternion& quat) noexcept;

            static Matrix CreateFromYawPitchRoll(float yaw, float pitch, float roll) noexcept;

            static Matrix CreateShadow(const Vector3& lightDir, const Plane& plane) noexcept;

            static Matrix CreateReflection(const Plane& plane) noexcept;

            static void Lerp(const Matrix& M1, const Matrix& M2, float t, Matrix& result) noexcept;
            static Matrix Lerp(const Matrix& M1, const Matrix& M2, float t) noexcept;

            static void Transform(const Matrix& M, const Quaternion& rotation, Matrix& result) noexcept;
            static Matrix Transform(const Matrix& M, const Quaternion& rotation) noexcept;

            // Constants
            static const Matrix Identity;
        };

        // Binary operators
        Matrix operator+ (const Matrix& M1, const Matrix& M2) noexcept;
        Matrix operator- (const Matrix& M1, const Matrix& M2) noexcept;
        Matrix operator* (const Matrix& M1, const Matrix& M2) noexcept;
        Matrix operator* (const Matrix& M, float S) noexcept;
        Matrix operator/ (const Matrix& M, float S) noexcept;
        Matrix operator/ (const Matrix& M1, const Matrix& M2) noexcept;
            // Element-wise divide
        Matrix operator* (float S, const Matrix& M) noexcept;


        //-----------------------------------------------------------------------------
        // Plane
        struct Plane : public XMFLOAT4
        {
            Plane() noexcept : XMFLOAT4(0.f, 1.f, 0.f, 0.f) {}
            constexpr Plane(float ix, float iy, float iz, float iw) noexcept : XMFLOAT4(ix, iy, iz, iw) {}
            Plane(const Vector3& normal, float d) noexcept : XMFLOAT4(normal.x, normal.y, normal.z, d) {}
            Plane(const Vector3& point1, const Vector3& point2, const Vector3& point3) noexcept;
            Plane(const Vector3& point, const Vector3& normal) noexcept;
            explicit Plane(const Vector4& v) noexcept : XMFLOAT4(v.x, v.y, v.z, v.w) {}
            explicit Plane(_In_reads_(4) const float *pArray) noexcept : XMFLOAT4(pArray) {}
            Plane(FXMVECTOR V) noexcept { XMStoreFloat4(this, V); }
            Plane(const XMFLOAT4& p) noexcept { this->x = p.x; this->y = p.y; this->z = p.z; this->w = p.w; }
            explicit Plane(const XMVECTORF32& F) noexcept { this->x = F.f[0]; this->y = F.f[1]; this->z = F.f[2]; this->w = F.f[3]; }

            Plane(const Plane&) = default;
            Plane& operator=(const Plane&) = default;

            Plane(Plane&&) = default;
            Plane& operator=(Plane&&) = default;

            operator XMVECTOR() const noexcept { return XMLoadFloat4(this); }

            // Comparison operators
            bool operator == (const Plane& p) const noexcept;
            bool operator != (const Plane& p) const noexcept;

            // Assignment operators
            Plane& operator= (const XMVECTORF32& F) noexcept { x = F.f[0]; y = F.f[1]; z = F.f[2]; w = F.f[3]; return *this; }

            // Properties
            Vector3 Normal() const noexcept { return Vector3(x, y, z); }
            void Normal(const Vector3& normal) noexcept { x = normal.x; y = normal.y; z = normal.z; }

            float D() const noexcept { return w; }
            void D(float d) noexcept { w = d; }

            // Plane operations
            void Normalize() noexcept;
            void Normalize(Plane& result) const noexcept;

            float Dot(const Vector4& v) const noexcept;
            float DotCoordinate(const Vector3& position) const noexcept;
            float DotNormal(const Vector3& normal) const noexcept;

            // Static functions
            static void Transform(const Plane& plane, const Matrix& M, Plane& result) noexcept;
            static Plane Transform(const Plane& plane, const Matrix& M) noexcept;

            static void Transform(const Plane& plane, const Quaternion& rotation, Plane& result) noexcept;
            static Plane Transform(const Plane& plane, const Quaternion& rotation) noexcept;
                // Input quaternion must be the inverse transpose of the transformation
        };

        //------------------------------------------------------------------------------
        // Quaternion
        struct Quaternion : public XMFLOAT4
        {
            Quaternion() noexcept : XMFLOAT4(0, 0, 0, 1.f) {}
            constexpr Quaternion(float ix, float iy, float iz, float iw) noexcept : XMFLOAT4(ix, iy, iz, iw) {}
            Quaternion(const Vector3& v, float scalar) noexcept : XMFLOAT4(v.x, v.y, v.z, scalar) {}
            explicit Quaternion(const Vector4& v) noexcept : XMFLOAT4(v.x, v.y, v.z, v.w) {}
            explicit Quaternion(_In_reads_(4) const float *pArray) noexcept : XMFLOAT4(pArray) {}
            Quaternion(FXMVECTOR V) noexcept { XMStoreFloat4(this, V); }
            Quaternion(const XMFLOAT4& q) noexcept { this->x = q.x; this->y = q.y; this->z = q.z; this->w = q.w; }
            explicit Quaternion(const XMVECTORF32& F) noexcept { this->x = F.f[0]; this->y = F.f[1]; this->z = F.f[2]; this->w = F.f[3]; }

            Quaternion(const Quaternion&) = default;
            Quaternion& operator=(const Quaternion&) = default;

            Quaternion(Quaternion&&) = default;
            Quaternion& operator=(Quaternion&&) = default;

            operator XMVECTOR() const noexcept { return XMLoadFloat4(this); }

            // Comparison operators
            bool operator == (const Quaternion& q) const noexcept;
            bool operator != (const Quaternion& q) const noexcept;

            // Assignment operators
            Quaternion& operator= (const XMVECTORF32& F) noexcept { x = F.f[0]; y = F.f[1]; z = F.f[2]; w = F.f[3]; return *this; }
            Quaternion& operator+= (const Quaternion& q) noexcept;
            Quaternion& operator-= (const Quaternion& q) noexcept;
            Quaternion& operator*= (const Quaternion& q) noexcept;
            Quaternion& operator*= (float S) noexcept;
            Quaternion& operator/= (const Quaternion& q) noexcept;

            // Unary operators
            Quaternion operator+ () const  noexcept { return *this; }
            Quaternion operator- () const noexcept;

            // Quaternion operations
            float Length() const noexcept;
            float LengthSquared() const noexcept;

            void Normalize() noexcept;
            void Normalize(Quaternion& result) const noexcept;

            void Conjugate() noexcept;
            void Conjugate(Quaternion& result) const noexcept;

            void Inverse(Quaternion& result) const noexcept;

            float Dot(const Quaternion& Q) const noexcept;

            // Static functions
            static Quaternion CreateFromAxisAngle(const Vector3& axis, float angle) noexcept;
            static Quaternion CreateFromYawPitchRoll(float yaw, float pitch, float roll) noexcept;
            static Quaternion CreateFromRotationMatrix(const Matrix& M) noexcept;

            static void Lerp(const Quaternion& q1, const Quaternion& q2, float t, Quaternion& result) noexcept;
            static Quaternion Lerp(const Quaternion& q1, const Quaternion& q2, float t) noexcept;

            static void Slerp(const Quaternion& q1, const Quaternion& q2, float t, Quaternion& result) noexcept;
            static Quaternion Slerp(const Quaternion& q1, const Quaternion& q2, float t) noexcept;

            static void Concatenate(const Quaternion& q1, const Quaternion& q2, Quaternion& result) noexcept;
            static Quaternion Concatenate(const Quaternion& q1, const Quaternion& q2) noexcept;

            // Constants
            static const Quaternion Identity;
        };

        // Binary operators
        Quaternion operator+ (const Quaternion& Q1, const Quaternion& Q2) noexcept;
        Quaternion operator- (const Quaternion& Q1, const Quaternion& Q2) noexcept;
        Quaternion operator* (const Quaternion& Q1, const Quaternion& Q2) noexcept;
        Quaternion operator* (const Quaternion& Q, float S) noexcept;
        Quaternion operator/ (const Quaternion& Q1, const Quaternion& Q2) noexcept;
        Quaternion operator* (float S, const Quaternion& Q) noexcept;

        //------------------------------------------------------------------------------
        // Color
        struct Color : public XMFLOAT4
        {
            Color() noexcept : XMFLOAT4(0, 0, 0, 1.f) {}
            constexpr Color(float _r, float _g, float _b) noexcept : XMFLOAT4(_r, _g, _b, 1.f) {}
            constexpr Color(float _r, float _g, float _b, float _a) noexcept : XMFLOAT4(_r, _g, _b, _a) {}
            explicit Color(const Vector3& clr) noexcept : XMFLOAT4(clr.x, clr.y, clr.z, 1.f) {}
            explicit Color(const Vector4& clr) noexcept : XMFLOAT4(clr.x, clr.y, clr.z, clr.w) {}
            explicit Color(_In_reads_(4) const float *pArray) noexcept : XMFLOAT4(pArray) {}
            Color(FXMVECTOR V) noexcept { XMStoreFloat4(this, V); }
            Color(const XMFLOAT4& c) noexcept { this->x = c.x; this->y = c.y; this->z = c.z; this->w = c.w; }
            explicit Color(const XMVECTORF32& F) noexcept { this->x = F.f[0]; this->y = F.f[1]; this->z = F.f[2]; this->w = F.f[3]; }

            explicit Color(const DirectX::PackedVector::XMCOLOR& Packed) noexcept;
                // BGRA Direct3D 9 D3DCOLOR packed color

            explicit Color(const DirectX::PackedVector::XMUBYTEN4& Packed) noexcept;
                // RGBA XNA Game Studio packed color

            Color(const Color&) = default;
            Color& operator=(const Color&) = default;

            Color(Color&&) = default;
            Color& operator=(Color&&) = default;

            operator XMVECTOR() const noexcept { return XMLoadFloat4(this); }
            operator const float*() const noexcept { return reinterpret_cast<const float*>(this); }

            // Comparison operators
            bool operator == (const Color& c) const noexcept;
            bool operator != (const Color& c) const noexcept;

            // Assignment operators
            Color& operator= (const XMVECTORF32& F) noexcept { x = F.f[0]; y = F.f[1]; z = F.f[2]; w = F.f[3]; return *this; }
            Color& operator= (const DirectX::PackedVector::XMCOLOR& Packed) noexcept;
            Color& operator= (const DirectX::PackedVector::XMUBYTEN4& Packed) noexcept;
            Color& operator+= (const Color& c) noexcept;
            Color& operator-= (const Color& c) noexcept;
            Color& operator*= (const Color& c) noexcept;
            Color& operator*= (float S) noexcept;
            Color& operator/= (const Color& c) noexcept;

            // Unary operators
            Color operator+ () const noexcept { return *this; }
            Color operator- () const noexcept;

            // Properties
            float R() const noexcept { return x; }
            void R(float r) noexcept { x = r; }

            float G() const noexcept { return y; }
            void G(float g) noexcept { y = g; }

            float B() const noexcept { return z; }
            void B(float b) noexcept { z = b; }

            float A() const noexcept { return w; }
            void A(float a) noexcept { w = a; }

            // Color operations
            DirectX::PackedVector::XMCOLOR BGRA() const noexcept;
            DirectX::PackedVector::XMUBYTEN4 RGBA() const noexcept;

            Vector3 ToVector3() const noexcept;
            Vector4 ToVector4() const noexcept;

            void Negate() noexcept;
            void Negate(Color& result) const noexcept;

            void Saturate() noexcept;
            void Saturate(Color& result) const noexcept;

            void Premultiply() noexcept;
            void Premultiply(Color& result) const noexcept;

            void AdjustSaturation(float sat) noexcept;
            void AdjustSaturation(float sat, Color& result) const noexcept;

            void AdjustContrast(float contrast) noexcept;
            void AdjustContrast(float contrast, Color& result) const noexcept;

            // Static functions
            static void Modulate(const Color& c1, const Color& c2, Color& result) noexcept;
            static Color Modulate(const Color& c1, const Color& c2) noexcept;

            static void Lerp(const Color& c1, const Color& c2, float t, Color& result) noexcept;
            static Color Lerp(const Color& c1, const Color& c2, float t) noexcept;
        };

        // Binary operators
        Color operator+ (const Color& C1, const Color& C2) noexcept;
        Color operator- (const Color& C1, const Color& C2) noexcept;
        Color operator* (const Color& C1, const Color& C2) noexcept;
        Color operator* (const Color& C, float S) noexcept;
        Color operator/ (const Color& C1, const Color& C2) noexcept;
        Color operator* (float S, const Color& C) noexcept;

        //------------------------------------------------------------------------------
        // Ray
        class Ray
        {
        public:
            Vector3 position;
            Vector3 direction;

            Ray() noexcept : position(0, 0, 0), direction(0, 0, 1) {}
            Ray(const Vector3& pos, const Vector3& dir) noexcept : position(pos), direction(dir) {}

            Ray(const Ray&) = default;
            Ray& operator=(const Ray&) = default;

            Ray(Ray&&) = default;
            Ray& operator=(Ray&&) = default;

            // Comparison operators
            bool operator == (const Ray& r) const noexcept;
            bool operator != (const Ray& r) const noexcept;

            // Ray operations
            bool Intersects(const BoundingSphere& sphere, _Out_ float& Dist) const noexcept;
            bool Intersects(const BoundingBox& box, _Out_ float& Dist) const noexcept;
            bool Intersects(const Vector3& tri0, const Vector3& tri1, const Vector3& tri2, _Out_ float& Dist) const noexcept;
            bool Intersects(const Plane& plane, _Out_ float& Dist) const noexcept;
        };

        //------------------------------------------------------------------------------
        // Viewport
        class Viewport
        {
        public:
            float x;
            float y;
            float width;
            float height;
            float minDepth;
            float maxDepth;

            Viewport() noexcept :
                x(0.f), y(0.f), width(0.f), height(0.f), minDepth(0.f), maxDepth(1.f) {}
            constexpr Viewport(float ix, float iy, float iw, float ih, float iminz = 0.f, float imaxz = 1.f) noexcept :
                x(ix), y(iy), width(iw), height(ih), minDepth(iminz), maxDepth(imaxz) {}
            explicit Viewport(const RECT& rct) noexcept :
                x(float(rct.left)), y(float(rct.top)),
                width(float(rct.right - rct.left)),
                height(float(rct.bottom - rct.top)),
                minDepth(0.f), maxDepth(1.f) {}

        #if defined(__d3d11_h__) || defined(__d3d11_x_h__)
            // Direct3D 11 interop
            explicit Viewport(const D3D11_VIEWPORT& vp) noexcept :
                x(vp.TopLeftX), y(vp.TopLeftY),
                width(vp.Width), height(vp.Height),
                minDepth(vp.MinDepth), maxDepth(vp.MaxDepth) {}

            operator D3D11_VIEWPORT() noexcept { return *reinterpret_cast<const D3D11_VIEWPORT*>(this); }
            const D3D11_VIEWPORT* Get11() const noexcept { return reinterpret_cast<const D3D11_VIEWPORT*>(this); }
            Viewport& operator= (const D3D11_VIEWPORT& vp) noexcept;
        #endif

        #if defined(__d3d12_h__) || defined(__d3d12_x_h__) || defined(__XBOX_D3D12_X__)
            // Direct3D 12 interop
            explicit Viewport(const D3D12_VIEWPORT& vp) noexcept :
                x(vp.TopLeftX), y(vp.TopLeftY),
                width(vp.Width), height(vp.Height),
                minDepth(vp.MinDepth), maxDepth(vp.MaxDepth) {}

            operator D3D12_VIEWPORT() noexcept { return *reinterpret_cast<const D3D12_VIEWPORT*>(this); }
            const D3D12_VIEWPORT* Get12() const noexcept { return reinterpret_cast<const D3D12_VIEWPORT*>(this); }
            Viewport& operator= (const D3D12_VIEWPORT& vp) noexcept;
        #endif

            Viewport(const Viewport&) = default;
            Viewport& operator=(const Viewport&) = default;

            Viewport(Viewport&&) = default;
            Viewport& operator=(Viewport&&) = default;

            // Comparison operators
            bool operator == (const Viewport& vp) const noexcept;
            bool operator != (const Viewport& vp) const noexcept;

            // Assignment operators
            Viewport& operator= (const RECT& rct) noexcept;

            // Viewport operations
            float AspectRatio() const noexcept;

            Vector3 Project(const Vector3& p, const Matrix& proj, const Matrix& view, const Matrix& world) const noexcept;
            void Project(const Vector3& p, const Matrix& proj, const Matrix& view, const Matrix& world, Vector3& result) const noexcept;

            Vector3 Unproject(const Vector3& p, const Matrix& proj, const Matrix& view, const Matrix& world) const noexcept;
            void Unproject(const Vector3& p, const Matrix& proj, const Matrix& view, const Matrix& world, Vector3& result) const noexcept;

            // Static methods
            static RECT __cdecl ComputeDisplayArea(DXGI_SCALING scaling, UINT backBufferWidth, UINT backBufferHeight, int outputWidth, int outputHeight) noexcept;
            static RECT __cdecl ComputeTitleSafeArea(UINT backBufferWidth, UINT backBufferHeight) noexcept;
        };

    #include "vendor/math/SimpleMath.inl"

    } // namespace SimpleMath

} // namespace DirectX

//------------------------------------------------------------------------------
// Support for SimpleMath and Standard C++ Library containers
namespace std
{

    template<> struct less<DirectX::SimpleMath::Rectangle>
    {
        bool operator()(const DirectX::SimpleMath::Rectangle& r1, const DirectX::SimpleMath::Rectangle& r2) const noexcept
        {
            return ((r1.x < r2.x)
                    || ((r1.x == r2.x) && (r1.y < r2.y))
                    || ((r1.x == r2.x) && (r1.y == r2.y) && (r1.width < r2.width))
                    || ((r1.x == r2.x) && (r1.y == r2.y) && (r1.width == r2.width) && (r1.height < r2.height)));
        }
    };

    template<> struct less<DirectX::SimpleMath::Vector2>
    {
        bool operator()(const DirectX::SimpleMath::Vector2& V1, const DirectX::SimpleMath::Vector2& V2) const noexcept
        {
            return ((V1.x < V2.x) || ((V1.x == V2.x) && (V1.y < V2.y)));
        }
    };

    template<> struct less<DirectX::SimpleMath::Vector3>
    {
        bool operator()(const DirectX::SimpleMath::Vector3& V1, const DirectX::SimpleMath::Vector3& V2) const noexcept
        {
            return ((V1.x < V2.x)
                    || ((V1.x == V2.x) && (V1.y < V2.y))
                    || ((V1.x == V2.x) && (V1.y == V2.y) && (V1.z < V2.z)));
        }
    };

    template<> struct less<DirectX::SimpleMath::Vector4>
    {
        bool operator()(const DirectX::SimpleMath::Vector4& V1, const DirectX::SimpleMath::Vector4& V2) const noexcept
        {
            return ((V1.x < V2.x)
                    || ((V1.x == V2.x) && (V1.y < V2.y))
                    || ((V1.x == V2.x) && (V1.y == V2.y) && (V1.z < V2.z))
                    || ((V1.x == V2.x) && (V1.y == V2.y) && (V1.z == V2.z) && (V1.w < V2.w)));
        }
    };

    template<> struct less<DirectX::SimpleMath::Matrix>
    {
        bool operator()(const DirectX::SimpleMath::Matrix& M1, const DirectX::SimpleMath::Matrix& M2) const noexcept
        {
            if (M1._11 != M2._11) return M1._11 < M2._11;
            if (M1._12 != M2._12) return M1._12 < M2._12;
            if (M1._13 != M2._13) return M1._13 < M2._13;
            if (M1._14 != M2._14) return M1._14 < M2._14;
            if (M1._21 != M2._21) return M1._21 < M2._21;
            if (M1._22 != M2._22) return M1._22 < M2._22;
            if (M1._23 != M2._23) return M1._23 < M2._23;
            if (M1._24 != M2._24) return M1._24 < M2._24;
            if (M1._31 != M2._31) return M1._31 < M2._31;
            if (M1._32 != M2._32) return M1._32 < M2._32;
            if (M1._33 != M2._33) return M1._33 < M2._33;
            if (M1._34 != M2._34) return M1._34 < M2._34;
            if (M1._41 != M2._41) return M1._41 < M2._41;
            if (M1._42 != M2._42) return M1._42 < M2._42;
            if (M1._43 != M2._43) return M1._43 < M2._43;
            if (M1._44 != M2._44) return M1._44 < M2._44;

            return false;
        }
    };

    template<> struct less<DirectX::SimpleMath::Plane>
    {
        bool operator()(const DirectX::SimpleMath::Plane& P1, const DirectX::SimpleMath::Plane& P2) const noexcept
        {
            return ((P1.x < P2.x)
                    || ((P1.x == P2.x) && (P1.y < P2.y))
                    || ((P1.x == P2.x) && (P1.y == P2.y) && (P1.z < P2.z))
                    || ((P1.x == P2.x) && (P1.y == P2.y) && (P1.z == P2.z) && (P1.w < P2.w)));
        }
    };

    template<> struct less<DirectX::SimpleMath::Quaternion>
    {
        bool operator()(const DirectX::SimpleMath::Quaternion& Q1, const DirectX::SimpleMath::Quaternion& Q2) const noexcept
        {
            return ((Q1.x < Q2.x)
                    || ((Q1.x == Q2.x) && (Q1.y < Q2.y))
                    || ((Q1.x == Q2.x) && (Q1.y == Q2.y) && (Q1.z < Q2.z))
                    || ((Q1.x == Q2.x) && (Q1.y == Q2.y) && (Q1.z == Q2.z) && (Q1.w < Q2.w)));
        }
    };

    template<> struct less<DirectX::SimpleMath::Color>
    {
        bool operator()(const DirectX::SimpleMath::Color& C1, const DirectX::SimpleMath::Color& C2) const noexcept
        {
            return ((C1.x < C2.x)
                    || ((C1.x == C2.x) && (C1.y < C2.y))
                    || ((C1.x == C2.x) && (C1.y == C2.y) && (C1.z < C2.z))
                    || ((C1.x == C2.x) && (C1.y == C2.y) && (C1.z == C2.z) && (C1.w < C2.w)));
        }
    };

    template<> struct less<DirectX::SimpleMath::Ray>
    {
        bool operator()(const DirectX::SimpleMath::Ray& R1, const DirectX::SimpleMath::Ray& R2) const noexcept
        {
            if (R1.position.x != R2.position.x) return R1.position.x < R2.position.x;
            if (R1.position.y != R2.position.y) return R1.position.y < R2.position.y;
            if (R1.position.z != R2.position.z) return R1.position.z < R2.position.z;

            if (R1.direction.x != R2.direction.x) return R1.direction.x < R2.direction.x;
            if (R1.direction.y != R2.direction.y) return R1.direction.y < R2.direction.y;
            if (R1.direction.z != R2.direction.z) return R1.direction.z < R2.direction.z;

            return false;
        }
    };

    template<> struct less<DirectX::SimpleMath::Viewport>
    {
        bool operator()(const DirectX::SimpleMath::Viewport& vp1, const DirectX::SimpleMath::Viewport& vp2) const noexcept
        {
            if (vp1.x != vp2.x) return (vp1.x < vp2.x);
            if (vp1.y != vp2.y) return (vp1.y < vp2.y);

            if (vp1.width != vp2.width) return (vp1.width < vp2.width);
            if (vp1.height != vp2.height) return (vp1.height < vp2.height);

            if (vp1.minDepth != vp2.minDepth) return (vp1.minDepth < vp2.minDepth);
            if (vp1.maxDepth != vp2.maxDepth) return (vp1.maxDepth < vp2.maxDepth);

            return false;
        }
    };

} // namespace std

#ifdef __clang__
#pragma clang diagnostic pop
#endif

```

`include/vendor/math/SimpleMath.inl`:

```inl
//-------------------------------------------------------------------------------------
// SimpleMath.inl -- Simplified C++ Math wrapper for DirectXMath
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//
// http://go.microsoft.com/fwlink/?LinkId=248929
// http://go.microsoft.com/fwlink/?LinkID=615561
//-------------------------------------------------------------------------------------

#pragma once

/****************************************************************************
*
* Rectangle
*
****************************************************************************/

//------------------------------------------------------------------------------
// Rectangle operations
//------------------------------------------------------------------------------
inline Vector2 Rectangle::Location() const noexcept
{
    return Vector2(float(x), float(y));
}

inline Vector2 Rectangle::Center() const noexcept
{
    return Vector2(float(x) + (float(width) / 2.f), float(y) + (float(height) / 2.f));
}

inline bool Rectangle::Contains(const Vector2& point) const noexcept
{
    return (float(x) <= point.x) && (point.x < float(x + width)) && (float(y) <= point.y) && (point.y < float(y + height));
}

inline void Rectangle::Inflate(long horizAmount, long vertAmount) noexcept
{
    x -= horizAmount;
    y -= vertAmount;
    width += horizAmount;
    height += vertAmount;
}

//------------------------------------------------------------------------------
// Static functions
//------------------------------------------------------------------------------

inline Rectangle Rectangle::Intersect(const Rectangle& ra, const Rectangle& rb) noexcept
{
    long righta = ra.x + ra.width;
    long rightb = rb.x + rb.width;

    long bottoma = ra.y + ra.height;
    long bottomb = rb.y + rb.height;

    long maxX = ra.x > rb.x ? ra.x : rb.x;
    long maxY = ra.y > rb.y ? ra.y : rb.y;

    long minRight = righta < rightb ? righta : rightb;
    long minBottom = bottoma < bottomb ? bottoma : bottomb;

    Rectangle result;

    if ((minRight > maxX) && (minBottom > maxY))
    {
        result.x = maxX;
        result.y = maxY;
        result.width = minRight - maxX;
        result.height = minBottom - maxY;
    }
    else
    {
        result.x = 0;
        result.y = 0;
        result.width = 0;
        result.height = 0;
    }

    return result;
}

inline RECT Rectangle::Intersect(const RECT& rcta, const RECT& rctb) noexcept
{
    long maxX = rcta.left > rctb.left ? rcta.left : rctb.left;
    long maxY = rcta.top > rctb.top ? rcta.top : rctb.top;

    long minRight = rcta.right < rctb.right ? rcta.right : rctb.right;
    long minBottom = rcta.bottom < rctb.bottom ? rcta.bottom : rctb.bottom;

    RECT result;

    if ((minRight > maxX) && (minBottom > maxY))
    {
        result.left = maxX;
        result.top = maxY;
        result.right = minRight;
        result.bottom = minBottom;
    }
    else
    {
        result.left = 0;
        result.top = 0;
        result.right = 0;
        result.bottom = 0;
    }

    return result;
}

inline Rectangle Rectangle::Union(const Rectangle& ra, const Rectangle& rb) noexcept
{
    long righta = ra.x + ra.width;
    long rightb = rb.x + rb.width;

    long bottoma = ra.y + ra.height;
    long bottomb = rb.y + rb.height;

    int minX = ra.x < rb.x ? ra.x : rb.x;
    int minY = ra.y < rb.y ? ra.y : rb.y;

    int maxRight = righta > rightb ? righta : rightb;
    int maxBottom = bottoma > bottomb ? bottoma : bottomb;

    Rectangle result;
    result.x = minX;
    result.y = minY;
    result.width = maxRight - minX;
    result.height = maxBottom - minY;
    return result;
}

inline RECT Rectangle::Union(const RECT& rcta, const RECT& rctb) noexcept
{
    RECT result;
    result.left = rcta.left < rctb.left ? rcta.left : rctb.left;
    result.top = rcta.top < rctb.top ? rcta.top : rctb.top;
    result.right = rcta.right > rctb.right ? rcta.right : rctb.right;
    result.bottom = rcta.bottom > rctb.bottom ? rcta.bottom : rctb.bottom;
    return result;
}


/****************************************************************************
 *
 * Vector2
 *
 ****************************************************************************/

//------------------------------------------------------------------------------
// Comparision operators
//------------------------------------------------------------------------------

inline bool Vector2::operator == (const Vector2& V) const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(this);
    XMVECTOR v2 = XMLoadFloat2(&V);
    return XMVector2Equal(v1, v2);
}

inline bool Vector2::operator != (const Vector2& V) const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(this);
    XMVECTOR v2 = XMLoadFloat2(&V);
    return XMVector2NotEqual(v1, v2);
}

//------------------------------------------------------------------------------
// Assignment operators
//------------------------------------------------------------------------------

inline Vector2& Vector2::operator+= (const Vector2& V) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(this);
    XMVECTOR v2 = XMLoadFloat2(&V);
    XMVECTOR X = XMVectorAdd(v1, v2);
    XMStoreFloat2(this, X);
    return *this;
}

inline Vector2& Vector2::operator-= (const Vector2& V) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(this);
    XMVECTOR v2 = XMLoadFloat2(&V);
    XMVECTOR X = XMVectorSubtract(v1, v2);
    XMStoreFloat2(this, X);
    return *this;
}

inline Vector2& Vector2::operator*= (const Vector2& V) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(this);
    XMVECTOR v2 = XMLoadFloat2(&V);
    XMVECTOR X = XMVectorMultiply(v1, v2);
    XMStoreFloat2(this, X);
    return *this;
}

inline Vector2& Vector2::operator*= (float S) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(this);
    XMVECTOR X = XMVectorScale(v1, S);
    XMStoreFloat2(this, X);
    return *this;
}

inline Vector2& Vector2::operator/= (float S) noexcept
{
    using namespace DirectX;
    assert(S != 0.0f);
    XMVECTOR v1 = XMLoadFloat2(this);
    XMVECTOR X = XMVectorScale(v1, 1.f / S);
    XMStoreFloat2(this, X);
    return *this;
}

//------------------------------------------------------------------------------
// Binary operators
//------------------------------------------------------------------------------

inline Vector2 operator+ (const Vector2& V1, const Vector2& V2) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(&V1);
    XMVECTOR v2 = XMLoadFloat2(&V2);
    XMVECTOR X = XMVectorAdd(v1, v2);
    Vector2 R;
    XMStoreFloat2(&R, X);
    return R;
}

inline Vector2 operator- (const Vector2& V1, const Vector2& V2) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(&V1);
    XMVECTOR v2 = XMLoadFloat2(&V2);
    XMVECTOR X = XMVectorSubtract(v1, v2);
    Vector2 R;
    XMStoreFloat2(&R, X);
    return R;
}

inline Vector2 operator* (const Vector2& V1, const Vector2& V2) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(&V1);
    XMVECTOR v2 = XMLoadFloat2(&V2);
    XMVECTOR X = XMVectorMultiply(v1, v2);
    Vector2 R;
    XMStoreFloat2(&R, X);
    return R;
}

inline Vector2 operator* (const Vector2& V, float S) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(&V);
    XMVECTOR X = XMVectorScale(v1, S);
    Vector2 R;
    XMStoreFloat2(&R, X);
    return R;
}

inline Vector2 operator/ (const Vector2& V1, const Vector2& V2) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(&V1);
    XMVECTOR v2 = XMLoadFloat2(&V2);
    XMVECTOR X = XMVectorDivide(v1, v2);
    Vector2 R;
    XMStoreFloat2(&R, X);
    return R;
}

inline Vector2 operator/ (const Vector2& V, float S) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(&V);
    XMVECTOR X = XMVectorScale(v1, 1.f / S);
    Vector2 R;
    XMStoreFloat2(&R, X);
    return R;
}

inline Vector2 operator* (float S, const Vector2& V) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(&V);
    XMVECTOR X = XMVectorScale(v1, S);
    Vector2 R;
    XMStoreFloat2(&R, X);
    return R;
}

//------------------------------------------------------------------------------
// Vector operations
//------------------------------------------------------------------------------

inline bool Vector2::InBounds(const Vector2& Bounds) const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(this);
    XMVECTOR v2 = XMLoadFloat2(&Bounds);
    return XMVector2InBounds(v1, v2);
}

inline float Vector2::Length() const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(this);
    XMVECTOR X = XMVector2Length(v1);
    return XMVectorGetX(X);
}

inline float Vector2::LengthSquared() const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(this);
    XMVECTOR X = XMVector2LengthSq(v1);
    return XMVectorGetX(X);
}

inline float Vector2::Dot(const Vector2& V) const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(this);
    XMVECTOR v2 = XMLoadFloat2(&V);
    XMVECTOR X = XMVector2Dot(v1, v2);
    return XMVectorGetX(X);
}

inline void Vector2::Cross(const Vector2& V, Vector2& result) const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(this);
    XMVECTOR v2 = XMLoadFloat2(&V);
    XMVECTOR R = XMVector2Cross(v1, v2);
    XMStoreFloat2(&result, R);
}

inline Vector2 Vector2::Cross(const Vector2& V) const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(this);
    XMVECTOR v2 = XMLoadFloat2(&V);
    XMVECTOR R = XMVector2Cross(v1, v2);

    Vector2 result;
    XMStoreFloat2(&result, R);
    return result;
}

inline void Vector2::Normalize() noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(this);
    XMVECTOR X = XMVector2Normalize(v1);
    XMStoreFloat2(this, X);
}

inline void Vector2::Normalize(Vector2& result) const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(this);
    XMVECTOR X = XMVector2Normalize(v1);
    XMStoreFloat2(&result, X);
}

inline void Vector2::Clamp(const Vector2& vmin, const Vector2& vmax) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(this);
    XMVECTOR v2 = XMLoadFloat2(&vmin);
    XMVECTOR v3 = XMLoadFloat2(&vmax);
    XMVECTOR X = XMVectorClamp(v1, v2, v3);
    XMStoreFloat2(this, X);
}

inline void Vector2::Clamp(const Vector2& vmin, const Vector2& vmax, Vector2& result) const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(this);
    XMVECTOR v2 = XMLoadFloat2(&vmin);
    XMVECTOR v3 = XMLoadFloat2(&vmax);
    XMVECTOR X = XMVectorClamp(v1, v2, v3);
    XMStoreFloat2(&result, X);
}

//------------------------------------------------------------------------------
// Static functions
//------------------------------------------------------------------------------

inline float Vector2::Distance(const Vector2& v1, const Vector2& v2) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat2(&v1);
    XMVECTOR x2 = XMLoadFloat2(&v2);
    XMVECTOR V = XMVectorSubtract(x2, x1);
    XMVECTOR X = XMVector2Length(V);
    return XMVectorGetX(X);
}

inline float Vector2::DistanceSquared(const Vector2& v1, const Vector2& v2) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat2(&v1);
    XMVECTOR x2 = XMLoadFloat2(&v2);
    XMVECTOR V = XMVectorSubtract(x2, x1);
    XMVECTOR X = XMVector2LengthSq(V);
    return XMVectorGetX(X);
}

inline void Vector2::Min(const Vector2& v1, const Vector2& v2, Vector2& result) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat2(&v1);
    XMVECTOR x2 = XMLoadFloat2(&v2);
    XMVECTOR X = XMVectorMin(x1, x2);
    XMStoreFloat2(&result, X);
}

inline Vector2 Vector2::Min(const Vector2& v1, const Vector2& v2) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat2(&v1);
    XMVECTOR x2 = XMLoadFloat2(&v2);
    XMVECTOR X = XMVectorMin(x1, x2);

    Vector2 result;
    XMStoreFloat2(&result, X);
    return result;
}

inline void Vector2::Max(const Vector2& v1, const Vector2& v2, Vector2& result) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat2(&v1);
    XMVECTOR x2 = XMLoadFloat2(&v2);
    XMVECTOR X = XMVectorMax(x1, x2);
    XMStoreFloat2(&result, X);
}

inline Vector2 Vector2::Max(const Vector2& v1, const Vector2& v2) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat2(&v1);
    XMVECTOR x2 = XMLoadFloat2(&v2);
    XMVECTOR X = XMVectorMax(x1, x2);

    Vector2 result;
    XMStoreFloat2(&result, X);
    return result;
}

inline void Vector2::Lerp(const Vector2& v1, const Vector2& v2, float t, Vector2& result) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat2(&v1);
    XMVECTOR x2 = XMLoadFloat2(&v2);
    XMVECTOR X = XMVectorLerp(x1, x2, t);
    XMStoreFloat2(&result, X);
}

inline Vector2 Vector2::Lerp(const Vector2& v1, const Vector2& v2, float t) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat2(&v1);
    XMVECTOR x2 = XMLoadFloat2(&v2);
    XMVECTOR X = XMVectorLerp(x1, x2, t);

    Vector2 result;
    XMStoreFloat2(&result, X);
    return result;
}

inline void Vector2::SmoothStep(const Vector2& v1, const Vector2& v2, float t, Vector2& result) noexcept
{
    using namespace DirectX;
    t = (t > 1.0f) ? 1.0f : ((t < 0.0f) ? 0.0f : t);  // Clamp value to 0 to 1
    t = t * t*(3.f - 2.f*t);
    XMVECTOR x1 = XMLoadFloat2(&v1);
    XMVECTOR x2 = XMLoadFloat2(&v2);
    XMVECTOR X = XMVectorLerp(x1, x2, t);
    XMStoreFloat2(&result, X);
}

inline Vector2 Vector2::SmoothStep(const Vector2& v1, const Vector2& v2, float t) noexcept
{
    using namespace DirectX;
    t = (t > 1.0f) ? 1.0f : ((t < 0.0f) ? 0.0f : t);  // Clamp value to 0 to 1
    t = t * t*(3.f - 2.f*t);
    XMVECTOR x1 = XMLoadFloat2(&v1);
    XMVECTOR x2 = XMLoadFloat2(&v2);
    XMVECTOR X = XMVectorLerp(x1, x2, t);

    Vector2 result;
    XMStoreFloat2(&result, X);
    return result;
}

inline void Vector2::Barycentric(const Vector2& v1, const Vector2& v2, const Vector2& v3, float f, float g, Vector2& result) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat2(&v1);
    XMVECTOR x2 = XMLoadFloat2(&v2);
    XMVECTOR x3 = XMLoadFloat2(&v3);
    XMVECTOR X = XMVectorBaryCentric(x1, x2, x3, f, g);
    XMStoreFloat2(&result, X);
}

inline Vector2 Vector2::Barycentric(const Vector2& v1, const Vector2& v2, const Vector2& v3, float f, float g) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat2(&v1);
    XMVECTOR x2 = XMLoadFloat2(&v2);
    XMVECTOR x3 = XMLoadFloat2(&v3);
    XMVECTOR X = XMVectorBaryCentric(x1, x2, x3, f, g);

    Vector2 result;
    XMStoreFloat2(&result, X);
    return result;
}

inline void Vector2::CatmullRom(const Vector2& v1, const Vector2& v2, const Vector2& v3, const Vector2& v4, float t, Vector2& result) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat2(&v1);
    XMVECTOR x2 = XMLoadFloat2(&v2);
    XMVECTOR x3 = XMLoadFloat2(&v3);
    XMVECTOR x4 = XMLoadFloat2(&v4);
    XMVECTOR X = XMVectorCatmullRom(x1, x2, x3, x4, t);
    XMStoreFloat2(&result, X);
}

inline Vector2 Vector2::CatmullRom(const Vector2& v1, const Vector2& v2, const Vector2& v3, const Vector2& v4, float t) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat2(&v1);
    XMVECTOR x2 = XMLoadFloat2(&v2);
    XMVECTOR x3 = XMLoadFloat2(&v3);
    XMVECTOR x4 = XMLoadFloat2(&v4);
    XMVECTOR X = XMVectorCatmullRom(x1, x2, x3, x4, t);

    Vector2 result;
    XMStoreFloat2(&result, X);
    return result;
}

inline void Vector2::Hermite(const Vector2& v1, const Vector2& t1, const Vector2& v2, const Vector2& t2, float t, Vector2& result) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat2(&v1);
    XMVECTOR x2 = XMLoadFloat2(&t1);
    XMVECTOR x3 = XMLoadFloat2(&v2);
    XMVECTOR x4 = XMLoadFloat2(&t2);
    XMVECTOR X = XMVectorHermite(x1, x2, x3, x4, t);
    XMStoreFloat2(&result, X);
}

inline Vector2 Vector2::Hermite(const Vector2& v1, const Vector2& t1, const Vector2& v2, const Vector2& t2, float t) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat2(&v1);
    XMVECTOR x2 = XMLoadFloat2(&t1);
    XMVECTOR x3 = XMLoadFloat2(&v2);
    XMVECTOR x4 = XMLoadFloat2(&t2);
    XMVECTOR X = XMVectorHermite(x1, x2, x3, x4, t);

    Vector2 result;
    XMStoreFloat2(&result, X);
    return result;
}

inline void Vector2::Reflect(const Vector2& ivec, const Vector2& nvec, Vector2& result) noexcept
{
    using namespace DirectX;
    XMVECTOR i = XMLoadFloat2(&ivec);
    XMVECTOR n = XMLoadFloat2(&nvec);
    XMVECTOR X = XMVector2Reflect(i, n);
    XMStoreFloat2(&result, X);
}

inline Vector2 Vector2::Reflect(const Vector2& ivec, const Vector2& nvec) noexcept
{
    using namespace DirectX;
    XMVECTOR i = XMLoadFloat2(&ivec);
    XMVECTOR n = XMLoadFloat2(&nvec);
    XMVECTOR X = XMVector2Reflect(i, n);

    Vector2 result;
    XMStoreFloat2(&result, X);
    return result;
}

inline void Vector2::Refract(const Vector2& ivec, const Vector2& nvec, float refractionIndex, Vector2& result) noexcept
{
    using namespace DirectX;
    XMVECTOR i = XMLoadFloat2(&ivec);
    XMVECTOR n = XMLoadFloat2(&nvec);
    XMVECTOR X = XMVector2Refract(i, n, refractionIndex);
    XMStoreFloat2(&result, X);
}

inline Vector2 Vector2::Refract(const Vector2& ivec, const Vector2& nvec, float refractionIndex) noexcept
{
    using namespace DirectX;
    XMVECTOR i = XMLoadFloat2(&ivec);
    XMVECTOR n = XMLoadFloat2(&nvec);
    XMVECTOR X = XMVector2Refract(i, n, refractionIndex);

    Vector2 result;
    XMStoreFloat2(&result, X);
    return result;
}

inline void Vector2::Transform(const Vector2& v, const Quaternion& quat, Vector2& result) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(&v);
    XMVECTOR q = XMLoadFloat4(&quat);
    XMVECTOR X = XMVector3Rotate(v1, q);
    XMStoreFloat2(&result, X);
}

inline Vector2 Vector2::Transform(const Vector2& v, const Quaternion& quat) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(&v);
    XMVECTOR q = XMLoadFloat4(&quat);
    XMVECTOR X = XMVector3Rotate(v1, q);

    Vector2 result;
    XMStoreFloat2(&result, X);
    return result;
}

inline void Vector2::Transform(const Vector2& v, const Matrix& m, Vector2& result) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(&v);
    XMMATRIX M = XMLoadFloat4x4(&m);
    XMVECTOR X = XMVector2TransformCoord(v1, M);
    XMStoreFloat2(&result, X);
}

inline Vector2 Vector2::Transform(const Vector2& v, const Matrix& m) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(&v);
    XMMATRIX M = XMLoadFloat4x4(&m);
    XMVECTOR X = XMVector2TransformCoord(v1, M);

    Vector2 result;
    XMStoreFloat2(&result, X);
    return result;
}

_Use_decl_annotations_
inline void Vector2::Transform(const Vector2* varray, size_t count, const Matrix& m, Vector2* resultArray) noexcept
{
    using namespace DirectX;
    XMMATRIX M = XMLoadFloat4x4(&m);
    XMVector2TransformCoordStream(resultArray, sizeof(XMFLOAT2), varray, sizeof(XMFLOAT2), count, M);
}

inline void Vector2::Transform(const Vector2& v, const Matrix& m, Vector4& result) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(&v);
    XMMATRIX M = XMLoadFloat4x4(&m);
    XMVECTOR X = XMVector2Transform(v1, M);
    XMStoreFloat4(&result, X);
}

_Use_decl_annotations_
inline void Vector2::Transform(const Vector2* varray, size_t count, const Matrix& m, Vector4* resultArray) noexcept
{
    using namespace DirectX;
    XMMATRIX M = XMLoadFloat4x4(&m);
    XMVector2TransformStream(resultArray, sizeof(XMFLOAT4), varray, sizeof(XMFLOAT2), count, M);
}

inline void Vector2::TransformNormal(const Vector2& v, const Matrix& m, Vector2& result) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(&v);
    XMMATRIX M = XMLoadFloat4x4(&m);
    XMVECTOR X = XMVector2TransformNormal(v1, M);
    XMStoreFloat2(&result, X);
}

inline Vector2 Vector2::TransformNormal(const Vector2& v, const Matrix& m) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(&v);
    XMMATRIX M = XMLoadFloat4x4(&m);
    XMVECTOR X = XMVector2TransformNormal(v1, M);

    Vector2 result;
    XMStoreFloat2(&result, X);
    return result;
}

_Use_decl_annotations_
inline void Vector2::TransformNormal(const Vector2* varray, size_t count, const Matrix& m, Vector2* resultArray) noexcept
{
    using namespace DirectX;
    XMMATRIX M = XMLoadFloat4x4(&m);
    XMVector2TransformNormalStream(resultArray, sizeof(XMFLOAT2), varray, sizeof(XMFLOAT2), count, M);
}


/****************************************************************************
 *
 * Vector3
 *
 ****************************************************************************/

//------------------------------------------------------------------------------
// Comparision operators
//------------------------------------------------------------------------------

inline bool Vector3::operator == (const Vector3& V) const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(this);
    XMVECTOR v2 = XMLoadFloat3(&V);
    return XMVector3Equal(v1, v2);
}

inline bool Vector3::operator != (const Vector3& V) const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(this);
    XMVECTOR v2 = XMLoadFloat3(&V);
    return XMVector3NotEqual(v1, v2);
}

//------------------------------------------------------------------------------
// Assignment operators
//------------------------------------------------------------------------------

inline Vector3& Vector3::operator+= (const Vector3& V) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(this);
    XMVECTOR v2 = XMLoadFloat3(&V);
    XMVECTOR X = XMVectorAdd(v1, v2);
    XMStoreFloat3(this, X);
    return *this;
}

inline Vector3& Vector3::operator-= (const Vector3& V) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(this);
    XMVECTOR v2 = XMLoadFloat3(&V);
    XMVECTOR X = XMVectorSubtract(v1, v2);
    XMStoreFloat3(this, X);
    return *this;
}

inline Vector3& Vector3::operator*= (const Vector3& V) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(this);
    XMVECTOR v2 = XMLoadFloat3(&V);
    XMVECTOR X = XMVectorMultiply(v1, v2);
    XMStoreFloat3(this, X);
    return *this;
}

inline Vector3& Vector3::operator*= (float S) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(this);
    XMVECTOR X = XMVectorScale(v1, S);
    XMStoreFloat3(this, X);
    return *this;
}

inline Vector3& Vector3::operator/= (float S) noexcept
{
    using namespace DirectX;
    assert(S != 0.0f);
    XMVECTOR v1 = XMLoadFloat3(this);
    XMVECTOR X = XMVectorScale(v1, 1.f / S);
    XMStoreFloat3(this, X);
    return *this;
}

//------------------------------------------------------------------------------
// Urnary operators
//------------------------------------------------------------------------------

inline Vector3 Vector3::operator- () const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(this);
    XMVECTOR X = XMVectorNegate(v1);
    Vector3 R;
    XMStoreFloat3(&R, X);
    return R;
}

//------------------------------------------------------------------------------
// Binary operators
//------------------------------------------------------------------------------

inline Vector3 operator+ (const Vector3& V1, const Vector3& V2) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(&V1);
    XMVECTOR v2 = XMLoadFloat3(&V2);
    XMVECTOR X = XMVectorAdd(v1, v2);
    Vector3 R;
    XMStoreFloat3(&R, X);
    return R;
}

inline Vector3 operator- (const Vector3& V1, const Vector3& V2) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(&V1);
    XMVECTOR v2 = XMLoadFloat3(&V2);
    XMVECTOR X = XMVectorSubtract(v1, v2);
    Vector3 R;
    XMStoreFloat3(&R, X);
    return R;
}

inline Vector3 operator* (const Vector3& V1, const Vector3& V2) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(&V1);
    XMVECTOR v2 = XMLoadFloat3(&V2);
    XMVECTOR X = XMVectorMultiply(v1, v2);
    Vector3 R;
    XMStoreFloat3(&R, X);
    return R;
}

inline Vector3 operator* (const Vector3& V, float S) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(&V);
    XMVECTOR X = XMVectorScale(v1, S);
    Vector3 R;
    XMStoreFloat3(&R, X);
    return R;
}

inline Vector3 operator/ (const Vector3& V1, const Vector3& V2) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(&V1);
    XMVECTOR v2 = XMLoadFloat3(&V2);
    XMVECTOR X = XMVectorDivide(v1, v2);
    Vector3 R;
    XMStoreFloat3(&R, X);
    return R;
}

inline Vector3 operator/ (const Vector3& V, float S) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(&V);
    XMVECTOR X = XMVectorScale(v1, 1.f / S);
    Vector3 R;
    XMStoreFloat3(&R, X);
    return R;
}

inline Vector3 operator* (float S, const Vector3& V) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(&V);
    XMVECTOR X = XMVectorScale(v1, S);
    Vector3 R;
    XMStoreFloat3(&R, X);
    return R;
}

//------------------------------------------------------------------------------
// Vector operations
//------------------------------------------------------------------------------

inline bool Vector3::InBounds(const Vector3& Bounds) const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(this);
    XMVECTOR v2 = XMLoadFloat3(&Bounds);
    return XMVector3InBounds(v1, v2);
}

inline float Vector3::Length() const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(this);
    XMVECTOR X = XMVector3Length(v1);
    return XMVectorGetX(X);
}

inline float Vector3::LengthSquared() const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(this);
    XMVECTOR X = XMVector3LengthSq(v1);
    return XMVectorGetX(X);
}

inline float Vector3::Dot(const Vector3& V) const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(this);
    XMVECTOR v2 = XMLoadFloat3(&V);
    XMVECTOR X = XMVector3Dot(v1, v2);
    return XMVectorGetX(X);
}

inline void Vector3::Cross(const Vector3& V, Vector3& result) const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(this);
    XMVECTOR v2 = XMLoadFloat3(&V);
    XMVECTOR R = XMVector3Cross(v1, v2);
    XMStoreFloat3(&result, R);
}

inline Vector3 Vector3::Cross(const Vector3& V) const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(this);
    XMVECTOR v2 = XMLoadFloat3(&V);
    XMVECTOR R = XMVector3Cross(v1, v2);

    Vector3 result;
    XMStoreFloat3(&result, R);
    return result;
}

inline void Vector3::Normalize() noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(this);
    XMVECTOR X = XMVector3Normalize(v1);
    XMStoreFloat3(this, X);
}

inline void Vector3::Normalize(Vector3& result) const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(this);
    XMVECTOR X = XMVector3Normalize(v1);
    XMStoreFloat3(&result, X);
}

inline void Vector3::Clamp(const Vector3& vmin, const Vector3& vmax) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(this);
    XMVECTOR v2 = XMLoadFloat3(&vmin);
    XMVECTOR v3 = XMLoadFloat3(&vmax);
    XMVECTOR X = XMVectorClamp(v1, v2, v3);
    XMStoreFloat3(this, X);
}

inline void Vector3::Clamp(const Vector3& vmin, const Vector3& vmax, Vector3& result) const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(this);
    XMVECTOR v2 = XMLoadFloat3(&vmin);
    XMVECTOR v3 = XMLoadFloat3(&vmax);
    XMVECTOR X = XMVectorClamp(v1, v2, v3);
    XMStoreFloat3(&result, X);
}

//------------------------------------------------------------------------------
// Static functions
//------------------------------------------------------------------------------

inline float Vector3::Distance(const Vector3& v1, const Vector3& v2) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat3(&v1);
    XMVECTOR x2 = XMLoadFloat3(&v2);
    XMVECTOR V = XMVectorSubtract(x2, x1);
    XMVECTOR X = XMVector3Length(V);
    return XMVectorGetX(X);
}

inline float Vector3::DistanceSquared(const Vector3& v1, const Vector3& v2) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat3(&v1);
    XMVECTOR x2 = XMLoadFloat3(&v2);
    XMVECTOR V = XMVectorSubtract(x2, x1);
    XMVECTOR X = XMVector3LengthSq(V);
    return XMVectorGetX(X);
}

inline void Vector3::Min(const Vector3& v1, const Vector3& v2, Vector3& result) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat3(&v1);
    XMVECTOR x2 = XMLoadFloat3(&v2);
    XMVECTOR X = XMVectorMin(x1, x2);
    XMStoreFloat3(&result, X);
}

inline Vector3 Vector3::Min(const Vector3& v1, const Vector3& v2) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat3(&v1);
    XMVECTOR x2 = XMLoadFloat3(&v2);
    XMVECTOR X = XMVectorMin(x1, x2);

    Vector3 result;
    XMStoreFloat3(&result, X);
    return result;
}

inline void Vector3::Max(const Vector3& v1, const Vector3& v2, Vector3& result) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat3(&v1);
    XMVECTOR x2 = XMLoadFloat3(&v2);
    XMVECTOR X = XMVectorMax(x1, x2);
    XMStoreFloat3(&result, X);
}

inline Vector3 Vector3::Max(const Vector3& v1, const Vector3& v2) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat3(&v1);
    XMVECTOR x2 = XMLoadFloat3(&v2);
    XMVECTOR X = XMVectorMax(x1, x2);

    Vector3 result;
    XMStoreFloat3(&result, X);
    return result;
}

inline void Vector3::Lerp(const Vector3& v1, const Vector3& v2, float t, Vector3& result) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat3(&v1);
    XMVECTOR x2 = XMLoadFloat3(&v2);
    XMVECTOR X = XMVectorLerp(x1, x2, t);
    XMStoreFloat3(&result, X);
}

inline Vector3 Vector3::Lerp(const Vector3& v1, const Vector3& v2, float t) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat3(&v1);
    XMVECTOR x2 = XMLoadFloat3(&v2);
    XMVECTOR X = XMVectorLerp(x1, x2, t);

    Vector3 result;
    XMStoreFloat3(&result, X);
    return result;
}

inline void Vector3::SmoothStep(const Vector3& v1, const Vector3& v2, float t, Vector3& result) noexcept
{
    using namespace DirectX;
    t = (t > 1.0f) ? 1.0f : ((t < 0.0f) ? 0.0f : t);  // Clamp value to 0 to 1
    t = t * t*(3.f - 2.f*t);
    XMVECTOR x1 = XMLoadFloat3(&v1);
    XMVECTOR x2 = XMLoadFloat3(&v2);
    XMVECTOR X = XMVectorLerp(x1, x2, t);
    XMStoreFloat3(&result, X);
}

inline Vector3 Vector3::SmoothStep(const Vector3& v1, const Vector3& v2, float t) noexcept
{
    using namespace DirectX;
    t = (t > 1.0f) ? 1.0f : ((t < 0.0f) ? 0.0f : t);  // Clamp value to 0 to 1
    t = t * t*(3.f - 2.f*t);
    XMVECTOR x1 = XMLoadFloat3(&v1);
    XMVECTOR x2 = XMLoadFloat3(&v2);
    XMVECTOR X = XMVectorLerp(x1, x2, t);

    Vector3 result;
    XMStoreFloat3(&result, X);
    return result;
}

inline void Vector3::Barycentric(const Vector3& v1, const Vector3& v2, const Vector3& v3, float f, float g, Vector3& result) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat3(&v1);
    XMVECTOR x2 = XMLoadFloat3(&v2);
    XMVECTOR x3 = XMLoadFloat3(&v3);
    XMVECTOR X = XMVectorBaryCentric(x1, x2, x3, f, g);
    XMStoreFloat3(&result, X);
}

inline Vector3 Vector3::Barycentric(const Vector3& v1, const Vector3& v2, const Vector3& v3, float f, float g) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat3(&v1);
    XMVECTOR x2 = XMLoadFloat3(&v2);
    XMVECTOR x3 = XMLoadFloat3(&v3);
    XMVECTOR X = XMVectorBaryCentric(x1, x2, x3, f, g);

    Vector3 result;
    XMStoreFloat3(&result, X);
    return result;
}

inline void Vector3::CatmullRom(const Vector3& v1, const Vector3& v2, const Vector3& v3, const Vector3& v4, float t, Vector3& result) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat3(&v1);
    XMVECTOR x2 = XMLoadFloat3(&v2);
    XMVECTOR x3 = XMLoadFloat3(&v3);
    XMVECTOR x4 = XMLoadFloat3(&v4);
    XMVECTOR X = XMVectorCatmullRom(x1, x2, x3, x4, t);
    XMStoreFloat3(&result, X);
}

inline Vector3 Vector3::CatmullRom(const Vector3& v1, const Vector3& v2, const Vector3& v3, const Vector3& v4, float t) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat3(&v1);
    XMVECTOR x2 = XMLoadFloat3(&v2);
    XMVECTOR x3 = XMLoadFloat3(&v3);
    XMVECTOR x4 = XMLoadFloat3(&v4);
    XMVECTOR X = XMVectorCatmullRom(x1, x2, x3, x4, t);

    Vector3 result;
    XMStoreFloat3(&result, X);
    return result;
}

inline void Vector3::Hermite(const Vector3& v1, const Vector3& t1, const Vector3& v2, const Vector3& t2, float t, Vector3& result) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat3(&v1);
    XMVECTOR x2 = XMLoadFloat3(&t1);
    XMVECTOR x3 = XMLoadFloat3(&v2);
    XMVECTOR x4 = XMLoadFloat3(&t2);
    XMVECTOR X = XMVectorHermite(x1, x2, x3, x4, t);
    XMStoreFloat3(&result, X);
}

inline Vector3 Vector3::Hermite(const Vector3& v1, const Vector3& t1, const Vector3& v2, const Vector3& t2, float t) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat3(&v1);
    XMVECTOR x2 = XMLoadFloat3(&t1);
    XMVECTOR x3 = XMLoadFloat3(&v2);
    XMVECTOR x4 = XMLoadFloat3(&t2);
    XMVECTOR X = XMVectorHermite(x1, x2, x3, x4, t);

    Vector3 result;
    XMStoreFloat3(&result, X);
    return result;
}

inline void Vector3::Reflect(const Vector3& ivec, const Vector3& nvec, Vector3& result) noexcept
{
    using namespace DirectX;
    XMVECTOR i = XMLoadFloat3(&ivec);
    XMVECTOR n = XMLoadFloat3(&nvec);
    XMVECTOR X = XMVector3Reflect(i, n);
    XMStoreFloat3(&result, X);
}

inline Vector3 Vector3::Reflect(const Vector3& ivec, const Vector3& nvec) noexcept
{
    using namespace DirectX;
    XMVECTOR i = XMLoadFloat3(&ivec);
    XMVECTOR n = XMLoadFloat3(&nvec);
    XMVECTOR X = XMVector3Reflect(i, n);

    Vector3 result;
    XMStoreFloat3(&result, X);
    return result;
}

inline void Vector3::Refract(const Vector3& ivec, const Vector3& nvec, float refractionIndex, Vector3& result) noexcept
{
    using namespace DirectX;
    XMVECTOR i = XMLoadFloat3(&ivec);
    XMVECTOR n = XMLoadFloat3(&nvec);
    XMVECTOR X = XMVector3Refract(i, n, refractionIndex);
    XMStoreFloat3(&result, X);
}

inline Vector3 Vector3::Refract(const Vector3& ivec, const Vector3& nvec, float refractionIndex) noexcept
{
    using namespace DirectX;
    XMVECTOR i = XMLoadFloat3(&ivec);
    XMVECTOR n = XMLoadFloat3(&nvec);
    XMVECTOR X = XMVector3Refract(i, n, refractionIndex);

    Vector3 result;
    XMStoreFloat3(&result, X);
    return result;
}

inline void Vector3::Transform(const Vector3& v, const Quaternion& quat, Vector3& result) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(&v);
    XMVECTOR q = XMLoadFloat4(&quat);
    XMVECTOR X = XMVector3Rotate(v1, q);
    XMStoreFloat3(&result, X);
}

inline Vector3 Vector3::Transform(const Vector3& v, const Quaternion& quat) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(&v);
    XMVECTOR q = XMLoadFloat4(&quat);
    XMVECTOR X = XMVector3Rotate(v1, q);

    Vector3 result;
    XMStoreFloat3(&result, X);
    return result;
}

inline void Vector3::Transform(const Vector3& v, const Matrix& m, Vector3& result) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(&v);
    XMMATRIX M = XMLoadFloat4x4(&m);
    XMVECTOR X = XMVector3TransformCoord(v1, M);
    XMStoreFloat3(&result, X);
}

inline Vector3 Vector3::Transform(const Vector3& v, const Matrix& m) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(&v);
    XMMATRIX M = XMLoadFloat4x4(&m);
    XMVECTOR X = XMVector3TransformCoord(v1, M);

    Vector3 result;
    XMStoreFloat3(&result, X);
    return result;
}

_Use_decl_annotations_
inline void Vector3::Transform(const Vector3* varray, size_t count, const Matrix& m, Vector3* resultArray) noexcept
{
    using namespace DirectX;
    XMMATRIX M = XMLoadFloat4x4(&m);
    XMVector3TransformCoordStream(resultArray, sizeof(XMFLOAT3), varray, sizeof(XMFLOAT3), count, M);
}

inline void Vector3::Transform(const Vector3& v, const Matrix& m, Vector4& result) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(&v);
    XMMATRIX M = XMLoadFloat4x4(&m);
    XMVECTOR X = XMVector3Transform(v1, M);
    XMStoreFloat4(&result, X);
}

_Use_decl_annotations_
inline void Vector3::Transform(const Vector3* varray, size_t count, const Matrix& m, Vector4* resultArray) noexcept
{
    using namespace DirectX;
    XMMATRIX M = XMLoadFloat4x4(&m);
    XMVector3TransformStream(resultArray, sizeof(XMFLOAT4), varray, sizeof(XMFLOAT3), count, M);
}

inline void Vector3::TransformNormal(const Vector3& v, const Matrix& m, Vector3& result) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(&v);
    XMMATRIX M = XMLoadFloat4x4(&m);
    XMVECTOR X = XMVector3TransformNormal(v1, M);
    XMStoreFloat3(&result, X);
}

inline Vector3 Vector3::TransformNormal(const Vector3& v, const Matrix& m) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(&v);
    XMMATRIX M = XMLoadFloat4x4(&m);
    XMVECTOR X = XMVector3TransformNormal(v1, M);

    Vector3 result;
    XMStoreFloat3(&result, X);
    return result;
}

_Use_decl_annotations_
inline void Vector3::TransformNormal(const Vector3* varray, size_t count, const Matrix& m, Vector3* resultArray) noexcept
{
    using namespace DirectX;
    XMMATRIX M = XMLoadFloat4x4(&m);
    XMVector3TransformNormalStream(resultArray, sizeof(XMFLOAT3), varray, sizeof(XMFLOAT3), count, M);
}


/****************************************************************************
 *
 * Vector4
 *
 ****************************************************************************/

//------------------------------------------------------------------------------
// Comparision operators
//------------------------------------------------------------------------------

inline bool Vector4::operator == (const Vector4& V) const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat4(this);
    XMVECTOR v2 = XMLoadFloat4(&V);
    return XMVector4Equal(v1, v2);
}

inline bool Vector4::operator != (const Vector4& V) const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat4(this);
    XMVECTOR v2 = XMLoadFloat4(&V);
    return XMVector4NotEqual(v1, v2);
}

//------------------------------------------------------------------------------
// Assignment operators
//------------------------------------------------------------------------------

inline Vector4& Vector4::operator+= (const Vector4& V) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat4(this);
    XMVECTOR v2 = XMLoadFloat4(&V);
    XMVECTOR X = XMVectorAdd(v1, v2);
    XMStoreFloat4(this, X);
    return *this;
}

inline Vector4& Vector4::operator-= (const Vector4& V) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat4(this);
    XMVECTOR v2 = XMLoadFloat4(&V);
    XMVECTOR X = XMVectorSubtract(v1, v2);
    XMStoreFloat4(this, X);
    return *this;
}

inline Vector4& Vector4::operator*= (const Vector4& V) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat4(this);
    XMVECTOR v2 = XMLoadFloat4(&V);
    XMVECTOR X = XMVectorMultiply(v1, v2);
    XMStoreFloat4(this, X);
    return *this;
}

inline Vector4& Vector4::operator*= (float S) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat4(this);
    XMVECTOR X = XMVectorScale(v1, S);
    XMStoreFloat4(this, X);
    return *this;
}

inline Vector4& Vector4::operator/= (float S) noexcept
{
    using namespace DirectX;
    assert(S != 0.0f);
    XMVECTOR v1 = XMLoadFloat4(this);
    XMVECTOR X = XMVectorScale(v1, 1.f / S);
    XMStoreFloat4(this, X);
    return *this;
}

//------------------------------------------------------------------------------
// Urnary operators
//------------------------------------------------------------------------------

inline Vector4 Vector4::operator- () const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat4(this);
    XMVECTOR X = XMVectorNegate(v1);
    Vector4 R;
    XMStoreFloat4(&R, X);
    return R;
}

//------------------------------------------------------------------------------
// Binary operators
//------------------------------------------------------------------------------

inline Vector4 operator+ (const Vector4& V1, const Vector4& V2) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat4(&V1);
    XMVECTOR v2 = XMLoadFloat4(&V2);
    XMVECTOR X = XMVectorAdd(v1, v2);
    Vector4 R;
    XMStoreFloat4(&R, X);
    return R;
}

inline Vector4 operator- (const Vector4& V1, const Vector4& V2) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat4(&V1);
    XMVECTOR v2 = XMLoadFloat4(&V2);
    XMVECTOR X = XMVectorSubtract(v1, v2);
    Vector4 R;
    XMStoreFloat4(&R, X);
    return R;
}

inline Vector4 operator* (const Vector4& V1, const Vector4& V2) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat4(&V1);
    XMVECTOR v2 = XMLoadFloat4(&V2);
    XMVECTOR X = XMVectorMultiply(v1, v2);
    Vector4 R;
    XMStoreFloat4(&R, X);
    return R;
}

inline Vector4 operator* (const Vector4& V, float S) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat4(&V);
    XMVECTOR X = XMVectorScale(v1, S);
    Vector4 R;
    XMStoreFloat4(&R, X);
    return R;
}

inline Vector4 operator/ (const Vector4& V1, const Vector4& V2) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat4(&V1);
    XMVECTOR v2 = XMLoadFloat4(&V2);
    XMVECTOR X = XMVectorDivide(v1, v2);
    Vector4 R;
    XMStoreFloat4(&R, X);
    return R;
}

inline Vector4 operator/ (const Vector4& V, float S) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat4(&V);
    XMVECTOR X = XMVectorScale(v1, 1.f / S);
    Vector4 R;
    XMStoreFloat4(&R, X);
    return R;
}

inline Vector4 operator* (float S, const Vector4& V) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat4(&V);
    XMVECTOR X = XMVectorScale(v1, S);
    Vector4 R;
    XMStoreFloat4(&R, X);
    return R;
}

//------------------------------------------------------------------------------
// Vector operations
//------------------------------------------------------------------------------

inline bool Vector4::InBounds(const Vector4& Bounds) const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat4(this);
    XMVECTOR v2 = XMLoadFloat4(&Bounds);
    return XMVector4InBounds(v1, v2);
}

inline float Vector4::Length() const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat4(this);
    XMVECTOR X = XMVector4Length(v1);
    return XMVectorGetX(X);
}

inline float Vector4::LengthSquared() const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat4(this);
    XMVECTOR X = XMVector4LengthSq(v1);
    return XMVectorGetX(X);
}

inline float Vector4::Dot(const Vector4& V) const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat4(this);
    XMVECTOR v2 = XMLoadFloat4(&V);
    XMVECTOR X = XMVector4Dot(v1, v2);
    return XMVectorGetX(X);
}

inline void Vector4::Cross(const Vector4& v1, const Vector4& v2, Vector4& result) const noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat4(this);
    XMVECTOR x2 = XMLoadFloat4(&v1);
    XMVECTOR x3 = XMLoadFloat4(&v2);
    XMVECTOR R = XMVector4Cross(x1, x2, x3);
    XMStoreFloat4(&result, R);
}

inline Vector4 Vector4::Cross(const Vector4& v1, const Vector4& v2) const noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat4(this);
    XMVECTOR x2 = XMLoadFloat4(&v1);
    XMVECTOR x3 = XMLoadFloat4(&v2);
    XMVECTOR R = XMVector4Cross(x1, x2, x3);

    Vector4 result;
    XMStoreFloat4(&result, R);
    return result;
}

inline void Vector4::Normalize() noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat4(this);
    XMVECTOR X = XMVector4Normalize(v1);
    XMStoreFloat4(this, X);
}

inline void Vector4::Normalize(Vector4& result) const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat4(this);
    XMVECTOR X = XMVector4Normalize(v1);
    XMStoreFloat4(&result, X);
}

inline void Vector4::Clamp(const Vector4& vmin, const Vector4& vmax) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat4(this);
    XMVECTOR v2 = XMLoadFloat4(&vmin);
    XMVECTOR v3 = XMLoadFloat4(&vmax);
    XMVECTOR X = XMVectorClamp(v1, v2, v3);
    XMStoreFloat4(this, X);
}

inline void Vector4::Clamp(const Vector4& vmin, const Vector4& vmax, Vector4& result) const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat4(this);
    XMVECTOR v2 = XMLoadFloat4(&vmin);
    XMVECTOR v3 = XMLoadFloat4(&vmax);
    XMVECTOR X = XMVectorClamp(v1, v2, v3);
    XMStoreFloat4(&result, X);
}

//------------------------------------------------------------------------------
// Static functions
//------------------------------------------------------------------------------

inline float Vector4::Distance(const Vector4& v1, const Vector4& v2) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat4(&v1);
    XMVECTOR x2 = XMLoadFloat4(&v2);
    XMVECTOR V = XMVectorSubtract(x2, x1);
    XMVECTOR X = XMVector4Length(V);
    return XMVectorGetX(X);
}

inline float Vector4::DistanceSquared(const Vector4& v1, const Vector4& v2) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat4(&v1);
    XMVECTOR x2 = XMLoadFloat4(&v2);
    XMVECTOR V = XMVectorSubtract(x2, x1);
    XMVECTOR X = XMVector4LengthSq(V);
    return XMVectorGetX(X);
}

inline void Vector4::Min(const Vector4& v1, const Vector4& v2, Vector4& result) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat4(&v1);
    XMVECTOR x2 = XMLoadFloat4(&v2);
    XMVECTOR X = XMVectorMin(x1, x2);
    XMStoreFloat4(&result, X);
}

inline Vector4 Vector4::Min(const Vector4& v1, const Vector4& v2) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat4(&v1);
    XMVECTOR x2 = XMLoadFloat4(&v2);
    XMVECTOR X = XMVectorMin(x1, x2);

    Vector4 result;
    XMStoreFloat4(&result, X);
    return result;
}

inline void Vector4::Max(const Vector4& v1, const Vector4& v2, Vector4& result) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat4(&v1);
    XMVECTOR x2 = XMLoadFloat4(&v2);
    XMVECTOR X = XMVectorMax(x1, x2);
    XMStoreFloat4(&result, X);
}

inline Vector4 Vector4::Max(const Vector4& v1, const Vector4& v2) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat4(&v1);
    XMVECTOR x2 = XMLoadFloat4(&v2);
    XMVECTOR X = XMVectorMax(x1, x2);

    Vector4 result;
    XMStoreFloat4(&result, X);
    return result;
}

inline void Vector4::Lerp(const Vector4& v1, const Vector4& v2, float t, Vector4& result) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat4(&v1);
    XMVECTOR x2 = XMLoadFloat4(&v2);
    XMVECTOR X = XMVectorLerp(x1, x2, t);
    XMStoreFloat4(&result, X);
}

inline Vector4 Vector4::Lerp(const Vector4& v1, const Vector4& v2, float t) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat4(&v1);
    XMVECTOR x2 = XMLoadFloat4(&v2);
    XMVECTOR X = XMVectorLerp(x1, x2, t);

    Vector4 result;
    XMStoreFloat4(&result, X);
    return result;
}

inline void Vector4::SmoothStep(const Vector4& v1, const Vector4& v2, float t, Vector4& result) noexcept
{
    using namespace DirectX;
    t = (t > 1.0f) ? 1.0f : ((t < 0.0f) ? 0.0f : t);  // Clamp value to 0 to 1
    t = t * t*(3.f - 2.f*t);
    XMVECTOR x1 = XMLoadFloat4(&v1);
    XMVECTOR x2 = XMLoadFloat4(&v2);
    XMVECTOR X = XMVectorLerp(x1, x2, t);
    XMStoreFloat4(&result, X);
}

inline Vector4 Vector4::SmoothStep(const Vector4& v1, const Vector4& v2, float t) noexcept
{
    using namespace DirectX;
    t = (t > 1.0f) ? 1.0f : ((t < 0.0f) ? 0.0f : t);  // Clamp value to 0 to 1
    t = t * t*(3.f - 2.f*t);
    XMVECTOR x1 = XMLoadFloat4(&v1);
    XMVECTOR x2 = XMLoadFloat4(&v2);
    XMVECTOR X = XMVectorLerp(x1, x2, t);

    Vector4 result;
    XMStoreFloat4(&result, X);
    return result;
}

inline void Vector4::Barycentric(const Vector4& v1, const Vector4& v2, const Vector4& v3, float f, float g, Vector4& result) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat4(&v1);
    XMVECTOR x2 = XMLoadFloat4(&v2);
    XMVECTOR x3 = XMLoadFloat4(&v3);
    XMVECTOR X = XMVectorBaryCentric(x1, x2, x3, f, g);
    XMStoreFloat4(&result, X);
}

inline Vector4 Vector4::Barycentric(const Vector4& v1, const Vector4& v2, const Vector4& v3, float f, float g) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat4(&v1);
    XMVECTOR x2 = XMLoadFloat4(&v2);
    XMVECTOR x3 = XMLoadFloat4(&v3);
    XMVECTOR X = XMVectorBaryCentric(x1, x2, x3, f, g);

    Vector4 result;
    XMStoreFloat4(&result, X);
    return result;
}

inline void Vector4::CatmullRom(const Vector4& v1, const Vector4& v2, const Vector4& v3, const Vector4& v4, float t, Vector4& result) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat4(&v1);
    XMVECTOR x2 = XMLoadFloat4(&v2);
    XMVECTOR x3 = XMLoadFloat4(&v3);
    XMVECTOR x4 = XMLoadFloat4(&v4);
    XMVECTOR X = XMVectorCatmullRom(x1, x2, x3, x4, t);
    XMStoreFloat4(&result, X);
}

inline Vector4 Vector4::CatmullRom(const Vector4& v1, const Vector4& v2, const Vector4& v3, const Vector4& v4, float t) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat4(&v1);
    XMVECTOR x2 = XMLoadFloat4(&v2);
    XMVECTOR x3 = XMLoadFloat4(&v3);
    XMVECTOR x4 = XMLoadFloat4(&v4);
    XMVECTOR X = XMVectorCatmullRom(x1, x2, x3, x4, t);

    Vector4 result;
    XMStoreFloat4(&result, X);
    return result;
}

inline void Vector4::Hermite(const Vector4& v1, const Vector4& t1, const Vector4& v2, const Vector4& t2, float t, Vector4& result) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat4(&v1);
    XMVECTOR x2 = XMLoadFloat4(&t1);
    XMVECTOR x3 = XMLoadFloat4(&v2);
    XMVECTOR x4 = XMLoadFloat4(&t2);
    XMVECTOR X = XMVectorHermite(x1, x2, x3, x4, t);
    XMStoreFloat4(&result, X);
}

inline Vector4 Vector4::Hermite(const Vector4& v1, const Vector4& t1, const Vector4& v2, const Vector4& t2, float t) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat4(&v1);
    XMVECTOR x2 = XMLoadFloat4(&t1);
    XMVECTOR x3 = XMLoadFloat4(&v2);
    XMVECTOR x4 = XMLoadFloat4(&t2);
    XMVECTOR X = XMVectorHermite(x1, x2, x3, x4, t);

    Vector4 result;
    XMStoreFloat4(&result, X);
    return result;
}

inline void Vector4::Reflect(const Vector4& ivec, const Vector4& nvec, Vector4& result) noexcept
{
    using namespace DirectX;
    XMVECTOR i = XMLoadFloat4(&ivec);
    XMVECTOR n = XMLoadFloat4(&nvec);
    XMVECTOR X = XMVector4Reflect(i, n);
    XMStoreFloat4(&result, X);
}

inline Vector4 Vector4::Reflect(const Vector4& ivec, const Vector4& nvec) noexcept
{
    using namespace DirectX;
    XMVECTOR i = XMLoadFloat4(&ivec);
    XMVECTOR n = XMLoadFloat4(&nvec);
    XMVECTOR X = XMVector4Reflect(i, n);

    Vector4 result;
    XMStoreFloat4(&result, X);
    return result;
}

inline void Vector4::Refract(const Vector4& ivec, const Vector4& nvec, float refractionIndex, Vector4& result) noexcept
{
    using namespace DirectX;
    XMVECTOR i = XMLoadFloat4(&ivec);
    XMVECTOR n = XMLoadFloat4(&nvec);
    XMVECTOR X = XMVector4Refract(i, n, refractionIndex);
    XMStoreFloat4(&result, X);
}

inline Vector4 Vector4::Refract(const Vector4& ivec, const Vector4& nvec, float refractionIndex) noexcept
{
    using namespace DirectX;
    XMVECTOR i = XMLoadFloat4(&ivec);
    XMVECTOR n = XMLoadFloat4(&nvec);
    XMVECTOR X = XMVector4Refract(i, n, refractionIndex);

    Vector4 result;
    XMStoreFloat4(&result, X);
    return result;
}

inline void Vector4::Transform(const Vector2& v, const Quaternion& quat, Vector4& result) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(&v);
    XMVECTOR q = XMLoadFloat4(&quat);
    XMVECTOR X = XMVector3Rotate(v1, q);
    X = XMVectorSelect(g_XMIdentityR3, X, g_XMSelect1110); // result.w = 1.f
    XMStoreFloat4(&result, X);
}

inline Vector4 Vector4::Transform(const Vector2& v, const Quaternion& quat) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat2(&v);
    XMVECTOR q = XMLoadFloat4(&quat);
    XMVECTOR X = XMVector3Rotate(v1, q);
    X = XMVectorSelect(g_XMIdentityR3, X, g_XMSelect1110); // result.w = 1.f

    Vector4 result;
    XMStoreFloat4(&result, X);
    return result;
}

inline void Vector4::Transform(const Vector3& v, const Quaternion& quat, Vector4& result) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(&v);
    XMVECTOR q = XMLoadFloat4(&quat);
    XMVECTOR X = XMVector3Rotate(v1, q);
    X = XMVectorSelect(g_XMIdentityR3, X, g_XMSelect1110); // result.w = 1.f
    XMStoreFloat4(&result, X);
}

inline Vector4 Vector4::Transform(const Vector3& v, const Quaternion& quat) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat3(&v);
    XMVECTOR q = XMLoadFloat4(&quat);
    XMVECTOR X = XMVector3Rotate(v1, q);
    X = XMVectorSelect(g_XMIdentityR3, X, g_XMSelect1110); // result.w = 1.f

    Vector4 result;
    XMStoreFloat4(&result, X);
    return result;
}

inline void Vector4::Transform(const Vector4& v, const Quaternion& quat, Vector4& result) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat4(&v);
    XMVECTOR q = XMLoadFloat4(&quat);
    XMVECTOR X = XMVector3Rotate(v1, q);
    X = XMVectorSelect(v1, X, g_XMSelect1110); // result.w = v.w
    XMStoreFloat4(&result, X);
}

inline Vector4 Vector4::Transform(const Vector4& v, const Quaternion& quat) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat4(&v);
    XMVECTOR q = XMLoadFloat4(&quat);
    XMVECTOR X = XMVector3Rotate(v1, q);
    X = XMVectorSelect(v1, X, g_XMSelect1110); // result.w = v.w

    Vector4 result;
    XMStoreFloat4(&result, X);
    return result;
}

inline void Vector4::Transform(const Vector4& v, const Matrix& m, Vector4& result) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat4(&v);
    XMMATRIX M = XMLoadFloat4x4(&m);
    XMVECTOR X = XMVector4Transform(v1, M);
    XMStoreFloat4(&result, X);
}

inline Vector4 Vector4::Transform(const Vector4& v, const Matrix& m) noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat4(&v);
    XMMATRIX M = XMLoadFloat4x4(&m);
    XMVECTOR X = XMVector4Transform(v1, M);

    Vector4 result;
    XMStoreFloat4(&result, X);
    return result;
}

_Use_decl_annotations_
inline void Vector4::Transform(const Vector4* varray, size_t count, const Matrix& m, Vector4* resultArray) noexcept
{
    using namespace DirectX;
    XMMATRIX M = XMLoadFloat4x4(&m);
    XMVector4TransformStream(resultArray, sizeof(XMFLOAT4), varray, sizeof(XMFLOAT4), count, M);
}


/****************************************************************************
 *
 * Matrix
 *
 ****************************************************************************/

//------------------------------------------------------------------------------
// Comparision operators
//------------------------------------------------------------------------------

inline bool Matrix::operator == (const Matrix& M) const noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_11));
    XMVECTOR x2 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_21));
    XMVECTOR x3 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_31));
    XMVECTOR x4 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_41));

    XMVECTOR y1 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._11));
    XMVECTOR y2 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._21));
    XMVECTOR y3 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._31));
    XMVECTOR y4 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._41));

    return (XMVector4Equal(x1, y1)
            && XMVector4Equal(x2, y2)
            && XMVector4Equal(x3, y3)
            && XMVector4Equal(x4, y4)) != 0;
}

inline bool Matrix::operator != (const Matrix& M) const noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_11));
    XMVECTOR x2 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_21));
    XMVECTOR x3 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_31));
    XMVECTOR x4 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_41));

    XMVECTOR y1 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._11));
    XMVECTOR y2 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._21));
    XMVECTOR y3 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._31));
    XMVECTOR y4 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._41));

    return (XMVector4NotEqual(x1, y1)
            || XMVector4NotEqual(x2, y2)
            || XMVector4NotEqual(x3, y3)
            || XMVector4NotEqual(x4, y4)) != 0;
}

//------------------------------------------------------------------------------
// Assignment operators
//------------------------------------------------------------------------------

inline Matrix::Matrix(const XMFLOAT3X3& M) noexcept
{
    _11 = M._11; _12 = M._12; _13 = M._13; _14 = 0.f;
    _21 = M._21; _22 = M._22; _23 = M._23; _24 = 0.f;
    _31 = M._31; _32 = M._32; _33 = M._33; _34 = 0.f;
    _41 = 0.f;   _42 = 0.f;   _43 = 0.f;   _44 = 1.f;
}

inline Matrix::Matrix(const XMFLOAT4X3& M) noexcept
{
    _11 = M._11; _12 = M._12; _13 = M._13; _14 = 0.f;
    _21 = M._21; _22 = M._22; _23 = M._23; _24 = 0.f;
    _31 = M._31; _32 = M._32; _33 = M._33; _34 = 0.f;
    _41 = M._41; _42 = M._42; _43 = M._43; _44 = 1.f;
}

inline Matrix& Matrix::operator= (const XMFLOAT3X3& M) noexcept
{
    _11 = M._11; _12 = M._12; _13 = M._13; _14 = 0.f;
    _21 = M._21; _22 = M._22; _23 = M._23; _24 = 0.f;
    _31 = M._31; _32 = M._32; _33 = M._33; _34 = 0.f;
    _41 = 0.f;   _42 = 0.f;   _43 = 0.f;   _44 = 1.f;
    return *this;
}

inline Matrix& Matrix::operator= (const XMFLOAT4X3& M) noexcept
{
    _11 = M._11; _12 = M._12; _13 = M._13; _14 = 0.f;
    _21 = M._21; _22 = M._22; _23 = M._23; _24 = 0.f;
    _31 = M._31; _32 = M._32; _33 = M._33; _34 = 0.f;
    _41 = M._41; _42 = M._42; _43 = M._43; _44 = 1.f;
    return *this;
}

inline Matrix& Matrix::operator+= (const Matrix& M) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_11));
    XMVECTOR x2 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_21));
    XMVECTOR x3 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_31));
    XMVECTOR x4 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_41));

    XMVECTOR y1 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._11));
    XMVECTOR y2 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._21));
    XMVECTOR y3 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._31));
    XMVECTOR y4 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._41));

    x1 = XMVectorAdd(x1, y1);
    x2 = XMVectorAdd(x2, y2);
    x3 = XMVectorAdd(x3, y3);
    x4 = XMVectorAdd(x4, y4);

    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&_11), x1);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&_21), x2);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&_31), x3);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&_41), x4);
    return *this;
}

inline Matrix& Matrix::operator-= (const Matrix& M) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_11));
    XMVECTOR x2 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_21));
    XMVECTOR x3 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_31));
    XMVECTOR x4 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_41));

    XMVECTOR y1 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._11));
    XMVECTOR y2 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._21));
    XMVECTOR y3 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._31));
    XMVECTOR y4 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._41));

    x1 = XMVectorSubtract(x1, y1);
    x2 = XMVectorSubtract(x2, y2);
    x3 = XMVectorSubtract(x3, y3);
    x4 = XMVectorSubtract(x4, y4);

    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&_11), x1);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&_21), x2);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&_31), x3);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&_41), x4);
    return *this;
}

inline Matrix& Matrix::operator*= (const Matrix& M) noexcept
{
    using namespace DirectX;
    XMMATRIX M1 = XMLoadFloat4x4(this);
    XMMATRIX M2 = XMLoadFloat4x4(&M);
    XMMATRIX X = XMMatrixMultiply(M1, M2);
    XMStoreFloat4x4(this, X);
    return *this;
}

inline Matrix& Matrix::operator*= (float S) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_11));
    XMVECTOR x2 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_21));
    XMVECTOR x3 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_31));
    XMVECTOR x4 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_41));

    x1 = XMVectorScale(x1, S);
    x2 = XMVectorScale(x2, S);
    x3 = XMVectorScale(x3, S);
    x4 = XMVectorScale(x4, S);

    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&_11), x1);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&_21), x2);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&_31), x3);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&_41), x4);
    return *this;
}

inline Matrix& Matrix::operator/= (float S) noexcept
{
    using namespace DirectX;
    assert(S != 0.f);
    XMVECTOR x1 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_11));
    XMVECTOR x2 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_21));
    XMVECTOR x3 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_31));
    XMVECTOR x4 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_41));

    float rs = 1.f / S;

    x1 = XMVectorScale(x1, rs);
    x2 = XMVectorScale(x2, rs);
    x3 = XMVectorScale(x3, rs);
    x4 = XMVectorScale(x4, rs);

    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&_11), x1);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&_21), x2);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&_31), x3);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&_41), x4);
    return *this;
}

inline Matrix& Matrix::operator/= (const Matrix& M) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_11));
    XMVECTOR x2 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_21));
    XMVECTOR x3 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_31));
    XMVECTOR x4 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_41));

    XMVECTOR y1 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._11));
    XMVECTOR y2 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._21));
    XMVECTOR y3 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._31));
    XMVECTOR y4 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._41));

    x1 = XMVectorDivide(x1, y1);
    x2 = XMVectorDivide(x2, y2);
    x3 = XMVectorDivide(x3, y3);
    x4 = XMVectorDivide(x4, y4);

    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&_11), x1);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&_21), x2);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&_31), x3);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&_41), x4);
    return *this;
}

//------------------------------------------------------------------------------
// Urnary operators
//------------------------------------------------------------------------------

inline Matrix Matrix::operator- () const noexcept
{
    using namespace DirectX;
    XMVECTOR v1 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_11));
    XMVECTOR v2 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_21));
    XMVECTOR v3 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_31));
    XMVECTOR v4 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&_41));

    v1 = XMVectorNegate(v1);
    v2 = XMVectorNegate(v2);
    v3 = XMVectorNegate(v3);
    v4 = XMVectorNegate(v4);

    Matrix R;
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&R._11), v1);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&R._21), v2);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&R._31), v3);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&R._41), v4);
    return R;
}

//------------------------------------------------------------------------------
// Binary operators
//------------------------------------------------------------------------------

inline Matrix operator+ (const Matrix& M1, const Matrix& M2) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M1._11));
    XMVECTOR x2 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M1._21));
    XMVECTOR x3 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M1._31));
    XMVECTOR x4 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M1._41));

    XMVECTOR y1 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M2._11));
    XMVECTOR y2 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M2._21));
    XMVECTOR y3 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M2._31));
    XMVECTOR y4 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M2._41));

    x1 = XMVectorAdd(x1, y1);
    x2 = XMVectorAdd(x2, y2);
    x3 = XMVectorAdd(x3, y3);
    x4 = XMVectorAdd(x4, y4);

    Matrix R;
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&R._11), x1);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&R._21), x2);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&R._31), x3);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&R._41), x4);
    return R;
}

inline Matrix operator- (const Matrix& M1, const Matrix& M2) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M1._11));
    XMVECTOR x2 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M1._21));
    XMVECTOR x3 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M1._31));
    XMVECTOR x4 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M1._41));

    XMVECTOR y1 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M2._11));
    XMVECTOR y2 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M2._21));
    XMVECTOR y3 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M2._31));
    XMVECTOR y4 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M2._41));

    x1 = XMVectorSubtract(x1, y1);
    x2 = XMVectorSubtract(x2, y2);
    x3 = XMVectorSubtract(x3, y3);
    x4 = XMVectorSubtract(x4, y4);

    Matrix R;
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&R._11), x1);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&R._21), x2);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&R._31), x3);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&R._41), x4);
    return R;
}

inline Matrix operator* (const Matrix& M1, const Matrix& M2) noexcept
{
    using namespace DirectX;
    XMMATRIX m1 = XMLoadFloat4x4(&M1);
    XMMATRIX m2 = XMLoadFloat4x4(&M2);
    XMMATRIX X = XMMatrixMultiply(m1, m2);

    Matrix R;
    XMStoreFloat4x4(&R, X);
    return R;
}

inline Matrix operator* (const Matrix& M, float S) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._11));
    XMVECTOR x2 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._21));
    XMVECTOR x3 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._31));
    XMVECTOR x4 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._41));

    x1 = XMVectorScale(x1, S);
    x2 = XMVectorScale(x2, S);
    x3 = XMVectorScale(x3, S);
    x4 = XMVectorScale(x4, S);

    Matrix R;
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&R._11), x1);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&R._21), x2);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&R._31), x3);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&R._41), x4);
    return R;
}

inline Matrix operator/ (const Matrix& M, float S) noexcept
{
    using namespace DirectX;
    assert(S != 0.f);

    XMVECTOR x1 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._11));
    XMVECTOR x2 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._21));
    XMVECTOR x3 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._31));
    XMVECTOR x4 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._41));

    float rs = 1.f / S;

    x1 = XMVectorScale(x1, rs);
    x2 = XMVectorScale(x2, rs);
    x3 = XMVectorScale(x3, rs);
    x4 = XMVectorScale(x4, rs);

    Matrix R;
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&R._11), x1);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&R._21), x2);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&R._31), x3);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&R._41), x4);
    return R;
}

inline Matrix operator/ (const Matrix& M1, const Matrix& M2) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M1._11));
    XMVECTOR x2 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M1._21));
    XMVECTOR x3 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M1._31));
    XMVECTOR x4 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M1._41));

    XMVECTOR y1 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M2._11));
    XMVECTOR y2 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M2._21));
    XMVECTOR y3 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M2._31));
    XMVECTOR y4 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M2._41));

    x1 = XMVectorDivide(x1, y1);
    x2 = XMVectorDivide(x2, y2);
    x3 = XMVectorDivide(x3, y3);
    x4 = XMVectorDivide(x4, y4);

    Matrix R;
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&R._11), x1);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&R._21), x2);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&R._31), x3);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&R._41), x4);
    return R;
}

inline Matrix operator* (float S, const Matrix& M) noexcept
{
    using namespace DirectX;

    XMVECTOR x1 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._11));
    XMVECTOR x2 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._21));
    XMVECTOR x3 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._31));
    XMVECTOR x4 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M._41));

    x1 = XMVectorScale(x1, S);
    x2 = XMVectorScale(x2, S);
    x3 = XMVectorScale(x3, S);
    x4 = XMVectorScale(x4, S);

    Matrix R;
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&R._11), x1);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&R._21), x2);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&R._31), x3);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&R._41), x4);
    return R;
}

//------------------------------------------------------------------------------
// Matrix operations
//------------------------------------------------------------------------------

inline bool Matrix::Decompose(Vector3& scale, Quaternion& rotation, Vector3& translation) noexcept
{
    using namespace DirectX;

    XMVECTOR s, r, t;

    if (!XMMatrixDecompose(&s, &r, &t, *this))
        return false;

    XMStoreFloat3(&scale, s);
    XMStoreFloat4(&rotation, r);
    XMStoreFloat3(&translation, t);

    return true;
}

inline Matrix Matrix::Transpose() const noexcept
{
    using namespace DirectX;
    XMMATRIX M = XMLoadFloat4x4(this);
    Matrix R;
    XMStoreFloat4x4(&R, XMMatrixTranspose(M));
    return R;
}

inline void Matrix::Transpose(Matrix& result) const noexcept
{
    using namespace DirectX;
    XMMATRIX M = XMLoadFloat4x4(this);
    XMStoreFloat4x4(&result, XMMatrixTranspose(M));
}

inline Matrix Matrix::Invert() const noexcept
{
    using namespace DirectX;
    XMMATRIX M = XMLoadFloat4x4(this);
    Matrix R;
    XMVECTOR det;
    XMStoreFloat4x4(&R, XMMatrixInverse(&det, M));
    return R;
}

inline void Matrix::Invert(Matrix& result) const noexcept
{
    using namespace DirectX;
    XMMATRIX M = XMLoadFloat4x4(this);
    XMVECTOR det;
    XMStoreFloat4x4(&result, XMMatrixInverse(&det, M));
}

inline float Matrix::Determinant() const noexcept
{
    using namespace DirectX;
    XMMATRIX M = XMLoadFloat4x4(this);
    return XMVectorGetX(XMMatrixDeterminant(M));
}

//------------------------------------------------------------------------------
// Static functions
//------------------------------------------------------------------------------

_Use_decl_annotations_
inline Matrix Matrix::CreateBillboard(
    const Vector3& object,
    const Vector3& cameraPosition,
    const Vector3& cameraUp,
    const Vector3* cameraForward) noexcept
{
    using namespace DirectX;
    XMVECTOR O = XMLoadFloat3(&object);
    XMVECTOR C = XMLoadFloat3(&cameraPosition);
    XMVECTOR Z = XMVectorSubtract(O, C);

    XMVECTOR N = XMVector3LengthSq(Z);
    if (XMVector3Less(N, g_XMEpsilon))
    {
        if (cameraForward)
        {
            XMVECTOR F = XMLoadFloat3(cameraForward);
            Z = XMVectorNegate(F);
        }
        else
            Z = g_XMNegIdentityR2;
    }
    else
    {
        Z = XMVector3Normalize(Z);
    }

    XMVECTOR up = XMLoadFloat3(&cameraUp);
    XMVECTOR X = XMVector3Cross(up, Z);
    X = XMVector3Normalize(X);

    XMVECTOR Y = XMVector3Cross(Z, X);

    XMMATRIX M;
    M.r[0] = X;
    M.r[1] = Y;
    M.r[2] = Z;
    M.r[3] = XMVectorSetW(O, 1.f);

    Matrix R;
    XMStoreFloat4x4(&R, M);
    return R;
}

_Use_decl_annotations_
inline Matrix Matrix::CreateConstrainedBillboard(
    const Vector3& object,
    const Vector3& cameraPosition,
    const Vector3& rotateAxis,
    const Vector3* cameraForward,
    const Vector3* objectForward) noexcept
{
    using namespace DirectX;

    static const XMVECTORF32 s_minAngle = { { { 0.99825467075f, 0.99825467075f, 0.99825467075f, 0.99825467075f } } }; // 1.0 - XMConvertToRadians( 0.1f );

    XMVECTOR O = XMLoadFloat3(&object);
    XMVECTOR C = XMLoadFloat3(&cameraPosition);
    XMVECTOR faceDir = XMVectorSubtract(O, C);

    XMVECTOR N = XMVector3LengthSq(faceDir);
    if (XMVector3Less(N, g_XMEpsilon))
    {
        if (cameraForward)
        {
            XMVECTOR F = XMLoadFloat3(cameraForward);
            faceDir = XMVectorNegate(F);
        }
        else
            faceDir = g_XMNegIdentityR2;
    }
    else
    {
        faceDir = XMVector3Normalize(faceDir);
    }

    XMVECTOR Y = XMLoadFloat3(&rotateAxis);
    XMVECTOR X, Z;

    XMVECTOR dot = XMVectorAbs(XMVector3Dot(Y, faceDir));
    if (XMVector3Greater(dot, s_minAngle))
    {
        if (objectForward)
        {
            Z = XMLoadFloat3(objectForward);
            dot = XMVectorAbs(XMVector3Dot(Y, Z));
            if (XMVector3Greater(dot, s_minAngle))
            {
                dot = XMVectorAbs(XMVector3Dot(Y, g_XMNegIdentityR2));
                Z = (XMVector3Greater(dot, s_minAngle)) ? g_XMIdentityR0 : g_XMNegIdentityR2;
            }
        }
        else
        {
            dot = XMVectorAbs(XMVector3Dot(Y, g_XMNegIdentityR2));
            Z = (XMVector3Greater(dot, s_minAngle)) ? g_XMIdentityR0 : g_XMNegIdentityR2;
        }

        X = XMVector3Cross(Y, Z);
        X = XMVector3Normalize(X);

        Z = XMVector3Cross(X, Y);
        Z = XMVector3Normalize(Z);
    }
    else
    {
        X = XMVector3Cross(Y, faceDir);
        X = XMVector3Normalize(X);

        Z = XMVector3Cross(X, Y);
        Z = XMVector3Normalize(Z);
    }

    XMMATRIX M;
    M.r[0] = X;
    M.r[1] = Y;
    M.r[2] = Z;
    M.r[3] = XMVectorSetW(O, 1.f);

    Matrix R;
    XMStoreFloat4x4(&R, M);
    return R;
}

inline Matrix Matrix::CreateTranslation(const Vector3& position) noexcept
{
    using namespace DirectX;
    Matrix R;
    XMStoreFloat4x4(&R, XMMatrixTranslation(position.x, position.y, position.z));
    return R;
}

inline Matrix Matrix::CreateTranslation(float x, float y, float z) noexcept
{
    using namespace DirectX;
    Matrix R;
    XMStoreFloat4x4(&R, XMMatrixTranslation(x, y, z));
    return R;
}

inline Matrix Matrix::CreateScale(const Vector3& scales) noexcept
{
    using namespace DirectX;
    Matrix R;
    XMStoreFloat4x4(&R, XMMatrixScaling(scales.x, scales.y, scales.z));
    return R;
}

inline Matrix Matrix::CreateScale(float xs, float ys, float zs) noexcept
{
    using namespace DirectX;
    Matrix R;
    XMStoreFloat4x4(&R, XMMatrixScaling(xs, ys, zs));
    return R;
}

inline Matrix Matrix::CreateScale(float scale) noexcept
{
    using namespace DirectX;
    Matrix R;
    XMStoreFloat4x4(&R, XMMatrixScaling(scale, scale, scale));
    return R;
}

inline Matrix Matrix::CreateRotationX(float radians) noexcept
{
    using namespace DirectX;
    Matrix R;
    XMStoreFloat4x4(&R, XMMatrixRotationX(radians));
    return R;
}

inline Matrix Matrix::CreateRotationY(float radians) noexcept
{
    using namespace DirectX;
    Matrix R;
    XMStoreFloat4x4(&R, XMMatrixRotationY(radians));
    return R;
}

inline Matrix Matrix::CreateRotationZ(float radians) noexcept
{
    using namespace DirectX;
    Matrix R;
    XMStoreFloat4x4(&R, XMMatrixRotationZ(radians));
    return R;
}

inline Matrix Matrix::CreateFromAxisAngle(const Vector3& axis, float angle) noexcept
{
    using namespace DirectX;
    Matrix R;
    XMVECTOR a = XMLoadFloat3(&axis);
    XMStoreFloat4x4(&R, XMMatrixRotationAxis(a, angle));
    return R;
}

inline Matrix Matrix::CreatePerspectiveFieldOfView(float fov, float aspectRatio, float nearPlane, float farPlane) noexcept
{
    using namespace DirectX;
    Matrix R;
    XMStoreFloat4x4(&R, XMMatrixPerspectiveFovRH(fov, aspectRatio, nearPlane, farPlane));
    return R;
}

inline Matrix Matrix::CreatePerspective(float width, float height, float nearPlane, float farPlane) noexcept
{
    using namespace DirectX;
    Matrix R;
    XMStoreFloat4x4(&R, XMMatrixPerspectiveRH(width, height, nearPlane, farPlane));
    return R;
}

inline Matrix Matrix::CreatePerspectiveOffCenter(float left, float right, float bottom, float top, float nearPlane, float farPlane) noexcept
{
    using namespace DirectX;
    Matrix R;
    XMStoreFloat4x4(&R, XMMatrixPerspectiveOffCenterRH(left, right, bottom, top, nearPlane, farPlane));
    return R;
}

inline Matrix Matrix::CreateOrthographic(float width, float height, float zNearPlane, float zFarPlane) noexcept
{
    using namespace DirectX;
    Matrix R;
    XMStoreFloat4x4(&R, XMMatrixOrthographicRH(width, height, zNearPlane, zFarPlane));
    return R;
}

inline Matrix Matrix::CreateOrthographicOffCenter(float left, float right, float bottom, float top, float zNearPlane, float zFarPlane) noexcept
{
    using namespace DirectX;
    Matrix R;
    XMStoreFloat4x4(&R, XMMatrixOrthographicOffCenterRH(left, right, bottom, top, zNearPlane, zFarPlane));
    return R;
}

inline Matrix Matrix::CreateLookAt(const Vector3& eye, const Vector3& target, const Vector3& up) noexcept
{
    using namespace DirectX;
    Matrix R;
    XMVECTOR eyev = XMLoadFloat3(&eye);
    XMVECTOR targetv = XMLoadFloat3(&target);
    XMVECTOR upv = XMLoadFloat3(&up);
    XMStoreFloat4x4(&R, XMMatrixLookAtRH(eyev, targetv, upv));
    return R;
}

inline Matrix Matrix::CreateWorld(const Vector3& position, const Vector3& forward, const Vector3& up) noexcept
{
    using namespace DirectX;
    XMVECTOR zaxis = XMVector3Normalize(XMVectorNegate(XMLoadFloat3(&forward)));
    XMVECTOR yaxis = XMLoadFloat3(&up);
    XMVECTOR xaxis = XMVector3Normalize(XMVector3Cross(yaxis, zaxis));
    yaxis = XMVector3Cross(zaxis, xaxis);

    Matrix R;
    XMStoreFloat3(reinterpret_cast<XMFLOAT3*>(&R._11), xaxis);
    XMStoreFloat3(reinterpret_cast<XMFLOAT3*>(&R._21), yaxis);
    XMStoreFloat3(reinterpret_cast<XMFLOAT3*>(&R._31), zaxis);
    R._14 = R._24 = R._34 = 0.f;
    R._41 = position.x; R._42 = position.y; R._43 = position.z;
    R._44 = 1.f;
    return R;
}

inline Matrix Matrix::CreateFromQuaternion(const Quaternion& rotation) noexcept
{
    using namespace DirectX;
    Matrix R;
    XMVECTOR quatv = XMLoadFloat4(&rotation);
    XMStoreFloat4x4(&R, XMMatrixRotationQuaternion(quatv));
    return R;
}

inline Matrix Matrix::CreateFromYawPitchRoll(float yaw, float pitch, float roll) noexcept
{
    using namespace DirectX;
    Matrix R;
    XMStoreFloat4x4(&R, XMMatrixRotationRollPitchYaw(pitch, yaw, roll));
    return R;
}

inline Matrix Matrix::CreateShadow(const Vector3& lightDir, const Plane& plane) noexcept
{
    using namespace DirectX;
    Matrix R;
    XMVECTOR light = XMLoadFloat3(&lightDir);
    XMVECTOR planev = XMLoadFloat4(&plane);
    XMStoreFloat4x4(&R, XMMatrixShadow(planev, light));
    return R;
}

inline Matrix Matrix::CreateReflection(const Plane& plane) noexcept
{
    using namespace DirectX;
    Matrix R;
    XMVECTOR planev = XMLoadFloat4(&plane);
    XMStoreFloat4x4(&R, XMMatrixReflect(planev));
    return R;
}

inline void Matrix::Lerp(const Matrix& M1, const Matrix& M2, float t, Matrix& result) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M1._11));
    XMVECTOR x2 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M1._21));
    XMVECTOR x3 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M1._31));
    XMVECTOR x4 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M1._41));

    XMVECTOR y1 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M2._11));
    XMVECTOR y2 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M2._21));
    XMVECTOR y3 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M2._31));
    XMVECTOR y4 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M2._41));

    x1 = XMVectorLerp(x1, y1, t);
    x2 = XMVectorLerp(x2, y2, t);
    x3 = XMVectorLerp(x3, y3, t);
    x4 = XMVectorLerp(x4, y4, t);

    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&result._11), x1);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&result._21), x2);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&result._31), x3);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&result._41), x4);
}

inline Matrix Matrix::Lerp(const Matrix& M1, const Matrix& M2, float t) noexcept
{
    using namespace DirectX;
    XMVECTOR x1 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M1._11));
    XMVECTOR x2 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M1._21));
    XMVECTOR x3 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M1._31));
    XMVECTOR x4 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M1._41));

    XMVECTOR y1 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M2._11));
    XMVECTOR y2 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M2._21));
    XMVECTOR y3 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M2._31));
    XMVECTOR y4 = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(&M2._41));

    x1 = XMVectorLerp(x1, y1, t);
    x2 = XMVectorLerp(x2, y2, t);
    x3 = XMVectorLerp(x3, y3, t);
    x4 = XMVectorLerp(x4, y4, t);

    Matrix result;
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&result._11), x1);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&result._21), x2);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&result._31), x3);
    XMStoreFloat4(reinterpret_cast<XMFLOAT4*>(&result._41), x4);
    return result;
}

inline void Matrix::Transform(const Matrix& M, const Quaternion& rotation, Matrix& result) noexcept
{
    using namespace DirectX;
    XMVECTOR quatv = XMLoadFloat4(&rotation);

    XMMATRIX M0 = XMLoadFloat4x4(&M);
    XMMATRIX M1 = XMMatrixRotationQuaternion(quatv);

    XMStoreFloat4x4(&result, XMMatrixMultiply(M0, M1));
}

inline Matrix Matrix::Transform(const Matrix& M, const Quaternion& rotation) noexcept
{
    using namespace DirectX;
    XMVECTOR quatv = XMLoadFloat4(&rotation);

    XMMATRIX M0 = XMLoadFloat4x4(&M);
    XMMATRIX M1 = XMMatrixRotationQuaternion(quatv);

    Matrix result;
    XMStoreFloat4x4(&result, XMMatrixMultiply(M0, M1));
    return result;
}


/****************************************************************************
 *
 * Plane
 *
 ****************************************************************************/

inline Plane::Plane(const Vector3& point1, const Vector3& point2, const Vector3& point3) noexcept
{
    using namespace DirectX;
    XMVECTOR P0 = XMLoadFloat3(&point1);
    XMVECTOR P1 = XMLoadFloat3(&point2);
    XMVECTOR P2 = XMLoadFloat3(&point3);
    XMStoreFloat4(this, XMPlaneFromPoints(P0, P1, P2));
}

inline Plane::Plane(const Vector3& point, const Vector3& normal) noexcept
{
    using namespace DirectX;
    XMVECTOR P = XMLoadFloat3(&point);
    XMVECTOR N = XMLoadFloat3(&normal);
    XMStoreFloat4(this, XMPlaneFromPointNormal(P, N));
}

//------------------------------------------------------------------------------
// Comparision operators
//------------------------------------------------------------------------------

inline bool Plane::operator == (const Plane& p) const noexcept
{
    using namespace DirectX;
    XMVECTOR p1 = XMLoadFloat4(this);
    XMVECTOR p2 = XMLoadFloat4(&p);
    return XMPlaneEqual(p1, p2);
}

inline bool Plane::operator != (const Plane& p) const noexcept
{
    using namespace DirectX;
    XMVECTOR p1 = XMLoadFloat4(this);
    XMVECTOR p2 = XMLoadFloat4(&p);
    return XMPlaneNotEqual(p1, p2);
}

//------------------------------------------------------------------------------
// Plane operations
//------------------------------------------------------------------------------

inline void Plane::Normalize() noexcept
{
    using namespace DirectX;
    XMVECTOR p = XMLoadFloat4(this);
    XMStoreFloat4(this, XMPlaneNormalize(p));
}

inline void Plane::Normalize(Plane& result) const noexcept
{
    using namespace DirectX;
    XMVECTOR p = XMLoadFloat4(this);
    XMStoreFloat4(&result, XMPlaneNormalize(p));
}

inline float Plane::Dot(const Vector4& v) const noexcept
{
    using namespace DirectX;
    XMVECTOR p = XMLoadFloat4(this);
    XMVECTOR v0 = XMLoadFloat4(&v);
    return XMVectorGetX(XMPlaneDot(p, v0));
}

inline float Plane::DotCoordinate(const Vector3& position) const noexcept
{
    using namespace DirectX;
    XMVECTOR p = XMLoadFloat4(this);
    XMVECTOR v0 = XMLoadFloat3(&position);
    return XMVectorGetX(XMPlaneDotCoord(p, v0));
}

inline float Plane::DotNormal(const Vector3& normal) const noexcept
{
    using namespace DirectX;
    XMVECTOR p = XMLoadFloat4(this);
    XMVECTOR n0 = XMLoadFloat3(&normal);
    return XMVectorGetX(XMPlaneDotNormal(p, n0));
}

//------------------------------------------------------------------------------
// Static functions
//------------------------------------------------------------------------------

inline void Plane::Transform(const Plane& plane, const Matrix& M, Plane& result) noexcept
{
    using namespace DirectX;
    XMVECTOR p = XMLoadFloat4(&plane);
    XMMATRIX m0 = XMLoadFloat4x4(&M);
    XMStoreFloat4(&result, XMPlaneTransform(p, m0));
}

inline Plane Plane::Transform(const Plane& plane, const Matrix& M) noexcept
{
    using namespace DirectX;
    XMVECTOR p = XMLoadFloat4(&plane);
    XMMATRIX m0 = XMLoadFloat4x4(&M);

    Plane result;
    XMStoreFloat4(&result, XMPlaneTransform(p, m0));
    return result;
}

inline void Plane::Transform(const Plane& plane, const Quaternion& rotation, Plane& result) noexcept
{
    using namespace DirectX;
    XMVECTOR p = XMLoadFloat4(&plane);
    XMVECTOR q = XMLoadFloat4(&rotation);
    XMVECTOR X = XMVector3Rotate(p, q);
    X = XMVectorSelect(p, X, g_XMSelect1110); // result.d = plane.d
    XMStoreFloat4(&result, X);
}

inline Plane Plane::Transform(const Plane& plane, const Quaternion& rotation) noexcept
{
    using namespace DirectX;
    XMVECTOR p = XMLoadFloat4(&plane);
    XMVECTOR q = XMLoadFloat4(&rotation);
    XMVECTOR X = XMVector3Rotate(p, q);
    X = XMVectorSelect(p, X, g_XMSelect1110); // result.d = plane.d

    Plane result;
    XMStoreFloat4(&result, X);
    return result;
}


/****************************************************************************
 *
 * Quaternion
 *
 ****************************************************************************/

//------------------------------------------------------------------------------
// Comparision operators
//------------------------------------------------------------------------------

inline bool Quaternion::operator == (const Quaternion& q) const noexcept
{
    using namespace DirectX;
    XMVECTOR q1 = XMLoadFloat4(this);
    XMVECTOR q2 = XMLoadFloat4(&q);
    return XMQuaternionEqual(q1, q2);
}

inline bool Quaternion::operator != (const Quaternion& q) const noexcept
{
    using namespace DirectX;
    XMVECTOR q1 = XMLoadFloat4(this);
    XMVECTOR q2 = XMLoadFloat4(&q);
    return XMQuaternionNotEqual(q1, q2);
}

//------------------------------------------------------------------------------
// Assignment operators
//------------------------------------------------------------------------------

inline Quaternion& Quaternion::operator+= (const Quaternion& q) noexcept
{
    using namespace DirectX;
    XMVECTOR q1 = XMLoadFloat4(this);
    XMVECTOR q2 = XMLoadFloat4(&q);
    XMStoreFloat4(this, XMVectorAdd(q1, q2));
    return *this;
}

inline Quaternion& Quaternion::operator-= (const Quaternion& q) noexcept
{
    using namespace DirectX;
    XMVECTOR q1 = XMLoadFloat4(this);
    XMVECTOR q2 = XMLoadFloat4(&q);
    XMStoreFloat4(this, XMVectorSubtract(q1, q2));
    return *this;
}

inline Quaternion& Quaternion::operator*= (const Quaternion& q) noexcept
{
    using namespace DirectX;
    XMVECTOR q1 = XMLoadFloat4(this);
    XMVECTOR q2 = XMLoadFloat4(&q);
    XMStoreFloat4(this, XMQuaternionMultiply(q1, q2));
    return *this;
}

inline Quaternion& Quaternion::operator*= (float S) noexcept
{
    using namespace DirectX;
    XMVECTOR q = XMLoadFloat4(this);
    XMStoreFloat4(this, XMVectorScale(q, S));
    return *this;
}

inline Quaternion& Quaternion::operator/= (const Quaternion& q) noexcept
{
    using namespace DirectX;
    XMVECTOR q1 = XMLoadFloat4(this);
    XMVECTOR q2 = XMLoadFloat4(&q);
    q2 = XMQuaternionInverse(q2);
    XMStoreFloat4(this, XMQuaternionMultiply(q1, q2));
    return *this;
}

//------------------------------------------------------------------------------
// Urnary operators
//------------------------------------------------------------------------------

inline Quaternion Quaternion::operator- () const noexcept
{
    using namespace DirectX;
    XMVECTOR q = XMLoadFloat4(this);

    Quaternion R;
    XMStoreFloat4(&R, XMVectorNegate(q));
    return R;
}

//------------------------------------------------------------------------------
// Binary operators
//------------------------------------------------------------------------------

inline Quaternion operator+ (const Quaternion& Q1, const Quaternion& Q2) noexcept
{
    using namespace DirectX;
    XMVECTOR q1 = XMLoadFloat4(&Q1);
    XMVECTOR q2 = XMLoadFloat4(&Q2);

    Quaternion R;
    XMStoreFloat4(&R, XMVectorAdd(q1, q2));
    return R;
}

inline Quaternion operator- (const Quaternion& Q1, const Quaternion& Q2) noexcept
{
    using namespace DirectX;
    XMVECTOR q1 = XMLoadFloat4(&Q1);
    XMVECTOR q2 = XMLoadFloat4(&Q2);

    Quaternion R;
    XMStoreFloat4(&R, XMVectorSubtract(q1, q2));
    return R;
}

inline Quaternion operator* (const Quaternion& Q1, const Quaternion& Q2) noexcept
{
    using namespace DirectX;
    XMVECTOR q1 = XMLoadFloat4(&Q1);
    XMVECTOR q2 = XMLoadFloat4(&Q2);

    Quaternion R;
    XMStoreFloat4(&R, XMQuaternionMultiply(q1, q2));
    return R;
}

inline Quaternion operator* (const Quaternion& Q, float S) noexcept
{
    using namespace DirectX;
    XMVECTOR q = XMLoadFloat4(&Q);

    Quaternion R;
    XMStoreFloat4(&R, XMVectorScale(q, S));
    return R;
}

inline Quaternion operator/ (const Quaternion& Q1, const Quaternion& Q2) noexcept
{
    using namespace DirectX;
    XMVECTOR q1 = XMLoadFloat4(&Q1);
    XMVECTOR q2 = XMLoadFloat4(&Q2);
    q2 = XMQuaternionInverse(q2);

    Quaternion R;
    XMStoreFloat4(&R, XMQuaternionMultiply(q1, q2));
    return R;
}

inline Quaternion operator* (float S, const Quaternion& Q) noexcept
{
    using namespace DirectX;
    XMVECTOR q1 = XMLoadFloat4(&Q);

    Quaternion R;
    XMStoreFloat4(&R, XMVectorScale(q1, S));
    return R;
}

//------------------------------------------------------------------------------
// Quaternion operations
//------------------------------------------------------------------------------

inline float Quaternion::Length() const noexcept
{
    using namespace DirectX;
    XMVECTOR q = XMLoadFloat4(this);
    return XMVectorGetX(XMQuaternionLength(q));
}

inline float Quaternion::LengthSquared() const noexcept
{
    using namespace DirectX;
    XMVECTOR q = XMLoadFloat4(this);
    return XMVectorGetX(XMQuaternionLengthSq(q));
}

inline void Quaternion::Normalize() noexcept
{
    using namespace DirectX;
    XMVECTOR q = XMLoadFloat4(this);
    XMStoreFloat4(this, XMQuaternionNormalize(q));
}

inline void Quaternion::Normalize(Quaternion& result) const noexcept
{
    using namespace DirectX;
    XMVECTOR q = XMLoadFloat4(this);
    XMStoreFloat4(&result, XMQuaternionNormalize(q));
}

inline void Quaternion::Conjugate() noexcept
{
    using namespace DirectX;
    XMVECTOR q = XMLoadFloat4(this);
    XMStoreFloat4(this, XMQuaternionConjugate(q));
}

inline void Quaternion::Conjugate(Quaternion& result) const noexcept
{
    using namespace DirectX;
    XMVECTOR q = XMLoadFloat4(this);
    XMStoreFloat4(&result, XMQuaternionConjugate(q));
}

inline void Quaternion::Inverse(Quaternion& result) const noexcept
{
    using namespace DirectX;
    XMVECTOR q = XMLoadFloat4(this);
    XMStoreFloat4(&result, XMQuaternionInverse(q));
}

inline float Quaternion::Dot(const Quaternion& q) const noexcept
{
    using namespace DirectX;
    XMVECTOR q1 = XMLoadFloat4(this);
    XMVECTOR q2 = XMLoadFloat4(&q);
    return XMVectorGetX(XMQuaternionDot(q1, q2));
}

//------------------------------------------------------------------------------
// Static functions
//------------------------------------------------------------------------------

inline Quaternion Quaternion::CreateFromAxisAngle(const Vector3& axis, float angle) noexcept
{
    using namespace DirectX;
    XMVECTOR a = XMLoadFloat3(&axis);

    Quaternion R;
    XMStoreFloat4(&R, XMQuaternionRotationAxis(a, angle));
    return R;
}

inline Quaternion Quaternion::CreateFromYawPitchRoll(float yaw, float pitch, float roll) noexcept
{
    using namespace DirectX;
    Quaternion R;
    XMStoreFloat4(&R, XMQuaternionRotationRollPitchYaw(pitch, yaw, roll));
    return R;
}

inline Quaternion Quaternion::CreateFromRotationMatrix(const Matrix& M) noexcept
{
    using namespace DirectX;
    XMMATRIX M0 = XMLoadFloat4x4(&M);

    Quaternion R;
    XMStoreFloat4(&R, XMQuaternionRotationMatrix(M0));
    return R;
}

inline void Quaternion::Lerp(const Quaternion& q1, const Quaternion& q2, float t, Quaternion& result) noexcept
{
    using namespace DirectX;
    XMVECTOR Q0 = XMLoadFloat4(&q1);
    XMVECTOR Q1 = XMLoadFloat4(&q2);

    XMVECTOR dot = XMVector4Dot(Q0, Q1);

    XMVECTOR R;
    if (XMVector4GreaterOrEqual(dot, XMVectorZero()))
    {
        R = XMVectorLerp(Q0, Q1, t);
    }
    else
    {
        XMVECTOR tv = XMVectorReplicate(t);
        XMVECTOR t1v = XMVectorReplicate(1.f - t);
        XMVECTOR X0 = XMVectorMultiply(Q0, t1v);
        XMVECTOR X1 = XMVectorMultiply(Q1, tv);
        R = XMVectorSubtract(X0, X1);
    }

    XMStoreFloat4(&result, XMQuaternionNormalize(R));
}

inline Quaternion Quaternion::Lerp(const Quaternion& q1, const Quaternion& q2, float t) noexcept
{
    using namespace DirectX;
    XMVECTOR Q0 = XMLoadFloat4(&q1);
    XMVECTOR Q1 = XMLoadFloat4(&q2);

    XMVECTOR dot = XMVector4Dot(Q0, Q1);

    XMVECTOR R;
    if (XMVector4GreaterOrEqual(dot, XMVectorZero()))
    {
        R = XMVectorLerp(Q0, Q1, t);
    }
    else
    {
        XMVECTOR tv = XMVectorReplicate(t);
        XMVECTOR t1v = XMVectorReplicate(1.f - t);
        XMVECTOR X0 = XMVectorMultiply(Q0, t1v);
        XMVECTOR X1 = XMVectorMultiply(Q1, tv);
        R = XMVectorSubtract(X0, X1);
    }

    Quaternion result;
    XMStoreFloat4(&result, XMQuaternionNormalize(R));
    return result;
}

inline void Quaternion::Slerp(const Quaternion& q1, const Quaternion& q2, float t, Quaternion& result) noexcept
{
    using namespace DirectX;
    XMVECTOR Q0 = XMLoadFloat4(&q1);
    XMVECTOR Q1 = XMLoadFloat4(&q2);
    XMStoreFloat4(&result, XMQuaternionSlerp(Q0, Q1, t));
}

inline Quaternion Quaternion::Slerp(const Quaternion& q1, const Quaternion& q2, float t) noexcept
{
    using namespace DirectX;
    XMVECTOR Q0 = XMLoadFloat4(&q1);
    XMVECTOR Q1 = XMLoadFloat4(&q2);

    Quaternion result;
    XMStoreFloat4(&result, XMQuaternionSlerp(Q0, Q1, t));
    return result;
}

inline void Quaternion::Concatenate(const Quaternion& q1, const Quaternion& q2, Quaternion& result) noexcept
{
    using namespace DirectX;
    XMVECTOR Q0 = XMLoadFloat4(&q1);
    XMVECTOR Q1 = XMLoadFloat4(&q2);
    XMStoreFloat4(&result, XMQuaternionMultiply(Q1, Q0));
}

inline Quaternion Quaternion::Concatenate(const Quaternion& q1, const Quaternion& q2) noexcept
{
    using namespace DirectX;
    XMVECTOR Q0 = XMLoadFloat4(&q1);
    XMVECTOR Q1 = XMLoadFloat4(&q2);

    Quaternion result;
    XMStoreFloat4(&result, XMQuaternionMultiply(Q1, Q0));
    return result;
}


/****************************************************************************
 *
 * Color
 *
 ****************************************************************************/

inline Color::Color(const DirectX::PackedVector::XMCOLOR& Packed) noexcept
{
    using namespace DirectX;
    XMStoreFloat4(this, PackedVector::XMLoadColor(&Packed));
}

inline Color::Color(const DirectX::PackedVector::XMUBYTEN4& Packed) noexcept
{
    using namespace DirectX;
    XMStoreFloat4(this, PackedVector::XMLoadUByteN4(&Packed));
}

//------------------------------------------------------------------------------
// Comparision operators
//------------------------------------------------------------------------------
inline bool Color::operator == (const Color& c) const noexcept
{
    using namespace DirectX;
    XMVECTOR c1 = XMLoadFloat4(this);
    XMVECTOR c2 = XMLoadFloat4(&c);
    return XMColorEqual(c1, c2);
}

inline bool Color::operator != (const Color& c) const noexcept
{
    using namespace DirectX;
    XMVECTOR c1 = XMLoadFloat4(this);
    XMVECTOR c2 = XMLoadFloat4(&c);
    return XMColorNotEqual(c1, c2);
}

//------------------------------------------------------------------------------
// Assignment operators
//------------------------------------------------------------------------------

inline Color& Color::operator= (const DirectX::PackedVector::XMCOLOR& Packed) noexcept
{
    using namespace DirectX;
    XMStoreFloat4(this, PackedVector::XMLoadColor(&Packed));
    return *this;
}

inline Color& Color::operator= (const DirectX::PackedVector::XMUBYTEN4& Packed) noexcept
{
    using namespace DirectX;
    XMStoreFloat4(this, PackedVector::XMLoadUByteN4(&Packed));
    return *this;
}

inline Color& Color::operator+= (const Color& c) noexcept
{
    using namespace DirectX;
    XMVECTOR c1 = XMLoadFloat4(this);
    XMVECTOR c2 = XMLoadFloat4(&c);
    XMStoreFloat4(this, XMVectorAdd(c1, c2));
    return *this;
}

inline Color& Color::operator-= (const Color& c) noexcept
{
    using namespace DirectX;
    XMVECTOR c1 = XMLoadFloat4(this);
    XMVECTOR c2 = XMLoadFloat4(&c);
    XMStoreFloat4(this, XMVectorSubtract(c1, c2));
    return *this;
}

inline Color& Color::operator*= (const Color& c) noexcept
{
    using namespace DirectX;
    XMVECTOR c1 = XMLoadFloat4(this);
    XMVECTOR c2 = XMLoadFloat4(&c);
    XMStoreFloat4(this, XMVectorMultiply(c1, c2));
    return *this;
}

inline Color& Color::operator*= (float S) noexcept
{
    using namespace DirectX;
    XMVECTOR c = XMLoadFloat4(this);
    XMStoreFloat4(this, XMVectorScale(c, S));
    return *this;
}

inline Color& Color::operator/= (const Color& c) noexcept
{
    using namespace DirectX;
    XMVECTOR c1 = XMLoadFloat4(this);
    XMVECTOR c2 = XMLoadFloat4(&c);
    XMStoreFloat4(this, XMVectorDivide(c1, c2));
    return *this;
}

//------------------------------------------------------------------------------
// Urnary operators
//------------------------------------------------------------------------------

inline Color Color::operator- () const noexcept
{
    using namespace DirectX;
    XMVECTOR c = XMLoadFloat4(this);
    Color R;
    XMStoreFloat4(&R, XMVectorNegate(c));
    return R;
}

//------------------------------------------------------------------------------
// Binary operators
//------------------------------------------------------------------------------

inline Color operator+ (const Color& C1, const Color& C2) noexcept
{
    using namespace DirectX;
    XMVECTOR c1 = XMLoadFloat4(&C1);
    XMVECTOR c2 = XMLoadFloat4(&C2);
    Color R;
    XMStoreFloat4(&R, XMVectorAdd(c1, c2));
    return R;
}

inline Color operator- (const Color& C1, const Color& C2) noexcept
{
    using namespace DirectX;
    XMVECTOR c1 = XMLoadFloat4(&C1);
    XMVECTOR c2 = XMLoadFloat4(&C2);
    Color R;
    XMStoreFloat4(&R, XMVectorSubtract(c1, c2));
    return R;
}

inline Color operator* (const Color& C1, const Color& C2) noexcept
{
    using namespace DirectX;
    XMVECTOR c1 = XMLoadFloat4(&C1);
    XMVECTOR c2 = XMLoadFloat4(&C2);
    Color R;
    XMStoreFloat4(&R, XMVectorMultiply(c1, c2));
    return R;
}

inline Color operator* (const Color& C, float S) noexcept
{
    using namespace DirectX;
    XMVECTOR c = XMLoadFloat4(&C);
    Color R;
    XMStoreFloat4(&R, XMVectorScale(c, S));
    return R;
}

inline Color operator/ (const Color& C1, const Color& C2) noexcept
{
    using namespace DirectX;
    XMVECTOR c1 = XMLoadFloat4(&C1);
    XMVECTOR c2 = XMLoadFloat4(&C2);
    Color R;
    XMStoreFloat4(&R, XMVectorDivide(c1, c2));
    return R;
}

inline Color operator* (float S, const Color& C) noexcept
{
    using namespace DirectX;
    XMVECTOR c1 = XMLoadFloat4(&C);
    Color R;
    XMStoreFloat4(&R, XMVectorScale(c1, S));
    return R;
}

//------------------------------------------------------------------------------
// Color operations
//------------------------------------------------------------------------------

inline DirectX::PackedVector::XMCOLOR Color::BGRA() const noexcept
{
    using namespace DirectX;
    XMVECTOR clr = XMLoadFloat4(this);
    PackedVector::XMCOLOR Packed;
    PackedVector::XMStoreColor(&Packed, clr);
    return Packed;
}

inline DirectX::PackedVector::XMUBYTEN4 Color::RGBA() const noexcept
{
    using namespace DirectX;
    XMVECTOR clr = XMLoadFloat4(this);
    PackedVector::XMUBYTEN4 Packed;
    PackedVector::XMStoreUByteN4(&Packed, clr);
    return Packed;
}

inline Vector3 Color::ToVector3() const noexcept
{
    return Vector3(x, y, z);
}

inline Vector4 Color::ToVector4() const noexcept
{
    return Vector4(x, y, z, w);
}

inline void Color::Negate() noexcept
{
    using namespace DirectX;
    XMVECTOR c = XMLoadFloat4(this);
    XMStoreFloat4(this, XMColorNegative(c));
}

inline void Color::Negate(Color& result) const noexcept
{
    using namespace DirectX;
    XMVECTOR c = XMLoadFloat4(this);
    XMStoreFloat4(&result, XMColorNegative(c));
}

inline void Color::Saturate() noexcept
{
    using namespace DirectX;
    XMVECTOR c = XMLoadFloat4(this);
    XMStoreFloat4(this, XMVectorSaturate(c));
}

inline void Color::Saturate(Color& result) const noexcept
{
    using namespace DirectX;
    XMVECTOR c = XMLoadFloat4(this);
    XMStoreFloat4(&result, XMVectorSaturate(c));
}

inline void Color::Premultiply() noexcept
{
    using namespace DirectX;
    XMVECTOR c = XMLoadFloat4(this);
    XMVECTOR a = XMVectorSplatW(c);
    a = XMVectorSelect(g_XMIdentityR3, a, g_XMSelect1110);
    XMStoreFloat4(this, XMVectorMultiply(c, a));
}

inline void Color::Premultiply(Color& result) const noexcept
{
    using namespace DirectX;
    XMVECTOR c = XMLoadFloat4(this);
    XMVECTOR a = XMVectorSplatW(c);
    a = XMVectorSelect(g_XMIdentityR3, a, g_XMSelect1110);
    XMStoreFloat4(&result, XMVectorMultiply(c, a));
}

inline void Color::AdjustSaturation(float sat) noexcept
{
    using namespace DirectX;
    XMVECTOR c = XMLoadFloat4(this);
    XMStoreFloat4(this, XMColorAdjustSaturation(c, sat));
}

inline void Color::AdjustSaturation(float sat, Color& result) const noexcept
{
    using namespace DirectX;
    XMVECTOR c = XMLoadFloat4(this);
    XMStoreFloat4(&result, XMColorAdjustSaturation(c, sat));
}

inline void Color::AdjustContrast(float contrast) noexcept
{
    using namespace DirectX;
    XMVECTOR c = XMLoadFloat4(this);
    XMStoreFloat4(this, XMColorAdjustContrast(c, contrast));
}

inline void Color::AdjustContrast(float contrast, Color& result) const noexcept
{
    using namespace DirectX;
    XMVECTOR c = XMLoadFloat4(this);
    XMStoreFloat4(&result, XMColorAdjustContrast(c, contrast));
}

//------------------------------------------------------------------------------
// Static functions
//------------------------------------------------------------------------------

inline void Color::Modulate(const Color& c1, const Color& c2, Color& result) noexcept
{
    using namespace DirectX;
    XMVECTOR C0 = XMLoadFloat4(&c1);
    XMVECTOR C1 = XMLoadFloat4(&c2);
    XMStoreFloat4(&result, XMColorModulate(C0, C1));
}

inline Color Color::Modulate(const Color& c1, const Color& c2) noexcept
{
    using namespace DirectX;
    XMVECTOR C0 = XMLoadFloat4(&c1);
    XMVECTOR C1 = XMLoadFloat4(&c2);

    Color result;
    XMStoreFloat4(&result, XMColorModulate(C0, C1));
    return result;
}

inline void Color::Lerp(const Color& c1, const Color& c2, float t, Color& result) noexcept
{
    using namespace DirectX;
    XMVECTOR C0 = XMLoadFloat4(&c1);
    XMVECTOR C1 = XMLoadFloat4(&c2);
    XMStoreFloat4(&result, XMVectorLerp(C0, C1, t));
}

inline Color Color::Lerp(const Color& c1, const Color& c2, float t) noexcept
{
    using namespace DirectX;
    XMVECTOR C0 = XMLoadFloat4(&c1);
    XMVECTOR C1 = XMLoadFloat4(&c2);

    Color result;
    XMStoreFloat4(&result, XMVectorLerp(C0, C1, t));
    return result;
}


/****************************************************************************
 *
 * Ray
 *
 ****************************************************************************/

//-----------------------------------------------------------------------------
// Comparision operators
//------------------------------------------------------------------------------
inline bool Ray::operator == (const Ray& r) const noexcept
{
    using namespace DirectX;
    XMVECTOR r1p = XMLoadFloat3(&position);
    XMVECTOR r2p = XMLoadFloat3(&r.position);
    XMVECTOR r1d = XMLoadFloat3(&direction);
    XMVECTOR r2d = XMLoadFloat3(&r.direction);
    return XMVector3Equal(r1p, r2p) && XMVector3Equal(r1d, r2d);
}

inline bool Ray::operator != (const Ray& r) const noexcept
{
    using namespace DirectX;
    XMVECTOR r1p = XMLoadFloat3(&position);
    XMVECTOR r2p = XMLoadFloat3(&r.position);
    XMVECTOR r1d = XMLoadFloat3(&direction);
    XMVECTOR r2d = XMLoadFloat3(&r.direction);
    return XMVector3NotEqual(r1p, r2p) && XMVector3NotEqual(r1d, r2d);
}

//-----------------------------------------------------------------------------
// Ray operators
//------------------------------------------------------------------------------

inline bool Ray::Intersects(const BoundingSphere& sphere, _Out_ float& Dist) const noexcept
{
    return sphere.Intersects(position, direction, Dist);
}

inline bool Ray::Intersects(const BoundingBox& box, _Out_ float& Dist) const noexcept
{
    return box.Intersects(position, direction, Dist);
}

inline bool Ray::Intersects(const Vector3& tri0, const Vector3& tri1, const Vector3& tri2, _Out_ float& Dist) const noexcept
{
    return DirectX::TriangleTests::Intersects(position, direction, tri0, tri1, tri2, Dist);
}

inline bool Ray::Intersects(const Plane& plane, _Out_ float& Dist) const noexcept
{
    using namespace DirectX;

    XMVECTOR p = XMLoadFloat4(&plane);
    XMVECTOR dir = XMLoadFloat3(&direction);

    XMVECTOR nd = XMPlaneDotNormal(p, dir);

    if (XMVector3LessOrEqual(XMVectorAbs(nd), g_RayEpsilon))
    {
        Dist = 0.f;
        return false;
    }
    else
    {
        // t = -(dot(n,origin) + D) / dot(n,dir)
        XMVECTOR pos = XMLoadFloat3(&position);
        XMVECTOR v = XMPlaneDotNormal(p, pos);
        v = XMVectorAdd(v, XMVectorSplatW(p));
        v = XMVectorDivide(v, nd);
        float dist = -XMVectorGetX(v);
        if (dist < 0)
        {
            Dist = 0.f;
            return false;
        }
        else
        {
            Dist = dist;
            return true;
        }
    }
}


/****************************************************************************
 *
 * Viewport
 *
 ****************************************************************************/

//------------------------------------------------------------------------------
// Comparision operators
//------------------------------------------------------------------------------

inline bool Viewport::operator == (const Viewport& vp) const noexcept
{
    return (x == vp.x && y == vp.y
            && width == vp.width && height == vp.height
            && minDepth == vp.minDepth && maxDepth == vp.maxDepth);
}

inline bool Viewport::operator != (const Viewport& vp) const noexcept
{
    return (x != vp.x || y != vp.y
            || width != vp.width || height != vp.height
            || minDepth != vp.minDepth || maxDepth != vp.maxDepth);
}

//------------------------------------------------------------------------------
// Assignment operators
//------------------------------------------------------------------------------

inline Viewport& Viewport::operator= (const RECT& rct) noexcept
{
    x = float(rct.left); y = float(rct.top);
    width = float(rct.right - rct.left);
    height = float(rct.bottom - rct.top);
    minDepth = 0.f; maxDepth = 1.f;
    return *this;
}

#if defined(__d3d11_h__) || defined(__d3d11_x_h__)
inline Viewport& Viewport::operator= (const D3D11_VIEWPORT& vp) noexcept
{
    x = vp.TopLeftX; y = vp.TopLeftY;
    width = vp.Width; height = vp.Height;
    minDepth = vp.MinDepth; maxDepth = vp.MaxDepth;
    return *this;
}
#endif

#if defined(__d3d12_h__) || defined(__d3d12_x_h__) || defined(__XBOX_D3D12_X__)
inline Viewport& Viewport::operator= (const D3D12_VIEWPORT& vp) noexcept
{
    x = vp.TopLeftX; y = vp.TopLeftY;
    width = vp.Width; height = vp.Height;
    minDepth = vp.MinDepth; maxDepth = vp.MaxDepth;
    return *this;
}
#endif

//------------------------------------------------------------------------------
// Viewport operations
//------------------------------------------------------------------------------

inline float Viewport::AspectRatio() const noexcept
{
    if (width == 0.f || height == 0.f)
        return 0.f;

    return (width / height);
}

inline Vector3 Viewport::Project(const Vector3& p, const Matrix& proj, const Matrix& view, const Matrix& world) const noexcept
{
    using namespace DirectX;
    XMVECTOR v = XMLoadFloat3(&p);
    XMMATRIX projection = XMLoadFloat4x4(&proj);
    v = XMVector3Project(v, x, y, width, height, minDepth, maxDepth, projection, view, world);
    Vector3 result;
    XMStoreFloat3(&result, v);
    return result;
}

inline void Viewport::Project(const Vector3& p, const Matrix& proj, const Matrix& view, const Matrix& world, Vector3& result) const noexcept
{
    using namespace DirectX;
    XMVECTOR v = XMLoadFloat3(&p);
    XMMATRIX projection = XMLoadFloat4x4(&proj);
    v = XMVector3Project(v, x, y, width, height, minDepth, maxDepth, projection, view, world);
    XMStoreFloat3(&result, v);
}

inline Vector3 Viewport::Unproject(const Vector3& p, const Matrix& proj, const Matrix& view, const Matrix& world) const noexcept
{
    using namespace DirectX;
    XMVECTOR v = XMLoadFloat3(&p);
    XMMATRIX projection = XMLoadFloat4x4(&proj);
    v = XMVector3Unproject(v, x, y, width, height, minDepth, maxDepth, projection, view, world);
    Vector3 result;
    XMStoreFloat3(&result, v);
    return result;
}

inline void Viewport::Unproject(const Vector3& p, const Matrix& proj, const Matrix& view, const Matrix& world, Vector3& result) const noexcept
{
    using namespace DirectX;
    XMVECTOR v = XMLoadFloat3(&p);
    XMMATRIX projection = XMLoadFloat4x4(&proj);
    v = XMVector3Unproject(v, x, y, width, height, minDepth, maxDepth, projection, view, world);
    XMStoreFloat3(&result, v);
}

```

`include/vendor/minhook.hpp`:

```hpp
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#if !(defined _M_IX86) && !(defined _M_X64) && !(defined __i386__) && !(defined __x86_64__)
#error MinHook supports only x86 and x64 systems.
#endif

#include <windows.h>

 // MinHook Error Codes.
typedef enum MH_STATUS
{
	// Unknown error. Should not be returned.
	MH_UNKNOWN = -1,

	// Successful.
	MH_OK = 0,

	// MinHook is already initialized.
	MH_ERROR_ALREADY_INITIALIZED,

	// MinHook is not initialized yet, or already uninitialized.
	MH_ERROR_NOT_INITIALIZED,

	// The hook for the specified target function is already created.
	MH_ERROR_ALREADY_CREATED,

	// The hook for the specified target function is not created yet.
	MH_ERROR_NOT_CREATED,

	// The hook for the specified target function is already enabled.
	MH_ERROR_ENABLED,

	// The hook for the specified target function is not enabled yet, or already
	// disabled.
	MH_ERROR_DISABLED,

	// The specified pointer is invalid. It points the address of non-allocated
	// and/or non-executable region.
	MH_ERROR_NOT_EXECUTABLE,

	// The specified target function cannot be hooked.
	MH_ERROR_UNSUPPORTED_FUNCTION,

	// Failed to allocate memory.
	MH_ERROR_MEMORY_ALLOC,

	// Failed to change the memory protection.
	MH_ERROR_MEMORY_PROTECT,

	// The specified module is not loaded.
	MH_ERROR_MODULE_NOT_FOUND,

	// The specified function is not found.
	MH_ERROR_FUNCTION_NOT_FOUND
}
MH_STATUS;

// Can be passed as a parameter to MH_EnableHook, MH_DisableHook,
// MH_QueueEnableHook or MH_QueueDisableHook.
#define MH_ALL_HOOKS NULL

#ifdef __cplusplus
extern "C" {
#endif

	// Initialize the MinHook library. You must call this function EXACTLY ONCE
	// at the beginning of your program.
	MH_STATUS WINAPI MH_Initialize(VOID);

	// Uninitialize the MinHook library. You must call this function EXACTLY
	// ONCE at the end of your program.
	MH_STATUS WINAPI MH_Uninitialize(VOID);

	// Creates a hook for the specified target function, in disabled state.
	// Parameters:
	//   pTarget     [in]  A pointer to the target function, which will be
	//                     overridden by the detour function.
	//   pDetour     [in]  A pointer to the detour function, which will override
	//                     the target function.
	//   ppOriginal  [out] A pointer to the trampoline function, which will be
	//                     used to call the original target function.
	//                     This parameter can be NULL.
	MH_STATUS WINAPI MH_CreateHook(LPVOID pTarget, LPVOID pDetour, LPVOID* ppOriginal);

	// Creates a hook for the specified API function, in disabled state.
	// Parameters:
	//   pszModule   [in]  A pointer to the loaded module name which contains the
	//                     target function.
	//   pszProcName [in]  A pointer to the target function name, which will be
	//                     overridden by the detour function.
	//   pDetour     [in]  A pointer to the detour function, which will override
	//                     the target function.
	//   ppOriginal  [out] A pointer to the trampoline function, which will be
	//                     used to call the original target function.
	//                     This parameter can be NULL.
	MH_STATUS WINAPI MH_CreateHookApi(
		LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID* ppOriginal);

	// Creates a hook for the specified API function, in disabled state.
	// Parameters:
	//   pszModule   [in]  A pointer to the loaded module name which contains the
	//                     target function.
	//   pszProcName [in]  A pointer to the target function name, which will be
	//                     overridden by the detour function.
	//   pDetour     [in]  A pointer to the detour function, which will override
	//                     the target function.
	//   ppOriginal  [out] A pointer to the trampoline function, which will be
	//                     used to call the original target function.
	//                     This parameter can be NULL.
	//   ppTarget    [out] A pointer to the target function, which will be used
	//                     with other functions.
	//                     This parameter can be NULL.
	MH_STATUS WINAPI MH_CreateHookApiEx(
		LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID* ppOriginal, LPVOID* ppTarget);

	// Removes an already created hook.
	// Parameters:
	//   pTarget [in] A pointer to the target function.
	MH_STATUS WINAPI MH_RemoveHook(LPVOID pTarget);

	// Enables an already created hook.
	// Parameters:
	//   pTarget [in] A pointer to the target function.
	//                If this parameter is MH_ALL_HOOKS, all created hooks are
	//                enabled in one go.
	MH_STATUS WINAPI MH_EnableHook(LPVOID pTarget);

	// Disables an already created hook.
	// Parameters:
	//   pTarget [in] A pointer to the target function.
	//                If this parameter is MH_ALL_HOOKS, all created hooks are
	//                disabled in one go.
	MH_STATUS WINAPI MH_DisableHook(LPVOID pTarget);

	// Queues to enable an already created hook.
	// Parameters:
	//   pTarget [in] A pointer to the target function.
	//                If this parameter is MH_ALL_HOOKS, all created hooks are
	//                queued to be enabled.
	MH_STATUS WINAPI MH_QueueEnableHook(LPVOID pTarget);

	// Queues to disable an already created hook.
	// Parameters:
	//   pTarget [in] A pointer to the target function.
	//                If this parameter is MH_ALL_HOOKS, all created hooks are
	//                queued to be disabled.
	MH_STATUS WINAPI MH_QueueDisableHook(LPVOID pTarget);

	// Applies all queued changes in one go.
	MH_STATUS WINAPI MH_ApplyQueued(VOID);

	// Translates the MH_STATUS to its name as a string.
	const char* WINAPI MH_StatusToString(MH_STATUS status);

#ifdef __cplusplus
}
#endif
```

`include/vendor/nlohmann/json.hpp`:

```hpp
/*
    __ _____ _____ _____
 __|  |   __|     |   | |  JSON for Modern C++
|  |  |__   |  |  | | | |  version 3.9.1
|_____|_____|_____|_|___|  https://github.com/nlohmann/json

Licensed under the MIT License <http://opensource.org/licenses/MIT>.
SPDX-License-Identifier: MIT
Copyright (c) 2013-2019 Niels Lohmann <http://nlohmann.me>.

Permission is hereby  granted, free of charge, to any  person obtaining a copy
of this software and associated  documentation files (the "Software"), to deal
in the Software  without restriction, including without  limitation the rights
to  use, copy,  modify, merge,  publish, distribute,  sublicense, and/or  sell
copies  of  the Software,  and  to  permit persons  to  whom  the Software  is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE  IS PROVIDED "AS  IS", WITHOUT WARRANTY  OF ANY KIND,  EXPRESS OR
IMPLIED,  INCLUDING BUT  NOT  LIMITED TO  THE  WARRANTIES OF  MERCHANTABILITY,
FITNESS FOR  A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT  SHALL THE
AUTHORS  OR COPYRIGHT  HOLDERS  BE  LIABLE FOR  ANY  CLAIM,  DAMAGES OR  OTHER
LIABILITY, WHETHER IN AN ACTION OF  CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE  OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#ifndef INCLUDE_NLOHMANN_JSON_HPP_
#define INCLUDE_NLOHMANN_JSON_HPP_

#define NLOHMANN_JSON_VERSION_MAJOR 3
#define NLOHMANN_JSON_VERSION_MINOR 9
#define NLOHMANN_JSON_VERSION_PATCH 1

#include <algorithm> // all_of, find, for_each
#include <cstddef> // nullptr_t, ptrdiff_t, size_t
#include <functional> // hash, less
#include <initializer_list> // initializer_list
#include <iosfwd> // istream, ostream
#include <iterator> // random_access_iterator_tag
#include <memory> // unique_ptr
#include <numeric> // accumulate
#include <string> // string, stoi, to_string
#include <utility> // declval, forward, move, pair, swap
#include <vector> // vector

// #include <nlohmann/adl_serializer.hpp>


#include <utility>

// #include <nlohmann/detail/conversions/from_json.hpp>


#include <algorithm> // transform
#include <array> // array
#include <forward_list> // forward_list
#include <iterator> // inserter, front_inserter, end
#include <map> // map
#include <string> // string
#include <tuple> // tuple, make_tuple
#include <type_traits> // is_arithmetic, is_same, is_enum, underlying_type, is_convertible
#include <unordered_map> // unordered_map
#include <utility> // pair, declval
#include <valarray> // valarray

// #include <nlohmann/detail/exceptions.hpp>


#include <exception> // exception
#include <stdexcept> // runtime_error
#include <string> // to_string

// #include <nlohmann/detail/input/position_t.hpp>


#include <cstddef> // size_t

namespace nlohmann
{
namespace detail
{
/// struct to capture the start position of the current token
struct position_t
{
    /// the total number of characters read
    std::size_t chars_read_total = 0;
    /// the number of characters read in the current line
    std::size_t chars_read_current_line = 0;
    /// the number of lines read
    std::size_t lines_read = 0;

    /// conversion to size_t to preserve SAX interface
    constexpr operator size_t() const
    {
        return chars_read_total;
    }
};

} // namespace detail
} // namespace nlohmann

// #include <nlohmann/detail/macro_scope.hpp>


#include <utility> // pair
// #include <nlohmann/thirdparty/hedley/hedley.hpp>
/* Hedley - https://nemequ.github.io/hedley
 * Created by Evan Nemerson <evan@nemerson.com>
 *
 * To the extent possible under law, the author(s) have dedicated all
 * copyright and related and neighboring rights to this software to
 * the public domain worldwide. This software is distributed without
 * any warranty.
 *
 * For details, see <http://creativecommons.org/publicdomain/zero/1.0/>.
 * SPDX-License-Identifier: CC0-1.0
 */

#if !defined(JSON_HEDLEY_VERSION) || (JSON_HEDLEY_VERSION < 13)
#if defined(JSON_HEDLEY_VERSION)
    #undef JSON_HEDLEY_VERSION
#endif
#define JSON_HEDLEY_VERSION 13

#if defined(JSON_HEDLEY_STRINGIFY_EX)
    #undef JSON_HEDLEY_STRINGIFY_EX
#endif
#define JSON_HEDLEY_STRINGIFY_EX(x) #x

#if defined(JSON_HEDLEY_STRINGIFY)
    #undef JSON_HEDLEY_STRINGIFY
#endif
#define JSON_HEDLEY_STRINGIFY(x) JSON_HEDLEY_STRINGIFY_EX(x)

#if defined(JSON_HEDLEY_CONCAT_EX)
    #undef JSON_HEDLEY_CONCAT_EX
#endif
#define JSON_HEDLEY_CONCAT_EX(a,b) a##b

#if defined(JSON_HEDLEY_CONCAT)
    #undef JSON_HEDLEY_CONCAT
#endif
#define JSON_HEDLEY_CONCAT(a,b) JSON_HEDLEY_CONCAT_EX(a,b)

#if defined(JSON_HEDLEY_CONCAT3_EX)
    #undef JSON_HEDLEY_CONCAT3_EX
#endif
#define JSON_HEDLEY_CONCAT3_EX(a,b,c) a##b##c

#if defined(JSON_HEDLEY_CONCAT3)
    #undef JSON_HEDLEY_CONCAT3
#endif
#define JSON_HEDLEY_CONCAT3(a,b,c) JSON_HEDLEY_CONCAT3_EX(a,b,c)

#if defined(JSON_HEDLEY_VERSION_ENCODE)
    #undef JSON_HEDLEY_VERSION_ENCODE
#endif
#define JSON_HEDLEY_VERSION_ENCODE(major,minor,revision) (((major) * 1000000) + ((minor) * 1000) + (revision))

#if defined(JSON_HEDLEY_VERSION_DECODE_MAJOR)
    #undef JSON_HEDLEY_VERSION_DECODE_MAJOR
#endif
#define JSON_HEDLEY_VERSION_DECODE_MAJOR(version) ((version) / 1000000)

#if defined(JSON_HEDLEY_VERSION_DECODE_MINOR)
    #undef JSON_HEDLEY_VERSION_DECODE_MINOR
#endif
#define JSON_HEDLEY_VERSION_DECODE_MINOR(version) (((version) % 1000000) / 1000)

#if defined(JSON_HEDLEY_VERSION_DECODE_REVISION)
    #undef JSON_HEDLEY_VERSION_DECODE_REVISION
#endif
#define JSON_HEDLEY_VERSION_DECODE_REVISION(version) ((version) % 1000)

#if defined(JSON_HEDLEY_GNUC_VERSION)
    #undef JSON_HEDLEY_GNUC_VERSION
#endif
#if defined(__GNUC__) && defined(__GNUC_PATCHLEVEL__)
    #define JSON_HEDLEY_GNUC_VERSION JSON_HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)
#elif defined(__GNUC__)
    #define JSON_HEDLEY_GNUC_VERSION JSON_HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, 0)
#endif

#if defined(JSON_HEDLEY_GNUC_VERSION_CHECK)
    #undef JSON_HEDLEY_GNUC_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_GNUC_VERSION)
    #define JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_GNUC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_MSVC_VERSION)
    #undef JSON_HEDLEY_MSVC_VERSION
#endif
#if defined(_MSC_FULL_VER) && (_MSC_FULL_VER >= 140000000)
    #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 10000000, (_MSC_FULL_VER % 10000000) / 100000, (_MSC_FULL_VER % 100000) / 100)
#elif defined(_MSC_FULL_VER)
    #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 1000000, (_MSC_FULL_VER % 1000000) / 10000, (_MSC_FULL_VER % 10000) / 10)
#elif defined(_MSC_VER)
    #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_VER / 100, _MSC_VER % 100, 0)
#endif

#if defined(JSON_HEDLEY_MSVC_VERSION_CHECK)
    #undef JSON_HEDLEY_MSVC_VERSION_CHECK
#endif
#if !defined(_MSC_VER)
    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (0)
#elif defined(_MSC_VER) && (_MSC_VER >= 1400)
    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_FULL_VER >= ((major * 10000000) + (minor * 100000) + (patch)))
#elif defined(_MSC_VER) && (_MSC_VER >= 1200)
    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_FULL_VER >= ((major * 1000000) + (minor * 10000) + (patch)))
#else
    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_VER >= ((major * 100) + (minor)))
#endif

#if defined(JSON_HEDLEY_INTEL_VERSION)
    #undef JSON_HEDLEY_INTEL_VERSION
#endif
#if defined(__INTEL_COMPILER) && defined(__INTEL_COMPILER_UPDATE)
    #define JSON_HEDLEY_INTEL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, __INTEL_COMPILER_UPDATE)
#elif defined(__INTEL_COMPILER)
    #define JSON_HEDLEY_INTEL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, 0)
#endif

#if defined(JSON_HEDLEY_INTEL_VERSION_CHECK)
    #undef JSON_HEDLEY_INTEL_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_INTEL_VERSION)
    #define JSON_HEDLEY_INTEL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_INTEL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_INTEL_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_PGI_VERSION)
    #undef JSON_HEDLEY_PGI_VERSION
#endif
#if defined(__PGI) && defined(__PGIC__) && defined(__PGIC_MINOR__) && defined(__PGIC_PATCHLEVEL__)
    #define JSON_HEDLEY_PGI_VERSION JSON_HEDLEY_VERSION_ENCODE(__PGIC__, __PGIC_MINOR__, __PGIC_PATCHLEVEL__)
#endif

#if defined(JSON_HEDLEY_PGI_VERSION_CHECK)
    #undef JSON_HEDLEY_PGI_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_PGI_VERSION)
    #define JSON_HEDLEY_PGI_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_PGI_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_PGI_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_SUNPRO_VERSION)
    #undef JSON_HEDLEY_SUNPRO_VERSION
#endif
#if defined(__SUNPRO_C) && (__SUNPRO_C > 0x1000)
    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((((__SUNPRO_C >> 16) & 0xf) * 10) + ((__SUNPRO_C >> 12) & 0xf), (((__SUNPRO_C >> 8) & 0xf) * 10) + ((__SUNPRO_C >> 4) & 0xf), (__SUNPRO_C & 0xf) * 10)
#elif defined(__SUNPRO_C)
    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((__SUNPRO_C >> 8) & 0xf, (__SUNPRO_C >> 4) & 0xf, (__SUNPRO_C) & 0xf)
#elif defined(__SUNPRO_CC) && (__SUNPRO_CC > 0x1000)
    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((((__SUNPRO_CC >> 16) & 0xf) * 10) + ((__SUNPRO_CC >> 12) & 0xf), (((__SUNPRO_CC >> 8) & 0xf) * 10) + ((__SUNPRO_CC >> 4) & 0xf), (__SUNPRO_CC & 0xf) * 10)
#elif defined(__SUNPRO_CC)
    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((__SUNPRO_CC >> 8) & 0xf, (__SUNPRO_CC >> 4) & 0xf, (__SUNPRO_CC) & 0xf)
#endif

#if defined(JSON_HEDLEY_SUNPRO_VERSION_CHECK)
    #undef JSON_HEDLEY_SUNPRO_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_SUNPRO_VERSION)
    #define JSON_HEDLEY_SUNPRO_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_SUNPRO_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_SUNPRO_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION)
    #undef JSON_HEDLEY_EMSCRIPTEN_VERSION
#endif
#if defined(__EMSCRIPTEN__)
    #define JSON_HEDLEY_EMSCRIPTEN_VERSION JSON_HEDLEY_VERSION_ENCODE(__EMSCRIPTEN_major__, __EMSCRIPTEN_minor__, __EMSCRIPTEN_tiny__)
#endif

#if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK)
    #undef JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION)
    #define JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_EMSCRIPTEN_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_ARM_VERSION)
    #undef JSON_HEDLEY_ARM_VERSION
#endif
#if defined(__CC_ARM) && defined(__ARMCOMPILER_VERSION)
    #define JSON_HEDLEY_ARM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ARMCOMPILER_VERSION / 1000000, (__ARMCOMPILER_VERSION % 1000000) / 10000, (__ARMCOMPILER_VERSION % 10000) / 100)
#elif defined(__CC_ARM) && defined(__ARMCC_VERSION)
    #define JSON_HEDLEY_ARM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ARMCC_VERSION / 1000000, (__ARMCC_VERSION % 1000000) / 10000, (__ARMCC_VERSION % 10000) / 100)
#endif

#if defined(JSON_HEDLEY_ARM_VERSION_CHECK)
    #undef JSON_HEDLEY_ARM_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_ARM_VERSION)
    #define JSON_HEDLEY_ARM_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_ARM_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_ARM_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_IBM_VERSION)
    #undef JSON_HEDLEY_IBM_VERSION
#endif
#if defined(__ibmxl__)
    #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ibmxl_version__, __ibmxl_release__, __ibmxl_modification__)
#elif defined(__xlC__) && defined(__xlC_ver__)
    #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__xlC__ >> 8, __xlC__ & 0xff, (__xlC_ver__ >> 8) & 0xff)
#elif defined(__xlC__)
    #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__xlC__ >> 8, __xlC__ & 0xff, 0)
#endif

#if defined(JSON_HEDLEY_IBM_VERSION_CHECK)
    #undef JSON_HEDLEY_IBM_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_IBM_VERSION)
    #define JSON_HEDLEY_IBM_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_IBM_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_IBM_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_VERSION)
    #undef JSON_HEDLEY_TI_VERSION
#endif
#if \
    defined(__TI_COMPILER_VERSION__) && \
    ( \
      defined(__TMS470__) || defined(__TI_ARM__) || \
      defined(__MSP430__) || \
      defined(__TMS320C2000__) \
    )
#if (__TI_COMPILER_VERSION__ >= 16000000)
    #define JSON_HEDLEY_TI_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif
#endif

#if defined(JSON_HEDLEY_TI_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_VERSION)
    #define JSON_HEDLEY_TI_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_CL2000_VERSION)
    #undef JSON_HEDLEY_TI_CL2000_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && defined(__TMS320C2000__)
    #define JSON_HEDLEY_TI_CL2000_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_CL2000_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_CL2000_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_CL2000_VERSION)
    #define JSON_HEDLEY_TI_CL2000_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL2000_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_CL2000_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_CL430_VERSION)
    #undef JSON_HEDLEY_TI_CL430_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && defined(__MSP430__)
    #define JSON_HEDLEY_TI_CL430_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_CL430_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_CL430_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_CL430_VERSION)
    #define JSON_HEDLEY_TI_CL430_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL430_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_CL430_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_ARMCL_VERSION)
    #undef JSON_HEDLEY_TI_ARMCL_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && (defined(__TMS470__) || defined(__TI_ARM__))
    #define JSON_HEDLEY_TI_ARMCL_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_ARMCL_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_ARMCL_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_ARMCL_VERSION)
    #define JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_ARMCL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_CL6X_VERSION)
    #undef JSON_HEDLEY_TI_CL6X_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && defined(__TMS320C6X__)
    #define JSON_HEDLEY_TI_CL6X_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_CL6X_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_CL6X_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_CL6X_VERSION)
    #define JSON_HEDLEY_TI_CL6X_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL6X_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_CL6X_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_CL7X_VERSION)
    #undef JSON_HEDLEY_TI_CL7X_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && defined(__C7000__)
    #define JSON_HEDLEY_TI_CL7X_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_CL7X_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_CL7X_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_CL7X_VERSION)
    #define JSON_HEDLEY_TI_CL7X_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL7X_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_CL7X_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_CLPRU_VERSION)
    #undef JSON_HEDLEY_TI_CLPRU_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && defined(__PRU__)
    #define JSON_HEDLEY_TI_CLPRU_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_CLPRU_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_CLPRU_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_CLPRU_VERSION)
    #define JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CLPRU_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_CRAY_VERSION)
    #undef JSON_HEDLEY_CRAY_VERSION
#endif
#if defined(_CRAYC)
    #if defined(_RELEASE_PATCHLEVEL)
        #define JSON_HEDLEY_CRAY_VERSION JSON_HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, _RELEASE_PATCHLEVEL)
    #else
        #define JSON_HEDLEY_CRAY_VERSION JSON_HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, 0)
    #endif
#endif

#if defined(JSON_HEDLEY_CRAY_VERSION_CHECK)
    #undef JSON_HEDLEY_CRAY_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_CRAY_VERSION)
    #define JSON_HEDLEY_CRAY_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_CRAY_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_CRAY_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_IAR_VERSION)
    #undef JSON_HEDLEY_IAR_VERSION
#endif
#if defined(__IAR_SYSTEMS_ICC__)
    #if __VER__ > 1000
        #define JSON_HEDLEY_IAR_VERSION JSON_HEDLEY_VERSION_ENCODE((__VER__ / 1000000), ((__VER__ / 1000) % 1000), (__VER__ % 1000))
    #else
        #define JSON_HEDLEY_IAR_VERSION JSON_HEDLEY_VERSION_ENCODE(VER / 100, __VER__ % 100, 0)
    #endif
#endif

#if defined(JSON_HEDLEY_IAR_VERSION_CHECK)
    #undef JSON_HEDLEY_IAR_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_IAR_VERSION)
    #define JSON_HEDLEY_IAR_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_IAR_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_IAR_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TINYC_VERSION)
    #undef JSON_HEDLEY_TINYC_VERSION
#endif
#if defined(__TINYC__)
    #define JSON_HEDLEY_TINYC_VERSION JSON_HEDLEY_VERSION_ENCODE(__TINYC__ / 1000, (__TINYC__ / 100) % 10, __TINYC__ % 100)
#endif

#if defined(JSON_HEDLEY_TINYC_VERSION_CHECK)
    #undef JSON_HEDLEY_TINYC_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TINYC_VERSION)
    #define JSON_HEDLEY_TINYC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TINYC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TINYC_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_DMC_VERSION)
    #undef JSON_HEDLEY_DMC_VERSION
#endif
#if defined(__DMC__)
    #define JSON_HEDLEY_DMC_VERSION JSON_HEDLEY_VERSION_ENCODE(__DMC__ >> 8, (__DMC__ >> 4) & 0xf, __DMC__ & 0xf)
#endif

#if defined(JSON_HEDLEY_DMC_VERSION_CHECK)
    #undef JSON_HEDLEY_DMC_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_DMC_VERSION)
    #define JSON_HEDLEY_DMC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_DMC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_DMC_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_COMPCERT_VERSION)
    #undef JSON_HEDLEY_COMPCERT_VERSION
#endif
#if defined(__COMPCERT_VERSION__)
    #define JSON_HEDLEY_COMPCERT_VERSION JSON_HEDLEY_VERSION_ENCODE(__COMPCERT_VERSION__ / 10000, (__COMPCERT_VERSION__ / 100) % 100, __COMPCERT_VERSION__ % 100)
#endif

#if defined(JSON_HEDLEY_COMPCERT_VERSION_CHECK)
    #undef JSON_HEDLEY_COMPCERT_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_COMPCERT_VERSION)
    #define JSON_HEDLEY_COMPCERT_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_COMPCERT_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_COMPCERT_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_PELLES_VERSION)
    #undef JSON_HEDLEY_PELLES_VERSION
#endif
#if defined(__POCC__)
    #define JSON_HEDLEY_PELLES_VERSION JSON_HEDLEY_VERSION_ENCODE(__POCC__ / 100, __POCC__ % 100, 0)
#endif

#if defined(JSON_HEDLEY_PELLES_VERSION_CHECK)
    #undef JSON_HEDLEY_PELLES_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_PELLES_VERSION)
    #define JSON_HEDLEY_PELLES_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_PELLES_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_PELLES_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_GCC_VERSION)
    #undef JSON_HEDLEY_GCC_VERSION
#endif
#if \
    defined(JSON_HEDLEY_GNUC_VERSION) && \
    !defined(__clang__) && \
    !defined(JSON_HEDLEY_INTEL_VERSION) && \
    !defined(JSON_HEDLEY_PGI_VERSION) && \
    !defined(JSON_HEDLEY_ARM_VERSION) && \
    !defined(JSON_HEDLEY_TI_VERSION) && \
    !defined(JSON_HEDLEY_TI_ARMCL_VERSION) && \
    !defined(JSON_HEDLEY_TI_CL430_VERSION) && \
    !defined(JSON_HEDLEY_TI_CL2000_VERSION) && \
    !defined(JSON_HEDLEY_TI_CL6X_VERSION) && \
    !defined(JSON_HEDLEY_TI_CL7X_VERSION) && \
    !defined(JSON_HEDLEY_TI_CLPRU_VERSION) && \
    !defined(__COMPCERT__)
    #define JSON_HEDLEY_GCC_VERSION JSON_HEDLEY_GNUC_VERSION
#endif

#if defined(JSON_HEDLEY_GCC_VERSION_CHECK)
    #undef JSON_HEDLEY_GCC_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_GCC_VERSION)
    #define JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_GCC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_HAS_ATTRIBUTE)
    #undef JSON_HEDLEY_HAS_ATTRIBUTE
#endif
#if defined(__has_attribute)
    #define JSON_HEDLEY_HAS_ATTRIBUTE(attribute) __has_attribute(attribute)
#else
    #define JSON_HEDLEY_HAS_ATTRIBUTE(attribute) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_ATTRIBUTE)
    #undef JSON_HEDLEY_GNUC_HAS_ATTRIBUTE
#endif
#if defined(__has_attribute)
    #define JSON_HEDLEY_GNUC_HAS_ATTRIBUTE(attribute,major,minor,patch) __has_attribute(attribute)
#else
    #define JSON_HEDLEY_GNUC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_ATTRIBUTE)
    #undef JSON_HEDLEY_GCC_HAS_ATTRIBUTE
#endif
#if defined(__has_attribute)
    #define JSON_HEDLEY_GCC_HAS_ATTRIBUTE(attribute,major,minor,patch) __has_attribute(attribute)
#else
    #define JSON_HEDLEY_GCC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_CPP_ATTRIBUTE)
    #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE
#endif
#if \
    defined(__has_cpp_attribute) && \
    defined(__cplusplus) && \
    (!defined(JSON_HEDLEY_SUNPRO_VERSION) || JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0))
    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute) __has_cpp_attribute(attribute)
#else
    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute) (0)
#endif

#if defined(JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS)
    #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS
#endif
#if !defined(__cplusplus) || !defined(__has_cpp_attribute)
    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) (0)
#elif \
    !defined(JSON_HEDLEY_PGI_VERSION) && \
    !defined(JSON_HEDLEY_IAR_VERSION) && \
    (!defined(JSON_HEDLEY_SUNPRO_VERSION) || JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0)) && \
    (!defined(JSON_HEDLEY_MSVC_VERSION) || JSON_HEDLEY_MSVC_VERSION_CHECK(19,20,0))
    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) JSON_HEDLEY_HAS_CPP_ATTRIBUTE(ns::attribute)
#else
    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE)
    #undef JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE
#endif
#if defined(__has_cpp_attribute) && defined(__cplusplus)
    #define JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) __has_cpp_attribute(attribute)
#else
    #define JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE)
    #undef JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE
#endif
#if defined(__has_cpp_attribute) && defined(__cplusplus)
    #define JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) __has_cpp_attribute(attribute)
#else
    #define JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_BUILTIN)
    #undef JSON_HEDLEY_HAS_BUILTIN
#endif
#if defined(__has_builtin)
    #define JSON_HEDLEY_HAS_BUILTIN(builtin) __has_builtin(builtin)
#else
    #define JSON_HEDLEY_HAS_BUILTIN(builtin) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_BUILTIN)
    #undef JSON_HEDLEY_GNUC_HAS_BUILTIN
#endif
#if defined(__has_builtin)
    #define JSON_HEDLEY_GNUC_HAS_BUILTIN(builtin,major,minor,patch) __has_builtin(builtin)
#else
    #define JSON_HEDLEY_GNUC_HAS_BUILTIN(builtin,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_BUILTIN)
    #undef JSON_HEDLEY_GCC_HAS_BUILTIN
#endif
#if defined(__has_builtin)
    #define JSON_HEDLEY_GCC_HAS_BUILTIN(builtin,major,minor,patch) __has_builtin(builtin)
#else
    #define JSON_HEDLEY_GCC_HAS_BUILTIN(builtin,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_FEATURE)
    #undef JSON_HEDLEY_HAS_FEATURE
#endif
#if defined(__has_feature)
    #define JSON_HEDLEY_HAS_FEATURE(feature) __has_feature(feature)
#else
    #define JSON_HEDLEY_HAS_FEATURE(feature) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_FEATURE)
    #undef JSON_HEDLEY_GNUC_HAS_FEATURE
#endif
#if defined(__has_feature)
    #define JSON_HEDLEY_GNUC_HAS_FEATURE(feature,major,minor,patch) __has_feature(feature)
#else
    #define JSON_HEDLEY_GNUC_HAS_FEATURE(feature,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_FEATURE)
    #undef JSON_HEDLEY_GCC_HAS_FEATURE
#endif
#if defined(__has_feature)
    #define JSON_HEDLEY_GCC_HAS_FEATURE(feature,major,minor,patch) __has_feature(feature)
#else
    #define JSON_HEDLEY_GCC_HAS_FEATURE(feature,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_EXTENSION)
    #undef JSON_HEDLEY_HAS_EXTENSION
#endif
#if defined(__has_extension)
    #define JSON_HEDLEY_HAS_EXTENSION(extension) __has_extension(extension)
#else
    #define JSON_HEDLEY_HAS_EXTENSION(extension) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_EXTENSION)
    #undef JSON_HEDLEY_GNUC_HAS_EXTENSION
#endif
#if defined(__has_extension)
    #define JSON_HEDLEY_GNUC_HAS_EXTENSION(extension,major,minor,patch) __has_extension(extension)
#else
    #define JSON_HEDLEY_GNUC_HAS_EXTENSION(extension,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_EXTENSION)
    #undef JSON_HEDLEY_GCC_HAS_EXTENSION
#endif
#if defined(__has_extension)
    #define JSON_HEDLEY_GCC_HAS_EXTENSION(extension,major,minor,patch) __has_extension(extension)
#else
    #define JSON_HEDLEY_GCC_HAS_EXTENSION(extension,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE)
    #undef JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE
#endif
#if defined(__has_declspec_attribute)
    #define JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute) __has_declspec_attribute(attribute)
#else
    #define JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE)
    #undef JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE
#endif
#if defined(__has_declspec_attribute)
    #define JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) __has_declspec_attribute(attribute)
#else
    #define JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE)
    #undef JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE
#endif
#if defined(__has_declspec_attribute)
    #define JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) __has_declspec_attribute(attribute)
#else
    #define JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_WARNING)
    #undef JSON_HEDLEY_HAS_WARNING
#endif
#if defined(__has_warning)
    #define JSON_HEDLEY_HAS_WARNING(warning) __has_warning(warning)
#else
    #define JSON_HEDLEY_HAS_WARNING(warning) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_WARNING)
    #undef JSON_HEDLEY_GNUC_HAS_WARNING
#endif
#if defined(__has_warning)
    #define JSON_HEDLEY_GNUC_HAS_WARNING(warning,major,minor,patch) __has_warning(warning)
#else
    #define JSON_HEDLEY_GNUC_HAS_WARNING(warning,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_WARNING)
    #undef JSON_HEDLEY_GCC_HAS_WARNING
#endif
#if defined(__has_warning)
    #define JSON_HEDLEY_GCC_HAS_WARNING(warning,major,minor,patch) __has_warning(warning)
#else
    #define JSON_HEDLEY_GCC_HAS_WARNING(warning,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

/* JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_ is for
   HEDLEY INTERNAL USE ONLY.  API subject to change without notice. */
#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_
#endif
#if defined(__cplusplus)
#  if JSON_HEDLEY_HAS_WARNING("-Wc++98-compat")
#    if JSON_HEDLEY_HAS_WARNING("-Wc++17-extensions")
#      define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wc++98-compat\"") \
    _Pragma("clang diagnostic ignored \"-Wc++17-extensions\"") \
    xpr \
    JSON_HEDLEY_DIAGNOSTIC_POP
#    else
#      define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wc++98-compat\"") \
    xpr \
    JSON_HEDLEY_DIAGNOSTIC_POP
#    endif
#  endif
#endif
#if !defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(x) x
#endif

#if defined(JSON_HEDLEY_CONST_CAST)
    #undef JSON_HEDLEY_CONST_CAST
#endif
#if defined(__cplusplus)
#  define JSON_HEDLEY_CONST_CAST(T, expr) (const_cast<T>(expr))
#elif \
  JSON_HEDLEY_HAS_WARNING("-Wcast-qual") || \
  JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
#  define JSON_HEDLEY_CONST_CAST(T, expr) (__extension__ ({ \
        JSON_HEDLEY_DIAGNOSTIC_PUSH \
        JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL \
        ((T) (expr)); \
        JSON_HEDLEY_DIAGNOSTIC_POP \
    }))
#else
#  define JSON_HEDLEY_CONST_CAST(T, expr) ((T) (expr))
#endif

#if defined(JSON_HEDLEY_REINTERPRET_CAST)
    #undef JSON_HEDLEY_REINTERPRET_CAST
#endif
#if defined(__cplusplus)
    #define JSON_HEDLEY_REINTERPRET_CAST(T, expr) (reinterpret_cast<T>(expr))
#else
    #define JSON_HEDLEY_REINTERPRET_CAST(T, expr) ((T) (expr))
#endif

#if defined(JSON_HEDLEY_STATIC_CAST)
    #undef JSON_HEDLEY_STATIC_CAST
#endif
#if defined(__cplusplus)
    #define JSON_HEDLEY_STATIC_CAST(T, expr) (static_cast<T>(expr))
#else
    #define JSON_HEDLEY_STATIC_CAST(T, expr) ((T) (expr))
#endif

#if defined(JSON_HEDLEY_CPP_CAST)
    #undef JSON_HEDLEY_CPP_CAST
#endif
#if defined(__cplusplus)
#  if JSON_HEDLEY_HAS_WARNING("-Wold-style-cast")
#    define JSON_HEDLEY_CPP_CAST(T, expr) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wold-style-cast\"") \
    ((T) (expr)) \
    JSON_HEDLEY_DIAGNOSTIC_POP
#  elif JSON_HEDLEY_IAR_VERSION_CHECK(8,3,0)
#    define JSON_HEDLEY_CPP_CAST(T, expr) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("diag_suppress=Pe137") \
    JSON_HEDLEY_DIAGNOSTIC_POP \
#  else
#    define JSON_HEDLEY_CPP_CAST(T, expr) ((T) (expr))
#  endif
#else
#  define JSON_HEDLEY_CPP_CAST(T, expr) (expr)
#endif

#if \
    (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || \
    defined(__clang__) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(18,4,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,7,0) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(2,0,1) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,1,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,0,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    JSON_HEDLEY_CRAY_VERSION_CHECK(5,0,0) || \
    JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,17) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(8,0,0) || \
    (JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) && defined(__C99_PRAGMA_OPERATOR))
    #define JSON_HEDLEY_PRAGMA(value) _Pragma(#value)
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
    #define JSON_HEDLEY_PRAGMA(value) __pragma(value)
#else
    #define JSON_HEDLEY_PRAGMA(value)
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_PUSH)
    #undef JSON_HEDLEY_DIAGNOSTIC_PUSH
#endif
#if defined(JSON_HEDLEY_DIAGNOSTIC_POP)
    #undef JSON_HEDLEY_DIAGNOSTIC_POP
#endif
#if defined(__clang__)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("clang diagnostic push")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("clang diagnostic pop")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("warning(push)")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("warning(pop)")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("GCC diagnostic push")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("GCC diagnostic pop")
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH __pragma(warning(push))
    #define JSON_HEDLEY_DIAGNOSTIC_POP __pragma(warning(pop))
#elif JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("push")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("pop")
#elif \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,4,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,1,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("diag_push")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("diag_pop")
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,90,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("warning(push)")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("warning(pop)")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH
    #define JSON_HEDLEY_DIAGNOSTIC_POP
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wdeprecated-declarations")
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("clang diagnostic ignored \"-Wdeprecated-declarations\"")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("warning(disable:1478 1786)")
#elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1215,1444")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"")
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED __pragma(warning(disable:4996))
#elif \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1291,1718")
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) && !defined(__cplusplus)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("error_messages(off,E_DEPRECATED_ATT,E_DEPRECATED_ATT_MESS)")
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) && defined(__cplusplus)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("error_messages(off,symdeprecated,symdeprecated2)")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress=Pe1444,Pe1215")
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,90,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("warn(disable:2241)")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas")
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("clang diagnostic ignored \"-Wunknown-pragmas\"")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("warning(disable:161)")
#elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 1675")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("GCC diagnostic ignored \"-Wunknown-pragmas\"")
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS __pragma(warning(disable:4068))
#elif \
    JSON_HEDLEY_TI_VERSION_CHECK(16,9,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,3,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 163")
#elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 163")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress=Pe161")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wunknown-attributes")
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("clang diagnostic ignored \"-Wunknown-attributes\"")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(17,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("warning(disable:1292)")
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(19,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES __pragma(warning(disable:5030))
#elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1097")
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,14,0) && defined(__cplusplus)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("error_messages(off,attrskipunsup)")
#elif \
    JSON_HEDLEY_TI_VERSION_CHECK(18,1,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,3,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1173")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress=Pe1097")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wcast-qual")
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("clang diagnostic ignored \"-Wcast-qual\"")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("warning(disable:2203 2331)")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("GCC diagnostic ignored \"-Wcast-qual\"")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
#endif

#if defined(JSON_HEDLEY_DEPRECATED)
    #undef JSON_HEDLEY_DEPRECATED
#endif
#if defined(JSON_HEDLEY_DEPRECATED_FOR)
    #undef JSON_HEDLEY_DEPRECATED_FOR
#endif
#if JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0)
    #define JSON_HEDLEY_DEPRECATED(since) __declspec(deprecated("Since " # since))
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated("Since " #since "; use " #replacement))
#elif defined(__cplusplus) && (__cplusplus >= 201402L)
    #define JSON_HEDLEY_DEPRECATED(since) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[deprecated("Since " #since)]])
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[deprecated("Since " #since "; use " #replacement)]])
#elif \
    JSON_HEDLEY_HAS_EXTENSION(attribute_deprecated_with_message) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,5,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(18,1,0) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(18,1,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,3,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,3,0)
    #define JSON_HEDLEY_DEPRECATED(since) __attribute__((__deprecated__("Since " #since)))
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __attribute__((__deprecated__("Since " #since "; use " #replacement)))
#elif \
    JSON_HEDLEY_HAS_ATTRIBUTE(deprecated) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
    #define JSON_HEDLEY_DEPRECATED(since) __attribute__((__deprecated__))
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __attribute__((__deprecated__))
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
    JSON_HEDLEY_PELLES_VERSION_CHECK(6,50,0)
    #define JSON_HEDLEY_DEPRECATED(since) __declspec(deprecated)
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated)
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DEPRECATED(since) _Pragma("deprecated")
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) _Pragma("deprecated")
#else
    #define JSON_HEDLEY_DEPRECATED(since)
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement)
#endif

#if defined(JSON_HEDLEY_UNAVAILABLE)
    #undef JSON_HEDLEY_UNAVAILABLE
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(warning) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_UNAVAILABLE(available_since) __attribute__((__warning__("Not available until " #available_since)))
#else
    #define JSON_HEDLEY_UNAVAILABLE(available_since)
#endif

#if defined(JSON_HEDLEY_WARN_UNUSED_RESULT)
    #undef JSON_HEDLEY_WARN_UNUSED_RESULT
#endif
#if defined(JSON_HEDLEY_WARN_UNUSED_RESULT_MSG)
    #undef JSON_HEDLEY_WARN_UNUSED_RESULT_MSG
#endif
#if (JSON_HEDLEY_HAS_CPP_ATTRIBUTE(nodiscard) >= 201907L)
    #define JSON_HEDLEY_WARN_UNUSED_RESULT JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard(msg)]])
#elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE(nodiscard)
    #define JSON_HEDLEY_WARN_UNUSED_RESULT JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
#elif \
    JSON_HEDLEY_HAS_ATTRIBUTE(warn_unused_result) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0) && defined(__cplusplus)) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
    #define JSON_HEDLEY_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))
    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) __attribute__((__warn_unused_result__))
#elif defined(_Check_return_) /* SAL */
    #define JSON_HEDLEY_WARN_UNUSED_RESULT _Check_return_
    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) _Check_return_
#else
    #define JSON_HEDLEY_WARN_UNUSED_RESULT
    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg)
#endif

#if defined(JSON_HEDLEY_SENTINEL)
    #undef JSON_HEDLEY_SENTINEL
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(sentinel) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(5,4,0)
    #define JSON_HEDLEY_SENTINEL(position) __attribute__((__sentinel__(position)))
#else
    #define JSON_HEDLEY_SENTINEL(position)
#endif

#if defined(JSON_HEDLEY_NO_RETURN)
    #undef JSON_HEDLEY_NO_RETURN
#endif
#if JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_NO_RETURN __noreturn
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_NO_RETURN __attribute__((__noreturn__))
#elif defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
    #define JSON_HEDLEY_NO_RETURN _Noreturn
#elif defined(__cplusplus) && (__cplusplus >= 201103L)
    #define JSON_HEDLEY_NO_RETURN JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[noreturn]])
#elif \
    JSON_HEDLEY_HAS_ATTRIBUTE(noreturn) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,2,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
    #define JSON_HEDLEY_NO_RETURN __attribute__((__noreturn__))
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
    #define JSON_HEDLEY_NO_RETURN _Pragma("does_not_return")
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0)
    #define JSON_HEDLEY_NO_RETURN __declspec(noreturn)
#elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,0,0) && defined(__cplusplus)
    #define JSON_HEDLEY_NO_RETURN _Pragma("FUNC_NEVER_RETURNS;")
#elif JSON_HEDLEY_COMPCERT_VERSION_CHECK(3,2,0)
    #define JSON_HEDLEY_NO_RETURN __attribute((noreturn))
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(9,0,0)
    #define JSON_HEDLEY_NO_RETURN __declspec(noreturn)
#else
    #define JSON_HEDLEY_NO_RETURN
#endif

#if defined(JSON_HEDLEY_NO_ESCAPE)
    #undef JSON_HEDLEY_NO_ESCAPE
#endif
#if JSON_HEDLEY_HAS_ATTRIBUTE(noescape)
    #define JSON_HEDLEY_NO_ESCAPE __attribute__((__noescape__))
#else
    #define JSON_HEDLEY_NO_ESCAPE
#endif

#if defined(JSON_HEDLEY_UNREACHABLE)
    #undef JSON_HEDLEY_UNREACHABLE
#endif
#if defined(JSON_HEDLEY_UNREACHABLE_RETURN)
    #undef JSON_HEDLEY_UNREACHABLE_RETURN
#endif
#if defined(JSON_HEDLEY_ASSUME)
    #undef JSON_HEDLEY_ASSUME
#endif
#if \
    JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_ASSUME(expr) __assume(expr)
#elif JSON_HEDLEY_HAS_BUILTIN(__builtin_assume)
    #define JSON_HEDLEY_ASSUME(expr) __builtin_assume(expr)
#elif \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0)
    #if defined(__cplusplus)
        #define JSON_HEDLEY_ASSUME(expr) std::_nassert(expr)
    #else
        #define JSON_HEDLEY_ASSUME(expr) _nassert(expr)
    #endif
#endif
#if \
    (JSON_HEDLEY_HAS_BUILTIN(__builtin_unreachable) && (!defined(JSON_HEDLEY_ARM_VERSION))) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,5,0) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(18,10,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(13,1,5)
    #define JSON_HEDLEY_UNREACHABLE() __builtin_unreachable()
#elif defined(JSON_HEDLEY_ASSUME)
    #define JSON_HEDLEY_UNREACHABLE() JSON_HEDLEY_ASSUME(0)
#endif
#if !defined(JSON_HEDLEY_ASSUME)
    #if defined(JSON_HEDLEY_UNREACHABLE)
        #define JSON_HEDLEY_ASSUME(expr) JSON_HEDLEY_STATIC_CAST(void, ((expr) ? 1 : (JSON_HEDLEY_UNREACHABLE(), 1)))
    #else
        #define JSON_HEDLEY_ASSUME(expr) JSON_HEDLEY_STATIC_CAST(void, expr)
    #endif
#endif
#if defined(JSON_HEDLEY_UNREACHABLE)
    #if  \
        JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
        JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0)
        #define JSON_HEDLEY_UNREACHABLE_RETURN(value) return (JSON_HEDLEY_STATIC_CAST(void, JSON_HEDLEY_ASSUME(0)), (value))
    #else
        #define JSON_HEDLEY_UNREACHABLE_RETURN(value) JSON_HEDLEY_UNREACHABLE()
    #endif
#else
    #define JSON_HEDLEY_UNREACHABLE_RETURN(value) return (value)
#endif
#if !defined(JSON_HEDLEY_UNREACHABLE)
    #define JSON_HEDLEY_UNREACHABLE() JSON_HEDLEY_ASSUME(0)
#endif

JSON_HEDLEY_DIAGNOSTIC_PUSH
#if JSON_HEDLEY_HAS_WARNING("-Wpedantic")
    #pragma clang diagnostic ignored "-Wpedantic"
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wc++98-compat-pedantic") && defined(__cplusplus)
    #pragma clang diagnostic ignored "-Wc++98-compat-pedantic"
#endif
#if JSON_HEDLEY_GCC_HAS_WARNING("-Wvariadic-macros",4,0,0)
    #if defined(__clang__)
        #pragma clang diagnostic ignored "-Wvariadic-macros"
    #elif defined(JSON_HEDLEY_GCC_VERSION)
        #pragma GCC diagnostic ignored "-Wvariadic-macros"
    #endif
#endif
#if defined(JSON_HEDLEY_NON_NULL)
    #undef JSON_HEDLEY_NON_NULL
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(nonnull) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0)
    #define JSON_HEDLEY_NON_NULL(...) __attribute__((__nonnull__(__VA_ARGS__)))
#else
    #define JSON_HEDLEY_NON_NULL(...)
#endif
JSON_HEDLEY_DIAGNOSTIC_POP

#if defined(JSON_HEDLEY_PRINTF_FORMAT)
    #undef JSON_HEDLEY_PRINTF_FORMAT
#endif
#if defined(__MINGW32__) && JSON_HEDLEY_GCC_HAS_ATTRIBUTE(format,4,4,0) && !defined(__USE_MINGW_ANSI_STDIO)
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(ms_printf, string_idx, first_to_check)))
#elif defined(__MINGW32__) && JSON_HEDLEY_GCC_HAS_ATTRIBUTE(format,4,4,0) && defined(__USE_MINGW_ANSI_STDIO)
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(gnu_printf, string_idx, first_to_check)))
#elif \
    JSON_HEDLEY_HAS_ATTRIBUTE(format) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(__printf__, string_idx, first_to_check)))
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(6,0,0)
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __declspec(vaformat(printf,string_idx,first_to_check))
#else
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check)
#endif

#if defined(JSON_HEDLEY_CONSTEXPR)
    #undef JSON_HEDLEY_CONSTEXPR
#endif
#if defined(__cplusplus)
    #if __cplusplus >= 201103L
        #define JSON_HEDLEY_CONSTEXPR JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(constexpr)
    #endif
#endif
#if !defined(JSON_HEDLEY_CONSTEXPR)
    #define JSON_HEDLEY_CONSTEXPR
#endif

#if defined(JSON_HEDLEY_PREDICT)
    #undef JSON_HEDLEY_PREDICT
#endif
#if defined(JSON_HEDLEY_LIKELY)
    #undef JSON_HEDLEY_LIKELY
#endif
#if defined(JSON_HEDLEY_UNLIKELY)
    #undef JSON_HEDLEY_UNLIKELY
#endif
#if defined(JSON_HEDLEY_UNPREDICTABLE)
    #undef JSON_HEDLEY_UNPREDICTABLE
#endif
#if JSON_HEDLEY_HAS_BUILTIN(__builtin_unpredictable)
    #define JSON_HEDLEY_UNPREDICTABLE(expr) __builtin_unpredictable((expr))
#endif
#if \
  JSON_HEDLEY_HAS_BUILTIN(__builtin_expect_with_probability) || \
  JSON_HEDLEY_GCC_VERSION_CHECK(9,0,0)
#  define JSON_HEDLEY_PREDICT(expr, value, probability) __builtin_expect_with_probability(  (expr), (value), (probability))
#  define JSON_HEDLEY_PREDICT_TRUE(expr, probability)   __builtin_expect_with_probability(!!(expr),    1   , (probability))
#  define JSON_HEDLEY_PREDICT_FALSE(expr, probability)  __builtin_expect_with_probability(!!(expr),    0   , (probability))
#  define JSON_HEDLEY_LIKELY(expr)                      __builtin_expect                 (!!(expr),    1                  )
#  define JSON_HEDLEY_UNLIKELY(expr)                    __builtin_expect                 (!!(expr),    0                  )
#elif \
  JSON_HEDLEY_HAS_BUILTIN(__builtin_expect) || \
  JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
  (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0) && defined(__cplusplus)) || \
  JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
  JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
  JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
  JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,7,0) || \
  JSON_HEDLEY_TI_CL430_VERSION_CHECK(3,1,0) || \
  JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,1,0) || \
  JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
  JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
  JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
  JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,27) || \
  JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0)
#  define JSON_HEDLEY_PREDICT(expr, expected, probability) \
    (((probability) >= 0.9) ? __builtin_expect((expr), (expected)) : (JSON_HEDLEY_STATIC_CAST(void, expected), (expr)))
#  define JSON_HEDLEY_PREDICT_TRUE(expr, probability) \
    (__extension__ ({ \
        double hedley_probability_ = (probability); \
        ((hedley_probability_ >= 0.9) ? __builtin_expect(!!(expr), 1) : ((hedley_probability_ <= 0.1) ? __builtin_expect(!!(expr), 0) : !!(expr))); \
    }))
#  define JSON_HEDLEY_PREDICT_FALSE(expr, probability) \
    (__extension__ ({ \
        double hedley_probability_ = (probability); \
        ((hedley_probability_ >= 0.9) ? __builtin_expect(!!(expr), 0) : ((hedley_probability_ <= 0.1) ? __builtin_expect(!!(expr), 1) : !!(expr))); \
    }))
#  define JSON_HEDLEY_LIKELY(expr)   __builtin_expect(!!(expr), 1)
#  define JSON_HEDLEY_UNLIKELY(expr) __builtin_expect(!!(expr), 0)
#else
#  define JSON_HEDLEY_PREDICT(expr, expected, probability) (JSON_HEDLEY_STATIC_CAST(void, expected), (expr))
#  define JSON_HEDLEY_PREDICT_TRUE(expr, probability) (!!(expr))
#  define JSON_HEDLEY_PREDICT_FALSE(expr, probability) (!!(expr))
#  define JSON_HEDLEY_LIKELY(expr) (!!(expr))
#  define JSON_HEDLEY_UNLIKELY(expr) (!!(expr))
#endif
#if !defined(JSON_HEDLEY_UNPREDICTABLE)
    #define JSON_HEDLEY_UNPREDICTABLE(expr) JSON_HEDLEY_PREDICT(expr, 1, 0.5)
#endif

#if defined(JSON_HEDLEY_MALLOC)
    #undef JSON_HEDLEY_MALLOC
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(malloc) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(12,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
    #define JSON_HEDLEY_MALLOC __attribute__((__malloc__))
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
    #define JSON_HEDLEY_MALLOC _Pragma("returns_new_memory")
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(14, 0, 0)
    #define JSON_HEDLEY_MALLOC __declspec(restrict)
#else
    #define JSON_HEDLEY_MALLOC
#endif

#if defined(JSON_HEDLEY_PURE)
    #undef JSON_HEDLEY_PURE
#endif
#if \
  JSON_HEDLEY_HAS_ATTRIBUTE(pure) || \
  JSON_HEDLEY_GCC_VERSION_CHECK(2,96,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
  JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
  JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
  JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
  JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
  (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
  (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
  (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
  (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
  JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
  JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
  JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
#  define JSON_HEDLEY_PURE __attribute__((__pure__))
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
#  define JSON_HEDLEY_PURE _Pragma("does_not_write_global_data")
#elif defined(__cplusplus) && \
    ( \
      JSON_HEDLEY_TI_CL430_VERSION_CHECK(2,0,1) || \
      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0) || \
      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) \
    )
#  define JSON_HEDLEY_PURE _Pragma("FUNC_IS_PURE;")
#else
#  define JSON_HEDLEY_PURE
#endif

#if defined(JSON_HEDLEY_CONST)
    #undef JSON_HEDLEY_CONST
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(const) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(2,5,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
    #define JSON_HEDLEY_CONST __attribute__((__const__))
#elif \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
    #define JSON_HEDLEY_CONST _Pragma("no_side_effect")
#else
    #define JSON_HEDLEY_CONST JSON_HEDLEY_PURE
#endif

#if defined(JSON_HEDLEY_RESTRICT)
    #undef JSON_HEDLEY_RESTRICT
#endif
#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && !defined(__cplusplus)
    #define JSON_HEDLEY_RESTRICT restrict
#elif \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,4) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,1,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,14,0) && defined(__cplusplus)) || \
    JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0) || \
    defined(__clang__)
    #define JSON_HEDLEY_RESTRICT __restrict
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,3,0) && !defined(__cplusplus)
    #define JSON_HEDLEY_RESTRICT _Restrict
#else
    #define JSON_HEDLEY_RESTRICT
#endif

#if defined(JSON_HEDLEY_INLINE)
    #undef JSON_HEDLEY_INLINE
#endif
#if \
    (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || \
    (defined(__cplusplus) && (__cplusplus >= 199711L))
    #define JSON_HEDLEY_INLINE inline
#elif \
    defined(JSON_HEDLEY_GCC_VERSION) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(6,2,0)
    #define JSON_HEDLEY_INLINE __inline__
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(12,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,1,0) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
    #define JSON_HEDLEY_INLINE __inline
#else
    #define JSON_HEDLEY_INLINE
#endif

#if defined(JSON_HEDLEY_ALWAYS_INLINE)
    #undef JSON_HEDLEY_ALWAYS_INLINE
#endif
#if \
  JSON_HEDLEY_HAS_ATTRIBUTE(always_inline) || \
  JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
  JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
  JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
  JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
  JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
  (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
  (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
  (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
  (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
  JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
  JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
#  define JSON_HEDLEY_ALWAYS_INLINE __attribute__((__always_inline__)) JSON_HEDLEY_INLINE
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(12,0,0)
#  define JSON_HEDLEY_ALWAYS_INLINE __forceinline
#elif defined(__cplusplus) && \
    ( \
      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) \
    )
#  define JSON_HEDLEY_ALWAYS_INLINE _Pragma("FUNC_ALWAYS_INLINE;")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
#  define JSON_HEDLEY_ALWAYS_INLINE _Pragma("inline=forced")
#else
#  define JSON_HEDLEY_ALWAYS_INLINE JSON_HEDLEY_INLINE
#endif

#if defined(JSON_HEDLEY_NEVER_INLINE)
    #undef JSON_HEDLEY_NEVER_INLINE
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(noinline) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
    #define JSON_HEDLEY_NEVER_INLINE __attribute__((__noinline__))
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0)
    #define JSON_HEDLEY_NEVER_INLINE __declspec(noinline)
#elif JSON_HEDLEY_PGI_VERSION_CHECK(10,2,0)
    #define JSON_HEDLEY_NEVER_INLINE _Pragma("noinline")
#elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,0,0) && defined(__cplusplus)
    #define JSON_HEDLEY_NEVER_INLINE _Pragma("FUNC_CANNOT_INLINE;")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_NEVER_INLINE _Pragma("inline=never")
#elif JSON_HEDLEY_COMPCERT_VERSION_CHECK(3,2,0)
    #define JSON_HEDLEY_NEVER_INLINE __attribute((noinline))
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(9,0,0)
    #define JSON_HEDLEY_NEVER_INLINE __declspec(noinline)
#else
    #define JSON_HEDLEY_NEVER_INLINE
#endif

#if defined(JSON_HEDLEY_PRIVATE)
    #undef JSON_HEDLEY_PRIVATE
#endif
#if defined(JSON_HEDLEY_PUBLIC)
    #undef JSON_HEDLEY_PUBLIC
#endif
#if defined(JSON_HEDLEY_IMPORT)
    #undef JSON_HEDLEY_IMPORT
#endif
#if defined(_WIN32) || defined(__CYGWIN__)
#  define JSON_HEDLEY_PRIVATE
#  define JSON_HEDLEY_PUBLIC   __declspec(dllexport)
#  define JSON_HEDLEY_IMPORT   __declspec(dllimport)
#else
#  if \
    JSON_HEDLEY_HAS_ATTRIBUTE(visibility) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
    ( \
      defined(__TI_EABI__) && \
      ( \
        (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
        JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) \
      ) \
    )
#    define JSON_HEDLEY_PRIVATE __attribute__((__visibility__("hidden")))
#    define JSON_HEDLEY_PUBLIC  __attribute__((__visibility__("default")))
#  else
#    define JSON_HEDLEY_PRIVATE
#    define JSON_HEDLEY_PUBLIC
#  endif
#  define JSON_HEDLEY_IMPORT    extern
#endif

#if defined(JSON_HEDLEY_NO_THROW)
    #undef JSON_HEDLEY_NO_THROW
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(nothrow) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_NO_THROW __attribute__((__nothrow__))
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(13,1,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0)
    #define JSON_HEDLEY_NO_THROW __declspec(nothrow)
#else
    #define JSON_HEDLEY_NO_THROW
#endif

#if defined(JSON_HEDLEY_FALL_THROUGH)
    #undef JSON_HEDLEY_FALL_THROUGH
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(fallthrough) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(7,0,0)
    #define JSON_HEDLEY_FALL_THROUGH __attribute__((__fallthrough__))
#elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(clang,fallthrough)
    #define JSON_HEDLEY_FALL_THROUGH JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[clang::fallthrough]])
#elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE(fallthrough)
    #define JSON_HEDLEY_FALL_THROUGH JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[fallthrough]])
#elif defined(__fallthrough) /* SAL */
    #define JSON_HEDLEY_FALL_THROUGH __fallthrough
#else
    #define JSON_HEDLEY_FALL_THROUGH
#endif

#if defined(JSON_HEDLEY_RETURNS_NON_NULL)
    #undef JSON_HEDLEY_RETURNS_NON_NULL
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(returns_nonnull) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0)
    #define JSON_HEDLEY_RETURNS_NON_NULL __attribute__((__returns_nonnull__))
#elif defined(_Ret_notnull_) /* SAL */
    #define JSON_HEDLEY_RETURNS_NON_NULL _Ret_notnull_
#else
    #define JSON_HEDLEY_RETURNS_NON_NULL
#endif

#if defined(JSON_HEDLEY_ARRAY_PARAM)
    #undef JSON_HEDLEY_ARRAY_PARAM
#endif
#if \
    defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && \
    !defined(__STDC_NO_VLA__) && \
    !defined(__cplusplus) && \
    !defined(JSON_HEDLEY_PGI_VERSION) && \
    !defined(JSON_HEDLEY_TINYC_VERSION)
    #define JSON_HEDLEY_ARRAY_PARAM(name) (name)
#else
    #define JSON_HEDLEY_ARRAY_PARAM(name)
#endif

#if defined(JSON_HEDLEY_IS_CONSTANT)
    #undef JSON_HEDLEY_IS_CONSTANT
#endif
#if defined(JSON_HEDLEY_REQUIRE_CONSTEXPR)
    #undef JSON_HEDLEY_REQUIRE_CONSTEXPR
#endif
/* JSON_HEDLEY_IS_CONSTEXPR_ is for
   HEDLEY INTERNAL USE ONLY.  API subject to change without notice. */
#if defined(JSON_HEDLEY_IS_CONSTEXPR_)
    #undef JSON_HEDLEY_IS_CONSTEXPR_
#endif
#if \
    JSON_HEDLEY_HAS_BUILTIN(__builtin_constant_p) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,19) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
    (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0) && !defined(__cplusplus)) || \
    JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0)
    #define JSON_HEDLEY_IS_CONSTANT(expr) __builtin_constant_p(expr)
#endif
#if !defined(__cplusplus)
#  if \
       JSON_HEDLEY_HAS_BUILTIN(__builtin_types_compatible_p) || \
       JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
       JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
       JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
       JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \
       JSON_HEDLEY_ARM_VERSION_CHECK(5,4,0) || \
       JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,24)
#if defined(__INTPTR_TYPE__)
    #define JSON_HEDLEY_IS_CONSTEXPR_(expr) __builtin_types_compatible_p(__typeof__((1 ? (void*) ((__INTPTR_TYPE__) ((expr) * 0)) : (int*) 0)), int*)
#else
    #include <stdint.h>
    #define JSON_HEDLEY_IS_CONSTEXPR_(expr) __builtin_types_compatible_p(__typeof__((1 ? (void*) ((intptr_t) ((expr) * 0)) : (int*) 0)), int*)
#endif
#  elif \
       ( \
          defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L) && \
          !defined(JSON_HEDLEY_SUNPRO_VERSION) && \
          !defined(JSON_HEDLEY_PGI_VERSION) && \
          !defined(JSON_HEDLEY_IAR_VERSION)) || \
       JSON_HEDLEY_HAS_EXTENSION(c_generic_selections) || \
       JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0) || \
       JSON_HEDLEY_INTEL_VERSION_CHECK(17,0,0) || \
       JSON_HEDLEY_IBM_VERSION_CHECK(12,1,0) || \
       JSON_HEDLEY_ARM_VERSION_CHECK(5,3,0)
#if defined(__INTPTR_TYPE__)
    #define JSON_HEDLEY_IS_CONSTEXPR_(expr) _Generic((1 ? (void*) ((__INTPTR_TYPE__) ((expr) * 0)) : (int*) 0), int*: 1, void*: 0)
#else
    #include <stdint.h>
    #define JSON_HEDLEY_IS_CONSTEXPR_(expr) _Generic((1 ? (void*) ((intptr_t) * 0) : (int*) 0), int*: 1, void*: 0)
#endif
#  elif \
       defined(JSON_HEDLEY_GCC_VERSION) || \
       defined(JSON_HEDLEY_INTEL_VERSION) || \
       defined(JSON_HEDLEY_TINYC_VERSION) || \
       defined(JSON_HEDLEY_TI_ARMCL_VERSION) || \
       JSON_HEDLEY_TI_CL430_VERSION_CHECK(18,12,0) || \
       defined(JSON_HEDLEY_TI_CL2000_VERSION) || \
       defined(JSON_HEDLEY_TI_CL6X_VERSION) || \
       defined(JSON_HEDLEY_TI_CL7X_VERSION) || \
       defined(JSON_HEDLEY_TI_CLPRU_VERSION) || \
       defined(__clang__)
#    define JSON_HEDLEY_IS_CONSTEXPR_(expr) ( \
        sizeof(void) != \
        sizeof(*( \
                  1 ? \
                  ((void*) ((expr) * 0L) ) : \
((struct { char v[sizeof(void) * 2]; } *) 1) \
                ) \
              ) \
                                            )
#  endif
#endif
#if defined(JSON_HEDLEY_IS_CONSTEXPR_)
    #if !defined(JSON_HEDLEY_IS_CONSTANT)
        #define JSON_HEDLEY_IS_CONSTANT(expr) JSON_HEDLEY_IS_CONSTEXPR_(expr)
    #endif
    #define JSON_HEDLEY_REQUIRE_CONSTEXPR(expr) (JSON_HEDLEY_IS_CONSTEXPR_(expr) ? (expr) : (-1))
#else
    #if !defined(JSON_HEDLEY_IS_CONSTANT)
        #define JSON_HEDLEY_IS_CONSTANT(expr) (0)
    #endif
    #define JSON_HEDLEY_REQUIRE_CONSTEXPR(expr) (expr)
#endif

#if defined(JSON_HEDLEY_BEGIN_C_DECLS)
    #undef JSON_HEDLEY_BEGIN_C_DECLS
#endif
#if defined(JSON_HEDLEY_END_C_DECLS)
    #undef JSON_HEDLEY_END_C_DECLS
#endif
#if defined(JSON_HEDLEY_C_DECL)
    #undef JSON_HEDLEY_C_DECL
#endif
#if defined(__cplusplus)
    #define JSON_HEDLEY_BEGIN_C_DECLS extern "C" {
    #define JSON_HEDLEY_END_C_DECLS }
    #define JSON_HEDLEY_C_DECL extern "C"
#else
    #define JSON_HEDLEY_BEGIN_C_DECLS
    #define JSON_HEDLEY_END_C_DECLS
    #define JSON_HEDLEY_C_DECL
#endif

#if defined(JSON_HEDLEY_STATIC_ASSERT)
    #undef JSON_HEDLEY_STATIC_ASSERT
#endif
#if \
  !defined(__cplusplus) && ( \
      (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)) || \
      JSON_HEDLEY_HAS_FEATURE(c_static_assert) || \
      JSON_HEDLEY_GCC_VERSION_CHECK(6,0,0) || \
      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
      defined(_Static_assert) \
    )
#  define JSON_HEDLEY_STATIC_ASSERT(expr, message) _Static_assert(expr, message)
#elif \
  (defined(__cplusplus) && (__cplusplus >= 201103L)) || \
  JSON_HEDLEY_MSVC_VERSION_CHECK(16,0,0)
#  define JSON_HEDLEY_STATIC_ASSERT(expr, message) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(static_assert(expr, message))
#else
#  define JSON_HEDLEY_STATIC_ASSERT(expr, message)
#endif

#if defined(JSON_HEDLEY_NULL)
    #undef JSON_HEDLEY_NULL
#endif
#if defined(__cplusplus)
    #if __cplusplus >= 201103L
        #define JSON_HEDLEY_NULL JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(nullptr)
    #elif defined(NULL)
        #define JSON_HEDLEY_NULL NULL
    #else
        #define JSON_HEDLEY_NULL JSON_HEDLEY_STATIC_CAST(void*, 0)
    #endif
#elif defined(NULL)
    #define JSON_HEDLEY_NULL NULL
#else
    #define JSON_HEDLEY_NULL ((void*) 0)
#endif

#if defined(JSON_HEDLEY_MESSAGE)
    #undef JSON_HEDLEY_MESSAGE
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas")
#  define JSON_HEDLEY_MESSAGE(msg) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS \
    JSON_HEDLEY_PRAGMA(message msg) \
    JSON_HEDLEY_DIAGNOSTIC_POP
#elif \
  JSON_HEDLEY_GCC_VERSION_CHECK(4,4,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message msg)
#elif JSON_HEDLEY_CRAY_VERSION_CHECK(5,0,0)
#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(_CRI message msg)
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message(msg))
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,0,0)
#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message(msg))
#else
#  define JSON_HEDLEY_MESSAGE(msg)
#endif

#if defined(JSON_HEDLEY_WARNING)
    #undef JSON_HEDLEY_WARNING
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas")
#  define JSON_HEDLEY_WARNING(msg) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS \
    JSON_HEDLEY_PRAGMA(clang warning msg) \
    JSON_HEDLEY_DIAGNOSTIC_POP
#elif \
  JSON_HEDLEY_GCC_VERSION_CHECK(4,8,0) || \
  JSON_HEDLEY_PGI_VERSION_CHECK(18,4,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
#  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_PRAGMA(GCC warning msg)
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
#  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_PRAGMA(message(msg))
#else
#  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_MESSAGE(msg)
#endif

#if defined(JSON_HEDLEY_REQUIRE)
    #undef JSON_HEDLEY_REQUIRE
#endif
#if defined(JSON_HEDLEY_REQUIRE_MSG)
    #undef JSON_HEDLEY_REQUIRE_MSG
#endif
#if JSON_HEDLEY_HAS_ATTRIBUTE(diagnose_if)
#  if JSON_HEDLEY_HAS_WARNING("-Wgcc-compat")
#    define JSON_HEDLEY_REQUIRE(expr) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wgcc-compat\"") \
    __attribute__((diagnose_if(!(expr), #expr, "error"))) \
    JSON_HEDLEY_DIAGNOSTIC_POP
#    define JSON_HEDLEY_REQUIRE_MSG(expr,msg) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wgcc-compat\"") \
    __attribute__((diagnose_if(!(expr), msg, "error"))) \
    JSON_HEDLEY_DIAGNOSTIC_POP
#  else
#    define JSON_HEDLEY_REQUIRE(expr) __attribute__((diagnose_if(!(expr), #expr, "error")))
#    define JSON_HEDLEY_REQUIRE_MSG(expr,msg) __attribute__((diagnose_if(!(expr), msg, "error")))
#  endif
#else
#  define JSON_HEDLEY_REQUIRE(expr)
#  define JSON_HEDLEY_REQUIRE_MSG(expr,msg)
#endif

#if defined(JSON_HEDLEY_FLAGS)
    #undef JSON_HEDLEY_FLAGS
#endif
#if JSON_HEDLEY_HAS_ATTRIBUTE(flag_enum)
    #define JSON_HEDLEY_FLAGS __attribute__((__flag_enum__))
#endif

#if defined(JSON_HEDLEY_FLAGS_CAST)
    #undef JSON_HEDLEY_FLAGS_CAST
#endif
#if JSON_HEDLEY_INTEL_VERSION_CHECK(19,0,0)
#  define JSON_HEDLEY_FLAGS_CAST(T, expr) (__extension__ ({ \
        JSON_HEDLEY_DIAGNOSTIC_PUSH \
        _Pragma("warning(disable:188)") \
        ((T) (expr)); \
        JSON_HEDLEY_DIAGNOSTIC_POP \
    }))
#else
#  define JSON_HEDLEY_FLAGS_CAST(T, expr) JSON_HEDLEY_STATIC_CAST(T, expr)
#endif

#if defined(JSON_HEDLEY_EMPTY_BASES)
    #undef JSON_HEDLEY_EMPTY_BASES
#endif
#if JSON_HEDLEY_MSVC_VERSION_CHECK(19,0,23918) && !JSON_HEDLEY_MSVC_VERSION_CHECK(20,0,0)
    #define JSON_HEDLEY_EMPTY_BASES __declspec(empty_bases)
#else
    #define JSON_HEDLEY_EMPTY_BASES
#endif

/* Remaining macros are deprecated. */

#if defined(JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK)
    #undef JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK
#endif
#if defined(__clang__)
    #define JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major,minor,patch) (0)
#else
    #define JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_CLANG_HAS_ATTRIBUTE)
    #undef JSON_HEDLEY_CLANG_HAS_ATTRIBUTE
#endif
#define JSON_HEDLEY_CLANG_HAS_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)

#if defined(JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE)
    #undef JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE
#endif
#define JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute)

#if defined(JSON_HEDLEY_CLANG_HAS_BUILTIN)
    #undef JSON_HEDLEY_CLANG_HAS_BUILTIN
#endif
#define JSON_HEDLEY_CLANG_HAS_BUILTIN(builtin) JSON_HEDLEY_HAS_BUILTIN(builtin)

#if defined(JSON_HEDLEY_CLANG_HAS_FEATURE)
    #undef JSON_HEDLEY_CLANG_HAS_FEATURE
#endif
#define JSON_HEDLEY_CLANG_HAS_FEATURE(feature) JSON_HEDLEY_HAS_FEATURE(feature)

#if defined(JSON_HEDLEY_CLANG_HAS_EXTENSION)
    #undef JSON_HEDLEY_CLANG_HAS_EXTENSION
#endif
#define JSON_HEDLEY_CLANG_HAS_EXTENSION(extension) JSON_HEDLEY_HAS_EXTENSION(extension)

#if defined(JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE)
    #undef JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE
#endif
#define JSON_HEDLEY_CLANG_HAS_DECLSPEC_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute)

#if defined(JSON_HEDLEY_CLANG_HAS_WARNING)
    #undef JSON_HEDLEY_CLANG_HAS_WARNING
#endif
#define JSON_HEDLEY_CLANG_HAS_WARNING(warning) JSON_HEDLEY_HAS_WARNING(warning)

#endif /* !defined(JSON_HEDLEY_VERSION) || (JSON_HEDLEY_VERSION < X) */


// This file contains all internal macro definitions
// You MUST include macro_unscope.hpp at the end of json.hpp to undef all of them

// exclude unsupported compilers
#if !defined(JSON_SKIP_UNSUPPORTED_COMPILER_CHECK)
    #if defined(__clang__)
        #if (__clang_major__ * 10000 + __clang_minor__ * 100 + __clang_patchlevel__) < 30400
            #error "unsupported Clang version - see https://github.com/nlohmann/json#supported-compilers"
        #endif
    #elif defined(__GNUC__) && !(defined(__ICC) || defined(__INTEL_COMPILER))
        #if (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) < 40800
            #error "unsupported GCC version - see https://github.com/nlohmann/json#supported-compilers"
        #endif
    #endif
#endif

// C++ language standard detection
#if (defined(__cplusplus) && __cplusplus >= 202002L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 202002L)
    #define JSON_HAS_CPP_20
    #define JSON_HAS_CPP_17
    #define JSON_HAS_CPP_14
#elif (defined(__cplusplus) && __cplusplus >= 201703L) || (defined(_HAS_CXX17) && _HAS_CXX17 == 1) // fix for issue #464
    #define JSON_HAS_CPP_17
    #define JSON_HAS_CPP_14
#elif (defined(__cplusplus) && __cplusplus >= 201402L) || (defined(_HAS_CXX14) && _HAS_CXX14 == 1)
    #define JSON_HAS_CPP_14
#endif

// disable float-equal warnings on GCC/clang
#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wfloat-equal"
#endif

// disable documentation warnings on clang
#if defined(__clang__)
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wdocumentation"
#endif

// allow to disable exceptions
#if (defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)) && !defined(JSON_NOEXCEPTION)
    #define JSON_THROW(exception) throw exception
    #define JSON_TRY try
    #define JSON_CATCH(exception) catch(exception)
    #define JSON_INTERNAL_CATCH(exception) catch(exception)
#else
    #include <cstdlib>
    #define JSON_THROW(exception) std::abort()
    #define JSON_TRY if(true)
    #define JSON_CATCH(exception) if(false)
    #define JSON_INTERNAL_CATCH(exception) if(false)
#endif

// override exception macros
#if defined(JSON_THROW_USER)
    #undef JSON_THROW
    #define JSON_THROW JSON_THROW_USER
#endif
#if defined(JSON_TRY_USER)
    #undef JSON_TRY
    #define JSON_TRY JSON_TRY_USER
#endif
#if defined(JSON_CATCH_USER)
    #undef JSON_CATCH
    #define JSON_CATCH JSON_CATCH_USER
    #undef JSON_INTERNAL_CATCH
    #define JSON_INTERNAL_CATCH JSON_CATCH_USER
#endif
#if defined(JSON_INTERNAL_CATCH_USER)
    #undef JSON_INTERNAL_CATCH
    #define JSON_INTERNAL_CATCH JSON_INTERNAL_CATCH_USER
#endif

// allow to override assert
#if !defined(JSON_ASSERT)
    #include <cassert> // assert
    #define JSON_ASSERT(x) assert(x)
#endif

/*!
@brief macro to briefly define a mapping between an enum and JSON
@def NLOHMANN_JSON_SERIALIZE_ENUM
@since version 3.4.0
*/
#define NLOHMANN_JSON_SERIALIZE_ENUM(ENUM_TYPE, ...)                                            \
    template<typename BasicJsonType>                                                            \
    inline void to_json(BasicJsonType& j, const ENUM_TYPE& e)                                   \
    {                                                                                           \
        static_assert(std::is_enum<ENUM_TYPE>::value, #ENUM_TYPE " must be an enum!");          \
        static const std::pair<ENUM_TYPE, BasicJsonType> m[] = __VA_ARGS__;                     \
        auto it = std::find_if(std::begin(m), std::end(m),                                      \
                               [e](const std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> bool  \
        {                                                                                       \
            return ej_pair.first == e;                                                          \
        });                                                                                     \
        j = ((it != std::end(m)) ? it : std::begin(m))->second;                                 \
    }                                                                                           \
    template<typename BasicJsonType>                                                            \
    inline void from_json(const BasicJsonType& j, ENUM_TYPE& e)                                 \
    {                                                                                           \
        static_assert(std::is_enum<ENUM_TYPE>::value, #ENUM_TYPE " must be an enum!");          \
        static const std::pair<ENUM_TYPE, BasicJsonType> m[] = __VA_ARGS__;                     \
        auto it = std::find_if(std::begin(m), std::end(m),                                      \
                               [&j](const std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> bool \
        {                                                                                       \
            return ej_pair.second == j;                                                         \
        });                                                                                     \
        e = ((it != std::end(m)) ? it : std::begin(m))->first;                                  \
    }

// Ugly macros to avoid uglier copy-paste when specializing basic_json. They
// may be removed in the future once the class is split.

#define NLOHMANN_BASIC_JSON_TPL_DECLARATION                                \
    template<template<typename, typename, typename...> class ObjectType,   \
             template<typename, typename...> class ArrayType,              \
             class StringType, class BooleanType, class NumberIntegerType, \
             class NumberUnsignedType, class NumberFloatType,              \
             template<typename> class AllocatorType,                       \
             template<typename, typename = void> class JSONSerializer,     \
             class BinaryType>

#define NLOHMANN_BASIC_JSON_TPL                                            \
    basic_json<ObjectType, ArrayType, StringType, BooleanType,             \
    NumberIntegerType, NumberUnsignedType, NumberFloatType,                \
    AllocatorType, JSONSerializer, BinaryType>

// Macros to simplify conversion from/to types

#define NLOHMANN_JSON_EXPAND( x ) x
#define NLOHMANN_JSON_GET_MACRO(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, NAME,...) NAME
#define NLOHMANN_JSON_PASTE(...) NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_GET_MACRO(__VA_ARGS__, \
        NLOHMANN_JSON_PASTE64, \
        NLOHMANN_JSON_PASTE63, \
        NLOHMANN_JSON_PASTE62, \
        NLOHMANN_JSON_PASTE61, \
        NLOHMANN_JSON_PASTE60, \
        NLOHMANN_JSON_PASTE59, \
        NLOHMANN_JSON_PASTE58, \
        NLOHMANN_JSON_PASTE57, \
        NLOHMANN_JSON_PASTE56, \
        NLOHMANN_JSON_PASTE55, \
        NLOHMANN_JSON_PASTE54, \
        NLOHMANN_JSON_PASTE53, \
        NLOHMANN_JSON_PASTE52, \
        NLOHMANN_JSON_PASTE51, \
        NLOHMANN_JSON_PASTE50, \
        NLOHMANN_JSON_PASTE49, \
        NLOHMANN_JSON_PASTE48, \
        NLOHMANN_JSON_PASTE47, \
        NLOHMANN_JSON_PASTE46, \
        NLOHMANN_JSON_PASTE45, \
        NLOHMANN_JSON_PASTE44, \
        NLOHMANN_JSON_PASTE43, \
        NLOHMANN_JSON_PASTE42, \
        NLOHMANN_JSON_PASTE41, \
        NLOHMANN_JSON_PASTE40, \
        NLOHMANN_JSON_PASTE39, \
        NLOHMANN_JSON_PASTE38, \
        NLOHMANN_JSON_PASTE37, \
        NLOHMANN_JSON_PASTE36, \
        NLOHMANN_JSON_PASTE35, \
        NLOHMANN_JSON_PASTE34, \
        NLOHMANN_JSON_PASTE33, \
        NLOHMANN_JSON_PASTE32, \
        NLOHMANN_JSON_PASTE31, \
        NLOHMANN_JSON_PASTE30, \
        NLOHMANN_JSON_PASTE29, \
        NLOHMANN_JSON_PASTE28, \
        NLOHMANN_JSON_PASTE27, \
        NLOHMANN_JSON_PASTE26, \
        NLOHMANN_JSON_PASTE25, \
        NLOHMANN_JSON_PASTE24, \
        NLOHMANN_JSON_PASTE23, \
        NLOHMANN_JSON_PASTE22, \
        NLOHMANN_JSON_PASTE21, \
        NLOHMANN_JSON_PASTE20, \
        NLOHMANN_JSON_PASTE19, \
        NLOHMANN_JSON_PASTE18, \
        NLOHMANN_JSON_PASTE17, \
        NLOHMANN_JSON_PASTE16, \
        NLOHMANN_JSON_PASTE15, \
        NLOHMANN_JSON_PASTE14, \
        NLOHMANN_JSON_PASTE13, \
        NLOHMANN_JSON_PASTE12, \
        NLOHMANN_JSON_PASTE11, \
        NLOHMANN_JSON_PASTE10, \
        NLOHMANN_JSON_PASTE9, \
        NLOHMANN_JSON_PASTE8, \
        NLOHMANN_JSON_PASTE7, \
        NLOHMANN_JSON_PASTE6, \
        NLOHMANN_JSON_PASTE5, \
        NLOHMANN_JSON_PASTE4, \
        NLOHMANN_JSON_PASTE3, \
        NLOHMANN_JSON_PASTE2, \
        NLOHMANN_JSON_PASTE1)(__VA_ARGS__))
#define NLOHMANN_JSON_PASTE2(func, v1) func(v1)
#define NLOHMANN_JSON_PASTE3(func, v1, v2) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE2(func, v2)
#define NLOHMANN_JSON_PASTE4(func, v1, v2, v3) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE3(func, v2, v3)
#define NLOHMANN_JSON_PASTE5(func, v1, v2, v3, v4) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE4(func, v2, v3, v4)
#define NLOHMANN_JSON_PASTE6(func, v1, v2, v3, v4, v5) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE5(func, v2, v3, v4, v5)
#define NLOHMANN_JSON_PASTE7(func, v1, v2, v3, v4, v5, v6) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE6(func, v2, v3, v4, v5, v6)
#define NLOHMANN_JSON_PASTE8(func, v1, v2, v3, v4, v5, v6, v7) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE7(func, v2, v3, v4, v5, v6, v7)
#define NLOHMANN_JSON_PASTE9(func, v1, v2, v3, v4, v5, v6, v7, v8) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE8(func, v2, v3, v4, v5, v6, v7, v8)
#define NLOHMANN_JSON_PASTE10(func, v1, v2, v3, v4, v5, v6, v7, v8, v9) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE9(func, v2, v3, v4, v5, v6, v7, v8, v9)
#define NLOHMANN_JSON_PASTE11(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE10(func, v2, v3, v4, v5, v6, v7, v8, v9, v10)
#define NLOHMANN_JSON_PASTE12(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE11(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11)
#define NLOHMANN_JSON_PASTE13(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE12(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12)
#define NLOHMANN_JSON_PASTE14(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE13(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13)
#define NLOHMANN_JSON_PASTE15(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE14(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14)
#define NLOHMANN_JSON_PASTE16(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE15(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)
#define NLOHMANN_JSON_PASTE17(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE16(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16)
#define NLOHMANN_JSON_PASTE18(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE17(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17)
#define NLOHMANN_JSON_PASTE19(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE18(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18)
#define NLOHMANN_JSON_PASTE20(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE19(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19)
#define NLOHMANN_JSON_PASTE21(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE20(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20)
#define NLOHMANN_JSON_PASTE22(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE21(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21)
#define NLOHMANN_JSON_PASTE23(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE22(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22)
#define NLOHMANN_JSON_PASTE24(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE23(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23)
#define NLOHMANN_JSON_PASTE25(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE24(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24)
#define NLOHMANN_JSON_PASTE26(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE25(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25)
#define NLOHMANN_JSON_PASTE27(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE26(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26)
#define NLOHMANN_JSON_PASTE28(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE27(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27)
#define NLOHMANN_JSON_PASTE29(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE28(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28)
#define NLOHMANN_JSON_PASTE30(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE29(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29)
#define NLOHMANN_JSON_PASTE31(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE30(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30)
#define NLOHMANN_JSON_PASTE32(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE31(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31)
#define NLOHMANN_JSON_PASTE33(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE32(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32)
#define NLOHMANN_JSON_PASTE34(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE33(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33)
#define NLOHMANN_JSON_PASTE35(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE34(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34)
#define NLOHMANN_JSON_PASTE36(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE35(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35)
#define NLOHMANN_JSON_PASTE37(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE36(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36)
#define NLOHMANN_JSON_PASTE38(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE37(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37)
#define NLOHMANN_JSON_PASTE39(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE38(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38)
#define NLOHMANN_JSON_PASTE40(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE39(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39)
#define NLOHMANN_JSON_PASTE41(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE40(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40)
#define NLOHMANN_JSON_PASTE42(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE41(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41)
#define NLOHMANN_JSON_PASTE43(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE42(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42)
#define NLOHMANN_JSON_PASTE44(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE43(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43)
#define NLOHMANN_JSON_PASTE45(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE44(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44)
#define NLOHMANN_JSON_PASTE46(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE45(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45)
#define NLOHMANN_JSON_PASTE47(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE46(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46)
#define NLOHMANN_JSON_PASTE48(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE47(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47)
#define NLOHMANN_JSON_PASTE49(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE48(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48)
#define NLOHMANN_JSON_PASTE50(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE49(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49)
#define NLOHMANN_JSON_PASTE51(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE50(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50)
#define NLOHMANN_JSON_PASTE52(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE51(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51)
#define NLOHMANN_JSON_PASTE53(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE52(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52)
#define NLOHMANN_JSON_PASTE54(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE53(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53)
#define NLOHMANN_JSON_PASTE55(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE54(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54)
#define NLOHMANN_JSON_PASTE56(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE55(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55)
#define NLOHMANN_JSON_PASTE57(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE56(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56)
#define NLOHMANN_JSON_PASTE58(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE57(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57)
#define NLOHMANN_JSON_PASTE59(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE58(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58)
#define NLOHMANN_JSON_PASTE60(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE59(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59)
#define NLOHMANN_JSON_PASTE61(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE60(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60)
#define NLOHMANN_JSON_PASTE62(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE61(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61)
#define NLOHMANN_JSON_PASTE63(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE62(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62)
#define NLOHMANN_JSON_PASTE64(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE63(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63)

#define NLOHMANN_JSON_TO(v1) nlohmann_json_j[#v1] = nlohmann_json_t.v1;
#define NLOHMANN_JSON_FROM(v1) nlohmann_json_j.at(#v1).get_to(nlohmann_json_t.v1);

/*!
@brief macro
@def NLOHMANN_DEFINE_TYPE_INTRUSIVE
@since version 3.9.0
*/
#define NLOHMANN_DEFINE_TYPE_INTRUSIVE(Type, ...)  \
    friend void to_json(nlohmann::json& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
    friend void from_json(const nlohmann::json& nlohmann_json_j, Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) }

/*!
@brief macro
@def NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE
@since version 3.9.0
*/
#define NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(Type, ...)  \
    inline void to_json(nlohmann::json& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
    inline void from_json(const nlohmann::json& nlohmann_json_j, Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) }

#ifndef JSON_USE_IMPLICIT_CONVERSIONS
    #define JSON_USE_IMPLICIT_CONVERSIONS 1
#endif

#if JSON_USE_IMPLICIT_CONVERSIONS
    #define JSON_EXPLICIT
#else
    #define JSON_EXPLICIT explicit
#endif


namespace nlohmann
{
namespace detail
{
////////////////
// exceptions //
////////////////

/*!
@brief general exception of the @ref basic_json class

This class is an extension of `std::exception` objects with a member @a id for
exception ids. It is used as the base class for all exceptions thrown by the
@ref basic_json class. This class can hence be used as "wildcard" to catch
exceptions.

Subclasses:
- @ref parse_error for exceptions indicating a parse error
- @ref invalid_iterator for exceptions indicating errors with iterators
- @ref type_error for exceptions indicating executing a member function with
                  a wrong type
- @ref out_of_range for exceptions indicating access out of the defined range
- @ref other_error for exceptions indicating other library errors

@internal
@note To have nothrow-copy-constructible exceptions, we internally use
      `std::runtime_error` which can cope with arbitrary-length error messages.
      Intermediate strings are built with static functions and then passed to
      the actual constructor.
@endinternal

@liveexample{The following code shows how arbitrary library exceptions can be
caught.,exception}

@since version 3.0.0
*/
class exception : public std::exception
{
  public:
    /// returns the explanatory string
    JSON_HEDLEY_RETURNS_NON_NULL
    const char* what() const noexcept override
    {
        return m.what();
    }

    /// the id of the exception
    const int id;

  protected:
    JSON_HEDLEY_NON_NULL(3)
    exception(int id_, const char* what_arg) : id(id_), m(what_arg) {}

    static std::string name(const std::string& ename, int id_)
    {
        return "[json.exception." + ename + "." + std::to_string(id_) + "] ";
    }

  private:
    /// an exception object as storage for error messages
    std::runtime_error m;
};

/*!
@brief exception indicating a parse error

This exception is thrown by the library when a parse error occurs. Parse errors
can occur during the deserialization of JSON text, CBOR, MessagePack, as well
as when using JSON Patch.

Member @a byte holds the byte index of the last read character in the input
file.

Exceptions have ids 1xx.

name / id                      | example message | description
------------------------------ | --------------- | -------------------------
json.exception.parse_error.101 | parse error at 2: unexpected end of input; expected string literal | This error indicates a syntax error while deserializing a JSON text. The error message describes that an unexpected token (character) was encountered, and the member @a byte indicates the error position.
json.exception.parse_error.102 | parse error at 14: missing or wrong low surrogate | JSON uses the `\uxxxx` format to describe Unicode characters. Code points above above 0xFFFF are split into two `\uxxxx` entries ("surrogate pairs"). This error indicates that the surrogate pair is incomplete or contains an invalid code point.
json.exception.parse_error.103 | parse error: code points above 0x10FFFF are invalid | Unicode supports code points up to 0x10FFFF. Code points above 0x10FFFF are invalid.
json.exception.parse_error.104 | parse error: JSON patch must be an array of objects | [RFC 6902](https://tools.ietf.org/html/rfc6902) requires a JSON Patch document to be a JSON document that represents an array of objects.
json.exception.parse_error.105 | parse error: operation must have string member 'op' | An operation of a JSON Patch document must contain exactly one "op" member, whose value indicates the operation to perform. Its value must be one of "add", "remove", "replace", "move", "copy", or "test"; other values are errors.
json.exception.parse_error.106 | parse error: array index '01' must not begin with '0' | An array index in a JSON Pointer ([RFC 6901](https://tools.ietf.org/html/rfc6901)) may be `0` or any number without a leading `0`.
json.exception.parse_error.107 | parse error: JSON pointer must be empty or begin with '/' - was: 'foo' | A JSON Pointer must be a Unicode string containing a sequence of zero or more reference tokens, each prefixed by a `/` character.
json.exception.parse_error.108 | parse error: escape character '~' must be followed with '0' or '1' | In a JSON Pointer, only `~0` and `~1` are valid escape sequences.
json.exception.parse_error.109 | parse error: array index 'one' is not a number | A JSON Pointer array index must be a number.
json.exception.parse_error.110 | parse error at 1: cannot read 2 bytes from vector | When parsing CBOR or MessagePack, the byte vector ends before the complete value has been read.
json.exception.parse_error.112 | parse error at 1: error reading CBOR; last byte: 0xF8 | Not all types of CBOR or MessagePack are supported. This exception occurs if an unsupported byte was read.
json.exception.parse_error.113 | parse error at 2: expected a CBOR string; last byte: 0x98 | While parsing a map key, a value that is not a string has been read.
json.exception.parse_error.114 | parse error: Unsupported BSON record type 0x0F | The parsing of the corresponding BSON record type is not implemented (yet).
json.exception.parse_error.115 | parse error at byte 5: syntax error while parsing UBJSON high-precision number: invalid number text: 1A | A UBJSON high-precision number could not be parsed.

@note For an input with n bytes, 1 is the index of the first character and n+1
      is the index of the terminating null byte or the end of file. This also
      holds true when reading a byte vector (CBOR or MessagePack).

@liveexample{The following code shows how a `parse_error` exception can be
caught.,parse_error}

@sa - @ref exception for the base class of the library exceptions
@sa - @ref invalid_iterator for exceptions indicating errors with iterators
@sa - @ref type_error for exceptions indicating executing a member function with
                    a wrong type
@sa - @ref out_of_range for exceptions indicating access out of the defined range
@sa - @ref other_error for exceptions indicating other library errors

@since version 3.0.0
*/
class parse_error : public exception
{
  public:
    /*!
    @brief create a parse error exception
    @param[in] id_       the id of the exception
    @param[in] pos       the position where the error occurred (or with
                         chars_read_total=0 if the position cannot be
                         determined)
    @param[in] what_arg  the explanatory string
    @return parse_error object
    */
    static parse_error create(int id_, const position_t& pos, const std::string& what_arg)
    {
        std::string w = exception::name("parse_error", id_) + "parse error" +
                        position_string(pos) + ": " + what_arg;
        return parse_error(id_, pos.chars_read_total, w.c_str());
    }

    static parse_error create(int id_, std::size_t byte_, const std::string& what_arg)
    {
        std::string w = exception::name("parse_error", id_) + "parse error" +
                        (byte_ != 0 ? (" at byte " + std::to_string(byte_)) : "") +
                        ": " + what_arg;
        return parse_error(id_, byte_, w.c_str());
    }

    /*!
    @brief byte index of the parse error

    The byte index of the last read character in the input file.

    @note For an input with n bytes, 1 is the index of the first character and
          n+1 is the index of the terminating null byte or the end of file.
          This also holds true when reading a byte vector (CBOR or MessagePack).
    */
    const std::size_t byte;

  private:
    parse_error(int id_, std::size_t byte_, const char* what_arg)
        : exception(id_, what_arg), byte(byte_) {}

    static std::string position_string(const position_t& pos)
    {
        return " at line " + std::to_string(pos.lines_read + 1) +
               ", column " + std::to_string(pos.chars_read_current_line);
    }
};

/*!
@brief exception indicating errors with iterators

This exception is thrown if iterators passed to a library function do not match
the expected semantics.

Exceptions have ids 2xx.

name / id                           | example message | description
----------------------------------- | --------------- | -------------------------
json.exception.invalid_iterator.201 | iterators are not compatible | The iterators passed to constructor @ref basic_json(InputIT first, InputIT last) are not compatible, meaning they do not belong to the same container. Therefore, the range (@a first, @a last) is invalid.
json.exception.invalid_iterator.202 | iterator does not fit current value | In an erase or insert function, the passed iterator @a pos does not belong to the JSON value for which the function was called. It hence does not define a valid position for the deletion/insertion.
json.exception.invalid_iterator.203 | iterators do not fit current value | Either iterator passed to function @ref erase(IteratorType first, IteratorType last) does not belong to the JSON value from which values shall be erased. It hence does not define a valid range to delete values from.
json.exception.invalid_iterator.204 | iterators out of range | When an iterator range for a primitive type (number, boolean, or string) is passed to a constructor or an erase function, this range has to be exactly (@ref begin(), @ref end()), because this is the only way the single stored value is expressed. All other ranges are invalid.
json.exception.invalid_iterator.205 | iterator out of range | When an iterator for a primitive type (number, boolean, or string) is passed to an erase function, the iterator has to be the @ref begin() iterator, because it is the only way to address the stored value. All other iterators are invalid.
json.exception.invalid_iterator.206 | cannot construct with iterators from null | The iterators passed to constructor @ref basic_json(InputIT first, InputIT last) belong to a JSON null value and hence to not define a valid range.
json.exception.invalid_iterator.207 | cannot use key() for non-object iterators | The key() member function can only be used on iterators belonging to a JSON object, because other types do not have a concept of a key.
json.exception.invalid_iterator.208 | cannot use operator[] for object iterators | The operator[] to specify a concrete offset cannot be used on iterators belonging to a JSON object, because JSON objects are unordered.
json.exception.invalid_iterator.209 | cannot use offsets with object iterators | The offset operators (+, -, +=, -=) cannot be used on iterators belonging to a JSON object, because JSON objects are unordered.
json.exception.invalid_iterator.210 | iterators do not fit | The iterator range passed to the insert function are not compatible, meaning they do not belong to the same container. Therefore, the range (@a first, @a last) is invalid.
json.exception.invalid_iterator.211 | passed iterators may not belong to container | The iterator range passed to the insert function must not be a subrange of the container to insert to.
json.exception.invalid_iterator.212 | cannot compare iterators of different containers | When two iterators are compared, they must belong to the same container.
json.exception.invalid_iterator.213 | cannot compare order of object iterators | The order of object iterators cannot be compared, because JSON objects are unordered.
json.exception.invalid_iterator.214 | cannot get value | Cannot get value for iterator: Either the iterator belongs to a null value or it is an iterator to a primitive type (number, boolean, or string), but the iterator is different to @ref begin().

@liveexample{The following code shows how an `invalid_iterator` exception can be
caught.,invalid_iterator}

@sa - @ref exception for the base class of the library exceptions
@sa - @ref parse_error for exceptions indicating a parse error
@sa - @ref type_error for exceptions indicating executing a member function with
                    a wrong type
@sa - @ref out_of_range for exceptions indicating access out of the defined range
@sa - @ref other_error for exceptions indicating other library errors

@since version 3.0.0
*/
class invalid_iterator : public exception
{
  public:
    static invalid_iterator create(int id_, const std::string& what_arg)
    {
        std::string w = exception::name("invalid_iterator", id_) + what_arg;
        return invalid_iterator(id_, w.c_str());
    }

  private:
    JSON_HEDLEY_NON_NULL(3)
    invalid_iterator(int id_, const char* what_arg)
        : exception(id_, what_arg) {}
};

/*!
@brief exception indicating executing a member function with a wrong type

This exception is thrown in case of a type error; that is, a library function is
executed on a JSON value whose type does not match the expected semantics.

Exceptions have ids 3xx.

name / id                     | example message | description
----------------------------- | --------------- | -------------------------
json.exception.type_error.301 | cannot create object from initializer list | To create an object from an initializer list, the initializer list must consist only of a list of pairs whose first element is a string. When this constraint is violated, an array is created instead.
json.exception.type_error.302 | type must be object, but is array | During implicit or explicit value conversion, the JSON type must be compatible to the target type. For instance, a JSON string can only be converted into string types, but not into numbers or boolean types.
json.exception.type_error.303 | incompatible ReferenceType for get_ref, actual type is object | To retrieve a reference to a value stored in a @ref basic_json object with @ref get_ref, the type of the reference must match the value type. For instance, for a JSON array, the @a ReferenceType must be @ref array_t &.
json.exception.type_error.304 | cannot use at() with string | The @ref at() member functions can only be executed for certain JSON types.
json.exception.type_error.305 | cannot use operator[] with string | The @ref operator[] member functions can only be executed for certain JSON types.
json.exception.type_error.306 | cannot use value() with string | The @ref value() member functions can only be executed for certain JSON types.
json.exception.type_error.307 | cannot use erase() with string | The @ref erase() member functions can only be executed for certain JSON types.
json.exception.type_error.308 | cannot use push_back() with string | The @ref push_back() and @ref operator+= member functions can only be executed for certain JSON types.
json.exception.type_error.309 | cannot use insert() with | The @ref insert() member functions can only be executed for certain JSON types.
json.exception.type_error.310 | cannot use swap() with number | The @ref swap() member functions can only be executed for certain JSON types.
json.exception.type_error.311 | cannot use emplace_back() with string | The @ref emplace_back() member function can only be executed for certain JSON types.
json.exception.type_error.312 | cannot use update() with string | The @ref update() member functions can only be executed for certain JSON types.
json.exception.type_error.313 | invalid value to unflatten | The @ref unflatten function converts an object whose keys are JSON Pointers back into an arbitrary nested JSON value. The JSON Pointers must not overlap, because then the resulting value would not be well defined.
json.exception.type_error.314 | only objects can be unflattened | The @ref unflatten function only works for an object whose keys are JSON Pointers.
json.exception.type_error.315 | values in object must be primitive | The @ref unflatten function only works for an object whose keys are JSON Pointers and whose values are primitive.
json.exception.type_error.316 | invalid UTF-8 byte at index 10: 0x7E | The @ref dump function only works with UTF-8 encoded strings; that is, if you assign a `std::string` to a JSON value, make sure it is UTF-8 encoded. |
json.exception.type_error.317 | JSON value cannot be serialized to requested format | The dynamic type of the object cannot be represented in the requested serialization format (e.g. a raw `true` or `null` JSON object cannot be serialized to BSON) |

@liveexample{The following code shows how a `type_error` exception can be
caught.,type_error}

@sa - @ref exception for the base class of the library exceptions
@sa - @ref parse_error for exceptions indicating a parse error
@sa - @ref invalid_iterator for exceptions indicating errors with iterators
@sa - @ref out_of_range for exceptions indicating access out of the defined range
@sa - @ref other_error for exceptions indicating other library errors

@since version 3.0.0
*/
class type_error : public exception
{
  public:
    static type_error create(int id_, const std::string& what_arg)
    {
        std::string w = exception::name("type_error", id_) + what_arg;
        return type_error(id_, w.c_str());
    }

  private:
    JSON_HEDLEY_NON_NULL(3)
    type_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
};

/*!
@brief exception indicating access out of the defined range

This exception is thrown in case a library function is called on an input
parameter that exceeds the expected range, for instance in case of array
indices or nonexisting object keys.

Exceptions have ids 4xx.

name / id                       | example message | description
------------------------------- | --------------- | -------------------------
json.exception.out_of_range.401 | array index 3 is out of range | The provided array index @a i is larger than @a size-1.
json.exception.out_of_range.402 | array index '-' (3) is out of range | The special array index `-` in a JSON Pointer never describes a valid element of the array, but the index past the end. That is, it can only be used to add elements at this position, but not to read it.
json.exception.out_of_range.403 | key 'foo' not found | The provided key was not found in the JSON object.
json.exception.out_of_range.404 | unresolved reference token 'foo' | A reference token in a JSON Pointer could not be resolved.
json.exception.out_of_range.405 | JSON pointer has no parent | The JSON Patch operations 'remove' and 'add' can not be applied to the root element of the JSON value.
json.exception.out_of_range.406 | number overflow parsing '10E1000' | A parsed number could not be stored as without changing it to NaN or INF.
json.exception.out_of_range.407 | number overflow serializing '9223372036854775808' | UBJSON and BSON only support integer numbers up to 9223372036854775807. (until version 3.8.0) |
json.exception.out_of_range.408 | excessive array size: 8658170730974374167 | The size (following `#`) of an UBJSON array or object exceeds the maximal capacity. |
json.exception.out_of_range.409 | BSON key cannot contain code point U+0000 (at byte 2) | Key identifiers to be serialized to BSON cannot contain code point U+0000, since the key is stored as zero-terminated c-string |

@liveexample{The following code shows how an `out_of_range` exception can be
caught.,out_of_range}

@sa - @ref exception for the base class of the library exceptions
@sa - @ref parse_error for exceptions indicating a parse error
@sa - @ref invalid_iterator for exceptions indicating errors with iterators
@sa - @ref type_error for exceptions indicating executing a member function with
                    a wrong type
@sa - @ref other_error for exceptions indicating other library errors

@since version 3.0.0
*/
class out_of_range : public exception
{
  public:
    static out_of_range create(int id_, const std::string& what_arg)
    {
        std::string w = exception::name("out_of_range", id_) + what_arg;
        return out_of_range(id_, w.c_str());
    }

  private:
    JSON_HEDLEY_NON_NULL(3)
    out_of_range(int id_, const char* what_arg) : exception(id_, what_arg) {}
};

/*!
@brief exception indicating other library errors

This exception is thrown in case of errors that cannot be classified with the
other exception types.

Exceptions have ids 5xx.

name / id                      | example message | description
------------------------------ | --------------- | -------------------------
json.exception.other_error.501 | unsuccessful: {"op":"test","path":"/baz", "value":"bar"} | A JSON Patch operation 'test' failed. The unsuccessful operation is also printed.

@sa - @ref exception for the base class of the library exceptions
@sa - @ref parse_error for exceptions indicating a parse error
@sa - @ref invalid_iterator for exceptions indicating errors with iterators
@sa - @ref type_error for exceptions indicating executing a member function with
                    a wrong type
@sa - @ref out_of_range for exceptions indicating access out of the defined range

@liveexample{The following code shows how an `other_error` exception can be
caught.,other_error}

@since version 3.0.0
*/
class other_error : public exception
{
  public:
    static other_error create(int id_, const std::string& what_arg)
    {
        std::string w = exception::name("other_error", id_) + what_arg;
        return other_error(id_, w.c_str());
    }

  private:
    JSON_HEDLEY_NON_NULL(3)
    other_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>


#include <cstddef> // size_t
#include <type_traits> // conditional, enable_if, false_type, integral_constant, is_constructible, is_integral, is_same, remove_cv, remove_reference, true_type

namespace nlohmann
{
namespace detail
{
// alias templates to reduce boilerplate
template<bool B, typename T = void>
using enable_if_t = typename std::enable_if<B, T>::type;

template<typename T>
using uncvref_t = typename std::remove_cv<typename std::remove_reference<T>::type>::type;

// implementation of C++14 index_sequence and affiliates
// source: https://stackoverflow.com/a/32223343
template<std::size_t... Ints>
struct index_sequence
{
    using type = index_sequence;
    using value_type = std::size_t;
    static constexpr std::size_t size() noexcept
    {
        return sizeof...(Ints);
    }
};

template<class Sequence1, class Sequence2>
struct merge_and_renumber;

template<std::size_t... I1, std::size_t... I2>
struct merge_and_renumber<index_sequence<I1...>, index_sequence<I2...>>
        : index_sequence < I1..., (sizeof...(I1) + I2)... > {};

template<std::size_t N>
struct make_index_sequence
    : merge_and_renumber < typename make_index_sequence < N / 2 >::type,
      typename make_index_sequence < N - N / 2 >::type > {};

template<> struct make_index_sequence<0> : index_sequence<> {};
template<> struct make_index_sequence<1> : index_sequence<0> {};

template<typename... Ts>
using index_sequence_for = make_index_sequence<sizeof...(Ts)>;

// dispatch utility (taken from ranges-v3)
template<unsigned N> struct priority_tag : priority_tag < N - 1 > {};
template<> struct priority_tag<0> {};

// taken from ranges-v3
template<typename T>
struct static_const
{
    static constexpr T value{};
};

template<typename T>
constexpr T static_const<T>::value;
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/meta/type_traits.hpp>


#include <limits> // numeric_limits
#include <type_traits> // false_type, is_constructible, is_integral, is_same, true_type
#include <utility> // declval

// #include <nlohmann/detail/iterators/iterator_traits.hpp>


#include <iterator> // random_access_iterator_tag

// #include <nlohmann/detail/meta/void_t.hpp>


namespace nlohmann
{
namespace detail
{
template<typename ...Ts> struct make_void
{
    using type = void;
};
template<typename ...Ts> using void_t = typename make_void<Ts...>::type;
} // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/meta/cpp_future.hpp>


namespace nlohmann
{
namespace detail
{
template<typename It, typename = void>
struct iterator_types {};

template<typename It>
struct iterator_types <
    It,
    void_t<typename It::difference_type, typename It::value_type, typename It::pointer,
    typename It::reference, typename It::iterator_category >>
{
    using difference_type = typename It::difference_type;
    using value_type = typename It::value_type;
    using pointer = typename It::pointer;
    using reference = typename It::reference;
    using iterator_category = typename It::iterator_category;
};

// This is required as some compilers implement std::iterator_traits in a way that
// doesn't work with SFINAE. See https://github.com/nlohmann/json/issues/1341.
template<typename T, typename = void>
struct iterator_traits
{
};

template<typename T>
struct iterator_traits < T, enable_if_t < !std::is_pointer<T>::value >>
            : iterator_types<T>
{
};

template<typename T>
struct iterator_traits<T*, enable_if_t<std::is_object<T>::value>>
{
    using iterator_category = std::random_access_iterator_tag;
    using value_type = T;
    using difference_type = ptrdiff_t;
    using pointer = T*;
    using reference = T&;
};
} // namespace detail
} // namespace nlohmann

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/detected.hpp>


#include <type_traits>

// #include <nlohmann/detail/meta/void_t.hpp>


// https://en.cppreference.com/w/cpp/experimental/is_detected
namespace nlohmann
{
namespace detail
{
struct nonesuch
{
    nonesuch() = delete;
    ~nonesuch() = delete;
    nonesuch(nonesuch const&) = delete;
    nonesuch(nonesuch const&&) = delete;
    void operator=(nonesuch const&) = delete;
    void operator=(nonesuch&&) = delete;
};

template<class Default,
         class AlwaysVoid,
         template<class...> class Op,
         class... Args>
struct detector
{
    using value_t = std::false_type;
    using type = Default;
};

template<class Default, template<class...> class Op, class... Args>
struct detector<Default, void_t<Op<Args...>>, Op, Args...>
{
    using value_t = std::true_type;
    using type = Op<Args...>;
};

template<template<class...> class Op, class... Args>
using is_detected = typename detector<nonesuch, void, Op, Args...>::value_t;

template<template<class...> class Op, class... Args>
using detected_t = typename detector<nonesuch, void, Op, Args...>::type;

template<class Default, template<class...> class Op, class... Args>
using detected_or = detector<Default, void, Op, Args...>;

template<class Default, template<class...> class Op, class... Args>
using detected_or_t = typename detected_or<Default, Op, Args...>::type;

template<class Expected, template<class...> class Op, class... Args>
using is_detected_exact = std::is_same<Expected, detected_t<Op, Args...>>;

template<class To, template<class...> class Op, class... Args>
using is_detected_convertible =
    std::is_convertible<detected_t<Op, Args...>, To>;
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/json_fwd.hpp>
#ifndef INCLUDE_NLOHMANN_JSON_FWD_HPP_
#define INCLUDE_NLOHMANN_JSON_FWD_HPP_

#include <cstdint> // int64_t, uint64_t
#include <map> // map
#include <memory> // allocator
#include <string> // string
#include <vector> // vector

/*!
@brief namespace for Niels Lohmann
@see https://github.com/nlohmann
@since version 1.0.0
*/
namespace nlohmann
{
/*!
@brief default JSONSerializer template argument

This serializer ignores the template arguments and uses ADL
([argument-dependent lookup](https://en.cppreference.com/w/cpp/language/adl))
for serialization.
*/
template<typename T = void, typename SFINAE = void>
struct adl_serializer;

template<template<typename U, typename V, typename... Args> class ObjectType =
         std::map,
         template<typename U, typename... Args> class ArrayType = std::vector,
         class StringType = std::string, class BooleanType = bool,
         class NumberIntegerType = std::int64_t,
         class NumberUnsignedType = std::uint64_t,
         class NumberFloatType = double,
         template<typename U> class AllocatorType = std::allocator,
         template<typename T, typename SFINAE = void> class JSONSerializer =
         adl_serializer,
         class BinaryType = std::vector<std::uint8_t>>
class basic_json;

/*!
@brief JSON Pointer

A JSON pointer defines a string syntax for identifying a specific value
within a JSON document. It can be used with functions `at` and
`operator[]`. Furthermore, JSON pointers are the base for JSON patches.

@sa [RFC 6901](https://tools.ietf.org/html/rfc6901)

@since version 2.0.0
*/
template<typename BasicJsonType>
class json_pointer;

/*!
@brief default JSON class

This type is the default specialization of the @ref basic_json class which
uses the standard template types.

@since version 1.0.0
*/
using json = basic_json<>;

template<class Key, class T, class IgnoredLess, class Allocator>
struct ordered_map;

/*!
@brief ordered JSON class

This type preserves the insertion order of object keys.

@since version 3.9.0
*/
using ordered_json = basic_json<nlohmann::ordered_map>;

}  // namespace nlohmann

#endif  // INCLUDE_NLOHMANN_JSON_FWD_HPP_


namespace nlohmann
{
/*!
@brief detail namespace with internal helper functions

This namespace collects functions that should not be exposed,
implementations of some @ref basic_json methods, and meta-programming helpers.

@since version 2.1.0
*/
namespace detail
{
/////////////
// helpers //
/////////////

// Note to maintainers:
//
// Every trait in this file expects a non CV-qualified type.
// The only exceptions are in the 'aliases for detected' section
// (i.e. those of the form: decltype(T::member_function(std::declval<T>())))
//
// In this case, T has to be properly CV-qualified to constraint the function arguments
// (e.g. to_json(BasicJsonType&, const T&))

template<typename> struct is_basic_json : std::false_type {};

NLOHMANN_BASIC_JSON_TPL_DECLARATION
struct is_basic_json<NLOHMANN_BASIC_JSON_TPL> : std::true_type {};

//////////////////////
// json_ref helpers //
//////////////////////

template<typename>
class json_ref;

template<typename>
struct is_json_ref : std::false_type {};

template<typename T>
struct is_json_ref<json_ref<T>> : std::true_type {};

//////////////////////////
// aliases for detected //
//////////////////////////

template<typename T>
using mapped_type_t = typename T::mapped_type;

template<typename T>
using key_type_t = typename T::key_type;

template<typename T>
using value_type_t = typename T::value_type;

template<typename T>
using difference_type_t = typename T::difference_type;

template<typename T>
using pointer_t = typename T::pointer;

template<typename T>
using reference_t = typename T::reference;

template<typename T>
using iterator_category_t = typename T::iterator_category;

template<typename T>
using iterator_t = typename T::iterator;

template<typename T, typename... Args>
using to_json_function = decltype(T::to_json(std::declval<Args>()...));

template<typename T, typename... Args>
using from_json_function = decltype(T::from_json(std::declval<Args>()...));

template<typename T, typename U>
using get_template_function = decltype(std::declval<T>().template get<U>());

// trait checking if JSONSerializer<T>::from_json(json const&, udt&) exists
template<typename BasicJsonType, typename T, typename = void>
struct has_from_json : std::false_type {};

// trait checking if j.get<T> is valid
// use this trait instead of std::is_constructible or std::is_convertible,
// both rely on, or make use of implicit conversions, and thus fail when T
// has several constructors/operator= (see https://github.com/nlohmann/json/issues/958)
template <typename BasicJsonType, typename T>
struct is_getable
{
    static constexpr bool value = is_detected<get_template_function, const BasicJsonType&, T>::value;
};

template<typename BasicJsonType, typename T>
struct has_from_json < BasicJsonType, T,
           enable_if_t < !is_basic_json<T>::value >>
{
    using serializer = typename BasicJsonType::template json_serializer<T, void>;

    static constexpr bool value =
        is_detected_exact<void, from_json_function, serializer,
        const BasicJsonType&, T&>::value;
};

// This trait checks if JSONSerializer<T>::from_json(json const&) exists
// this overload is used for non-default-constructible user-defined-types
template<typename BasicJsonType, typename T, typename = void>
struct has_non_default_from_json : std::false_type {};

template<typename BasicJsonType, typename T>
struct has_non_default_from_json < BasicJsonType, T, enable_if_t < !is_basic_json<T>::value >>
{
    using serializer = typename BasicJsonType::template json_serializer<T, void>;

    static constexpr bool value =
        is_detected_exact<T, from_json_function, serializer,
        const BasicJsonType&>::value;
};

// This trait checks if BasicJsonType::json_serializer<T>::to_json exists
// Do not evaluate the trait when T is a basic_json type, to avoid template instantiation infinite recursion.
template<typename BasicJsonType, typename T, typename = void>
struct has_to_json : std::false_type {};

template<typename BasicJsonType, typename T>
struct has_to_json < BasicJsonType, T, enable_if_t < !is_basic_json<T>::value >>
{
    using serializer = typename BasicJsonType::template json_serializer<T, void>;

    static constexpr bool value =
        is_detected_exact<void, to_json_function, serializer, BasicJsonType&,
        T>::value;
};


///////////////////
// is_ functions //
///////////////////

template<typename T, typename = void>
struct is_iterator_traits : std::false_type {};

template<typename T>
struct is_iterator_traits<iterator_traits<T>>
{
  private:
    using traits = iterator_traits<T>;

  public:
    static constexpr auto value =
        is_detected<value_type_t, traits>::value &&
        is_detected<difference_type_t, traits>::value &&
        is_detected<pointer_t, traits>::value &&
        is_detected<iterator_category_t, traits>::value &&
        is_detected<reference_t, traits>::value;
};

// source: https://stackoverflow.com/a/37193089/4116453

template<typename T, typename = void>
struct is_complete_type : std::false_type {};

template<typename T>
struct is_complete_type<T, decltype(void(sizeof(T)))> : std::true_type {};

template<typename BasicJsonType, typename CompatibleObjectType,
         typename = void>
struct is_compatible_object_type_impl : std::false_type {};

template<typename BasicJsonType, typename CompatibleObjectType>
struct is_compatible_object_type_impl <
    BasicJsonType, CompatibleObjectType,
    enable_if_t < is_detected<mapped_type_t, CompatibleObjectType>::value&&
    is_detected<key_type_t, CompatibleObjectType>::value >>
{

    using object_t = typename BasicJsonType::object_t;

    // macOS's is_constructible does not play well with nonesuch...
    static constexpr bool value =
        std::is_constructible<typename object_t::key_type,
        typename CompatibleObjectType::key_type>::value &&
        std::is_constructible<typename object_t::mapped_type,
        typename CompatibleObjectType::mapped_type>::value;
};

template<typename BasicJsonType, typename CompatibleObjectType>
struct is_compatible_object_type
    : is_compatible_object_type_impl<BasicJsonType, CompatibleObjectType> {};

template<typename BasicJsonType, typename ConstructibleObjectType,
         typename = void>
struct is_constructible_object_type_impl : std::false_type {};

template<typename BasicJsonType, typename ConstructibleObjectType>
struct is_constructible_object_type_impl <
    BasicJsonType, ConstructibleObjectType,
    enable_if_t < is_detected<mapped_type_t, ConstructibleObjectType>::value&&
    is_detected<key_type_t, ConstructibleObjectType>::value >>
{
    using object_t = typename BasicJsonType::object_t;

    static constexpr bool value =
        (std::is_default_constructible<ConstructibleObjectType>::value &&
         (std::is_move_assignable<ConstructibleObjectType>::value ||
          std::is_copy_assignable<ConstructibleObjectType>::value) &&
         (std::is_constructible<typename ConstructibleObjectType::key_type,
          typename object_t::key_type>::value &&
          std::is_same <
          typename object_t::mapped_type,
          typename ConstructibleObjectType::mapped_type >::value)) ||
        (has_from_json<BasicJsonType,
         typename ConstructibleObjectType::mapped_type>::value ||
         has_non_default_from_json <
         BasicJsonType,
         typename ConstructibleObjectType::mapped_type >::value);
};

template<typename BasicJsonType, typename ConstructibleObjectType>
struct is_constructible_object_type
    : is_constructible_object_type_impl<BasicJsonType,
      ConstructibleObjectType> {};

template<typename BasicJsonType, typename CompatibleStringType,
         typename = void>
struct is_compatible_string_type_impl : std::false_type {};

template<typename BasicJsonType, typename CompatibleStringType>
struct is_compatible_string_type_impl <
    BasicJsonType, CompatibleStringType,
    enable_if_t<is_detected_exact<typename BasicJsonType::string_t::value_type,
    value_type_t, CompatibleStringType>::value >>
{
    static constexpr auto value =
        std::is_constructible<typename BasicJsonType::string_t, CompatibleStringType>::value;
};

template<typename BasicJsonType, typename ConstructibleStringType>
struct is_compatible_string_type
    : is_compatible_string_type_impl<BasicJsonType, ConstructibleStringType> {};

template<typename BasicJsonType, typename ConstructibleStringType,
         typename = void>
struct is_constructible_string_type_impl : std::false_type {};

template<typename BasicJsonType, typename ConstructibleStringType>
struct is_constructible_string_type_impl <
    BasicJsonType, ConstructibleStringType,
    enable_if_t<is_detected_exact<typename BasicJsonType::string_t::value_type,
    value_type_t, ConstructibleStringType>::value >>
{
    static constexpr auto value =
        std::is_constructible<ConstructibleStringType,
        typename BasicJsonType::string_t>::value;
};

template<typename BasicJsonType, typename ConstructibleStringType>
struct is_constructible_string_type
    : is_constructible_string_type_impl<BasicJsonType, ConstructibleStringType> {};

template<typename BasicJsonType, typename CompatibleArrayType, typename = void>
struct is_compatible_array_type_impl : std::false_type {};

template<typename BasicJsonType, typename CompatibleArrayType>
struct is_compatible_array_type_impl <
    BasicJsonType, CompatibleArrayType,
    enable_if_t < is_detected<value_type_t, CompatibleArrayType>::value&&
    is_detected<iterator_t, CompatibleArrayType>::value&&
// This is needed because json_reverse_iterator has a ::iterator type...
// Therefore it is detected as a CompatibleArrayType.
// The real fix would be to have an Iterable concept.
    !is_iterator_traits <
    iterator_traits<CompatibleArrayType >>::value >>
{
    static constexpr bool value =
        std::is_constructible<BasicJsonType,
        typename CompatibleArrayType::value_type>::value;
};

template<typename BasicJsonType, typename CompatibleArrayType>
struct is_compatible_array_type
    : is_compatible_array_type_impl<BasicJsonType, CompatibleArrayType> {};

template<typename BasicJsonType, typename ConstructibleArrayType, typename = void>
struct is_constructible_array_type_impl : std::false_type {};

template<typename BasicJsonType, typename ConstructibleArrayType>
struct is_constructible_array_type_impl <
    BasicJsonType, ConstructibleArrayType,
    enable_if_t<std::is_same<ConstructibleArrayType,
    typename BasicJsonType::value_type>::value >>
            : std::true_type {};

template<typename BasicJsonType, typename ConstructibleArrayType>
struct is_constructible_array_type_impl <
    BasicJsonType, ConstructibleArrayType,
    enable_if_t < !std::is_same<ConstructibleArrayType,
    typename BasicJsonType::value_type>::value&&
    std::is_default_constructible<ConstructibleArrayType>::value&&
(std::is_move_assignable<ConstructibleArrayType>::value ||
 std::is_copy_assignable<ConstructibleArrayType>::value)&&
is_detected<value_type_t, ConstructibleArrayType>::value&&
is_detected<iterator_t, ConstructibleArrayType>::value&&
is_complete_type <
detected_t<value_type_t, ConstructibleArrayType >>::value >>
{
    static constexpr bool value =
        // This is needed because json_reverse_iterator has a ::iterator type,
        // furthermore, std::back_insert_iterator (and other iterators) have a
        // base class `iterator`... Therefore it is detected as a
        // ConstructibleArrayType. The real fix would be to have an Iterable
        // concept.
        !is_iterator_traits<iterator_traits<ConstructibleArrayType>>::value &&

        (std::is_same<typename ConstructibleArrayType::value_type,
         typename BasicJsonType::array_t::value_type>::value ||
         has_from_json<BasicJsonType,
         typename ConstructibleArrayType::value_type>::value ||
         has_non_default_from_json <
         BasicJsonType, typename ConstructibleArrayType::value_type >::value);
};

template<typename BasicJsonType, typename ConstructibleArrayType>
struct is_constructible_array_type
    : is_constructible_array_type_impl<BasicJsonType, ConstructibleArrayType> {};

template<typename RealIntegerType, typename CompatibleNumberIntegerType,
         typename = void>
struct is_compatible_integer_type_impl : std::false_type {};

template<typename RealIntegerType, typename CompatibleNumberIntegerType>
struct is_compatible_integer_type_impl <
    RealIntegerType, CompatibleNumberIntegerType,
    enable_if_t < std::is_integral<RealIntegerType>::value&&
    std::is_integral<CompatibleNumberIntegerType>::value&&
    !std::is_same<bool, CompatibleNumberIntegerType>::value >>
{
    // is there an assert somewhere on overflows?
    using RealLimits = std::numeric_limits<RealIntegerType>;
    using CompatibleLimits = std::numeric_limits<CompatibleNumberIntegerType>;

    static constexpr auto value =
        std::is_constructible<RealIntegerType,
        CompatibleNumberIntegerType>::value &&
        CompatibleLimits::is_integer &&
        RealLimits::is_signed == CompatibleLimits::is_signed;
};

template<typename RealIntegerType, typename CompatibleNumberIntegerType>
struct is_compatible_integer_type
    : is_compatible_integer_type_impl<RealIntegerType,
      CompatibleNumberIntegerType> {};

template<typename BasicJsonType, typename CompatibleType, typename = void>
struct is_compatible_type_impl: std::false_type {};

template<typename BasicJsonType, typename CompatibleType>
struct is_compatible_type_impl <
    BasicJsonType, CompatibleType,
    enable_if_t<is_complete_type<CompatibleType>::value >>
{
    static constexpr bool value =
        has_to_json<BasicJsonType, CompatibleType>::value;
};

template<typename BasicJsonType, typename CompatibleType>
struct is_compatible_type
    : is_compatible_type_impl<BasicJsonType, CompatibleType> {};

// https://en.cppreference.com/w/cpp/types/conjunction
template<class...> struct conjunction : std::true_type { };
template<class B1> struct conjunction<B1> : B1 { };
template<class B1, class... Bn>
struct conjunction<B1, Bn...>
: std::conditional<bool(B1::value), conjunction<Bn...>, B1>::type {};

template<typename T1, typename T2>
struct is_constructible_tuple : std::false_type {};

template<typename T1, typename... Args>
struct is_constructible_tuple<T1, std::tuple<Args...>> : conjunction<std::is_constructible<T1, Args>...> {};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/value_t.hpp>


#include <array> // array
#include <cstddef> // size_t
#include <cstdint> // uint8_t
#include <string> // string

namespace nlohmann
{
namespace detail
{
///////////////////////////
// JSON type enumeration //
///////////////////////////

/*!
@brief the JSON type enumeration

This enumeration collects the different JSON types. It is internally used to
distinguish the stored values, and the functions @ref basic_json::is_null(),
@ref basic_json::is_object(), @ref basic_json::is_array(),
@ref basic_json::is_string(), @ref basic_json::is_boolean(),
@ref basic_json::is_number() (with @ref basic_json::is_number_integer(),
@ref basic_json::is_number_unsigned(), and @ref basic_json::is_number_float()),
@ref basic_json::is_discarded(), @ref basic_json::is_primitive(), and
@ref basic_json::is_structured() rely on it.

@note There are three enumeration entries (number_integer, number_unsigned, and
number_float), because the library distinguishes these three types for numbers:
@ref basic_json::number_unsigned_t is used for unsigned integers,
@ref basic_json::number_integer_t is used for signed integers, and
@ref basic_json::number_float_t is used for floating-point numbers or to
approximate integers which do not fit in the limits of their respective type.

@sa @ref basic_json::basic_json(const value_t value_type) -- create a JSON
value with the default value for a given type

@since version 1.0.0
*/
enum class value_t : std::uint8_t
{
    null,             ///< null value
    object,           ///< object (unordered set of name/value pairs)
    array,            ///< array (ordered collection of values)
    string,           ///< string value
    boolean,          ///< boolean value
    number_integer,   ///< number value (signed integer)
    number_unsigned,  ///< number value (unsigned integer)
    number_float,     ///< number value (floating-point)
    binary,           ///< binary array (ordered collection of bytes)
    discarded         ///< discarded by the parser callback function
};

/*!
@brief comparison operator for JSON types

Returns an ordering that is similar to Python:
- order: null < boolean < number < object < array < string < binary
- furthermore, each type is not smaller than itself
- discarded values are not comparable
- binary is represented as a b"" string in python and directly comparable to a
  string; however, making a binary array directly comparable with a string would
  be surprising behavior in a JSON file.

@since version 1.0.0
*/
inline bool operator<(const value_t lhs, const value_t rhs) noexcept
{
    static constexpr std::array<std::uint8_t, 9> order = {{
            0 /* null */, 3 /* object */, 4 /* array */, 5 /* string */,
            1 /* boolean */, 2 /* integer */, 2 /* unsigned */, 2 /* float */,
            6 /* binary */
        }
    };

    const auto l_index = static_cast<std::size_t>(lhs);
    const auto r_index = static_cast<std::size_t>(rhs);
    return l_index < order.size() && r_index < order.size() && order[l_index] < order[r_index];
}
}  // namespace detail
}  // namespace nlohmann


namespace nlohmann
{
namespace detail
{
template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename std::nullptr_t& n)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_null()))
    {
        JSON_THROW(type_error::create(302, "type must be null, but is " + std::string(j.type_name())));
    }
    n = nullptr;
}

// overloads for basic_json template parameters
template < typename BasicJsonType, typename ArithmeticType,
           enable_if_t < std::is_arithmetic<ArithmeticType>::value&&
                         !std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,
                         int > = 0 >
void get_arithmetic_value(const BasicJsonType& j, ArithmeticType& val)
{
    switch (static_cast<value_t>(j))
    {
        case value_t::number_unsigned:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());
            break;
        }
        case value_t::number_integer:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());
            break;
        }
        case value_t::number_float:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());
            break;
        }

        default:
            JSON_THROW(type_error::create(302, "type must be number, but is " + std::string(j.type_name())));
    }
}

template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename BasicJsonType::boolean_t& b)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_boolean()))
    {
        JSON_THROW(type_error::create(302, "type must be boolean, but is " + std::string(j.type_name())));
    }
    b = *j.template get_ptr<const typename BasicJsonType::boolean_t*>();
}

template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename BasicJsonType::string_t& s)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_string()))
    {
        JSON_THROW(type_error::create(302, "type must be string, but is " + std::string(j.type_name())));
    }
    s = *j.template get_ptr<const typename BasicJsonType::string_t*>();
}

template <
    typename BasicJsonType, typename ConstructibleStringType,
    enable_if_t <
        is_constructible_string_type<BasicJsonType, ConstructibleStringType>::value&&
        !std::is_same<typename BasicJsonType::string_t,
                      ConstructibleStringType>::value,
        int > = 0 >
void from_json(const BasicJsonType& j, ConstructibleStringType& s)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_string()))
    {
        JSON_THROW(type_error::create(302, "type must be string, but is " + std::string(j.type_name())));
    }

    s = *j.template get_ptr<const typename BasicJsonType::string_t*>();
}

template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename BasicJsonType::number_float_t& val)
{
    get_arithmetic_value(j, val);
}

template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename BasicJsonType::number_unsigned_t& val)
{
    get_arithmetic_value(j, val);
}

template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename BasicJsonType::number_integer_t& val)
{
    get_arithmetic_value(j, val);
}

template<typename BasicJsonType, typename EnumType,
         enable_if_t<std::is_enum<EnumType>::value, int> = 0>
void from_json(const BasicJsonType& j, EnumType& e)
{
    typename std::underlying_type<EnumType>::type val;
    get_arithmetic_value(j, val);
    e = static_cast<EnumType>(val);
}

// forward_list doesn't have an insert method
template<typename BasicJsonType, typename T, typename Allocator,
         enable_if_t<is_getable<BasicJsonType, T>::value, int> = 0>
void from_json(const BasicJsonType& j, std::forward_list<T, Allocator>& l)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name())));
    }
    l.clear();
    std::transform(j.rbegin(), j.rend(),
                   std::front_inserter(l), [](const BasicJsonType & i)
    {
        return i.template get<T>();
    });
}

// valarray doesn't have an insert method
template<typename BasicJsonType, typename T,
         enable_if_t<is_getable<BasicJsonType, T>::value, int> = 0>
void from_json(const BasicJsonType& j, std::valarray<T>& l)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name())));
    }
    l.resize(j.size());
    std::transform(j.begin(), j.end(), std::begin(l),
                   [](const BasicJsonType & elem)
    {
        return elem.template get<T>();
    });
}

template<typename BasicJsonType, typename T, std::size_t N>
auto from_json(const BasicJsonType& j, T (&arr)[N])
-> decltype(j.template get<T>(), void())
{
    for (std::size_t i = 0; i < N; ++i)
    {
        arr[i] = j.at(i).template get<T>();
    }
}

template<typename BasicJsonType>
void from_json_array_impl(const BasicJsonType& j, typename BasicJsonType::array_t& arr, priority_tag<3> /*unused*/)
{
    arr = *j.template get_ptr<const typename BasicJsonType::array_t*>();
}

template<typename BasicJsonType, typename T, std::size_t N>
auto from_json_array_impl(const BasicJsonType& j, std::array<T, N>& arr,
                          priority_tag<2> /*unused*/)
-> decltype(j.template get<T>(), void())
{
    for (std::size_t i = 0; i < N; ++i)
    {
        arr[i] = j.at(i).template get<T>();
    }
}

template<typename BasicJsonType, typename ConstructibleArrayType>
auto from_json_array_impl(const BasicJsonType& j, ConstructibleArrayType& arr, priority_tag<1> /*unused*/)
-> decltype(
    arr.reserve(std::declval<typename ConstructibleArrayType::size_type>()),
    j.template get<typename ConstructibleArrayType::value_type>(),
    void())
{
    using std::end;

    ConstructibleArrayType ret;
    ret.reserve(j.size());
    std::transform(j.begin(), j.end(),
                   std::inserter(ret, end(ret)), [](const BasicJsonType & i)
    {
        // get<BasicJsonType>() returns *this, this won't call a from_json
        // method when value_type is BasicJsonType
        return i.template get<typename ConstructibleArrayType::value_type>();
    });
    arr = std::move(ret);
}

template<typename BasicJsonType, typename ConstructibleArrayType>
void from_json_array_impl(const BasicJsonType& j, ConstructibleArrayType& arr,
                          priority_tag<0> /*unused*/)
{
    using std::end;

    ConstructibleArrayType ret;
    std::transform(
        j.begin(), j.end(), std::inserter(ret, end(ret)),
        [](const BasicJsonType & i)
    {
        // get<BasicJsonType>() returns *this, this won't call a from_json
        // method when value_type is BasicJsonType
        return i.template get<typename ConstructibleArrayType::value_type>();
    });
    arr = std::move(ret);
}

template < typename BasicJsonType, typename ConstructibleArrayType,
           enable_if_t <
               is_constructible_array_type<BasicJsonType, ConstructibleArrayType>::value&&
               !is_constructible_object_type<BasicJsonType, ConstructibleArrayType>::value&&
               !is_constructible_string_type<BasicJsonType, ConstructibleArrayType>::value&&
               !std::is_same<ConstructibleArrayType, typename BasicJsonType::binary_t>::value&&
               !is_basic_json<ConstructibleArrayType>::value,
               int > = 0 >
auto from_json(const BasicJsonType& j, ConstructibleArrayType& arr)
-> decltype(from_json_array_impl(j, arr, priority_tag<3> {}),
j.template get<typename ConstructibleArrayType::value_type>(),
void())
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, "type must be array, but is " +
                                      std::string(j.type_name())));
    }

    from_json_array_impl(j, arr, priority_tag<3> {});
}

template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename BasicJsonType::binary_t& bin)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_binary()))
    {
        JSON_THROW(type_error::create(302, "type must be binary, but is " + std::string(j.type_name())));
    }

    bin = *j.template get_ptr<const typename BasicJsonType::binary_t*>();
}

template<typename BasicJsonType, typename ConstructibleObjectType,
         enable_if_t<is_constructible_object_type<BasicJsonType, ConstructibleObjectType>::value, int> = 0>
void from_json(const BasicJsonType& j, ConstructibleObjectType& obj)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_object()))
    {
        JSON_THROW(type_error::create(302, "type must be object, but is " + std::string(j.type_name())));
    }

    ConstructibleObjectType ret;
    auto inner_object = j.template get_ptr<const typename BasicJsonType::object_t*>();
    using value_type = typename ConstructibleObjectType::value_type;
    std::transform(
        inner_object->begin(), inner_object->end(),
        std::inserter(ret, ret.begin()),
        [](typename BasicJsonType::object_t::value_type const & p)
    {
        return value_type(p.first, p.second.template get<typename ConstructibleObjectType::mapped_type>());
    });
    obj = std::move(ret);
}

// overload for arithmetic types, not chosen for basic_json template arguments
// (BooleanType, etc..); note: Is it really necessary to provide explicit
// overloads for boolean_t etc. in case of a custom BooleanType which is not
// an arithmetic type?
template < typename BasicJsonType, typename ArithmeticType,
           enable_if_t <
               std::is_arithmetic<ArithmeticType>::value&&
               !std::is_same<ArithmeticType, typename BasicJsonType::number_unsigned_t>::value&&
               !std::is_same<ArithmeticType, typename BasicJsonType::number_integer_t>::value&&
               !std::is_same<ArithmeticType, typename BasicJsonType::number_float_t>::value&&
               !std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,
               int > = 0 >
void from_json(const BasicJsonType& j, ArithmeticType& val)
{
    switch (static_cast<value_t>(j))
    {
        case value_t::number_unsigned:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());
            break;
        }
        case value_t::number_integer:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());
            break;
        }
        case value_t::number_float:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());
            break;
        }
        case value_t::boolean:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::boolean_t*>());
            break;
        }

        default:
            JSON_THROW(type_error::create(302, "type must be number, but is " + std::string(j.type_name())));
    }
}

template<typename BasicJsonType, typename A1, typename A2>
void from_json(const BasicJsonType& j, std::pair<A1, A2>& p)
{
    p = {j.at(0).template get<A1>(), j.at(1).template get<A2>()};
}

template<typename BasicJsonType, typename Tuple, std::size_t... Idx>
void from_json_tuple_impl(const BasicJsonType& j, Tuple& t, index_sequence<Idx...> /*unused*/)
{
    t = std::make_tuple(j.at(Idx).template get<typename std::tuple_element<Idx, Tuple>::type>()...);
}

template<typename BasicJsonType, typename... Args>
void from_json(const BasicJsonType& j, std::tuple<Args...>& t)
{
    from_json_tuple_impl(j, t, index_sequence_for<Args...> {});
}

template < typename BasicJsonType, typename Key, typename Value, typename Compare, typename Allocator,
           typename = enable_if_t < !std::is_constructible <
                                        typename BasicJsonType::string_t, Key >::value >>
void from_json(const BasicJsonType& j, std::map<Key, Value, Compare, Allocator>& m)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name())));
    }
    m.clear();
    for (const auto& p : j)
    {
        if (JSON_HEDLEY_UNLIKELY(!p.is_array()))
        {
            JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(p.type_name())));
        }
        m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());
    }
}

template < typename BasicJsonType, typename Key, typename Value, typename Hash, typename KeyEqual, typename Allocator,
           typename = enable_if_t < !std::is_constructible <
                                        typename BasicJsonType::string_t, Key >::value >>
void from_json(const BasicJsonType& j, std::unordered_map<Key, Value, Hash, KeyEqual, Allocator>& m)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name())));
    }
    m.clear();
    for (const auto& p : j)
    {
        if (JSON_HEDLEY_UNLIKELY(!p.is_array()))
        {
            JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(p.type_name())));
        }
        m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());
    }
}

struct from_json_fn
{
    template<typename BasicJsonType, typename T>
    auto operator()(const BasicJsonType& j, T& val) const
    noexcept(noexcept(from_json(j, val)))
    -> decltype(from_json(j, val), void())
    {
        return from_json(j, val);
    }
};
}  // namespace detail

/// namespace to hold default `from_json` function
/// to see why this is required:
/// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4381.html
namespace
{
constexpr const auto& from_json = detail::static_const<detail::from_json_fn>::value;
} // namespace
} // namespace nlohmann

// #include <nlohmann/detail/conversions/to_json.hpp>


#include <algorithm> // copy
#include <iterator> // begin, end
#include <string> // string
#include <tuple> // tuple, get
#include <type_traits> // is_same, is_constructible, is_floating_point, is_enum, underlying_type
#include <utility> // move, forward, declval, pair
#include <valarray> // valarray
#include <vector> // vector

// #include <nlohmann/detail/iterators/iteration_proxy.hpp>


#include <cstddef> // size_t
#include <iterator> // input_iterator_tag
#include <string> // string, to_string
#include <tuple> // tuple_size, get, tuple_element

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
namespace detail
{
template<typename string_type>
void int_to_string( string_type& target, std::size_t value )
{
    // For ADL
    using std::to_string;
    target = to_string(value);
}
template<typename IteratorType> class iteration_proxy_value
{
  public:
    using difference_type = std::ptrdiff_t;
    using value_type = iteration_proxy_value;
    using pointer = value_type * ;
    using reference = value_type & ;
    using iterator_category = std::input_iterator_tag;
    using string_type = typename std::remove_cv< typename std::remove_reference<decltype( std::declval<IteratorType>().key() ) >::type >::type;

  private:
    /// the iterator
    IteratorType anchor;
    /// an index for arrays (used to create key names)
    std::size_t array_index = 0;
    /// last stringified array index
    mutable std::size_t array_index_last = 0;
    /// a string representation of the array index
    mutable string_type array_index_str = "0";
    /// an empty string (to return a reference for primitive values)
    const string_type empty_str = "";

  public:
    explicit iteration_proxy_value(IteratorType it) noexcept : anchor(it) {}

    /// dereference operator (needed for range-based for)
    iteration_proxy_value& operator*()
    {
        return *this;
    }

    /// increment operator (needed for range-based for)
    iteration_proxy_value& operator++()
    {
        ++anchor;
        ++array_index;

        return *this;
    }

    /// equality operator (needed for InputIterator)
    bool operator==(const iteration_proxy_value& o) const
    {
        return anchor == o.anchor;
    }

    /// inequality operator (needed for range-based for)
    bool operator!=(const iteration_proxy_value& o) const
    {
        return anchor != o.anchor;
    }

    /// return key of the iterator
    const string_type& key() const
    {
        JSON_ASSERT(anchor.m_object != nullptr);

        switch (anchor.m_object->type())
        {
            // use integer array index as key
            case value_t::array:
            {
                if (array_index != array_index_last)
                {
                    int_to_string( array_index_str, array_index );
                    array_index_last = array_index;
                }
                return array_index_str;
            }

            // use key from the object
            case value_t::object:
                return anchor.key();

            // use an empty key for all primitive types
            default:
                return empty_str;
        }
    }

    /// return value of the iterator
    typename IteratorType::reference value() const
    {
        return anchor.value();
    }
};

/// proxy class for the items() function
template<typename IteratorType> class iteration_proxy
{
  private:
    /// the container to iterate
    typename IteratorType::reference container;

  public:
    /// construct iteration proxy from a container
    explicit iteration_proxy(typename IteratorType::reference cont) noexcept
        : container(cont) {}

    /// return iterator begin (needed for range-based for)
    iteration_proxy_value<IteratorType> begin() noexcept
    {
        return iteration_proxy_value<IteratorType>(container.begin());
    }

    /// return iterator end (needed for range-based for)
    iteration_proxy_value<IteratorType> end() noexcept
    {
        return iteration_proxy_value<IteratorType>(container.end());
    }
};
// Structured Bindings Support
// For further reference see https://blog.tartanllama.xyz/structured-bindings/
// And see https://github.com/nlohmann/json/pull/1391
template<std::size_t N, typename IteratorType, enable_if_t<N == 0, int> = 0>
auto get(const nlohmann::detail::iteration_proxy_value<IteratorType>& i) -> decltype(i.key())
{
    return i.key();
}
// Structured Bindings Support
// For further reference see https://blog.tartanllama.xyz/structured-bindings/
// And see https://github.com/nlohmann/json/pull/1391
template<std::size_t N, typename IteratorType, enable_if_t<N == 1, int> = 0>
auto get(const nlohmann::detail::iteration_proxy_value<IteratorType>& i) -> decltype(i.value())
{
    return i.value();
}
}  // namespace detail
}  // namespace nlohmann

// The Addition to the STD Namespace is required to add
// Structured Bindings Support to the iteration_proxy_value class
// For further reference see https://blog.tartanllama.xyz/structured-bindings/
// And see https://github.com/nlohmann/json/pull/1391
namespace std
{
#if defined(__clang__)
    // Fix: https://github.com/nlohmann/json/issues/1401
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wmismatched-tags"
#endif
template<typename IteratorType>
class tuple_size<::nlohmann::detail::iteration_proxy_value<IteratorType>>
            : public std::integral_constant<std::size_t, 2> {};

template<std::size_t N, typename IteratorType>
class tuple_element<N, ::nlohmann::detail::iteration_proxy_value<IteratorType >>
{
  public:
    using type = decltype(
                     get<N>(std::declval <
                            ::nlohmann::detail::iteration_proxy_value<IteratorType >> ()));
};
#if defined(__clang__)
    #pragma clang diagnostic pop
#endif
} // namespace std

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
namespace detail
{
//////////////////
// constructors //
//////////////////

template<value_t> struct external_constructor;

template<>
struct external_constructor<value_t::boolean>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::boolean_t b) noexcept
    {
        j.m_type = value_t::boolean;
        j.m_value = b;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::string>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::string_t& s)
    {
        j.m_type = value_t::string;
        j.m_value = s;
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::string_t&& s)
    {
        j.m_type = value_t::string;
        j.m_value = std::move(s);
        j.assert_invariant();
    }

    template < typename BasicJsonType, typename CompatibleStringType,
               enable_if_t < !std::is_same<CompatibleStringType, typename BasicJsonType::string_t>::value,
                             int > = 0 >
    static void construct(BasicJsonType& j, const CompatibleStringType& str)
    {
        j.m_type = value_t::string;
        j.m_value.string = j.template create<typename BasicJsonType::string_t>(str);
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::binary>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::binary_t& b)
    {
        j.m_type = value_t::binary;
        typename BasicJsonType::binary_t value{b};
        j.m_value = value;
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::binary_t&& b)
    {
        j.m_type = value_t::binary;
        typename BasicJsonType::binary_t value{std::move(b)};
        j.m_value = value;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::number_float>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::number_float_t val) noexcept
    {
        j.m_type = value_t::number_float;
        j.m_value = val;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::number_unsigned>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::number_unsigned_t val) noexcept
    {
        j.m_type = value_t::number_unsigned;
        j.m_value = val;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::number_integer>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::number_integer_t val) noexcept
    {
        j.m_type = value_t::number_integer;
        j.m_value = val;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::array>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::array_t& arr)
    {
        j.m_type = value_t::array;
        j.m_value = arr;
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::array_t&& arr)
    {
        j.m_type = value_t::array;
        j.m_value = std::move(arr);
        j.assert_invariant();
    }

    template < typename BasicJsonType, typename CompatibleArrayType,
               enable_if_t < !std::is_same<CompatibleArrayType, typename BasicJsonType::array_t>::value,
                             int > = 0 >
    static void construct(BasicJsonType& j, const CompatibleArrayType& arr)
    {
        using std::begin;
        using std::end;
        j.m_type = value_t::array;
        j.m_value.array = j.template create<typename BasicJsonType::array_t>(begin(arr), end(arr));
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const std::vector<bool>& arr)
    {
        j.m_type = value_t::array;
        j.m_value = value_t::array;
        j.m_value.array->reserve(arr.size());
        for (const bool x : arr)
        {
            j.m_value.array->push_back(x);
        }
        j.assert_invariant();
    }

    template<typename BasicJsonType, typename T,
             enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>
    static void construct(BasicJsonType& j, const std::valarray<T>& arr)
    {
        j.m_type = value_t::array;
        j.m_value = value_t::array;
        j.m_value.array->resize(arr.size());
        if (arr.size() > 0)
        {
            std::copy(std::begin(arr), std::end(arr), j.m_value.array->begin());
        }
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::object>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::object_t& obj)
    {
        j.m_type = value_t::object;
        j.m_value = obj;
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::object_t&& obj)
    {
        j.m_type = value_t::object;
        j.m_value = std::move(obj);
        j.assert_invariant();
    }

    template < typename BasicJsonType, typename CompatibleObjectType,
               enable_if_t < !std::is_same<CompatibleObjectType, typename BasicJsonType::object_t>::value, int > = 0 >
    static void construct(BasicJsonType& j, const CompatibleObjectType& obj)
    {
        using std::begin;
        using std::end;

        j.m_type = value_t::object;
        j.m_value.object = j.template create<typename BasicJsonType::object_t>(begin(obj), end(obj));
        j.assert_invariant();
    }
};

/////////////
// to_json //
/////////////

template<typename BasicJsonType, typename T,
         enable_if_t<std::is_same<T, typename BasicJsonType::boolean_t>::value, int> = 0>
void to_json(BasicJsonType& j, T b) noexcept
{
    external_constructor<value_t::boolean>::construct(j, b);
}

template<typename BasicJsonType, typename CompatibleString,
         enable_if_t<std::is_constructible<typename BasicJsonType::string_t, CompatibleString>::value, int> = 0>
void to_json(BasicJsonType& j, const CompatibleString& s)
{
    external_constructor<value_t::string>::construct(j, s);
}

template<typename BasicJsonType>
void to_json(BasicJsonType& j, typename BasicJsonType::string_t&& s)
{
    external_constructor<value_t::string>::construct(j, std::move(s));
}

template<typename BasicJsonType, typename FloatType,
         enable_if_t<std::is_floating_point<FloatType>::value, int> = 0>
void to_json(BasicJsonType& j, FloatType val) noexcept
{
    external_constructor<value_t::number_float>::construct(j, static_cast<typename BasicJsonType::number_float_t>(val));
}

template<typename BasicJsonType, typename CompatibleNumberUnsignedType,
         enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_unsigned_t, CompatibleNumberUnsignedType>::value, int> = 0>
void to_json(BasicJsonType& j, CompatibleNumberUnsignedType val) noexcept
{
    external_constructor<value_t::number_unsigned>::construct(j, static_cast<typename BasicJsonType::number_unsigned_t>(val));
}

template<typename BasicJsonType, typename CompatibleNumberIntegerType,
         enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_integer_t, CompatibleNumberIntegerType>::value, int> = 0>
void to_json(BasicJsonType& j, CompatibleNumberIntegerType val) noexcept
{
    external_constructor<value_t::number_integer>::construct(j, static_cast<typename BasicJsonType::number_integer_t>(val));
}

template<typename BasicJsonType, typename EnumType,
         enable_if_t<std::is_enum<EnumType>::value, int> = 0>
void to_json(BasicJsonType& j, EnumType e) noexcept
{
    using underlying_type = typename std::underlying_type<EnumType>::type;
    external_constructor<value_t::number_integer>::construct(j, static_cast<underlying_type>(e));
}

template<typename BasicJsonType>
void to_json(BasicJsonType& j, const std::vector<bool>& e)
{
    external_constructor<value_t::array>::construct(j, e);
}

template < typename BasicJsonType, typename CompatibleArrayType,
           enable_if_t < is_compatible_array_type<BasicJsonType,
                         CompatibleArrayType>::value&&
                         !is_compatible_object_type<BasicJsonType, CompatibleArrayType>::value&&
                         !is_compatible_string_type<BasicJsonType, CompatibleArrayType>::value&&
                         !std::is_same<typename BasicJsonType::binary_t, CompatibleArrayType>::value&&
                         !is_basic_json<CompatibleArrayType>::value,
                         int > = 0 >
void to_json(BasicJsonType& j, const CompatibleArrayType& arr)
{
    external_constructor<value_t::array>::construct(j, arr);
}

template<typename BasicJsonType>
void to_json(BasicJsonType& j, const typename BasicJsonType::binary_t& bin)
{
    external_constructor<value_t::binary>::construct(j, bin);
}

template<typename BasicJsonType, typename T,
         enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>
void to_json(BasicJsonType& j, const std::valarray<T>& arr)
{
    external_constructor<value_t::array>::construct(j, std::move(arr));
}

template<typename BasicJsonType>
void to_json(BasicJsonType& j, typename BasicJsonType::array_t&& arr)
{
    external_constructor<value_t::array>::construct(j, std::move(arr));
}

template < typename BasicJsonType, typename CompatibleObjectType,
           enable_if_t < is_compatible_object_type<BasicJsonType, CompatibleObjectType>::value&& !is_basic_json<CompatibleObjectType>::value, int > = 0 >
void to_json(BasicJsonType& j, const CompatibleObjectType& obj)
{
    external_constructor<value_t::object>::construct(j, obj);
}

template<typename BasicJsonType>
void to_json(BasicJsonType& j, typename BasicJsonType::object_t&& obj)
{
    external_constructor<value_t::object>::construct(j, std::move(obj));
}

template <
    typename BasicJsonType, typename T, std::size_t N,
    enable_if_t < !std::is_constructible<typename BasicJsonType::string_t,
                  const T(&)[N]>::value,
                  int > = 0 >
void to_json(BasicJsonType& j, const T(&arr)[N])
{
    external_constructor<value_t::array>::construct(j, arr);
}

template < typename BasicJsonType, typename T1, typename T2, enable_if_t < std::is_constructible<BasicJsonType, T1>::value&& std::is_constructible<BasicJsonType, T2>::value, int > = 0 >
void to_json(BasicJsonType& j, const std::pair<T1, T2>& p)
{
    j = { p.first, p.second };
}

// for https://github.com/nlohmann/json/pull/1134
template<typename BasicJsonType, typename T,
         enable_if_t<std::is_same<T, iteration_proxy_value<typename BasicJsonType::iterator>>::value, int> = 0>
void to_json(BasicJsonType& j, const T& b)
{
    j = { {b.key(), b.value()} };
}

template<typename BasicJsonType, typename Tuple, std::size_t... Idx>
void to_json_tuple_impl(BasicJsonType& j, const Tuple& t, index_sequence<Idx...> /*unused*/)
{
    j = { std::get<Idx>(t)... };
}

template<typename BasicJsonType, typename T, enable_if_t<is_constructible_tuple<BasicJsonType, T>::value, int > = 0>
void to_json(BasicJsonType& j, const T& t)
{
    to_json_tuple_impl(j, t, make_index_sequence<std::tuple_size<T>::value> {});
}

struct to_json_fn
{
    template<typename BasicJsonType, typename T>
    auto operator()(BasicJsonType& j, T&& val) const noexcept(noexcept(to_json(j, std::forward<T>(val))))
    -> decltype(to_json(j, std::forward<T>(val)), void())
    {
        return to_json(j, std::forward<T>(val));
    }
};
}  // namespace detail

/// namespace to hold default `to_json` function
namespace
{
constexpr const auto& to_json = detail::static_const<detail::to_json_fn>::value;
} // namespace
} // namespace nlohmann


namespace nlohmann
{

template<typename, typename>
struct adl_serializer
{
    /*!
    @brief convert a JSON value to any value type

    This function is usually called by the `get()` function of the
    @ref basic_json class (either explicit or via conversion operators).

    @param[in] j        JSON value to read from
    @param[in,out] val  value to write to
    */
    template<typename BasicJsonType, typename ValueType>
    static auto from_json(BasicJsonType&& j, ValueType& val) noexcept(
        noexcept(::nlohmann::from_json(std::forward<BasicJsonType>(j), val)))
    -> decltype(::nlohmann::from_json(std::forward<BasicJsonType>(j), val), void())
    {
        ::nlohmann::from_json(std::forward<BasicJsonType>(j), val);
    }

    /*!
    @brief convert any value type to a JSON value

    This function is usually called by the constructors of the @ref basic_json
    class.

    @param[in,out] j  JSON value to write to
    @param[in] val    value to read from
    */
    template<typename BasicJsonType, typename ValueType>
    static auto to_json(BasicJsonType& j, ValueType&& val) noexcept(
        noexcept(::nlohmann::to_json(j, std::forward<ValueType>(val))))
    -> decltype(::nlohmann::to_json(j, std::forward<ValueType>(val)), void())
    {
        ::nlohmann::to_json(j, std::forward<ValueType>(val));
    }
};

}  // namespace nlohmann

// #include <nlohmann/byte_container_with_subtype.hpp>


#include <cstdint> // uint8_t
#include <tuple> // tie
#include <utility> // move

namespace nlohmann
{

/*!
@brief an internal type for a backed binary type

This type extends the template parameter @a BinaryType provided to `basic_json`
with a subtype used by BSON and MessagePack. This type exists so that the user
does not have to specify a type themselves with a specific naming scheme in
order to override the binary type.

@tparam BinaryType container to store bytes (`std::vector<std::uint8_t>` by
                   default)

@since version 3.8.0
*/
template<typename BinaryType>
class byte_container_with_subtype : public BinaryType
{
  public:
    /// the type of the underlying container
    using container_type = BinaryType;

    byte_container_with_subtype() noexcept(noexcept(container_type()))
        : container_type()
    {}

    byte_container_with_subtype(const container_type& b) noexcept(noexcept(container_type(b)))
        : container_type(b)
    {}

    byte_container_with_subtype(container_type&& b) noexcept(noexcept(container_type(std::move(b))))
        : container_type(std::move(b))
    {}

    byte_container_with_subtype(const container_type& b, std::uint8_t subtype) noexcept(noexcept(container_type(b)))
        : container_type(b)
        , m_subtype(subtype)
        , m_has_subtype(true)
    {}

    byte_container_with_subtype(container_type&& b, std::uint8_t subtype) noexcept(noexcept(container_type(std::move(b))))
        : container_type(std::move(b))
        , m_subtype(subtype)
        , m_has_subtype(true)
    {}

    bool operator==(const byte_container_with_subtype& rhs) const
    {
        return std::tie(static_cast<const BinaryType&>(*this), m_subtype, m_has_subtype) ==
               std::tie(static_cast<const BinaryType&>(rhs), rhs.m_subtype, rhs.m_has_subtype);
    }

    bool operator!=(const byte_container_with_subtype& rhs) const
    {
        return !(rhs == *this);
    }

    /*!
    @brief sets the binary subtype

    Sets the binary subtype of the value, also flags a binary JSON value as
    having a subtype, which has implications for serialization.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @sa @ref subtype() -- return the binary subtype
    @sa @ref clear_subtype() -- clears the binary subtype
    @sa @ref has_subtype() -- returns whether or not the binary value has a
    subtype

    @since version 3.8.0
    */
    void set_subtype(std::uint8_t subtype) noexcept
    {
        m_subtype = subtype;
        m_has_subtype = true;
    }

    /*!
    @brief return the binary subtype

    Returns the numerical subtype of the value if it has a subtype. If it does
    not have a subtype, this function will return size_t(-1) as a sentinel
    value.

    @return the numerical subtype of the binary value

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @sa @ref set_subtype() -- sets the binary subtype
    @sa @ref clear_subtype() -- clears the binary subtype
    @sa @ref has_subtype() -- returns whether or not the binary value has a
    subtype

    @since version 3.8.0
    */
    constexpr std::uint8_t subtype() const noexcept
    {
        return m_subtype;
    }

    /*!
    @brief return whether the value has a subtype

    @return whether the value has a subtype

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @sa @ref subtype() -- return the binary subtype
    @sa @ref set_subtype() -- sets the binary subtype
    @sa @ref clear_subtype() -- clears the binary subtype

    @since version 3.8.0
    */
    constexpr bool has_subtype() const noexcept
    {
        return m_has_subtype;
    }

    /*!
    @brief clears the binary subtype

    Clears the binary subtype and flags the value as not having a subtype, which
    has implications for serialization; for instance MessagePack will prefer the
    bin family over the ext family.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @sa @ref subtype() -- return the binary subtype
    @sa @ref set_subtype() -- sets the binary subtype
    @sa @ref has_subtype() -- returns whether or not the binary value has a
    subtype

    @since version 3.8.0
    */
    void clear_subtype() noexcept
    {
        m_subtype = 0;
        m_has_subtype = false;
    }

  private:
    std::uint8_t m_subtype = 0;
    bool m_has_subtype = false;
};

}  // namespace nlohmann

// #include <nlohmann/detail/conversions/from_json.hpp>

// #include <nlohmann/detail/conversions/to_json.hpp>

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/hash.hpp>


#include <cstddef> // size_t, uint8_t
#include <functional> // hash

namespace nlohmann
{
namespace detail
{

// boost::hash_combine
inline std::size_t combine(std::size_t seed, std::size_t h) noexcept
{
    seed ^= h + 0x9e3779b9 + (seed << 6U) + (seed >> 2U);
    return seed;
}

/*!
@brief hash a JSON value

The hash function tries to rely on std::hash where possible. Furthermore, the
type of the JSON value is taken into account to have different hash values for
null, 0, 0U, and false, etc.

@tparam BasicJsonType basic_json specialization
@param j JSON value to hash
@return hash value of j
*/
template<typename BasicJsonType>
std::size_t hash(const BasicJsonType& j)
{
    using string_t = typename BasicJsonType::string_t;
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;

    const auto type = static_cast<std::size_t>(j.type());
    switch (j.type())
    {
        case BasicJsonType::value_t::null:
        case BasicJsonType::value_t::discarded:
        {
            return combine(type, 0);
        }

        case BasicJsonType::value_t::object:
        {
            auto seed = combine(type, j.size());
            for (const auto& element : j.items())
            {
                const auto h = std::hash<string_t> {}(element.key());
                seed = combine(seed, h);
                seed = combine(seed, hash(element.value()));
            }
            return seed;
        }

        case BasicJsonType::value_t::array:
        {
            auto seed = combine(type, j.size());
            for (const auto& element : j)
            {
                seed = combine(seed, hash(element));
            }
            return seed;
        }

        case BasicJsonType::value_t::string:
        {
            const auto h = std::hash<string_t> {}(j.template get_ref<const string_t&>());
            return combine(type, h);
        }

        case BasicJsonType::value_t::boolean:
        {
            const auto h = std::hash<bool> {}(j.template get<bool>());
            return combine(type, h);
        }

        case BasicJsonType::value_t::number_integer:
        {
            const auto h = std::hash<number_integer_t> {}(j.template get<number_integer_t>());
            return combine(type, h);
        }

        case nlohmann::detail::value_t::number_unsigned:
        {
            const auto h = std::hash<number_unsigned_t> {}(j.template get<number_unsigned_t>());
            return combine(type, h);
        }

        case nlohmann::detail::value_t::number_float:
        {
            const auto h = std::hash<number_float_t> {}(j.template get<number_float_t>());
            return combine(type, h);
        }

        case nlohmann::detail::value_t::binary:
        {
            auto seed = combine(type, j.get_binary().size());
            const auto h = std::hash<bool> {}(j.get_binary().has_subtype());
            seed = combine(seed, h);
            seed = combine(seed, j.get_binary().subtype());
            for (const auto byte : j.get_binary())
            {
                seed = combine(seed, std::hash<std::uint8_t> {}(byte));
            }
            return seed;
        }

        default: // LCOV_EXCL_LINE
            JSON_ASSERT(false); // LCOV_EXCL_LINE
    }
}

}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/input/binary_reader.hpp>


#include <algorithm> // generate_n
#include <array> // array
#include <cmath> // ldexp
#include <cstddef> // size_t
#include <cstdint> // uint8_t, uint16_t, uint32_t, uint64_t
#include <cstdio> // snprintf
#include <cstring> // memcpy
#include <iterator> // back_inserter
#include <limits> // numeric_limits
#include <string> // char_traits, string
#include <utility> // make_pair, move

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/input/input_adapters.hpp>


#include <array> // array
#include <cstddef> // size_t
#include <cstdio> //FILE *
#include <cstring> // strlen
#include <istream> // istream
#include <iterator> // begin, end, iterator_traits, random_access_iterator_tag, distance, next
#include <memory> // shared_ptr, make_shared, addressof
#include <numeric> // accumulate
#include <string> // string, char_traits
#include <type_traits> // enable_if, is_base_of, is_pointer, is_integral, remove_pointer
#include <utility> // pair, declval

// #include <nlohmann/detail/iterators/iterator_traits.hpp>

// #include <nlohmann/detail/macro_scope.hpp>


namespace nlohmann
{
namespace detail
{
/// the supported input formats
enum class input_format_t { json, cbor, msgpack, ubjson, bson };

////////////////////
// input adapters //
////////////////////

/*!
Input adapter for stdio file access. This adapter read only 1 byte and do not use any
 buffer. This adapter is a very low level adapter.
*/
class file_input_adapter
{
  public:
    using char_type = char;

    JSON_HEDLEY_NON_NULL(2)
    explicit file_input_adapter(std::FILE* f) noexcept
        : m_file(f)
    {}

    // make class move-only
    file_input_adapter(const file_input_adapter&) = delete;
    file_input_adapter(file_input_adapter&&) = default;
    file_input_adapter& operator=(const file_input_adapter&) = delete;
    file_input_adapter& operator=(file_input_adapter&&) = delete;

    std::char_traits<char>::int_type get_character() noexcept
    {
        return std::fgetc(m_file);
    }

  private:
    /// the file pointer to read from
    std::FILE* m_file;
};


/*!
Input adapter for a (caching) istream. Ignores a UFT Byte Order Mark at
beginning of input. Does not support changing the underlying std::streambuf
in mid-input. Maintains underlying std::istream and std::streambuf to support
subsequent use of standard std::istream operations to process any input
characters following those used in parsing the JSON input.  Clears the
std::istream flags; any input errors (e.g., EOF) will be detected by the first
subsequent call for input from the std::istream.
*/
class input_stream_adapter
{
  public:
    using char_type = char;

    ~input_stream_adapter()
    {
        // clear stream flags; we use underlying streambuf I/O, do not
        // maintain ifstream flags, except eof
        if (is != nullptr)
        {
            is->clear(is->rdstate() & std::ios::eofbit);
        }
    }

    explicit input_stream_adapter(std::istream& i)
        : is(&i), sb(i.rdbuf())
    {}

    // delete because of pointer members
    input_stream_adapter(const input_stream_adapter&) = delete;
    input_stream_adapter& operator=(input_stream_adapter&) = delete;
    input_stream_adapter& operator=(input_stream_adapter&& rhs) = delete;

    input_stream_adapter(input_stream_adapter&& rhs) noexcept : is(rhs.is), sb(rhs.sb)
    {
        rhs.is = nullptr;
        rhs.sb = nullptr;
    }

    // std::istream/std::streambuf use std::char_traits<char>::to_int_type, to
    // ensure that std::char_traits<char>::eof() and the character 0xFF do not
    // end up as the same value, eg. 0xFFFFFFFF.
    std::char_traits<char>::int_type get_character()
    {
        auto res = sb->sbumpc();
        // set eof manually, as we don't use the istream interface.
        if (JSON_HEDLEY_UNLIKELY(res == EOF))
        {
            is->clear(is->rdstate() | std::ios::eofbit);
        }
        return res;
    }

  private:
    /// the associated input stream
    std::istream* is = nullptr;
    std::streambuf* sb = nullptr;
};

// General-purpose iterator-based adapter. It might not be as fast as
// theoretically possible for some containers, but it is extremely versatile.
template<typename IteratorType>
class iterator_input_adapter
{
  public:
    using char_type = typename std::iterator_traits<IteratorType>::value_type;

    iterator_input_adapter(IteratorType first, IteratorType last)
        : current(std::move(first)), end(std::move(last)) {}

    typename std::char_traits<char_type>::int_type get_character()
    {
        if (JSON_HEDLEY_LIKELY(current != end))
        {
            auto result = std::char_traits<char_type>::to_int_type(*current);
            std::advance(current, 1);
            return result;
        }
        else
        {
            return std::char_traits<char_type>::eof();
        }
    }

  private:
    IteratorType current;
    IteratorType end;

    template<typename BaseInputAdapter, size_t T>
    friend struct wide_string_input_helper;

    bool empty() const
    {
        return current == end;
    }

};


template<typename BaseInputAdapter, size_t T>
struct wide_string_input_helper;

template<typename BaseInputAdapter>
struct wide_string_input_helper<BaseInputAdapter, 4>
{
    // UTF-32
    static void fill_buffer(BaseInputAdapter& input,
                            std::array<std::char_traits<char>::int_type, 4>& utf8_bytes,
                            size_t& utf8_bytes_index,
                            size_t& utf8_bytes_filled)
    {
        utf8_bytes_index = 0;

        if (JSON_HEDLEY_UNLIKELY(input.empty()))
        {
            utf8_bytes[0] = std::char_traits<char>::eof();
            utf8_bytes_filled = 1;
        }
        else
        {
            // get the current character
            const auto wc = input.get_character();

            // UTF-32 to UTF-8 encoding
            if (wc < 0x80)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
                utf8_bytes_filled = 1;
            }
            else if (wc <= 0x7FF)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xC0u | ((static_cast<unsigned int>(wc) >> 6u) & 0x1Fu));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
                utf8_bytes_filled = 2;
            }
            else if (wc <= 0xFFFF)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xE0u | ((static_cast<unsigned int>(wc) >> 12u) & 0x0Fu));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 6u) & 0x3Fu));
                utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
                utf8_bytes_filled = 3;
            }
            else if (wc <= 0x10FFFF)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xF0u | ((static_cast<unsigned int>(wc) >> 18u) & 0x07u));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 12u) & 0x3Fu));
                utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 6u) & 0x3Fu));
                utf8_bytes[3] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
                utf8_bytes_filled = 4;
            }
            else
            {
                // unknown character
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
                utf8_bytes_filled = 1;
            }
        }
    }
};

template<typename BaseInputAdapter>
struct wide_string_input_helper<BaseInputAdapter, 2>
{
    // UTF-16
    static void fill_buffer(BaseInputAdapter& input,
                            std::array<std::char_traits<char>::int_type, 4>& utf8_bytes,
                            size_t& utf8_bytes_index,
                            size_t& utf8_bytes_filled)
    {
        utf8_bytes_index = 0;

        if (JSON_HEDLEY_UNLIKELY(input.empty()))
        {
            utf8_bytes[0] = std::char_traits<char>::eof();
            utf8_bytes_filled = 1;
        }
        else
        {
            // get the current character
            const auto wc = input.get_character();

            // UTF-16 to UTF-8 encoding
            if (wc < 0x80)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
                utf8_bytes_filled = 1;
            }
            else if (wc <= 0x7FF)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xC0u | ((static_cast<unsigned int>(wc) >> 6u)));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
                utf8_bytes_filled = 2;
            }
            else if (0xD800 > wc || wc >= 0xE000)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xE0u | ((static_cast<unsigned int>(wc) >> 12u)));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 6u) & 0x3Fu));
                utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
                utf8_bytes_filled = 3;
            }
            else
            {
                if (JSON_HEDLEY_UNLIKELY(!input.empty()))
                {
                    const auto wc2 = static_cast<unsigned int>(input.get_character());
                    const auto charcode = 0x10000u + (((static_cast<unsigned int>(wc) & 0x3FFu) << 10u) | (wc2 & 0x3FFu));
                    utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xF0u | (charcode >> 18u));
                    utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((charcode >> 12u) & 0x3Fu));
                    utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | ((charcode >> 6u) & 0x3Fu));
                    utf8_bytes[3] = static_cast<std::char_traits<char>::int_type>(0x80u | (charcode & 0x3Fu));
                    utf8_bytes_filled = 4;
                }
                else
                {
                    utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
                    utf8_bytes_filled = 1;
                }
            }
        }
    }
};

// Wraps another input apdater to convert wide character types into individual bytes.
template<typename BaseInputAdapter, typename WideCharType>
class wide_string_input_adapter
{
  public:
    using char_type = char;

    wide_string_input_adapter(BaseInputAdapter base)
        : base_adapter(base) {}

    typename std::char_traits<char>::int_type get_character() noexcept
    {
        // check if buffer needs to be filled
        if (utf8_bytes_index == utf8_bytes_filled)
        {
            fill_buffer<sizeof(WideCharType)>();

            JSON_ASSERT(utf8_bytes_filled > 0);
            JSON_ASSERT(utf8_bytes_index == 0);
        }

        // use buffer
        JSON_ASSERT(utf8_bytes_filled > 0);
        JSON_ASSERT(utf8_bytes_index < utf8_bytes_filled);
        return utf8_bytes[utf8_bytes_index++];
    }

  private:
    BaseInputAdapter base_adapter;

    template<size_t T>
    void fill_buffer()
    {
        wide_string_input_helper<BaseInputAdapter, T>::fill_buffer(base_adapter, utf8_bytes, utf8_bytes_index, utf8_bytes_filled);
    }

    /// a buffer for UTF-8 bytes
    std::array<std::char_traits<char>::int_type, 4> utf8_bytes = {{0, 0, 0, 0}};

    /// index to the utf8_codes array for the next valid byte
    std::size_t utf8_bytes_index = 0;
    /// number of valid bytes in the utf8_codes array
    std::size_t utf8_bytes_filled = 0;
};


template<typename IteratorType, typename Enable = void>
struct iterator_input_adapter_factory
{
    using iterator_type = IteratorType;
    using char_type = typename std::iterator_traits<iterator_type>::value_type;
    using adapter_type = iterator_input_adapter<iterator_type>;

    static adapter_type create(IteratorType first, IteratorType last)
    {
        return adapter_type(std::move(first), std::move(last));
    }
};

template<typename T>
struct is_iterator_of_multibyte
{
    using value_type = typename std::iterator_traits<T>::value_type;
    enum
    {
        value = sizeof(value_type) > 1
    };
};

template<typename IteratorType>
struct iterator_input_adapter_factory<IteratorType, enable_if_t<is_iterator_of_multibyte<IteratorType>::value>>
{
    using iterator_type = IteratorType;
    using char_type = typename std::iterator_traits<iterator_type>::value_type;
    using base_adapter_type = iterator_input_adapter<iterator_type>;
    using adapter_type = wide_string_input_adapter<base_adapter_type, char_type>;

    static adapter_type create(IteratorType first, IteratorType last)
    {
        return adapter_type(base_adapter_type(std::move(first), std::move(last)));
    }
};

// General purpose iterator-based input
template<typename IteratorType>
typename iterator_input_adapter_factory<IteratorType>::adapter_type input_adapter(IteratorType first, IteratorType last)
{
    using factory_type = iterator_input_adapter_factory<IteratorType>;
    return factory_type::create(first, last);
}

// Convenience shorthand from container to iterator
template<typename ContainerType>
auto input_adapter(const ContainerType& container) -> decltype(input_adapter(begin(container), end(container)))
{
    // Enable ADL
    using std::begin;
    using std::end;

    return input_adapter(begin(container), end(container));
}

// Special cases with fast paths
inline file_input_adapter input_adapter(std::FILE* file)
{
    return file_input_adapter(file);
}

inline input_stream_adapter input_adapter(std::istream& stream)
{
    return input_stream_adapter(stream);
}

inline input_stream_adapter input_adapter(std::istream&& stream)
{
    return input_stream_adapter(stream);
}

using contiguous_bytes_input_adapter = decltype(input_adapter(std::declval<const char*>(), std::declval<const char*>()));

// Null-delimited strings, and the like.
template < typename CharT,
           typename std::enable_if <
               std::is_pointer<CharT>::value&&
               !std::is_array<CharT>::value&&
               std::is_integral<typename std::remove_pointer<CharT>::type>::value&&
               sizeof(typename std::remove_pointer<CharT>::type) == 1,
               int >::type = 0 >
contiguous_bytes_input_adapter input_adapter(CharT b)
{
    auto length = std::strlen(reinterpret_cast<const char*>(b));
    const auto* ptr = reinterpret_cast<const char*>(b);
    return input_adapter(ptr, ptr + length);
}

template<typename T, std::size_t N>
auto input_adapter(T (&array)[N]) -> decltype(input_adapter(array, array + N))
{
    return input_adapter(array, array + N);
}

// This class only handles inputs of input_buffer_adapter type.
// It's required so that expressions like {ptr, len} can be implicitely casted
// to the correct adapter.
class span_input_adapter
{
  public:
    template < typename CharT,
               typename std::enable_if <
                   std::is_pointer<CharT>::value&&
                   std::is_integral<typename std::remove_pointer<CharT>::type>::value&&
                   sizeof(typename std::remove_pointer<CharT>::type) == 1,
                   int >::type = 0 >
    span_input_adapter(CharT b, std::size_t l)
        : ia(reinterpret_cast<const char*>(b), reinterpret_cast<const char*>(b) + l) {}

    template<class IteratorType,
             typename std::enable_if<
                 std::is_same<typename iterator_traits<IteratorType>::iterator_category, std::random_access_iterator_tag>::value,
                 int>::type = 0>
    span_input_adapter(IteratorType first, IteratorType last)
        : ia(input_adapter(first, last)) {}

    contiguous_bytes_input_adapter&& get()
    {
        return std::move(ia);
    }

  private:
    contiguous_bytes_input_adapter ia;
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/input/json_sax.hpp>


#include <cstddef>
#include <string> // string
#include <utility> // move
#include <vector> // vector

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/macro_scope.hpp>


namespace nlohmann
{

/*!
@brief SAX interface

This class describes the SAX interface used by @ref nlohmann::json::sax_parse.
Each function is called in different situations while the input is parsed. The
boolean return value informs the parser whether to continue processing the
input.
*/
template<typename BasicJsonType>
struct json_sax
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;

    /*!
    @brief a null value was read
    @return whether parsing should proceed
    */
    virtual bool null() = 0;

    /*!
    @brief a boolean value was read
    @param[in] val  boolean value
    @return whether parsing should proceed
    */
    virtual bool boolean(bool val) = 0;

    /*!
    @brief an integer number was read
    @param[in] val  integer value
    @return whether parsing should proceed
    */
    virtual bool number_integer(number_integer_t val) = 0;

    /*!
    @brief an unsigned integer number was read
    @param[in] val  unsigned integer value
    @return whether parsing should proceed
    */
    virtual bool number_unsigned(number_unsigned_t val) = 0;

    /*!
    @brief an floating-point number was read
    @param[in] val  floating-point value
    @param[in] s    raw token value
    @return whether parsing should proceed
    */
    virtual bool number_float(number_float_t val, const string_t& s) = 0;

    /*!
    @brief a string was read
    @param[in] val  string value
    @return whether parsing should proceed
    @note It is safe to move the passed string.
    */
    virtual bool string(string_t& val) = 0;

    /*!
    @brief a binary string was read
    @param[in] val  binary value
    @return whether parsing should proceed
    @note It is safe to move the passed binary.
    */
    virtual bool binary(binary_t& val) = 0;

    /*!
    @brief the beginning of an object was read
    @param[in] elements  number of object elements or -1 if unknown
    @return whether parsing should proceed
    @note binary formats may report the number of elements
    */
    virtual bool start_object(std::size_t elements) = 0;

    /*!
    @brief an object key was read
    @param[in] val  object key
    @return whether parsing should proceed
    @note It is safe to move the passed string.
    */
    virtual bool key(string_t& val) = 0;

    /*!
    @brief the end of an object was read
    @return whether parsing should proceed
    */
    virtual bool end_object() = 0;

    /*!
    @brief the beginning of an array was read
    @param[in] elements  number of array elements or -1 if unknown
    @return whether parsing should proceed
    @note binary formats may report the number of elements
    */
    virtual bool start_array(std::size_t elements) = 0;

    /*!
    @brief the end of an array was read
    @return whether parsing should proceed
    */
    virtual bool end_array() = 0;

    /*!
    @brief a parse error occurred
    @param[in] position    the position in the input where the error occurs
    @param[in] last_token  the last read token
    @param[in] ex          an exception object describing the error
    @return whether parsing should proceed (must return false)
    */
    virtual bool parse_error(std::size_t position,
                             const std::string& last_token,
                             const detail::exception& ex) = 0;

    virtual ~json_sax() = default;
};


namespace detail
{
/*!
@brief SAX implementation to create a JSON value from SAX events

This class implements the @ref json_sax interface and processes the SAX events
to create a JSON value which makes it basically a DOM parser. The structure or
hierarchy of the JSON value is managed by the stack `ref_stack` which contains
a pointer to the respective array or object for each recursion depth.

After successful parsing, the value that is passed by reference to the
constructor contains the parsed value.

@tparam BasicJsonType  the JSON type
*/
template<typename BasicJsonType>
class json_sax_dom_parser
{
  public:
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;

    /*!
    @param[in, out] r  reference to a JSON value that is manipulated while
                       parsing
    @param[in] allow_exceptions_  whether parse errors yield exceptions
    */
    explicit json_sax_dom_parser(BasicJsonType& r, const bool allow_exceptions_ = true)
        : root(r), allow_exceptions(allow_exceptions_)
    {}

    // make class move-only
    json_sax_dom_parser(const json_sax_dom_parser&) = delete;
    json_sax_dom_parser(json_sax_dom_parser&&) = default;
    json_sax_dom_parser& operator=(const json_sax_dom_parser&) = delete;
    json_sax_dom_parser& operator=(json_sax_dom_parser&&) = default;
    ~json_sax_dom_parser() = default;

    bool null()
    {
        handle_value(nullptr);
        return true;
    }

    bool boolean(bool val)
    {
        handle_value(val);
        return true;
    }

    bool number_integer(number_integer_t val)
    {
        handle_value(val);
        return true;
    }

    bool number_unsigned(number_unsigned_t val)
    {
        handle_value(val);
        return true;
    }

    bool number_float(number_float_t val, const string_t& /*unused*/)
    {
        handle_value(val);
        return true;
    }

    bool string(string_t& val)
    {
        handle_value(val);
        return true;
    }

    bool binary(binary_t& val)
    {
        handle_value(std::move(val));
        return true;
    }

    bool start_object(std::size_t len)
    {
        ref_stack.push_back(handle_value(BasicJsonType::value_t::object));

        if (JSON_HEDLEY_UNLIKELY(len != std::size_t(-1) && len > ref_stack.back()->max_size()))
        {
            JSON_THROW(out_of_range::create(408,
                                            "excessive object size: " + std::to_string(len)));
        }

        return true;
    }

    bool key(string_t& val)
    {
        // add null at given key and store the reference for later
        object_element = &(ref_stack.back()->m_value.object->operator[](val));
        return true;
    }

    bool end_object()
    {
        ref_stack.pop_back();
        return true;
    }

    bool start_array(std::size_t len)
    {
        ref_stack.push_back(handle_value(BasicJsonType::value_t::array));

        if (JSON_HEDLEY_UNLIKELY(len != std::size_t(-1) && len > ref_stack.back()->max_size()))
        {
            JSON_THROW(out_of_range::create(408,
                                            "excessive array size: " + std::to_string(len)));
        }

        return true;
    }

    bool end_array()
    {
        ref_stack.pop_back();
        return true;
    }

    template<class Exception>
    bool parse_error(std::size_t /*unused*/, const std::string& /*unused*/,
                     const Exception& ex)
    {
        errored = true;
        static_cast<void>(ex);
        if (allow_exceptions)
        {
            JSON_THROW(ex);
        }
        return false;
    }

    constexpr bool is_errored() const
    {
        return errored;
    }

  private:
    /*!
    @invariant If the ref stack is empty, then the passed value will be the new
               root.
    @invariant If the ref stack contains a value, then it is an array or an
               object to which we can add elements
    */
    template<typename Value>
    JSON_HEDLEY_RETURNS_NON_NULL
    BasicJsonType* handle_value(Value&& v)
    {
        if (ref_stack.empty())
        {
            root = BasicJsonType(std::forward<Value>(v));
            return &root;
        }

        JSON_ASSERT(ref_stack.back()->is_array() || ref_stack.back()->is_object());

        if (ref_stack.back()->is_array())
        {
            ref_stack.back()->m_value.array->emplace_back(std::forward<Value>(v));
            return &(ref_stack.back()->m_value.array->back());
        }

        JSON_ASSERT(ref_stack.back()->is_object());
        JSON_ASSERT(object_element);
        *object_element = BasicJsonType(std::forward<Value>(v));
        return object_element;
    }

    /// the parsed JSON value
    BasicJsonType& root;
    /// stack to model hierarchy of values
    std::vector<BasicJsonType*> ref_stack {};
    /// helper to hold the reference for the next object element
    BasicJsonType* object_element = nullptr;
    /// whether a syntax error occurred
    bool errored = false;
    /// whether to throw exceptions in case of errors
    const bool allow_exceptions = true;
};

template<typename BasicJsonType>
class json_sax_dom_callback_parser
{
  public:
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;
    using parser_callback_t = typename BasicJsonType::parser_callback_t;
    using parse_event_t = typename BasicJsonType::parse_event_t;

    json_sax_dom_callback_parser(BasicJsonType& r,
                                 const parser_callback_t cb,
                                 const bool allow_exceptions_ = true)
        : root(r), callback(cb), allow_exceptions(allow_exceptions_)
    {
        keep_stack.push_back(true);
    }

    // make class move-only
    json_sax_dom_callback_parser(const json_sax_dom_callback_parser&) = delete;
    json_sax_dom_callback_parser(json_sax_dom_callback_parser&&) = default;
    json_sax_dom_callback_parser& operator=(const json_sax_dom_callback_parser&) = delete;
    json_sax_dom_callback_parser& operator=(json_sax_dom_callback_parser&&) = default;
    ~json_sax_dom_callback_parser() = default;

    bool null()
    {
        handle_value(nullptr);
        return true;
    }

    bool boolean(bool val)
    {
        handle_value(val);
        return true;
    }

    bool number_integer(number_integer_t val)
    {
        handle_value(val);
        return true;
    }

    bool number_unsigned(number_unsigned_t val)
    {
        handle_value(val);
        return true;
    }

    bool number_float(number_float_t val, const string_t& /*unused*/)
    {
        handle_value(val);
        return true;
    }

    bool string(string_t& val)
    {
        handle_value(val);
        return true;
    }

    bool binary(binary_t& val)
    {
        handle_value(std::move(val));
        return true;
    }

    bool start_object(std::size_t len)
    {
        // check callback for object start
        const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::object_start, discarded);
        keep_stack.push_back(keep);

        auto val = handle_value(BasicJsonType::value_t::object, true);
        ref_stack.push_back(val.second);

        // check object limit
        if (ref_stack.back() && JSON_HEDLEY_UNLIKELY(len != std::size_t(-1) && len > ref_stack.back()->max_size()))
        {
            JSON_THROW(out_of_range::create(408, "excessive object size: " + std::to_string(len)));
        }

        return true;
    }

    bool key(string_t& val)
    {
        BasicJsonType k = BasicJsonType(val);

        // check callback for key
        const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::key, k);
        key_keep_stack.push_back(keep);

        // add discarded value at given key and store the reference for later
        if (keep && ref_stack.back())
        {
            object_element = &(ref_stack.back()->m_value.object->operator[](val) = discarded);
        }

        return true;
    }

    bool end_object()
    {
        if (ref_stack.back() && !callback(static_cast<int>(ref_stack.size()) - 1, parse_event_t::object_end, *ref_stack.back()))
        {
            // discard object
            *ref_stack.back() = discarded;
        }

        JSON_ASSERT(!ref_stack.empty());
        JSON_ASSERT(!keep_stack.empty());
        ref_stack.pop_back();
        keep_stack.pop_back();

        if (!ref_stack.empty() && ref_stack.back() && ref_stack.back()->is_structured())
        {
            // remove discarded value
            for (auto it = ref_stack.back()->begin(); it != ref_stack.back()->end(); ++it)
            {
                if (it->is_discarded())
                {
                    ref_stack.back()->erase(it);
                    break;
                }
            }
        }

        return true;
    }

    bool start_array(std::size_t len)
    {
        const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::array_start, discarded);
        keep_stack.push_back(keep);

        auto val = handle_value(BasicJsonType::value_t::array, true);
        ref_stack.push_back(val.second);

        // check array limit
        if (ref_stack.back() && JSON_HEDLEY_UNLIKELY(len != std::size_t(-1) && len > ref_stack.back()->max_size()))
        {
            JSON_THROW(out_of_range::create(408, "excessive array size: " + std::to_string(len)));
        }

        return true;
    }

    bool end_array()
    {
        bool keep = true;

        if (ref_stack.back())
        {
            keep = callback(static_cast<int>(ref_stack.size()) - 1, parse_event_t::array_end, *ref_stack.back());
            if (!keep)
            {
                // discard array
                *ref_stack.back() = discarded;
            }
        }

        JSON_ASSERT(!ref_stack.empty());
        JSON_ASSERT(!keep_stack.empty());
        ref_stack.pop_back();
        keep_stack.pop_back();

        // remove discarded value
        if (!keep && !ref_stack.empty() && ref_stack.back()->is_array())
        {
            ref_stack.back()->m_value.array->pop_back();
        }

        return true;
    }

    template<class Exception>
    bool parse_error(std::size_t /*unused*/, const std::string& /*unused*/,
                     const Exception& ex)
    {
        errored = true;
        static_cast<void>(ex);
        if (allow_exceptions)
        {
            JSON_THROW(ex);
        }
        return false;
    }

    constexpr bool is_errored() const
    {
        return errored;
    }

  private:
    /*!
    @param[in] v  value to add to the JSON value we build during parsing
    @param[in] skip_callback  whether we should skip calling the callback
               function; this is required after start_array() and
               start_object() SAX events, because otherwise we would call the
               callback function with an empty array or object, respectively.

    @invariant If the ref stack is empty, then the passed value will be the new
               root.
    @invariant If the ref stack contains a value, then it is an array or an
               object to which we can add elements

    @return pair of boolean (whether value should be kept) and pointer (to the
            passed value in the ref_stack hierarchy; nullptr if not kept)
    */
    template<typename Value>
    std::pair<bool, BasicJsonType*> handle_value(Value&& v, const bool skip_callback = false)
    {
        JSON_ASSERT(!keep_stack.empty());

        // do not handle this value if we know it would be added to a discarded
        // container
        if (!keep_stack.back())
        {
            return {false, nullptr};
        }

        // create value
        auto value = BasicJsonType(std::forward<Value>(v));

        // check callback
        const bool keep = skip_callback || callback(static_cast<int>(ref_stack.size()), parse_event_t::value, value);

        // do not handle this value if we just learnt it shall be discarded
        if (!keep)
        {
            return {false, nullptr};
        }

        if (ref_stack.empty())
        {
            root = std::move(value);
            return {true, &root};
        }

        // skip this value if we already decided to skip the parent
        // (https://github.com/nlohmann/json/issues/971#issuecomment-413678360)
        if (!ref_stack.back())
        {
            return {false, nullptr};
        }

        // we now only expect arrays and objects
        JSON_ASSERT(ref_stack.back()->is_array() || ref_stack.back()->is_object());

        // array
        if (ref_stack.back()->is_array())
        {
            ref_stack.back()->m_value.array->push_back(std::move(value));
            return {true, &(ref_stack.back()->m_value.array->back())};
        }

        // object
        JSON_ASSERT(ref_stack.back()->is_object());
        // check if we should store an element for the current key
        JSON_ASSERT(!key_keep_stack.empty());
        const bool store_element = key_keep_stack.back();
        key_keep_stack.pop_back();

        if (!store_element)
        {
            return {false, nullptr};
        }

        JSON_ASSERT(object_element);
        *object_element = std::move(value);
        return {true, object_element};
    }

    /// the parsed JSON value
    BasicJsonType& root;
    /// stack to model hierarchy of values
    std::vector<BasicJsonType*> ref_stack {};
    /// stack to manage which values to keep
    std::vector<bool> keep_stack {};
    /// stack to manage which object keys to keep
    std::vector<bool> key_keep_stack {};
    /// helper to hold the reference for the next object element
    BasicJsonType* object_element = nullptr;
    /// whether a syntax error occurred
    bool errored = false;
    /// callback function
    const parser_callback_t callback = nullptr;
    /// whether to throw exceptions in case of errors
    const bool allow_exceptions = true;
    /// a discarded value for the callback
    BasicJsonType discarded = BasicJsonType::value_t::discarded;
};

template<typename BasicJsonType>
class json_sax_acceptor
{
  public:
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;

    bool null()
    {
        return true;
    }

    bool boolean(bool /*unused*/)
    {
        return true;
    }

    bool number_integer(number_integer_t /*unused*/)
    {
        return true;
    }

    bool number_unsigned(number_unsigned_t /*unused*/)
    {
        return true;
    }

    bool number_float(number_float_t /*unused*/, const string_t& /*unused*/)
    {
        return true;
    }

    bool string(string_t& /*unused*/)
    {
        return true;
    }

    bool binary(binary_t& /*unused*/)
    {
        return true;
    }

    bool start_object(std::size_t /*unused*/ = std::size_t(-1))
    {
        return true;
    }

    bool key(string_t& /*unused*/)
    {
        return true;
    }

    bool end_object()
    {
        return true;
    }

    bool start_array(std::size_t /*unused*/ = std::size_t(-1))
    {
        return true;
    }

    bool end_array()
    {
        return true;
    }

    bool parse_error(std::size_t /*unused*/, const std::string& /*unused*/, const detail::exception& /*unused*/)
    {
        return false;
    }
};
}  // namespace detail

}  // namespace nlohmann

// #include <nlohmann/detail/input/lexer.hpp>


#include <array> // array
#include <clocale> // localeconv
#include <cstddef> // size_t
#include <cstdio> // snprintf
#include <cstdlib> // strtof, strtod, strtold, strtoll, strtoull
#include <initializer_list> // initializer_list
#include <string> // char_traits, string
#include <utility> // move
#include <vector> // vector

// #include <nlohmann/detail/input/input_adapters.hpp>

// #include <nlohmann/detail/input/position_t.hpp>

// #include <nlohmann/detail/macro_scope.hpp>


namespace nlohmann
{
namespace detail
{
///////////
// lexer //
///////////

template<typename BasicJsonType>
class lexer_base
{
  public:
    /// token types for the parser
    enum class token_type
    {
        uninitialized,    ///< indicating the scanner is uninitialized
        literal_true,     ///< the `true` literal
        literal_false,    ///< the `false` literal
        literal_null,     ///< the `null` literal
        value_string,     ///< a string -- use get_string() for actual value
        value_unsigned,   ///< an unsigned integer -- use get_number_unsigned() for actual value
        value_integer,    ///< a signed integer -- use get_number_integer() for actual value
        value_float,      ///< an floating point number -- use get_number_float() for actual value
        begin_array,      ///< the character for array begin `[`
        begin_object,     ///< the character for object begin `{`
        end_array,        ///< the character for array end `]`
        end_object,       ///< the character for object end `}`
        name_separator,   ///< the name separator `:`
        value_separator,  ///< the value separator `,`
        parse_error,      ///< indicating a parse error
        end_of_input,     ///< indicating the end of the input buffer
        literal_or_value  ///< a literal or the begin of a value (only for diagnostics)
    };

    /// return name of values of type token_type (only used for errors)
    JSON_HEDLEY_RETURNS_NON_NULL
    JSON_HEDLEY_CONST
    static const char* token_type_name(const token_type t) noexcept
    {
        switch (t)
        {
            case token_type::uninitialized:
                return "<uninitialized>";
            case token_type::literal_true:
                return "true literal";
            case token_type::literal_false:
                return "false literal";
            case token_type::literal_null:
                return "null literal";
            case token_type::value_string:
                return "string literal";
            case token_type::value_unsigned:
            case token_type::value_integer:
            case token_type::value_float:
                return "number literal";
            case token_type::begin_array:
                return "'['";
            case token_type::begin_object:
                return "'{'";
            case token_type::end_array:
                return "']'";
            case token_type::end_object:
                return "'}'";
            case token_type::name_separator:
                return "':'";
            case token_type::value_separator:
                return "','";
            case token_type::parse_error:
                return "<parse error>";
            case token_type::end_of_input:
                return "end of input";
            case token_type::literal_or_value:
                return "'[', '{', or a literal";
            // LCOV_EXCL_START
            default: // catch non-enum values
                return "unknown token";
                // LCOV_EXCL_STOP
        }
    }
};
/*!
@brief lexical analysis

This class organizes the lexical analysis during JSON deserialization.
*/
template<typename BasicJsonType, typename InputAdapterType>
class lexer : public lexer_base<BasicJsonType>
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using char_type = typename InputAdapterType::char_type;
    using char_int_type = typename std::char_traits<char_type>::int_type;

  public:
    using token_type = typename lexer_base<BasicJsonType>::token_type;

    explicit lexer(InputAdapterType&& adapter, bool ignore_comments_ = false)
        : ia(std::move(adapter))
        , ignore_comments(ignore_comments_)
        , decimal_point_char(static_cast<char_int_type>(get_decimal_point()))
    {}

    // delete because of pointer members
    lexer(const lexer&) = delete;
    lexer(lexer&&) = default;
    lexer& operator=(lexer&) = delete;
    lexer& operator=(lexer&&) = default;
    ~lexer() = default;

  private:
    /////////////////////
    // locales
    /////////////////////

    /// return the locale-dependent decimal point
    JSON_HEDLEY_PURE
    static char get_decimal_point() noexcept
    {
        const auto* loc = localeconv();
        JSON_ASSERT(loc != nullptr);
        return (loc->decimal_point == nullptr) ? '.' : *(loc->decimal_point);
    }

    /////////////////////
    // scan functions
    /////////////////////

    /*!
    @brief get codepoint from 4 hex characters following `\u`

    For input "\u c1 c2 c3 c4" the codepoint is:
      (c1 * 0x1000) + (c2 * 0x0100) + (c3 * 0x0010) + c4
    = (c1 << 12) + (c2 << 8) + (c3 << 4) + (c4 << 0)

    Furthermore, the possible characters '0'..'9', 'A'..'F', and 'a'..'f'
    must be converted to the integers 0x0..0x9, 0xA..0xF, 0xA..0xF, resp. The
    conversion is done by subtracting the offset (0x30, 0x37, and 0x57)
    between the ASCII value of the character and the desired integer value.

    @return codepoint (0x0000..0xFFFF) or -1 in case of an error (e.g. EOF or
            non-hex character)
    */
    int get_codepoint()
    {
        // this function only makes sense after reading `\u`
        JSON_ASSERT(current == 'u');
        int codepoint = 0;

        const auto factors = { 12u, 8u, 4u, 0u };
        for (const auto factor : factors)
        {
            get();

            if (current >= '0' && current <= '9')
            {
                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x30u) << factor);
            }
            else if (current >= 'A' && current <= 'F')
            {
                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x37u) << factor);
            }
            else if (current >= 'a' && current <= 'f')
            {
                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x57u) << factor);
            }
            else
            {
                return -1;
            }
        }

        JSON_ASSERT(0x0000 <= codepoint && codepoint <= 0xFFFF);
        return codepoint;
    }

    /*!
    @brief check if the next byte(s) are inside a given range

    Adds the current byte and, for each passed range, reads a new byte and
    checks if it is inside the range. If a violation was detected, set up an
    error message and return false. Otherwise, return true.

    @param[in] ranges  list of integers; interpreted as list of pairs of
                       inclusive lower and upper bound, respectively

    @pre The passed list @a ranges must have 2, 4, or 6 elements; that is,
         1, 2, or 3 pairs. This precondition is enforced by an assertion.

    @return true if and only if no range violation was detected
    */
    bool next_byte_in_range(std::initializer_list<char_int_type> ranges)
    {
        JSON_ASSERT(ranges.size() == 2 || ranges.size() == 4 || ranges.size() == 6);
        add(current);

        for (auto range = ranges.begin(); range != ranges.end(); ++range)
        {
            get();
            if (JSON_HEDLEY_LIKELY(*range <= current && current <= *(++range)))
            {
                add(current);
            }
            else
            {
                error_message = "invalid string: ill-formed UTF-8 byte";
                return false;
            }
        }

        return true;
    }

    /*!
    @brief scan a string literal

    This function scans a string according to Sect. 7 of RFC 7159. While
    scanning, bytes are escaped and copied into buffer token_buffer. Then the
    function returns successfully, token_buffer is *not* null-terminated (as it
    may contain \0 bytes), and token_buffer.size() is the number of bytes in the
    string.

    @return token_type::value_string if string could be successfully scanned,
            token_type::parse_error otherwise

    @note In case of errors, variable error_message contains a textual
          description.
    */
    token_type scan_string()
    {
        // reset token_buffer (ignore opening quote)
        reset();

        // we entered the function by reading an open quote
        JSON_ASSERT(current == '\"');

        while (true)
        {
            // get next character
            switch (get())
            {
                // end of file while parsing string
                case std::char_traits<char_type>::eof():
                {
                    error_message = "invalid string: missing closing quote";
                    return token_type::parse_error;
                }

                // closing quote
                case '\"':
                {
                    return token_type::value_string;
                }

                // escapes
                case '\\':
                {
                    switch (get())
                    {
                        // quotation mark
                        case '\"':
                            add('\"');
                            break;
                        // reverse solidus
                        case '\\':
                            add('\\');
                            break;
                        // solidus
                        case '/':
                            add('/');
                            break;
                        // backspace
                        case 'b':
                            add('\b');
                            break;
                        // form feed
                        case 'f':
                            add('\f');
                            break;
                        // line feed
                        case 'n':
                            add('\n');
                            break;
                        // carriage return
                        case 'r':
                            add('\r');
                            break;
                        // tab
                        case 't':
                            add('\t');
                            break;

                        // unicode escapes
                        case 'u':
                        {
                            const int codepoint1 = get_codepoint();
                            int codepoint = codepoint1; // start with codepoint1

                            if (JSON_HEDLEY_UNLIKELY(codepoint1 == -1))
                            {
                                error_message = "invalid string: '\\u' must be followed by 4 hex digits";
                                return token_type::parse_error;
                            }

                            // check if code point is a high surrogate
                            if (0xD800 <= codepoint1 && codepoint1 <= 0xDBFF)
                            {
                                // expect next \uxxxx entry
                                if (JSON_HEDLEY_LIKELY(get() == '\\' && get() == 'u'))
                                {
                                    const int codepoint2 = get_codepoint();

                                    if (JSON_HEDLEY_UNLIKELY(codepoint2 == -1))
                                    {
                                        error_message = "invalid string: '\\u' must be followed by 4 hex digits";
                                        return token_type::parse_error;
                                    }

                                    // check if codepoint2 is a low surrogate
                                    if (JSON_HEDLEY_LIKELY(0xDC00 <= codepoint2 && codepoint2 <= 0xDFFF))
                                    {
                                        // overwrite codepoint
                                        codepoint = static_cast<int>(
                                                        // high surrogate occupies the most significant 22 bits
                                                        (static_cast<unsigned int>(codepoint1) << 10u)
                                                        // low surrogate occupies the least significant 15 bits
                                                        + static_cast<unsigned int>(codepoint2)
                                                        // there is still the 0xD800, 0xDC00 and 0x10000 noise
                                                        // in the result so we have to subtract with:
                                                        // (0xD800 << 10) + DC00 - 0x10000 = 0x35FDC00
                                                        - 0x35FDC00u);
                                    }
                                    else
                                    {
                                        error_message = "invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF";
                                        return token_type::parse_error;
                                    }
                                }
                                else
                                {
                                    error_message = "invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF";
                                    return token_type::parse_error;
                                }
                            }
                            else
                            {
                                if (JSON_HEDLEY_UNLIKELY(0xDC00 <= codepoint1 && codepoint1 <= 0xDFFF))
                                {
                                    error_message = "invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF";
                                    return token_type::parse_error;
                                }
                            }

                            // result of the above calculation yields a proper codepoint
                            JSON_ASSERT(0x00 <= codepoint && codepoint <= 0x10FFFF);

                            // translate codepoint into bytes
                            if (codepoint < 0x80)
                            {
                                // 1-byte characters: 0xxxxxxx (ASCII)
                                add(static_cast<char_int_type>(codepoint));
                            }
                            else if (codepoint <= 0x7FF)
                            {
                                // 2-byte characters: 110xxxxx 10xxxxxx
                                add(static_cast<char_int_type>(0xC0u | (static_cast<unsigned int>(codepoint) >> 6u)));
                                add(static_cast<char_int_type>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
                            }
                            else if (codepoint <= 0xFFFF)
                            {
                                // 3-byte characters: 1110xxxx 10xxxxxx 10xxxxxx
                                add(static_cast<char_int_type>(0xE0u | (static_cast<unsigned int>(codepoint) >> 12u)));
                                add(static_cast<char_int_type>(0x80u | ((static_cast<unsigned int>(codepoint) >> 6u) & 0x3Fu)));
                                add(static_cast<char_int_type>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
                            }
                            else
                            {
                                // 4-byte characters: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
                                add(static_cast<char_int_type>(0xF0u | (static_cast<unsigned int>(codepoint) >> 18u)));
                                add(static_cast<char_int_type>(0x80u | ((static_cast<unsigned int>(codepoint) >> 12u) & 0x3Fu)));
                                add(static_cast<char_int_type>(0x80u | ((static_cast<unsigned int>(codepoint) >> 6u) & 0x3Fu)));
                                add(static_cast<char_int_type>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
                            }

                            break;
                        }

                        // other characters after escape
                        default:
                            error_message = "invalid string: forbidden character after backslash";
                            return token_type::parse_error;
                    }

                    break;
                }

                // invalid control characters
                case 0x00:
                {
                    error_message = "invalid string: control character U+0000 (NUL) must be escaped to \\u0000";
                    return token_type::parse_error;
                }

                case 0x01:
                {
                    error_message = "invalid string: control character U+0001 (SOH) must be escaped to \\u0001";
                    return token_type::parse_error;
                }

                case 0x02:
                {
                    error_message = "invalid string: control character U+0002 (STX) must be escaped to \\u0002";
                    return token_type::parse_error;
                }

                case 0x03:
                {
                    error_message = "invalid string: control character U+0003 (ETX) must be escaped to \\u0003";
                    return token_type::parse_error;
                }

                case 0x04:
                {
                    error_message = "invalid string: control character U+0004 (EOT) must be escaped to \\u0004";
                    return token_type::parse_error;
                }

                case 0x05:
                {
                    error_message = "invalid string: control character U+0005 (ENQ) must be escaped to \\u0005";
                    return token_type::parse_error;
                }

                case 0x06:
                {
                    error_message = "invalid string: control character U+0006 (ACK) must be escaped to \\u0006";
                    return token_type::parse_error;
                }

                case 0x07:
                {
                    error_message = "invalid string: control character U+0007 (BEL) must be escaped to \\u0007";
                    return token_type::parse_error;
                }

                case 0x08:
                {
                    error_message = "invalid string: control character U+0008 (BS) must be escaped to \\u0008 or \\b";
                    return token_type::parse_error;
                }

                case 0x09:
                {
                    error_message = "invalid string: control character U+0009 (HT) must be escaped to \\u0009 or \\t";
                    return token_type::parse_error;
                }

                case 0x0A:
                {
                    error_message = "invalid string: control character U+000A (LF) must be escaped to \\u000A or \\n";
                    return token_type::parse_error;
                }

                case 0x0B:
                {
                    error_message = "invalid string: control character U+000B (VT) must be escaped to \\u000B";
                    return token_type::parse_error;
                }

                case 0x0C:
                {
                    error_message = "invalid string: control character U+000C (FF) must be escaped to \\u000C or \\f";
                    return token_type::parse_error;
                }

                case 0x0D:
                {
                    error_message = "invalid string: control character U+000D (CR) must be escaped to \\u000D or \\r";
                    return token_type::parse_error;
                }

                case 0x0E:
                {
                    error_message = "invalid string: control character U+000E (SO) must be escaped to \\u000E";
                    return token_type::parse_error;
                }

                case 0x0F:
                {
                    error_message = "invalid string: control character U+000F (SI) must be escaped to \\u000F";
                    return token_type::parse_error;
                }

                case 0x10:
                {
                    error_message = "invalid string: control character U+0010 (DLE) must be escaped to \\u0010";
                    return token_type::parse_error;
                }

                case 0x11:
                {
                    error_message = "invalid string: control character U+0011 (DC1) must be escaped to \\u0011";
                    return token_type::parse_error;
                }

                case 0x12:
                {
                    error_message = "invalid string: control character U+0012 (DC2) must be escaped to \\u0012";
                    return token_type::parse_error;
                }

                case 0x13:
                {
                    error_message = "invalid string: control character U+0013 (DC3) must be escaped to \\u0013";
                    return token_type::parse_error;
                }

                case 0x14:
                {
                    error_message = "invalid string: control character U+0014 (DC4) must be escaped to \\u0014";
                    return token_type::parse_error;
                }

                case 0x15:
                {
                    error_message = "invalid string: control character U+0015 (NAK) must be escaped to \\u0015";
                    return token_type::parse_error;
                }

                case 0x16:
                {
                    error_message = "invalid string: control character U+0016 (SYN) must be escaped to \\u0016";
                    return token_type::parse_error;
                }

                case 0x17:
                {
                    error_message = "invalid string: control character U+0017 (ETB) must be escaped to \\u0017";
                    return token_type::parse_error;
                }

                case 0x18:
                {
                    error_message = "invalid string: control character U+0018 (CAN) must be escaped to \\u0018";
                    return token_type::parse_error;
                }

                case 0x19:
                {
                    error_message = "invalid string: control character U+0019 (EM) must be escaped to \\u0019";
                    return token_type::parse_error;
                }

                case 0x1A:
                {
                    error_message = "invalid string: control character U+001A (SUB) must be escaped to \\u001A";
                    return token_type::parse_error;
                }

                case 0x1B:
                {
                    error_message = "invalid string: control character U+001B (ESC) must be escaped to \\u001B";
                    return token_type::parse_error;
                }

                case 0x1C:
                {
                    error_message = "invalid string: control character U+001C (FS) must be escaped to \\u001C";
                    return token_type::parse_error;
                }

                case 0x1D:
                {
                    error_message = "invalid string: control character U+001D (GS) must be escaped to \\u001D";
                    return token_type::parse_error;
                }

                case 0x1E:
                {
                    error_message = "invalid string: control character U+001E (RS) must be escaped to \\u001E";
                    return token_type::parse_error;
                }

                case 0x1F:
                {
                    error_message = "invalid string: control character U+001F (US) must be escaped to \\u001F";
                    return token_type::parse_error;
                }

                // U+0020..U+007F (except U+0022 (quote) and U+005C (backspace))
                case 0x20:
                case 0x21:
                case 0x23:
                case 0x24:
                case 0x25:
                case 0x26:
                case 0x27:
                case 0x28:
                case 0x29:
                case 0x2A:
                case 0x2B:
                case 0x2C:
                case 0x2D:
                case 0x2E:
                case 0x2F:
                case 0x30:
                case 0x31:
                case 0x32:
                case 0x33:
                case 0x34:
                case 0x35:
                case 0x36:
                case 0x37:
                case 0x38:
                case 0x39:
                case 0x3A:
                case 0x3B:
                case 0x3C:
                case 0x3D:
                case 0x3E:
                case 0x3F:
                case 0x40:
                case 0x41:
                case 0x42:
                case 0x43:
                case 0x44:
                case 0x45:
                case 0x46:
                case 0x47:
                case 0x48:
                case 0x49:
                case 0x4A:
                case 0x4B:
                case 0x4C:
                case 0x4D:
                case 0x4E:
                case 0x4F:
                case 0x50:
                case 0x51:
                case 0x52:
                case 0x53:
                case 0x54:
                case 0x55:
                case 0x56:
                case 0x57:
                case 0x58:
                case 0x59:
                case 0x5A:
                case 0x5B:
                case 0x5D:
                case 0x5E:
                case 0x5F:
                case 0x60:
                case 0x61:
                case 0x62:
                case 0x63:
                case 0x64:
                case 0x65:
                case 0x66:
                case 0x67:
                case 0x68:
                case 0x69:
                case 0x6A:
                case 0x6B:
                case 0x6C:
                case 0x6D:
                case 0x6E:
                case 0x6F:
                case 0x70:
                case 0x71:
                case 0x72:
                case 0x73:
                case 0x74:
                case 0x75:
                case 0x76:
                case 0x77:
                case 0x78:
                case 0x79:
                case 0x7A:
                case 0x7B:
                case 0x7C:
                case 0x7D:
                case 0x7E:
                case 0x7F:
                {
                    add(current);
                    break;
                }

                // U+0080..U+07FF: bytes C2..DF 80..BF
                case 0xC2:
                case 0xC3:
                case 0xC4:
                case 0xC5:
                case 0xC6:
                case 0xC7:
                case 0xC8:
                case 0xC9:
                case 0xCA:
                case 0xCB:
                case 0xCC:
                case 0xCD:
                case 0xCE:
                case 0xCF:
                case 0xD0:
                case 0xD1:
                case 0xD2:
                case 0xD3:
                case 0xD4:
                case 0xD5:
                case 0xD6:
                case 0xD7:
                case 0xD8:
                case 0xD9:
                case 0xDA:
                case 0xDB:
                case 0xDC:
                case 0xDD:
                case 0xDE:
                case 0xDF:
                {
                    if (JSON_HEDLEY_UNLIKELY(!next_byte_in_range({0x80, 0xBF})))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+0800..U+0FFF: bytes E0 A0..BF 80..BF
                case 0xE0:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0xA0, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+1000..U+CFFF: bytes E1..EC 80..BF 80..BF
                // U+E000..U+FFFF: bytes EE..EF 80..BF 80..BF
                case 0xE1:
                case 0xE2:
                case 0xE3:
                case 0xE4:
                case 0xE5:
                case 0xE6:
                case 0xE7:
                case 0xE8:
                case 0xE9:
                case 0xEA:
                case 0xEB:
                case 0xEC:
                case 0xEE:
                case 0xEF:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+D000..U+D7FF: bytes ED 80..9F 80..BF
                case 0xED:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0x9F, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+10000..U+3FFFF F0 90..BF 80..BF 80..BF
                case 0xF0:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x90, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+40000..U+FFFFF F1..F3 80..BF 80..BF 80..BF
                case 0xF1:
                case 0xF2:
                case 0xF3:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+100000..U+10FFFF F4 80..8F 80..BF 80..BF
                case 0xF4:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0x8F, 0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // remaining bytes (80..C1 and F5..FF) are ill-formed
                default:
                {
                    error_message = "invalid string: ill-formed UTF-8 byte";
                    return token_type::parse_error;
                }
            }
        }
    }

    /*!
     * @brief scan a comment
     * @return whether comment could be scanned successfully
     */
    bool scan_comment()
    {
        switch (get())
        {
            // single-line comments skip input until a newline or EOF is read
            case '/':
            {
                while (true)
                {
                    switch (get())
                    {
                        case '\n':
                        case '\r':
                        case std::char_traits<char_type>::eof():
                        case '\0':
                            return true;

                        default:
                            break;
                    }
                }
            }

            // multi-line comments skip input until */ is read
            case '*':
            {
                while (true)
                {
                    switch (get())
                    {
                        case std::char_traits<char_type>::eof():
                        case '\0':
                        {
                            error_message = "invalid comment; missing closing '*/'";
                            return false;
                        }

                        case '*':
                        {
                            switch (get())
                            {
                                case '/':
                                    return true;

                                default:
                                {
                                    unget();
                                    continue;
                                }
                            }
                        }

                        default:
                            continue;
                    }
                }
            }

            // unexpected character after reading '/'
            default:
            {
                error_message = "invalid comment; expecting '/' or '*' after '/'";
                return false;
            }
        }
    }

    JSON_HEDLEY_NON_NULL(2)
    static void strtof(float& f, const char* str, char** endptr) noexcept
    {
        f = std::strtof(str, endptr);
    }

    JSON_HEDLEY_NON_NULL(2)
    static void strtof(double& f, const char* str, char** endptr) noexcept
    {
        f = std::strtod(str, endptr);
    }

    JSON_HEDLEY_NON_NULL(2)
    static void strtof(long double& f, const char* str, char** endptr) noexcept
    {
        f = std::strtold(str, endptr);
    }

    /*!
    @brief scan a number literal

    This function scans a string according to Sect. 6 of RFC 7159.

    The function is realized with a deterministic finite state machine derived
    from the grammar described in RFC 7159. Starting in state "init", the
    input is read and used to determined the next state. Only state "done"
    accepts the number. State "error" is a trap state to model errors. In the
    table below, "anything" means any character but the ones listed before.

    state    | 0        | 1-9      | e E      | +       | -       | .        | anything
    ---------|----------|----------|----------|---------|---------|----------|-----------
    init     | zero     | any1     | [error]  | [error] | minus   | [error]  | [error]
    minus    | zero     | any1     | [error]  | [error] | [error] | [error]  | [error]
    zero     | done     | done     | exponent | done    | done    | decimal1 | done
    any1     | any1     | any1     | exponent | done    | done    | decimal1 | done
    decimal1 | decimal2 | decimal2 | [error]  | [error] | [error] | [error]  | [error]
    decimal2 | decimal2 | decimal2 | exponent | done    | done    | done     | done
    exponent | any2     | any2     | [error]  | sign    | sign    | [error]  | [error]
    sign     | any2     | any2     | [error]  | [error] | [error] | [error]  | [error]
    any2     | any2     | any2     | done     | done    | done    | done     | done

    The state machine is realized with one label per state (prefixed with
    "scan_number_") and `goto` statements between them. The state machine
    contains cycles, but any cycle can be left when EOF is read. Therefore,
    the function is guaranteed to terminate.

    During scanning, the read bytes are stored in token_buffer. This string is
    then converted to a signed integer, an unsigned integer, or a
    floating-point number.

    @return token_type::value_unsigned, token_type::value_integer, or
            token_type::value_float if number could be successfully scanned,
            token_type::parse_error otherwise

    @note The scanner is independent of the current locale. Internally, the
          locale's decimal point is used instead of `.` to work with the
          locale-dependent converters.
    */
    token_type scan_number()  // lgtm [cpp/use-of-goto]
    {
        // reset token_buffer to store the number's bytes
        reset();

        // the type of the parsed number; initially set to unsigned; will be
        // changed if minus sign, decimal point or exponent is read
        token_type number_type = token_type::value_unsigned;

        // state (init): we just found out we need to scan a number
        switch (current)
        {
            case '-':
            {
                add(current);
                goto scan_number_minus;
            }

            case '0':
            {
                add(current);
                goto scan_number_zero;
            }

            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any1;
            }

            // all other characters are rejected outside scan_number()
            default:            // LCOV_EXCL_LINE
                JSON_ASSERT(false);  // LCOV_EXCL_LINE
        }

scan_number_minus:
        // state: we just parsed a leading minus sign
        number_type = token_type::value_integer;
        switch (get())
        {
            case '0':
            {
                add(current);
                goto scan_number_zero;
            }

            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any1;
            }

            default:
            {
                error_message = "invalid number; expected digit after '-'";
                return token_type::parse_error;
            }
        }

scan_number_zero:
        // state: we just parse a zero (maybe with a leading minus sign)
        switch (get())
        {
            case '.':
            {
                add(decimal_point_char);
                goto scan_number_decimal1;
            }

            case 'e':
            case 'E':
            {
                add(current);
                goto scan_number_exponent;
            }

            default:
                goto scan_number_done;
        }

scan_number_any1:
        // state: we just parsed a number 0-9 (maybe with a leading minus sign)
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any1;
            }

            case '.':
            {
                add(decimal_point_char);
                goto scan_number_decimal1;
            }

            case 'e':
            case 'E':
            {
                add(current);
                goto scan_number_exponent;
            }

            default:
                goto scan_number_done;
        }

scan_number_decimal1:
        // state: we just parsed a decimal point
        number_type = token_type::value_float;
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_decimal2;
            }

            default:
            {
                error_message = "invalid number; expected digit after '.'";
                return token_type::parse_error;
            }
        }

scan_number_decimal2:
        // we just parsed at least one number after a decimal point
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_decimal2;
            }

            case 'e':
            case 'E':
            {
                add(current);
                goto scan_number_exponent;
            }

            default:
                goto scan_number_done;
        }

scan_number_exponent:
        // we just parsed an exponent
        number_type = token_type::value_float;
        switch (get())
        {
            case '+':
            case '-':
            {
                add(current);
                goto scan_number_sign;
            }

            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any2;
            }

            default:
            {
                error_message =
                    "invalid number; expected '+', '-', or digit after exponent";
                return token_type::parse_error;
            }
        }

scan_number_sign:
        // we just parsed an exponent sign
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any2;
            }

            default:
            {
                error_message = "invalid number; expected digit after exponent sign";
                return token_type::parse_error;
            }
        }

scan_number_any2:
        // we just parsed a number after the exponent or exponent sign
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any2;
            }

            default:
                goto scan_number_done;
        }

scan_number_done:
        // unget the character after the number (we only read it to know that
        // we are done scanning a number)
        unget();

        char* endptr = nullptr;
        errno = 0;

        // try to parse integers first and fall back to floats
        if (number_type == token_type::value_unsigned)
        {
            const auto x = std::strtoull(token_buffer.data(), &endptr, 10);

            // we checked the number format before
            JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());

            if (errno == 0)
            {
                value_unsigned = static_cast<number_unsigned_t>(x);
                if (value_unsigned == x)
                {
                    return token_type::value_unsigned;
                }
            }
        }
        else if (number_type == token_type::value_integer)
        {
            const auto x = std::strtoll(token_buffer.data(), &endptr, 10);

            // we checked the number format before
            JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());

            if (errno == 0)
            {
                value_integer = static_cast<number_integer_t>(x);
                if (value_integer == x)
                {
                    return token_type::value_integer;
                }
            }
        }

        // this code is reached if we parse a floating-point number or if an
        // integer conversion above failed
        strtof(value_float, token_buffer.data(), &endptr);

        // we checked the number format before
        JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());

        return token_type::value_float;
    }

    /*!
    @param[in] literal_text  the literal text to expect
    @param[in] length        the length of the passed literal text
    @param[in] return_type   the token type to return on success
    */
    JSON_HEDLEY_NON_NULL(2)
    token_type scan_literal(const char_type* literal_text, const std::size_t length,
                            token_type return_type)
    {
        JSON_ASSERT(std::char_traits<char_type>::to_char_type(current) == literal_text[0]);
        for (std::size_t i = 1; i < length; ++i)
        {
            if (JSON_HEDLEY_UNLIKELY(std::char_traits<char_type>::to_char_type(get()) != literal_text[i]))
            {
                error_message = "invalid literal";
                return token_type::parse_error;
            }
        }
        return return_type;
    }

    /////////////////////
    // input management
    /////////////////////

    /// reset token_buffer; current character is beginning of token
    void reset() noexcept
    {
        token_buffer.clear();
        token_string.clear();
        token_string.push_back(std::char_traits<char_type>::to_char_type(current));
    }

    /*
    @brief get next character from the input

    This function provides the interface to the used input adapter. It does
    not throw in case the input reached EOF, but returns a
    `std::char_traits<char>::eof()` in that case.  Stores the scanned characters
    for use in error messages.

    @return character read from the input
    */
    char_int_type get()
    {
        ++position.chars_read_total;
        ++position.chars_read_current_line;

        if (next_unget)
        {
            // just reset the next_unget variable and work with current
            next_unget = false;
        }
        else
        {
            current = ia.get_character();
        }

        if (JSON_HEDLEY_LIKELY(current != std::char_traits<char_type>::eof()))
        {
            token_string.push_back(std::char_traits<char_type>::to_char_type(current));
        }

        if (current == '\n')
        {
            ++position.lines_read;
            position.chars_read_current_line = 0;
        }

        return current;
    }

    /*!
    @brief unget current character (read it again on next get)

    We implement unget by setting variable next_unget to true. The input is not
    changed - we just simulate ungetting by modifying chars_read_total,
    chars_read_current_line, and token_string. The next call to get() will
    behave as if the unget character is read again.
    */
    void unget()
    {
        next_unget = true;

        --position.chars_read_total;

        // in case we "unget" a newline, we have to also decrement the lines_read
        if (position.chars_read_current_line == 0)
        {
            if (position.lines_read > 0)
            {
                --position.lines_read;
            }
        }
        else
        {
            --position.chars_read_current_line;
        }

        if (JSON_HEDLEY_LIKELY(current != std::char_traits<char_type>::eof()))
        {
            JSON_ASSERT(!token_string.empty());
            token_string.pop_back();
        }
    }

    /// add a character to token_buffer
    void add(char_int_type c)
    {
        token_buffer.push_back(static_cast<typename string_t::value_type>(c));
    }

  public:
    /////////////////////
    // value getters
    /////////////////////

    /// return integer value
    constexpr number_integer_t get_number_integer() const noexcept
    {
        return value_integer;
    }

    /// return unsigned integer value
    constexpr number_unsigned_t get_number_unsigned() const noexcept
    {
        return value_unsigned;
    }

    /// return floating-point value
    constexpr number_float_t get_number_float() const noexcept
    {
        return value_float;
    }

    /// return current string value (implicitly resets the token; useful only once)
    string_t& get_string()
    {
        return token_buffer;
    }

    /////////////////////
    // diagnostics
    /////////////////////

    /// return position of last read token
    constexpr position_t get_position() const noexcept
    {
        return position;
    }

    /// return the last read token (for errors only).  Will never contain EOF
    /// (an arbitrary value that is not a valid char value, often -1), because
    /// 255 may legitimately occur.  May contain NUL, which should be escaped.
    std::string get_token_string() const
    {
        // escape control characters
        std::string result;
        for (const auto c : token_string)
        {
            if (static_cast<unsigned char>(c) <= '\x1F')
            {
                // escape control characters
                std::array<char, 9> cs{{}};
                (std::snprintf)(cs.data(), cs.size(), "<U+%.4X>", static_cast<unsigned char>(c));
                result += cs.data();
            }
            else
            {
                // add character as is
                result.push_back(static_cast<std::string::value_type>(c));
            }
        }

        return result;
    }

    /// return syntax error message
    JSON_HEDLEY_RETURNS_NON_NULL
    constexpr const char* get_error_message() const noexcept
    {
        return error_message;
    }

    /////////////////////
    // actual scanner
    /////////////////////

    /*!
    @brief skip the UTF-8 byte order mark
    @return true iff there is no BOM or the correct BOM has been skipped
    */
    bool skip_bom()
    {
        if (get() == 0xEF)
        {
            // check if we completely parse the BOM
            return get() == 0xBB && get() == 0xBF;
        }

        // the first character is not the beginning of the BOM; unget it to
        // process is later
        unget();
        return true;
    }

    void skip_whitespace()
    {
        do
        {
            get();
        }
        while (current == ' ' || current == '\t' || current == '\n' || current == '\r');
    }

    token_type scan()
    {
        // initially, skip the BOM
        if (position.chars_read_total == 0 && !skip_bom())
        {
            error_message = "invalid BOM; must be 0xEF 0xBB 0xBF if given";
            return token_type::parse_error;
        }

        // read next character and ignore whitespace
        skip_whitespace();

        // ignore comments
        while (ignore_comments && current == '/')
        {
            if (!scan_comment())
            {
                return token_type::parse_error;
            }

            // skip following whitespace
            skip_whitespace();
        }

        switch (current)
        {
            // structural characters
            case '[':
                return token_type::begin_array;
            case ']':
                return token_type::end_array;
            case '{':
                return token_type::begin_object;
            case '}':
                return token_type::end_object;
            case ':':
                return token_type::name_separator;
            case ',':
                return token_type::value_separator;

            // literals
            case 't':
            {
                std::array<char_type, 4> true_literal = {{'t', 'r', 'u', 'e'}};
                return scan_literal(true_literal.data(), true_literal.size(), token_type::literal_true);
            }
            case 'f':
            {
                std::array<char_type, 5> false_literal = {{'f', 'a', 'l', 's', 'e'}};
                return scan_literal(false_literal.data(), false_literal.size(), token_type::literal_false);
            }
            case 'n':
            {
                std::array<char_type, 4> null_literal = {{'n', 'u', 'l', 'l'}};
                return scan_literal(null_literal.data(), null_literal.size(), token_type::literal_null);
            }

            // string
            case '\"':
                return scan_string();

            // number
            case '-':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                return scan_number();

            // end of input (the null byte is needed when parsing from
            // string literals)
            case '\0':
            case std::char_traits<char_type>::eof():
                return token_type::end_of_input;

            // error
            default:
                error_message = "invalid literal";
                return token_type::parse_error;
        }
    }

  private:
    /// input adapter
    InputAdapterType ia;

    /// whether comments should be ignored (true) or signaled as errors (false)
    const bool ignore_comments = false;

    /// the current character
    char_int_type current = std::char_traits<char_type>::eof();

    /// whether the next get() call should just return current
    bool next_unget = false;

    /// the start position of the current token
    position_t position {};

    /// raw input token string (for error messages)
    std::vector<char_type> token_string {};

    /// buffer for variable-length tokens (numbers, strings)
    string_t token_buffer {};

    /// a description of occurred lexer errors
    const char* error_message = "";

    // number values
    number_integer_t value_integer = 0;
    number_unsigned_t value_unsigned = 0;
    number_float_t value_float = 0;

    /// the decimal point
    const char_int_type decimal_point_char = '.';
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/is_sax.hpp>


#include <cstdint> // size_t
#include <utility> // declval
#include <string> // string

// #include <nlohmann/detail/meta/detected.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>


namespace nlohmann
{
namespace detail
{
template<typename T>
using null_function_t = decltype(std::declval<T&>().null());

template<typename T>
using boolean_function_t =
    decltype(std::declval<T&>().boolean(std::declval<bool>()));

template<typename T, typename Integer>
using number_integer_function_t =
    decltype(std::declval<T&>().number_integer(std::declval<Integer>()));

template<typename T, typename Unsigned>
using number_unsigned_function_t =
    decltype(std::declval<T&>().number_unsigned(std::declval<Unsigned>()));

template<typename T, typename Float, typename String>
using number_float_function_t = decltype(std::declval<T&>().number_float(
                                    std::declval<Float>(), std::declval<const String&>()));

template<typename T, typename String>
using string_function_t =
    decltype(std::declval<T&>().string(std::declval<String&>()));

template<typename T, typename Binary>
using binary_function_t =
    decltype(std::declval<T&>().binary(std::declval<Binary&>()));

template<typename T>
using start_object_function_t =
    decltype(std::declval<T&>().start_object(std::declval<std::size_t>()));

template<typename T, typename String>
using key_function_t =
    decltype(std::declval<T&>().key(std::declval<String&>()));

template<typename T>
using end_object_function_t = decltype(std::declval<T&>().end_object());

template<typename T>
using start_array_function_t =
    decltype(std::declval<T&>().start_array(std::declval<std::size_t>()));

template<typename T>
using end_array_function_t = decltype(std::declval<T&>().end_array());

template<typename T, typename Exception>
using parse_error_function_t = decltype(std::declval<T&>().parse_error(
        std::declval<std::size_t>(), std::declval<const std::string&>(),
        std::declval<const Exception&>()));

template<typename SAX, typename BasicJsonType>
struct is_sax
{
  private:
    static_assert(is_basic_json<BasicJsonType>::value,
                  "BasicJsonType must be of type basic_json<...>");

    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;
    using exception_t = typename BasicJsonType::exception;

  public:
    static constexpr bool value =
        is_detected_exact<bool, null_function_t, SAX>::value &&
        is_detected_exact<bool, boolean_function_t, SAX>::value &&
        is_detected_exact<bool, number_integer_function_t, SAX, number_integer_t>::value &&
        is_detected_exact<bool, number_unsigned_function_t, SAX, number_unsigned_t>::value &&
        is_detected_exact<bool, number_float_function_t, SAX, number_float_t, string_t>::value &&
        is_detected_exact<bool, string_function_t, SAX, string_t>::value &&
        is_detected_exact<bool, binary_function_t, SAX, binary_t>::value &&
        is_detected_exact<bool, start_object_function_t, SAX>::value &&
        is_detected_exact<bool, key_function_t, SAX, string_t>::value &&
        is_detected_exact<bool, end_object_function_t, SAX>::value &&
        is_detected_exact<bool, start_array_function_t, SAX>::value &&
        is_detected_exact<bool, end_array_function_t, SAX>::value &&
        is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value;
};

template<typename SAX, typename BasicJsonType>
struct is_sax_static_asserts
{
  private:
    static_assert(is_basic_json<BasicJsonType>::value,
                  "BasicJsonType must be of type basic_json<...>");

    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;
    using exception_t = typename BasicJsonType::exception;

  public:
    static_assert(is_detected_exact<bool, null_function_t, SAX>::value,
                  "Missing/invalid function: bool null()");
    static_assert(is_detected_exact<bool, boolean_function_t, SAX>::value,
                  "Missing/invalid function: bool boolean(bool)");
    static_assert(is_detected_exact<bool, boolean_function_t, SAX>::value,
                  "Missing/invalid function: bool boolean(bool)");
    static_assert(
        is_detected_exact<bool, number_integer_function_t, SAX,
        number_integer_t>::value,
        "Missing/invalid function: bool number_integer(number_integer_t)");
    static_assert(
        is_detected_exact<bool, number_unsigned_function_t, SAX,
        number_unsigned_t>::value,
        "Missing/invalid function: bool number_unsigned(number_unsigned_t)");
    static_assert(is_detected_exact<bool, number_float_function_t, SAX,
                  number_float_t, string_t>::value,
                  "Missing/invalid function: bool number_float(number_float_t, const string_t&)");
    static_assert(
        is_detected_exact<bool, string_function_t, SAX, string_t>::value,
        "Missing/invalid function: bool string(string_t&)");
    static_assert(
        is_detected_exact<bool, binary_function_t, SAX, binary_t>::value,
        "Missing/invalid function: bool binary(binary_t&)");
    static_assert(is_detected_exact<bool, start_object_function_t, SAX>::value,
                  "Missing/invalid function: bool start_object(std::size_t)");
    static_assert(is_detected_exact<bool, key_function_t, SAX, string_t>::value,
                  "Missing/invalid function: bool key(string_t&)");
    static_assert(is_detected_exact<bool, end_object_function_t, SAX>::value,
                  "Missing/invalid function: bool end_object()");
    static_assert(is_detected_exact<bool, start_array_function_t, SAX>::value,
                  "Missing/invalid function: bool start_array(std::size_t)");
    static_assert(is_detected_exact<bool, end_array_function_t, SAX>::value,
                  "Missing/invalid function: bool end_array()");
    static_assert(
        is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value,
        "Missing/invalid function: bool parse_error(std::size_t, const "
        "std::string&, const exception&)");
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
namespace detail
{

/// how to treat CBOR tags
enum class cbor_tag_handler_t
{
    error,  ///< throw a parse_error exception in case of a tag
    ignore   ///< ignore tags
};

/*!
@brief determine system byte order

@return true if and only if system's byte order is little endian

@note from https://stackoverflow.com/a/1001328/266378
*/
static inline bool little_endianess(int num = 1) noexcept
{
    return *reinterpret_cast<char*>(&num) == 1;
}


///////////////////
// binary reader //
///////////////////

/*!
@brief deserialization of CBOR, MessagePack, and UBJSON values
*/
template<typename BasicJsonType, typename InputAdapterType, typename SAX = json_sax_dom_parser<BasicJsonType>>
class binary_reader
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;
    using json_sax_t = SAX;
    using char_type = typename InputAdapterType::char_type;
    using char_int_type = typename std::char_traits<char_type>::int_type;

  public:
    /*!
    @brief create a binary reader

    @param[in] adapter  input adapter to read from
    */
    explicit binary_reader(InputAdapterType&& adapter) : ia(std::move(adapter))
    {
        (void)detail::is_sax_static_asserts<SAX, BasicJsonType> {};
    }

    // make class move-only
    binary_reader(const binary_reader&) = delete;
    binary_reader(binary_reader&&) = default;
    binary_reader& operator=(const binary_reader&) = delete;
    binary_reader& operator=(binary_reader&&) = default;
    ~binary_reader() = default;

    /*!
    @param[in] format  the binary format to parse
    @param[in] sax_    a SAX event processor
    @param[in] strict  whether to expect the input to be consumed completed
    @param[in] tag_handler  how to treat CBOR tags

    @return
    */
    JSON_HEDLEY_NON_NULL(3)
    bool sax_parse(const input_format_t format,
                   json_sax_t* sax_,
                   const bool strict = true,
                   const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
    {
        sax = sax_;
        bool result = false;

        switch (format)
        {
            case input_format_t::bson:
                result = parse_bson_internal();
                break;

            case input_format_t::cbor:
                result = parse_cbor_internal(true, tag_handler);
                break;

            case input_format_t::msgpack:
                result = parse_msgpack_internal();
                break;

            case input_format_t::ubjson:
                result = parse_ubjson_internal();
                break;

            default:            // LCOV_EXCL_LINE
                JSON_ASSERT(false);  // LCOV_EXCL_LINE
        }

        // strict mode: next byte must be EOF
        if (result && strict)
        {
            if (format == input_format_t::ubjson)
            {
                get_ignore_noop();
            }
            else
            {
                get();
            }

            if (JSON_HEDLEY_UNLIKELY(current != std::char_traits<char_type>::eof()))
            {
                return sax->parse_error(chars_read, get_token_string(),
                                        parse_error::create(110, chars_read, exception_message(format, "expected end of input; last byte: 0x" + get_token_string(), "value")));
            }
        }

        return result;
    }

  private:
    //////////
    // BSON //
    //////////

    /*!
    @brief Reads in a BSON-object and passes it to the SAX-parser.
    @return whether a valid BSON-value was passed to the SAX parser
    */
    bool parse_bson_internal()
    {
        std::int32_t document_size{};
        get_number<std::int32_t, true>(input_format_t::bson, document_size);

        if (JSON_HEDLEY_UNLIKELY(!sax->start_object(std::size_t(-1))))
        {
            return false;
        }

        if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_list(/*is_array*/false)))
        {
            return false;
        }

        return sax->end_object();
    }

    /*!
    @brief Parses a C-style string from the BSON input.
    @param[in, out] result  A reference to the string variable where the read
                            string is to be stored.
    @return `true` if the \x00-byte indicating the end of the string was
             encountered before the EOF; false` indicates an unexpected EOF.
    */
    bool get_bson_cstr(string_t& result)
    {
        auto out = std::back_inserter(result);
        while (true)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::bson, "cstring")))
            {
                return false;
            }
            if (current == 0x00)
            {
                return true;
            }
            *out++ = static_cast<typename string_t::value_type>(current);
        }
    }

    /*!
    @brief Parses a zero-terminated string of length @a len from the BSON
           input.
    @param[in] len  The length (including the zero-byte at the end) of the
                    string to be read.
    @param[in, out] result  A reference to the string variable where the read
                            string is to be stored.
    @tparam NumberType The type of the length @a len
    @pre len >= 1
    @return `true` if the string was successfully parsed
    */
    template<typename NumberType>
    bool get_bson_string(const NumberType len, string_t& result)
    {
        if (JSON_HEDLEY_UNLIKELY(len < 1))
        {
            auto last_token = get_token_string();
            return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::bson, "string length must be at least 1, is " + std::to_string(len), "string")));
        }

        return get_string(input_format_t::bson, len - static_cast<NumberType>(1), result) && get() != std::char_traits<char_type>::eof();
    }

    /*!
    @brief Parses a byte array input of length @a len from the BSON input.
    @param[in] len  The length of the byte array to be read.
    @param[in, out] result  A reference to the binary variable where the read
                            array is to be stored.
    @tparam NumberType The type of the length @a len
    @pre len >= 0
    @return `true` if the byte array was successfully parsed
    */
    template<typename NumberType>
    bool get_bson_binary(const NumberType len, binary_t& result)
    {
        if (JSON_HEDLEY_UNLIKELY(len < 0))
        {
            auto last_token = get_token_string();
            return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::bson, "byte array length cannot be negative, is " + std::to_string(len), "binary")));
        }

        // All BSON binary values have a subtype
        std::uint8_t subtype{};
        get_number<std::uint8_t>(input_format_t::bson, subtype);
        result.set_subtype(subtype);

        return get_binary(input_format_t::bson, len, result);
    }

    /*!
    @brief Read a BSON document element of the given @a element_type.
    @param[in] element_type The BSON element type, c.f. http://bsonspec.org/spec.html
    @param[in] element_type_parse_position The position in the input stream,
               where the `element_type` was read.
    @warning Not all BSON element types are supported yet. An unsupported
             @a element_type will give rise to a parse_error.114:
             Unsupported BSON record type 0x...
    @return whether a valid BSON-object/array was passed to the SAX parser
    */
    bool parse_bson_element_internal(const char_int_type element_type,
                                     const std::size_t element_type_parse_position)
    {
        switch (element_type)
        {
            case 0x01: // double
            {
                double number{};
                return get_number<double, true>(input_format_t::bson, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 0x02: // string
            {
                std::int32_t len{};
                string_t value;
                return get_number<std::int32_t, true>(input_format_t::bson, len) && get_bson_string(len, value) && sax->string(value);
            }

            case 0x03: // object
            {
                return parse_bson_internal();
            }

            case 0x04: // array
            {
                return parse_bson_array();
            }

            case 0x05: // binary
            {
                std::int32_t len{};
                binary_t value;
                return get_number<std::int32_t, true>(input_format_t::bson, len) && get_bson_binary(len, value) && sax->binary(value);
            }

            case 0x08: // boolean
            {
                return sax->boolean(get() != 0);
            }

            case 0x0A: // null
            {
                return sax->null();
            }

            case 0x10: // int32
            {
                std::int32_t value{};
                return get_number<std::int32_t, true>(input_format_t::bson, value) && sax->number_integer(value);
            }

            case 0x12: // int64
            {
                std::int64_t value{};
                return get_number<std::int64_t, true>(input_format_t::bson, value) && sax->number_integer(value);
            }

            default: // anything else not supported (yet)
            {
                std::array<char, 3> cr{{}};
                (std::snprintf)(cr.data(), cr.size(), "%.2hhX", static_cast<unsigned char>(element_type));
                return sax->parse_error(element_type_parse_position, std::string(cr.data()), parse_error::create(114, element_type_parse_position, "Unsupported BSON record type 0x" + std::string(cr.data())));
            }
        }
    }

    /*!
    @brief Read a BSON element list (as specified in the BSON-spec)

    The same binary layout is used for objects and arrays, hence it must be
    indicated with the argument @a is_array which one is expected
    (true --> array, false --> object).

    @param[in] is_array Determines if the element list being read is to be
                        treated as an object (@a is_array == false), or as an
                        array (@a is_array == true).
    @return whether a valid BSON-object/array was passed to the SAX parser
    */
    bool parse_bson_element_list(const bool is_array)
    {
        string_t key;

        while (auto element_type = get())
        {
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::bson, "element list")))
            {
                return false;
            }

            const std::size_t element_type_parse_position = chars_read;
            if (JSON_HEDLEY_UNLIKELY(!get_bson_cstr(key)))
            {
                return false;
            }

            if (!is_array && !sax->key(key))
            {
                return false;
            }

            if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_internal(element_type, element_type_parse_position)))
            {
                return false;
            }

            // get_bson_cstr only appends
            key.clear();
        }

        return true;
    }

    /*!
    @brief Reads an array from the BSON input and passes it to the SAX-parser.
    @return whether a valid BSON-array was passed to the SAX parser
    */
    bool parse_bson_array()
    {
        std::int32_t document_size{};
        get_number<std::int32_t, true>(input_format_t::bson, document_size);

        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(std::size_t(-1))))
        {
            return false;
        }

        if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_list(/*is_array*/true)))
        {
            return false;
        }

        return sax->end_array();
    }

    //////////
    // CBOR //
    //////////

    /*!
    @param[in] get_char  whether a new character should be retrieved from the
                         input (true) or whether the last read character should
                         be considered instead (false)
    @param[in] tag_handler how CBOR tags should be treated

    @return whether a valid CBOR value was passed to the SAX parser
    */
    bool parse_cbor_internal(const bool get_char,
                             const cbor_tag_handler_t tag_handler)
    {
        switch (get_char ? get() : current)
        {
            // EOF
            case std::char_traits<char_type>::eof():
                return unexpect_eof(input_format_t::cbor, "value");

            // Integer 0x00..0x17 (0..23)
            case 0x00:
            case 0x01:
            case 0x02:
            case 0x03:
            case 0x04:
            case 0x05:
            case 0x06:
            case 0x07:
            case 0x08:
            case 0x09:
            case 0x0A:
            case 0x0B:
            case 0x0C:
            case 0x0D:
            case 0x0E:
            case 0x0F:
            case 0x10:
            case 0x11:
            case 0x12:
            case 0x13:
            case 0x14:
            case 0x15:
            case 0x16:
            case 0x17:
                return sax->number_unsigned(static_cast<number_unsigned_t>(current));

            case 0x18: // Unsigned integer (one-byte uint8_t follows)
            {
                std::uint8_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
            }

            case 0x19: // Unsigned integer (two-byte uint16_t follows)
            {
                std::uint16_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
            }

            case 0x1A: // Unsigned integer (four-byte uint32_t follows)
            {
                std::uint32_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
            }

            case 0x1B: // Unsigned integer (eight-byte uint64_t follows)
            {
                std::uint64_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
            }

            // Negative integer -1-0x00..-1-0x17 (-1..-24)
            case 0x20:
            case 0x21:
            case 0x22:
            case 0x23:
            case 0x24:
            case 0x25:
            case 0x26:
            case 0x27:
            case 0x28:
            case 0x29:
            case 0x2A:
            case 0x2B:
            case 0x2C:
            case 0x2D:
            case 0x2E:
            case 0x2F:
            case 0x30:
            case 0x31:
            case 0x32:
            case 0x33:
            case 0x34:
            case 0x35:
            case 0x36:
            case 0x37:
                return sax->number_integer(static_cast<std::int8_t>(0x20 - 1 - current));

            case 0x38: // Negative integer (one-byte uint8_t follows)
            {
                std::uint8_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1) - number);
            }

            case 0x39: // Negative integer -1-n (two-byte uint16_t follows)
            {
                std::uint16_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1) - number);
            }

            case 0x3A: // Negative integer -1-n (four-byte uint32_t follows)
            {
                std::uint32_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1) - number);
            }

            case 0x3B: // Negative integer -1-n (eight-byte uint64_t follows)
            {
                std::uint64_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1)
                        - static_cast<number_integer_t>(number));
            }

            // Binary data (0x00..0x17 bytes follow)
            case 0x40:
            case 0x41:
            case 0x42:
            case 0x43:
            case 0x44:
            case 0x45:
            case 0x46:
            case 0x47:
            case 0x48:
            case 0x49:
            case 0x4A:
            case 0x4B:
            case 0x4C:
            case 0x4D:
            case 0x4E:
            case 0x4F:
            case 0x50:
            case 0x51:
            case 0x52:
            case 0x53:
            case 0x54:
            case 0x55:
            case 0x56:
            case 0x57:
            case 0x58: // Binary data (one-byte uint8_t for n follows)
            case 0x59: // Binary data (two-byte uint16_t for n follow)
            case 0x5A: // Binary data (four-byte uint32_t for n follow)
            case 0x5B: // Binary data (eight-byte uint64_t for n follow)
            case 0x5F: // Binary data (indefinite length)
            {
                binary_t b;
                return get_cbor_binary(b) && sax->binary(b);
            }

            // UTF-8 string (0x00..0x17 bytes follow)
            case 0x60:
            case 0x61:
            case 0x62:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
            case 0x68:
            case 0x69:
            case 0x6A:
            case 0x6B:
            case 0x6C:
            case 0x6D:
            case 0x6E:
            case 0x6F:
            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
            case 0x74:
            case 0x75:
            case 0x76:
            case 0x77:
            case 0x78: // UTF-8 string (one-byte uint8_t for n follows)
            case 0x79: // UTF-8 string (two-byte uint16_t for n follow)
            case 0x7A: // UTF-8 string (four-byte uint32_t for n follow)
            case 0x7B: // UTF-8 string (eight-byte uint64_t for n follow)
            case 0x7F: // UTF-8 string (indefinite length)
            {
                string_t s;
                return get_cbor_string(s) && sax->string(s);
            }

            // array (0x00..0x17 data items follow)
            case 0x80:
            case 0x81:
            case 0x82:
            case 0x83:
            case 0x84:
            case 0x85:
            case 0x86:
            case 0x87:
            case 0x88:
            case 0x89:
            case 0x8A:
            case 0x8B:
            case 0x8C:
            case 0x8D:
            case 0x8E:
            case 0x8F:
            case 0x90:
            case 0x91:
            case 0x92:
            case 0x93:
            case 0x94:
            case 0x95:
            case 0x96:
            case 0x97:
                return get_cbor_array(static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x1Fu), tag_handler);

            case 0x98: // array (one-byte uint8_t for n follows)
            {
                std::uint8_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_array(static_cast<std::size_t>(len), tag_handler);
            }

            case 0x99: // array (two-byte uint16_t for n follow)
            {
                std::uint16_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_array(static_cast<std::size_t>(len), tag_handler);
            }

            case 0x9A: // array (four-byte uint32_t for n follow)
            {
                std::uint32_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_array(static_cast<std::size_t>(len), tag_handler);
            }

            case 0x9B: // array (eight-byte uint64_t for n follow)
            {
                std::uint64_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_array(static_cast<std::size_t>(len), tag_handler);
            }

            case 0x9F: // array (indefinite length)
                return get_cbor_array(std::size_t(-1), tag_handler);

            // map (0x00..0x17 pairs of data items follow)
            case 0xA0:
            case 0xA1:
            case 0xA2:
            case 0xA3:
            case 0xA4:
            case 0xA5:
            case 0xA6:
            case 0xA7:
            case 0xA8:
            case 0xA9:
            case 0xAA:
            case 0xAB:
            case 0xAC:
            case 0xAD:
            case 0xAE:
            case 0xAF:
            case 0xB0:
            case 0xB1:
            case 0xB2:
            case 0xB3:
            case 0xB4:
            case 0xB5:
            case 0xB6:
            case 0xB7:
                return get_cbor_object(static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x1Fu), tag_handler);

            case 0xB8: // map (one-byte uint8_t for n follows)
            {
                std::uint8_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_object(static_cast<std::size_t>(len), tag_handler);
            }

            case 0xB9: // map (two-byte uint16_t for n follow)
            {
                std::uint16_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_object(static_cast<std::size_t>(len), tag_handler);
            }

            case 0xBA: // map (four-byte uint32_t for n follow)
            {
                std::uint32_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_object(static_cast<std::size_t>(len), tag_handler);
            }

            case 0xBB: // map (eight-byte uint64_t for n follow)
            {
                std::uint64_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_object(static_cast<std::size_t>(len), tag_handler);
            }

            case 0xBF: // map (indefinite length)
                return get_cbor_object(std::size_t(-1), tag_handler);

            case 0xC6: // tagged item
            case 0xC7:
            case 0xC8:
            case 0xC9:
            case 0xCA:
            case 0xCB:
            case 0xCC:
            case 0xCD:
            case 0xCE:
            case 0xCF:
            case 0xD0:
            case 0xD1:
            case 0xD2:
            case 0xD3:
            case 0xD4:
            case 0xD8: // tagged item (1 bytes follow)
            case 0xD9: // tagged item (2 bytes follow)
            case 0xDA: // tagged item (4 bytes follow)
            case 0xDB: // tagged item (8 bytes follow)
            {
                switch (tag_handler)
                {
                    case cbor_tag_handler_t::error:
                    {
                        auto last_token = get_token_string();
                        return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::cbor, "invalid byte: 0x" + last_token, "value")));
                    }

                    case cbor_tag_handler_t::ignore:
                    {
                        switch (current)
                        {
                            case 0xD8:
                            {
                                std::uint8_t len{};
                                get_number(input_format_t::cbor, len);
                                break;
                            }
                            case 0xD9:
                            {
                                std::uint16_t len{};
                                get_number(input_format_t::cbor, len);
                                break;
                            }
                            case 0xDA:
                            {
                                std::uint32_t len{};
                                get_number(input_format_t::cbor, len);
                                break;
                            }
                            case 0xDB:
                            {
                                std::uint64_t len{};
                                get_number(input_format_t::cbor, len);
                                break;
                            }
                            default:
                                break;
                        }
                        return parse_cbor_internal(true, tag_handler);
                    }

                    default:            // LCOV_EXCL_LINE
                        JSON_ASSERT(false);  // LCOV_EXCL_LINE
                }
            }

            case 0xF4: // false
                return sax->boolean(false);

            case 0xF5: // true
                return sax->boolean(true);

            case 0xF6: // null
                return sax->null();

            case 0xF9: // Half-Precision Float (two-byte IEEE 754)
            {
                const auto byte1_raw = get();
                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "number")))
                {
                    return false;
                }
                const auto byte2_raw = get();
                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "number")))
                {
                    return false;
                }

                const auto byte1 = static_cast<unsigned char>(byte1_raw);
                const auto byte2 = static_cast<unsigned char>(byte2_raw);

                // code from RFC 7049, Appendix D, Figure 3:
                // As half-precision floating-point numbers were only added
                // to IEEE 754 in 2008, today's programming platforms often
                // still only have limited support for them. It is very
                // easy to include at least decoding support for them even
                // without such support. An example of a small decoder for
                // half-precision floating-point numbers in the C language
                // is shown in Fig. 3.
                const auto half = static_cast<unsigned int>((byte1 << 8u) + byte2);
                const double val = [&half]
                {
                    const int exp = (half >> 10u) & 0x1Fu;
                    const unsigned int mant = half & 0x3FFu;
                    JSON_ASSERT(0 <= exp&& exp <= 32);
                    JSON_ASSERT(mant <= 1024);
                    switch (exp)
                    {
                        case 0:
                            return std::ldexp(mant, -24);
                        case 31:
                            return (mant == 0)
                            ? std::numeric_limits<double>::infinity()
                            : std::numeric_limits<double>::quiet_NaN();
                        default:
                            return std::ldexp(mant + 1024, exp - 25);
                    }
                }();
                return sax->number_float((half & 0x8000u) != 0
                                         ? static_cast<number_float_t>(-val)
                                         : static_cast<number_float_t>(val), "");
            }

            case 0xFA: // Single-Precision Float (four-byte IEEE 754)
            {
                float number{};
                return get_number(input_format_t::cbor, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 0xFB: // Double-Precision Float (eight-byte IEEE 754)
            {
                double number{};
                return get_number(input_format_t::cbor, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            default: // anything else (0xFF is handled inside the other types)
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::cbor, "invalid byte: 0x" + last_token, "value")));
            }
        }
    }

    /*!
    @brief reads a CBOR string

    This function first reads starting bytes to determine the expected
    string length and then copies this number of bytes into a string.
    Additionally, CBOR's strings with indefinite lengths are supported.

    @param[out] result  created string

    @return whether string creation completed
    */
    bool get_cbor_string(string_t& result)
    {
        if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "string")))
        {
            return false;
        }

        switch (current)
        {
            // UTF-8 string (0x00..0x17 bytes follow)
            case 0x60:
            case 0x61:
            case 0x62:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
            case 0x68:
            case 0x69:
            case 0x6A:
            case 0x6B:
            case 0x6C:
            case 0x6D:
            case 0x6E:
            case 0x6F:
            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
            case 0x74:
            case 0x75:
            case 0x76:
            case 0x77:
            {
                return get_string(input_format_t::cbor, static_cast<unsigned int>(current) & 0x1Fu, result);
            }

            case 0x78: // UTF-8 string (one-byte uint8_t for n follows)
            {
                std::uint8_t len{};
                return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
            }

            case 0x79: // UTF-8 string (two-byte uint16_t for n follow)
            {
                std::uint16_t len{};
                return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
            }

            case 0x7A: // UTF-8 string (four-byte uint32_t for n follow)
            {
                std::uint32_t len{};
                return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
            }

            case 0x7B: // UTF-8 string (eight-byte uint64_t for n follow)
            {
                std::uint64_t len{};
                return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
            }

            case 0x7F: // UTF-8 string (indefinite length)
            {
                while (get() != 0xFF)
                {
                    string_t chunk;
                    if (!get_cbor_string(chunk))
                    {
                        return false;
                    }
                    result.append(chunk);
                }
                return true;
            }

            default:
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::cbor, "expected length specification (0x60-0x7B) or indefinite string type (0x7F); last byte: 0x" + last_token, "string")));
            }
        }
    }

    /*!
    @brief reads a CBOR byte array

    This function first reads starting bytes to determine the expected
    byte array length and then copies this number of bytes into the byte array.
    Additionally, CBOR's byte arrays with indefinite lengths are supported.

    @param[out] result  created byte array

    @return whether byte array creation completed
    */
    bool get_cbor_binary(binary_t& result)
    {
        if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "binary")))
        {
            return false;
        }

        switch (current)
        {
            // Binary data (0x00..0x17 bytes follow)
            case 0x40:
            case 0x41:
            case 0x42:
            case 0x43:
            case 0x44:
            case 0x45:
            case 0x46:
            case 0x47:
            case 0x48:
            case 0x49:
            case 0x4A:
            case 0x4B:
            case 0x4C:
            case 0x4D:
            case 0x4E:
            case 0x4F:
            case 0x50:
            case 0x51:
            case 0x52:
            case 0x53:
            case 0x54:
            case 0x55:
            case 0x56:
            case 0x57:
            {
                return get_binary(input_format_t::cbor, static_cast<unsigned int>(current) & 0x1Fu, result);
            }

            case 0x58: // Binary data (one-byte uint8_t for n follows)
            {
                std::uint8_t len{};
                return get_number(input_format_t::cbor, len) &&
                       get_binary(input_format_t::cbor, len, result);
            }

            case 0x59: // Binary data (two-byte uint16_t for n follow)
            {
                std::uint16_t len{};
                return get_number(input_format_t::cbor, len) &&
                       get_binary(input_format_t::cbor, len, result);
            }

            case 0x5A: // Binary data (four-byte uint32_t for n follow)
            {
                std::uint32_t len{};
                return get_number(input_format_t::cbor, len) &&
                       get_binary(input_format_t::cbor, len, result);
            }

            case 0x5B: // Binary data (eight-byte uint64_t for n follow)
            {
                std::uint64_t len{};
                return get_number(input_format_t::cbor, len) &&
                       get_binary(input_format_t::cbor, len, result);
            }

            case 0x5F: // Binary data (indefinite length)
            {
                while (get() != 0xFF)
                {
                    binary_t chunk;
                    if (!get_cbor_binary(chunk))
                    {
                        return false;
                    }
                    result.insert(result.end(), chunk.begin(), chunk.end());
                }
                return true;
            }

            default:
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::cbor, "expected length specification (0x40-0x5B) or indefinite binary array type (0x5F); last byte: 0x" + last_token, "binary")));
            }
        }
    }

    /*!
    @param[in] len  the length of the array or std::size_t(-1) for an
                    array of indefinite size
    @param[in] tag_handler how CBOR tags should be treated
    @return whether array creation completed
    */
    bool get_cbor_array(const std::size_t len,
                        const cbor_tag_handler_t tag_handler)
    {
        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(len)))
        {
            return false;
        }

        if (len != std::size_t(-1))
        {
            for (std::size_t i = 0; i < len; ++i)
            {
                if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
                {
                    return false;
                }
            }
        }
        else
        {
            while (get() != 0xFF)
            {
                if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(false, tag_handler)))
                {
                    return false;
                }
            }
        }

        return sax->end_array();
    }

    /*!
    @param[in] len  the length of the object or std::size_t(-1) for an
                    object of indefinite size
    @param[in] tag_handler how CBOR tags should be treated
    @return whether object creation completed
    */
    bool get_cbor_object(const std::size_t len,
                         const cbor_tag_handler_t tag_handler)
    {
        if (JSON_HEDLEY_UNLIKELY(!sax->start_object(len)))
        {
            return false;
        }

        string_t key;
        if (len != std::size_t(-1))
        {
            for (std::size_t i = 0; i < len; ++i)
            {
                get();
                if (JSON_HEDLEY_UNLIKELY(!get_cbor_string(key) || !sax->key(key)))
                {
                    return false;
                }

                if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
                {
                    return false;
                }
                key.clear();
            }
        }
        else
        {
            while (get() != 0xFF)
            {
                if (JSON_HEDLEY_UNLIKELY(!get_cbor_string(key) || !sax->key(key)))
                {
                    return false;
                }

                if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
                {
                    return false;
                }
                key.clear();
            }
        }

        return sax->end_object();
    }

    /////////////
    // MsgPack //
    /////////////

    /*!
    @return whether a valid MessagePack value was passed to the SAX parser
    */
    bool parse_msgpack_internal()
    {
        switch (get())
        {
            // EOF
            case std::char_traits<char_type>::eof():
                return unexpect_eof(input_format_t::msgpack, "value");

            // positive fixint
            case 0x00:
            case 0x01:
            case 0x02:
            case 0x03:
            case 0x04:
            case 0x05:
            case 0x06:
            case 0x07:
            case 0x08:
            case 0x09:
            case 0x0A:
            case 0x0B:
            case 0x0C:
            case 0x0D:
            case 0x0E:
            case 0x0F:
            case 0x10:
            case 0x11:
            case 0x12:
            case 0x13:
            case 0x14:
            case 0x15:
            case 0x16:
            case 0x17:
            case 0x18:
            case 0x19:
            case 0x1A:
            case 0x1B:
            case 0x1C:
            case 0x1D:
            case 0x1E:
            case 0x1F:
            case 0x20:
            case 0x21:
            case 0x22:
            case 0x23:
            case 0x24:
            case 0x25:
            case 0x26:
            case 0x27:
            case 0x28:
            case 0x29:
            case 0x2A:
            case 0x2B:
            case 0x2C:
            case 0x2D:
            case 0x2E:
            case 0x2F:
            case 0x30:
            case 0x31:
            case 0x32:
            case 0x33:
            case 0x34:
            case 0x35:
            case 0x36:
            case 0x37:
            case 0x38:
            case 0x39:
            case 0x3A:
            case 0x3B:
            case 0x3C:
            case 0x3D:
            case 0x3E:
            case 0x3F:
            case 0x40:
            case 0x41:
            case 0x42:
            case 0x43:
            case 0x44:
            case 0x45:
            case 0x46:
            case 0x47:
            case 0x48:
            case 0x49:
            case 0x4A:
            case 0x4B:
            case 0x4C:
            case 0x4D:
            case 0x4E:
            case 0x4F:
            case 0x50:
            case 0x51:
            case 0x52:
            case 0x53:
            case 0x54:
            case 0x55:
            case 0x56:
            case 0x57:
            case 0x58:
            case 0x59:
            case 0x5A:
            case 0x5B:
            case 0x5C:
            case 0x5D:
            case 0x5E:
            case 0x5F:
            case 0x60:
            case 0x61:
            case 0x62:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
            case 0x68:
            case 0x69:
            case 0x6A:
            case 0x6B:
            case 0x6C:
            case 0x6D:
            case 0x6E:
            case 0x6F:
            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
            case 0x74:
            case 0x75:
            case 0x76:
            case 0x77:
            case 0x78:
            case 0x79:
            case 0x7A:
            case 0x7B:
            case 0x7C:
            case 0x7D:
            case 0x7E:
            case 0x7F:
                return sax->number_unsigned(static_cast<number_unsigned_t>(current));

            // fixmap
            case 0x80:
            case 0x81:
            case 0x82:
            case 0x83:
            case 0x84:
            case 0x85:
            case 0x86:
            case 0x87:
            case 0x88:
            case 0x89:
            case 0x8A:
            case 0x8B:
            case 0x8C:
            case 0x8D:
            case 0x8E:
            case 0x8F:
                return get_msgpack_object(static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x0Fu));

            // fixarray
            case 0x90:
            case 0x91:
            case 0x92:
            case 0x93:
            case 0x94:
            case 0x95:
            case 0x96:
            case 0x97:
            case 0x98:
            case 0x99:
            case 0x9A:
            case 0x9B:
            case 0x9C:
            case 0x9D:
            case 0x9E:
            case 0x9F:
                return get_msgpack_array(static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x0Fu));

            // fixstr
            case 0xA0:
            case 0xA1:
            case 0xA2:
            case 0xA3:
            case 0xA4:
            case 0xA5:
            case 0xA6:
            case 0xA7:
            case 0xA8:
            case 0xA9:
            case 0xAA:
            case 0xAB:
            case 0xAC:
            case 0xAD:
            case 0xAE:
            case 0xAF:
            case 0xB0:
            case 0xB1:
            case 0xB2:
            case 0xB3:
            case 0xB4:
            case 0xB5:
            case 0xB6:
            case 0xB7:
            case 0xB8:
            case 0xB9:
            case 0xBA:
            case 0xBB:
            case 0xBC:
            case 0xBD:
            case 0xBE:
            case 0xBF:
            case 0xD9: // str 8
            case 0xDA: // str 16
            case 0xDB: // str 32
            {
                string_t s;
                return get_msgpack_string(s) && sax->string(s);
            }

            case 0xC0: // nil
                return sax->null();

            case 0xC2: // false
                return sax->boolean(false);

            case 0xC3: // true
                return sax->boolean(true);

            case 0xC4: // bin 8
            case 0xC5: // bin 16
            case 0xC6: // bin 32
            case 0xC7: // ext 8
            case 0xC8: // ext 16
            case 0xC9: // ext 32
            case 0xD4: // fixext 1
            case 0xD5: // fixext 2
            case 0xD6: // fixext 4
            case 0xD7: // fixext 8
            case 0xD8: // fixext 16
            {
                binary_t b;
                return get_msgpack_binary(b) && sax->binary(b);
            }

            case 0xCA: // float 32
            {
                float number{};
                return get_number(input_format_t::msgpack, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 0xCB: // float 64
            {
                double number{};
                return get_number(input_format_t::msgpack, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 0xCC: // uint 8
            {
                std::uint8_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
            }

            case 0xCD: // uint 16
            {
                std::uint16_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
            }

            case 0xCE: // uint 32
            {
                std::uint32_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
            }

            case 0xCF: // uint 64
            {
                std::uint64_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
            }

            case 0xD0: // int 8
            {
                std::int8_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
            }

            case 0xD1: // int 16
            {
                std::int16_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
            }

            case 0xD2: // int 32
            {
                std::int32_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
            }

            case 0xD3: // int 64
            {
                std::int64_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
            }

            case 0xDC: // array 16
            {
                std::uint16_t len{};
                return get_number(input_format_t::msgpack, len) && get_msgpack_array(static_cast<std::size_t>(len));
            }

            case 0xDD: // array 32
            {
                std::uint32_t len{};
                return get_number(input_format_t::msgpack, len) && get_msgpack_array(static_cast<std::size_t>(len));
            }

            case 0xDE: // map 16
            {
                std::uint16_t len{};
                return get_number(input_format_t::msgpack, len) && get_msgpack_object(static_cast<std::size_t>(len));
            }

            case 0xDF: // map 32
            {
                std::uint32_t len{};
                return get_number(input_format_t::msgpack, len) && get_msgpack_object(static_cast<std::size_t>(len));
            }

            // negative fixint
            case 0xE0:
            case 0xE1:
            case 0xE2:
            case 0xE3:
            case 0xE4:
            case 0xE5:
            case 0xE6:
            case 0xE7:
            case 0xE8:
            case 0xE9:
            case 0xEA:
            case 0xEB:
            case 0xEC:
            case 0xED:
            case 0xEE:
            case 0xEF:
            case 0xF0:
            case 0xF1:
            case 0xF2:
            case 0xF3:
            case 0xF4:
            case 0xF5:
            case 0xF6:
            case 0xF7:
            case 0xF8:
            case 0xF9:
            case 0xFA:
            case 0xFB:
            case 0xFC:
            case 0xFD:
            case 0xFE:
            case 0xFF:
                return sax->number_integer(static_cast<std::int8_t>(current));

            default: // anything else
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::msgpack, "invalid byte: 0x" + last_token, "value")));
            }
        }
    }

    /*!
    @brief reads a MessagePack string

    This function first reads starting bytes to determine the expected
    string length and then copies this number of bytes into a string.

    @param[out] result  created string

    @return whether string creation completed
    */
    bool get_msgpack_string(string_t& result)
    {
        if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::msgpack, "string")))
        {
            return false;
        }

        switch (current)
        {
            // fixstr
            case 0xA0:
            case 0xA1:
            case 0xA2:
            case 0xA3:
            case 0xA4:
            case 0xA5:
            case 0xA6:
            case 0xA7:
            case 0xA8:
            case 0xA9:
            case 0xAA:
            case 0xAB:
            case 0xAC:
            case 0xAD:
            case 0xAE:
            case 0xAF:
            case 0xB0:
            case 0xB1:
            case 0xB2:
            case 0xB3:
            case 0xB4:
            case 0xB5:
            case 0xB6:
            case 0xB7:
            case 0xB8:
            case 0xB9:
            case 0xBA:
            case 0xBB:
            case 0xBC:
            case 0xBD:
            case 0xBE:
            case 0xBF:
            {
                return get_string(input_format_t::msgpack, static_cast<unsigned int>(current) & 0x1Fu, result);
            }

            case 0xD9: // str 8
            {
                std::uint8_t len{};
                return get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);
            }

            case 0xDA: // str 16
            {
                std::uint16_t len{};
                return get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);
            }

            case 0xDB: // str 32
            {
                std::uint32_t len{};
                return get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);
            }

            default:
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::msgpack, "expected length specification (0xA0-0xBF, 0xD9-0xDB); last byte: 0x" + last_token, "string")));
            }
        }
    }

    /*!
    @brief reads a MessagePack byte array

    This function first reads starting bytes to determine the expected
    byte array length and then copies this number of bytes into a byte array.

    @param[out] result  created byte array

    @return whether byte array creation completed
    */
    bool get_msgpack_binary(binary_t& result)
    {
        // helper function to set the subtype
        auto assign_and_return_true = [&result](std::int8_t subtype)
        {
            result.set_subtype(static_cast<std::uint8_t>(subtype));
            return true;
        };

        switch (current)
        {
            case 0xC4: // bin 8
            {
                std::uint8_t len{};
                return get_number(input_format_t::msgpack, len) &&
                       get_binary(input_format_t::msgpack, len, result);
            }

            case 0xC5: // bin 16
            {
                std::uint16_t len{};
                return get_number(input_format_t::msgpack, len) &&
                       get_binary(input_format_t::msgpack, len, result);
            }

            case 0xC6: // bin 32
            {
                std::uint32_t len{};
                return get_number(input_format_t::msgpack, len) &&
                       get_binary(input_format_t::msgpack, len, result);
            }

            case 0xC7: // ext 8
            {
                std::uint8_t len{};
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, len) &&
                       get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, len, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xC8: // ext 16
            {
                std::uint16_t len{};
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, len) &&
                       get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, len, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xC9: // ext 32
            {
                std::uint32_t len{};
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, len) &&
                       get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, len, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xD4: // fixext 1
            {
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, 1, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xD5: // fixext 2
            {
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, 2, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xD6: // fixext 4
            {
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, 4, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xD7: // fixext 8
            {
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, 8, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xD8: // fixext 16
            {
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, 16, result) &&
                       assign_and_return_true(subtype);
            }

            default:           // LCOV_EXCL_LINE
                return false;  // LCOV_EXCL_LINE
        }
    }

    /*!
    @param[in] len  the length of the array
    @return whether array creation completed
    */
    bool get_msgpack_array(const std::size_t len)
    {
        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(len)))
        {
            return false;
        }

        for (std::size_t i = 0; i < len; ++i)
        {
            if (JSON_HEDLEY_UNLIKELY(!parse_msgpack_internal()))
            {
                return false;
            }
        }

        return sax->end_array();
    }

    /*!
    @param[in] len  the length of the object
    @return whether object creation completed
    */
    bool get_msgpack_object(const std::size_t len)
    {
        if (JSON_HEDLEY_UNLIKELY(!sax->start_object(len)))
        {
            return false;
        }

        string_t key;
        for (std::size_t i = 0; i < len; ++i)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(!get_msgpack_string(key) || !sax->key(key)))
            {
                return false;
            }

            if (JSON_HEDLEY_UNLIKELY(!parse_msgpack_internal()))
            {
                return false;
            }
            key.clear();
        }

        return sax->end_object();
    }

    ////////////
    // UBJSON //
    ////////////

    /*!
    @param[in] get_char  whether a new character should be retrieved from the
                         input (true, default) or whether the last read
                         character should be considered instead

    @return whether a valid UBJSON value was passed to the SAX parser
    */
    bool parse_ubjson_internal(const bool get_char = true)
    {
        return get_ubjson_value(get_char ? get_ignore_noop() : current);
    }

    /*!
    @brief reads a UBJSON string

    This function is either called after reading the 'S' byte explicitly
    indicating a string, or in case of an object key where the 'S' byte can be
    left out.

    @param[out] result   created string
    @param[in] get_char  whether a new character should be retrieved from the
                         input (true, default) or whether the last read
                         character should be considered instead

    @return whether string creation completed
    */
    bool get_ubjson_string(string_t& result, const bool get_char = true)
    {
        if (get_char)
        {
            get();  // TODO(niels): may we ignore N here?
        }

        if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, "value")))
        {
            return false;
        }

        switch (current)
        {
            case 'U':
            {
                std::uint8_t len{};
                return get_number(input_format_t::ubjson, len) && get_string(input_format_t::ubjson, len, result);
            }

            case 'i':
            {
                std::int8_t len{};
                return get_number(input_format_t::ubjson, len) && get_string(input_format_t::ubjson, len, result);
            }

            case 'I':
            {
                std::int16_t len{};
                return get_number(input_format_t::ubjson, len) && get_string(input_format_t::ubjson, len, result);
            }

            case 'l':
            {
                std::int32_t len{};
                return get_number(input_format_t::ubjson, len) && get_string(input_format_t::ubjson, len, result);
            }

            case 'L':
            {
                std::int64_t len{};
                return get_number(input_format_t::ubjson, len) && get_string(input_format_t::ubjson, len, result);
            }

            default:
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::ubjson, "expected length type specification (U, i, I, l, L); last byte: 0x" + last_token, "string")));
        }
    }

    /*!
    @param[out] result  determined size
    @return whether size determination completed
    */
    bool get_ubjson_size_value(std::size_t& result)
    {
        switch (get_ignore_noop())
        {
            case 'U':
            {
                std::uint8_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))
                {
                    return false;
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'i':
            {
                std::int8_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))
                {
                    return false;
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'I':
            {
                std::int16_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))
                {
                    return false;
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'l':
            {
                std::int32_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))
                {
                    return false;
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'L':
            {
                std::int64_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))
                {
                    return false;
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            default:
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::ubjson, "expected length type specification (U, i, I, l, L) after '#'; last byte: 0x" + last_token, "size")));
            }
        }
    }

    /*!
    @brief determine the type and size for a container

    In the optimized UBJSON format, a type and a size can be provided to allow
    for a more compact representation.

    @param[out] result  pair of the size and the type

    @return whether pair creation completed
    */
    bool get_ubjson_size_type(std::pair<std::size_t, char_int_type>& result)
    {
        result.first = string_t::npos; // size
        result.second = 0; // type

        get_ignore_noop();

        if (current == '$')
        {
            result.second = get();  // must not ignore 'N', because 'N' maybe the type
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, "type")))
            {
                return false;
            }

            get_ignore_noop();
            if (JSON_HEDLEY_UNLIKELY(current != '#'))
            {
                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, "value")))
                {
                    return false;
                }
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::ubjson, "expected '#' after type information; last byte: 0x" + last_token, "size")));
            }

            return get_ubjson_size_value(result.first);
        }

        if (current == '#')
        {
            return get_ubjson_size_value(result.first);
        }

        return true;
    }

    /*!
    @param prefix  the previously read or set type prefix
    @return whether value creation completed
    */
    bool get_ubjson_value(const char_int_type prefix)
    {
        switch (prefix)
        {
            case std::char_traits<char_type>::eof():  // EOF
                return unexpect_eof(input_format_t::ubjson, "value");

            case 'T':  // true
                return sax->boolean(true);
            case 'F':  // false
                return sax->boolean(false);

            case 'Z':  // null
                return sax->null();

            case 'U':
            {
                std::uint8_t number{};
                return get_number(input_format_t::ubjson, number) && sax->number_unsigned(number);
            }

            case 'i':
            {
                std::int8_t number{};
                return get_number(input_format_t::ubjson, number) && sax->number_integer(number);
            }

            case 'I':
            {
                std::int16_t number{};
                return get_number(input_format_t::ubjson, number) && sax->number_integer(number);
            }

            case 'l':
            {
                std::int32_t number{};
                return get_number(input_format_t::ubjson, number) && sax->number_integer(number);
            }

            case 'L':
            {
                std::int64_t number{};
                return get_number(input_format_t::ubjson, number) && sax->number_integer(number);
            }

            case 'd':
            {
                float number{};
                return get_number(input_format_t::ubjson, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 'D':
            {
                double number{};
                return get_number(input_format_t::ubjson, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 'H':
            {
                return get_ubjson_high_precision_number();
            }

            case 'C':  // char
            {
                get();
                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, "char")))
                {
                    return false;
                }
                if (JSON_HEDLEY_UNLIKELY(current > 127))
                {
                    auto last_token = get_token_string();
                    return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::ubjson, "byte after 'C' must be in range 0x00..0x7F; last byte: 0x" + last_token, "char")));
                }
                string_t s(1, static_cast<typename string_t::value_type>(current));
                return sax->string(s);
            }

            case 'S':  // string
            {
                string_t s;
                return get_ubjson_string(s) && sax->string(s);
            }

            case '[':  // array
                return get_ubjson_array();

            case '{':  // object
                return get_ubjson_object();

            default: // anything else
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::ubjson, "invalid byte: 0x" + last_token, "value")));
            }
        }
    }

    /*!
    @return whether array creation completed
    */
    bool get_ubjson_array()
    {
        std::pair<std::size_t, char_int_type> size_and_type;
        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type)))
        {
            return false;
        }

        if (size_and_type.first != string_t::npos)
        {
            if (JSON_HEDLEY_UNLIKELY(!sax->start_array(size_and_type.first)))
            {
                return false;
            }

            if (size_and_type.second != 0)
            {
                if (size_and_type.second != 'N')
                {
                    for (std::size_t i = 0; i < size_and_type.first; ++i)
                    {
                        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))
                        {
                            return false;
                        }
                    }
                }
            }
            else
            {
                for (std::size_t i = 0; i < size_and_type.first; ++i)
                {
                    if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
                    {
                        return false;
                    }
                }
            }
        }
        else
        {
            if (JSON_HEDLEY_UNLIKELY(!sax->start_array(std::size_t(-1))))
            {
                return false;
            }

            while (current != ']')
            {
                if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal(false)))
                {
                    return false;
                }
                get_ignore_noop();
            }
        }

        return sax->end_array();
    }

    /*!
    @return whether object creation completed
    */
    bool get_ubjson_object()
    {
        std::pair<std::size_t, char_int_type> size_and_type;
        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type)))
        {
            return false;
        }

        string_t key;
        if (size_and_type.first != string_t::npos)
        {
            if (JSON_HEDLEY_UNLIKELY(!sax->start_object(size_and_type.first)))
            {
                return false;
            }

            if (size_and_type.second != 0)
            {
                for (std::size_t i = 0; i < size_and_type.first; ++i)
                {
                    if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key) || !sax->key(key)))
                    {
                        return false;
                    }
                    if (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))
                    {
                        return false;
                    }
                    key.clear();
                }
            }
            else
            {
                for (std::size_t i = 0; i < size_and_type.first; ++i)
                {
                    if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key) || !sax->key(key)))
                    {
                        return false;
                    }
                    if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
                    {
                        return false;
                    }
                    key.clear();
                }
            }
        }
        else
        {
            if (JSON_HEDLEY_UNLIKELY(!sax->start_object(std::size_t(-1))))
            {
                return false;
            }

            while (current != '}')
            {
                if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key, false) || !sax->key(key)))
                {
                    return false;
                }
                if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
                {
                    return false;
                }
                get_ignore_noop();
                key.clear();
            }
        }

        return sax->end_object();
    }

    // Note, no reader for UBJSON binary types is implemented because they do
    // not exist

    bool get_ubjson_high_precision_number()
    {
        // get size of following number string
        std::size_t size{};
        auto res = get_ubjson_size_value(size);
        if (JSON_HEDLEY_UNLIKELY(!res))
        {
            return res;
        }

        // get number string
        std::vector<char> number_vector;
        for (std::size_t i = 0; i < size; ++i)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, "number")))
            {
                return false;
            }
            number_vector.push_back(static_cast<char>(current));
        }

        // parse number string
        auto number_ia = detail::input_adapter(std::forward<decltype(number_vector)>(number_vector));
        auto number_lexer = detail::lexer<BasicJsonType, decltype(number_ia)>(std::move(number_ia), false);
        const auto result_number = number_lexer.scan();
        const auto number_string = number_lexer.get_token_string();
        const auto result_remainder = number_lexer.scan();

        using token_type = typename detail::lexer_base<BasicJsonType>::token_type;

        if (JSON_HEDLEY_UNLIKELY(result_remainder != token_type::end_of_input))
        {
            return sax->parse_error(chars_read, number_string, parse_error::create(115, chars_read, exception_message(input_format_t::ubjson, "invalid number text: " + number_lexer.get_token_string(), "high-precision number")));
        }

        switch (result_number)
        {
            case token_type::value_integer:
                return sax->number_integer(number_lexer.get_number_integer());
            case token_type::value_unsigned:
                return sax->number_unsigned(number_lexer.get_number_unsigned());
            case token_type::value_float:
                return sax->number_float(number_lexer.get_number_float(), std::move(number_string));
            default:
                return sax->parse_error(chars_read, number_string, parse_error::create(115, chars_read, exception_message(input_format_t::ubjson, "invalid number text: " + number_lexer.get_token_string(), "high-precision number")));
        }
    }

    ///////////////////////
    // Utility functions //
    ///////////////////////

    /*!
    @brief get next character from the input

    This function provides the interface to the used input adapter. It does
    not throw in case the input reached EOF, but returns a -'ve valued
    `std::char_traits<char_type>::eof()` in that case.

    @return character read from the input
    */
    char_int_type get()
    {
        ++chars_read;
        return current = ia.get_character();
    }

    /*!
    @return character read from the input after ignoring all 'N' entries
    */
    char_int_type get_ignore_noop()
    {
        do
        {
            get();
        }
        while (current == 'N');

        return current;
    }

    /*
    @brief read a number from the input

    @tparam NumberType the type of the number
    @param[in] format   the current format (for diagnostics)
    @param[out] result  number of type @a NumberType

    @return whether conversion completed

    @note This function needs to respect the system's endianess, because
          bytes in CBOR, MessagePack, and UBJSON are stored in network order
          (big endian) and therefore need reordering on little endian systems.
    */
    template<typename NumberType, bool InputIsLittleEndian = false>
    bool get_number(const input_format_t format, NumberType& result)
    {
        // step 1: read input into array with system's byte order
        std::array<std::uint8_t, sizeof(NumberType)> vec;
        for (std::size_t i = 0; i < sizeof(NumberType); ++i)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, "number")))
            {
                return false;
            }

            // reverse byte order prior to conversion if necessary
            if (is_little_endian != InputIsLittleEndian)
            {
                vec[sizeof(NumberType) - i - 1] = static_cast<std::uint8_t>(current);
            }
            else
            {
                vec[i] = static_cast<std::uint8_t>(current); // LCOV_EXCL_LINE
            }
        }

        // step 2: convert array into number of type T and return
        std::memcpy(&result, vec.data(), sizeof(NumberType));
        return true;
    }

    /*!
    @brief create a string by reading characters from the input

    @tparam NumberType the type of the number
    @param[in] format the current format (for diagnostics)
    @param[in] len number of characters to read
    @param[out] result string created by reading @a len bytes

    @return whether string creation completed

    @note We can not reserve @a len bytes for the result, because @a len
          may be too large. Usually, @ref unexpect_eof() detects the end of
          the input before we run out of string memory.
    */
    template<typename NumberType>
    bool get_string(const input_format_t format,
                    const NumberType len,
                    string_t& result)
    {
        bool success = true;
        for (NumberType i = 0; i < len; i++)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, "string")))
            {
                success = false;
                break;
            }
            result.push_back(static_cast<typename string_t::value_type>(current));
        };
        return success;
    }

    /*!
    @brief create a byte array by reading bytes from the input

    @tparam NumberType the type of the number
    @param[in] format the current format (for diagnostics)
    @param[in] len number of bytes to read
    @param[out] result byte array created by reading @a len bytes

    @return whether byte array creation completed

    @note We can not reserve @a len bytes for the result, because @a len
          may be too large. Usually, @ref unexpect_eof() detects the end of
          the input before we run out of memory.
    */
    template<typename NumberType>
    bool get_binary(const input_format_t format,
                    const NumberType len,
                    binary_t& result)
    {
        bool success = true;
        for (NumberType i = 0; i < len; i++)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, "binary")))
            {
                success = false;
                break;
            }
            result.push_back(static_cast<std::uint8_t>(current));
        }
        return success;
    }

    /*!
    @param[in] format   the current format (for diagnostics)
    @param[in] context  further context information (for diagnostics)
    @return whether the last read character is not EOF
    */
    JSON_HEDLEY_NON_NULL(3)
    bool unexpect_eof(const input_format_t format, const char* context) const
    {
        if (JSON_HEDLEY_UNLIKELY(current == std::char_traits<char_type>::eof()))
        {
            return sax->parse_error(chars_read, "<end of file>",
                                    parse_error::create(110, chars_read, exception_message(format, "unexpected end of input", context)));
        }
        return true;
    }

    /*!
    @return a string representation of the last read byte
    */
    std::string get_token_string() const
    {
        std::array<char, 3> cr{{}};
        (std::snprintf)(cr.data(), cr.size(), "%.2hhX", static_cast<unsigned char>(current));
        return std::string{cr.data()};
    }

    /*!
    @param[in] format   the current format
    @param[in] detail   a detailed error message
    @param[in] context  further context information
    @return a message string to use in the parse_error exceptions
    */
    std::string exception_message(const input_format_t format,
                                  const std::string& detail,
                                  const std::string& context) const
    {
        std::string error_msg = "syntax error while parsing ";

        switch (format)
        {
            case input_format_t::cbor:
                error_msg += "CBOR";
                break;

            case input_format_t::msgpack:
                error_msg += "MessagePack";
                break;

            case input_format_t::ubjson:
                error_msg += "UBJSON";
                break;

            case input_format_t::bson:
                error_msg += "BSON";
                break;

            default:            // LCOV_EXCL_LINE
                JSON_ASSERT(false);  // LCOV_EXCL_LINE
        }

        return error_msg + " " + context + ": " + detail;
    }

  private:
    /// input adapter
    InputAdapterType ia;

    /// the current character
    char_int_type current = std::char_traits<char_type>::eof();

    /// the number of characters read
    std::size_t chars_read = 0;

    /// whether we can assume little endianess
    const bool is_little_endian = little_endianess();

    /// the SAX parser
    json_sax_t* sax = nullptr;
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/input/input_adapters.hpp>

// #include <nlohmann/detail/input/lexer.hpp>

// #include <nlohmann/detail/input/parser.hpp>


#include <cmath> // isfinite
#include <cstdint> // uint8_t
#include <functional> // function
#include <string> // string
#include <utility> // move
#include <vector> // vector

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/input/input_adapters.hpp>

// #include <nlohmann/detail/input/json_sax.hpp>

// #include <nlohmann/detail/input/lexer.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/is_sax.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
namespace detail
{
////////////
// parser //
////////////

enum class parse_event_t : uint8_t
{
    /// the parser read `{` and started to process a JSON object
    object_start,
    /// the parser read `}` and finished processing a JSON object
    object_end,
    /// the parser read `[` and started to process a JSON array
    array_start,
    /// the parser read `]` and finished processing a JSON array
    array_end,
    /// the parser read a key of a value in an object
    key,
    /// the parser finished reading a JSON value
    value
};

template<typename BasicJsonType>
using parser_callback_t =
    std::function<bool(int depth, parse_event_t event, BasicJsonType& parsed)>;

/*!
@brief syntax analysis

This class implements a recursive descent parser.
*/
template<typename BasicJsonType, typename InputAdapterType>
class parser
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using lexer_t = lexer<BasicJsonType, InputAdapterType>;
    using token_type = typename lexer_t::token_type;

  public:
    /// a parser reading from an input adapter
    explicit parser(InputAdapterType&& adapter,
                    const parser_callback_t<BasicJsonType> cb = nullptr,
                    const bool allow_exceptions_ = true,
                    const bool skip_comments = false)
        : callback(cb)
        , m_lexer(std::move(adapter), skip_comments)
        , allow_exceptions(allow_exceptions_)
    {
        // read first token
        get_token();
    }

    /*!
    @brief public parser interface

    @param[in] strict      whether to expect the last token to be EOF
    @param[in,out] result  parsed JSON value

    @throw parse_error.101 in case of an unexpected token
    @throw parse_error.102 if to_unicode fails or surrogate error
    @throw parse_error.103 if to_unicode fails
    */
    void parse(const bool strict, BasicJsonType& result)
    {
        if (callback)
        {
            json_sax_dom_callback_parser<BasicJsonType> sdp(result, callback, allow_exceptions);
            sax_parse_internal(&sdp);
            result.assert_invariant();

            // in strict mode, input must be completely read
            if (strict && (get_token() != token_type::end_of_input))
            {
                sdp.parse_error(m_lexer.get_position(),
                                m_lexer.get_token_string(),
                                parse_error::create(101, m_lexer.get_position(),
                                                    exception_message(token_type::end_of_input, "value")));
            }

            // in case of an error, return discarded value
            if (sdp.is_errored())
            {
                result = value_t::discarded;
                return;
            }

            // set top-level value to null if it was discarded by the callback
            // function
            if (result.is_discarded())
            {
                result = nullptr;
            }
        }
        else
        {
            json_sax_dom_parser<BasicJsonType> sdp(result, allow_exceptions);
            sax_parse_internal(&sdp);
            result.assert_invariant();

            // in strict mode, input must be completely read
            if (strict && (get_token() != token_type::end_of_input))
            {
                sdp.parse_error(m_lexer.get_position(),
                                m_lexer.get_token_string(),
                                parse_error::create(101, m_lexer.get_position(),
                                                    exception_message(token_type::end_of_input, "value")));
            }

            // in case of an error, return discarded value
            if (sdp.is_errored())
            {
                result = value_t::discarded;
                return;
            }
        }
    }

    /*!
    @brief public accept interface

    @param[in] strict  whether to expect the last token to be EOF
    @return whether the input is a proper JSON text
    */
    bool accept(const bool strict = true)
    {
        json_sax_acceptor<BasicJsonType> sax_acceptor;
        return sax_parse(&sax_acceptor, strict);
    }

    template<typename SAX>
    JSON_HEDLEY_NON_NULL(2)
    bool sax_parse(SAX* sax, const bool strict = true)
    {
        (void)detail::is_sax_static_asserts<SAX, BasicJsonType> {};
        const bool result = sax_parse_internal(sax);

        // strict mode: next byte must be EOF
        if (result && strict && (get_token() != token_type::end_of_input))
        {
            return sax->parse_error(m_lexer.get_position(),
                                    m_lexer.get_token_string(),
                                    parse_error::create(101, m_lexer.get_position(),
                                            exception_message(token_type::end_of_input, "value")));
        }

        return result;
    }

  private:
    template<typename SAX>
    JSON_HEDLEY_NON_NULL(2)
    bool sax_parse_internal(SAX* sax)
    {
        // stack to remember the hierarchy of structured values we are parsing
        // true = array; false = object
        std::vector<bool> states;
        // value to avoid a goto (see comment where set to true)
        bool skip_to_state_evaluation = false;

        while (true)
        {
            if (!skip_to_state_evaluation)
            {
                // invariant: get_token() was called before each iteration
                switch (last_token)
                {
                    case token_type::begin_object:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->start_object(std::size_t(-1))))
                        {
                            return false;
                        }

                        // closing } -> we are done
                        if (get_token() == token_type::end_object)
                        {
                            if (JSON_HEDLEY_UNLIKELY(!sax->end_object()))
                            {
                                return false;
                            }
                            break;
                        }

                        // parse key
                        if (JSON_HEDLEY_UNLIKELY(last_token != token_type::value_string))
                        {
                            return sax->parse_error(m_lexer.get_position(),
                                                    m_lexer.get_token_string(),
                                                    parse_error::create(101, m_lexer.get_position(),
                                                            exception_message(token_type::value_string, "object key")));
                        }
                        if (JSON_HEDLEY_UNLIKELY(!sax->key(m_lexer.get_string())))
                        {
                            return false;
                        }

                        // parse separator (:)
                        if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::name_separator))
                        {
                            return sax->parse_error(m_lexer.get_position(),
                                                    m_lexer.get_token_string(),
                                                    parse_error::create(101, m_lexer.get_position(),
                                                            exception_message(token_type::name_separator, "object separator")));
                        }

                        // remember we are now inside an object
                        states.push_back(false);

                        // parse values
                        get_token();
                        continue;
                    }

                    case token_type::begin_array:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(std::size_t(-1))))
                        {
                            return false;
                        }

                        // closing ] -> we are done
                        if (get_token() == token_type::end_array)
                        {
                            if (JSON_HEDLEY_UNLIKELY(!sax->end_array()))
                            {
                                return false;
                            }
                            break;
                        }

                        // remember we are now inside an array
                        states.push_back(true);

                        // parse values (no need to call get_token)
                        continue;
                    }

                    case token_type::value_float:
                    {
                        const auto res = m_lexer.get_number_float();

                        if (JSON_HEDLEY_UNLIKELY(!std::isfinite(res)))
                        {
                            return sax->parse_error(m_lexer.get_position(),
                                                    m_lexer.get_token_string(),
                                                    out_of_range::create(406, "number overflow parsing '" + m_lexer.get_token_string() + "'"));
                        }

                        if (JSON_HEDLEY_UNLIKELY(!sax->number_float(res, m_lexer.get_string())))
                        {
                            return false;
                        }

                        break;
                    }

                    case token_type::literal_false:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->boolean(false)))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::literal_null:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->null()))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::literal_true:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->boolean(true)))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::value_integer:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->number_integer(m_lexer.get_number_integer())))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::value_string:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->string(m_lexer.get_string())))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::value_unsigned:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->number_unsigned(m_lexer.get_number_unsigned())))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::parse_error:
                    {
                        // using "uninitialized" to avoid "expected" message
                        return sax->parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(),
                                                        exception_message(token_type::uninitialized, "value")));
                    }

                    default: // the last token was unexpected
                    {
                        return sax->parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(),
                                                        exception_message(token_type::literal_or_value, "value")));
                    }
                }
            }
            else
            {
                skip_to_state_evaluation = false;
            }

            // we reached this line after we successfully parsed a value
            if (states.empty())
            {
                // empty stack: we reached the end of the hierarchy: done
                return true;
            }

            if (states.back())  // array
            {
                // comma -> next value
                if (get_token() == token_type::value_separator)
                {
                    // parse a new value
                    get_token();
                    continue;
                }

                // closing ]
                if (JSON_HEDLEY_LIKELY(last_token == token_type::end_array))
                {
                    if (JSON_HEDLEY_UNLIKELY(!sax->end_array()))
                    {
                        return false;
                    }

                    // We are done with this array. Before we can parse a
                    // new value, we need to evaluate the new state first.
                    // By setting skip_to_state_evaluation to false, we
                    // are effectively jumping to the beginning of this if.
                    JSON_ASSERT(!states.empty());
                    states.pop_back();
                    skip_to_state_evaluation = true;
                    continue;
                }

                return sax->parse_error(m_lexer.get_position(),
                                        m_lexer.get_token_string(),
                                        parse_error::create(101, m_lexer.get_position(),
                                                exception_message(token_type::end_array, "array")));
            }
            else  // object
            {
                // comma -> next value
                if (get_token() == token_type::value_separator)
                {
                    // parse key
                    if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::value_string))
                    {
                        return sax->parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(),
                                                        exception_message(token_type::value_string, "object key")));
                    }

                    if (JSON_HEDLEY_UNLIKELY(!sax->key(m_lexer.get_string())))
                    {
                        return false;
                    }

                    // parse separator (:)
                    if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::name_separator))
                    {
                        return sax->parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(),
                                                        exception_message(token_type::name_separator, "object separator")));
                    }

                    // parse values
                    get_token();
                    continue;
                }

                // closing }
                if (JSON_HEDLEY_LIKELY(last_token == token_type::end_object))
                {
                    if (JSON_HEDLEY_UNLIKELY(!sax->end_object()))
                    {
                        return false;
                    }

                    // We are done with this object. Before we can parse a
                    // new value, we need to evaluate the new state first.
                    // By setting skip_to_state_evaluation to false, we
                    // are effectively jumping to the beginning of this if.
                    JSON_ASSERT(!states.empty());
                    states.pop_back();
                    skip_to_state_evaluation = true;
                    continue;
                }

                return sax->parse_error(m_lexer.get_position(),
                                        m_lexer.get_token_string(),
                                        parse_error::create(101, m_lexer.get_position(),
                                                exception_message(token_type::end_object, "object")));
            }
        }
    }

    /// get next token from lexer
    token_type get_token()
    {
        return last_token = m_lexer.scan();
    }

    std::string exception_message(const token_type expected, const std::string& context)
    {
        std::string error_msg = "syntax error ";

        if (!context.empty())
        {
            error_msg += "while parsing " + context + " ";
        }

        error_msg += "- ";

        if (last_token == token_type::parse_error)
        {
            error_msg += std::string(m_lexer.get_error_message()) + "; last read: '" +
                         m_lexer.get_token_string() + "'";
        }
        else
        {
            error_msg += "unexpected " + std::string(lexer_t::token_type_name(last_token));
        }

        if (expected != token_type::uninitialized)
        {
            error_msg += "; expected " + std::string(lexer_t::token_type_name(expected));
        }

        return error_msg;
    }

  private:
    /// callback function
    const parser_callback_t<BasicJsonType> callback = nullptr;
    /// the type of the last read token
    token_type last_token = token_type::uninitialized;
    /// the lexer
    lexer_t m_lexer;
    /// whether to throw exceptions in case of errors
    const bool allow_exceptions = true;
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/iterators/internal_iterator.hpp>


// #include <nlohmann/detail/iterators/primitive_iterator.hpp>


#include <cstddef> // ptrdiff_t
#include <limits>  // numeric_limits

namespace nlohmann
{
namespace detail
{
/*
@brief an iterator for primitive JSON types

This class models an iterator for primitive JSON types (boolean, number,
string). It's only purpose is to allow the iterator/const_iterator classes
to "iterate" over primitive values. Internally, the iterator is modeled by
a `difference_type` variable. Value begin_value (`0`) models the begin,
end_value (`1`) models past the end.
*/
class primitive_iterator_t
{
  private:
    using difference_type = std::ptrdiff_t;
    static constexpr difference_type begin_value = 0;
    static constexpr difference_type end_value = begin_value + 1;

    /// iterator as signed integer type
    difference_type m_it = (std::numeric_limits<std::ptrdiff_t>::min)();

  public:
    constexpr difference_type get_value() const noexcept
    {
        return m_it;
    }

    /// set iterator to a defined beginning
    void set_begin() noexcept
    {
        m_it = begin_value;
    }

    /// set iterator to a defined past the end
    void set_end() noexcept
    {
        m_it = end_value;
    }

    /// return whether the iterator can be dereferenced
    constexpr bool is_begin() const noexcept
    {
        return m_it == begin_value;
    }

    /// return whether the iterator is at end
    constexpr bool is_end() const noexcept
    {
        return m_it == end_value;
    }

    friend constexpr bool operator==(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
    {
        return lhs.m_it == rhs.m_it;
    }

    friend constexpr bool operator<(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
    {
        return lhs.m_it < rhs.m_it;
    }

    primitive_iterator_t operator+(difference_type n) noexcept
    {
        auto result = *this;
        result += n;
        return result;
    }

    friend constexpr difference_type operator-(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
    {
        return lhs.m_it - rhs.m_it;
    }

    primitive_iterator_t& operator++() noexcept
    {
        ++m_it;
        return *this;
    }

    primitive_iterator_t const operator++(int) noexcept
    {
        auto result = *this;
        ++m_it;
        return result;
    }

    primitive_iterator_t& operator--() noexcept
    {
        --m_it;
        return *this;
    }

    primitive_iterator_t const operator--(int) noexcept
    {
        auto result = *this;
        --m_it;
        return result;
    }

    primitive_iterator_t& operator+=(difference_type n) noexcept
    {
        m_it += n;
        return *this;
    }

    primitive_iterator_t& operator-=(difference_type n) noexcept
    {
        m_it -= n;
        return *this;
    }
};
}  // namespace detail
}  // namespace nlohmann


namespace nlohmann
{
namespace detail
{
/*!
@brief an iterator value

@note This structure could easily be a union, but MSVC currently does not allow
unions members with complex constructors, see https://github.com/nlohmann/json/pull/105.
*/
template<typename BasicJsonType> struct internal_iterator
{
    /// iterator for JSON objects
    typename BasicJsonType::object_t::iterator object_iterator {};
    /// iterator for JSON arrays
    typename BasicJsonType::array_t::iterator array_iterator {};
    /// generic iterator for all other types
    primitive_iterator_t primitive_iterator {};
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/iterators/iter_impl.hpp>


#include <iterator> // iterator, random_access_iterator_tag, bidirectional_iterator_tag, advance, next
#include <type_traits> // conditional, is_const, remove_const

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/iterators/internal_iterator.hpp>

// #include <nlohmann/detail/iterators/primitive_iterator.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
namespace detail
{
// forward declare, to be able to friend it later on
template<typename IteratorType> class iteration_proxy;
template<typename IteratorType> class iteration_proxy_value;

/*!
@brief a template for a bidirectional iterator for the @ref basic_json class
This class implements a both iterators (iterator and const_iterator) for the
@ref basic_json class.
@note An iterator is called *initialized* when a pointer to a JSON value has
      been set (e.g., by a constructor or a copy assignment). If the iterator is
      default-constructed, it is *uninitialized* and most methods are undefined.
      **The library uses assertions to detect calls on uninitialized iterators.**
@requirement The class satisfies the following concept requirements:
-
[BidirectionalIterator](https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator):
  The iterator that can be moved can be moved in both directions (i.e.
  incremented and decremented).
@since version 1.0.0, simplified in version 2.0.9, change to bidirectional
       iterators in version 3.0.0 (see https://github.com/nlohmann/json/issues/593)
*/
template<typename BasicJsonType>
class iter_impl
{
    /// allow basic_json to access private members
    friend iter_impl<typename std::conditional<std::is_const<BasicJsonType>::value, typename std::remove_const<BasicJsonType>::type, const BasicJsonType>::type>;
    friend BasicJsonType;
    friend iteration_proxy<iter_impl>;
    friend iteration_proxy_value<iter_impl>;

    using object_t = typename BasicJsonType::object_t;
    using array_t = typename BasicJsonType::array_t;
    // make sure BasicJsonType is basic_json or const basic_json
    static_assert(is_basic_json<typename std::remove_const<BasicJsonType>::type>::value,
                  "iter_impl only accepts (const) basic_json");

  public:

    /// The std::iterator class template (used as a base class to provide typedefs) is deprecated in C++17.
    /// The C++ Standard has never required user-defined iterators to derive from std::iterator.
    /// A user-defined iterator should provide publicly accessible typedefs named
    /// iterator_category, value_type, difference_type, pointer, and reference.
    /// Note that value_type is required to be non-const, even for constant iterators.
    using iterator_category = std::bidirectional_iterator_tag;

    /// the type of the values when the iterator is dereferenced
    using value_type = typename BasicJsonType::value_type;
    /// a type to represent differences between iterators
    using difference_type = typename BasicJsonType::difference_type;
    /// defines a pointer to the type iterated over (value_type)
    using pointer = typename std::conditional<std::is_const<BasicJsonType>::value,
          typename BasicJsonType::const_pointer,
          typename BasicJsonType::pointer>::type;
    /// defines a reference to the type iterated over (value_type)
    using reference =
        typename std::conditional<std::is_const<BasicJsonType>::value,
        typename BasicJsonType::const_reference,
        typename BasicJsonType::reference>::type;

    /// default constructor
    iter_impl() = default;

    /*!
    @brief constructor for a given JSON instance
    @param[in] object  pointer to a JSON object for this iterator
    @pre object != nullptr
    @post The iterator is initialized; i.e. `m_object != nullptr`.
    */
    explicit iter_impl(pointer object) noexcept : m_object(object)
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                m_it.object_iterator = typename object_t::iterator();
                break;
            }

            case value_t::array:
            {
                m_it.array_iterator = typename array_t::iterator();
                break;
            }

            default:
            {
                m_it.primitive_iterator = primitive_iterator_t();
                break;
            }
        }
    }

    /*!
    @note The conventional copy constructor and copy assignment are implicitly
          defined. Combined with the following converting constructor and
          assignment, they support: (1) copy from iterator to iterator, (2)
          copy from const iterator to const iterator, and (3) conversion from
          iterator to const iterator. However conversion from const iterator
          to iterator is not defined.
    */

    /*!
    @brief const copy constructor
    @param[in] other const iterator to copy from
    @note This copy constructor had to be defined explicitly to circumvent a bug
          occurring on msvc v19.0 compiler (VS 2015) debug build. For more
          information refer to: https://github.com/nlohmann/json/issues/1608
    */
    iter_impl(const iter_impl<const BasicJsonType>& other) noexcept
        : m_object(other.m_object), m_it(other.m_it)
    {}

    /*!
    @brief converting assignment
    @param[in] other const iterator to copy from
    @return const/non-const iterator
    @note It is not checked whether @a other is initialized.
    */
    iter_impl& operator=(const iter_impl<const BasicJsonType>& other) noexcept
    {
        m_object = other.m_object;
        m_it = other.m_it;
        return *this;
    }

    /*!
    @brief converting constructor
    @param[in] other  non-const iterator to copy from
    @note It is not checked whether @a other is initialized.
    */
    iter_impl(const iter_impl<typename std::remove_const<BasicJsonType>::type>& other) noexcept
        : m_object(other.m_object), m_it(other.m_it)
    {}

    /*!
    @brief converting assignment
    @param[in] other  non-const iterator to copy from
    @return const/non-const iterator
    @note It is not checked whether @a other is initialized.
    */
    iter_impl& operator=(const iter_impl<typename std::remove_const<BasicJsonType>::type>& other) noexcept
    {
        m_object = other.m_object;
        m_it = other.m_it;
        return *this;
    }

  private:
    /*!
    @brief set the iterator to the first value
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    void set_begin() noexcept
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                m_it.object_iterator = m_object->m_value.object->begin();
                break;
            }

            case value_t::array:
            {
                m_it.array_iterator = m_object->m_value.array->begin();
                break;
            }

            case value_t::null:
            {
                // set to end so begin()==end() is true: null is empty
                m_it.primitive_iterator.set_end();
                break;
            }

            default:
            {
                m_it.primitive_iterator.set_begin();
                break;
            }
        }
    }

    /*!
    @brief set the iterator past the last value
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    void set_end() noexcept
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                m_it.object_iterator = m_object->m_value.object->end();
                break;
            }

            case value_t::array:
            {
                m_it.array_iterator = m_object->m_value.array->end();
                break;
            }

            default:
            {
                m_it.primitive_iterator.set_end();
                break;
            }
        }
    }

  public:
    /*!
    @brief return a reference to the value pointed to by the iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    reference operator*() const
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                JSON_ASSERT(m_it.object_iterator != m_object->m_value.object->end());
                return m_it.object_iterator->second;
            }

            case value_t::array:
            {
                JSON_ASSERT(m_it.array_iterator != m_object->m_value.array->end());
                return *m_it.array_iterator;
            }

            case value_t::null:
                JSON_THROW(invalid_iterator::create(214, "cannot get value"));

            default:
            {
                if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.is_begin()))
                {
                    return *m_object;
                }

                JSON_THROW(invalid_iterator::create(214, "cannot get value"));
            }
        }
    }

    /*!
    @brief dereference the iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    pointer operator->() const
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                JSON_ASSERT(m_it.object_iterator != m_object->m_value.object->end());
                return &(m_it.object_iterator->second);
            }

            case value_t::array:
            {
                JSON_ASSERT(m_it.array_iterator != m_object->m_value.array->end());
                return &*m_it.array_iterator;
            }

            default:
            {
                if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.is_begin()))
                {
                    return m_object;
                }

                JSON_THROW(invalid_iterator::create(214, "cannot get value"));
            }
        }
    }

    /*!
    @brief post-increment (it++)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl const operator++(int)
    {
        auto result = *this;
        ++(*this);
        return result;
    }

    /*!
    @brief pre-increment (++it)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator++()
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                std::advance(m_it.object_iterator, 1);
                break;
            }

            case value_t::array:
            {
                std::advance(m_it.array_iterator, 1);
                break;
            }

            default:
            {
                ++m_it.primitive_iterator;
                break;
            }
        }

        return *this;
    }

    /*!
    @brief post-decrement (it--)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl const operator--(int)
    {
        auto result = *this;
        --(*this);
        return result;
    }

    /*!
    @brief pre-decrement (--it)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator--()
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                std::advance(m_it.object_iterator, -1);
                break;
            }

            case value_t::array:
            {
                std::advance(m_it.array_iterator, -1);
                break;
            }

            default:
            {
                --m_it.primitive_iterator;
                break;
            }
        }

        return *this;
    }

    /*!
    @brief  comparison: equal
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator==(const iter_impl& other) const
    {
        // if objects are not the same, the comparison is undefined
        if (JSON_HEDLEY_UNLIKELY(m_object != other.m_object))
        {
            JSON_THROW(invalid_iterator::create(212, "cannot compare iterators of different containers"));
        }

        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
                return (m_it.object_iterator == other.m_it.object_iterator);

            case value_t::array:
                return (m_it.array_iterator == other.m_it.array_iterator);

            default:
                return (m_it.primitive_iterator == other.m_it.primitive_iterator);
        }
    }

    /*!
    @brief  comparison: not equal
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator!=(const iter_impl& other) const
    {
        return !operator==(other);
    }

    /*!
    @brief  comparison: smaller
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator<(const iter_impl& other) const
    {
        // if objects are not the same, the comparison is undefined
        if (JSON_HEDLEY_UNLIKELY(m_object != other.m_object))
        {
            JSON_THROW(invalid_iterator::create(212, "cannot compare iterators of different containers"));
        }

        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(213, "cannot compare order of object iterators"));

            case value_t::array:
                return (m_it.array_iterator < other.m_it.array_iterator);

            default:
                return (m_it.primitive_iterator < other.m_it.primitive_iterator);
        }
    }

    /*!
    @brief  comparison: less than or equal
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator<=(const iter_impl& other) const
    {
        return !other.operator < (*this);
    }

    /*!
    @brief  comparison: greater than
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator>(const iter_impl& other) const
    {
        return !operator<=(other);
    }

    /*!
    @brief  comparison: greater than or equal
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator>=(const iter_impl& other) const
    {
        return !operator<(other);
    }

    /*!
    @brief  add to iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator+=(difference_type i)
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(209, "cannot use offsets with object iterators"));

            case value_t::array:
            {
                std::advance(m_it.array_iterator, i);
                break;
            }

            default:
            {
                m_it.primitive_iterator += i;
                break;
            }
        }

        return *this;
    }

    /*!
    @brief  subtract from iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator-=(difference_type i)
    {
        return operator+=(-i);
    }

    /*!
    @brief  add to iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl operator+(difference_type i) const
    {
        auto result = *this;
        result += i;
        return result;
    }

    /*!
    @brief  addition of distance and iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    friend iter_impl operator+(difference_type i, const iter_impl& it)
    {
        auto result = it;
        result += i;
        return result;
    }

    /*!
    @brief  subtract from iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl operator-(difference_type i) const
    {
        auto result = *this;
        result -= i;
        return result;
    }

    /*!
    @brief  return difference
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    difference_type operator-(const iter_impl& other) const
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(209, "cannot use offsets with object iterators"));

            case value_t::array:
                return m_it.array_iterator - other.m_it.array_iterator;

            default:
                return m_it.primitive_iterator - other.m_it.primitive_iterator;
        }
    }

    /*!
    @brief  access to successor
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    reference operator[](difference_type n) const
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(208, "cannot use operator[] for object iterators"));

            case value_t::array:
                return *std::next(m_it.array_iterator, n);

            case value_t::null:
                JSON_THROW(invalid_iterator::create(214, "cannot get value"));

            default:
            {
                if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.get_value() == -n))
                {
                    return *m_object;
                }

                JSON_THROW(invalid_iterator::create(214, "cannot get value"));
            }
        }
    }

    /*!
    @brief  return the key of an object iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    const typename object_t::key_type& key() const
    {
        JSON_ASSERT(m_object != nullptr);

        if (JSON_HEDLEY_LIKELY(m_object->is_object()))
        {
            return m_it.object_iterator->first;
        }

        JSON_THROW(invalid_iterator::create(207, "cannot use key() for non-object iterators"));
    }

    /*!
    @brief  return the value of an iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    reference value() const
    {
        return operator*();
    }

  private:
    /// associated JSON instance
    pointer m_object = nullptr;
    /// the actual iterator of the associated instance
    internal_iterator<typename std::remove_const<BasicJsonType>::type> m_it {};
};
} // namespace detail
} // namespace nlohmann

// #include <nlohmann/detail/iterators/iteration_proxy.hpp>

// #include <nlohmann/detail/iterators/json_reverse_iterator.hpp>


#include <cstddef> // ptrdiff_t
#include <iterator> // reverse_iterator
#include <utility> // declval

namespace nlohmann
{
namespace detail
{
//////////////////////
// reverse_iterator //
//////////////////////

/*!
@brief a template for a reverse iterator class

@tparam Base the base iterator type to reverse. Valid types are @ref
iterator (to create @ref reverse_iterator) and @ref const_iterator (to
create @ref const_reverse_iterator).

@requirement The class satisfies the following concept requirements:
-
[BidirectionalIterator](https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator):
  The iterator that can be moved can be moved in both directions (i.e.
  incremented and decremented).
- [OutputIterator](https://en.cppreference.com/w/cpp/named_req/OutputIterator):
  It is possible to write to the pointed-to element (only if @a Base is
  @ref iterator).

@since version 1.0.0
*/
template<typename Base>
class json_reverse_iterator : public std::reverse_iterator<Base>
{
  public:
    using difference_type = std::ptrdiff_t;
    /// shortcut to the reverse iterator adapter
    using base_iterator = std::reverse_iterator<Base>;
    /// the reference type for the pointed-to element
    using reference = typename Base::reference;

    /// create reverse iterator from iterator
    explicit json_reverse_iterator(const typename base_iterator::iterator_type& it) noexcept
        : base_iterator(it) {}

    /// create reverse iterator from base class
    explicit json_reverse_iterator(const base_iterator& it) noexcept : base_iterator(it) {}

    /// post-increment (it++)
    json_reverse_iterator const operator++(int)
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator++(1));
    }

    /// pre-increment (++it)
    json_reverse_iterator& operator++()
    {
        return static_cast<json_reverse_iterator&>(base_iterator::operator++());
    }

    /// post-decrement (it--)
    json_reverse_iterator const operator--(int)
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator--(1));
    }

    /// pre-decrement (--it)
    json_reverse_iterator& operator--()
    {
        return static_cast<json_reverse_iterator&>(base_iterator::operator--());
    }

    /// add to iterator
    json_reverse_iterator& operator+=(difference_type i)
    {
        return static_cast<json_reverse_iterator&>(base_iterator::operator+=(i));
    }

    /// add to iterator
    json_reverse_iterator operator+(difference_type i) const
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator+(i));
    }

    /// subtract from iterator
    json_reverse_iterator operator-(difference_type i) const
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator-(i));
    }

    /// return difference
    difference_type operator-(const json_reverse_iterator& other) const
    {
        return base_iterator(*this) - base_iterator(other);
    }

    /// access to successor
    reference operator[](difference_type n) const
    {
        return *(this->operator+(n));
    }

    /// return the key of an object iterator
    auto key() const -> decltype(std::declval<Base>().key())
    {
        auto it = --this->base();
        return it.key();
    }

    /// return the value of an iterator
    reference value() const
    {
        auto it = --this->base();
        return it.operator * ();
    }
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/iterators/primitive_iterator.hpp>

// #include <nlohmann/detail/json_pointer.hpp>


#include <algorithm> // all_of
#include <cctype> // isdigit
#include <limits> // max
#include <numeric> // accumulate
#include <string> // string
#include <utility> // move
#include <vector> // vector

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
template<typename BasicJsonType>
class json_pointer
{
    // allow basic_json to access private members
    NLOHMANN_BASIC_JSON_TPL_DECLARATION
    friend class basic_json;

  public:
    /*!
    @brief create JSON pointer

    Create a JSON pointer according to the syntax described in
    [Section 3 of RFC6901](https://tools.ietf.org/html/rfc6901#section-3).

    @param[in] s  string representing the JSON pointer; if omitted, the empty
                  string is assumed which references the whole JSON value

    @throw parse_error.107 if the given JSON pointer @a s is nonempty and does
                           not begin with a slash (`/`); see example below

    @throw parse_error.108 if a tilde (`~`) in the given JSON pointer @a s is
    not followed by `0` (representing `~`) or `1` (representing `/`); see
    example below

    @liveexample{The example shows the construction several valid JSON pointers
    as well as the exceptional behavior.,json_pointer}

    @since version 2.0.0
    */
    explicit json_pointer(const std::string& s = "")
        : reference_tokens(split(s))
    {}

    /*!
    @brief return a string representation of the JSON pointer

    @invariant For each JSON pointer `ptr`, it holds:
    @code {.cpp}
    ptr == json_pointer(ptr.to_string());
    @endcode

    @return a string representation of the JSON pointer

    @liveexample{The example shows the result of `to_string`.,json_pointer__to_string}

    @since version 2.0.0
    */
    std::string to_string() const
    {
        return std::accumulate(reference_tokens.begin(), reference_tokens.end(),
                               std::string{},
                               [](const std::string & a, const std::string & b)
        {
            return a + "/" + escape(b);
        });
    }

    /// @copydoc to_string()
    operator std::string() const
    {
        return to_string();
    }

    /*!
    @brief append another JSON pointer at the end of this JSON pointer

    @param[in] ptr  JSON pointer to append
    @return JSON pointer with @a ptr appended

    @liveexample{The example shows the usage of `operator/=`.,json_pointer__operator_add}

    @complexity Linear in the length of @a ptr.

    @sa @ref operator/=(std::string) to append a reference token
    @sa @ref operator/=(std::size_t) to append an array index
    @sa @ref operator/(const json_pointer&, const json_pointer&) for a binary operator

    @since version 3.6.0
    */
    json_pointer& operator/=(const json_pointer& ptr)
    {
        reference_tokens.insert(reference_tokens.end(),
                                ptr.reference_tokens.begin(),
                                ptr.reference_tokens.end());
        return *this;
    }

    /*!
    @brief append an unescaped reference token at the end of this JSON pointer

    @param[in] token  reference token to append
    @return JSON pointer with @a token appended without escaping @a token

    @liveexample{The example shows the usage of `operator/=`.,json_pointer__operator_add}

    @complexity Amortized constant.

    @sa @ref operator/=(const json_pointer&) to append a JSON pointer
    @sa @ref operator/=(std::size_t) to append an array index
    @sa @ref operator/(const json_pointer&, std::size_t) for a binary operator

    @since version 3.6.0
    */
    json_pointer& operator/=(std::string token)
    {
        push_back(std::move(token));
        return *this;
    }

    /*!
    @brief append an array index at the end of this JSON pointer

    @param[in] array_idx  array index to append
    @return JSON pointer with @a array_idx appended

    @liveexample{The example shows the usage of `operator/=`.,json_pointer__operator_add}

    @complexity Amortized constant.

    @sa @ref operator/=(const json_pointer&) to append a JSON pointer
    @sa @ref operator/=(std::string) to append a reference token
    @sa @ref operator/(const json_pointer&, std::string) for a binary operator

    @since version 3.6.0
    */
    json_pointer& operator/=(std::size_t array_idx)
    {
        return *this /= std::to_string(array_idx);
    }

    /*!
    @brief create a new JSON pointer by appending the right JSON pointer at the end of the left JSON pointer

    @param[in] lhs  JSON pointer
    @param[in] rhs  JSON pointer
    @return a new JSON pointer with @a rhs appended to @a lhs

    @liveexample{The example shows the usage of `operator/`.,json_pointer__operator_add_binary}

    @complexity Linear in the length of @a lhs and @a rhs.

    @sa @ref operator/=(const json_pointer&) to append a JSON pointer

    @since version 3.6.0
    */
    friend json_pointer operator/(const json_pointer& lhs,
                                  const json_pointer& rhs)
    {
        return json_pointer(lhs) /= rhs;
    }

    /*!
    @brief create a new JSON pointer by appending the unescaped token at the end of the JSON pointer

    @param[in] ptr  JSON pointer
    @param[in] token  reference token
    @return a new JSON pointer with unescaped @a token appended to @a ptr

    @liveexample{The example shows the usage of `operator/`.,json_pointer__operator_add_binary}

    @complexity Linear in the length of @a ptr.

    @sa @ref operator/=(std::string) to append a reference token

    @since version 3.6.0
    */
    friend json_pointer operator/(const json_pointer& ptr, std::string token)
    {
        return json_pointer(ptr) /= std::move(token);
    }

    /*!
    @brief create a new JSON pointer by appending the array-index-token at the end of the JSON pointer

    @param[in] ptr  JSON pointer
    @param[in] array_idx  array index
    @return a new JSON pointer with @a array_idx appended to @a ptr

    @liveexample{The example shows the usage of `operator/`.,json_pointer__operator_add_binary}

    @complexity Linear in the length of @a ptr.

    @sa @ref operator/=(std::size_t) to append an array index

    @since version 3.6.0
    */
    friend json_pointer operator/(const json_pointer& ptr, std::size_t array_idx)
    {
        return json_pointer(ptr) /= array_idx;
    }

    /*!
    @brief returns the parent of this JSON pointer

    @return parent of this JSON pointer; in case this JSON pointer is the root,
            the root itself is returned

    @complexity Linear in the length of the JSON pointer.

    @liveexample{The example shows the result of `parent_pointer` for different
    JSON Pointers.,json_pointer__parent_pointer}

    @since version 3.6.0
    */
    json_pointer parent_pointer() const
    {
        if (empty())
        {
            return *this;
        }

        json_pointer res = *this;
        res.pop_back();
        return res;
    }

    /*!
    @brief remove last reference token

    @pre not `empty()`

    @liveexample{The example shows the usage of `pop_back`.,json_pointer__pop_back}

    @complexity Constant.

    @throw out_of_range.405 if JSON pointer has no parent

    @since version 3.6.0
    */
    void pop_back()
    {
        if (JSON_HEDLEY_UNLIKELY(empty()))
        {
            JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent"));
        }

        reference_tokens.pop_back();
    }

    /*!
    @brief return last reference token

    @pre not `empty()`
    @return last reference token

    @liveexample{The example shows the usage of `back`.,json_pointer__back}

    @complexity Constant.

    @throw out_of_range.405 if JSON pointer has no parent

    @since version 3.6.0
    */
    const std::string& back() const
    {
        if (JSON_HEDLEY_UNLIKELY(empty()))
        {
            JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent"));
        }

        return reference_tokens.back();
    }

    /*!
    @brief append an unescaped token at the end of the reference pointer

    @param[in] token  token to add

    @complexity Amortized constant.

    @liveexample{The example shows the result of `push_back` for different
    JSON Pointers.,json_pointer__push_back}

    @since version 3.6.0
    */
    void push_back(const std::string& token)
    {
        reference_tokens.push_back(token);
    }

    /// @copydoc push_back(const std::string&)
    void push_back(std::string&& token)
    {
        reference_tokens.push_back(std::move(token));
    }

    /*!
    @brief return whether pointer points to the root document

    @return true iff the JSON pointer points to the root document

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example shows the result of `empty` for different JSON
    Pointers.,json_pointer__empty}

    @since version 3.6.0
    */
    bool empty() const noexcept
    {
        return reference_tokens.empty();
    }

  private:
    /*!
    @param[in] s  reference token to be converted into an array index

    @return integer representation of @a s

    @throw parse_error.106  if an array index begins with '0'
    @throw parse_error.109  if an array index begins not with a digit
    @throw out_of_range.404 if string @a s could not be converted to an integer
    @throw out_of_range.410 if an array index exceeds size_type
    */
    static typename BasicJsonType::size_type array_index(const std::string& s)
    {
        using size_type = typename BasicJsonType::size_type;

        // error condition (cf. RFC 6901, Sect. 4)
        if (JSON_HEDLEY_UNLIKELY(s.size() > 1 && s[0] == '0'))
        {
            JSON_THROW(detail::parse_error::create(106, 0,
                                                   "array index '" + s +
                                                   "' must not begin with '0'"));
        }

        // error condition (cf. RFC 6901, Sect. 4)
        if (JSON_HEDLEY_UNLIKELY(s.size() > 1 && !(s[0] >= '1' && s[0] <= '9')))
        {
            JSON_THROW(detail::parse_error::create(109, 0, "array index '" + s + "' is not a number"));
        }

        std::size_t processed_chars = 0;
        unsigned long long res = 0;
        JSON_TRY
        {
            res = std::stoull(s, &processed_chars);
        }
        JSON_CATCH(std::out_of_range&)
        {
            JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + s + "'"));
        }

        // check if the string was completely read
        if (JSON_HEDLEY_UNLIKELY(processed_chars != s.size()))
        {
            JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + s + "'"));
        }

        // only triggered on special platforms (like 32bit), see also
        // https://github.com/nlohmann/json/pull/2203
        if (res >= static_cast<unsigned long long>((std::numeric_limits<size_type>::max)()))
        {
            JSON_THROW(detail::out_of_range::create(410, "array index " + s + " exceeds size_type")); // LCOV_EXCL_LINE
        }

        return static_cast<size_type>(res);
    }

    json_pointer top() const
    {
        if (JSON_HEDLEY_UNLIKELY(empty()))
        {
            JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent"));
        }

        json_pointer result = *this;
        result.reference_tokens = {reference_tokens[0]};
        return result;
    }

    /*!
    @brief create and return a reference to the pointed to value

    @complexity Linear in the number of reference tokens.

    @throw parse_error.109 if array index is not a number
    @throw type_error.313 if value cannot be unflattened
    */
    BasicJsonType& get_and_create(BasicJsonType& j) const
    {
        auto result = &j;

        // in case no reference tokens exist, return a reference to the JSON value
        // j which will be overwritten by a primitive value
        for (const auto& reference_token : reference_tokens)
        {
            switch (result->type())
            {
                case detail::value_t::null:
                {
                    if (reference_token == "0")
                    {
                        // start a new array if reference token is 0
                        result = &result->operator[](0);
                    }
                    else
                    {
                        // start a new object otherwise
                        result = &result->operator[](reference_token);
                    }
                    break;
                }

                case detail::value_t::object:
                {
                    // create an entry in the object
                    result = &result->operator[](reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    // create an entry in the array
                    result = &result->operator[](array_index(reference_token));
                    break;
                }

                /*
                The following code is only reached if there exists a reference
                token _and_ the current value is primitive. In this case, we have
                an error situation, because primitive values may only occur as
                single value; that is, with an empty list of reference tokens.
                */
                default:
                    JSON_THROW(detail::type_error::create(313, "invalid value to unflatten"));
            }
        }

        return *result;
    }

    /*!
    @brief return a reference to the pointed to value

    @note This version does not throw if a value is not present, but tries to
          create nested values instead. For instance, calling this function
          with pointer `"/this/that"` on a null value is equivalent to calling
          `operator[]("this").operator[]("that")` on that value, effectively
          changing the null value to an object.

    @param[in] ptr  a JSON value

    @return reference to the JSON value pointed to by the JSON pointer

    @complexity Linear in the length of the JSON pointer.

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    BasicJsonType& get_unchecked(BasicJsonType* ptr) const
    {
        for (const auto& reference_token : reference_tokens)
        {
            // convert null values to arrays or objects before continuing
            if (ptr->is_null())
            {
                // check if reference token is a number
                const bool nums =
                    std::all_of(reference_token.begin(), reference_token.end(),
                                [](const unsigned char x)
                {
                    return std::isdigit(x);
                });

                // change value to array for numbers or "-" or to object otherwise
                *ptr = (nums || reference_token == "-")
                       ? detail::value_t::array
                       : detail::value_t::object;
            }

            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    // use unchecked object access
                    ptr = &ptr->operator[](reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (reference_token == "-")
                    {
                        // explicitly treat "-" as index beyond the end
                        ptr = &ptr->operator[](ptr->m_value.array->size());
                    }
                    else
                    {
                        // convert array index to number; unchecked access
                        ptr = &ptr->operator[](array_index(reference_token));
                    }
                    break;
                }

                default:
                    JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'"));
            }
        }

        return *ptr;
    }

    /*!
    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    BasicJsonType& get_checked(BasicJsonType* ptr) const
    {
        for (const auto& reference_token : reference_tokens)
        {
            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    // note: at performs range check
                    ptr = &ptr->at(reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
                    {
                        // "-" always fails the range check
                        JSON_THROW(detail::out_of_range::create(402,
                                                                "array index '-' (" + std::to_string(ptr->m_value.array->size()) +
                                                                ") is out of range"));
                    }

                    // note: at performs range check
                    ptr = &ptr->at(array_index(reference_token));
                    break;
                }

                default:
                    JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'"));
            }
        }

        return *ptr;
    }

    /*!
    @brief return a const reference to the pointed to value

    @param[in] ptr  a JSON value

    @return const reference to the JSON value pointed to by the JSON
    pointer

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    const BasicJsonType& get_unchecked(const BasicJsonType* ptr) const
    {
        for (const auto& reference_token : reference_tokens)
        {
            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    // use unchecked object access
                    ptr = &ptr->operator[](reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
                    {
                        // "-" cannot be used for const access
                        JSON_THROW(detail::out_of_range::create(402,
                                                                "array index '-' (" + std::to_string(ptr->m_value.array->size()) +
                                                                ") is out of range"));
                    }

                    // use unchecked array access
                    ptr = &ptr->operator[](array_index(reference_token));
                    break;
                }

                default:
                    JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'"));
            }
        }

        return *ptr;
    }

    /*!
    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    const BasicJsonType& get_checked(const BasicJsonType* ptr) const
    {
        for (const auto& reference_token : reference_tokens)
        {
            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    // note: at performs range check
                    ptr = &ptr->at(reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
                    {
                        // "-" always fails the range check
                        JSON_THROW(detail::out_of_range::create(402,
                                                                "array index '-' (" + std::to_string(ptr->m_value.array->size()) +
                                                                ") is out of range"));
                    }

                    // note: at performs range check
                    ptr = &ptr->at(array_index(reference_token));
                    break;
                }

                default:
                    JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'"));
            }
        }

        return *ptr;
    }

    /*!
    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    */
    bool contains(const BasicJsonType* ptr) const
    {
        for (const auto& reference_token : reference_tokens)
        {
            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    if (!ptr->contains(reference_token))
                    {
                        // we did not find the key in the object
                        return false;
                    }

                    ptr = &ptr->operator[](reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
                    {
                        // "-" always fails the range check
                        return false;
                    }
                    if (JSON_HEDLEY_UNLIKELY(reference_token.size() == 1 && !("0" <= reference_token && reference_token <= "9")))
                    {
                        // invalid char
                        return false;
                    }
                    if (JSON_HEDLEY_UNLIKELY(reference_token.size() > 1))
                    {
                        if (JSON_HEDLEY_UNLIKELY(!('1' <= reference_token[0] && reference_token[0] <= '9')))
                        {
                            // first char should be between '1' and '9'
                            return false;
                        }
                        for (std::size_t i = 1; i < reference_token.size(); i++)
                        {
                            if (JSON_HEDLEY_UNLIKELY(!('0' <= reference_token[i] && reference_token[i] <= '9')))
                            {
                                // other char should be between '0' and '9'
                                return false;
                            }
                        }
                    }

                    const auto idx = array_index(reference_token);
                    if (idx >= ptr->size())
                    {
                        // index out of range
                        return false;
                    }

                    ptr = &ptr->operator[](idx);
                    break;
                }

                default:
                {
                    // we do not expect primitive values if there is still a
                    // reference token to process
                    return false;
                }
            }
        }

        // no reference token left means we found a primitive value
        return true;
    }

    /*!
    @brief split the string input to reference tokens

    @note This function is only called by the json_pointer constructor.
          All exceptions below are documented there.

    @throw parse_error.107  if the pointer is not empty or begins with '/'
    @throw parse_error.108  if character '~' is not followed by '0' or '1'
    */
    static std::vector<std::string> split(const std::string& reference_string)
    {
        std::vector<std::string> result;

        // special case: empty reference string -> no reference tokens
        if (reference_string.empty())
        {
            return result;
        }

        // check if nonempty reference string begins with slash
        if (JSON_HEDLEY_UNLIKELY(reference_string[0] != '/'))
        {
            JSON_THROW(detail::parse_error::create(107, 1,
                                                   "JSON pointer must be empty or begin with '/' - was: '" +
                                                   reference_string + "'"));
        }

        // extract the reference tokens:
        // - slash: position of the last read slash (or end of string)
        // - start: position after the previous slash
        for (
            // search for the first slash after the first character
            std::size_t slash = reference_string.find_first_of('/', 1),
            // set the beginning of the first reference token
            start = 1;
            // we can stop if start == 0 (if slash == std::string::npos)
            start != 0;
            // set the beginning of the next reference token
            // (will eventually be 0 if slash == std::string::npos)
            start = (slash == std::string::npos) ? 0 : slash + 1,
            // find next slash
            slash = reference_string.find_first_of('/', start))
        {
            // use the text between the beginning of the reference token
            // (start) and the last slash (slash).
            auto reference_token = reference_string.substr(start, slash - start);

            // check reference tokens are properly escaped
            for (std::size_t pos = reference_token.find_first_of('~');
                    pos != std::string::npos;
                    pos = reference_token.find_first_of('~', pos + 1))
            {
                JSON_ASSERT(reference_token[pos] == '~');

                // ~ must be followed by 0 or 1
                if (JSON_HEDLEY_UNLIKELY(pos == reference_token.size() - 1 ||
                                         (reference_token[pos + 1] != '0' &&
                                          reference_token[pos + 1] != '1')))
                {
                    JSON_THROW(detail::parse_error::create(108, 0, "escape character '~' must be followed with '0' or '1'"));
                }
            }

            // finally, store the reference token
            unescape(reference_token);
            result.push_back(reference_token);
        }

        return result;
    }

    /*!
    @brief replace all occurrences of a substring by another string

    @param[in,out] s  the string to manipulate; changed so that all
                   occurrences of @a f are replaced with @a t
    @param[in]     f  the substring to replace with @a t
    @param[in]     t  the string to replace @a f

    @pre The search string @a f must not be empty. **This precondition is
    enforced with an assertion.**

    @since version 2.0.0
    */
    static void replace_substring(std::string& s, const std::string& f,
                                  const std::string& t)
    {
        JSON_ASSERT(!f.empty());
        for (auto pos = s.find(f);                // find first occurrence of f
                pos != std::string::npos;         // make sure f was found
                s.replace(pos, f.size(), t),      // replace with t, and
                pos = s.find(f, pos + t.size()))  // find next occurrence of f
        {}
    }

    /// escape "~" to "~0" and "/" to "~1"
    static std::string escape(std::string s)
    {
        replace_substring(s, "~", "~0");
        replace_substring(s, "/", "~1");
        return s;
    }

    /// unescape "~1" to tilde and "~0" to slash (order is important!)
    static void unescape(std::string& s)
    {
        replace_substring(s, "~1", "/");
        replace_substring(s, "~0", "~");
    }

    /*!
    @param[in] reference_string  the reference string to the current value
    @param[in] value             the value to consider
    @param[in,out] result        the result object to insert values to

    @note Empty objects or arrays are flattened to `null`.
    */
    static void flatten(const std::string& reference_string,
                        const BasicJsonType& value,
                        BasicJsonType& result)
    {
        switch (value.type())
        {
            case detail::value_t::array:
            {
                if (value.m_value.array->empty())
                {
                    // flatten empty array as null
                    result[reference_string] = nullptr;
                }
                else
                {
                    // iterate array and use index as reference string
                    for (std::size_t i = 0; i < value.m_value.array->size(); ++i)
                    {
                        flatten(reference_string + "/" + std::to_string(i),
                                value.m_value.array->operator[](i), result);
                    }
                }
                break;
            }

            case detail::value_t::object:
            {
                if (value.m_value.object->empty())
                {
                    // flatten empty object as null
                    result[reference_string] = nullptr;
                }
                else
                {
                    // iterate object and use keys as reference string
                    for (const auto& element : *value.m_value.object)
                    {
                        flatten(reference_string + "/" + escape(element.first), element.second, result);
                    }
                }
                break;
            }

            default:
            {
                // add primitive value with its reference string
                result[reference_string] = value;
                break;
            }
        }
    }

    /*!
    @param[in] value  flattened JSON

    @return unflattened JSON

    @throw parse_error.109 if array index is not a number
    @throw type_error.314  if value is not an object
    @throw type_error.315  if object values are not primitive
    @throw type_error.313  if value cannot be unflattened
    */
    static BasicJsonType
    unflatten(const BasicJsonType& value)
    {
        if (JSON_HEDLEY_UNLIKELY(!value.is_object()))
        {
            JSON_THROW(detail::type_error::create(314, "only objects can be unflattened"));
        }

        BasicJsonType result;

        // iterate the JSON object values
        for (const auto& element : *value.m_value.object)
        {
            if (JSON_HEDLEY_UNLIKELY(!element.second.is_primitive()))
            {
                JSON_THROW(detail::type_error::create(315, "values in object must be primitive"));
            }

            // assign value to reference pointed to by JSON pointer; Note that if
            // the JSON pointer is "" (i.e., points to the whole value), function
            // get_and_create returns a reference to result itself. An assignment
            // will then create a primitive value.
            json_pointer(element.first).get_and_create(result) = element.second;
        }

        return result;
    }

    /*!
    @brief compares two JSON pointers for equality

    @param[in] lhs  JSON pointer to compare
    @param[in] rhs  JSON pointer to compare
    @return whether @a lhs is equal to @a rhs

    @complexity Linear in the length of the JSON pointer

    @exceptionsafety No-throw guarantee: this function never throws exceptions.
    */
    friend bool operator==(json_pointer const& lhs,
                           json_pointer const& rhs) noexcept
    {
        return lhs.reference_tokens == rhs.reference_tokens;
    }

    /*!
    @brief compares two JSON pointers for inequality

    @param[in] lhs  JSON pointer to compare
    @param[in] rhs  JSON pointer to compare
    @return whether @a lhs is not equal @a rhs

    @complexity Linear in the length of the JSON pointer

    @exceptionsafety No-throw guarantee: this function never throws exceptions.
    */
    friend bool operator!=(json_pointer const& lhs,
                           json_pointer const& rhs) noexcept
    {
        return !(lhs == rhs);
    }

    /// the reference tokens
    std::vector<std::string> reference_tokens;
};
}  // namespace nlohmann

// #include <nlohmann/detail/json_ref.hpp>


#include <initializer_list>
#include <utility>

// #include <nlohmann/detail/meta/type_traits.hpp>


namespace nlohmann
{
namespace detail
{
template<typename BasicJsonType>
class json_ref
{
  public:
    using value_type = BasicJsonType;

    json_ref(value_type&& value)
        : owned_value(std::move(value))
        , value_ref(&owned_value)
        , is_rvalue(true)
    {}

    json_ref(const value_type& value)
        : value_ref(const_cast<value_type*>(&value))
        , is_rvalue(false)
    {}

    json_ref(std::initializer_list<json_ref> init)
        : owned_value(init)
        , value_ref(&owned_value)
        , is_rvalue(true)
    {}

    template <
        class... Args,
        enable_if_t<std::is_constructible<value_type, Args...>::value, int> = 0 >
    json_ref(Args && ... args)
        : owned_value(std::forward<Args>(args)...)
        , value_ref(&owned_value)
        , is_rvalue(true)
    {}

    // class should be movable only
    json_ref(json_ref&&) = default;
    json_ref(const json_ref&) = delete;
    json_ref& operator=(const json_ref&) = delete;
    json_ref& operator=(json_ref&&) = delete;
    ~json_ref() = default;

    value_type moved_or_copied() const
    {
        if (is_rvalue)
        {
            return std::move(*value_ref);
        }
        return *value_ref;
    }

    value_type const& operator*() const
    {
        return *static_cast<value_type const*>(value_ref);
    }

    value_type const* operator->() const
    {
        return static_cast<value_type const*>(value_ref);
    }

  private:
    mutable value_type owned_value = nullptr;
    value_type* value_ref = nullptr;
    const bool is_rvalue = true;
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/output/binary_writer.hpp>


#include <algorithm> // reverse
#include <array> // array
#include <cstdint> // uint8_t, uint16_t, uint32_t, uint64_t
#include <cstring> // memcpy
#include <limits> // numeric_limits
#include <string> // string
#include <cmath> // isnan, isinf

// #include <nlohmann/detail/input/binary_reader.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/output/output_adapters.hpp>


#include <algorithm> // copy
#include <cstddef> // size_t
#include <ios> // streamsize
#include <iterator> // back_inserter
#include <memory> // shared_ptr, make_shared
#include <ostream> // basic_ostream
#include <string> // basic_string
#include <vector> // vector
// #include <nlohmann/detail/macro_scope.hpp>


namespace nlohmann
{
namespace detail
{
/// abstract output adapter interface
template<typename CharType> struct output_adapter_protocol
{
    virtual void write_character(CharType c) = 0;
    virtual void write_characters(const CharType* s, std::size_t length) = 0;
    virtual ~output_adapter_protocol() = default;
};

/// a type to simplify interfaces
template<typename CharType>
using output_adapter_t = std::shared_ptr<output_adapter_protocol<CharType>>;

/// output adapter for byte vectors
template<typename CharType>
class output_vector_adapter : public output_adapter_protocol<CharType>
{
  public:
    explicit output_vector_adapter(std::vector<CharType>& vec) noexcept
        : v(vec)
    {}

    void write_character(CharType c) override
    {
        v.push_back(c);
    }

    JSON_HEDLEY_NON_NULL(2)
    void write_characters(const CharType* s, std::size_t length) override
    {
        std::copy(s, s + length, std::back_inserter(v));
    }

  private:
    std::vector<CharType>& v;
};

/// output adapter for output streams
template<typename CharType>
class output_stream_adapter : public output_adapter_protocol<CharType>
{
  public:
    explicit output_stream_adapter(std::basic_ostream<CharType>& s) noexcept
        : stream(s)
    {}

    void write_character(CharType c) override
    {
        stream.put(c);
    }

    JSON_HEDLEY_NON_NULL(2)
    void write_characters(const CharType* s, std::size_t length) override
    {
        stream.write(s, static_cast<std::streamsize>(length));
    }

  private:
    std::basic_ostream<CharType>& stream;
};

/// output adapter for basic_string
template<typename CharType, typename StringType = std::basic_string<CharType>>
class output_string_adapter : public output_adapter_protocol<CharType>
{
  public:
    explicit output_string_adapter(StringType& s) noexcept
        : str(s)
    {}

    void write_character(CharType c) override
    {
        str.push_back(c);
    }

    JSON_HEDLEY_NON_NULL(2)
    void write_characters(const CharType* s, std::size_t length) override
    {
        str.append(s, length);
    }

  private:
    StringType& str;
};

template<typename CharType, typename StringType = std::basic_string<CharType>>
class output_adapter
{
  public:
    output_adapter(std::vector<CharType>& vec)
        : oa(std::make_shared<output_vector_adapter<CharType>>(vec)) {}

    output_adapter(std::basic_ostream<CharType>& s)
        : oa(std::make_shared<output_stream_adapter<CharType>>(s)) {}

    output_adapter(StringType& s)
        : oa(std::make_shared<output_string_adapter<CharType, StringType>>(s)) {}

    operator output_adapter_t<CharType>()
    {
        return oa;
    }

  private:
    output_adapter_t<CharType> oa = nullptr;
};
}  // namespace detail
}  // namespace nlohmann


namespace nlohmann
{
namespace detail
{
///////////////////
// binary writer //
///////////////////

/*!
@brief serialization to CBOR and MessagePack values
*/
template<typename BasicJsonType, typename CharType>
class binary_writer
{
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;
    using number_float_t = typename BasicJsonType::number_float_t;

  public:
    /*!
    @brief create a binary writer

    @param[in] adapter  output adapter to write to
    */
    explicit binary_writer(output_adapter_t<CharType> adapter) : oa(adapter)
    {
        JSON_ASSERT(oa);
    }

    /*!
    @param[in] j  JSON value to serialize
    @pre       j.type() == value_t::object
    */
    void write_bson(const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::object:
            {
                write_bson_object(*j.m_value.object);
                break;
            }

            default:
            {
                JSON_THROW(type_error::create(317, "to serialize to BSON, top-level type must be object, but is " + std::string(j.type_name())));
            }
        }
    }

    /*!
    @param[in] j  JSON value to serialize
    */
    void write_cbor(const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::null:
            {
                oa->write_character(to_char_type(0xF6));
                break;
            }

            case value_t::boolean:
            {
                oa->write_character(j.m_value.boolean
                                    ? to_char_type(0xF5)
                                    : to_char_type(0xF4));
                break;
            }

            case value_t::number_integer:
            {
                if (j.m_value.number_integer >= 0)
                {
                    // CBOR does not differentiate between positive signed
                    // integers and unsigned integers. Therefore, we used the
                    // code from the value_t::number_unsigned case here.
                    if (j.m_value.number_integer <= 0x17)
                    {
                        write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer <= (std::numeric_limits<std::uint8_t>::max)())
                    {
                        oa->write_character(to_char_type(0x18));
                        write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer <= (std::numeric_limits<std::uint16_t>::max)())
                    {
                        oa->write_character(to_char_type(0x19));
                        write_number(static_cast<std::uint16_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer <= (std::numeric_limits<std::uint32_t>::max)())
                    {
                        oa->write_character(to_char_type(0x1A));
                        write_number(static_cast<std::uint32_t>(j.m_value.number_integer));
                    }
                    else
                    {
                        oa->write_character(to_char_type(0x1B));
                        write_number(static_cast<std::uint64_t>(j.m_value.number_integer));
                    }
                }
                else
                {
                    // The conversions below encode the sign in the first
                    // byte, and the value is converted to a positive number.
                    const auto positive_number = -1 - j.m_value.number_integer;
                    if (j.m_value.number_integer >= -24)
                    {
                        write_number(static_cast<std::uint8_t>(0x20 + positive_number));
                    }
                    else if (positive_number <= (std::numeric_limits<std::uint8_t>::max)())
                    {
                        oa->write_character(to_char_type(0x38));
                        write_number(static_cast<std::uint8_t>(positive_number));
                    }
                    else if (positive_number <= (std::numeric_limits<std::uint16_t>::max)())
                    {
                        oa->write_character(to_char_type(0x39));
                        write_number(static_cast<std::uint16_t>(positive_number));
                    }
                    else if (positive_number <= (std::numeric_limits<std::uint32_t>::max)())
                    {
                        oa->write_character(to_char_type(0x3A));
                        write_number(static_cast<std::uint32_t>(positive_number));
                    }
                    else
                    {
                        oa->write_character(to_char_type(0x3B));
                        write_number(static_cast<std::uint64_t>(positive_number));
                    }
                }
                break;
            }

            case value_t::number_unsigned:
            {
                if (j.m_value.number_unsigned <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(j.m_value.number_unsigned));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0x18));
                    write_number(static_cast<std::uint8_t>(j.m_value.number_unsigned));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0x19));
                    write_number(static_cast<std::uint16_t>(j.m_value.number_unsigned));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0x1A));
                    write_number(static_cast<std::uint32_t>(j.m_value.number_unsigned));
                }
                else
                {
                    oa->write_character(to_char_type(0x1B));
                    write_number(static_cast<std::uint64_t>(j.m_value.number_unsigned));
                }
                break;
            }

            case value_t::number_float:
            {
                if (std::isnan(j.m_value.number_float))
                {
                    // NaN is 0xf97e00 in CBOR
                    oa->write_character(to_char_type(0xF9));
                    oa->write_character(to_char_type(0x7E));
                    oa->write_character(to_char_type(0x00));
                }
                else if (std::isinf(j.m_value.number_float))
                {
                    // Infinity is 0xf97c00, -Infinity is 0xf9fc00
                    oa->write_character(to_char_type(0xf9));
                    oa->write_character(j.m_value.number_float > 0 ? to_char_type(0x7C) : to_char_type(0xFC));
                    oa->write_character(to_char_type(0x00));
                }
                else
                {
                    write_compact_float(j.m_value.number_float, detail::input_format_t::cbor);
                }
                break;
            }

            case value_t::string:
            {
                // step 1: write control byte and the string length
                const auto N = j.m_value.string->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(0x60 + N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0x78));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0x79));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0x7A));
                    write_number(static_cast<std::uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    oa->write_character(to_char_type(0x7B));
                    write_number(static_cast<std::uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write the string
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_value.string->c_str()),
                    j.m_value.string->size());
                break;
            }

            case value_t::array:
            {
                // step 1: write control byte and the array size
                const auto N = j.m_value.array->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(0x80 + N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0x98));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0x99));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0x9A));
                    write_number(static_cast<std::uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    oa->write_character(to_char_type(0x9B));
                    write_number(static_cast<std::uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write each element
                for (const auto& el : *j.m_value.array)
                {
                    write_cbor(el);
                }
                break;
            }

            case value_t::binary:
            {
                if (j.m_value.binary->has_subtype())
                {
                    write_number(static_cast<std::uint8_t>(0xd8));
                    write_number(j.m_value.binary->subtype());
                }

                // step 1: write control byte and the binary array size
                const auto N = j.m_value.binary->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(0x40 + N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0x58));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0x59));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0x5A));
                    write_number(static_cast<std::uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    oa->write_character(to_char_type(0x5B));
                    write_number(static_cast<std::uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write each element
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_value.binary->data()),
                    N);

                break;
            }

            case value_t::object:
            {
                // step 1: write control byte and the object size
                const auto N = j.m_value.object->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(0xA0 + N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0xB8));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0xB9));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0xBA));
                    write_number(static_cast<std::uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    oa->write_character(to_char_type(0xBB));
                    write_number(static_cast<std::uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write each element
                for (const auto& el : *j.m_value.object)
                {
                    write_cbor(el.first);
                    write_cbor(el.second);
                }
                break;
            }

            default:
                break;
        }
    }

    /*!
    @param[in] j  JSON value to serialize
    */
    void write_msgpack(const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::null: // nil
            {
                oa->write_character(to_char_type(0xC0));
                break;
            }

            case value_t::boolean: // true and false
            {
                oa->write_character(j.m_value.boolean
                                    ? to_char_type(0xC3)
                                    : to_char_type(0xC2));
                break;
            }

            case value_t::number_integer:
            {
                if (j.m_value.number_integer >= 0)
                {
                    // MessagePack does not differentiate between positive
                    // signed integers and unsigned integers. Therefore, we used
                    // the code from the value_t::number_unsigned case here.
                    if (j.m_value.number_unsigned < 128)
                    {
                        // positive fixnum
                        write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
                    {
                        // uint 8
                        oa->write_character(to_char_type(0xCC));
                        write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
                    {
                        // uint 16
                        oa->write_character(to_char_type(0xCD));
                        write_number(static_cast<std::uint16_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
                    {
                        // uint 32
                        oa->write_character(to_char_type(0xCE));
                        write_number(static_cast<std::uint32_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())
                    {
                        // uint 64
                        oa->write_character(to_char_type(0xCF));
                        write_number(static_cast<std::uint64_t>(j.m_value.number_integer));
                    }
                }
                else
                {
                    if (j.m_value.number_integer >= -32)
                    {
                        // negative fixnum
                        write_number(static_cast<std::int8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer >= (std::numeric_limits<std::int8_t>::min)() &&
                             j.m_value.number_integer <= (std::numeric_limits<std::int8_t>::max)())
                    {
                        // int 8
                        oa->write_character(to_char_type(0xD0));
                        write_number(static_cast<std::int8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer >= (std::numeric_limits<std::int16_t>::min)() &&
                             j.m_value.number_integer <= (std::numeric_limits<std::int16_t>::max)())
                    {
                        // int 16
                        oa->write_character(to_char_type(0xD1));
                        write_number(static_cast<std::int16_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer >= (std::numeric_limits<std::int32_t>::min)() &&
                             j.m_value.number_integer <= (std::numeric_limits<std::int32_t>::max)())
                    {
                        // int 32
                        oa->write_character(to_char_type(0xD2));
                        write_number(static_cast<std::int32_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer >= (std::numeric_limits<std::int64_t>::min)() &&
                             j.m_value.number_integer <= (std::numeric_limits<std::int64_t>::max)())
                    {
                        // int 64
                        oa->write_character(to_char_type(0xD3));
                        write_number(static_cast<std::int64_t>(j.m_value.number_integer));
                    }
                }
                break;
            }

            case value_t::number_unsigned:
            {
                if (j.m_value.number_unsigned < 128)
                {
                    // positive fixnum
                    write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    // uint 8
                    oa->write_character(to_char_type(0xCC));
                    write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    // uint 16
                    oa->write_character(to_char_type(0xCD));
                    write_number(static_cast<std::uint16_t>(j.m_value.number_integer));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    // uint 32
                    oa->write_character(to_char_type(0xCE));
                    write_number(static_cast<std::uint32_t>(j.m_value.number_integer));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    // uint 64
                    oa->write_character(to_char_type(0xCF));
                    write_number(static_cast<std::uint64_t>(j.m_value.number_integer));
                }
                break;
            }

            case value_t::number_float:
            {
                write_compact_float(j.m_value.number_float, detail::input_format_t::msgpack);
                break;
            }

            case value_t::string:
            {
                // step 1: write control byte and the string length
                const auto N = j.m_value.string->size();
                if (N <= 31)
                {
                    // fixstr
                    write_number(static_cast<std::uint8_t>(0xA0 | N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    // str 8
                    oa->write_character(to_char_type(0xD9));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    // str 16
                    oa->write_character(to_char_type(0xDA));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    // str 32
                    oa->write_character(to_char_type(0xDB));
                    write_number(static_cast<std::uint32_t>(N));
                }

                // step 2: write the string
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_value.string->c_str()),
                    j.m_value.string->size());
                break;
            }

            case value_t::array:
            {
                // step 1: write control byte and the array size
                const auto N = j.m_value.array->size();
                if (N <= 15)
                {
                    // fixarray
                    write_number(static_cast<std::uint8_t>(0x90 | N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    // array 16
                    oa->write_character(to_char_type(0xDC));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    // array 32
                    oa->write_character(to_char_type(0xDD));
                    write_number(static_cast<std::uint32_t>(N));
                }

                // step 2: write each element
                for (const auto& el : *j.m_value.array)
                {
                    write_msgpack(el);
                }
                break;
            }

            case value_t::binary:
            {
                // step 0: determine if the binary type has a set subtype to
                // determine whether or not to use the ext or fixext types
                const bool use_ext = j.m_value.binary->has_subtype();

                // step 1: write control byte and the byte string length
                const auto N = j.m_value.binary->size();
                if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    std::uint8_t output_type{};
                    bool fixed = true;
                    if (use_ext)
                    {
                        switch (N)
                        {
                            case 1:
                                output_type = 0xD4; // fixext 1
                                break;
                            case 2:
                                output_type = 0xD5; // fixext 2
                                break;
                            case 4:
                                output_type = 0xD6; // fixext 4
                                break;
                            case 8:
                                output_type = 0xD7; // fixext 8
                                break;
                            case 16:
                                output_type = 0xD8; // fixext 16
                                break;
                            default:
                                output_type = 0xC7; // ext 8
                                fixed = false;
                                break;
                        }

                    }
                    else
                    {
                        output_type = 0xC4; // bin 8
                        fixed = false;
                    }

                    oa->write_character(to_char_type(output_type));
                    if (!fixed)
                    {
                        write_number(static_cast<std::uint8_t>(N));
                    }
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    std::uint8_t output_type = use_ext
                                               ? 0xC8 // ext 16
                                               : 0xC5; // bin 16

                    oa->write_character(to_char_type(output_type));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    std::uint8_t output_type = use_ext
                                               ? 0xC9 // ext 32
                                               : 0xC6; // bin 32

                    oa->write_character(to_char_type(output_type));
                    write_number(static_cast<std::uint32_t>(N));
                }

                // step 1.5: if this is an ext type, write the subtype
                if (use_ext)
                {
                    write_number(static_cast<std::int8_t>(j.m_value.binary->subtype()));
                }

                // step 2: write the byte string
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_value.binary->data()),
                    N);

                break;
            }

            case value_t::object:
            {
                // step 1: write control byte and the object size
                const auto N = j.m_value.object->size();
                if (N <= 15)
                {
                    // fixmap
                    write_number(static_cast<std::uint8_t>(0x80 | (N & 0xF)));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    // map 16
                    oa->write_character(to_char_type(0xDE));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    // map 32
                    oa->write_character(to_char_type(0xDF));
                    write_number(static_cast<std::uint32_t>(N));
                }

                // step 2: write each element
                for (const auto& el : *j.m_value.object)
                {
                    write_msgpack(el.first);
                    write_msgpack(el.second);
                }
                break;
            }

            default:
                break;
        }
    }

    /*!
    @param[in] j  JSON value to serialize
    @param[in] use_count   whether to use '#' prefixes (optimized format)
    @param[in] use_type    whether to use '$' prefixes (optimized format)
    @param[in] add_prefix  whether prefixes need to be used for this value
    */
    void write_ubjson(const BasicJsonType& j, const bool use_count,
                      const bool use_type, const bool add_prefix = true)
    {
        switch (j.type())
        {
            case value_t::null:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('Z'));
                }
                break;
            }

            case value_t::boolean:
            {
                if (add_prefix)
                {
                    oa->write_character(j.m_value.boolean
                                        ? to_char_type('T')
                                        : to_char_type('F'));
                }
                break;
            }

            case value_t::number_integer:
            {
                write_number_with_ubjson_prefix(j.m_value.number_integer, add_prefix);
                break;
            }

            case value_t::number_unsigned:
            {
                write_number_with_ubjson_prefix(j.m_value.number_unsigned, add_prefix);
                break;
            }

            case value_t::number_float:
            {
                write_number_with_ubjson_prefix(j.m_value.number_float, add_prefix);
                break;
            }

            case value_t::string:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('S'));
                }
                write_number_with_ubjson_prefix(j.m_value.string->size(), true);
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_value.string->c_str()),
                    j.m_value.string->size());
                break;
            }

            case value_t::array:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('['));
                }

                bool prefix_required = true;
                if (use_type && !j.m_value.array->empty())
                {
                    JSON_ASSERT(use_count);
                    const CharType first_prefix = ubjson_prefix(j.front());
                    const bool same_prefix = std::all_of(j.begin() + 1, j.end(),
                                                         [this, first_prefix](const BasicJsonType & v)
                    {
                        return ubjson_prefix(v) == first_prefix;
                    });

                    if (same_prefix)
                    {
                        prefix_required = false;
                        oa->write_character(to_char_type('$'));
                        oa->write_character(first_prefix);
                    }
                }

                if (use_count)
                {
                    oa->write_character(to_char_type('#'));
                    write_number_with_ubjson_prefix(j.m_value.array->size(), true);
                }

                for (const auto& el : *j.m_value.array)
                {
                    write_ubjson(el, use_count, use_type, prefix_required);
                }

                if (!use_count)
                {
                    oa->write_character(to_char_type(']'));
                }

                break;
            }

            case value_t::binary:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('['));
                }

                if (use_type && !j.m_value.binary->empty())
                {
                    JSON_ASSERT(use_count);
                    oa->write_character(to_char_type('$'));
                    oa->write_character('U');
                }

                if (use_count)
                {
                    oa->write_character(to_char_type('#'));
                    write_number_with_ubjson_prefix(j.m_value.binary->size(), true);
                }

                if (use_type)
                {
                    oa->write_characters(
                        reinterpret_cast<const CharType*>(j.m_value.binary->data()),
                        j.m_value.binary->size());
                }
                else
                {
                    for (size_t i = 0; i < j.m_value.binary->size(); ++i)
                    {
                        oa->write_character(to_char_type('U'));
                        oa->write_character(j.m_value.binary->data()[i]);
                    }
                }

                if (!use_count)
                {
                    oa->write_character(to_char_type(']'));
                }

                break;
            }

            case value_t::object:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('{'));
                }

                bool prefix_required = true;
                if (use_type && !j.m_value.object->empty())
                {
                    JSON_ASSERT(use_count);
                    const CharType first_prefix = ubjson_prefix(j.front());
                    const bool same_prefix = std::all_of(j.begin(), j.end(),
                                                         [this, first_prefix](const BasicJsonType & v)
                    {
                        return ubjson_prefix(v) == first_prefix;
                    });

                    if (same_prefix)
                    {
                        prefix_required = false;
                        oa->write_character(to_char_type('$'));
                        oa->write_character(first_prefix);
                    }
                }

                if (use_count)
                {
                    oa->write_character(to_char_type('#'));
                    write_number_with_ubjson_prefix(j.m_value.object->size(), true);
                }

                for (const auto& el : *j.m_value.object)
                {
                    write_number_with_ubjson_prefix(el.first.size(), true);
                    oa->write_characters(
                        reinterpret_cast<const CharType*>(el.first.c_str()),
                        el.first.size());
                    write_ubjson(el.second, use_count, use_type, prefix_required);
                }

                if (!use_count)
                {
                    oa->write_character(to_char_type('}'));
                }

                break;
            }

            default:
                break;
        }
    }

  private:
    //////////
    // BSON //
    //////////

    /*!
    @return The size of a BSON document entry header, including the id marker
            and the entry name size (and its null-terminator).
    */
    static std::size_t calc_bson_entry_header_size(const string_t& name)
    {
        const auto it = name.find(static_cast<typename string_t::value_type>(0));
        if (JSON_HEDLEY_UNLIKELY(it != BasicJsonType::string_t::npos))
        {
            JSON_THROW(out_of_range::create(409,
                                            "BSON key cannot contain code point U+0000 (at byte " + std::to_string(it) + ")"));
        }

        return /*id*/ 1ul + name.size() + /*zero-terminator*/1u;
    }

    /*!
    @brief Writes the given @a element_type and @a name to the output adapter
    */
    void write_bson_entry_header(const string_t& name,
                                 const std::uint8_t element_type)
    {
        oa->write_character(to_char_type(element_type)); // boolean
        oa->write_characters(
            reinterpret_cast<const CharType*>(name.c_str()),
            name.size() + 1u);
    }

    /*!
    @brief Writes a BSON element with key @a name and boolean value @a value
    */
    void write_bson_boolean(const string_t& name,
                            const bool value)
    {
        write_bson_entry_header(name, 0x08);
        oa->write_character(value ? to_char_type(0x01) : to_char_type(0x00));
    }

    /*!
    @brief Writes a BSON element with key @a name and double value @a value
    */
    void write_bson_double(const string_t& name,
                           const double value)
    {
        write_bson_entry_header(name, 0x01);
        write_number<double, true>(value);
    }

    /*!
    @return The size of the BSON-encoded string in @a value
    */
    static std::size_t calc_bson_string_size(const string_t& value)
    {
        return sizeof(std::int32_t) + value.size() + 1ul;
    }

    /*!
    @brief Writes a BSON element with key @a name and string value @a value
    */
    void write_bson_string(const string_t& name,
                           const string_t& value)
    {
        write_bson_entry_header(name, 0x02);

        write_number<std::int32_t, true>(static_cast<std::int32_t>(value.size() + 1ul));
        oa->write_characters(
            reinterpret_cast<const CharType*>(value.c_str()),
            value.size() + 1);
    }

    /*!
    @brief Writes a BSON element with key @a name and null value
    */
    void write_bson_null(const string_t& name)
    {
        write_bson_entry_header(name, 0x0A);
    }

    /*!
    @return The size of the BSON-encoded integer @a value
    */
    static std::size_t calc_bson_integer_size(const std::int64_t value)
    {
        return (std::numeric_limits<std::int32_t>::min)() <= value && value <= (std::numeric_limits<std::int32_t>::max)()
               ? sizeof(std::int32_t)
               : sizeof(std::int64_t);
    }

    /*!
    @brief Writes a BSON element with key @a name and integer @a value
    */
    void write_bson_integer(const string_t& name,
                            const std::int64_t value)
    {
        if ((std::numeric_limits<std::int32_t>::min)() <= value && value <= (std::numeric_limits<std::int32_t>::max)())
        {
            write_bson_entry_header(name, 0x10); // int32
            write_number<std::int32_t, true>(static_cast<std::int32_t>(value));
        }
        else
        {
            write_bson_entry_header(name, 0x12); // int64
            write_number<std::int64_t, true>(static_cast<std::int64_t>(value));
        }
    }

    /*!
    @return The size of the BSON-encoded unsigned integer in @a j
    */
    static constexpr std::size_t calc_bson_unsigned_size(const std::uint64_t value) noexcept
    {
        return (value <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
               ? sizeof(std::int32_t)
               : sizeof(std::int64_t);
    }

    /*!
    @brief Writes a BSON element with key @a name and unsigned @a value
    */
    void write_bson_unsigned(const string_t& name,
                             const std::uint64_t value)
    {
        if (value <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
        {
            write_bson_entry_header(name, 0x10 /* int32 */);
            write_number<std::int32_t, true>(static_cast<std::int32_t>(value));
        }
        else if (value <= static_cast<std::uint64_t>((std::numeric_limits<std::int64_t>::max)()))
        {
            write_bson_entry_header(name, 0x12 /* int64 */);
            write_number<std::int64_t, true>(static_cast<std::int64_t>(value));
        }
        else
        {
            JSON_THROW(out_of_range::create(407, "integer number " + std::to_string(value) + " cannot be represented by BSON as it does not fit int64"));
        }
    }

    /*!
    @brief Writes a BSON element with key @a name and object @a value
    */
    void write_bson_object_entry(const string_t& name,
                                 const typename BasicJsonType::object_t& value)
    {
        write_bson_entry_header(name, 0x03); // object
        write_bson_object(value);
    }

    /*!
    @return The size of the BSON-encoded array @a value
    */
    static std::size_t calc_bson_array_size(const typename BasicJsonType::array_t& value)
    {
        std::size_t array_index = 0ul;

        const std::size_t embedded_document_size = std::accumulate(std::begin(value), std::end(value), std::size_t(0), [&array_index](std::size_t result, const typename BasicJsonType::array_t::value_type & el)
        {
            return result + calc_bson_element_size(std::to_string(array_index++), el);
        });

        return sizeof(std::int32_t) + embedded_document_size + 1ul;
    }

    /*!
    @return The size of the BSON-encoded binary array @a value
    */
    static std::size_t calc_bson_binary_size(const typename BasicJsonType::binary_t& value)
    {
        return sizeof(std::int32_t) + value.size() + 1ul;
    }

    /*!
    @brief Writes a BSON element with key @a name and array @a value
    */
    void write_bson_array(const string_t& name,
                          const typename BasicJsonType::array_t& value)
    {
        write_bson_entry_header(name, 0x04); // array
        write_number<std::int32_t, true>(static_cast<std::int32_t>(calc_bson_array_size(value)));

        std::size_t array_index = 0ul;

        for (const auto& el : value)
        {
            write_bson_element(std::to_string(array_index++), el);
        }

        oa->write_character(to_char_type(0x00));
    }

    /*!
    @brief Writes a BSON element with key @a name and binary value @a value
    */
    void write_bson_binary(const string_t& name,
                           const binary_t& value)
    {
        write_bson_entry_header(name, 0x05);

        write_number<std::int32_t, true>(static_cast<std::int32_t>(value.size()));
        write_number(value.has_subtype() ? value.subtype() : std::uint8_t(0x00));

        oa->write_characters(reinterpret_cast<const CharType*>(value.data()), value.size());
    }

    /*!
    @brief Calculates the size necessary to serialize the JSON value @a j with its @a name
    @return The calculated size for the BSON document entry for @a j with the given @a name.
    */
    static std::size_t calc_bson_element_size(const string_t& name,
            const BasicJsonType& j)
    {
        const auto header_size = calc_bson_entry_header_size(name);
        switch (j.type())
        {
            case value_t::object:
                return header_size + calc_bson_object_size(*j.m_value.object);

            case value_t::array:
                return header_size + calc_bson_array_size(*j.m_value.array);

            case value_t::binary:
                return header_size + calc_bson_binary_size(*j.m_value.binary);

            case value_t::boolean:
                return header_size + 1ul;

            case value_t::number_float:
                return header_size + 8ul;

            case value_t::number_integer:
                return header_size + calc_bson_integer_size(j.m_value.number_integer);

            case value_t::number_unsigned:
                return header_size + calc_bson_unsigned_size(j.m_value.number_unsigned);

            case value_t::string:
                return header_size + calc_bson_string_size(*j.m_value.string);

            case value_t::null:
                return header_size + 0ul;

            // LCOV_EXCL_START
            default:
                JSON_ASSERT(false);
                return 0ul;
                // LCOV_EXCL_STOP
        }
    }

    /*!
    @brief Serializes the JSON value @a j to BSON and associates it with the
           key @a name.
    @param name The name to associate with the JSON entity @a j within the
                current BSON document
    @return The size of the BSON entry
    */
    void write_bson_element(const string_t& name,
                            const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::object:
                return write_bson_object_entry(name, *j.m_value.object);

            case value_t::array:
                return write_bson_array(name, *j.m_value.array);

            case value_t::binary:
                return write_bson_binary(name, *j.m_value.binary);

            case value_t::boolean:
                return write_bson_boolean(name, j.m_value.boolean);

            case value_t::number_float:
                return write_bson_double(name, j.m_value.number_float);

            case value_t::number_integer:
                return write_bson_integer(name, j.m_value.number_integer);

            case value_t::number_unsigned:
                return write_bson_unsigned(name, j.m_value.number_unsigned);

            case value_t::string:
                return write_bson_string(name, *j.m_value.string);

            case value_t::null:
                return write_bson_null(name);

            // LCOV_EXCL_START
            default:
                JSON_ASSERT(false);
                return;
                // LCOV_EXCL_STOP
        }
    }

    /*!
    @brief Calculates the size of the BSON serialization of the given
           JSON-object @a j.
    @param[in] j  JSON value to serialize
    @pre       j.type() == value_t::object
    */
    static std::size_t calc_bson_object_size(const typename BasicJsonType::object_t& value)
    {
        std::size_t document_size = std::accumulate(value.begin(), value.end(), std::size_t(0),
                                    [](size_t result, const typename BasicJsonType::object_t::value_type & el)
        {
            return result += calc_bson_element_size(el.first, el.second);
        });

        return sizeof(std::int32_t) + document_size + 1ul;
    }

    /*!
    @param[in] j  JSON value to serialize
    @pre       j.type() == value_t::object
    */
    void write_bson_object(const typename BasicJsonType::object_t& value)
    {
        write_number<std::int32_t, true>(static_cast<std::int32_t>(calc_bson_object_size(value)));

        for (const auto& el : value)
        {
            write_bson_element(el.first, el.second);
        }

        oa->write_character(to_char_type(0x00));
    }

    //////////
    // CBOR //
    //////////

    static constexpr CharType get_cbor_float_prefix(float /*unused*/)
    {
        return to_char_type(0xFA);  // Single-Precision Float
    }

    static constexpr CharType get_cbor_float_prefix(double /*unused*/)
    {
        return to_char_type(0xFB);  // Double-Precision Float
    }

    /////////////
    // MsgPack //
    /////////////

    static constexpr CharType get_msgpack_float_prefix(float /*unused*/)
    {
        return to_char_type(0xCA);  // float 32
    }

    static constexpr CharType get_msgpack_float_prefix(double /*unused*/)
    {
        return to_char_type(0xCB);  // float 64
    }

    ////////////
    // UBJSON //
    ////////////

    // UBJSON: write number (floating point)
    template<typename NumberType, typename std::enable_if<
                 std::is_floating_point<NumberType>::value, int>::type = 0>
    void write_number_with_ubjson_prefix(const NumberType n,
                                         const bool add_prefix)
    {
        if (add_prefix)
        {
            oa->write_character(get_ubjson_float_prefix(n));
        }
        write_number(n);
    }

    // UBJSON: write number (unsigned integer)
    template<typename NumberType, typename std::enable_if<
                 std::is_unsigned<NumberType>::value, int>::type = 0>
    void write_number_with_ubjson_prefix(const NumberType n,
                                         const bool add_prefix)
    {
        if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int8_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('i'));  // int8
            }
            write_number(static_cast<std::uint8_t>(n));
        }
        else if (n <= (std::numeric_limits<std::uint8_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('U'));  // uint8
            }
            write_number(static_cast<std::uint8_t>(n));
        }
        else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int16_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('I'));  // int16
            }
            write_number(static_cast<std::int16_t>(n));
        }
        else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('l'));  // int32
            }
            write_number(static_cast<std::int32_t>(n));
        }
        else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int64_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('L'));  // int64
            }
            write_number(static_cast<std::int64_t>(n));
        }
        else
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('H'));  // high-precision number
            }

            const auto number = BasicJsonType(n).dump();
            write_number_with_ubjson_prefix(number.size(), true);
            for (std::size_t i = 0; i < number.size(); ++i)
            {
                oa->write_character(to_char_type(static_cast<std::uint8_t>(number[i])));
            }
        }
    }

    // UBJSON: write number (signed integer)
    template < typename NumberType, typename std::enable_if <
                   std::is_signed<NumberType>::value&&
                   !std::is_floating_point<NumberType>::value, int >::type = 0 >
    void write_number_with_ubjson_prefix(const NumberType n,
                                         const bool add_prefix)
    {
        if ((std::numeric_limits<std::int8_t>::min)() <= n && n <= (std::numeric_limits<std::int8_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('i'));  // int8
            }
            write_number(static_cast<std::int8_t>(n));
        }
        else if (static_cast<std::int64_t>((std::numeric_limits<std::uint8_t>::min)()) <= n && n <= static_cast<std::int64_t>((std::numeric_limits<std::uint8_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('U'));  // uint8
            }
            write_number(static_cast<std::uint8_t>(n));
        }
        else if ((std::numeric_limits<std::int16_t>::min)() <= n && n <= (std::numeric_limits<std::int16_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('I'));  // int16
            }
            write_number(static_cast<std::int16_t>(n));
        }
        else if ((std::numeric_limits<std::int32_t>::min)() <= n && n <= (std::numeric_limits<std::int32_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('l'));  // int32
            }
            write_number(static_cast<std::int32_t>(n));
        }
        else if ((std::numeric_limits<std::int64_t>::min)() <= n && n <= (std::numeric_limits<std::int64_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('L'));  // int64
            }
            write_number(static_cast<std::int64_t>(n));
        }
        // LCOV_EXCL_START
        else
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('H'));  // high-precision number
            }

            const auto number = BasicJsonType(n).dump();
            write_number_with_ubjson_prefix(number.size(), true);
            for (std::size_t i = 0; i < number.size(); ++i)
            {
                oa->write_character(to_char_type(static_cast<std::uint8_t>(number[i])));
            }
        }
        // LCOV_EXCL_STOP
    }

    /*!
    @brief determine the type prefix of container values
    */
    CharType ubjson_prefix(const BasicJsonType& j) const noexcept
    {
        switch (j.type())
        {
            case value_t::null:
                return 'Z';

            case value_t::boolean:
                return j.m_value.boolean ? 'T' : 'F';

            case value_t::number_integer:
            {
                if ((std::numeric_limits<std::int8_t>::min)() <= j.m_value.number_integer && j.m_value.number_integer <= (std::numeric_limits<std::int8_t>::max)())
                {
                    return 'i';
                }
                if ((std::numeric_limits<std::uint8_t>::min)() <= j.m_value.number_integer && j.m_value.number_integer <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    return 'U';
                }
                if ((std::numeric_limits<std::int16_t>::min)() <= j.m_value.number_integer && j.m_value.number_integer <= (std::numeric_limits<std::int16_t>::max)())
                {
                    return 'I';
                }
                if ((std::numeric_limits<std::int32_t>::min)() <= j.m_value.number_integer && j.m_value.number_integer <= (std::numeric_limits<std::int32_t>::max)())
                {
                    return 'l';
                }
                if ((std::numeric_limits<std::int64_t>::min)() <= j.m_value.number_integer && j.m_value.number_integer <= (std::numeric_limits<std::int64_t>::max)())
                {
                    return 'L';
                }
                // anything else is treated as high-precision number
                return 'H'; // LCOV_EXCL_LINE
            }

            case value_t::number_unsigned:
            {
                if (j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int8_t>::max)()))
                {
                    return 'i';
                }
                if (j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::uint8_t>::max)()))
                {
                    return 'U';
                }
                if (j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int16_t>::max)()))
                {
                    return 'I';
                }
                if (j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
                {
                    return 'l';
                }
                if (j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int64_t>::max)()))
                {
                    return 'L';
                }
                // anything else is treated as high-precision number
                return 'H'; // LCOV_EXCL_LINE
            }

            case value_t::number_float:
                return get_ubjson_float_prefix(j.m_value.number_float);

            case value_t::string:
                return 'S';

            case value_t::array: // fallthrough
            case value_t::binary:
                return '[';

            case value_t::object:
                return '{';

            default:  // discarded values
                return 'N';
        }
    }

    static constexpr CharType get_ubjson_float_prefix(float /*unused*/)
    {
        return 'd';  // float 32
    }

    static constexpr CharType get_ubjson_float_prefix(double /*unused*/)
    {
        return 'D';  // float 64
    }

    ///////////////////////
    // Utility functions //
    ///////////////////////

    /*
    @brief write a number to output input
    @param[in] n number of type @a NumberType
    @tparam NumberType the type of the number
    @tparam OutputIsLittleEndian Set to true if output data is
                                 required to be little endian

    @note This function needs to respect the system's endianess, because bytes
          in CBOR, MessagePack, and UBJSON are stored in network order (big
          endian) and therefore need reordering on little endian systems.
    */
    template<typename NumberType, bool OutputIsLittleEndian = false>
    void write_number(const NumberType n)
    {
        // step 1: write number to array of length NumberType
        std::array<CharType, sizeof(NumberType)> vec;
        std::memcpy(vec.data(), &n, sizeof(NumberType));

        // step 2: write array to output (with possible reordering)
        if (is_little_endian != OutputIsLittleEndian)
        {
            // reverse byte order prior to conversion if necessary
            std::reverse(vec.begin(), vec.end());
        }

        oa->write_characters(vec.data(), sizeof(NumberType));
    }

    void write_compact_float(const number_float_t n, detail::input_format_t format)
    {
        if (static_cast<double>(n) >= static_cast<double>(std::numeric_limits<float>::lowest()) &&
                static_cast<double>(n) <= static_cast<double>((std::numeric_limits<float>::max)()) &&
                static_cast<double>(static_cast<float>(n)) == static_cast<double>(n))
        {
            oa->write_character(format == detail::input_format_t::cbor
                                ? get_cbor_float_prefix(static_cast<float>(n))
                                : get_msgpack_float_prefix(static_cast<float>(n)));
            write_number(static_cast<float>(n));
        }
        else
        {
            oa->write_character(format == detail::input_format_t::cbor
                                ? get_cbor_float_prefix(n)
                                : get_msgpack_float_prefix(n));
            write_number(n);
        }
    }

  public:
    // The following to_char_type functions are implement the conversion
    // between uint8_t and CharType. In case CharType is not unsigned,
    // such a conversion is required to allow values greater than 128.
    // See <https://github.com/nlohmann/json/issues/1286> for a discussion.
    template < typename C = CharType,
               enable_if_t < std::is_signed<C>::value && std::is_signed<char>::value > * = nullptr >
    static constexpr CharType to_char_type(std::uint8_t x) noexcept
    {
        return *reinterpret_cast<char*>(&x);
    }

    template < typename C = CharType,
               enable_if_t < std::is_signed<C>::value && std::is_unsigned<char>::value > * = nullptr >
    static CharType to_char_type(std::uint8_t x) noexcept
    {
        static_assert(sizeof(std::uint8_t) == sizeof(CharType), "size of CharType must be equal to std::uint8_t");
        static_assert(std::is_trivial<CharType>::value, "CharType must be trivial");
        CharType result;
        std::memcpy(&result, &x, sizeof(x));
        return result;
    }

    template<typename C = CharType,
             enable_if_t<std::is_unsigned<C>::value>* = nullptr>
    static constexpr CharType to_char_type(std::uint8_t x) noexcept
    {
        return x;
    }

    template < typename InputCharType, typename C = CharType,
               enable_if_t <
                   std::is_signed<C>::value &&
                   std::is_signed<char>::value &&
                   std::is_same<char, typename std::remove_cv<InputCharType>::type>::value
                   > * = nullptr >
    static constexpr CharType to_char_type(InputCharType x) noexcept
    {
        return x;
    }

  private:
    /// whether we can assume little endianess
    const bool is_little_endian = little_endianess();

    /// the output
    output_adapter_t<CharType> oa = nullptr;
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/output/output_adapters.hpp>

// #include <nlohmann/detail/output/serializer.hpp>


#include <algorithm> // reverse, remove, fill, find, none_of
#include <array> // array
#include <clocale> // localeconv, lconv
#include <cmath> // labs, isfinite, isnan, signbit
#include <cstddef> // size_t, ptrdiff_t
#include <cstdint> // uint8_t
#include <cstdio> // snprintf
#include <limits> // numeric_limits
#include <string> // string, char_traits
#include <type_traits> // is_same
#include <utility> // move

// #include <nlohmann/detail/conversions/to_chars.hpp>


#include <array> // array
#include <cmath>   // signbit, isfinite
#include <cstdint> // intN_t, uintN_t
#include <cstring> // memcpy, memmove
#include <limits> // numeric_limits
#include <type_traits> // conditional

// #include <nlohmann/detail/macro_scope.hpp>


namespace nlohmann
{
namespace detail
{

/*!
@brief implements the Grisu2 algorithm for binary to decimal floating-point
conversion.

This implementation is a slightly modified version of the reference
implementation which may be obtained from
http://florian.loitsch.com/publications (bench.tar.gz).

The code is distributed under the MIT license, Copyright (c) 2009 Florian Loitsch.

For a detailed description of the algorithm see:

[1] Loitsch, "Printing Floating-Point Numbers Quickly and Accurately with
    Integers", Proceedings of the ACM SIGPLAN 2010 Conference on Programming
    Language Design and Implementation, PLDI 2010
[2] Burger, Dybvig, "Printing Floating-Point Numbers Quickly and Accurately",
    Proceedings of the ACM SIGPLAN 1996 Conference on Programming Language
    Design and Implementation, PLDI 1996
*/
namespace dtoa_impl
{

template<typename Target, typename Source>
Target reinterpret_bits(const Source source)
{
    static_assert(sizeof(Target) == sizeof(Source), "size mismatch");

    Target target;
    std::memcpy(&target, &source, sizeof(Source));
    return target;
}

struct diyfp // f * 2^e
{
    static constexpr int kPrecision = 64; // = q

    std::uint64_t f = 0;
    int e = 0;

    constexpr diyfp(std::uint64_t f_, int e_) noexcept : f(f_), e(e_) {}

    /*!
    @brief returns x - y
    @pre x.e == y.e and x.f >= y.f
    */
    static diyfp sub(const diyfp& x, const diyfp& y) noexcept
    {
        JSON_ASSERT(x.e == y.e);
        JSON_ASSERT(x.f >= y.f);

        return {x.f - y.f, x.e};
    }

    /*!
    @brief returns x * y
    @note The result is rounded. (Only the upper q bits are returned.)
    */
    static diyfp mul(const diyfp& x, const diyfp& y) noexcept
    {
        static_assert(kPrecision == 64, "internal error");

        // Computes:
        //  f = round((x.f * y.f) / 2^q)
        //  e = x.e + y.e + q

        // Emulate the 64-bit * 64-bit multiplication:
        //
        // p = u * v
        //   = (u_lo + 2^32 u_hi) (v_lo + 2^32 v_hi)
        //   = (u_lo v_lo         ) + 2^32 ((u_lo v_hi         ) + (u_hi v_lo         )) + 2^64 (u_hi v_hi         )
        //   = (p0                ) + 2^32 ((p1                ) + (p2                )) + 2^64 (p3                )
        //   = (p0_lo + 2^32 p0_hi) + 2^32 ((p1_lo + 2^32 p1_hi) + (p2_lo + 2^32 p2_hi)) + 2^64 (p3                )
        //   = (p0_lo             ) + 2^32 (p0_hi + p1_lo + p2_lo                      ) + 2^64 (p1_hi + p2_hi + p3)
        //   = (p0_lo             ) + 2^32 (Q                                          ) + 2^64 (H                 )
        //   = (p0_lo             ) + 2^32 (Q_lo + 2^32 Q_hi                           ) + 2^64 (H                 )
        //
        // (Since Q might be larger than 2^32 - 1)
        //
        //   = (p0_lo + 2^32 Q_lo) + 2^64 (Q_hi + H)
        //
        // (Q_hi + H does not overflow a 64-bit int)
        //
        //   = p_lo + 2^64 p_hi

        const std::uint64_t u_lo = x.f & 0xFFFFFFFFu;
        const std::uint64_t u_hi = x.f >> 32u;
        const std::uint64_t v_lo = y.f & 0xFFFFFFFFu;
        const std::uint64_t v_hi = y.f >> 32u;

        const std::uint64_t p0 = u_lo * v_lo;
        const std::uint64_t p1 = u_lo * v_hi;
        const std::uint64_t p2 = u_hi * v_lo;
        const std::uint64_t p3 = u_hi * v_hi;

        const std::uint64_t p0_hi = p0 >> 32u;
        const std::uint64_t p1_lo = p1 & 0xFFFFFFFFu;
        const std::uint64_t p1_hi = p1 >> 32u;
        const std::uint64_t p2_lo = p2 & 0xFFFFFFFFu;
        const std::uint64_t p2_hi = p2 >> 32u;

        std::uint64_t Q = p0_hi + p1_lo + p2_lo;

        // The full product might now be computed as
        //
        // p_hi = p3 + p2_hi + p1_hi + (Q >> 32)
        // p_lo = p0_lo + (Q << 32)
        //
        // But in this particular case here, the full p_lo is not required.
        // Effectively we only need to add the highest bit in p_lo to p_hi (and
        // Q_hi + 1 does not overflow).

        Q += std::uint64_t{1} << (64u - 32u - 1u); // round, ties up

        const std::uint64_t h = p3 + p2_hi + p1_hi + (Q >> 32u);

        return {h, x.e + y.e + 64};
    }

    /*!
    @brief normalize x such that the significand is >= 2^(q-1)
    @pre x.f != 0
    */
    static diyfp normalize(diyfp x) noexcept
    {
        JSON_ASSERT(x.f != 0);

        while ((x.f >> 63u) == 0)
        {
            x.f <<= 1u;
            x.e--;
        }

        return x;
    }

    /*!
    @brief normalize x such that the result has the exponent E
    @pre e >= x.e and the upper e - x.e bits of x.f must be zero.
    */
    static diyfp normalize_to(const diyfp& x, const int target_exponent) noexcept
    {
        const int delta = x.e - target_exponent;

        JSON_ASSERT(delta >= 0);
        JSON_ASSERT(((x.f << delta) >> delta) == x.f);

        return {x.f << delta, target_exponent};
    }
};

struct boundaries
{
    diyfp w;
    diyfp minus;
    diyfp plus;
};

/*!
Compute the (normalized) diyfp representing the input number 'value' and its
boundaries.

@pre value must be finite and positive
*/
template<typename FloatType>
boundaries compute_boundaries(FloatType value)
{
    JSON_ASSERT(std::isfinite(value));
    JSON_ASSERT(value > 0);

    // Convert the IEEE representation into a diyfp.
    //
    // If v is denormal:
    //      value = 0.F * 2^(1 - bias) = (          F) * 2^(1 - bias - (p-1))
    // If v is normalized:
    //      value = 1.F * 2^(E - bias) = (2^(p-1) + F) * 2^(E - bias - (p-1))

    static_assert(std::numeric_limits<FloatType>::is_iec559,
                  "internal error: dtoa_short requires an IEEE-754 floating-point implementation");

    constexpr int      kPrecision = std::numeric_limits<FloatType>::digits; // = p (includes the hidden bit)
    constexpr int      kBias      = std::numeric_limits<FloatType>::max_exponent - 1 + (kPrecision - 1);
    constexpr int      kMinExp    = 1 - kBias;
    constexpr std::uint64_t kHiddenBit = std::uint64_t{1} << (kPrecision - 1); // = 2^(p-1)

    using bits_type = typename std::conditional<kPrecision == 24, std::uint32_t, std::uint64_t >::type;

    const std::uint64_t bits = reinterpret_bits<bits_type>(value);
    const std::uint64_t E = bits >> (kPrecision - 1);
    const std::uint64_t F = bits & (kHiddenBit - 1);

    const bool is_denormal = E == 0;
    const diyfp v = is_denormal
                    ? diyfp(F, kMinExp)
                    : diyfp(F + kHiddenBit, static_cast<int>(E) - kBias);

    // Compute the boundaries m- and m+ of the floating-point value
    // v = f * 2^e.
    //
    // Determine v- and v+, the floating-point predecessor and successor if v,
    // respectively.
    //
    //      v- = v - 2^e        if f != 2^(p-1) or e == e_min                (A)
    //         = v - 2^(e-1)    if f == 2^(p-1) and e > e_min                (B)
    //
    //      v+ = v + 2^e
    //
    // Let m- = (v- + v) / 2 and m+ = (v + v+) / 2. All real numbers _strictly_
    // between m- and m+ round to v, regardless of how the input rounding
    // algorithm breaks ties.
    //
    //      ---+-------------+-------------+-------------+-------------+---  (A)
    //         v-            m-            v             m+            v+
    //
    //      -----------------+------+------+-------------+-------------+---  (B)
    //                       v-     m-     v             m+            v+

    const bool lower_boundary_is_closer = F == 0 && E > 1;
    const diyfp m_plus = diyfp(2 * v.f + 1, v.e - 1);
    const diyfp m_minus = lower_boundary_is_closer
                          ? diyfp(4 * v.f - 1, v.e - 2)  // (B)
                          : diyfp(2 * v.f - 1, v.e - 1); // (A)

    // Determine the normalized w+ = m+.
    const diyfp w_plus = diyfp::normalize(m_plus);

    // Determine w- = m- such that e_(w-) = e_(w+).
    const diyfp w_minus = diyfp::normalize_to(m_minus, w_plus.e);

    return {diyfp::normalize(v), w_minus, w_plus};
}

// Given normalized diyfp w, Grisu needs to find a (normalized) cached
// power-of-ten c, such that the exponent of the product c * w = f * 2^e lies
// within a certain range [alpha, gamma] (Definition 3.2 from [1])
//
//      alpha <= e = e_c + e_w + q <= gamma
//
// or
//
//      f_c * f_w * 2^alpha <= f_c 2^(e_c) * f_w 2^(e_w) * 2^q
//                          <= f_c * f_w * 2^gamma
//
// Since c and w are normalized, i.e. 2^(q-1) <= f < 2^q, this implies
//
//      2^(q-1) * 2^(q-1) * 2^alpha <= c * w * 2^q < 2^q * 2^q * 2^gamma
//
// or
//
//      2^(q - 2 + alpha) <= c * w < 2^(q + gamma)
//
// The choice of (alpha,gamma) determines the size of the table and the form of
// the digit generation procedure. Using (alpha,gamma)=(-60,-32) works out well
// in practice:
//
// The idea is to cut the number c * w = f * 2^e into two parts, which can be
// processed independently: An integral part p1, and a fractional part p2:
//
//      f * 2^e = ( (f div 2^-e) * 2^-e + (f mod 2^-e) ) * 2^e
//              = (f div 2^-e) + (f mod 2^-e) * 2^e
//              = p1 + p2 * 2^e
//
// The conversion of p1 into decimal form requires a series of divisions and
// modulos by (a power of) 10. These operations are faster for 32-bit than for
// 64-bit integers, so p1 should ideally fit into a 32-bit integer. This can be
// achieved by choosing
//
//      -e >= 32   or   e <= -32 := gamma
//
// In order to convert the fractional part
//
//      p2 * 2^e = p2 / 2^-e = d[-1] / 10^1 + d[-2] / 10^2 + ...
//
// into decimal form, the fraction is repeatedly multiplied by 10 and the digits
// d[-i] are extracted in order:
//
//      (10 * p2) div 2^-e = d[-1]
//      (10 * p2) mod 2^-e = d[-2] / 10^1 + ...
//
// The multiplication by 10 must not overflow. It is sufficient to choose
//
//      10 * p2 < 16 * p2 = 2^4 * p2 <= 2^64.
//
// Since p2 = f mod 2^-e < 2^-e,
//
//      -e <= 60   or   e >= -60 := alpha

constexpr int kAlpha = -60;
constexpr int kGamma = -32;

struct cached_power // c = f * 2^e ~= 10^k
{
    std::uint64_t f;
    int e;
    int k;
};

/*!
For a normalized diyfp w = f * 2^e, this function returns a (normalized) cached
power-of-ten c = f_c * 2^e_c, such that the exponent of the product w * c
satisfies (Definition 3.2 from [1])

     alpha <= e_c + e + q <= gamma.
*/
inline cached_power get_cached_power_for_binary_exponent(int e)
{
    // Now
    //
    //      alpha <= e_c + e + q <= gamma                                    (1)
    //      ==> f_c * 2^alpha <= c * 2^e * 2^q
    //
    // and since the c's are normalized, 2^(q-1) <= f_c,
    //
    //      ==> 2^(q - 1 + alpha) <= c * 2^(e + q)
    //      ==> 2^(alpha - e - 1) <= c
    //
    // If c were an exact power of ten, i.e. c = 10^k, one may determine k as
    //
    //      k = ceil( log_10( 2^(alpha - e - 1) ) )
    //        = ceil( (alpha - e - 1) * log_10(2) )
    //
    // From the paper:
    // "In theory the result of the procedure could be wrong since c is rounded,
    //  and the computation itself is approximated [...]. In practice, however,
    //  this simple function is sufficient."
    //
    // For IEEE double precision floating-point numbers converted into
    // normalized diyfp's w = f * 2^e, with q = 64,
    //
    //      e >= -1022      (min IEEE exponent)
    //           -52        (p - 1)
    //           -52        (p - 1, possibly normalize denormal IEEE numbers)
    //           -11        (normalize the diyfp)
    //         = -1137
    //
    // and
    //
    //      e <= +1023      (max IEEE exponent)
    //           -52        (p - 1)
    //           -11        (normalize the diyfp)
    //         = 960
    //
    // This binary exponent range [-1137,960] results in a decimal exponent
    // range [-307,324]. One does not need to store a cached power for each
    // k in this range. For each such k it suffices to find a cached power
    // such that the exponent of the product lies in [alpha,gamma].
    // This implies that the difference of the decimal exponents of adjacent
    // table entries must be less than or equal to
    //
    //      floor( (gamma - alpha) * log_10(2) ) = 8.
    //
    // (A smaller distance gamma-alpha would require a larger table.)

    // NB:
    // Actually this function returns c, such that -60 <= e_c + e + 64 <= -34.

    constexpr int kCachedPowersMinDecExp = -300;
    constexpr int kCachedPowersDecStep = 8;

    static constexpr std::array<cached_power, 79> kCachedPowers =
    {
        {
            { 0xAB70FE17C79AC6CA, -1060, -300 },
            { 0xFF77B1FCBEBCDC4F, -1034, -292 },
            { 0xBE5691EF416BD60C, -1007, -284 },
            { 0x8DD01FAD907FFC3C,  -980, -276 },
            { 0xD3515C2831559A83,  -954, -268 },
            { 0x9D71AC8FADA6C9B5,  -927, -260 },
            { 0xEA9C227723EE8BCB,  -901, -252 },
            { 0xAECC49914078536D,  -874, -244 },
            { 0x823C12795DB6CE57,  -847, -236 },
            { 0xC21094364DFB5637,  -821, -228 },
            { 0x9096EA6F3848984F,  -794, -220 },
            { 0xD77485CB25823AC7,  -768, -212 },
            { 0xA086CFCD97BF97F4,  -741, -204 },
            { 0xEF340A98172AACE5,  -715, -196 },
            { 0xB23867FB2A35B28E,  -688, -188 },
            { 0x84C8D4DFD2C63F3B,  -661, -180 },
            { 0xC5DD44271AD3CDBA,  -635, -172 },
            { 0x936B9FCEBB25C996,  -608, -164 },
            { 0xDBAC6C247D62A584,  -582, -156 },
            { 0xA3AB66580D5FDAF6,  -555, -148 },
            { 0xF3E2F893DEC3F126,  -529, -140 },
            { 0xB5B5ADA8AAFF80B8,  -502, -132 },
            { 0x87625F056C7C4A8B,  -475, -124 },
            { 0xC9BCFF6034C13053,  -449, -116 },
            { 0x964E858C91BA2655,  -422, -108 },
            { 0xDFF9772470297EBD,  -396, -100 },
            { 0xA6DFBD9FB8E5B88F,  -369,  -92 },
            { 0xF8A95FCF88747D94,  -343,  -84 },
            { 0xB94470938FA89BCF,  -316,  -76 },
            { 0x8A08F0F8BF0F156B,  -289,  -68 },
            { 0xCDB02555653131B6,  -263,  -60 },
            { 0x993FE2C6D07B7FAC,  -236,  -52 },
            { 0xE45C10C42A2B3B06,  -210,  -44 },
            { 0xAA242499697392D3,  -183,  -36 },
            { 0xFD87B5F28300CA0E,  -157,  -28 },
            { 0xBCE5086492111AEB,  -130,  -20 },
            { 0x8CBCCC096F5088CC,  -103,  -12 },
            { 0xD1B71758E219652C,   -77,   -4 },
            { 0x9C40000000000000,   -50,    4 },
            { 0xE8D4A51000000000,   -24,   12 },
            { 0xAD78EBC5AC620000,     3,   20 },
            { 0x813F3978F8940984,    30,   28 },
            { 0xC097CE7BC90715B3,    56,   36 },
            { 0x8F7E32CE7BEA5C70,    83,   44 },
            { 0xD5D238A4ABE98068,   109,   52 },
            { 0x9F4F2726179A2245,   136,   60 },
            { 0xED63A231D4C4FB27,   162,   68 },
            { 0xB0DE65388CC8ADA8,   189,   76 },
            { 0x83C7088E1AAB65DB,   216,   84 },
            { 0xC45D1DF942711D9A,   242,   92 },
            { 0x924D692CA61BE758,   269,  100 },
            { 0xDA01EE641A708DEA,   295,  108 },
            { 0xA26DA3999AEF774A,   322,  116 },
            { 0xF209787BB47D6B85,   348,  124 },
            { 0xB454E4A179DD1877,   375,  132 },
            { 0x865B86925B9BC5C2,   402,  140 },
            { 0xC83553C5C8965D3D,   428,  148 },
            { 0x952AB45CFA97A0B3,   455,  156 },
            { 0xDE469FBD99A05FE3,   481,  164 },
            { 0xA59BC234DB398C25,   508,  172 },
            { 0xF6C69A72A3989F5C,   534,  180 },
            { 0xB7DCBF5354E9BECE,   561,  188 },
            { 0x88FCF317F22241E2,   588,  196 },
            { 0xCC20CE9BD35C78A5,   614,  204 },
            { 0x98165AF37B2153DF,   641,  212 },
            { 0xE2A0B5DC971F303A,   667,  220 },
            { 0xA8D9D1535CE3B396,   694,  228 },
            { 0xFB9B7CD9A4A7443C,   720,  236 },
            { 0xBB764C4CA7A44410,   747,  244 },
            { 0x8BAB8EEFB6409C1A,   774,  252 },
            { 0xD01FEF10A657842C,   800,  260 },
            { 0x9B10A4E5E9913129,   827,  268 },
            { 0xE7109BFBA19C0C9D,   853,  276 },
            { 0xAC2820D9623BF429,   880,  284 },
            { 0x80444B5E7AA7CF85,   907,  292 },
            { 0xBF21E44003ACDD2D,   933,  300 },
            { 0x8E679C2F5E44FF8F,   960,  308 },
            { 0xD433179D9C8CB841,   986,  316 },
            { 0x9E19DB92B4E31BA9,  1013,  324 },
        }
    };

    // This computation gives exactly the same results for k as
    //      k = ceil((kAlpha - e - 1) * 0.30102999566398114)
    // for |e| <= 1500, but doesn't require floating-point operations.
    // NB: log_10(2) ~= 78913 / 2^18
    JSON_ASSERT(e >= -1500);
    JSON_ASSERT(e <=  1500);
    const int f = kAlpha - e - 1;
    const int k = (f * 78913) / (1 << 18) + static_cast<int>(f > 0);

    const int index = (-kCachedPowersMinDecExp + k + (kCachedPowersDecStep - 1)) / kCachedPowersDecStep;
    JSON_ASSERT(index >= 0);
    JSON_ASSERT(static_cast<std::size_t>(index) < kCachedPowers.size());

    const cached_power cached = kCachedPowers[static_cast<std::size_t>(index)];
    JSON_ASSERT(kAlpha <= cached.e + e + 64);
    JSON_ASSERT(kGamma >= cached.e + e + 64);

    return cached;
}

/*!
For n != 0, returns k, such that pow10 := 10^(k-1) <= n < 10^k.
For n == 0, returns 1 and sets pow10 := 1.
*/
inline int find_largest_pow10(const std::uint32_t n, std::uint32_t& pow10)
{
    // LCOV_EXCL_START
    if (n >= 1000000000)
    {
        pow10 = 1000000000;
        return 10;
    }
    // LCOV_EXCL_STOP
    else if (n >= 100000000)
    {
        pow10 = 100000000;
        return  9;
    }
    else if (n >= 10000000)
    {
        pow10 = 10000000;
        return  8;
    }
    else if (n >= 1000000)
    {
        pow10 = 1000000;
        return  7;
    }
    else if (n >= 100000)
    {
        pow10 = 100000;
        return  6;
    }
    else if (n >= 10000)
    {
        pow10 = 10000;
        return  5;
    }
    else if (n >= 1000)
    {
        pow10 = 1000;
        return  4;
    }
    else if (n >= 100)
    {
        pow10 = 100;
        return  3;
    }
    else if (n >= 10)
    {
        pow10 = 10;
        return  2;
    }
    else
    {
        pow10 = 1;
        return 1;
    }
}

inline void grisu2_round(char* buf, int len, std::uint64_t dist, std::uint64_t delta,
                         std::uint64_t rest, std::uint64_t ten_k)
{
    JSON_ASSERT(len >= 1);
    JSON_ASSERT(dist <= delta);
    JSON_ASSERT(rest <= delta);
    JSON_ASSERT(ten_k > 0);

    //               <--------------------------- delta ---->
    //                                  <---- dist --------->
    // --------------[------------------+-------------------]--------------
    //               M-                 w                   M+
    //
    //                                  ten_k
    //                                <------>
    //                                       <---- rest ---->
    // --------------[------------------+----+--------------]--------------
    //                                  w    V
    //                                       = buf * 10^k
    //
    // ten_k represents a unit-in-the-last-place in the decimal representation
    // stored in buf.
    // Decrement buf by ten_k while this takes buf closer to w.

    // The tests are written in this order to avoid overflow in unsigned
    // integer arithmetic.

    while (rest < dist
            && delta - rest >= ten_k
            && (rest + ten_k < dist || dist - rest > rest + ten_k - dist))
    {
        JSON_ASSERT(buf[len - 1] != '0');
        buf[len - 1]--;
        rest += ten_k;
    }
}

/*!
Generates V = buffer * 10^decimal_exponent, such that M- <= V <= M+.
M- and M+ must be normalized and share the same exponent -60 <= e <= -32.
*/
inline void grisu2_digit_gen(char* buffer, int& length, int& decimal_exponent,
                             diyfp M_minus, diyfp w, diyfp M_plus)
{
    static_assert(kAlpha >= -60, "internal error");
    static_assert(kGamma <= -32, "internal error");

    // Generates the digits (and the exponent) of a decimal floating-point
    // number V = buffer * 10^decimal_exponent in the range [M-, M+]. The diyfp's
    // w, M- and M+ share the same exponent e, which satisfies alpha <= e <= gamma.
    //
    //               <--------------------------- delta ---->
    //                                  <---- dist --------->
    // --------------[------------------+-------------------]--------------
    //               M-                 w                   M+
    //
    // Grisu2 generates the digits of M+ from left to right and stops as soon as
    // V is in [M-,M+].

    JSON_ASSERT(M_plus.e >= kAlpha);
    JSON_ASSERT(M_plus.e <= kGamma);

    std::uint64_t delta = diyfp::sub(M_plus, M_minus).f; // (significand of (M+ - M-), implicit exponent is e)
    std::uint64_t dist  = diyfp::sub(M_plus, w      ).f; // (significand of (M+ - w ), implicit exponent is e)

    // Split M+ = f * 2^e into two parts p1 and p2 (note: e < 0):
    //
    //      M+ = f * 2^e
    //         = ((f div 2^-e) * 2^-e + (f mod 2^-e)) * 2^e
    //         = ((p1        ) * 2^-e + (p2        )) * 2^e
    //         = p1 + p2 * 2^e

    const diyfp one(std::uint64_t{1} << -M_plus.e, M_plus.e);

    auto p1 = static_cast<std::uint32_t>(M_plus.f >> -one.e); // p1 = f div 2^-e (Since -e >= 32, p1 fits into a 32-bit int.)
    std::uint64_t p2 = M_plus.f & (one.f - 1);                    // p2 = f mod 2^-e

    // 1)
    //
    // Generate the digits of the integral part p1 = d[n-1]...d[1]d[0]

    JSON_ASSERT(p1 > 0);

    std::uint32_t pow10;
    const int k = find_largest_pow10(p1, pow10);

    //      10^(k-1) <= p1 < 10^k, pow10 = 10^(k-1)
    //
    //      p1 = (p1 div 10^(k-1)) * 10^(k-1) + (p1 mod 10^(k-1))
    //         = (d[k-1]         ) * 10^(k-1) + (p1 mod 10^(k-1))
    //
    //      M+ = p1                                             + p2 * 2^e
    //         = d[k-1] * 10^(k-1) + (p1 mod 10^(k-1))          + p2 * 2^e
    //         = d[k-1] * 10^(k-1) + ((p1 mod 10^(k-1)) * 2^-e + p2) * 2^e
    //         = d[k-1] * 10^(k-1) + (                         rest) * 2^e
    //
    // Now generate the digits d[n] of p1 from left to right (n = k-1,...,0)
    //
    //      p1 = d[k-1]...d[n] * 10^n + d[n-1]...d[0]
    //
    // but stop as soon as
    //
    //      rest * 2^e = (d[n-1]...d[0] * 2^-e + p2) * 2^e <= delta * 2^e

    int n = k;
    while (n > 0)
    {
        // Invariants:
        //      M+ = buffer * 10^n + (p1 + p2 * 2^e)    (buffer = 0 for n = k)
        //      pow10 = 10^(n-1) <= p1 < 10^n
        //
        const std::uint32_t d = p1 / pow10;  // d = p1 div 10^(n-1)
        const std::uint32_t r = p1 % pow10;  // r = p1 mod 10^(n-1)
        //
        //      M+ = buffer * 10^n + (d * 10^(n-1) + r) + p2 * 2^e
        //         = (buffer * 10 + d) * 10^(n-1) + (r + p2 * 2^e)
        //
        JSON_ASSERT(d <= 9);
        buffer[length++] = static_cast<char>('0' + d); // buffer := buffer * 10 + d
        //
        //      M+ = buffer * 10^(n-1) + (r + p2 * 2^e)
        //
        p1 = r;
        n--;
        //
        //      M+ = buffer * 10^n + (p1 + p2 * 2^e)
        //      pow10 = 10^n
        //

        // Now check if enough digits have been generated.
        // Compute
        //
        //      p1 + p2 * 2^e = (p1 * 2^-e + p2) * 2^e = rest * 2^e
        //
        // Note:
        // Since rest and delta share the same exponent e, it suffices to
        // compare the significands.
        const std::uint64_t rest = (std::uint64_t{p1} << -one.e) + p2;
        if (rest <= delta)
        {
            // V = buffer * 10^n, with M- <= V <= M+.

            decimal_exponent += n;

            // We may now just stop. But instead look if the buffer could be
            // decremented to bring V closer to w.
            //
            // pow10 = 10^n is now 1 ulp in the decimal representation V.
            // The rounding procedure works with diyfp's with an implicit
            // exponent of e.
            //
            //      10^n = (10^n * 2^-e) * 2^e = ulp * 2^e
            //
            const std::uint64_t ten_n = std::uint64_t{pow10} << -one.e;
            grisu2_round(buffer, length, dist, delta, rest, ten_n);

            return;
        }

        pow10 /= 10;
        //
        //      pow10 = 10^(n-1) <= p1 < 10^n
        // Invariants restored.
    }

    // 2)
    //
    // The digits of the integral part have been generated:
    //
    //      M+ = d[k-1]...d[1]d[0] + p2 * 2^e
    //         = buffer            + p2 * 2^e
    //
    // Now generate the digits of the fractional part p2 * 2^e.
    //
    // Note:
    // No decimal point is generated: the exponent is adjusted instead.
    //
    // p2 actually represents the fraction
    //
    //      p2 * 2^e
    //          = p2 / 2^-e
    //          = d[-1] / 10^1 + d[-2] / 10^2 + ...
    //
    // Now generate the digits d[-m] of p1 from left to right (m = 1,2,...)
    //
    //      p2 * 2^e = d[-1]d[-2]...d[-m] * 10^-m
    //                      + 10^-m * (d[-m-1] / 10^1 + d[-m-2] / 10^2 + ...)
    //
    // using
    //
    //      10^m * p2 = ((10^m * p2) div 2^-e) * 2^-e + ((10^m * p2) mod 2^-e)
    //                = (                   d) * 2^-e + (                   r)
    //
    // or
    //      10^m * p2 * 2^e = d + r * 2^e
    //
    // i.e.
    //
    //      M+ = buffer + p2 * 2^e
    //         = buffer + 10^-m * (d + r * 2^e)
    //         = (buffer * 10^m + d) * 10^-m + 10^-m * r * 2^e
    //
    // and stop as soon as 10^-m * r * 2^e <= delta * 2^e

    JSON_ASSERT(p2 > delta);

    int m = 0;
    for (;;)
    {
        // Invariant:
        //      M+ = buffer * 10^-m + 10^-m * (d[-m-1] / 10 + d[-m-2] / 10^2 + ...) * 2^e
        //         = buffer * 10^-m + 10^-m * (p2                                 ) * 2^e
        //         = buffer * 10^-m + 10^-m * (1/10 * (10 * p2)                   ) * 2^e
        //         = buffer * 10^-m + 10^-m * (1/10 * ((10*p2 div 2^-e) * 2^-e + (10*p2 mod 2^-e)) * 2^e
        //
        JSON_ASSERT(p2 <= (std::numeric_limits<std::uint64_t>::max)() / 10);
        p2 *= 10;
        const std::uint64_t d = p2 >> -one.e;     // d = (10 * p2) div 2^-e
        const std::uint64_t r = p2 & (one.f - 1); // r = (10 * p2) mod 2^-e
        //
        //      M+ = buffer * 10^-m + 10^-m * (1/10 * (d * 2^-e + r) * 2^e
        //         = buffer * 10^-m + 10^-m * (1/10 * (d + r * 2^e))
        //         = (buffer * 10 + d) * 10^(-m-1) + 10^(-m-1) * r * 2^e
        //
        JSON_ASSERT(d <= 9);
        buffer[length++] = static_cast<char>('0' + d); // buffer := buffer * 10 + d
        //
        //      M+ = buffer * 10^(-m-1) + 10^(-m-1) * r * 2^e
        //
        p2 = r;
        m++;
        //
        //      M+ = buffer * 10^-m + 10^-m * p2 * 2^e
        // Invariant restored.

        // Check if enough digits have been generated.
        //
        //      10^-m * p2 * 2^e <= delta * 2^e
        //              p2 * 2^e <= 10^m * delta * 2^e
        //                    p2 <= 10^m * delta
        delta *= 10;
        dist  *= 10;
        if (p2 <= delta)
        {
            break;
        }
    }

    // V = buffer * 10^-m, with M- <= V <= M+.

    decimal_exponent -= m;

    // 1 ulp in the decimal representation is now 10^-m.
    // Since delta and dist are now scaled by 10^m, we need to do the
    // same with ulp in order to keep the units in sync.
    //
    //      10^m * 10^-m = 1 = 2^-e * 2^e = ten_m * 2^e
    //
    const std::uint64_t ten_m = one.f;
    grisu2_round(buffer, length, dist, delta, p2, ten_m);

    // By construction this algorithm generates the shortest possible decimal
    // number (Loitsch, Theorem 6.2) which rounds back to w.
    // For an input number of precision p, at least
    //
    //      N = 1 + ceil(p * log_10(2))
    //
    // decimal digits are sufficient to identify all binary floating-point
    // numbers (Matula, "In-and-Out conversions").
    // This implies that the algorithm does not produce more than N decimal
    // digits.
    //
    //      N = 17 for p = 53 (IEEE double precision)
    //      N = 9  for p = 24 (IEEE single precision)
}

/*!
v = buf * 10^decimal_exponent
len is the length of the buffer (number of decimal digits)
The buffer must be large enough, i.e. >= max_digits10.
*/
JSON_HEDLEY_NON_NULL(1)
inline void grisu2(char* buf, int& len, int& decimal_exponent,
                   diyfp m_minus, diyfp v, diyfp m_plus)
{
    JSON_ASSERT(m_plus.e == m_minus.e);
    JSON_ASSERT(m_plus.e == v.e);

    //  --------(-----------------------+-----------------------)--------    (A)
    //          m-                      v                       m+
    //
    //  --------------------(-----------+-----------------------)--------    (B)
    //                      m-          v                       m+
    //
    // First scale v (and m- and m+) such that the exponent is in the range
    // [alpha, gamma].

    const cached_power cached = get_cached_power_for_binary_exponent(m_plus.e);

    const diyfp c_minus_k(cached.f, cached.e); // = c ~= 10^-k

    // The exponent of the products is = v.e + c_minus_k.e + q and is in the range [alpha,gamma]
    const diyfp w       = diyfp::mul(v,       c_minus_k);
    const diyfp w_minus = diyfp::mul(m_minus, c_minus_k);
    const diyfp w_plus  = diyfp::mul(m_plus,  c_minus_k);

    //  ----(---+---)---------------(---+---)---------------(---+---)----
    //          w-                      w                       w+
    //          = c*m-                  = c*v                   = c*m+
    //
    // diyfp::mul rounds its result and c_minus_k is approximated too. w, w- and
    // w+ are now off by a small amount.
    // In fact:
    //
    //      w - v * 10^k < 1 ulp
    //
    // To account for this inaccuracy, add resp. subtract 1 ulp.
    //
    //  --------+---[---------------(---+---)---------------]---+--------
    //          w-  M-                  w                   M+  w+
    //
    // Now any number in [M-, M+] (bounds included) will round to w when input,
    // regardless of how the input rounding algorithm breaks ties.
    //
    // And digit_gen generates the shortest possible such number in [M-, M+].
    // Note that this does not mean that Grisu2 always generates the shortest
    // possible number in the interval (m-, m+).
    const diyfp M_minus(w_minus.f + 1, w_minus.e);
    const diyfp M_plus (w_plus.f  - 1, w_plus.e );

    decimal_exponent = -cached.k; // = -(-k) = k

    grisu2_digit_gen(buf, len, decimal_exponent, M_minus, w, M_plus);
}

/*!
v = buf * 10^decimal_exponent
len is the length of the buffer (number of decimal digits)
The buffer must be large enough, i.e. >= max_digits10.
*/
template<typename FloatType>
JSON_HEDLEY_NON_NULL(1)
void grisu2(char* buf, int& len, int& decimal_exponent, FloatType value)
{
    static_assert(diyfp::kPrecision >= std::numeric_limits<FloatType>::digits + 3,
                  "internal error: not enough precision");

    JSON_ASSERT(std::isfinite(value));
    JSON_ASSERT(value > 0);

    // If the neighbors (and boundaries) of 'value' are always computed for double-precision
    // numbers, all float's can be recovered using strtod (and strtof). However, the resulting
    // decimal representations are not exactly "short".
    //
    // The documentation for 'std::to_chars' (https://en.cppreference.com/w/cpp/utility/to_chars)
    // says "value is converted to a string as if by std::sprintf in the default ("C") locale"
    // and since sprintf promotes float's to double's, I think this is exactly what 'std::to_chars'
    // does.
    // On the other hand, the documentation for 'std::to_chars' requires that "parsing the
    // representation using the corresponding std::from_chars function recovers value exactly". That
    // indicates that single precision floating-point numbers should be recovered using
    // 'std::strtof'.
    //
    // NB: If the neighbors are computed for single-precision numbers, there is a single float
    //     (7.0385307e-26f) which can't be recovered using strtod. The resulting double precision
    //     value is off by 1 ulp.
#if 0
    const boundaries w = compute_boundaries(static_cast<double>(value));
#else
    const boundaries w = compute_boundaries(value);
#endif

    grisu2(buf, len, decimal_exponent, w.minus, w.w, w.plus);
}

/*!
@brief appends a decimal representation of e to buf
@return a pointer to the element following the exponent.
@pre -1000 < e < 1000
*/
JSON_HEDLEY_NON_NULL(1)
JSON_HEDLEY_RETURNS_NON_NULL
inline char* append_exponent(char* buf, int e)
{
    JSON_ASSERT(e > -1000);
    JSON_ASSERT(e <  1000);

    if (e < 0)
    {
        e = -e;
        *buf++ = '-';
    }
    else
    {
        *buf++ = '+';
    }

    auto k = static_cast<std::uint32_t>(e);
    if (k < 10)
    {
        // Always print at least two digits in the exponent.
        // This is for compatibility with printf("%g").
        *buf++ = '0';
        *buf++ = static_cast<char>('0' + k);
    }
    else if (k < 100)
    {
        *buf++ = static_cast<char>('0' + k / 10);
        k %= 10;
        *buf++ = static_cast<char>('0' + k);
    }
    else
    {
        *buf++ = static_cast<char>('0' + k / 100);
        k %= 100;
        *buf++ = static_cast<char>('0' + k / 10);
        k %= 10;
        *buf++ = static_cast<char>('0' + k);
    }

    return buf;
}

/*!
@brief prettify v = buf * 10^decimal_exponent

If v is in the range [10^min_exp, 10^max_exp) it will be printed in fixed-point
notation. Otherwise it will be printed in exponential notation.

@pre min_exp < 0
@pre max_exp > 0
*/
JSON_HEDLEY_NON_NULL(1)
JSON_HEDLEY_RETURNS_NON_NULL
inline char* format_buffer(char* buf, int len, int decimal_exponent,
                           int min_exp, int max_exp)
{
    JSON_ASSERT(min_exp < 0);
    JSON_ASSERT(max_exp > 0);

    const int k = len;
    const int n = len + decimal_exponent;

    // v = buf * 10^(n-k)
    // k is the length of the buffer (number of decimal digits)
    // n is the position of the decimal point relative to the start of the buffer.

    if (k <= n && n <= max_exp)
    {
        // digits[000]
        // len <= max_exp + 2

        std::memset(buf + k, '0', static_cast<size_t>(n) - static_cast<size_t>(k));
        // Make it look like a floating-point number (#362, #378)
        buf[n + 0] = '.';
        buf[n + 1] = '0';
        return buf + (static_cast<size_t>(n) + 2);
    }

    if (0 < n && n <= max_exp)
    {
        // dig.its
        // len <= max_digits10 + 1

        JSON_ASSERT(k > n);

        std::memmove(buf + (static_cast<size_t>(n) + 1), buf + n, static_cast<size_t>(k) - static_cast<size_t>(n));
        buf[n] = '.';
        return buf + (static_cast<size_t>(k) + 1U);
    }

    if (min_exp < n && n <= 0)
    {
        // 0.[000]digits
        // len <= 2 + (-min_exp - 1) + max_digits10

        std::memmove(buf + (2 + static_cast<size_t>(-n)), buf, static_cast<size_t>(k));
        buf[0] = '0';
        buf[1] = '.';
        std::memset(buf + 2, '0', static_cast<size_t>(-n));
        return buf + (2U + static_cast<size_t>(-n) + static_cast<size_t>(k));
    }

    if (k == 1)
    {
        // dE+123
        // len <= 1 + 5

        buf += 1;
    }
    else
    {
        // d.igitsE+123
        // len <= max_digits10 + 1 + 5

        std::memmove(buf + 2, buf + 1, static_cast<size_t>(k) - 1);
        buf[1] = '.';
        buf += 1 + static_cast<size_t>(k);
    }

    *buf++ = 'e';
    return append_exponent(buf, n - 1);
}

} // namespace dtoa_impl

/*!
@brief generates a decimal representation of the floating-point number value in [first, last).

The format of the resulting decimal representation is similar to printf's %g
format. Returns an iterator pointing past-the-end of the decimal representation.

@note The input number must be finite, i.e. NaN's and Inf's are not supported.
@note The buffer must be large enough.
@note The result is NOT null-terminated.
*/
template<typename FloatType>
JSON_HEDLEY_NON_NULL(1, 2)
JSON_HEDLEY_RETURNS_NON_NULL
char* to_chars(char* first, const char* last, FloatType value)
{
    static_cast<void>(last); // maybe unused - fix warning
    JSON_ASSERT(std::isfinite(value));

    // Use signbit(value) instead of (value < 0) since signbit works for -0.
    if (std::signbit(value))
    {
        value = -value;
        *first++ = '-';
    }

    if (value == 0) // +-0
    {
        *first++ = '0';
        // Make it look like a floating-point number (#362, #378)
        *first++ = '.';
        *first++ = '0';
        return first;
    }

    JSON_ASSERT(last - first >= std::numeric_limits<FloatType>::max_digits10);

    // Compute v = buffer * 10^decimal_exponent.
    // The decimal digits are stored in the buffer, which needs to be interpreted
    // as an unsigned decimal integer.
    // len is the length of the buffer, i.e. the number of decimal digits.
    int len = 0;
    int decimal_exponent = 0;
    dtoa_impl::grisu2(first, len, decimal_exponent, value);

    JSON_ASSERT(len <= std::numeric_limits<FloatType>::max_digits10);

    // Format the buffer like printf("%.*g", prec, value)
    constexpr int kMinExp = -4;
    // Use digits10 here to increase compatibility with version 2.
    constexpr int kMaxExp = std::numeric_limits<FloatType>::digits10;

    JSON_ASSERT(last - first >= kMaxExp + 2);
    JSON_ASSERT(last - first >= 2 + (-kMinExp - 1) + std::numeric_limits<FloatType>::max_digits10);
    JSON_ASSERT(last - first >= std::numeric_limits<FloatType>::max_digits10 + 6);

    return dtoa_impl::format_buffer(first, len, decimal_exponent, kMinExp, kMaxExp);
}

} // namespace detail
} // namespace nlohmann

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/output/binary_writer.hpp>

// #include <nlohmann/detail/output/output_adapters.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
namespace detail
{
///////////////////
// serialization //
///////////////////

/// how to treat decoding errors
enum class error_handler_t
{
    strict,  ///< throw a type_error exception in case of invalid UTF-8
    replace, ///< replace invalid UTF-8 sequences with U+FFFD
    ignore   ///< ignore invalid UTF-8 sequences
};

template<typename BasicJsonType>
class serializer
{
    using string_t = typename BasicJsonType::string_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using binary_char_t = typename BasicJsonType::binary_t::value_type;
    static constexpr std::uint8_t UTF8_ACCEPT = 0;
    static constexpr std::uint8_t UTF8_REJECT = 1;

  public:
    /*!
    @param[in] s  output stream to serialize to
    @param[in] ichar  indentation character to use
    @param[in] error_handler_  how to react on decoding errors
    */
    serializer(output_adapter_t<char> s, const char ichar,
               error_handler_t error_handler_ = error_handler_t::strict)
        : o(std::move(s))
        , loc(std::localeconv())
        , thousands_sep(loc->thousands_sep == nullptr ? '\0' : std::char_traits<char>::to_char_type(* (loc->thousands_sep)))
        , decimal_point(loc->decimal_point == nullptr ? '\0' : std::char_traits<char>::to_char_type(* (loc->decimal_point)))
        , indent_char(ichar)
        , indent_string(512, indent_char)
        , error_handler(error_handler_)
    {}

    // delete because of pointer members
    serializer(const serializer&) = delete;
    serializer& operator=(const serializer&) = delete;
    serializer(serializer&&) = delete;
    serializer& operator=(serializer&&) = delete;
    ~serializer() = default;

    /*!
    @brief internal implementation of the serialization function

    This function is called by the public member function dump and organizes
    the serialization internally. The indentation level is propagated as
    additional parameter. In case of arrays and objects, the function is
    called recursively.

    - strings and object keys are escaped using `escape_string()`
    - integer numbers are converted implicitly via `operator<<`
    - floating-point numbers are converted to a string using `"%g"` format
    - binary values are serialized as objects containing the subtype and the
      byte array

    @param[in] val               value to serialize
    @param[in] pretty_print      whether the output shall be pretty-printed
    @param[in] ensure_ascii If @a ensure_ascii is true, all non-ASCII characters
    in the output are escaped with `\uXXXX` sequences, and the result consists
    of ASCII characters only.
    @param[in] indent_step       the indent level
    @param[in] current_indent    the current indent level (only used internally)
    */
    void dump(const BasicJsonType& val,
              const bool pretty_print,
              const bool ensure_ascii,
              const unsigned int indent_step,
              const unsigned int current_indent = 0)
    {
        switch (val.m_type)
        {
            case value_t::object:
            {
                if (val.m_value.object->empty())
                {
                    o->write_characters("{}", 2);
                    return;
                }

                if (pretty_print)
                {
                    o->write_characters("{\n", 2);

                    // variable to hold indentation for recursive calls
                    const auto new_indent = current_indent + indent_step;
                    if (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))
                    {
                        indent_string.resize(indent_string.size() * 2, ' ');
                    }

                    // first n-1 elements
                    auto i = val.m_value.object->cbegin();
                    for (std::size_t cnt = 0; cnt < val.m_value.object->size() - 1; ++cnt, ++i)
                    {
                        o->write_characters(indent_string.c_str(), new_indent);
                        o->write_character('\"');
                        dump_escaped(i->first, ensure_ascii);
                        o->write_characters("\": ", 3);
                        dump(i->second, true, ensure_ascii, indent_step, new_indent);
                        o->write_characters(",\n", 2);
                    }

                    // last element
                    JSON_ASSERT(i != val.m_value.object->cend());
                    JSON_ASSERT(std::next(i) == val.m_value.object->cend());
                    o->write_characters(indent_string.c_str(), new_indent);
                    o->write_character('\"');
                    dump_escaped(i->first, ensure_ascii);
                    o->write_characters("\": ", 3);
                    dump(i->second, true, ensure_ascii, indent_step, new_indent);

                    o->write_character('\n');
                    o->write_characters(indent_string.c_str(), current_indent);
                    o->write_character('}');
                }
                else
                {
                    o->write_character('{');

                    // first n-1 elements
                    auto i = val.m_value.object->cbegin();
                    for (std::size_t cnt = 0; cnt < val.m_value.object->size() - 1; ++cnt, ++i)
                    {
                        o->write_character('\"');
                        dump_escaped(i->first, ensure_ascii);
                        o->write_characters("\":", 2);
                        dump(i->second, false, ensure_ascii, indent_step, current_indent);
                        o->write_character(',');
                    }

                    // last element
                    JSON_ASSERT(i != val.m_value.object->cend());
                    JSON_ASSERT(std::next(i) == val.m_value.object->cend());
                    o->write_character('\"');
                    dump_escaped(i->first, ensure_ascii);
                    o->write_characters("\":", 2);
                    dump(i->second, false, ensure_ascii, indent_step, current_indent);

                    o->write_character('}');
                }

                return;
            }

            case value_t::array:
            {
                if (val.m_value.array->empty())
                {
                    o->write_characters("[]", 2);
                    return;
                }

                if (pretty_print)
                {
                    o->write_characters("[\n", 2);

                    // variable to hold indentation for recursive calls
                    const auto new_indent = current_indent + indent_step;
                    if (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))
                    {
                        indent_string.resize(indent_string.size() * 2, ' ');
                    }

                    // first n-1 elements
                    for (auto i = val.m_value.array->cbegin();
                            i != val.m_value.array->cend() - 1; ++i)
                    {
                        o->write_characters(indent_string.c_str(), new_indent);
                        dump(*i, true, ensure_ascii, indent_step, new_indent);
                        o->write_characters(",\n", 2);
                    }

                    // last element
                    JSON_ASSERT(!val.m_value.array->empty());
                    o->write_characters(indent_string.c_str(), new_indent);
                    dump(val.m_value.array->back(), true, ensure_ascii, indent_step, new_indent);

                    o->write_character('\n');
                    o->write_characters(indent_string.c_str(), current_indent);
                    o->write_character(']');
                }
                else
                {
                    o->write_character('[');

                    // first n-1 elements
                    for (auto i = val.m_value.array->cbegin();
                            i != val.m_value.array->cend() - 1; ++i)
                    {
                        dump(*i, false, ensure_ascii, indent_step, current_indent);
                        o->write_character(',');
                    }

                    // last element
                    JSON_ASSERT(!val.m_value.array->empty());
                    dump(val.m_value.array->back(), false, ensure_ascii, indent_step, current_indent);

                    o->write_character(']');
                }

                return;
            }

            case value_t::string:
            {
                o->write_character('\"');
                dump_escaped(*val.m_value.string, ensure_ascii);
                o->write_character('\"');
                return;
            }

            case value_t::binary:
            {
                if (pretty_print)
                {
                    o->write_characters("{\n", 2);

                    // variable to hold indentation for recursive calls
                    const auto new_indent = current_indent + indent_step;
                    if (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))
                    {
                        indent_string.resize(indent_string.size() * 2, ' ');
                    }

                    o->write_characters(indent_string.c_str(), new_indent);

                    o->write_characters("\"bytes\": [", 10);

                    if (!val.m_value.binary->empty())
                    {
                        for (auto i = val.m_value.binary->cbegin();
                                i != val.m_value.binary->cend() - 1; ++i)
                        {
                            dump_integer(*i);
                            o->write_characters(", ", 2);
                        }
                        dump_integer(val.m_value.binary->back());
                    }

                    o->write_characters("],\n", 3);
                    o->write_characters(indent_string.c_str(), new_indent);

                    o->write_characters("\"subtype\": ", 11);
                    if (val.m_value.binary->has_subtype())
                    {
                        dump_integer(val.m_value.binary->subtype());
                    }
                    else
                    {
                        o->write_characters("null", 4);
                    }
                    o->write_character('\n');
                    o->write_characters(indent_string.c_str(), current_indent);
                    o->write_character('}');
                }
                else
                {
                    o->write_characters("{\"bytes\":[", 10);

                    if (!val.m_value.binary->empty())
                    {
                        for (auto i = val.m_value.binary->cbegin();
                                i != val.m_value.binary->cend() - 1; ++i)
                        {
                            dump_integer(*i);
                            o->write_character(',');
                        }
                        dump_integer(val.m_value.binary->back());
                    }

                    o->write_characters("],\"subtype\":", 12);
                    if (val.m_value.binary->has_subtype())
                    {
                        dump_integer(val.m_value.binary->subtype());
                        o->write_character('}');
                    }
                    else
                    {
                        o->write_characters("null}", 5);
                    }
                }
                return;
            }

            case value_t::boolean:
            {
                if (val.m_value.boolean)
                {
                    o->write_characters("true", 4);
                }
                else
                {
                    o->write_characters("false", 5);
                }
                return;
            }

            case value_t::number_integer:
            {
                dump_integer(val.m_value.number_integer);
                return;
            }

            case value_t::number_unsigned:
            {
                dump_integer(val.m_value.number_unsigned);
                return;
            }

            case value_t::number_float:
            {
                dump_float(val.m_value.number_float);
                return;
            }

            case value_t::discarded:
            {
                o->write_characters("<discarded>", 11);
                return;
            }

            case value_t::null:
            {
                o->write_characters("null", 4);
                return;
            }

            default:            // LCOV_EXCL_LINE
                JSON_ASSERT(false);  // LCOV_EXCL_LINE
        }
    }

  private:
    /*!
    @brief dump escaped string

    Escape a string by replacing certain special characters by a sequence of an
    escape character (backslash) and another character and other control
    characters by a sequence of "\u" followed by a four-digit hex
    representation. The escaped string is written to output stream @a o.

    @param[in] s  the string to escape
    @param[in] ensure_ascii  whether to escape non-ASCII characters with
                             \uXXXX sequences

    @complexity Linear in the length of string @a s.
    */
    void dump_escaped(const string_t& s, const bool ensure_ascii)
    {
        std::uint32_t codepoint;
        std::uint8_t state = UTF8_ACCEPT;
        std::size_t bytes = 0;  // number of bytes written to string_buffer

        // number of bytes written at the point of the last valid byte
        std::size_t bytes_after_last_accept = 0;
        std::size_t undumped_chars = 0;

        for (std::size_t i = 0; i < s.size(); ++i)
        {
            const auto byte = static_cast<uint8_t>(s[i]);

            switch (decode(state, codepoint, byte))
            {
                case UTF8_ACCEPT:  // decode found a new code point
                {
                    switch (codepoint)
                    {
                        case 0x08: // backspace
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 'b';
                            break;
                        }

                        case 0x09: // horizontal tab
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 't';
                            break;
                        }

                        case 0x0A: // newline
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 'n';
                            break;
                        }

                        case 0x0C: // formfeed
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 'f';
                            break;
                        }

                        case 0x0D: // carriage return
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 'r';
                            break;
                        }

                        case 0x22: // quotation mark
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = '\"';
                            break;
                        }

                        case 0x5C: // reverse solidus
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = '\\';
                            break;
                        }

                        default:
                        {
                            // escape control characters (0x00..0x1F) or, if
                            // ensure_ascii parameter is used, non-ASCII characters
                            if ((codepoint <= 0x1F) || (ensure_ascii && (codepoint >= 0x7F)))
                            {
                                if (codepoint <= 0xFFFF)
                                {
                                    (std::snprintf)(string_buffer.data() + bytes, 7, "\\u%04x",
                                                    static_cast<std::uint16_t>(codepoint));
                                    bytes += 6;
                                }
                                else
                                {
                                    (std::snprintf)(string_buffer.data() + bytes, 13, "\\u%04x\\u%04x",
                                                    static_cast<std::uint16_t>(0xD7C0u + (codepoint >> 10u)),
                                                    static_cast<std::uint16_t>(0xDC00u + (codepoint & 0x3FFu)));
                                    bytes += 12;
                                }
                            }
                            else
                            {
                                // copy byte to buffer (all previous bytes
                                // been copied have in default case above)
                                string_buffer[bytes++] = s[i];
                            }
                            break;
                        }
                    }

                    // write buffer and reset index; there must be 13 bytes
                    // left, as this is the maximal number of bytes to be
                    // written ("\uxxxx\uxxxx\0") for one code point
                    if (string_buffer.size() - bytes < 13)
                    {
                        o->write_characters(string_buffer.data(), bytes);
                        bytes = 0;
                    }

                    // remember the byte position of this accept
                    bytes_after_last_accept = bytes;
                    undumped_chars = 0;
                    break;
                }

                case UTF8_REJECT:  // decode found invalid UTF-8 byte
                {
                    switch (error_handler)
                    {
                        case error_handler_t::strict:
                        {
                            std::string sn(3, '\0');
                            (std::snprintf)(&sn[0], sn.size(), "%.2X", byte);
                            JSON_THROW(type_error::create(316, "invalid UTF-8 byte at index " + std::to_string(i) + ": 0x" + sn));
                        }

                        case error_handler_t::ignore:
                        case error_handler_t::replace:
                        {
                            // in case we saw this character the first time, we
                            // would like to read it again, because the byte
                            // may be OK for itself, but just not OK for the
                            // previous sequence
                            if (undumped_chars > 0)
                            {
                                --i;
                            }

                            // reset length buffer to the last accepted index;
                            // thus removing/ignoring the invalid characters
                            bytes = bytes_after_last_accept;

                            if (error_handler == error_handler_t::replace)
                            {
                                // add a replacement character
                                if (ensure_ascii)
                                {
                                    string_buffer[bytes++] = '\\';
                                    string_buffer[bytes++] = 'u';
                                    string_buffer[bytes++] = 'f';
                                    string_buffer[bytes++] = 'f';
                                    string_buffer[bytes++] = 'f';
                                    string_buffer[bytes++] = 'd';
                                }
                                else
                                {
                                    string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xEF');
                                    string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xBF');
                                    string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xBD');
                                }

                                // write buffer and reset index; there must be 13 bytes
                                // left, as this is the maximal number of bytes to be
                                // written ("\uxxxx\uxxxx\0") for one code point
                                if (string_buffer.size() - bytes < 13)
                                {
                                    o->write_characters(string_buffer.data(), bytes);
                                    bytes = 0;
                                }

                                bytes_after_last_accept = bytes;
                            }

                            undumped_chars = 0;

                            // continue processing the string
                            state = UTF8_ACCEPT;
                            break;
                        }

                        default:            // LCOV_EXCL_LINE
                            JSON_ASSERT(false);  // LCOV_EXCL_LINE
                    }
                    break;
                }

                default:  // decode found yet incomplete multi-byte code point
                {
                    if (!ensure_ascii)
                    {
                        // code point will not be escaped - copy byte to buffer
                        string_buffer[bytes++] = s[i];
                    }
                    ++undumped_chars;
                    break;
                }
            }
        }

        // we finished processing the string
        if (JSON_HEDLEY_LIKELY(state == UTF8_ACCEPT))
        {
            // write buffer
            if (bytes > 0)
            {
                o->write_characters(string_buffer.data(), bytes);
            }
        }
        else
        {
            // we finish reading, but do not accept: string was incomplete
            switch (error_handler)
            {
                case error_handler_t::strict:
                {
                    std::string sn(3, '\0');
                    (std::snprintf)(&sn[0], sn.size(), "%.2X", static_cast<std::uint8_t>(s.back()));
                    JSON_THROW(type_error::create(316, "incomplete UTF-8 string; last byte: 0x" + sn));
                }

                case error_handler_t::ignore:
                {
                    // write all accepted bytes
                    o->write_characters(string_buffer.data(), bytes_after_last_accept);
                    break;
                }

                case error_handler_t::replace:
                {
                    // write all accepted bytes
                    o->write_characters(string_buffer.data(), bytes_after_last_accept);
                    // add a replacement character
                    if (ensure_ascii)
                    {
                        o->write_characters("\\ufffd", 6);
                    }
                    else
                    {
                        o->write_characters("\xEF\xBF\xBD", 3);
                    }
                    break;
                }

                default:            // LCOV_EXCL_LINE
                    JSON_ASSERT(false);  // LCOV_EXCL_LINE
            }
        }
    }

    /*!
    @brief count digits

    Count the number of decimal (base 10) digits for an input unsigned integer.

    @param[in] x  unsigned integer number to count its digits
    @return    number of decimal digits
    */
    inline unsigned int count_digits(number_unsigned_t x) noexcept
    {
        unsigned int n_digits = 1;
        for (;;)
        {
            if (x < 10)
            {
                return n_digits;
            }
            if (x < 100)
            {
                return n_digits + 1;
            }
            if (x < 1000)
            {
                return n_digits + 2;
            }
            if (x < 10000)
            {
                return n_digits + 3;
            }
            x = x / 10000u;
            n_digits += 4;
        }
    }

    /*!
    @brief dump an integer

    Dump a given integer to output stream @a o. Works internally with
    @a number_buffer.

    @param[in] x  integer number (signed or unsigned) to dump
    @tparam NumberType either @a number_integer_t or @a number_unsigned_t
    */
    template < typename NumberType, detail::enable_if_t <
                   std::is_same<NumberType, number_unsigned_t>::value ||
                   std::is_same<NumberType, number_integer_t>::value ||
                   std::is_same<NumberType, binary_char_t>::value,
                   int > = 0 >
    void dump_integer(NumberType x)
    {
        static constexpr std::array<std::array<char, 2>, 100> digits_to_99
        {
            {
                {{'0', '0'}}, {{'0', '1'}}, {{'0', '2'}}, {{'0', '3'}}, {{'0', '4'}}, {{'0', '5'}}, {{'0', '6'}}, {{'0', '7'}}, {{'0', '8'}}, {{'0', '9'}},
                {{'1', '0'}}, {{'1', '1'}}, {{'1', '2'}}, {{'1', '3'}}, {{'1', '4'}}, {{'1', '5'}}, {{'1', '6'}}, {{'1', '7'}}, {{'1', '8'}}, {{'1', '9'}},
                {{'2', '0'}}, {{'2', '1'}}, {{'2', '2'}}, {{'2', '3'}}, {{'2', '4'}}, {{'2', '5'}}, {{'2', '6'}}, {{'2', '7'}}, {{'2', '8'}}, {{'2', '9'}},
                {{'3', '0'}}, {{'3', '1'}}, {{'3', '2'}}, {{'3', '3'}}, {{'3', '4'}}, {{'3', '5'}}, {{'3', '6'}}, {{'3', '7'}}, {{'3', '8'}}, {{'3', '9'}},
                {{'4', '0'}}, {{'4', '1'}}, {{'4', '2'}}, {{'4', '3'}}, {{'4', '4'}}, {{'4', '5'}}, {{'4', '6'}}, {{'4', '7'}}, {{'4', '8'}}, {{'4', '9'}},
                {{'5', '0'}}, {{'5', '1'}}, {{'5', '2'}}, {{'5', '3'}}, {{'5', '4'}}, {{'5', '5'}}, {{'5', '6'}}, {{'5', '7'}}, {{'5', '8'}}, {{'5', '9'}},
                {{'6', '0'}}, {{'6', '1'}}, {{'6', '2'}}, {{'6', '3'}}, {{'6', '4'}}, {{'6', '5'}}, {{'6', '6'}}, {{'6', '7'}}, {{'6', '8'}}, {{'6', '9'}},
                {{'7', '0'}}, {{'7', '1'}}, {{'7', '2'}}, {{'7', '3'}}, {{'7', '4'}}, {{'7', '5'}}, {{'7', '6'}}, {{'7', '7'}}, {{'7', '8'}}, {{'7', '9'}},
                {{'8', '0'}}, {{'8', '1'}}, {{'8', '2'}}, {{'8', '3'}}, {{'8', '4'}}, {{'8', '5'}}, {{'8', '6'}}, {{'8', '7'}}, {{'8', '8'}}, {{'8', '9'}},
                {{'9', '0'}}, {{'9', '1'}}, {{'9', '2'}}, {{'9', '3'}}, {{'9', '4'}}, {{'9', '5'}}, {{'9', '6'}}, {{'9', '7'}}, {{'9', '8'}}, {{'9', '9'}},
            }
        };

        // special case for "0"
        if (x == 0)
        {
            o->write_character('0');
            return;
        }

        // use a pointer to fill the buffer
        auto buffer_ptr = number_buffer.begin();

        const bool is_negative = std::is_same<NumberType, number_integer_t>::value && !(x >= 0); // see issue #755
        number_unsigned_t abs_value;

        unsigned int n_chars;

        if (is_negative)
        {
            *buffer_ptr = '-';
            abs_value = remove_sign(static_cast<number_integer_t>(x));

            // account one more byte for the minus sign
            n_chars = 1 + count_digits(abs_value);
        }
        else
        {
            abs_value = static_cast<number_unsigned_t>(x);
            n_chars = count_digits(abs_value);
        }

        // spare 1 byte for '\0'
        JSON_ASSERT(n_chars < number_buffer.size() - 1);

        // jump to the end to generate the string from backward
        // so we later avoid reversing the result
        buffer_ptr += n_chars;

        // Fast int2ascii implementation inspired by "Fastware" talk by Andrei Alexandrescu
        // See: https://www.youtube.com/watch?v=o4-CwDo2zpg
        while (abs_value >= 100)
        {
            const auto digits_index = static_cast<unsigned>((abs_value % 100));
            abs_value /= 100;
            *(--buffer_ptr) = digits_to_99[digits_index][1];
            *(--buffer_ptr) = digits_to_99[digits_index][0];
        }

        if (abs_value >= 10)
        {
            const auto digits_index = static_cast<unsigned>(abs_value);
            *(--buffer_ptr) = digits_to_99[digits_index][1];
            *(--buffer_ptr) = digits_to_99[digits_index][0];
        }
        else
        {
            *(--buffer_ptr) = static_cast<char>('0' + abs_value);
        }

        o->write_characters(number_buffer.data(), n_chars);
    }

    /*!
    @brief dump a floating-point number

    Dump a given floating-point number to output stream @a o. Works internally
    with @a number_buffer.

    @param[in] x  floating-point number to dump
    */
    void dump_float(number_float_t x)
    {
        // NaN / inf
        if (!std::isfinite(x))
        {
            o->write_characters("null", 4);
            return;
        }

        // If number_float_t is an IEEE-754 single or double precision number,
        // use the Grisu2 algorithm to produce short numbers which are
        // guaranteed to round-trip, using strtof and strtod, resp.
        //
        // NB: The test below works if <long double> == <double>.
        static constexpr bool is_ieee_single_or_double
            = (std::numeric_limits<number_float_t>::is_iec559 && std::numeric_limits<number_float_t>::digits == 24 && std::numeric_limits<number_float_t>::max_exponent == 128) ||
              (std::numeric_limits<number_float_t>::is_iec559 && std::numeric_limits<number_float_t>::digits == 53 && std::numeric_limits<number_float_t>::max_exponent == 1024);

        dump_float(x, std::integral_constant<bool, is_ieee_single_or_double>());
    }

    void dump_float(number_float_t x, std::true_type /*is_ieee_single_or_double*/)
    {
        char* begin = number_buffer.data();
        char* end = ::nlohmann::detail::to_chars(begin, begin + number_buffer.size(), x);

        o->write_characters(begin, static_cast<size_t>(end - begin));
    }

    void dump_float(number_float_t x, std::false_type /*is_ieee_single_or_double*/)
    {
        // get number of digits for a float -> text -> float round-trip
        static constexpr auto d = std::numeric_limits<number_float_t>::max_digits10;

        // the actual conversion
        std::ptrdiff_t len = (std::snprintf)(number_buffer.data(), number_buffer.size(), "%.*g", d, x);

        // negative value indicates an error
        JSON_ASSERT(len > 0);
        // check if buffer was large enough
        JSON_ASSERT(static_cast<std::size_t>(len) < number_buffer.size());

        // erase thousands separator
        if (thousands_sep != '\0')
        {
            const auto end = std::remove(number_buffer.begin(),
                                         number_buffer.begin() + len, thousands_sep);
            std::fill(end, number_buffer.end(), '\0');
            JSON_ASSERT((end - number_buffer.begin()) <= len);
            len = (end - number_buffer.begin());
        }

        // convert decimal point to '.'
        if (decimal_point != '\0' && decimal_point != '.')
        {
            const auto dec_pos = std::find(number_buffer.begin(), number_buffer.end(), decimal_point);
            if (dec_pos != number_buffer.end())
            {
                *dec_pos = '.';
            }
        }

        o->write_characters(number_buffer.data(), static_cast<std::size_t>(len));

        // determine if need to append ".0"
        const bool value_is_int_like =
            std::none_of(number_buffer.begin(), number_buffer.begin() + len + 1,
                         [](char c)
        {
            return c == '.' || c == 'e';
        });

        if (value_is_int_like)
        {
            o->write_characters(".0", 2);
        }
    }

    /*!
    @brief check whether a string is UTF-8 encoded

    The function checks each byte of a string whether it is UTF-8 encoded. The
    result of the check is stored in the @a state parameter. The function must
    be called initially with state 0 (accept). State 1 means the string must
    be rejected, because the current byte is not allowed. If the string is
    completely processed, but the state is non-zero, the string ended
    prematurely; that is, the last byte indicated more bytes should have
    followed.

    @param[in,out] state  the state of the decoding
    @param[in,out] codep  codepoint (valid only if resulting state is UTF8_ACCEPT)
    @param[in] byte       next byte to decode
    @return               new state

    @note The function has been edited: a std::array is used.

    @copyright Copyright (c) 2008-2009 Bjoern Hoehrmann <bjoern@hoehrmann.de>
    @sa http://bjoern.hoehrmann.de/utf-8/decoder/dfa/
    */
    static std::uint8_t decode(std::uint8_t& state, std::uint32_t& codep, const std::uint8_t byte) noexcept
    {
        static const std::array<std::uint8_t, 400> utf8d =
        {
            {
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 00..1F
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 20..3F
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 40..5F
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 60..7F
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, // 80..9F
                7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, // A0..BF
                8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, // C0..DF
                0xA, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x4, 0x3, 0x3, // E0..EF
                0xB, 0x6, 0x6, 0x6, 0x5, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, // F0..FF
                0x0, 0x1, 0x2, 0x3, 0x5, 0x8, 0x7, 0x1, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x1, 0x1, // s0..s0
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, // s1..s2
                1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, // s3..s4
                1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, // s5..s6
                1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // s7..s8
            }
        };

        const std::uint8_t type = utf8d[byte];

        codep = (state != UTF8_ACCEPT)
                ? (byte & 0x3fu) | (codep << 6u)
                : (0xFFu >> type) & (byte);

        std::size_t index = 256u + static_cast<size_t>(state) * 16u + static_cast<size_t>(type);
        JSON_ASSERT(index < 400);
        state = utf8d[index];
        return state;
    }

    /*
     * Overload to make the compiler happy while it is instantiating
     * dump_integer for number_unsigned_t.
     * Must never be called.
     */
    number_unsigned_t remove_sign(number_unsigned_t x)
    {
        JSON_ASSERT(false); // LCOV_EXCL_LINE
        return x; // LCOV_EXCL_LINE
    }

    /*
     * Helper function for dump_integer
     *
     * This function takes a negative signed integer and returns its absolute
     * value as unsigned integer. The plus/minus shuffling is necessary as we can
     * not directly remove the sign of an arbitrary signed integer as the
     * absolute values of INT_MIN and INT_MAX are usually not the same. See
     * #1708 for details.
     */
    inline number_unsigned_t remove_sign(number_integer_t x) noexcept
    {
        JSON_ASSERT(x < 0 && x < (std::numeric_limits<number_integer_t>::max)());
        return static_cast<number_unsigned_t>(-(x + 1)) + 1;
    }

  private:
    /// the output of the serializer
    output_adapter_t<char> o = nullptr;

    /// a (hopefully) large enough character buffer
    std::array<char, 64> number_buffer{{}};

    /// the locale
    const std::lconv* loc = nullptr;
    /// the locale's thousand separator character
    const char thousands_sep = '\0';
    /// the locale's decimal point character
    const char decimal_point = '\0';

    /// string buffer
    std::array<char, 512> string_buffer{{}};

    /// the indentation character
    const char indent_char;
    /// the indentation string
    string_t indent_string;

    /// error_handler how to react on decoding errors
    const error_handler_t error_handler;
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/value_t.hpp>

// #include <nlohmann/json_fwd.hpp>

// #include <nlohmann/ordered_map.hpp>


#include <functional> // less
#include <memory> // allocator
#include <utility> // pair
#include <vector> // vector

namespace nlohmann
{

/// ordered_map: a minimal map-like container that preserves insertion order
/// for use within nlohmann::basic_json<ordered_map>
template <class Key, class T, class IgnoredLess = std::less<Key>,
          class Allocator = std::allocator<std::pair<const Key, T>>>
                  struct ordered_map : std::vector<std::pair<const Key, T>, Allocator>
{
    using key_type = Key;
    using mapped_type = T;
    using Container = std::vector<std::pair<const Key, T>, Allocator>;
    using typename Container::iterator;
    using typename Container::const_iterator;
    using typename Container::size_type;
    using typename Container::value_type;

    // Explicit constructors instead of `using Container::Container`
    // otherwise older compilers choke on it (GCC <= 5.5, xcode <= 9.4)
    ordered_map(const Allocator& alloc = Allocator()) : Container{alloc} {}
    template <class It>
    ordered_map(It first, It last, const Allocator& alloc = Allocator())
        : Container{first, last, alloc} {}
    ordered_map(std::initializer_list<T> init, const Allocator& alloc = Allocator() )
        : Container{init, alloc} {}

    std::pair<iterator, bool> emplace(const key_type& key, T&& t)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (it->first == key)
            {
                return {it, false};
            }
        }
        Container::emplace_back(key, t);
        return {--this->end(), true};
    }

    T& operator[](const Key& key)
    {
        return emplace(key, T{}).first->second;
    }

    const T& operator[](const Key& key) const
    {
        return at(key);
    }

    T& at(const Key& key)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (it->first == key)
            {
                return it->second;
            }
        }

        throw std::out_of_range("key not found");
    }

    const T& at(const Key& key) const
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (it->first == key)
            {
                return it->second;
            }
        }

        throw std::out_of_range("key not found");
    }

    size_type erase(const Key& key)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (it->first == key)
            {
                // Since we cannot move const Keys, re-construct them in place
                for (auto next = it; ++next != this->end(); ++it)
                {
                    it->~value_type(); // Destroy but keep allocation
                    new (&*it) value_type{std::move(*next)};
                }
                Container::pop_back();
                return 1;
            }
        }
        return 0;
    }

    iterator erase(iterator pos)
    {
        auto it = pos;

        // Since we cannot move const Keys, re-construct them in place
        for (auto next = it; ++next != this->end(); ++it)
        {
            it->~value_type(); // Destroy but keep allocation
            new (&*it) value_type{std::move(*next)};
        }
        Container::pop_back();
        return pos;
    }

    size_type count(const Key& key) const
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (it->first == key)
            {
                return 1;
            }
        }
        return 0;
    }

    iterator find(const Key& key)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (it->first == key)
            {
                return it;
            }
        }
        return Container::end();
    }

    const_iterator find(const Key& key) const
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (it->first == key)
            {
                return it;
            }
        }
        return Container::end();
    }

    std::pair<iterator, bool> insert( value_type&& value )
    {
        return emplace(value.first, std::move(value.second));
    }

    std::pair<iterator, bool> insert( const value_type& value )
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (it->first == value.first)
            {
                return {it, false};
            }
        }
        Container::push_back(value);
        return {--this->end(), true};
    }
};

}  // namespace nlohmann


/*!
@brief namespace for Niels Lohmann
@see https://github.com/nlohmann
@since version 1.0.0
*/
namespace nlohmann
{

/*!
@brief a class to store JSON values

@tparam ObjectType type for JSON objects (`std::map` by default; will be used
in @ref object_t)
@tparam ArrayType type for JSON arrays (`std::vector` by default; will be used
in @ref array_t)
@tparam StringType type for JSON strings and object keys (`std::string` by
default; will be used in @ref string_t)
@tparam BooleanType type for JSON booleans (`bool` by default; will be used
in @ref boolean_t)
@tparam NumberIntegerType type for JSON integer numbers (`int64_t` by
default; will be used in @ref number_integer_t)
@tparam NumberUnsignedType type for JSON unsigned integer numbers (@c
`uint64_t` by default; will be used in @ref number_unsigned_t)
@tparam NumberFloatType type for JSON floating-point numbers (`double` by
default; will be used in @ref number_float_t)
@tparam BinaryType type for packed binary data for compatibility with binary
serialization formats (`std::vector<std::uint8_t>` by default; will be used in
@ref binary_t)
@tparam AllocatorType type of the allocator to use (`std::allocator` by
default)
@tparam JSONSerializer the serializer to resolve internal calls to `to_json()`
and `from_json()` (@ref adl_serializer by default)

@requirement The class satisfies the following concept requirements:
- Basic
 - [DefaultConstructible](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible):
   JSON values can be default constructed. The result will be a JSON null
   value.
 - [MoveConstructible](https://en.cppreference.com/w/cpp/named_req/MoveConstructible):
   A JSON value can be constructed from an rvalue argument.
 - [CopyConstructible](https://en.cppreference.com/w/cpp/named_req/CopyConstructible):
   A JSON value can be copy-constructed from an lvalue expression.
 - [MoveAssignable](https://en.cppreference.com/w/cpp/named_req/MoveAssignable):
   A JSON value van be assigned from an rvalue argument.
 - [CopyAssignable](https://en.cppreference.com/w/cpp/named_req/CopyAssignable):
   A JSON value can be copy-assigned from an lvalue expression.
 - [Destructible](https://en.cppreference.com/w/cpp/named_req/Destructible):
   JSON values can be destructed.
- Layout
 - [StandardLayoutType](https://en.cppreference.com/w/cpp/named_req/StandardLayoutType):
   JSON values have
   [standard layout](https://en.cppreference.com/w/cpp/language/data_members#Standard_layout):
   All non-static data members are private and standard layout types, the
   class has no virtual functions or (virtual) base classes.
- Library-wide
 - [EqualityComparable](https://en.cppreference.com/w/cpp/named_req/EqualityComparable):
   JSON values can be compared with `==`, see @ref
   operator==(const_reference,const_reference).
 - [LessThanComparable](https://en.cppreference.com/w/cpp/named_req/LessThanComparable):
   JSON values can be compared with `<`, see @ref
   operator<(const_reference,const_reference).
 - [Swappable](https://en.cppreference.com/w/cpp/named_req/Swappable):
   Any JSON lvalue or rvalue of can be swapped with any lvalue or rvalue of
   other compatible types, using unqualified function call @ref swap().
 - [NullablePointer](https://en.cppreference.com/w/cpp/named_req/NullablePointer):
   JSON values can be compared against `std::nullptr_t` objects which are used
   to model the `null` value.
- Container
 - [Container](https://en.cppreference.com/w/cpp/named_req/Container):
   JSON values can be used like STL containers and provide iterator access.
 - [ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer);
   JSON values can be used like STL containers and provide reverse iterator
   access.

@invariant The member variables @a m_value and @a m_type have the following
relationship:
- If `m_type == value_t::object`, then `m_value.object != nullptr`.
- If `m_type == value_t::array`, then `m_value.array != nullptr`.
- If `m_type == value_t::string`, then `m_value.string != nullptr`.
The invariants are checked by member function assert_invariant().

@internal
@note ObjectType trick from https://stackoverflow.com/a/9860911
@endinternal

@see [RFC 7159: The JavaScript Object Notation (JSON) Data Interchange
Format](http://rfc7159.net/rfc7159)

@since version 1.0.0

@nosubgrouping
*/
NLOHMANN_BASIC_JSON_TPL_DECLARATION
class basic_json
{
  private:
    template<detail::value_t> friend struct detail::external_constructor;
    friend ::nlohmann::json_pointer<basic_json>;

    template<typename BasicJsonType, typename InputType>
    friend class ::nlohmann::detail::parser;
    friend ::nlohmann::detail::serializer<basic_json>;
    template<typename BasicJsonType>
    friend class ::nlohmann::detail::iter_impl;
    template<typename BasicJsonType, typename CharType>
    friend class ::nlohmann::detail::binary_writer;
    template<typename BasicJsonType, typename InputType, typename SAX>
    friend class ::nlohmann::detail::binary_reader;
    template<typename BasicJsonType>
    friend class ::nlohmann::detail::json_sax_dom_parser;
    template<typename BasicJsonType>
    friend class ::nlohmann::detail::json_sax_dom_callback_parser;

    /// workaround type for MSVC
    using basic_json_t = NLOHMANN_BASIC_JSON_TPL;

    // convenience aliases for types residing in namespace detail;
    using lexer = ::nlohmann::detail::lexer_base<basic_json>;

    template<typename InputAdapterType>
    static ::nlohmann::detail::parser<basic_json, InputAdapterType> parser(
        InputAdapterType adapter,
        detail::parser_callback_t<basic_json>cb = nullptr,
        const bool allow_exceptions = true,
        const bool ignore_comments = false
                                 )
    {
        return ::nlohmann::detail::parser<basic_json, InputAdapterType>(std::move(adapter),
                std::move(cb), allow_exceptions, ignore_comments);
    }

    using primitive_iterator_t = ::nlohmann::detail::primitive_iterator_t;
    template<typename BasicJsonType>
    using internal_iterator = ::nlohmann::detail::internal_iterator<BasicJsonType>;
    template<typename BasicJsonType>
    using iter_impl = ::nlohmann::detail::iter_impl<BasicJsonType>;
    template<typename Iterator>
    using iteration_proxy = ::nlohmann::detail::iteration_proxy<Iterator>;
    template<typename Base> using json_reverse_iterator = ::nlohmann::detail::json_reverse_iterator<Base>;

    template<typename CharType>
    using output_adapter_t = ::nlohmann::detail::output_adapter_t<CharType>;

    template<typename InputType>
    using binary_reader = ::nlohmann::detail::binary_reader<basic_json, InputType>;
    template<typename CharType> using binary_writer = ::nlohmann::detail::binary_writer<basic_json, CharType>;

    using serializer = ::nlohmann::detail::serializer<basic_json>;

  public:
    using value_t = detail::value_t;
    /// JSON Pointer, see @ref nlohmann::json_pointer
    using json_pointer = ::nlohmann::json_pointer<basic_json>;
    template<typename T, typename SFINAE>
    using json_serializer = JSONSerializer<T, SFINAE>;
    /// how to treat decoding errors
    using error_handler_t = detail::error_handler_t;
    /// how to treat CBOR tags
    using cbor_tag_handler_t = detail::cbor_tag_handler_t;
    /// helper type for initializer lists of basic_json values
    using initializer_list_t = std::initializer_list<detail::json_ref<basic_json>>;

    using input_format_t = detail::input_format_t;
    /// SAX interface type, see @ref nlohmann::json_sax
    using json_sax_t = json_sax<basic_json>;

    ////////////////
    // exceptions //
    ////////////////

    /// @name exceptions
    /// Classes to implement user-defined exceptions.
    /// @{

    /// @copydoc detail::exception
    using exception = detail::exception;
    /// @copydoc detail::parse_error
    using parse_error = detail::parse_error;
    /// @copydoc detail::invalid_iterator
    using invalid_iterator = detail::invalid_iterator;
    /// @copydoc detail::type_error
    using type_error = detail::type_error;
    /// @copydoc detail::out_of_range
    using out_of_range = detail::out_of_range;
    /// @copydoc detail::other_error
    using other_error = detail::other_error;

    /// @}


    /////////////////////
    // container types //
    /////////////////////

    /// @name container types
    /// The canonic container types to use @ref basic_json like any other STL
    /// container.
    /// @{

    /// the type of elements in a basic_json container
    using value_type = basic_json;

    /// the type of an element reference
    using reference = value_type&;
    /// the type of an element const reference
    using const_reference = const value_type&;

    /// a type to represent differences between iterators
    using difference_type = std::ptrdiff_t;
    /// a type to represent container sizes
    using size_type = std::size_t;

    /// the allocator type
    using allocator_type = AllocatorType<basic_json>;

    /// the type of an element pointer
    using pointer = typename std::allocator_traits<allocator_type>::pointer;
    /// the type of an element const pointer
    using const_pointer = typename std::allocator_traits<allocator_type>::const_pointer;

    /// an iterator for a basic_json container
    using iterator = iter_impl<basic_json>;
    /// a const iterator for a basic_json container
    using const_iterator = iter_impl<const basic_json>;
    /// a reverse iterator for a basic_json container
    using reverse_iterator = json_reverse_iterator<typename basic_json::iterator>;
    /// a const reverse iterator for a basic_json container
    using const_reverse_iterator = json_reverse_iterator<typename basic_json::const_iterator>;

    /// @}


    /*!
    @brief returns the allocator associated with the container
    */
    static allocator_type get_allocator()
    {
        return allocator_type();
    }

    /*!
    @brief returns version information on the library

    This function returns a JSON object with information about the library,
    including the version number and information on the platform and compiler.

    @return JSON object holding version information
    key         | description
    ----------- | ---------------
    `compiler`  | Information on the used compiler. It is an object with the following keys: `c++` (the used C++ standard), `family` (the compiler family; possible values are `clang`, `icc`, `gcc`, `ilecpp`, `msvc`, `pgcpp`, `sunpro`, and `unknown`), and `version` (the compiler version).
    `copyright` | The copyright line for the library as string.
    `name`      | The name of the library as string.
    `platform`  | The used platform as string. Possible values are `win32`, `linux`, `apple`, `unix`, and `unknown`.
    `url`       | The URL of the project as string.
    `version`   | The version of the library. It is an object with the following keys: `major`, `minor`, and `patch` as defined by [Semantic Versioning](http://semver.org), and `string` (the version string).

    @liveexample{The following code shows an example output of the `meta()`
    function.,meta}

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @complexity Constant.

    @since 2.1.0
    */
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json meta()
    {
        basic_json result;

        result["copyright"] = "(C) 2013-2020 Niels Lohmann";
        result["name"] = "JSON for Modern C++";
        result["url"] = "https://github.com/nlohmann/json";
        result["version"]["string"] =
            std::to_string(NLOHMANN_JSON_VERSION_MAJOR) + "." +
            std::to_string(NLOHMANN_JSON_VERSION_MINOR) + "." +
            std::to_string(NLOHMANN_JSON_VERSION_PATCH);
        result["version"]["major"] = NLOHMANN_JSON_VERSION_MAJOR;
        result["version"]["minor"] = NLOHMANN_JSON_VERSION_MINOR;
        result["version"]["patch"] = NLOHMANN_JSON_VERSION_PATCH;

#ifdef _WIN32
        result["platform"] = "win32";
#elif defined __linux__
        result["platform"] = "linux";
#elif defined __APPLE__
        result["platform"] = "apple";
#elif defined __unix__
        result["platform"] = "unix";
#else
        result["platform"] = "unknown";
#endif

#if defined(__ICC) || defined(__INTEL_COMPILER)
        result["compiler"] = {{"family", "icc"}, {"version", __INTEL_COMPILER}};
#elif defined(__clang__)
        result["compiler"] = {{"family", "clang"}, {"version", __clang_version__}};
#elif defined(__GNUC__) || defined(__GNUG__)
        result["compiler"] = {{"family", "gcc"}, {"version", std::to_string(__GNUC__) + "." + std::to_string(__GNUC_MINOR__) + "." + std::to_string(__GNUC_PATCHLEVEL__)}};
#elif defined(__HP_cc) || defined(__HP_aCC)
        result["compiler"] = "hp"
#elif defined(__IBMCPP__)
        result["compiler"] = {{"family", "ilecpp"}, {"version", __IBMCPP__}};
#elif defined(_MSC_VER)
        result["compiler"] = {{"family", "msvc"}, {"version", _MSC_VER}};
#elif defined(__PGI)
        result["compiler"] = {{"family", "pgcpp"}, {"version", __PGI}};
#elif defined(__SUNPRO_CC)
        result["compiler"] = {{"family", "sunpro"}, {"version", __SUNPRO_CC}};
#else
        result["compiler"] = {{"family", "unknown"}, {"version", "unknown"}};
#endif

#ifdef __cplusplus
        result["compiler"]["c++"] = std::to_string(__cplusplus);
#else
        result["compiler"]["c++"] = "unknown";
#endif
        return result;
    }


    ///////////////////////////
    // JSON value data types //
    ///////////////////////////

    /// @name JSON value data types
    /// The data types to store a JSON value. These types are derived from
    /// the template arguments passed to class @ref basic_json.
    /// @{

#if defined(JSON_HAS_CPP_14)
    // Use transparent comparator if possible, combined with perfect forwarding
    // on find() and count() calls prevents unnecessary string construction.
    using object_comparator_t = std::less<>;
#else
    using object_comparator_t = std::less<StringType>;
#endif

    /*!
    @brief a type for an object

    [RFC 7159](http://rfc7159.net/rfc7159) describes JSON objects as follows:
    > An object is an unordered collection of zero or more name/value pairs,
    > where a name is a string and a value is a string, number, boolean, null,
    > object, or array.

    To store objects in C++, a type is defined by the template parameters
    described below.

    @tparam ObjectType  the container to store objects (e.g., `std::map` or
    `std::unordered_map`)
    @tparam StringType the type of the keys or names (e.g., `std::string`).
    The comparison function `std::less<StringType>` is used to order elements
    inside the container.
    @tparam AllocatorType the allocator to use for objects (e.g.,
    `std::allocator`)

    #### Default type

    With the default values for @a ObjectType (`std::map`), @a StringType
    (`std::string`), and @a AllocatorType (`std::allocator`), the default
    value for @a object_t is:

    @code {.cpp}
    std::map<
      std::string, // key_type
      basic_json, // value_type
      std::less<std::string>, // key_compare
      std::allocator<std::pair<const std::string, basic_json>> // allocator_type
    >
    @endcode

    #### Behavior

    The choice of @a object_t influences the behavior of the JSON class. With
    the default type, objects have the following behavior:

    - When all names are unique, objects will be interoperable in the sense
      that all software implementations receiving that object will agree on
      the name-value mappings.
    - When the names within an object are not unique, it is unspecified which
      one of the values for a given key will be chosen. For instance,
      `{"key": 2, "key": 1}` could be equal to either `{"key": 1}` or
      `{"key": 2}`.
    - Internally, name/value pairs are stored in lexicographical order of the
      names. Objects will also be serialized (see @ref dump) in this order.
      For instance, `{"b": 1, "a": 2}` and `{"a": 2, "b": 1}` will be stored
      and serialized as `{"a": 2, "b": 1}`.
    - When comparing objects, the order of the name/value pairs is irrelevant.
      This makes objects interoperable in the sense that they will not be
      affected by these differences. For instance, `{"b": 1, "a": 2}` and
      `{"a": 2, "b": 1}` will be treated as equal.

    #### Limits

    [RFC 7159](http://rfc7159.net/rfc7159) specifies:
    > An implementation may set limits on the maximum depth of nesting.

    In this class, the object's limit of nesting is not explicitly constrained.
    However, a maximum depth of nesting may be introduced by the compiler or
    runtime environment. A theoretical limit can be queried by calling the
    @ref max_size function of a JSON object.

    #### Storage

    Objects are stored as pointers in a @ref basic_json type. That is, for any
    access to object values, a pointer of type `object_t*` must be
    dereferenced.

    @sa @ref array_t -- type for an array value

    @since version 1.0.0

    @note The order name/value pairs are added to the object is *not*
    preserved by the library. Therefore, iterating an object may return
    name/value pairs in a different order than they were originally stored. In
    fact, keys will be traversed in alphabetical order as `std::map` with
    `std::less` is used by default. Please note this behavior conforms to [RFC
    7159](http://rfc7159.net/rfc7159), because any order implements the
    specified "unordered" nature of JSON objects.
    */
    using object_t = ObjectType<StringType,
          basic_json,
          object_comparator_t,
          AllocatorType<std::pair<const StringType,
          basic_json>>>;

    /*!
    @brief a type for an array

    [RFC 7159](http://rfc7159.net/rfc7159) describes JSON arrays as follows:
    > An array is an ordered sequence of zero or more values.

    To store objects in C++, a type is defined by the template parameters
    explained below.

    @tparam ArrayType  container type to store arrays (e.g., `std::vector` or
    `std::list`)
    @tparam AllocatorType allocator to use for arrays (e.g., `std::allocator`)

    #### Default type

    With the default values for @a ArrayType (`std::vector`) and @a
    AllocatorType (`std::allocator`), the default value for @a array_t is:

    @code {.cpp}
    std::vector<
      basic_json, // value_type
      std::allocator<basic_json> // allocator_type
    >
    @endcode

    #### Limits

    [RFC 7159](http://rfc7159.net/rfc7159) specifies:
    > An implementation may set limits on the maximum depth of nesting.

    In this class, the array's limit of nesting is not explicitly constrained.
    However, a maximum depth of nesting may be introduced by the compiler or
    runtime environment. A theoretical limit can be queried by calling the
    @ref max_size function of a JSON array.

    #### Storage

    Arrays are stored as pointers in a @ref basic_json type. That is, for any
    access to array values, a pointer of type `array_t*` must be dereferenced.

    @sa @ref object_t -- type for an object value

    @since version 1.0.0
    */
    using array_t = ArrayType<basic_json, AllocatorType<basic_json>>;

    /*!
    @brief a type for a string

    [RFC 7159](http://rfc7159.net/rfc7159) describes JSON strings as follows:
    > A string is a sequence of zero or more Unicode characters.

    To store objects in C++, a type is defined by the template parameter
    described below. Unicode values are split by the JSON class into
    byte-sized characters during deserialization.

    @tparam StringType  the container to store strings (e.g., `std::string`).
    Note this container is used for keys/names in objects, see @ref object_t.

    #### Default type

    With the default values for @a StringType (`std::string`), the default
    value for @a string_t is:

    @code {.cpp}
    std::string
    @endcode

    #### Encoding

    Strings are stored in UTF-8 encoding. Therefore, functions like
    `std::string::size()` or `std::string::length()` return the number of
    bytes in the string rather than the number of characters or glyphs.

    #### String comparison

    [RFC 7159](http://rfc7159.net/rfc7159) states:
    > Software implementations are typically required to test names of object
    > members for equality. Implementations that transform the textual
    > representation into sequences of Unicode code units and then perform the
    > comparison numerically, code unit by code unit, are interoperable in the
    > sense that implementations will agree in all cases on equality or
    > inequality of two strings. For example, implementations that compare
    > strings with escaped characters unconverted may incorrectly find that
    > `"a\\b"` and `"a\u005Cb"` are not equal.

    This implementation is interoperable as it does compare strings code unit
    by code unit.

    #### Storage

    String values are stored as pointers in a @ref basic_json type. That is,
    for any access to string values, a pointer of type `string_t*` must be
    dereferenced.

    @since version 1.0.0
    */
    using string_t = StringType;

    /*!
    @brief a type for a boolean

    [RFC 7159](http://rfc7159.net/rfc7159) implicitly describes a boolean as a
    type which differentiates the two literals `true` and `false`.

    To store objects in C++, a type is defined by the template parameter @a
    BooleanType which chooses the type to use.

    #### Default type

    With the default values for @a BooleanType (`bool`), the default value for
    @a boolean_t is:

    @code {.cpp}
    bool
    @endcode

    #### Storage

    Boolean values are stored directly inside a @ref basic_json type.

    @since version 1.0.0
    */
    using boolean_t = BooleanType;

    /*!
    @brief a type for a number (integer)

    [RFC 7159](http://rfc7159.net/rfc7159) describes numbers as follows:
    > The representation of numbers is similar to that used in most
    > programming languages. A number is represented in base 10 using decimal
    > digits. It contains an integer component that may be prefixed with an
    > optional minus sign, which may be followed by a fraction part and/or an
    > exponent part. Leading zeros are not allowed. (...) Numeric values that
    > cannot be represented in the grammar below (such as Infinity and NaN)
    > are not permitted.

    This description includes both integer and floating-point numbers.
    However, C++ allows more precise storage if it is known whether the number
    is a signed integer, an unsigned integer or a floating-point number.
    Therefore, three different types, @ref number_integer_t, @ref
    number_unsigned_t and @ref number_float_t are used.

    To store integer numbers in C++, a type is defined by the template
    parameter @a NumberIntegerType which chooses the type to use.

    #### Default type

    With the default values for @a NumberIntegerType (`int64_t`), the default
    value for @a number_integer_t is:

    @code {.cpp}
    int64_t
    @endcode

    #### Default behavior

    - The restrictions about leading zeros is not enforced in C++. Instead,
      leading zeros in integer literals lead to an interpretation as octal
      number. Internally, the value will be stored as decimal number. For
      instance, the C++ integer literal `010` will be serialized to `8`.
      During deserialization, leading zeros yield an error.
    - Not-a-number (NaN) values will be serialized to `null`.

    #### Limits

    [RFC 7159](http://rfc7159.net/rfc7159) specifies:
    > An implementation may set limits on the range and precision of numbers.

    When the default type is used, the maximal integer number that can be
    stored is `9223372036854775807` (INT64_MAX) and the minimal integer number
    that can be stored is `-9223372036854775808` (INT64_MIN). Integer numbers
    that are out of range will yield over/underflow when used in a
    constructor. During deserialization, too large or small integer numbers
    will be automatically be stored as @ref number_unsigned_t or @ref
    number_float_t.

    [RFC 7159](http://rfc7159.net/rfc7159) further states:
    > Note that when such software is used, numbers that are integers and are
    > in the range \f$[-2^{53}+1, 2^{53}-1]\f$ are interoperable in the sense
    > that implementations will agree exactly on their numeric values.

    As this range is a subrange of the exactly supported range [INT64_MIN,
    INT64_MAX], this class's integer type is interoperable.

    #### Storage

    Integer number values are stored directly inside a @ref basic_json type.

    @sa @ref number_float_t -- type for number values (floating-point)

    @sa @ref number_unsigned_t -- type for number values (unsigned integer)

    @since version 1.0.0
    */
    using number_integer_t = NumberIntegerType;

    /*!
    @brief a type for a number (unsigned)

    [RFC 7159](http://rfc7159.net/rfc7159) describes numbers as follows:
    > The representation of numbers is similar to that used in most
    > programming languages. A number is represented in base 10 using decimal
    > digits. It contains an integer component that may be prefixed with an
    > optional minus sign, which may be followed by a fraction part and/or an
    > exponent part. Leading zeros are not allowed. (...) Numeric values that
    > cannot be represented in the grammar below (such as Infinity and NaN)
    > are not permitted.

    This description includes both integer and floating-point numbers.
    However, C++ allows more precise storage if it is known whether the number
    is a signed integer, an unsigned integer or a floating-point number.
    Therefore, three different types, @ref number_integer_t, @ref
    number_unsigned_t and @ref number_float_t are used.

    To store unsigned integer numbers in C++, a type is defined by the
    template parameter @a NumberUnsignedType which chooses the type to use.

    #### Default type

    With the default values for @a NumberUnsignedType (`uint64_t`), the
    default value for @a number_unsigned_t is:

    @code {.cpp}
    uint64_t
    @endcode

    #### Default behavior

    - The restrictions about leading zeros is not enforced in C++. Instead,
      leading zeros in integer literals lead to an interpretation as octal
      number. Internally, the value will be stored as decimal number. For
      instance, the C++ integer literal `010` will be serialized to `8`.
      During deserialization, leading zeros yield an error.
    - Not-a-number (NaN) values will be serialized to `null`.

    #### Limits

    [RFC 7159](http://rfc7159.net/rfc7159) specifies:
    > An implementation may set limits on the range and precision of numbers.

    When the default type is used, the maximal integer number that can be
    stored is `18446744073709551615` (UINT64_MAX) and the minimal integer
    number that can be stored is `0`. Integer numbers that are out of range
    will yield over/underflow when used in a constructor. During
    deserialization, too large or small integer numbers will be automatically
    be stored as @ref number_integer_t or @ref number_float_t.

    [RFC 7159](http://rfc7159.net/rfc7159) further states:
    > Note that when such software is used, numbers that are integers and are
    > in the range \f$[-2^{53}+1, 2^{53}-1]\f$ are interoperable in the sense
    > that implementations will agree exactly on their numeric values.

    As this range is a subrange (when considered in conjunction with the
    number_integer_t type) of the exactly supported range [0, UINT64_MAX],
    this class's integer type is interoperable.

    #### Storage

    Integer number values are stored directly inside a @ref basic_json type.

    @sa @ref number_float_t -- type for number values (floating-point)
    @sa @ref number_integer_t -- type for number values (integer)

    @since version 2.0.0
    */
    using number_unsigned_t = NumberUnsignedType;

    /*!
    @brief a type for a number (floating-point)

    [RFC 7159](http://rfc7159.net/rfc7159) describes numbers as follows:
    > The representation of numbers is similar to that used in most
    > programming languages. A number is represented in base 10 using decimal
    > digits. It contains an integer component that may be prefixed with an
    > optional minus sign, which may be followed by a fraction part and/or an
    > exponent part. Leading zeros are not allowed. (...) Numeric values that
    > cannot be represented in the grammar below (such as Infinity and NaN)
    > are not permitted.

    This description includes both integer and floating-point numbers.
    However, C++ allows more precise storage if it is known whether the number
    is a signed integer, an unsigned integer or a floating-point number.
    Therefore, three different types, @ref number_integer_t, @ref
    number_unsigned_t and @ref number_float_t are used.

    To store floating-point numbers in C++, a type is defined by the template
    parameter @a NumberFloatType which chooses the type to use.

    #### Default type

    With the default values for @a NumberFloatType (`double`), the default
    value for @a number_float_t is:

    @code {.cpp}
    double
    @endcode

    #### Default behavior

    - The restrictions about leading zeros is not enforced in C++. Instead,
      leading zeros in floating-point literals will be ignored. Internally,
      the value will be stored as decimal number. For instance, the C++
      floating-point literal `01.2` will be serialized to `1.2`. During
      deserialization, leading zeros yield an error.
    - Not-a-number (NaN) values will be serialized to `null`.

    #### Limits

    [RFC 7159](http://rfc7159.net/rfc7159) states:
    > This specification allows implementations to set limits on the range and
    > precision of numbers accepted. Since software that implements IEEE
    > 754-2008 binary64 (double precision) numbers is generally available and
    > widely used, good interoperability can be achieved by implementations
    > that expect no more precision or range than these provide, in the sense
    > that implementations will approximate JSON numbers within the expected
    > precision.

    This implementation does exactly follow this approach, as it uses double
    precision floating-point numbers. Note values smaller than
    `-1.79769313486232e+308` and values greater than `1.79769313486232e+308`
    will be stored as NaN internally and be serialized to `null`.

    #### Storage

    Floating-point number values are stored directly inside a @ref basic_json
    type.

    @sa @ref number_integer_t -- type for number values (integer)

    @sa @ref number_unsigned_t -- type for number values (unsigned integer)

    @since version 1.0.0
    */
    using number_float_t = NumberFloatType;

    /*!
    @brief a type for a packed binary type

    This type is a type designed to carry binary data that appears in various
    serialized formats, such as CBOR's Major Type 2, MessagePack's bin, and
    BSON's generic binary subtype. This type is NOT a part of standard JSON and
    exists solely for compatibility with these binary types. As such, it is
    simply defined as an ordered sequence of zero or more byte values.

    Additionally, as an implementation detail, the subtype of the binary data is
    carried around as a `std::uint8_t`, which is compatible with both of the
    binary data formats that use binary subtyping, (though the specific
    numbering is incompatible with each other, and it is up to the user to
    translate between them).

    [CBOR's RFC 7049](https://tools.ietf.org/html/rfc7049) describes this type
    as:
    > Major type 2: a byte string. The string's length in bytes is represented
    > following the rules for positive integers (major type 0).

    [MessagePack's documentation on the bin type
    family](https://github.com/msgpack/msgpack/blob/master/spec.md#bin-format-family)
    describes this type as:
    > Bin format family stores an byte array in 2, 3, or 5 bytes of extra bytes
    > in addition to the size of the byte array.

    [BSON's specifications](http://bsonspec.org/spec.html) describe several
    binary types; however, this type is intended to represent the generic binary
    type which has the description:
    > Generic binary subtype - This is the most commonly used binary subtype and
    > should be the 'default' for drivers and tools.

    None of these impose any limitations on the internal representation other
    than the basic unit of storage be some type of array whose parts are
    decomposable into bytes.

    The default representation of this binary format is a
    `std::vector<std::uint8_t>`, which is a very common way to represent a byte
    array in modern C++.

    #### Default type

    The default values for @a BinaryType is `std::vector<std::uint8_t>`

    #### Storage

    Binary Arrays are stored as pointers in a @ref basic_json type. That is,
    for any access to array values, a pointer of the type `binary_t*` must be
    dereferenced.

    #### Notes on subtypes

    - CBOR
       - Binary values are represented as byte strings. No subtypes are
         supported and will be ignored when CBOR is written.
    - MessagePack
       - If a subtype is given and the binary array contains exactly 1, 2, 4, 8,
         or 16 elements, the fixext family (fixext1, fixext2, fixext4, fixext8)
         is used. For other sizes, the ext family (ext8, ext16, ext32) is used.
         The subtype is then added as singed 8-bit integer.
       - If no subtype is given, the bin family (bin8, bin16, bin32) is used.
    - BSON
       - If a subtype is given, it is used and added as unsigned 8-bit integer.
       - If no subtype is given, the generic binary subtype 0x00 is used.

    @sa @ref binary -- create a binary array

    @since version 3.8.0
    */
    using binary_t = nlohmann::byte_container_with_subtype<BinaryType>;
    /// @}

  private:

    /// helper for exception-safe object creation
    template<typename T, typename... Args>
    JSON_HEDLEY_RETURNS_NON_NULL
    static T* create(Args&& ... args)
    {
        AllocatorType<T> alloc;
        using AllocatorTraits = std::allocator_traits<AllocatorType<T>>;

        auto deleter = [&](T * object)
        {
            AllocatorTraits::deallocate(alloc, object, 1);
        };
        std::unique_ptr<T, decltype(deleter)> object(AllocatorTraits::allocate(alloc, 1), deleter);
        AllocatorTraits::construct(alloc, object.get(), std::forward<Args>(args)...);
        JSON_ASSERT(object != nullptr);
        return object.release();
    }

    ////////////////////////
    // JSON value storage //
    ////////////////////////

    /*!
    @brief a JSON value

    The actual storage for a JSON value of the @ref basic_json class. This
    union combines the different storage types for the JSON value types
    defined in @ref value_t.

    JSON type | value_t type    | used type
    --------- | --------------- | ------------------------
    object    | object          | pointer to @ref object_t
    array     | array           | pointer to @ref array_t
    string    | string          | pointer to @ref string_t
    boolean   | boolean         | @ref boolean_t
    number    | number_integer  | @ref number_integer_t
    number    | number_unsigned | @ref number_unsigned_t
    number    | number_float    | @ref number_float_t
    binary    | binary          | pointer to @ref binary_t
    null      | null            | *no value is stored*

    @note Variable-length types (objects, arrays, and strings) are stored as
    pointers. The size of the union should not exceed 64 bits if the default
    value types are used.

    @since version 1.0.0
    */
    union json_value
    {
        /// object (stored with pointer to save storage)
        object_t* object;
        /// array (stored with pointer to save storage)
        array_t* array;
        /// string (stored with pointer to save storage)
        string_t* string;
        /// binary (stored with pointer to save storage)
        binary_t* binary;
        /// boolean
        boolean_t boolean;
        /// number (integer)
        number_integer_t number_integer;
        /// number (unsigned integer)
        number_unsigned_t number_unsigned;
        /// number (floating-point)
        number_float_t number_float;

        /// default constructor (for null values)
        json_value() = default;
        /// constructor for booleans
        json_value(boolean_t v) noexcept : boolean(v) {}
        /// constructor for numbers (integer)
        json_value(number_integer_t v) noexcept : number_integer(v) {}
        /// constructor for numbers (unsigned)
        json_value(number_unsigned_t v) noexcept : number_unsigned(v) {}
        /// constructor for numbers (floating-point)
        json_value(number_float_t v) noexcept : number_float(v) {}
        /// constructor for empty values of a given type
        json_value(value_t t)
        {
            switch (t)
            {
                case value_t::object:
                {
                    object = create<object_t>();
                    break;
                }

                case value_t::array:
                {
                    array = create<array_t>();
                    break;
                }

                case value_t::string:
                {
                    string = create<string_t>("");
                    break;
                }

                case value_t::binary:
                {
                    binary = create<binary_t>();
                    break;
                }

                case value_t::boolean:
                {
                    boolean = boolean_t(false);
                    break;
                }

                case value_t::number_integer:
                {
                    number_integer = number_integer_t(0);
                    break;
                }

                case value_t::number_unsigned:
                {
                    number_unsigned = number_unsigned_t(0);
                    break;
                }

                case value_t::number_float:
                {
                    number_float = number_float_t(0.0);
                    break;
                }

                case value_t::null:
                {
                    object = nullptr;  // silence warning, see #821
                    break;
                }

                default:
                {
                    object = nullptr;  // silence warning, see #821
                    if (JSON_HEDLEY_UNLIKELY(t == value_t::null))
                    {
                        JSON_THROW(other_error::create(500, "961c151d2e87f2686a955a9be24d316f1362bf21 3.9.1")); // LCOV_EXCL_LINE
                    }
                    break;
                }
            }
        }

        /// constructor for strings
        json_value(const string_t& value)
        {
            string = create<string_t>(value);
        }

        /// constructor for rvalue strings
        json_value(string_t&& value)
        {
            string = create<string_t>(std::move(value));
        }

        /// constructor for objects
        json_value(const object_t& value)
        {
            object = create<object_t>(value);
        }

        /// constructor for rvalue objects
        json_value(object_t&& value)
        {
            object = create<object_t>(std::move(value));
        }

        /// constructor for arrays
        json_value(const array_t& value)
        {
            array = create<array_t>(value);
        }

        /// constructor for rvalue arrays
        json_value(array_t&& value)
        {
            array = create<array_t>(std::move(value));
        }

        /// constructor for binary arrays
        json_value(const typename binary_t::container_type& value)
        {
            binary = create<binary_t>(value);
        }

        /// constructor for rvalue binary arrays
        json_value(typename binary_t::container_type&& value)
        {
            binary = create<binary_t>(std::move(value));
        }

        /// constructor for binary arrays (internal type)
        json_value(const binary_t& value)
        {
            binary = create<binary_t>(value);
        }

        /// constructor for rvalue binary arrays (internal type)
        json_value(binary_t&& value)
        {
            binary = create<binary_t>(std::move(value));
        }

        void destroy(value_t t) noexcept
        {
            // flatten the current json_value to a heap-allocated stack
            std::vector<basic_json> stack;

            // move the top-level items to stack
            if (t == value_t::array)
            {
                stack.reserve(array->size());
                std::move(array->begin(), array->end(), std::back_inserter(stack));
            }
            else if (t == value_t::object)
            {
                stack.reserve(object->size());
                for (auto&& it : *object)
                {
                    stack.push_back(std::move(it.second));
                }
            }

            while (!stack.empty())
            {
                // move the last item to local variable to be processed
                basic_json current_item(std::move(stack.back()));
                stack.pop_back();

                // if current_item is array/object, move
                // its children to the stack to be processed later
                if (current_item.is_array())
                {
                    std::move(current_item.m_value.array->begin(), current_item.m_value.array->end(),
                              std::back_inserter(stack));

                    current_item.m_value.array->clear();
                }
                else if (current_item.is_object())
                {
                    for (auto&& it : *current_item.m_value.object)
                    {
                        stack.push_back(std::move(it.second));
                    }

                    current_item.m_value.object->clear();
                }

                // it's now safe that current_item get destructed
                // since it doesn't have any children
            }

            switch (t)
            {
                case value_t::object:
                {
                    AllocatorType<object_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, object);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, object, 1);
                    break;
                }

                case value_t::array:
                {
                    AllocatorType<array_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, array);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, array, 1);
                    break;
                }

                case value_t::string:
                {
                    AllocatorType<string_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, string);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, string, 1);
                    break;
                }

                case value_t::binary:
                {
                    AllocatorType<binary_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, binary);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, binary, 1);
                    break;
                }

                default:
                {
                    break;
                }
            }
        }
    };

    /*!
    @brief checks the class invariants

    This function asserts the class invariants. It needs to be called at the
    end of every constructor to make sure that created objects respect the
    invariant. Furthermore, it has to be called each time the type of a JSON
    value is changed, because the invariant expresses a relationship between
    @a m_type and @a m_value.
    */
    void assert_invariant() const noexcept
    {
        JSON_ASSERT(m_type != value_t::object || m_value.object != nullptr);
        JSON_ASSERT(m_type != value_t::array || m_value.array != nullptr);
        JSON_ASSERT(m_type != value_t::string || m_value.string != nullptr);
        JSON_ASSERT(m_type != value_t::binary || m_value.binary != nullptr);
    }

  public:
    //////////////////////////
    // JSON parser callback //
    //////////////////////////

    /*!
    @brief parser event types

    The parser callback distinguishes the following events:
    - `object_start`: the parser read `{` and started to process a JSON object
    - `key`: the parser read a key of a value in an object
    - `object_end`: the parser read `}` and finished processing a JSON object
    - `array_start`: the parser read `[` and started to process a JSON array
    - `array_end`: the parser read `]` and finished processing a JSON array
    - `value`: the parser finished reading a JSON value

    @image html callback_events.png "Example when certain parse events are triggered"

    @sa @ref parser_callback_t for more information and examples
    */
    using parse_event_t = detail::parse_event_t;

    /*!
    @brief per-element parser callback type

    With a parser callback function, the result of parsing a JSON text can be
    influenced. When passed to @ref parse, it is called on certain events
    (passed as @ref parse_event_t via parameter @a event) with a set recursion
    depth @a depth and context JSON value @a parsed. The return value of the
    callback function is a boolean indicating whether the element that emitted
    the callback shall be kept or not.

    We distinguish six scenarios (determined by the event type) in which the
    callback function can be called. The following table describes the values
    of the parameters @a depth, @a event, and @a parsed.

    parameter @a event | description | parameter @a depth | parameter @a parsed
    ------------------ | ----------- | ------------------ | -------------------
    parse_event_t::object_start | the parser read `{` and started to process a JSON object | depth of the parent of the JSON object | a JSON value with type discarded
    parse_event_t::key | the parser read a key of a value in an object | depth of the currently parsed JSON object | a JSON string containing the key
    parse_event_t::object_end | the parser read `}` and finished processing a JSON object | depth of the parent of the JSON object | the parsed JSON object
    parse_event_t::array_start | the parser read `[` and started to process a JSON array | depth of the parent of the JSON array | a JSON value with type discarded
    parse_event_t::array_end | the parser read `]` and finished processing a JSON array | depth of the parent of the JSON array | the parsed JSON array
    parse_event_t::value | the parser finished reading a JSON value | depth of the value | the parsed JSON value

    @image html callback_events.png "Example when certain parse events are triggered"

    Discarding a value (i.e., returning `false`) has different effects
    depending on the context in which function was called:

    - Discarded values in structured types are skipped. That is, the parser
      will behave as if the discarded value was never read.
    - In case a value outside a structured type is skipped, it is replaced
      with `null`. This case happens if the top-level element is skipped.

    @param[in] depth  the depth of the recursion during parsing

    @param[in] event  an event of type parse_event_t indicating the context in
    the callback function has been called

    @param[in,out] parsed  the current intermediate parse result; note that
    writing to this value has no effect for parse_event_t::key events

    @return Whether the JSON value which called the function during parsing
    should be kept (`true`) or not (`false`). In the latter case, it is either
    skipped completely or replaced by an empty discarded object.

    @sa @ref parse for examples

    @since version 1.0.0
    */
    using parser_callback_t = detail::parser_callback_t<basic_json>;

    //////////////////
    // constructors //
    //////////////////

    /// @name constructors and destructors
    /// Constructors of class @ref basic_json, copy/move constructor, copy
    /// assignment, static functions creating objects, and the destructor.
    /// @{

    /*!
    @brief create an empty value with a given type

    Create an empty JSON value with a given type. The value will be default
    initialized with an empty value which depends on the type:

    Value type  | initial value
    ----------- | -------------
    null        | `null`
    boolean     | `false`
    string      | `""`
    number      | `0`
    object      | `{}`
    array       | `[]`
    binary      | empty array

    @param[in] v  the type of the value to create

    @complexity Constant.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The following code shows the constructor for different @ref
    value_t values,basic_json__value_t}

    @sa @ref clear() -- restores the postcondition of this constructor

    @since version 1.0.0
    */
    basic_json(const value_t v)
        : m_type(v), m_value(v)
    {
        assert_invariant();
    }

    /*!
    @brief create a null object

    Create a `null` JSON value. It either takes a null pointer as parameter
    (explicitly creating `null`) or no parameter (implicitly creating `null`).
    The passed null pointer itself is not read -- it is only used to choose
    the right constructor.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this constructor never throws
    exceptions.

    @liveexample{The following code shows the constructor with and without a
    null pointer parameter.,basic_json__nullptr_t}

    @since version 1.0.0
    */
    basic_json(std::nullptr_t = nullptr) noexcept
        : basic_json(value_t::null)
    {
        assert_invariant();
    }

    /*!
    @brief create a JSON value

    This is a "catch all" constructor for all compatible JSON types; that is,
    types for which a `to_json()` method exists. The constructor forwards the
    parameter @a val to that method (to `json_serializer<U>::to_json` method
    with `U = uncvref_t<CompatibleType>`, to be exact).

    Template type @a CompatibleType includes, but is not limited to, the
    following types:
    - **arrays**: @ref array_t and all kinds of compatible containers such as
      `std::vector`, `std::deque`, `std::list`, `std::forward_list`,
      `std::array`, `std::valarray`, `std::set`, `std::unordered_set`,
      `std::multiset`, and `std::unordered_multiset` with a `value_type` from
      which a @ref basic_json value can be constructed.
    - **objects**: @ref object_t and all kinds of compatible associative
      containers such as `std::map`, `std::unordered_map`, `std::multimap`,
      and `std::unordered_multimap` with a `key_type` compatible to
      @ref string_t and a `value_type` from which a @ref basic_json value can
      be constructed.
    - **strings**: @ref string_t, string literals, and all compatible string
      containers can be used.
    - **numbers**: @ref number_integer_t, @ref number_unsigned_t,
      @ref number_float_t, and all convertible number types such as `int`,
      `size_t`, `int64_t`, `float` or `double` can be used.
    - **boolean**: @ref boolean_t / `bool` can be used.
    - **binary**: @ref binary_t / `std::vector<uint8_t>` may be used,
      unfortunately because string literals cannot be distinguished from binary
      character arrays by the C++ type system, all types compatible with `const
      char*` will be directed to the string constructor instead.  This is both
      for backwards compatibility, and due to the fact that a binary type is not
      a standard JSON type.

    See the examples below.

    @tparam CompatibleType a type such that:
    - @a CompatibleType is not derived from `std::istream`,
    - @a CompatibleType is not @ref basic_json (to avoid hijacking copy/move
         constructors),
    - @a CompatibleType is not a different @ref basic_json type (i.e. with different template arguments)
    - @a CompatibleType is not a @ref basic_json nested type (e.g.,
         @ref json_pointer, @ref iterator, etc ...)
    - @ref @ref json_serializer<U> has a
         `to_json(basic_json_t&, CompatibleType&&)` method

    @tparam U = `uncvref_t<CompatibleType>`

    @param[in] val the value to be forwarded to the respective constructor

    @complexity Usually linear in the size of the passed @a val, also
                depending on the implementation of the called `to_json()`
                method.

    @exceptionsafety Depends on the called constructor. For types directly
    supported by the library (i.e., all types for which no `to_json()` function
    was provided), strong guarantee holds: if an exception is thrown, there are
    no changes to any JSON value.

    @liveexample{The following code shows the constructor with several
    compatible types.,basic_json__CompatibleType}

    @since version 2.1.0
    */
    template < typename CompatibleType,
               typename U = detail::uncvref_t<CompatibleType>,
               detail::enable_if_t <
                   !detail::is_basic_json<U>::value && detail::is_compatible_type<basic_json_t, U>::value, int > = 0 >
    basic_json(CompatibleType && val) noexcept(noexcept(
                JSONSerializer<U>::to_json(std::declval<basic_json_t&>(),
                                           std::forward<CompatibleType>(val))))
    {
        JSONSerializer<U>::to_json(*this, std::forward<CompatibleType>(val));
        assert_invariant();
    }

    /*!
    @brief create a JSON value from an existing one

    This is a constructor for existing @ref basic_json types.
    It does not hijack copy/move constructors, since the parameter has different
    template arguments than the current ones.

    The constructor tries to convert the internal @ref m_value of the parameter.

    @tparam BasicJsonType a type such that:
    - @a BasicJsonType is a @ref basic_json type.
    - @a BasicJsonType has different template arguments than @ref basic_json_t.

    @param[in] val the @ref basic_json value to be converted.

    @complexity Usually linear in the size of the passed @a val, also
                depending on the implementation of the called `to_json()`
                method.

    @exceptionsafety Depends on the called constructor. For types directly
    supported by the library (i.e., all types for which no `to_json()` function
    was provided), strong guarantee holds: if an exception is thrown, there are
    no changes to any JSON value.

    @since version 3.2.0
    */
    template < typename BasicJsonType,
               detail::enable_if_t <
                   detail::is_basic_json<BasicJsonType>::value&& !std::is_same<basic_json, BasicJsonType>::value, int > = 0 >
    basic_json(const BasicJsonType& val)
    {
        using other_boolean_t = typename BasicJsonType::boolean_t;
        using other_number_float_t = typename BasicJsonType::number_float_t;
        using other_number_integer_t = typename BasicJsonType::number_integer_t;
        using other_number_unsigned_t = typename BasicJsonType::number_unsigned_t;
        using other_string_t = typename BasicJsonType::string_t;
        using other_object_t = typename BasicJsonType::object_t;
        using other_array_t = typename BasicJsonType::array_t;
        using other_binary_t = typename BasicJsonType::binary_t;

        switch (val.type())
        {
            case value_t::boolean:
                JSONSerializer<other_boolean_t>::to_json(*this, val.template get<other_boolean_t>());
                break;
            case value_t::number_float:
                JSONSerializer<other_number_float_t>::to_json(*this, val.template get<other_number_float_t>());
                break;
            case value_t::number_integer:
                JSONSerializer<other_number_integer_t>::to_json(*this, val.template get<other_number_integer_t>());
                break;
            case value_t::number_unsigned:
                JSONSerializer<other_number_unsigned_t>::to_json(*this, val.template get<other_number_unsigned_t>());
                break;
            case value_t::string:
                JSONSerializer<other_string_t>::to_json(*this, val.template get_ref<const other_string_t&>());
                break;
            case value_t::object:
                JSONSerializer<other_object_t>::to_json(*this, val.template get_ref<const other_object_t&>());
                break;
            case value_t::array:
                JSONSerializer<other_array_t>::to_json(*this, val.template get_ref<const other_array_t&>());
                break;
            case value_t::binary:
                JSONSerializer<other_binary_t>::to_json(*this, val.template get_ref<const other_binary_t&>());
                break;
            case value_t::null:
                *this = nullptr;
                break;
            case value_t::discarded:
                m_type = value_t::discarded;
                break;
            default:            // LCOV_EXCL_LINE
                JSON_ASSERT(false);  // LCOV_EXCL_LINE
        }
        assert_invariant();
    }

    /*!
    @brief create a container (array or object) from an initializer list

    Creates a JSON value of type array or object from the passed initializer
    list @a init. In case @a type_deduction is `true` (default), the type of
    the JSON value to be created is deducted from the initializer list @a init
    according to the following rules:

    1. If the list is empty, an empty JSON object value `{}` is created.
    2. If the list consists of pairs whose first element is a string, a JSON
       object value is created where the first elements of the pairs are
       treated as keys and the second elements are as values.
    3. In all other cases, an array is created.

    The rules aim to create the best fit between a C++ initializer list and
    JSON values. The rationale is as follows:

    1. The empty initializer list is written as `{}` which is exactly an empty
       JSON object.
    2. C++ has no way of describing mapped types other than to list a list of
       pairs. As JSON requires that keys must be of type string, rule 2 is the
       weakest constraint one can pose on initializer lists to interpret them
       as an object.
    3. In all other cases, the initializer list could not be interpreted as
       JSON object type, so interpreting it as JSON array type is safe.

    With the rules described above, the following JSON values cannot be
    expressed by an initializer list:

    - the empty array (`[]`): use @ref array(initializer_list_t)
      with an empty initializer list in this case
    - arrays whose elements satisfy rule 2: use @ref
      array(initializer_list_t) with the same initializer list
      in this case

    @note When used without parentheses around an empty initializer list, @ref
    basic_json() is called instead of this function, yielding the JSON null
    value.

    @param[in] init  initializer list with JSON values

    @param[in] type_deduction internal parameter; when set to `true`, the type
    of the JSON value is deducted from the initializer list @a init; when set
    to `false`, the type provided via @a manual_type is forced. This mode is
    used by the functions @ref array(initializer_list_t) and
    @ref object(initializer_list_t).

    @param[in] manual_type internal parameter; when @a type_deduction is set
    to `false`, the created JSON value will use the provided type (only @ref
    value_t::array and @ref value_t::object are valid); when @a type_deduction
    is set to `true`, this parameter has no effect

    @throw type_error.301 if @a type_deduction is `false`, @a manual_type is
    `value_t::object`, but @a init contains an element which is not a pair
    whose first element is a string. In this case, the constructor could not
    create an object. If @a type_deduction would have be `true`, an array
    would have been created. See @ref object(initializer_list_t)
    for an example.

    @complexity Linear in the size of the initializer list @a init.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The example below shows how JSON values are created from
    initializer lists.,basic_json__list_init_t}

    @sa @ref array(initializer_list_t) -- create a JSON array
    value from an initializer list
    @sa @ref object(initializer_list_t) -- create a JSON object
    value from an initializer list

    @since version 1.0.0
    */
    basic_json(initializer_list_t init,
               bool type_deduction = true,
               value_t manual_type = value_t::array)
    {
        // check if each element is an array with two elements whose first
        // element is a string
        bool is_an_object = std::all_of(init.begin(), init.end(),
                                        [](const detail::json_ref<basic_json>& element_ref)
        {
            return element_ref->is_array() && element_ref->size() == 2 && (*element_ref)[0].is_string();
        });

        // adjust type if type deduction is not wanted
        if (!type_deduction)
        {
            // if array is wanted, do not create an object though possible
            if (manual_type == value_t::array)
            {
                is_an_object = false;
            }

            // if object is wanted but impossible, throw an exception
            if (JSON_HEDLEY_UNLIKELY(manual_type == value_t::object && !is_an_object))
            {
                JSON_THROW(type_error::create(301, "cannot create object from initializer list"));
            }
        }

        if (is_an_object)
        {
            // the initializer list is a list of pairs -> create object
            m_type = value_t::object;
            m_value = value_t::object;

            std::for_each(init.begin(), init.end(), [this](const detail::json_ref<basic_json>& element_ref)
            {
                auto element = element_ref.moved_or_copied();
                m_value.object->emplace(
                    std::move(*((*element.m_value.array)[0].m_value.string)),
                    std::move((*element.m_value.array)[1]));
            });
        }
        else
        {
            // the initializer list describes an array -> create array
            m_type = value_t::array;
            m_value.array = create<array_t>(init.begin(), init.end());
        }

        assert_invariant();
    }

    /*!
    @brief explicitly create a binary array (without subtype)

    Creates a JSON binary array value from a given binary container. Binary
    values are part of various binary formats, such as CBOR, MessagePack, and
    BSON. This constructor is used to create a value for serialization to those
    formats.

    @note Note, this function exists because of the difficulty in correctly
    specifying the correct template overload in the standard value ctor, as both
    JSON arrays and JSON binary arrays are backed with some form of a
    `std::vector`. Because JSON binary arrays are a non-standard extension it
    was decided that it would be best to prevent automatic initialization of a
    binary array type, for backwards compatibility and so it does not happen on
    accident.

    @param[in] init container containing bytes to use as binary type

    @return JSON binary array value

    @complexity Linear in the size of @a init.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @since version 3.8.0
    */
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json binary(const typename binary_t::container_type& init)
    {
        auto res = basic_json();
        res.m_type = value_t::binary;
        res.m_value = init;
        return res;
    }

    /*!
    @brief explicitly create a binary array (with subtype)

    Creates a JSON binary array value from a given binary container. Binary
    values are part of various binary formats, such as CBOR, MessagePack, and
    BSON. This constructor is used to create a value for serialization to those
    formats.

    @note Note, this function exists because of the difficulty in correctly
    specifying the correct template overload in the standard value ctor, as both
    JSON arrays and JSON binary arrays are backed with some form of a
    `std::vector`. Because JSON binary arrays are a non-standard extension it
    was decided that it would be best to prevent automatic initialization of a
    binary array type, for backwards compatibility and so it does not happen on
    accident.

    @param[in] init container containing bytes to use as binary type
    @param[in] subtype subtype to use in MessagePack and BSON

    @return JSON binary array value

    @complexity Linear in the size of @a init.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @since version 3.8.0
    */
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json binary(const typename binary_t::container_type& init, std::uint8_t subtype)
    {
        auto res = basic_json();
        res.m_type = value_t::binary;
        res.m_value = binary_t(init, subtype);
        return res;
    }

    /// @copydoc binary(const typename binary_t::container_type&)
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json binary(typename binary_t::container_type&& init)
    {
        auto res = basic_json();
        res.m_type = value_t::binary;
        res.m_value = std::move(init);
        return res;
    }

    /// @copydoc binary(const typename binary_t::container_type&, std::uint8_t)
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json binary(typename binary_t::container_type&& init, std::uint8_t subtype)
    {
        auto res = basic_json();
        res.m_type = value_t::binary;
        res.m_value = binary_t(std::move(init), subtype);
        return res;
    }

    /*!
    @brief explicitly create an array from an initializer list

    Creates a JSON array value from a given initializer list. That is, given a
    list of values `a, b, c`, creates the JSON value `[a, b, c]`. If the
    initializer list is empty, the empty array `[]` is created.

    @note This function is only needed to express two edge cases that cannot
    be realized with the initializer list constructor (@ref
    basic_json(initializer_list_t, bool, value_t)). These cases
    are:
    1. creating an array whose elements are all pairs whose first element is a
    string -- in this case, the initializer list constructor would create an
    object, taking the first elements as keys
    2. creating an empty array -- passing the empty initializer list to the
    initializer list constructor yields an empty object

    @param[in] init  initializer list with JSON values to create an array from
    (optional)

    @return JSON array value

    @complexity Linear in the size of @a init.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The following code shows an example for the `array`
    function.,array}

    @sa @ref basic_json(initializer_list_t, bool, value_t) --
    create a JSON value from an initializer list
    @sa @ref object(initializer_list_t) -- create a JSON object
    value from an initializer list

    @since version 1.0.0
    */
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json array(initializer_list_t init = {})
    {
        return basic_json(init, false, value_t::array);
    }

    /*!
    @brief explicitly create an object from an initializer list

    Creates a JSON object value from a given initializer list. The initializer
    lists elements must be pairs, and their first elements must be strings. If
    the initializer list is empty, the empty object `{}` is created.

    @note This function is only added for symmetry reasons. In contrast to the
    related function @ref array(initializer_list_t), there are
    no cases which can only be expressed by this function. That is, any
    initializer list @a init can also be passed to the initializer list
    constructor @ref basic_json(initializer_list_t, bool, value_t).

    @param[in] init  initializer list to create an object from (optional)

    @return JSON object value

    @throw type_error.301 if @a init is not a list of pairs whose first
    elements are strings. In this case, no object can be created. When such a
    value is passed to @ref basic_json(initializer_list_t, bool, value_t),
    an array would have been created from the passed initializer list @a init.
    See example below.

    @complexity Linear in the size of @a init.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The following code shows an example for the `object`
    function.,object}

    @sa @ref basic_json(initializer_list_t, bool, value_t) --
    create a JSON value from an initializer list
    @sa @ref array(initializer_list_t) -- create a JSON array
    value from an initializer list

    @since version 1.0.0
    */
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json object(initializer_list_t init = {})
    {
        return basic_json(init, false, value_t::object);
    }

    /*!
    @brief construct an array with count copies of given value

    Constructs a JSON array value by creating @a cnt copies of a passed value.
    In case @a cnt is `0`, an empty array is created.

    @param[in] cnt  the number of JSON copies of @a val to create
    @param[in] val  the JSON value to copy

    @post `std::distance(begin(),end()) == cnt` holds.

    @complexity Linear in @a cnt.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The following code shows examples for the @ref
    basic_json(size_type\, const basic_json&)
    constructor.,basic_json__size_type_basic_json}

    @since version 1.0.0
    */
    basic_json(size_type cnt, const basic_json& val)
        : m_type(value_t::array)
    {
        m_value.array = create<array_t>(cnt, val);
        assert_invariant();
    }

    /*!
    @brief construct a JSON container given an iterator range

    Constructs the JSON value with the contents of the range `[first, last)`.
    The semantics depends on the different types a JSON value can have:
    - In case of a null type, invalid_iterator.206 is thrown.
    - In case of other primitive types (number, boolean, or string), @a first
      must be `begin()` and @a last must be `end()`. In this case, the value is
      copied. Otherwise, invalid_iterator.204 is thrown.
    - In case of structured types (array, object), the constructor behaves as
      similar versions for `std::vector` or `std::map`; that is, a JSON array
      or object is constructed from the values in the range.

    @tparam InputIT an input iterator type (@ref iterator or @ref
    const_iterator)

    @param[in] first begin of the range to copy from (included)
    @param[in] last end of the range to copy from (excluded)

    @pre Iterators @a first and @a last must be initialized. **This
         precondition is enforced with an assertion (see warning).** If
         assertions are switched off, a violation of this precondition yields
         undefined behavior.

    @pre Range `[first, last)` is valid. Usually, this precondition cannot be
         checked efficiently. Only certain edge cases are detected; see the
         description of the exceptions below. A violation of this precondition
         yields undefined behavior.

    @warning A precondition is enforced with a runtime assertion that will
             result in calling `std::abort` if this precondition is not met.
             Assertions can be disabled by defining `NDEBUG` at compile time.
             See https://en.cppreference.com/w/cpp/error/assert for more
             information.

    @throw invalid_iterator.201 if iterators @a first and @a last are not
    compatible (i.e., do not belong to the same JSON value). In this case,
    the range `[first, last)` is undefined.
    @throw invalid_iterator.204 if iterators @a first and @a last belong to a
    primitive type (number, boolean, or string), but @a first does not point
    to the first element any more. In this case, the range `[first, last)` is
    undefined. See example code below.
    @throw invalid_iterator.206 if iterators @a first and @a last belong to a
    null value. In this case, the range `[first, last)` is undefined.

    @complexity Linear in distance between @a first and @a last.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The example below shows several ways to create JSON values by
    specifying a subrange with iterators.,basic_json__InputIt_InputIt}

    @since version 1.0.0
    */
    template < class InputIT, typename std::enable_if <
                   std::is_same<InputIT, typename basic_json_t::iterator>::value ||
                   std::is_same<InputIT, typename basic_json_t::const_iterator>::value, int >::type = 0 >
    basic_json(InputIT first, InputIT last)
    {
        JSON_ASSERT(first.m_object != nullptr);
        JSON_ASSERT(last.m_object != nullptr);

        // make sure iterator fits the current value
        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(201, "iterators are not compatible"));
        }

        // copy type from first iterator
        m_type = first.m_object->m_type;

        // check if iterator range is complete for primitive values
        switch (m_type)
        {
            case value_t::boolean:
            case value_t::number_float:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::string:
            {
                if (JSON_HEDLEY_UNLIKELY(!first.m_it.primitive_iterator.is_begin()
                                         || !last.m_it.primitive_iterator.is_end()))
                {
                    JSON_THROW(invalid_iterator::create(204, "iterators out of range"));
                }
                break;
            }

            default:
                break;
        }

        switch (m_type)
        {
            case value_t::number_integer:
            {
                m_value.number_integer = first.m_object->m_value.number_integer;
                break;
            }

            case value_t::number_unsigned:
            {
                m_value.number_unsigned = first.m_object->m_value.number_unsigned;
                break;
            }

            case value_t::number_float:
            {
                m_value.number_float = first.m_object->m_value.number_float;
                break;
            }

            case value_t::boolean:
            {
                m_value.boolean = first.m_object->m_value.boolean;
                break;
            }

            case value_t::string:
            {
                m_value = *first.m_object->m_value.string;
                break;
            }

            case value_t::object:
            {
                m_value.object = create<object_t>(first.m_it.object_iterator,
                                                  last.m_it.object_iterator);
                break;
            }

            case value_t::array:
            {
                m_value.array = create<array_t>(first.m_it.array_iterator,
                                                last.m_it.array_iterator);
                break;
            }

            case value_t::binary:
            {
                m_value = *first.m_object->m_value.binary;
                break;
            }

            default:
                JSON_THROW(invalid_iterator::create(206, "cannot construct with iterators from " +
                                                    std::string(first.m_object->type_name())));
        }

        assert_invariant();
    }


    ///////////////////////////////////////
    // other constructors and destructor //
    ///////////////////////////////////////

    template<typename JsonRef,
             detail::enable_if_t<detail::conjunction<detail::is_json_ref<JsonRef>,
                                 std::is_same<typename JsonRef::value_type, basic_json>>::value, int> = 0 >
    basic_json(const JsonRef& ref) : basic_json(ref.moved_or_copied()) {}

    /*!
    @brief copy constructor

    Creates a copy of a given JSON value.

    @param[in] other  the JSON value to copy

    @post `*this == other`

    @complexity Linear in the size of @a other.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is linear.
    - As postcondition, it holds: `other == basic_json(other)`.

    @liveexample{The following code shows an example for the copy
    constructor.,basic_json__basic_json}

    @since version 1.0.0
    */
    basic_json(const basic_json& other)
        : m_type(other.m_type)
    {
        // check of passed value is valid
        other.assert_invariant();

        switch (m_type)
        {
            case value_t::object:
            {
                m_value = *other.m_value.object;
                break;
            }

            case value_t::array:
            {
                m_value = *other.m_value.array;
                break;
            }

            case value_t::string:
            {
                m_value = *other.m_value.string;
                break;
            }

            case value_t::boolean:
            {
                m_value = other.m_value.boolean;
                break;
            }

            case value_t::number_integer:
            {
                m_value = other.m_value.number_integer;
                break;
            }

            case value_t::number_unsigned:
            {
                m_value = other.m_value.number_unsigned;
                break;
            }

            case value_t::number_float:
            {
                m_value = other.m_value.number_float;
                break;
            }

            case value_t::binary:
            {
                m_value = *other.m_value.binary;
                break;
            }

            default:
                break;
        }

        assert_invariant();
    }

    /*!
    @brief move constructor

    Move constructor. Constructs a JSON value with the contents of the given
    value @a other using move semantics. It "steals" the resources from @a
    other and leaves it as JSON null value.

    @param[in,out] other  value to move to this object

    @post `*this` has the same value as @a other before the call.
    @post @a other is a JSON null value.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this constructor never throws
    exceptions.

    @requirement This function helps `basic_json` satisfying the
    [MoveConstructible](https://en.cppreference.com/w/cpp/named_req/MoveConstructible)
    requirements.

    @liveexample{The code below shows the move constructor explicitly called
    via std::move.,basic_json__moveconstructor}

    @since version 1.0.0
    */
    basic_json(basic_json&& other) noexcept
        : m_type(std::move(other.m_type)),
          m_value(std::move(other.m_value))
    {
        // check that passed value is valid
        other.assert_invariant();

        // invalidate payload
        other.m_type = value_t::null;
        other.m_value = {};

        assert_invariant();
    }

    /*!
    @brief copy assignment

    Copy assignment operator. Copies a JSON value via the "copy and swap"
    strategy: It is expressed in terms of the copy constructor, destructor,
    and the `swap()` member function.

    @param[in] other  value to copy from

    @complexity Linear.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is linear.

    @liveexample{The code below shows and example for the copy assignment. It
    creates a copy of value `a` which is then swapped with `b`. Finally\, the
    copy of `a` (which is the null value after the swap) is
    destroyed.,basic_json__copyassignment}

    @since version 1.0.0
    */
    basic_json& operator=(basic_json other) noexcept (
        std::is_nothrow_move_constructible<value_t>::value&&
        std::is_nothrow_move_assignable<value_t>::value&&
        std::is_nothrow_move_constructible<json_value>::value&&
        std::is_nothrow_move_assignable<json_value>::value
    )
    {
        // check that passed value is valid
        other.assert_invariant();

        using std::swap;
        swap(m_type, other.m_type);
        swap(m_value, other.m_value);

        assert_invariant();
        return *this;
    }

    /*!
    @brief destructor

    Destroys the JSON value and frees all allocated memory.

    @complexity Linear.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is linear.
    - All stored elements are destroyed and all memory is freed.

    @since version 1.0.0
    */
    ~basic_json() noexcept
    {
        assert_invariant();
        m_value.destroy(m_type);
    }

    /// @}

  public:
    ///////////////////////
    // object inspection //
    ///////////////////////

    /// @name object inspection
    /// Functions to inspect the type of a JSON value.
    /// @{

    /*!
    @brief serialization

    Serialization function for JSON values. The function tries to mimic
    Python's `json.dumps()` function, and currently supports its @a indent
    and @a ensure_ascii parameters.

    @param[in] indent If indent is nonnegative, then array elements and object
    members will be pretty-printed with that indent level. An indent level of
    `0` will only insert newlines. `-1` (the default) selects the most compact
    representation.
    @param[in] indent_char The character to use for indentation if @a indent is
    greater than `0`. The default is ` ` (space).
    @param[in] ensure_ascii If @a ensure_ascii is true, all non-ASCII characters
    in the output are escaped with `\uXXXX` sequences, and the result consists
    of ASCII characters only.
    @param[in] error_handler  how to react on decoding errors; there are three
    possible values: `strict` (throws and exception in case a decoding error
    occurs; default), `replace` (replace invalid UTF-8 sequences with U+FFFD),
    and `ignore` (ignore invalid UTF-8 sequences during serialization; all
    bytes are copied to the output unchanged).

    @return string containing the serialization of the JSON value

    @throw type_error.316 if a string stored inside the JSON value is not
                          UTF-8 encoded and @a error_handler is set to strict

    @note Binary values are serialized as object containing two keys:
      - "bytes": an array of bytes as integers
      - "subtype": the subtype as integer or "null" if the binary has no subtype

    @complexity Linear.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @liveexample{The following example shows the effect of different @a indent\,
    @a indent_char\, and @a ensure_ascii parameters to the result of the
    serialization.,dump}

    @see https://docs.python.org/2/library/json.html#json.dump

    @since version 1.0.0; indentation character @a indent_char, option
           @a ensure_ascii and exceptions added in version 3.0.0; error
           handlers added in version 3.4.0; serialization of binary values added
           in version 3.8.0.
    */
    string_t dump(const int indent = -1,
                  const char indent_char = ' ',
                  const bool ensure_ascii = false,
                  const error_handler_t error_handler = error_handler_t::strict) const
    {
        string_t result;
        serializer s(detail::output_adapter<char, string_t>(result), indent_char, error_handler);

        if (indent >= 0)
        {
            s.dump(*this, true, ensure_ascii, static_cast<unsigned int>(indent));
        }
        else
        {
            s.dump(*this, false, ensure_ascii, 0);
        }

        return result;
    }

    /*!
    @brief return the type of the JSON value (explicit)

    Return the type of the JSON value as a value from the @ref value_t
    enumeration.

    @return the type of the JSON value
            Value type                | return value
            ------------------------- | -------------------------
            null                      | value_t::null
            boolean                   | value_t::boolean
            string                    | value_t::string
            number (integer)          | value_t::number_integer
            number (unsigned integer) | value_t::number_unsigned
            number (floating-point)   | value_t::number_float
            object                    | value_t::object
            array                     | value_t::array
            binary                    | value_t::binary
            discarded                 | value_t::discarded

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `type()` for all JSON
    types.,type}

    @sa @ref operator value_t() -- return the type of the JSON value (implicit)
    @sa @ref type_name() -- return the type as string

    @since version 1.0.0
    */
    constexpr value_t type() const noexcept
    {
        return m_type;
    }

    /*!
    @brief return whether type is primitive

    This function returns true if and only if the JSON type is primitive
    (string, number, boolean, or null).

    @return `true` if type is primitive (string, number, boolean, or null),
    `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_primitive()` for all JSON
    types.,is_primitive}

    @sa @ref is_structured() -- returns whether JSON value is structured
    @sa @ref is_null() -- returns whether JSON value is `null`
    @sa @ref is_string() -- returns whether JSON value is a string
    @sa @ref is_boolean() -- returns whether JSON value is a boolean
    @sa @ref is_number() -- returns whether JSON value is a number
    @sa @ref is_binary() -- returns whether JSON value is a binary array

    @since version 1.0.0
    */
    constexpr bool is_primitive() const noexcept
    {
        return is_null() || is_string() || is_boolean() || is_number() || is_binary();
    }

    /*!
    @brief return whether type is structured

    This function returns true if and only if the JSON type is structured
    (array or object).

    @return `true` if type is structured (array or object), `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_structured()` for all JSON
    types.,is_structured}

    @sa @ref is_primitive() -- returns whether value is primitive
    @sa @ref is_array() -- returns whether value is an array
    @sa @ref is_object() -- returns whether value is an object

    @since version 1.0.0
    */
    constexpr bool is_structured() const noexcept
    {
        return is_array() || is_object();
    }

    /*!
    @brief return whether value is null

    This function returns true if and only if the JSON value is null.

    @return `true` if type is null, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_null()` for all JSON
    types.,is_null}

    @since version 1.0.0
    */
    constexpr bool is_null() const noexcept
    {
        return m_type == value_t::null;
    }

    /*!
    @brief return whether value is a boolean

    This function returns true if and only if the JSON value is a boolean.

    @return `true` if type is boolean, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_boolean()` for all JSON
    types.,is_boolean}

    @since version 1.0.0
    */
    constexpr bool is_boolean() const noexcept
    {
        return m_type == value_t::boolean;
    }

    /*!
    @brief return whether value is a number

    This function returns true if and only if the JSON value is a number. This
    includes both integer (signed and unsigned) and floating-point values.

    @return `true` if type is number (regardless whether integer, unsigned
    integer or floating-type), `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_number()` for all JSON
    types.,is_number}

    @sa @ref is_number_integer() -- check if value is an integer or unsigned
    integer number
    @sa @ref is_number_unsigned() -- check if value is an unsigned integer
    number
    @sa @ref is_number_float() -- check if value is a floating-point number

    @since version 1.0.0
    */
    constexpr bool is_number() const noexcept
    {
        return is_number_integer() || is_number_float();
    }

    /*!
    @brief return whether value is an integer number

    This function returns true if and only if the JSON value is a signed or
    unsigned integer number. This excludes floating-point values.

    @return `true` if type is an integer or unsigned integer number, `false`
    otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_number_integer()` for all
    JSON types.,is_number_integer}

    @sa @ref is_number() -- check if value is a number
    @sa @ref is_number_unsigned() -- check if value is an unsigned integer
    number
    @sa @ref is_number_float() -- check if value is a floating-point number

    @since version 1.0.0
    */
    constexpr bool is_number_integer() const noexcept
    {
        return m_type == value_t::number_integer || m_type == value_t::number_unsigned;
    }

    /*!
    @brief return whether value is an unsigned integer number

    This function returns true if and only if the JSON value is an unsigned
    integer number. This excludes floating-point and signed integer values.

    @return `true` if type is an unsigned integer number, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_number_unsigned()` for all
    JSON types.,is_number_unsigned}

    @sa @ref is_number() -- check if value is a number
    @sa @ref is_number_integer() -- check if value is an integer or unsigned
    integer number
    @sa @ref is_number_float() -- check if value is a floating-point number

    @since version 2.0.0
    */
    constexpr bool is_number_unsigned() const noexcept
    {
        return m_type == value_t::number_unsigned;
    }

    /*!
    @brief return whether value is a floating-point number

    This function returns true if and only if the JSON value is a
    floating-point number. This excludes signed and unsigned integer values.

    @return `true` if type is a floating-point number, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_number_float()` for all
    JSON types.,is_number_float}

    @sa @ref is_number() -- check if value is number
    @sa @ref is_number_integer() -- check if value is an integer number
    @sa @ref is_number_unsigned() -- check if value is an unsigned integer
    number

    @since version 1.0.0
    */
    constexpr bool is_number_float() const noexcept
    {
        return m_type == value_t::number_float;
    }

    /*!
    @brief return whether value is an object

    This function returns true if and only if the JSON value is an object.

    @return `true` if type is object, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_object()` for all JSON
    types.,is_object}

    @since version 1.0.0
    */
    constexpr bool is_object() const noexcept
    {
        return m_type == value_t::object;
    }

    /*!
    @brief return whether value is an array

    This function returns true if and only if the JSON value is an array.

    @return `true` if type is array, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_array()` for all JSON
    types.,is_array}

    @since version 1.0.0
    */
    constexpr bool is_array() const noexcept
    {
        return m_type == value_t::array;
    }

    /*!
    @brief return whether value is a string

    This function returns true if and only if the JSON value is a string.

    @return `true` if type is string, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_string()` for all JSON
    types.,is_string}

    @since version 1.0.0
    */
    constexpr bool is_string() const noexcept
    {
        return m_type == value_t::string;
    }

    /*!
    @brief return whether value is a binary array

    This function returns true if and only if the JSON value is a binary array.

    @return `true` if type is binary array, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_binary()` for all JSON
    types.,is_binary}

    @since version 3.8.0
    */
    constexpr bool is_binary() const noexcept
    {
        return m_type == value_t::binary;
    }

    /*!
    @brief return whether value is discarded

    This function returns true if and only if the JSON value was discarded
    during parsing with a callback function (see @ref parser_callback_t).

    @note This function will always be `false` for JSON values after parsing.
    That is, discarded values can only occur during parsing, but will be
    removed when inside a structured value or replaced by null in other cases.

    @return `true` if type is discarded, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_discarded()` for all JSON
    types.,is_discarded}

    @since version 1.0.0
    */
    constexpr bool is_discarded() const noexcept
    {
        return m_type == value_t::discarded;
    }

    /*!
    @brief return the type of the JSON value (implicit)

    Implicitly return the type of the JSON value as a value from the @ref
    value_t enumeration.

    @return the type of the JSON value

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies the @ref value_t operator for
    all JSON types.,operator__value_t}

    @sa @ref type() -- return the type of the JSON value (explicit)
    @sa @ref type_name() -- return the type as string

    @since version 1.0.0
    */
    constexpr operator value_t() const noexcept
    {
        return m_type;
    }

    /// @}

  private:
    //////////////////
    // value access //
    //////////////////

    /// get a boolean (explicit)
    boolean_t get_impl(boolean_t* /*unused*/) const
    {
        if (JSON_HEDLEY_LIKELY(is_boolean()))
        {
            return m_value.boolean;
        }

        JSON_THROW(type_error::create(302, "type must be boolean, but is " + std::string(type_name())));
    }

    /// get a pointer to the value (object)
    object_t* get_impl_ptr(object_t* /*unused*/) noexcept
    {
        return is_object() ? m_value.object : nullptr;
    }

    /// get a pointer to the value (object)
    constexpr const object_t* get_impl_ptr(const object_t* /*unused*/) const noexcept
    {
        return is_object() ? m_value.object : nullptr;
    }

    /// get a pointer to the value (array)
    array_t* get_impl_ptr(array_t* /*unused*/) noexcept
    {
        return is_array() ? m_value.array : nullptr;
    }

    /// get a pointer to the value (array)
    constexpr const array_t* get_impl_ptr(const array_t* /*unused*/) const noexcept
    {
        return is_array() ? m_value.array : nullptr;
    }

    /// get a pointer to the value (string)
    string_t* get_impl_ptr(string_t* /*unused*/) noexcept
    {
        return is_string() ? m_value.string : nullptr;
    }

    /// get a pointer to the value (string)
    constexpr const string_t* get_impl_ptr(const string_t* /*unused*/) const noexcept
    {
        return is_string() ? m_value.string : nullptr;
    }

    /// get a pointer to the value (boolean)
    boolean_t* get_impl_ptr(boolean_t* /*unused*/) noexcept
    {
        return is_boolean() ? &m_value.boolean : nullptr;
    }

    /// get a pointer to the value (boolean)
    constexpr const boolean_t* get_impl_ptr(const boolean_t* /*unused*/) const noexcept
    {
        return is_boolean() ? &m_value.boolean : nullptr;
    }

    /// get a pointer to the value (integer number)
    number_integer_t* get_impl_ptr(number_integer_t* /*unused*/) noexcept
    {
        return is_number_integer() ? &m_value.number_integer : nullptr;
    }

    /// get a pointer to the value (integer number)
    constexpr const number_integer_t* get_impl_ptr(const number_integer_t* /*unused*/) const noexcept
    {
        return is_number_integer() ? &m_value.number_integer : nullptr;
    }

    /// get a pointer to the value (unsigned number)
    number_unsigned_t* get_impl_ptr(number_unsigned_t* /*unused*/) noexcept
    {
        return is_number_unsigned() ? &m_value.number_unsigned : nullptr;
    }

    /// get a pointer to the value (unsigned number)
    constexpr const number_unsigned_t* get_impl_ptr(const number_unsigned_t* /*unused*/) const noexcept
    {
        return is_number_unsigned() ? &m_value.number_unsigned : nullptr;
    }

    /// get a pointer to the value (floating-point number)
    number_float_t* get_impl_ptr(number_float_t* /*unused*/) noexcept
    {
        return is_number_float() ? &m_value.number_float : nullptr;
    }

    /// get a pointer to the value (floating-point number)
    constexpr const number_float_t* get_impl_ptr(const number_float_t* /*unused*/) const noexcept
    {
        return is_number_float() ? &m_value.number_float : nullptr;
    }

    /// get a pointer to the value (binary)
    binary_t* get_impl_ptr(binary_t* /*unused*/) noexcept
    {
        return is_binary() ? m_value.binary : nullptr;
    }

    /// get a pointer to the value (binary)
    constexpr const binary_t* get_impl_ptr(const binary_t* /*unused*/) const noexcept
    {
        return is_binary() ? m_value.binary : nullptr;
    }

    /*!
    @brief helper function to implement get_ref()

    This function helps to implement get_ref() without code duplication for
    const and non-const overloads

    @tparam ThisType will be deduced as `basic_json` or `const basic_json`

    @throw type_error.303 if ReferenceType does not match underlying value
    type of the current JSON
    */
    template<typename ReferenceType, typename ThisType>
    static ReferenceType get_ref_impl(ThisType& obj)
    {
        // delegate the call to get_ptr<>()
        auto ptr = obj.template get_ptr<typename std::add_pointer<ReferenceType>::type>();

        if (JSON_HEDLEY_LIKELY(ptr != nullptr))
        {
            return *ptr;
        }

        JSON_THROW(type_error::create(303, "incompatible ReferenceType for get_ref, actual type is " + std::string(obj.type_name())));
    }

  public:
    /// @name value access
    /// Direct access to the stored value of a JSON value.
    /// @{

    /*!
    @brief get special-case overload

    This overloads avoids a lot of template boilerplate, it can be seen as the
    identity method

    @tparam BasicJsonType == @ref basic_json

    @return a copy of *this

    @complexity Constant.

    @since version 2.1.0
    */
    template<typename BasicJsonType, detail::enable_if_t<
                 std::is_same<typename std::remove_const<BasicJsonType>::type, basic_json_t>::value,
                 int> = 0>
    basic_json get() const
    {
        return *this;
    }

    /*!
    @brief get special-case overload

    This overloads converts the current @ref basic_json in a different
    @ref basic_json type

    @tparam BasicJsonType == @ref basic_json

    @return a copy of *this, converted into @tparam BasicJsonType

    @complexity Depending on the implementation of the called `from_json()`
                method.

    @since version 3.2.0
    */
    template < typename BasicJsonType, detail::enable_if_t <
                   !std::is_same<BasicJsonType, basic_json>::value&&
                   detail::is_basic_json<BasicJsonType>::value, int > = 0 >
    BasicJsonType get() const
    {
        return *this;
    }

    /*!
    @brief get a value (explicit)

    Explicit type conversion between the JSON value and a compatible value
    which is [CopyConstructible](https://en.cppreference.com/w/cpp/named_req/CopyConstructible)
    and [DefaultConstructible](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible).
    The value is converted by calling the @ref json_serializer<ValueType>
    `from_json()` method.

    The function is equivalent to executing
    @code {.cpp}
    ValueType ret;
    JSONSerializer<ValueType>::from_json(*this, ret);
    return ret;
    @endcode

    This overloads is chosen if:
    - @a ValueType is not @ref basic_json,
    - @ref json_serializer<ValueType> has a `from_json()` method of the form
      `void from_json(const basic_json&, ValueType&)`, and
    - @ref json_serializer<ValueType> does not have a `from_json()` method of
      the form `ValueType from_json(const basic_json&)`

    @tparam ValueTypeCV the provided value type
    @tparam ValueType the returned value type

    @return copy of the JSON value, converted to @a ValueType

    @throw what @ref json_serializer<ValueType> `from_json()` method throws

    @liveexample{The example below shows several conversions from JSON values
    to other types. There a few things to note: (1) Floating-point numbers can
    be converted to integers\, (2) A JSON array can be converted to a standard
    `std::vector<short>`\, (3) A JSON object can be converted to C++
    associative containers such as `std::unordered_map<std::string\,
    json>`.,get__ValueType_const}

    @since version 2.1.0
    */
    template < typename ValueTypeCV, typename ValueType = detail::uncvref_t<ValueTypeCV>,
               detail::enable_if_t <
                   !detail::is_basic_json<ValueType>::value &&
                   detail::has_from_json<basic_json_t, ValueType>::value &&
                   !detail::has_non_default_from_json<basic_json_t, ValueType>::value,
                   int > = 0 >
    ValueType get() const noexcept(noexcept(
                                       JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>(), std::declval<ValueType&>())))
    {
        // we cannot static_assert on ValueTypeCV being non-const, because
        // there is support for get<const basic_json_t>(), which is why we
        // still need the uncvref
        static_assert(!std::is_reference<ValueTypeCV>::value,
                      "get() cannot be used with reference types, you might want to use get_ref()");
        static_assert(std::is_default_constructible<ValueType>::value,
                      "types must be DefaultConstructible when used with get()");

        ValueType ret;
        JSONSerializer<ValueType>::from_json(*this, ret);
        return ret;
    }

    /*!
    @brief get a value (explicit); special case

    Explicit type conversion between the JSON value and a compatible value
    which is **not** [CopyConstructible](https://en.cppreference.com/w/cpp/named_req/CopyConstructible)
    and **not** [DefaultConstructible](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible).
    The value is converted by calling the @ref json_serializer<ValueType>
    `from_json()` method.

    The function is equivalent to executing
    @code {.cpp}
    return JSONSerializer<ValueTypeCV>::from_json(*this);
    @endcode

    This overloads is chosen if:
    - @a ValueType is not @ref basic_json and
    - @ref json_serializer<ValueType> has a `from_json()` method of the form
      `ValueType from_json(const basic_json&)`

    @note If @ref json_serializer<ValueType> has both overloads of
    `from_json()`, this one is chosen.

    @tparam ValueTypeCV the provided value type
    @tparam ValueType the returned value type

    @return copy of the JSON value, converted to @a ValueType

    @throw what @ref json_serializer<ValueType> `from_json()` method throws

    @since version 2.1.0
    */
    template < typename ValueTypeCV, typename ValueType = detail::uncvref_t<ValueTypeCV>,
               detail::enable_if_t < !std::is_same<basic_json_t, ValueType>::value &&
                                     detail::has_non_default_from_json<basic_json_t, ValueType>::value,
                                     int > = 0 >
    ValueType get() const noexcept(noexcept(
                                       JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>())))
    {
        static_assert(!std::is_reference<ValueTypeCV>::value,
                      "get() cannot be used with reference types, you might want to use get_ref()");
        return JSONSerializer<ValueType>::from_json(*this);
    }

    /*!
    @brief get a value (explicit)

    Explicit type conversion between the JSON value and a compatible value.
    The value is filled into the input parameter by calling the @ref json_serializer<ValueType>
    `from_json()` method.

    The function is equivalent to executing
    @code {.cpp}
    ValueType v;
    JSONSerializer<ValueType>::from_json(*this, v);
    @endcode

    This overloads is chosen if:
    - @a ValueType is not @ref basic_json,
    - @ref json_serializer<ValueType> has a `from_json()` method of the form
      `void from_json(const basic_json&, ValueType&)`, and

    @tparam ValueType the input parameter type.

    @return the input parameter, allowing chaining calls.

    @throw what @ref json_serializer<ValueType> `from_json()` method throws

    @liveexample{The example below shows several conversions from JSON values
    to other types. There a few things to note: (1) Floating-point numbers can
    be converted to integers\, (2) A JSON array can be converted to a standard
    `std::vector<short>`\, (3) A JSON object can be converted to C++
    associative containers such as `std::unordered_map<std::string\,
    json>`.,get_to}

    @since version 3.3.0
    */
    template < typename ValueType,
               detail::enable_if_t <
                   !detail::is_basic_json<ValueType>::value&&
                   detail::has_from_json<basic_json_t, ValueType>::value,
                   int > = 0 >
    ValueType & get_to(ValueType& v) const noexcept(noexcept(
                JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>(), v)))
    {
        JSONSerializer<ValueType>::from_json(*this, v);
        return v;
    }

    // specialization to allow to call get_to with a basic_json value
    // see https://github.com/nlohmann/json/issues/2175
    template<typename ValueType,
             detail::enable_if_t <
                 detail::is_basic_json<ValueType>::value,
                 int> = 0>
    ValueType & get_to(ValueType& v) const
    {
        v = *this;
        return v;
    }

    template <
        typename T, std::size_t N,
        typename Array = T (&)[N],
        detail::enable_if_t <
            detail::has_from_json<basic_json_t, Array>::value, int > = 0 >
    Array get_to(T (&v)[N]) const
    noexcept(noexcept(JSONSerializer<Array>::from_json(
                          std::declval<const basic_json_t&>(), v)))
    {
        JSONSerializer<Array>::from_json(*this, v);
        return v;
    }


    /*!
    @brief get a pointer value (implicit)

    Implicit pointer access to the internally stored JSON value. No copies are
    made.

    @warning Writing data to the pointee of the result yields an undefined
    state.

    @tparam PointerType pointer type; must be a pointer to @ref array_t, @ref
    object_t, @ref string_t, @ref boolean_t, @ref number_integer_t,
    @ref number_unsigned_t, or @ref number_float_t. Enforced by a static
    assertion.

    @return pointer to the internally stored JSON value if the requested
    pointer type @a PointerType fits to the JSON value; `nullptr` otherwise

    @complexity Constant.

    @liveexample{The example below shows how pointers to internal values of a
    JSON value can be requested. Note that no type conversions are made and a
    `nullptr` is returned if the value and the requested pointer type does not
    match.,get_ptr}

    @since version 1.0.0
    */
    template<typename PointerType, typename std::enable_if<
                 std::is_pointer<PointerType>::value, int>::type = 0>
    auto get_ptr() noexcept -> decltype(std::declval<basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))
    {
        // delegate the call to get_impl_ptr<>()
        return get_impl_ptr(static_cast<PointerType>(nullptr));
    }

    /*!
    @brief get a pointer value (implicit)
    @copydoc get_ptr()
    */
    template < typename PointerType, typename std::enable_if <
                   std::is_pointer<PointerType>::value&&
                   std::is_const<typename std::remove_pointer<PointerType>::type>::value, int >::type = 0 >
    constexpr auto get_ptr() const noexcept -> decltype(std::declval<const basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))
    {
        // delegate the call to get_impl_ptr<>() const
        return get_impl_ptr(static_cast<PointerType>(nullptr));
    }

    /*!
    @brief get a pointer value (explicit)

    Explicit pointer access to the internally stored JSON value. No copies are
    made.

    @warning The pointer becomes invalid if the underlying JSON object
    changes.

    @tparam PointerType pointer type; must be a pointer to @ref array_t, @ref
    object_t, @ref string_t, @ref boolean_t, @ref number_integer_t,
    @ref number_unsigned_t, or @ref number_float_t.

    @return pointer to the internally stored JSON value if the requested
    pointer type @a PointerType fits to the JSON value; `nullptr` otherwise

    @complexity Constant.

    @liveexample{The example below shows how pointers to internal values of a
    JSON value can be requested. Note that no type conversions are made and a
    `nullptr` is returned if the value and the requested pointer type does not
    match.,get__PointerType}

    @sa @ref get_ptr() for explicit pointer-member access

    @since version 1.0.0
    */
    template<typename PointerType, typename std::enable_if<
                 std::is_pointer<PointerType>::value, int>::type = 0>
    auto get() noexcept -> decltype(std::declval<basic_json_t&>().template get_ptr<PointerType>())
    {
        // delegate the call to get_ptr
        return get_ptr<PointerType>();
    }

    /*!
    @brief get a pointer value (explicit)
    @copydoc get()
    */
    template<typename PointerType, typename std::enable_if<
                 std::is_pointer<PointerType>::value, int>::type = 0>
    constexpr auto get() const noexcept -> decltype(std::declval<const basic_json_t&>().template get_ptr<PointerType>())
    {
        // delegate the call to get_ptr
        return get_ptr<PointerType>();
    }

    /*!
    @brief get a reference value (implicit)

    Implicit reference access to the internally stored JSON value. No copies
    are made.

    @warning Writing data to the referee of the result yields an undefined
    state.

    @tparam ReferenceType reference type; must be a reference to @ref array_t,
    @ref object_t, @ref string_t, @ref boolean_t, @ref number_integer_t, or
    @ref number_float_t. Enforced by static assertion.

    @return reference to the internally stored JSON value if the requested
    reference type @a ReferenceType fits to the JSON value; throws
    type_error.303 otherwise

    @throw type_error.303 in case passed type @a ReferenceType is incompatible
    with the stored JSON value; see example below

    @complexity Constant.

    @liveexample{The example shows several calls to `get_ref()`.,get_ref}

    @since version 1.1.0
    */
    template<typename ReferenceType, typename std::enable_if<
                 std::is_reference<ReferenceType>::value, int>::type = 0>
    ReferenceType get_ref()
    {
        // delegate call to get_ref_impl
        return get_ref_impl<ReferenceType>(*this);
    }

    /*!
    @brief get a reference value (implicit)
    @copydoc get_ref()
    */
    template < typename ReferenceType, typename std::enable_if <
                   std::is_reference<ReferenceType>::value&&
                   std::is_const<typename std::remove_reference<ReferenceType>::type>::value, int >::type = 0 >
    ReferenceType get_ref() const
    {
        // delegate call to get_ref_impl
        return get_ref_impl<ReferenceType>(*this);
    }

    /*!
    @brief get a value (implicit)

    Implicit type conversion between the JSON value and a compatible value.
    The call is realized by calling @ref get() const.

    @tparam ValueType non-pointer type compatible to the JSON value, for
    instance `int` for JSON integer numbers, `bool` for JSON booleans, or
    `std::vector` types for JSON arrays. The character type of @ref string_t
    as well as an initializer list of this type is excluded to avoid
    ambiguities as these types implicitly convert to `std::string`.

    @return copy of the JSON value, converted to type @a ValueType

    @throw type_error.302 in case passed type @a ValueType is incompatible
    to the JSON value type (e.g., the JSON value is of type boolean, but a
    string is requested); see example below

    @complexity Linear in the size of the JSON value.

    @liveexample{The example below shows several conversions from JSON values
    to other types. There a few things to note: (1) Floating-point numbers can
    be converted to integers\, (2) A JSON array can be converted to a standard
    `std::vector<short>`\, (3) A JSON object can be converted to C++
    associative containers such as `std::unordered_map<std::string\,
    json>`.,operator__ValueType}

    @since version 1.0.0
    */
    template < typename ValueType, typename std::enable_if <
                   !std::is_pointer<ValueType>::value&&
                   !std::is_same<ValueType, detail::json_ref<basic_json>>::value&&
                   !std::is_same<ValueType, typename string_t::value_type>::value&&
                   !detail::is_basic_json<ValueType>::value
                   && !std::is_same<ValueType, std::initializer_list<typename string_t::value_type>>::value
#if defined(JSON_HAS_CPP_17) && (defined(__GNUC__) || (defined(_MSC_VER) && _MSC_VER >= 1910 && _MSC_VER <= 1914))
                   && !std::is_same<ValueType, typename std::string_view>::value
#endif
                   && detail::is_detected<detail::get_template_function, const basic_json_t&, ValueType>::value
                   , int >::type = 0 >
    JSON_EXPLICIT operator ValueType() const
    {
        // delegate the call to get<>() const
        return get<ValueType>();
    }

    /*!
    @return reference to the binary value

    @throw type_error.302 if the value is not binary

    @sa @ref is_binary() to check if the value is binary

    @since version 3.8.0
    */
    binary_t& get_binary()
    {
        if (!is_binary())
        {
            JSON_THROW(type_error::create(302, "type must be binary, but is " + std::string(type_name())));
        }

        return *get_ptr<binary_t*>();
    }

    /// @copydoc get_binary()
    const binary_t& get_binary() const
    {
        if (!is_binary())
        {
            JSON_THROW(type_error::create(302, "type must be binary, but is " + std::string(type_name())));
        }

        return *get_ptr<const binary_t*>();
    }

    /// @}


    ////////////////////
    // element access //
    ////////////////////

    /// @name element access
    /// Access to the JSON value.
    /// @{

    /*!
    @brief access specified array element with bounds checking

    Returns a reference to the element at specified location @a idx, with
    bounds checking.

    @param[in] idx  index of the element to access

    @return reference to the element at index @a idx

    @throw type_error.304 if the JSON value is not an array; in this case,
    calling `at` with an index makes no sense. See example below.
    @throw out_of_range.401 if the index @a idx is out of range of the array;
    that is, `idx >= size()`. See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @since version 1.0.0

    @liveexample{The example below shows how array elements can be read and
    written using `at()`. It also demonstrates the different exceptions that
    can be thrown.,at__size_type}
    */
    reference at(size_type idx)
    {
        // at only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            JSON_TRY
            {
                return m_value.array->at(idx);
            }
            JSON_CATCH (std::out_of_range&)
            {
                // create better exception explanation
                JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range"));
            }
        }
        else
        {
            JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
        }
    }

    /*!
    @brief access specified array element with bounds checking

    Returns a const reference to the element at specified location @a idx,
    with bounds checking.

    @param[in] idx  index of the element to access

    @return const reference to the element at index @a idx

    @throw type_error.304 if the JSON value is not an array; in this case,
    calling `at` with an index makes no sense. See example below.
    @throw out_of_range.401 if the index @a idx is out of range of the array;
    that is, `idx >= size()`. See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @since version 1.0.0

    @liveexample{The example below shows how array elements can be read using
    `at()`. It also demonstrates the different exceptions that can be thrown.,
    at__size_type_const}
    */
    const_reference at(size_type idx) const
    {
        // at only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            JSON_TRY
            {
                return m_value.array->at(idx);
            }
            JSON_CATCH (std::out_of_range&)
            {
                // create better exception explanation
                JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range"));
            }
        }
        else
        {
            JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
        }
    }

    /*!
    @brief access specified object element with bounds checking

    Returns a reference to the element at with specified key @a key, with
    bounds checking.

    @param[in] key  key of the element to access

    @return reference to the element at key @a key

    @throw type_error.304 if the JSON value is not an object; in this case,
    calling `at` with a key makes no sense. See example below.
    @throw out_of_range.403 if the key @a key is is not stored in the object;
    that is, `find(key) == end()`. See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Logarithmic in the size of the container.

    @sa @ref operator[](const typename object_t::key_type&) for unchecked
    access by reference
    @sa @ref value() for access by value with a default value

    @since version 1.0.0

    @liveexample{The example below shows how object elements can be read and
    written using `at()`. It also demonstrates the different exceptions that
    can be thrown.,at__object_t_key_type}
    */
    reference at(const typename object_t::key_type& key)
    {
        // at only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            JSON_TRY
            {
                return m_value.object->at(key);
            }
            JSON_CATCH (std::out_of_range&)
            {
                // create better exception explanation
                JSON_THROW(out_of_range::create(403, "key '" + key + "' not found"));
            }
        }
        else
        {
            JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
        }
    }

    /*!
    @brief access specified object element with bounds checking

    Returns a const reference to the element at with specified key @a key,
    with bounds checking.

    @param[in] key  key of the element to access

    @return const reference to the element at key @a key

    @throw type_error.304 if the JSON value is not an object; in this case,
    calling `at` with a key makes no sense. See example below.
    @throw out_of_range.403 if the key @a key is is not stored in the object;
    that is, `find(key) == end()`. See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Logarithmic in the size of the container.

    @sa @ref operator[](const typename object_t::key_type&) for unchecked
    access by reference
    @sa @ref value() for access by value with a default value

    @since version 1.0.0

    @liveexample{The example below shows how object elements can be read using
    `at()`. It also demonstrates the different exceptions that can be thrown.,
    at__object_t_key_type_const}
    */
    const_reference at(const typename object_t::key_type& key) const
    {
        // at only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            JSON_TRY
            {
                return m_value.object->at(key);
            }
            JSON_CATCH (std::out_of_range&)
            {
                // create better exception explanation
                JSON_THROW(out_of_range::create(403, "key '" + key + "' not found"));
            }
        }
        else
        {
            JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
        }
    }

    /*!
    @brief access specified array element

    Returns a reference to the element at specified location @a idx.

    @note If @a idx is beyond the range of the array (i.e., `idx >= size()`),
    then the array is silently filled up with `null` values to make `idx` a
    valid reference to the last stored element.

    @param[in] idx  index of the element to access

    @return reference to the element at index @a idx

    @throw type_error.305 if the JSON value is not an array or null; in that
    cases, using the [] operator with an index makes no sense.

    @complexity Constant if @a idx is in the range of the array. Otherwise
    linear in `idx - size()`.

    @liveexample{The example below shows how array elements can be read and
    written using `[]` operator. Note the addition of `null`
    values.,operatorarray__size_type}

    @since version 1.0.0
    */
    reference operator[](size_type idx)
    {
        // implicitly convert null value to an empty array
        if (is_null())
        {
            m_type = value_t::array;
            m_value.array = create<array_t>();
            assert_invariant();
        }

        // operator[] only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            // fill up array with null values if given idx is outside range
            if (idx >= m_value.array->size())
            {
                m_value.array->insert(m_value.array->end(),
                                      idx - m_value.array->size() + 1,
                                      basic_json());
            }

            return m_value.array->operator[](idx);
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with a numeric argument with " + std::string(type_name())));
    }

    /*!
    @brief access specified array element

    Returns a const reference to the element at specified location @a idx.

    @param[in] idx  index of the element to access

    @return const reference to the element at index @a idx

    @throw type_error.305 if the JSON value is not an array; in that case,
    using the [] operator with an index makes no sense.

    @complexity Constant.

    @liveexample{The example below shows how array elements can be read using
    the `[]` operator.,operatorarray__size_type_const}

    @since version 1.0.0
    */
    const_reference operator[](size_type idx) const
    {
        // const operator[] only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            return m_value.array->operator[](idx);
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with a numeric argument with " + std::string(type_name())));
    }

    /*!
    @brief access specified object element

    Returns a reference to the element at with specified key @a key.

    @note If @a key is not found in the object, then it is silently added to
    the object and filled with a `null` value to make `key` a valid reference.
    In case the value was `null` before, it is converted to an object.

    @param[in] key  key of the element to access

    @return reference to the element at key @a key

    @throw type_error.305 if the JSON value is not an object or null; in that
    cases, using the [] operator with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be read and
    written using the `[]` operator.,operatorarray__key_type}

    @sa @ref at(const typename object_t::key_type&) for access by reference
    with range checking
    @sa @ref value() for access by value with a default value

    @since version 1.0.0
    */
    reference operator[](const typename object_t::key_type& key)
    {
        // implicitly convert null value to an empty object
        if (is_null())
        {
            m_type = value_t::object;
            m_value.object = create<object_t>();
            assert_invariant();
        }

        // operator[] only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            return m_value.object->operator[](key);
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name())));
    }

    /*!
    @brief read-only access specified object element

    Returns a const reference to the element at with specified key @a key. No
    bounds checking is performed.

    @warning If the element with key @a key does not exist, the behavior is
    undefined.

    @param[in] key  key of the element to access

    @return const reference to the element at key @a key

    @pre The element with key @a key must exist. **This precondition is
         enforced with an assertion.**

    @throw type_error.305 if the JSON value is not an object; in that case,
    using the [] operator with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be read using
    the `[]` operator.,operatorarray__key_type_const}

    @sa @ref at(const typename object_t::key_type&) for access by reference
    with range checking
    @sa @ref value() for access by value with a default value

    @since version 1.0.0
    */
    const_reference operator[](const typename object_t::key_type& key) const
    {
        // const operator[] only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            JSON_ASSERT(m_value.object->find(key) != m_value.object->end());
            return m_value.object->find(key)->second;
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name())));
    }

    /*!
    @brief access specified object element

    Returns a reference to the element at with specified key @a key.

    @note If @a key is not found in the object, then it is silently added to
    the object and filled with a `null` value to make `key` a valid reference.
    In case the value was `null` before, it is converted to an object.

    @param[in] key  key of the element to access

    @return reference to the element at key @a key

    @throw type_error.305 if the JSON value is not an object or null; in that
    cases, using the [] operator with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be read and
    written using the `[]` operator.,operatorarray__key_type}

    @sa @ref at(const typename object_t::key_type&) for access by reference
    with range checking
    @sa @ref value() for access by value with a default value

    @since version 1.1.0
    */
    template<typename T>
    JSON_HEDLEY_NON_NULL(2)
    reference operator[](T* key)
    {
        // implicitly convert null to object
        if (is_null())
        {
            m_type = value_t::object;
            m_value = value_t::object;
            assert_invariant();
        }

        // at only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            return m_value.object->operator[](key);
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name())));
    }

    /*!
    @brief read-only access specified object element

    Returns a const reference to the element at with specified key @a key. No
    bounds checking is performed.

    @warning If the element with key @a key does not exist, the behavior is
    undefined.

    @param[in] key  key of the element to access

    @return const reference to the element at key @a key

    @pre The element with key @a key must exist. **This precondition is
         enforced with an assertion.**

    @throw type_error.305 if the JSON value is not an object; in that case,
    using the [] operator with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be read using
    the `[]` operator.,operatorarray__key_type_const}

    @sa @ref at(const typename object_t::key_type&) for access by reference
    with range checking
    @sa @ref value() for access by value with a default value

    @since version 1.1.0
    */
    template<typename T>
    JSON_HEDLEY_NON_NULL(2)
    const_reference operator[](T* key) const
    {
        // at only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            JSON_ASSERT(m_value.object->find(key) != m_value.object->end());
            return m_value.object->find(key)->second;
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name())));
    }

    /*!
    @brief access specified object element with default value

    Returns either a copy of an object's element at the specified key @a key
    or a given default value if no element with key @a key exists.

    The function is basically equivalent to executing
    @code {.cpp}
    try {
        return at(key);
    } catch(out_of_range) {
        return default_value;
    }
    @endcode

    @note Unlike @ref at(const typename object_t::key_type&), this function
    does not throw if the given key @a key was not found.

    @note Unlike @ref operator[](const typename object_t::key_type& key), this
    function does not implicitly add an element to the position defined by @a
    key. This function is furthermore also applicable to const objects.

    @param[in] key  key of the element to access
    @param[in] default_value  the value to return if @a key is not found

    @tparam ValueType type compatible to JSON values, for instance `int` for
    JSON integer numbers, `bool` for JSON booleans, or `std::vector` types for
    JSON arrays. Note the type of the expected value at @a key and the default
    value @a default_value must be compatible.

    @return copy of the element at key @a key or @a default_value if @a key
    is not found

    @throw type_error.302 if @a default_value does not match the type of the
    value at @a key
    @throw type_error.306 if the JSON value is not an object; in that case,
    using `value()` with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be queried
    with a default value.,basic_json__value}

    @sa @ref at(const typename object_t::key_type&) for access by reference
    with range checking
    @sa @ref operator[](const typename object_t::key_type&) for unchecked
    access by reference

    @since version 1.0.0
    */
    // using std::is_convertible in a std::enable_if will fail when using explicit conversions
    template < class ValueType, typename std::enable_if <
                   detail::is_getable<basic_json_t, ValueType>::value
                   && !std::is_same<value_t, ValueType>::value, int >::type = 0 >
    ValueType value(const typename object_t::key_type& key, const ValueType& default_value) const
    {
        // at only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            // if key is found, return value and given default value otherwise
            const auto it = find(key);
            if (it != end())
            {
                return it->template get<ValueType>();
            }

            return default_value;
        }

        JSON_THROW(type_error::create(306, "cannot use value() with " + std::string(type_name())));
    }

    /*!
    @brief overload for a default value of type const char*
    @copydoc basic_json::value(const typename object_t::key_type&, const ValueType&) const
    */
    string_t value(const typename object_t::key_type& key, const char* default_value) const
    {
        return value(key, string_t(default_value));
    }

    /*!
    @brief access specified object element via JSON Pointer with default value

    Returns either a copy of an object's element at the specified key @a key
    or a given default value if no element with key @a key exists.

    The function is basically equivalent to executing
    @code {.cpp}
    try {
        return at(ptr);
    } catch(out_of_range) {
        return default_value;
    }
    @endcode

    @note Unlike @ref at(const json_pointer&), this function does not throw
    if the given key @a key was not found.

    @param[in] ptr  a JSON pointer to the element to access
    @param[in] default_value  the value to return if @a ptr found no value

    @tparam ValueType type compatible to JSON values, for instance `int` for
    JSON integer numbers, `bool` for JSON booleans, or `std::vector` types for
    JSON arrays. Note the type of the expected value at @a key and the default
    value @a default_value must be compatible.

    @return copy of the element at key @a key or @a default_value if @a key
    is not found

    @throw type_error.302 if @a default_value does not match the type of the
    value at @a ptr
    @throw type_error.306 if the JSON value is not an object; in that case,
    using `value()` with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be queried
    with a default value.,basic_json__value_ptr}

    @sa @ref operator[](const json_pointer&) for unchecked access by reference

    @since version 2.0.2
    */
    template<class ValueType, typename std::enable_if<
                 detail::is_getable<basic_json_t, ValueType>::value, int>::type = 0>
    ValueType value(const json_pointer& ptr, const ValueType& default_value) const
    {
        // at only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            // if pointer resolves a value, return it or use default value
            JSON_TRY
            {
                return ptr.get_checked(this).template get<ValueType>();
            }
            JSON_INTERNAL_CATCH (out_of_range&)
            {
                return default_value;
            }
        }

        JSON_THROW(type_error::create(306, "cannot use value() with " + std::string(type_name())));
    }

    /*!
    @brief overload for a default value of type const char*
    @copydoc basic_json::value(const json_pointer&, ValueType) const
    */
    JSON_HEDLEY_NON_NULL(3)
    string_t value(const json_pointer& ptr, const char* default_value) const
    {
        return value(ptr, string_t(default_value));
    }

    /*!
    @brief access the first element

    Returns a reference to the first element in the container. For a JSON
    container `c`, the expression `c.front()` is equivalent to `*c.begin()`.

    @return In case of a structured type (array or object), a reference to the
    first element is returned. In case of number, string, boolean, or binary
    values, a reference to the value is returned.

    @complexity Constant.

    @pre The JSON value must not be `null` (would throw `std::out_of_range`)
    or an empty array or object (undefined behavior, **guarded by
    assertions**).
    @post The JSON value remains unchanged.

    @throw invalid_iterator.214 when called on `null` value

    @liveexample{The following code shows an example for `front()`.,front}

    @sa @ref back() -- access the last element

    @since version 1.0.0
    */
    reference front()
    {
        return *begin();
    }

    /*!
    @copydoc basic_json::front()
    */
    const_reference front() const
    {
        return *cbegin();
    }

    /*!
    @brief access the last element

    Returns a reference to the last element in the container. For a JSON
    container `c`, the expression `c.back()` is equivalent to
    @code {.cpp}
    auto tmp = c.end();
    --tmp;
    return *tmp;
    @endcode

    @return In case of a structured type (array or object), a reference to the
    last element is returned. In case of number, string, boolean, or binary
    values, a reference to the value is returned.

    @complexity Constant.

    @pre The JSON value must not be `null` (would throw `std::out_of_range`)
    or an empty array or object (undefined behavior, **guarded by
    assertions**).
    @post The JSON value remains unchanged.

    @throw invalid_iterator.214 when called on a `null` value. See example
    below.

    @liveexample{The following code shows an example for `back()`.,back}

    @sa @ref front() -- access the first element

    @since version 1.0.0
    */
    reference back()
    {
        auto tmp = end();
        --tmp;
        return *tmp;
    }

    /*!
    @copydoc basic_json::back()
    */
    const_reference back() const
    {
        auto tmp = cend();
        --tmp;
        return *tmp;
    }

    /*!
    @brief remove element given an iterator

    Removes the element specified by iterator @a pos. The iterator @a pos must
    be valid and dereferenceable. Thus the `end()` iterator (which is valid,
    but is not dereferenceable) cannot be used as a value for @a pos.

    If called on a primitive type other than `null`, the resulting JSON value
    will be `null`.

    @param[in] pos iterator to the element to remove
    @return Iterator following the last removed element. If the iterator @a
    pos refers to the last element, the `end()` iterator is returned.

    @tparam IteratorType an @ref iterator or @ref const_iterator

    @post Invalidates iterators and references at or after the point of the
    erase, including the `end()` iterator.

    @throw type_error.307 if called on a `null` value; example: `"cannot use
    erase() with null"`
    @throw invalid_iterator.202 if called on an iterator which does not belong
    to the current JSON value; example: `"iterator does not fit current
    value"`
    @throw invalid_iterator.205 if called on a primitive type with invalid
    iterator (i.e., any iterator which is not `begin()`); example: `"iterator
    out of range"`

    @complexity The complexity depends on the type:
    - objects: amortized constant
    - arrays: linear in distance between @a pos and the end of the container
    - strings and binary: linear in the length of the member
    - other types: constant

    @liveexample{The example shows the result of `erase()` for different JSON
    types.,erase__IteratorType}

    @sa @ref erase(IteratorType, IteratorType) -- removes the elements in
    the given range
    @sa @ref erase(const typename object_t::key_type&) -- removes the element
    from an object at the given key
    @sa @ref erase(const size_type) -- removes the element from an array at
    the given index

    @since version 1.0.0
    */
    template < class IteratorType, typename std::enable_if <
                   std::is_same<IteratorType, typename basic_json_t::iterator>::value ||
                   std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, int >::type
               = 0 >
    IteratorType erase(IteratorType pos)
    {
        // make sure iterator fits the current value
        if (JSON_HEDLEY_UNLIKELY(this != pos.m_object))
        {
            JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
        }

        IteratorType result = end();

        switch (m_type)
        {
            case value_t::boolean:
            case value_t::number_float:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::string:
            case value_t::binary:
            {
                if (JSON_HEDLEY_UNLIKELY(!pos.m_it.primitive_iterator.is_begin()))
                {
                    JSON_THROW(invalid_iterator::create(205, "iterator out of range"));
                }

                if (is_string())
                {
                    AllocatorType<string_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_value.string);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_value.string, 1);
                    m_value.string = nullptr;
                }
                else if (is_binary())
                {
                    AllocatorType<binary_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_value.binary);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_value.binary, 1);
                    m_value.binary = nullptr;
                }

                m_type = value_t::null;
                assert_invariant();
                break;
            }

            case value_t::object:
            {
                result.m_it.object_iterator = m_value.object->erase(pos.m_it.object_iterator);
                break;
            }

            case value_t::array:
            {
                result.m_it.array_iterator = m_value.array->erase(pos.m_it.array_iterator);
                break;
            }

            default:
                JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
        }

        return result;
    }

    /*!
    @brief remove elements given an iterator range

    Removes the element specified by the range `[first; last)`. The iterator
    @a first does not need to be dereferenceable if `first == last`: erasing
    an empty range is a no-op.

    If called on a primitive type other than `null`, the resulting JSON value
    will be `null`.

    @param[in] first iterator to the beginning of the range to remove
    @param[in] last iterator past the end of the range to remove
    @return Iterator following the last removed element. If the iterator @a
    second refers to the last element, the `end()` iterator is returned.

    @tparam IteratorType an @ref iterator or @ref const_iterator

    @post Invalidates iterators and references at or after the point of the
    erase, including the `end()` iterator.

    @throw type_error.307 if called on a `null` value; example: `"cannot use
    erase() with null"`
    @throw invalid_iterator.203 if called on iterators which does not belong
    to the current JSON value; example: `"iterators do not fit current value"`
    @throw invalid_iterator.204 if called on a primitive type with invalid
    iterators (i.e., if `first != begin()` and `last != end()`); example:
    `"iterators out of range"`

    @complexity The complexity depends on the type:
    - objects: `log(size()) + std::distance(first, last)`
    - arrays: linear in the distance between @a first and @a last, plus linear
      in the distance between @a last and end of the container
    - strings and binary: linear in the length of the member
    - other types: constant

    @liveexample{The example shows the result of `erase()` for different JSON
    types.,erase__IteratorType_IteratorType}

    @sa @ref erase(IteratorType) -- removes the element at a given position
    @sa @ref erase(const typename object_t::key_type&) -- removes the element
    from an object at the given key
    @sa @ref erase(const size_type) -- removes the element from an array at
    the given index

    @since version 1.0.0
    */
    template < class IteratorType, typename std::enable_if <
                   std::is_same<IteratorType, typename basic_json_t::iterator>::value ||
                   std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, int >::type
               = 0 >
    IteratorType erase(IteratorType first, IteratorType last)
    {
        // make sure iterator fits the current value
        if (JSON_HEDLEY_UNLIKELY(this != first.m_object || this != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(203, "iterators do not fit current value"));
        }

        IteratorType result = end();

        switch (m_type)
        {
            case value_t::boolean:
            case value_t::number_float:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::string:
            case value_t::binary:
            {
                if (JSON_HEDLEY_LIKELY(!first.m_it.primitive_iterator.is_begin()
                                       || !last.m_it.primitive_iterator.is_end()))
                {
                    JSON_THROW(invalid_iterator::create(204, "iterators out of range"));
                }

                if (is_string())
                {
                    AllocatorType<string_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_value.string);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_value.string, 1);
                    m_value.string = nullptr;
                }
                else if (is_binary())
                {
                    AllocatorType<binary_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_value.binary);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_value.binary, 1);
                    m_value.binary = nullptr;
                }

                m_type = value_t::null;
                assert_invariant();
                break;
            }

            case value_t::object:
            {
                result.m_it.object_iterator = m_value.object->erase(first.m_it.object_iterator,
                                              last.m_it.object_iterator);
                break;
            }

            case value_t::array:
            {
                result.m_it.array_iterator = m_value.array->erase(first.m_it.array_iterator,
                                             last.m_it.array_iterator);
                break;
            }

            default:
                JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
        }

        return result;
    }

    /*!
    @brief remove element from a JSON object given a key

    Removes elements from a JSON object with the key value @a key.

    @param[in] key value of the elements to remove

    @return Number of elements removed. If @a ObjectType is the default
    `std::map` type, the return value will always be `0` (@a key was not
    found) or `1` (@a key was found).

    @post References and iterators to the erased elements are invalidated.
    Other references and iterators are not affected.

    @throw type_error.307 when called on a type other than JSON object;
    example: `"cannot use erase() with null"`

    @complexity `log(size()) + count(key)`

    @liveexample{The example shows the effect of `erase()`.,erase__key_type}

    @sa @ref erase(IteratorType) -- removes the element at a given position
    @sa @ref erase(IteratorType, IteratorType) -- removes the elements in
    the given range
    @sa @ref erase(const size_type) -- removes the element from an array at
    the given index

    @since version 1.0.0
    */
    size_type erase(const typename object_t::key_type& key)
    {
        // this erase only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            return m_value.object->erase(key);
        }

        JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
    }

    /*!
    @brief remove element from a JSON array given an index

    Removes element from a JSON array at the index @a idx.

    @param[in] idx index of the element to remove

    @throw type_error.307 when called on a type other than JSON object;
    example: `"cannot use erase() with null"`
    @throw out_of_range.401 when `idx >= size()`; example: `"array index 17
    is out of range"`

    @complexity Linear in distance between @a idx and the end of the container.

    @liveexample{The example shows the effect of `erase()`.,erase__size_type}

    @sa @ref erase(IteratorType) -- removes the element at a given position
    @sa @ref erase(IteratorType, IteratorType) -- removes the elements in
    the given range
    @sa @ref erase(const typename object_t::key_type&) -- removes the element
    from an object at the given key

    @since version 1.0.0
    */
    void erase(const size_type idx)
    {
        // this erase only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            if (JSON_HEDLEY_UNLIKELY(idx >= size()))
            {
                JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range"));
            }

            m_value.array->erase(m_value.array->begin() + static_cast<difference_type>(idx));
        }
        else
        {
            JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
        }
    }

    /// @}


    ////////////
    // lookup //
    ////////////

    /// @name lookup
    /// @{

    /*!
    @brief find an element in a JSON object

    Finds an element in a JSON object with key equivalent to @a key. If the
    element is not found or the JSON value is not an object, end() is
    returned.

    @note This method always returns @ref end() when executed on a JSON type
          that is not an object.

    @param[in] key key value of the element to search for.

    @return Iterator to an element with key equivalent to @a key. If no such
    element is found or the JSON value is not an object, past-the-end (see
    @ref end()) iterator is returned.

    @complexity Logarithmic in the size of the JSON object.

    @liveexample{The example shows how `find()` is used.,find__key_type}

    @sa @ref contains(KeyT&&) const -- checks whether a key exists

    @since version 1.0.0
    */
    template<typename KeyT>
    iterator find(KeyT&& key)
    {
        auto result = end();

        if (is_object())
        {
            result.m_it.object_iterator = m_value.object->find(std::forward<KeyT>(key));
        }

        return result;
    }

    /*!
    @brief find an element in a JSON object
    @copydoc find(KeyT&&)
    */
    template<typename KeyT>
    const_iterator find(KeyT&& key) const
    {
        auto result = cend();

        if (is_object())
        {
            result.m_it.object_iterator = m_value.object->find(std::forward<KeyT>(key));
        }

        return result;
    }

    /*!
    @brief returns the number of occurrences of a key in a JSON object

    Returns the number of elements with key @a key. If ObjectType is the
    default `std::map` type, the return value will always be `0` (@a key was
    not found) or `1` (@a key was found).

    @note This method always returns `0` when executed on a JSON type that is
          not an object.

    @param[in] key key value of the element to count

    @return Number of elements with key @a key. If the JSON value is not an
    object, the return value will be `0`.

    @complexity Logarithmic in the size of the JSON object.

    @liveexample{The example shows how `count()` is used.,count}

    @since version 1.0.0
    */
    template<typename KeyT>
    size_type count(KeyT&& key) const
    {
        // return 0 for all nonobject types
        return is_object() ? m_value.object->count(std::forward<KeyT>(key)) : 0;
    }

    /*!
    @brief check the existence of an element in a JSON object

    Check whether an element exists in a JSON object with key equivalent to
    @a key. If the element is not found or the JSON value is not an object,
    false is returned.

    @note This method always returns false when executed on a JSON type
          that is not an object.

    @param[in] key key value to check its existence.

    @return true if an element with specified @a key exists. If no such
    element with such key is found or the JSON value is not an object,
    false is returned.

    @complexity Logarithmic in the size of the JSON object.

    @liveexample{The following code shows an example for `contains()`.,contains}

    @sa @ref find(KeyT&&) -- returns an iterator to an object element
    @sa @ref contains(const json_pointer&) const -- checks the existence for a JSON pointer

    @since version 3.6.0
    */
    template < typename KeyT, typename std::enable_if <
                   !std::is_same<typename std::decay<KeyT>::type, json_pointer>::value, int >::type = 0 >
    bool contains(KeyT && key) const
    {
        return is_object() && m_value.object->find(std::forward<KeyT>(key)) != m_value.object->end();
    }

    /*!
    @brief check the existence of an element in a JSON object given a JSON pointer

    Check whether the given JSON pointer @a ptr can be resolved in the current
    JSON value.

    @note This method can be executed on any JSON value type.

    @param[in] ptr JSON pointer to check its existence.

    @return true if the JSON pointer can be resolved to a stored value, false
    otherwise.

    @post If `j.contains(ptr)` returns true, it is safe to call `j[ptr]`.

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number

    @complexity Logarithmic in the size of the JSON object.

    @liveexample{The following code shows an example for `contains()`.,contains_json_pointer}

    @sa @ref contains(KeyT &&) const -- checks the existence of a key

    @since version 3.7.0
    */
    bool contains(const json_pointer& ptr) const
    {
        return ptr.contains(this);
    }

    /// @}


    ///////////////
    // iterators //
    ///////////////

    /// @name iterators
    /// @{

    /*!
    @brief returns an iterator to the first element

    Returns an iterator to the first element.

    @image html range-begin-end.svg "Illustration from cppreference.com"

    @return iterator to the first element

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is constant.

    @liveexample{The following code shows an example for `begin()`.,begin}

    @sa @ref cbegin() -- returns a const iterator to the beginning
    @sa @ref end() -- returns an iterator to the end
    @sa @ref cend() -- returns a const iterator to the end

    @since version 1.0.0
    */
    iterator begin() noexcept
    {
        iterator result(this);
        result.set_begin();
        return result;
    }

    /*!
    @copydoc basic_json::cbegin()
    */
    const_iterator begin() const noexcept
    {
        return cbegin();
    }

    /*!
    @brief returns a const iterator to the first element

    Returns a const iterator to the first element.

    @image html range-begin-end.svg "Illustration from cppreference.com"

    @return const iterator to the first element

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is constant.
    - Has the semantics of `const_cast<const basic_json&>(*this).begin()`.

    @liveexample{The following code shows an example for `cbegin()`.,cbegin}

    @sa @ref begin() -- returns an iterator to the beginning
    @sa @ref end() -- returns an iterator to the end
    @sa @ref cend() -- returns a const iterator to the end

    @since version 1.0.0
    */
    const_iterator cbegin() const noexcept
    {
        const_iterator result(this);
        result.set_begin();
        return result;
    }

    /*!
    @brief returns an iterator to one past the last element

    Returns an iterator to one past the last element.

    @image html range-begin-end.svg "Illustration from cppreference.com"

    @return iterator one past the last element

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is constant.

    @liveexample{The following code shows an example for `end()`.,end}

    @sa @ref cend() -- returns a const iterator to the end
    @sa @ref begin() -- returns an iterator to the beginning
    @sa @ref cbegin() -- returns a const iterator to the beginning

    @since version 1.0.0
    */
    iterator end() noexcept
    {
        iterator result(this);
        result.set_end();
        return result;
    }

    /*!
    @copydoc basic_json::cend()
    */
    const_iterator end() const noexcept
    {
        return cend();
    }

    /*!
    @brief returns a const iterator to one past the last element

    Returns a const iterator to one past the last element.

    @image html range-begin-end.svg "Illustration from cppreference.com"

    @return const iterator one past the last element

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is constant.
    - Has the semantics of `const_cast<const basic_json&>(*this).end()`.

    @liveexample{The following code shows an example for `cend()`.,cend}

    @sa @ref end() -- returns an iterator to the end
    @sa @ref begin() -- returns an iterator to the beginning
    @sa @ref cbegin() -- returns a const iterator to the beginning

    @since version 1.0.0
    */
    const_iterator cend() const noexcept
    {
        const_iterator result(this);
        result.set_end();
        return result;
    }

    /*!
    @brief returns an iterator to the reverse-beginning

    Returns an iterator to the reverse-beginning; that is, the last element.

    @image html range-rbegin-rend.svg "Illustration from cppreference.com"

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer)
    requirements:
    - The complexity is constant.
    - Has the semantics of `reverse_iterator(end())`.

    @liveexample{The following code shows an example for `rbegin()`.,rbegin}

    @sa @ref crbegin() -- returns a const reverse iterator to the beginning
    @sa @ref rend() -- returns a reverse iterator to the end
    @sa @ref crend() -- returns a const reverse iterator to the end

    @since version 1.0.0
    */
    reverse_iterator rbegin() noexcept
    {
        return reverse_iterator(end());
    }

    /*!
    @copydoc basic_json::crbegin()
    */
    const_reverse_iterator rbegin() const noexcept
    {
        return crbegin();
    }

    /*!
    @brief returns an iterator to the reverse-end

    Returns an iterator to the reverse-end; that is, one before the first
    element.

    @image html range-rbegin-rend.svg "Illustration from cppreference.com"

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer)
    requirements:
    - The complexity is constant.
    - Has the semantics of `reverse_iterator(begin())`.

    @liveexample{The following code shows an example for `rend()`.,rend}

    @sa @ref crend() -- returns a const reverse iterator to the end
    @sa @ref rbegin() -- returns a reverse iterator to the beginning
    @sa @ref crbegin() -- returns a const reverse iterator to the beginning

    @since version 1.0.0
    */
    reverse_iterator rend() noexcept
    {
        return reverse_iterator(begin());
    }

    /*!
    @copydoc basic_json::crend()
    */
    const_reverse_iterator rend() const noexcept
    {
        return crend();
    }

    /*!
    @brief returns a const reverse iterator to the last element

    Returns a const iterator to the reverse-beginning; that is, the last
    element.

    @image html range-rbegin-rend.svg "Illustration from cppreference.com"

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer)
    requirements:
    - The complexity is constant.
    - Has the semantics of `const_cast<const basic_json&>(*this).rbegin()`.

    @liveexample{The following code shows an example for `crbegin()`.,crbegin}

    @sa @ref rbegin() -- returns a reverse iterator to the beginning
    @sa @ref rend() -- returns a reverse iterator to the end
    @sa @ref crend() -- returns a const reverse iterator to the end

    @since version 1.0.0
    */
    const_reverse_iterator crbegin() const noexcept
    {
        return const_reverse_iterator(cend());
    }

    /*!
    @brief returns a const reverse iterator to one before the first

    Returns a const reverse iterator to the reverse-end; that is, one before
    the first element.

    @image html range-rbegin-rend.svg "Illustration from cppreference.com"

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer)
    requirements:
    - The complexity is constant.
    - Has the semantics of `const_cast<const basic_json&>(*this).rend()`.

    @liveexample{The following code shows an example for `crend()`.,crend}

    @sa @ref rend() -- returns a reverse iterator to the end
    @sa @ref rbegin() -- returns a reverse iterator to the beginning
    @sa @ref crbegin() -- returns a const reverse iterator to the beginning

    @since version 1.0.0
    */
    const_reverse_iterator crend() const noexcept
    {
        return const_reverse_iterator(cbegin());
    }

  public:
    /*!
    @brief wrapper to access iterator member functions in range-based for

    This function allows to access @ref iterator::key() and @ref
    iterator::value() during range-based for loops. In these loops, a
    reference to the JSON values is returned, so there is no access to the
    underlying iterator.

    For loop without iterator_wrapper:

    @code{cpp}
    for (auto it = j_object.begin(); it != j_object.end(); ++it)
    {
        std::cout << "key: " << it.key() << ", value:" << it.value() << '\n';
    }
    @endcode

    Range-based for loop without iterator proxy:

    @code{cpp}
    for (auto it : j_object)
    {
        // "it" is of type json::reference and has no key() member
        std::cout << "value: " << it << '\n';
    }
    @endcode

    Range-based for loop with iterator proxy:

    @code{cpp}
    for (auto it : json::iterator_wrapper(j_object))
    {
        std::cout << "key: " << it.key() << ", value:" << it.value() << '\n';
    }
    @endcode

    @note When iterating over an array, `key()` will return the index of the
          element as string (see example).

    @param[in] ref  reference to a JSON value
    @return iteration proxy object wrapping @a ref with an interface to use in
            range-based for loops

    @liveexample{The following code shows how the wrapper is used,iterator_wrapper}

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @note The name of this function is not yet final and may change in the
    future.

    @deprecated This stream operator is deprecated and will be removed in
                future 4.0.0 of the library. Please use @ref items() instead;
                that is, replace `json::iterator_wrapper(j)` with `j.items()`.
    */
    JSON_HEDLEY_DEPRECATED_FOR(3.1.0, items())
    static iteration_proxy<iterator> iterator_wrapper(reference ref) noexcept
    {
        return ref.items();
    }

    /*!
    @copydoc iterator_wrapper(reference)
    */
    JSON_HEDLEY_DEPRECATED_FOR(3.1.0, items())
    static iteration_proxy<const_iterator> iterator_wrapper(const_reference ref) noexcept
    {
        return ref.items();
    }

    /*!
    @brief helper to access iterator member functions in range-based for

    This function allows to access @ref iterator::key() and @ref
    iterator::value() during range-based for loops. In these loops, a
    reference to the JSON values is returned, so there is no access to the
    underlying iterator.

    For loop without `items()` function:

    @code{cpp}
    for (auto it = j_object.begin(); it != j_object.end(); ++it)
    {
        std::cout << "key: " << it.key() << ", value:" << it.value() << '\n';
    }
    @endcode

    Range-based for loop without `items()` function:

    @code{cpp}
    for (auto it : j_object)
    {
        // "it" is of type json::reference and has no key() member
        std::cout << "value: " << it << '\n';
    }
    @endcode

    Range-based for loop with `items()` function:

    @code{cpp}
    for (auto& el : j_object.items())
    {
        std::cout << "key: " << el.key() << ", value:" << el.value() << '\n';
    }
    @endcode

    The `items()` function also allows to use
    [structured bindings](https://en.cppreference.com/w/cpp/language/structured_binding)
    (C++17):

    @code{cpp}
    for (auto& [key, val] : j_object.items())
    {
        std::cout << "key: " << key << ", value:" << val << '\n';
    }
    @endcode

    @note When iterating over an array, `key()` will return the index of the
          element as string (see example). For primitive types (e.g., numbers),
          `key()` returns an empty string.

    @warning Using `items()` on temporary objects is dangerous. Make sure the
             object's lifetime exeeds the iteration. See
             <https://github.com/nlohmann/json/issues/2040> for more
             information.

    @return iteration proxy object wrapping @a ref with an interface to use in
            range-based for loops

    @liveexample{The following code shows how the function is used.,items}

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @since version 3.1.0, structured bindings support since 3.5.0.
    */
    iteration_proxy<iterator> items() noexcept
    {
        return iteration_proxy<iterator>(*this);
    }

    /*!
    @copydoc items()
    */
    iteration_proxy<const_iterator> items() const noexcept
    {
        return iteration_proxy<const_iterator>(*this);
    }

    /// @}


    //////////////
    // capacity //
    //////////////

    /// @name capacity
    /// @{

    /*!
    @brief checks whether the container is empty.

    Checks if a JSON value has no elements (i.e. whether its @ref size is `0`).

    @return The return value depends on the different types and is
            defined as follows:
            Value type  | return value
            ----------- | -------------
            null        | `true`
            boolean     | `false`
            string      | `false`
            number      | `false`
            binary      | `false`
            object      | result of function `object_t::empty()`
            array       | result of function `array_t::empty()`

    @liveexample{The following code uses `empty()` to check if a JSON
    object contains any elements.,empty}

    @complexity Constant, as long as @ref array_t and @ref object_t satisfy
    the Container concept; that is, their `empty()` functions have constant
    complexity.

    @iterators No changes.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @note This function does not return whether a string stored as JSON value
    is empty - it returns whether the JSON container itself is empty which is
    false in the case of a string.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is constant.
    - Has the semantics of `begin() == end()`.

    @sa @ref size() -- returns the number of elements

    @since version 1.0.0
    */
    bool empty() const noexcept
    {
        switch (m_type)
        {
            case value_t::null:
            {
                // null values are empty
                return true;
            }

            case value_t::array:
            {
                // delegate call to array_t::empty()
                return m_value.array->empty();
            }

            case value_t::object:
            {
                // delegate call to object_t::empty()
                return m_value.object->empty();
            }

            default:
            {
                // all other types are nonempty
                return false;
            }
        }
    }

    /*!
    @brief returns the number of elements

    Returns the number of elements in a JSON value.

    @return The return value depends on the different types and is
            defined as follows:
            Value type  | return value
            ----------- | -------------
            null        | `0`
            boolean     | `1`
            string      | `1`
            number      | `1`
            binary      | `1`
            object      | result of function object_t::size()
            array       | result of function array_t::size()

    @liveexample{The following code calls `size()` on the different value
    types.,size}

    @complexity Constant, as long as @ref array_t and @ref object_t satisfy
    the Container concept; that is, their size() functions have constant
    complexity.

    @iterators No changes.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @note This function does not return the length of a string stored as JSON
    value - it returns the number of elements in the JSON value which is 1 in
    the case of a string.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is constant.
    - Has the semantics of `std::distance(begin(), end())`.

    @sa @ref empty() -- checks whether the container is empty
    @sa @ref max_size() -- returns the maximal number of elements

    @since version 1.0.0
    */
    size_type size() const noexcept
    {
        switch (m_type)
        {
            case value_t::null:
            {
                // null values are empty
                return 0;
            }

            case value_t::array:
            {
                // delegate call to array_t::size()
                return m_value.array->size();
            }

            case value_t::object:
            {
                // delegate call to object_t::size()
                return m_value.object->size();
            }

            default:
            {
                // all other types have size 1
                return 1;
            }
        }
    }

    /*!
    @brief returns the maximum possible number of elements

    Returns the maximum number of elements a JSON value is able to hold due to
    system or library implementation limitations, i.e. `std::distance(begin(),
    end())` for the JSON value.

    @return The return value depends on the different types and is
            defined as follows:
            Value type  | return value
            ----------- | -------------
            null        | `0` (same as `size()`)
            boolean     | `1` (same as `size()`)
            string      | `1` (same as `size()`)
            number      | `1` (same as `size()`)
            binary      | `1` (same as `size()`)
            object      | result of function `object_t::max_size()`
            array       | result of function `array_t::max_size()`

    @liveexample{The following code calls `max_size()` on the different value
    types. Note the output is implementation specific.,max_size}

    @complexity Constant, as long as @ref array_t and @ref object_t satisfy
    the Container concept; that is, their `max_size()` functions have constant
    complexity.

    @iterators No changes.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is constant.
    - Has the semantics of returning `b.size()` where `b` is the largest
      possible JSON value.

    @sa @ref size() -- returns the number of elements

    @since version 1.0.0
    */
    size_type max_size() const noexcept
    {
        switch (m_type)
        {
            case value_t::array:
            {
                // delegate call to array_t::max_size()
                return m_value.array->max_size();
            }

            case value_t::object:
            {
                // delegate call to object_t::max_size()
                return m_value.object->max_size();
            }

            default:
            {
                // all other types have max_size() == size()
                return size();
            }
        }
    }

    /// @}


    ///////////////
    // modifiers //
    ///////////////

    /// @name modifiers
    /// @{

    /*!
    @brief clears the contents

    Clears the content of a JSON value and resets it to the default value as
    if @ref basic_json(value_t) would have been called with the current value
    type from @ref type():

    Value type  | initial value
    ----------- | -------------
    null        | `null`
    boolean     | `false`
    string      | `""`
    number      | `0`
    binary      | An empty byte vector
    object      | `{}`
    array       | `[]`

    @post Has the same effect as calling
    @code {.cpp}
    *this = basic_json(type());
    @endcode

    @liveexample{The example below shows the effect of `clear()` to different
    JSON types.,clear}

    @complexity Linear in the size of the JSON value.

    @iterators All iterators, pointers and references related to this container
               are invalidated.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @sa @ref basic_json(value_t) -- constructor that creates an object with the
        same value than calling `clear()`

    @since version 1.0.0
    */
    void clear() noexcept
    {
        switch (m_type)
        {
            case value_t::number_integer:
            {
                m_value.number_integer = 0;
                break;
            }

            case value_t::number_unsigned:
            {
                m_value.number_unsigned = 0;
                break;
            }

            case value_t::number_float:
            {
                m_value.number_float = 0.0;
                break;
            }

            case value_t::boolean:
            {
                m_value.boolean = false;
                break;
            }

            case value_t::string:
            {
                m_value.string->clear();
                break;
            }

            case value_t::binary:
            {
                m_value.binary->clear();
                break;
            }

            case value_t::array:
            {
                m_value.array->clear();
                break;
            }

            case value_t::object:
            {
                m_value.object->clear();
                break;
            }

            default:
                break;
        }
    }

    /*!
    @brief add an object to an array

    Appends the given element @a val to the end of the JSON value. If the
    function is called on a JSON null value, an empty array is created before
    appending @a val.

    @param[in] val the value to add to the JSON array

    @throw type_error.308 when called on a type other than JSON array or
    null; example: `"cannot use push_back() with number"`

    @complexity Amortized constant.

    @liveexample{The example shows how `push_back()` and `+=` can be used to
    add elements to a JSON array. Note how the `null` value was silently
    converted to a JSON array.,push_back}

    @since version 1.0.0
    */
    void push_back(basic_json&& val)
    {
        // push_back only works for null objects or arrays
        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
        {
            JSON_THROW(type_error::create(308, "cannot use push_back() with " + std::string(type_name())));
        }

        // transform null object into an array
        if (is_null())
        {
            m_type = value_t::array;
            m_value = value_t::array;
            assert_invariant();
        }

        // add element to array (move semantics)
        m_value.array->push_back(std::move(val));
        // if val is moved from, basic_json move constructor marks it null so we do not call the destructor
    }

    /*!
    @brief add an object to an array
    @copydoc push_back(basic_json&&)
    */
    reference operator+=(basic_json&& val)
    {
        push_back(std::move(val));
        return *this;
    }

    /*!
    @brief add an object to an array
    @copydoc push_back(basic_json&&)
    */
    void push_back(const basic_json& val)
    {
        // push_back only works for null objects or arrays
        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
        {
            JSON_THROW(type_error::create(308, "cannot use push_back() with " + std::string(type_name())));
        }

        // transform null object into an array
        if (is_null())
        {
            m_type = value_t::array;
            m_value = value_t::array;
            assert_invariant();
        }

        // add element to array
        m_value.array->push_back(val);
    }

    /*!
    @brief add an object to an array
    @copydoc push_back(basic_json&&)
    */
    reference operator+=(const basic_json& val)
    {
        push_back(val);
        return *this;
    }

    /*!
    @brief add an object to an object

    Inserts the given element @a val to the JSON object. If the function is
    called on a JSON null value, an empty object is created before inserting
    @a val.

    @param[in] val the value to add to the JSON object

    @throw type_error.308 when called on a type other than JSON object or
    null; example: `"cannot use push_back() with number"`

    @complexity Logarithmic in the size of the container, O(log(`size()`)).

    @liveexample{The example shows how `push_back()` and `+=` can be used to
    add elements to a JSON object. Note how the `null` value was silently
    converted to a JSON object.,push_back__object_t__value}

    @since version 1.0.0
    */
    void push_back(const typename object_t::value_type& val)
    {
        // push_back only works for null objects or objects
        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_object())))
        {
            JSON_THROW(type_error::create(308, "cannot use push_back() with " + std::string(type_name())));
        }

        // transform null object into an object
        if (is_null())
        {
            m_type = value_t::object;
            m_value = value_t::object;
            assert_invariant();
        }

        // add element to array
        m_value.object->insert(val);
    }

    /*!
    @brief add an object to an object
    @copydoc push_back(const typename object_t::value_type&)
    */
    reference operator+=(const typename object_t::value_type& val)
    {
        push_back(val);
        return *this;
    }

    /*!
    @brief add an object to an object

    This function allows to use `push_back` with an initializer list. In case

    1. the current value is an object,
    2. the initializer list @a init contains only two elements, and
    3. the first element of @a init is a string,

    @a init is converted into an object element and added using
    @ref push_back(const typename object_t::value_type&). Otherwise, @a init
    is converted to a JSON value and added using @ref push_back(basic_json&&).

    @param[in] init  an initializer list

    @complexity Linear in the size of the initializer list @a init.

    @note This function is required to resolve an ambiguous overload error,
          because pairs like `{"key", "value"}` can be both interpreted as
          `object_t::value_type` or `std::initializer_list<basic_json>`, see
          https://github.com/nlohmann/json/issues/235 for more information.

    @liveexample{The example shows how initializer lists are treated as
    objects when possible.,push_back__initializer_list}
    */
    void push_back(initializer_list_t init)
    {
        if (is_object() && init.size() == 2 && (*init.begin())->is_string())
        {
            basic_json&& key = init.begin()->moved_or_copied();
            push_back(typename object_t::value_type(
                          std::move(key.get_ref<string_t&>()), (init.begin() + 1)->moved_or_copied()));
        }
        else
        {
            push_back(basic_json(init));
        }
    }

    /*!
    @brief add an object to an object
    @copydoc push_back(initializer_list_t)
    */
    reference operator+=(initializer_list_t init)
    {
        push_back(init);
        return *this;
    }

    /*!
    @brief add an object to an array

    Creates a JSON value from the passed parameters @a args to the end of the
    JSON value. If the function is called on a JSON null value, an empty array
    is created before appending the value created from @a args.

    @param[in] args arguments to forward to a constructor of @ref basic_json
    @tparam Args compatible types to create a @ref basic_json object

    @return reference to the inserted element

    @throw type_error.311 when called on a type other than JSON array or
    null; example: `"cannot use emplace_back() with number"`

    @complexity Amortized constant.

    @liveexample{The example shows how `push_back()` can be used to add
    elements to a JSON array. Note how the `null` value was silently converted
    to a JSON array.,emplace_back}

    @since version 2.0.8, returns reference since 3.7.0
    */
    template<class... Args>
    reference emplace_back(Args&& ... args)
    {
        // emplace_back only works for null objects or arrays
        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
        {
            JSON_THROW(type_error::create(311, "cannot use emplace_back() with " + std::string(type_name())));
        }

        // transform null object into an array
        if (is_null())
        {
            m_type = value_t::array;
            m_value = value_t::array;
            assert_invariant();
        }

        // add element to array (perfect forwarding)
#ifdef JSON_HAS_CPP_17
        return m_value.array->emplace_back(std::forward<Args>(args)...);
#else
        m_value.array->emplace_back(std::forward<Args>(args)...);
        return m_value.array->back();
#endif
    }

    /*!
    @brief add an object to an object if key does not exist

    Inserts a new element into a JSON object constructed in-place with the
    given @a args if there is no element with the key in the container. If the
    function is called on a JSON null value, an empty object is created before
    appending the value created from @a args.

    @param[in] args arguments to forward to a constructor of @ref basic_json
    @tparam Args compatible types to create a @ref basic_json object

    @return a pair consisting of an iterator to the inserted element, or the
            already-existing element if no insertion happened, and a bool
            denoting whether the insertion took place.

    @throw type_error.311 when called on a type other than JSON object or
    null; example: `"cannot use emplace() with number"`

    @complexity Logarithmic in the size of the container, O(log(`size()`)).

    @liveexample{The example shows how `emplace()` can be used to add elements
    to a JSON object. Note how the `null` value was silently converted to a
    JSON object. Further note how no value is added if there was already one
    value stored with the same key.,emplace}

    @since version 2.0.8
    */
    template<class... Args>
    std::pair<iterator, bool> emplace(Args&& ... args)
    {
        // emplace only works for null objects or arrays
        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_object())))
        {
            JSON_THROW(type_error::create(311, "cannot use emplace() with " + std::string(type_name())));
        }

        // transform null object into an object
        if (is_null())
        {
            m_type = value_t::object;
            m_value = value_t::object;
            assert_invariant();
        }

        // add element to array (perfect forwarding)
        auto res = m_value.object->emplace(std::forward<Args>(args)...);
        // create result iterator and set iterator to the result of emplace
        auto it = begin();
        it.m_it.object_iterator = res.first;

        // return pair of iterator and boolean
        return {it, res.second};
    }

    /// Helper for insertion of an iterator
    /// @note: This uses std::distance to support GCC 4.8,
    ///        see https://github.com/nlohmann/json/pull/1257
    template<typename... Args>
    iterator insert_iterator(const_iterator pos, Args&& ... args)
    {
        iterator result(this);
        JSON_ASSERT(m_value.array != nullptr);

        auto insert_pos = std::distance(m_value.array->begin(), pos.m_it.array_iterator);
        m_value.array->insert(pos.m_it.array_iterator, std::forward<Args>(args)...);
        result.m_it.array_iterator = m_value.array->begin() + insert_pos;

        // This could have been written as:
        // result.m_it.array_iterator = m_value.array->insert(pos.m_it.array_iterator, cnt, val);
        // but the return value of insert is missing in GCC 4.8, so it is written this way instead.

        return result;
    }

    /*!
    @brief inserts element

    Inserts element @a val before iterator @a pos.

    @param[in] pos iterator before which the content will be inserted; may be
    the end() iterator
    @param[in] val element to insert
    @return iterator pointing to the inserted @a val.

    @throw type_error.309 if called on JSON values other than arrays;
    example: `"cannot use insert() with string"`
    @throw invalid_iterator.202 if @a pos is not an iterator of *this;
    example: `"iterator does not fit current value"`

    @complexity Constant plus linear in the distance between @a pos and end of
    the container.

    @liveexample{The example shows how `insert()` is used.,insert}

    @since version 1.0.0
    */
    iterator insert(const_iterator pos, const basic_json& val)
    {
        // insert only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            // check if iterator pos fits to this JSON value
            if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
            {
                JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
            }

            // insert to array and return iterator
            return insert_iterator(pos, val);
        }

        JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
    }

    /*!
    @brief inserts element
    @copydoc insert(const_iterator, const basic_json&)
    */
    iterator insert(const_iterator pos, basic_json&& val)
    {
        return insert(pos, val);
    }

    /*!
    @brief inserts elements

    Inserts @a cnt copies of @a val before iterator @a pos.

    @param[in] pos iterator before which the content will be inserted; may be
    the end() iterator
    @param[in] cnt number of copies of @a val to insert
    @param[in] val element to insert
    @return iterator pointing to the first element inserted, or @a pos if
    `cnt==0`

    @throw type_error.309 if called on JSON values other than arrays; example:
    `"cannot use insert() with string"`
    @throw invalid_iterator.202 if @a pos is not an iterator of *this;
    example: `"iterator does not fit current value"`

    @complexity Linear in @a cnt plus linear in the distance between @a pos
    and end of the container.

    @liveexample{The example shows how `insert()` is used.,insert__count}

    @since version 1.0.0
    */
    iterator insert(const_iterator pos, size_type cnt, const basic_json& val)
    {
        // insert only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            // check if iterator pos fits to this JSON value
            if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
            {
                JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
            }

            // insert to array and return iterator
            return insert_iterator(pos, cnt, val);
        }

        JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
    }

    /*!
    @brief inserts elements

    Inserts elements from range `[first, last)` before iterator @a pos.

    @param[in] pos iterator before which the content will be inserted; may be
    the end() iterator
    @param[in] first begin of the range of elements to insert
    @param[in] last end of the range of elements to insert

    @throw type_error.309 if called on JSON values other than arrays; example:
    `"cannot use insert() with string"`
    @throw invalid_iterator.202 if @a pos is not an iterator of *this;
    example: `"iterator does not fit current value"`
    @throw invalid_iterator.210 if @a first and @a last do not belong to the
    same JSON value; example: `"iterators do not fit"`
    @throw invalid_iterator.211 if @a first or @a last are iterators into
    container for which insert is called; example: `"passed iterators may not
    belong to container"`

    @return iterator pointing to the first element inserted, or @a pos if
    `first==last`

    @complexity Linear in `std::distance(first, last)` plus linear in the
    distance between @a pos and end of the container.

    @liveexample{The example shows how `insert()` is used.,insert__range}

    @since version 1.0.0
    */
    iterator insert(const_iterator pos, const_iterator first, const_iterator last)
    {
        // insert only works for arrays
        if (JSON_HEDLEY_UNLIKELY(!is_array()))
        {
            JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
        }

        // check if iterator pos fits to this JSON value
        if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
        {
            JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
        }

        // check if range iterators belong to the same JSON object
        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(210, "iterators do not fit"));
        }

        if (JSON_HEDLEY_UNLIKELY(first.m_object == this))
        {
            JSON_THROW(invalid_iterator::create(211, "passed iterators may not belong to container"));
        }

        // insert to array and return iterator
        return insert_iterator(pos, first.m_it.array_iterator, last.m_it.array_iterator);
    }

    /*!
    @brief inserts elements

    Inserts elements from initializer list @a ilist before iterator @a pos.

    @param[in] pos iterator before which the content will be inserted; may be
    the end() iterator
    @param[in] ilist initializer list to insert the values from

    @throw type_error.309 if called on JSON values other than arrays; example:
    `"cannot use insert() with string"`
    @throw invalid_iterator.202 if @a pos is not an iterator of *this;
    example: `"iterator does not fit current value"`

    @return iterator pointing to the first element inserted, or @a pos if
    `ilist` is empty

    @complexity Linear in `ilist.size()` plus linear in the distance between
    @a pos and end of the container.

    @liveexample{The example shows how `insert()` is used.,insert__ilist}

    @since version 1.0.0
    */
    iterator insert(const_iterator pos, initializer_list_t ilist)
    {
        // insert only works for arrays
        if (JSON_HEDLEY_UNLIKELY(!is_array()))
        {
            JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
        }

        // check if iterator pos fits to this JSON value
        if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
        {
            JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
        }

        // insert to array and return iterator
        return insert_iterator(pos, ilist.begin(), ilist.end());
    }

    /*!
    @brief inserts elements

    Inserts elements from range `[first, last)`.

    @param[in] first begin of the range of elements to insert
    @param[in] last end of the range of elements to insert

    @throw type_error.309 if called on JSON values other than objects; example:
    `"cannot use insert() with string"`
    @throw invalid_iterator.202 if iterator @a first or @a last does does not
    point to an object; example: `"iterators first and last must point to
    objects"`
    @throw invalid_iterator.210 if @a first and @a last do not belong to the
    same JSON value; example: `"iterators do not fit"`

    @complexity Logarithmic: `O(N*log(size() + N))`, where `N` is the number
    of elements to insert.

    @liveexample{The example shows how `insert()` is used.,insert__range_object}

    @since version 3.0.0
    */
    void insert(const_iterator first, const_iterator last)
    {
        // insert only works for objects
        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
        }

        // check if range iterators belong to the same JSON object
        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(210, "iterators do not fit"));
        }

        // passed iterators must belong to objects
        if (JSON_HEDLEY_UNLIKELY(!first.m_object->is_object()))
        {
            JSON_THROW(invalid_iterator::create(202, "iterators first and last must point to objects"));
        }

        m_value.object->insert(first.m_it.object_iterator, last.m_it.object_iterator);
    }

    /*!
    @brief updates a JSON object from another object, overwriting existing keys

    Inserts all values from JSON object @a j and overwrites existing keys.

    @param[in] j  JSON object to read values from

    @throw type_error.312 if called on JSON values other than objects; example:
    `"cannot use update() with string"`

    @complexity O(N*log(size() + N)), where N is the number of elements to
                insert.

    @liveexample{The example shows how `update()` is used.,update}

    @sa https://docs.python.org/3.6/library/stdtypes.html#dict.update

    @since version 3.0.0
    */
    void update(const_reference j)
    {
        // implicitly convert null value to an empty object
        if (is_null())
        {
            m_type = value_t::object;
            m_value.object = create<object_t>();
            assert_invariant();
        }

        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(312, "cannot use update() with " + std::string(type_name())));
        }
        if (JSON_HEDLEY_UNLIKELY(!j.is_object()))
        {
            JSON_THROW(type_error::create(312, "cannot use update() with " + std::string(j.type_name())));
        }

        for (auto it = j.cbegin(); it != j.cend(); ++it)
        {
            m_value.object->operator[](it.key()) = it.value();
        }
    }

    /*!
    @brief updates a JSON object from another object, overwriting existing keys

    Inserts all values from from range `[first, last)` and overwrites existing
    keys.

    @param[in] first begin of the range of elements to insert
    @param[in] last end of the range of elements to insert

    @throw type_error.312 if called on JSON values other than objects; example:
    `"cannot use update() with string"`
    @throw invalid_iterator.202 if iterator @a first or @a last does does not
    point to an object; example: `"iterators first and last must point to
    objects"`
    @throw invalid_iterator.210 if @a first and @a last do not belong to the
    same JSON value; example: `"iterators do not fit"`

    @complexity O(N*log(size() + N)), where N is the number of elements to
                insert.

    @liveexample{The example shows how `update()` is used__range.,update}

    @sa https://docs.python.org/3.6/library/stdtypes.html#dict.update

    @since version 3.0.0
    */
    void update(const_iterator first, const_iterator last)
    {
        // implicitly convert null value to an empty object
        if (is_null())
        {
            m_type = value_t::object;
            m_value.object = create<object_t>();
            assert_invariant();
        }

        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(312, "cannot use update() with " + std::string(type_name())));
        }

        // check if range iterators belong to the same JSON object
        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(210, "iterators do not fit"));
        }

        // passed iterators must belong to objects
        if (JSON_HEDLEY_UNLIKELY(!first.m_object->is_object()
                                 || !last.m_object->is_object()))
        {
            JSON_THROW(invalid_iterator::create(202, "iterators first and last must point to objects"));
        }

        for (auto it = first; it != last; ++it)
        {
            m_value.object->operator[](it.key()) = it.value();
        }
    }

    /*!
    @brief exchanges the values

    Exchanges the contents of the JSON value with those of @a other. Does not
    invoke any move, copy, or swap operations on individual elements. All
    iterators and references remain valid. The past-the-end iterator is
    invalidated.

    @param[in,out] other JSON value to exchange the contents with

    @complexity Constant.

    @liveexample{The example below shows how JSON values can be swapped with
    `swap()`.,swap__reference}

    @since version 1.0.0
    */
    void swap(reference other) noexcept (
        std::is_nothrow_move_constructible<value_t>::value&&
        std::is_nothrow_move_assignable<value_t>::value&&
        std::is_nothrow_move_constructible<json_value>::value&&
        std::is_nothrow_move_assignable<json_value>::value
    )
    {
        std::swap(m_type, other.m_type);
        std::swap(m_value, other.m_value);
        assert_invariant();
    }

    /*!
    @brief exchanges the values

    Exchanges the contents of the JSON value from @a left with those of @a right. Does not
    invoke any move, copy, or swap operations on individual elements. All
    iterators and references remain valid. The past-the-end iterator is
    invalidated. implemented as a friend function callable via ADL.

    @param[in,out] left JSON value to exchange the contents with
    @param[in,out] right JSON value to exchange the contents with

    @complexity Constant.

    @liveexample{The example below shows how JSON values can be swapped with
    `swap()`.,swap__reference}

    @since version 1.0.0
    */
    friend void swap(reference left, reference right) noexcept (
        std::is_nothrow_move_constructible<value_t>::value&&
        std::is_nothrow_move_assignable<value_t>::value&&
        std::is_nothrow_move_constructible<json_value>::value&&
        std::is_nothrow_move_assignable<json_value>::value
    )
    {
        left.swap(right);
    }

    /*!
    @brief exchanges the values

    Exchanges the contents of a JSON array with those of @a other. Does not
    invoke any move, copy, or swap operations on individual elements. All
    iterators and references remain valid. The past-the-end iterator is
    invalidated.

    @param[in,out] other array to exchange the contents with

    @throw type_error.310 when JSON value is not an array; example: `"cannot
    use swap() with string"`

    @complexity Constant.

    @liveexample{The example below shows how arrays can be swapped with
    `swap()`.,swap__array_t}

    @since version 1.0.0
    */
    void swap(array_t& other)
    {
        // swap only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            std::swap(*(m_value.array), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name())));
        }
    }

    /*!
    @brief exchanges the values

    Exchanges the contents of a JSON object with those of @a other. Does not
    invoke any move, copy, or swap operations on individual elements. All
    iterators and references remain valid. The past-the-end iterator is
    invalidated.

    @param[in,out] other object to exchange the contents with

    @throw type_error.310 when JSON value is not an object; example:
    `"cannot use swap() with string"`

    @complexity Constant.

    @liveexample{The example below shows how objects can be swapped with
    `swap()`.,swap__object_t}

    @since version 1.0.0
    */
    void swap(object_t& other)
    {
        // swap only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            std::swap(*(m_value.object), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name())));
        }
    }

    /*!
    @brief exchanges the values

    Exchanges the contents of a JSON string with those of @a other. Does not
    invoke any move, copy, or swap operations on individual elements. All
    iterators and references remain valid. The past-the-end iterator is
    invalidated.

    @param[in,out] other string to exchange the contents with

    @throw type_error.310 when JSON value is not a string; example: `"cannot
    use swap() with boolean"`

    @complexity Constant.

    @liveexample{The example below shows how strings can be swapped with
    `swap()`.,swap__string_t}

    @since version 1.0.0
    */
    void swap(string_t& other)
    {
        // swap only works for strings
        if (JSON_HEDLEY_LIKELY(is_string()))
        {
            std::swap(*(m_value.string), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name())));
        }
    }

    /*!
    @brief exchanges the values

    Exchanges the contents of a JSON string with those of @a other. Does not
    invoke any move, copy, or swap operations on individual elements. All
    iterators and references remain valid. The past-the-end iterator is
    invalidated.

    @param[in,out] other binary to exchange the contents with

    @throw type_error.310 when JSON value is not a string; example: `"cannot
    use swap() with boolean"`

    @complexity Constant.

    @liveexample{The example below shows how strings can be swapped with
    `swap()`.,swap__binary_t}

    @since version 3.8.0
    */
    void swap(binary_t& other)
    {
        // swap only works for strings
        if (JSON_HEDLEY_LIKELY(is_binary()))
        {
            std::swap(*(m_value.binary), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name())));
        }
    }

    /// @copydoc swap(binary_t)
    void swap(typename binary_t::container_type& other)
    {
        // swap only works for strings
        if (JSON_HEDLEY_LIKELY(is_binary()))
        {
            std::swap(*(m_value.binary), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name())));
        }
    }

    /// @}

  public:
    //////////////////////////////////////////
    // lexicographical comparison operators //
    //////////////////////////////////////////

    /// @name lexicographical comparison operators
    /// @{

    /*!
    @brief comparison: equal

    Compares two JSON values for equality according to the following rules:
    - Two JSON values are equal if (1) they are from the same type and (2)
      their stored values are the same according to their respective
      `operator==`.
    - Integer and floating-point numbers are automatically converted before
      comparison. Note that two NaN values are always treated as unequal.
    - Two JSON null values are equal.

    @note Floating-point inside JSON values numbers are compared with
    `json::number_float_t::operator==` which is `double::operator==` by
    default. To compare floating-point while respecting an epsilon, an alternative
    [comparison function](https://github.com/mariokonrad/marnav/blob/master/include/marnav/math/floatingpoint.hpp#L34-#L39)
    could be used, for instance
    @code {.cpp}
    template<typename T, typename = typename std::enable_if<std::is_floating_point<T>::value, T>::type>
    inline bool is_same(T a, T b, T epsilon = std::numeric_limits<T>::epsilon()) noexcept
    {
        return std::abs(a - b) <= epsilon;
    }
    @endcode
    Or you can self-defined operator equal function like this:
    @code {.cpp}
    bool my_equal(const_reference lhs, const_reference rhs) {
    const auto lhs_type lhs.type();
    const auto rhs_type rhs.type();
    if (lhs_type == rhs_type) {
        switch(lhs_type)
            // self_defined case
            case value_t::number_float:
                return std::abs(lhs - rhs) <= std::numeric_limits<float>::epsilon();
            // other cases remain the same with the original
            ...
    }
    ...
    }
    @endcode

    @note NaN values never compare equal to themselves or to other NaN values.

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether the values @a lhs and @a rhs are equal

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @complexity Linear.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__equal}

    @since version 1.0.0
    */
    friend bool operator==(const_reference lhs, const_reference rhs) noexcept
    {
        const auto lhs_type = lhs.type();
        const auto rhs_type = rhs.type();

        if (lhs_type == rhs_type)
        {
            switch (lhs_type)
            {
                case value_t::array:
                    return *lhs.m_value.array == *rhs.m_value.array;

                case value_t::object:
                    return *lhs.m_value.object == *rhs.m_value.object;

                case value_t::null:
                    return true;

                case value_t::string:
                    return *lhs.m_value.string == *rhs.m_value.string;

                case value_t::boolean:
                    return lhs.m_value.boolean == rhs.m_value.boolean;

                case value_t::number_integer:
                    return lhs.m_value.number_integer == rhs.m_value.number_integer;

                case value_t::number_unsigned:
                    return lhs.m_value.number_unsigned == rhs.m_value.number_unsigned;

                case value_t::number_float:
                    return lhs.m_value.number_float == rhs.m_value.number_float;

                case value_t::binary:
                    return *lhs.m_value.binary == *rhs.m_value.binary;

                default:
                    return false;
            }
        }
        else if (lhs_type == value_t::number_integer && rhs_type == value_t::number_float)
        {
            return static_cast<number_float_t>(lhs.m_value.number_integer) == rhs.m_value.number_float;
        }
        else if (lhs_type == value_t::number_float && rhs_type == value_t::number_integer)
        {
            return lhs.m_value.number_float == static_cast<number_float_t>(rhs.m_value.number_integer);
        }
        else if (lhs_type == value_t::number_unsigned && rhs_type == value_t::number_float)
        {
            return static_cast<number_float_t>(lhs.m_value.number_unsigned) == rhs.m_value.number_float;
        }
        else if (lhs_type == value_t::number_float && rhs_type == value_t::number_unsigned)
        {
            return lhs.m_value.number_float == static_cast<number_float_t>(rhs.m_value.number_unsigned);
        }
        else if (lhs_type == value_t::number_unsigned && rhs_type == value_t::number_integer)
        {
            return static_cast<number_integer_t>(lhs.m_value.number_unsigned) == rhs.m_value.number_integer;
        }
        else if (lhs_type == value_t::number_integer && rhs_type == value_t::number_unsigned)
        {
            return lhs.m_value.number_integer == static_cast<number_integer_t>(rhs.m_value.number_unsigned);
        }

        return false;
    }

    /*!
    @brief comparison: equal
    @copydoc operator==(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator==(const_reference lhs, const ScalarType rhs) noexcept
    {
        return lhs == basic_json(rhs);
    }

    /*!
    @brief comparison: equal
    @copydoc operator==(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator==(const ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) == rhs;
    }

    /*!
    @brief comparison: not equal

    Compares two JSON values for inequality by calculating `not (lhs == rhs)`.

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether the values @a lhs and @a rhs are not equal

    @complexity Linear.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__notequal}

    @since version 1.0.0
    */
    friend bool operator!=(const_reference lhs, const_reference rhs) noexcept
    {
        return !(lhs == rhs);
    }

    /*!
    @brief comparison: not equal
    @copydoc operator!=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator!=(const_reference lhs, const ScalarType rhs) noexcept
    {
        return lhs != basic_json(rhs);
    }

    /*!
    @brief comparison: not equal
    @copydoc operator!=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator!=(const ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) != rhs;
    }

    /*!
    @brief comparison: less than

    Compares whether one JSON value @a lhs is less than another JSON value @a
    rhs according to the following rules:
    - If @a lhs and @a rhs have the same type, the values are compared using
      the default `<` operator.
    - Integer and floating-point numbers are automatically converted before
      comparison
    - In case @a lhs and @a rhs have different types, the values are ignored
      and the order of the types is considered, see
      @ref operator<(const value_t, const value_t).

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether @a lhs is less than @a rhs

    @complexity Linear.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__less}

    @since version 1.0.0
    */
    friend bool operator<(const_reference lhs, const_reference rhs) noexcept
    {
        const auto lhs_type = lhs.type();
        const auto rhs_type = rhs.type();

        if (lhs_type == rhs_type)
        {
            switch (lhs_type)
            {
                case value_t::array:
                    // note parentheses are necessary, see
                    // https://github.com/nlohmann/json/issues/1530
                    return (*lhs.m_value.array) < (*rhs.m_value.array);

                case value_t::object:
                    return (*lhs.m_value.object) < (*rhs.m_value.object);

                case value_t::null:
                    return false;

                case value_t::string:
                    return (*lhs.m_value.string) < (*rhs.m_value.string);

                case value_t::boolean:
                    return (lhs.m_value.boolean) < (rhs.m_value.boolean);

                case value_t::number_integer:
                    return (lhs.m_value.number_integer) < (rhs.m_value.number_integer);

                case value_t::number_unsigned:
                    return (lhs.m_value.number_unsigned) < (rhs.m_value.number_unsigned);

                case value_t::number_float:
                    return (lhs.m_value.number_float) < (rhs.m_value.number_float);

                case value_t::binary:
                    return (*lhs.m_value.binary) < (*rhs.m_value.binary);

                default:
                    return false;
            }
        }
        else if (lhs_type == value_t::number_integer && rhs_type == value_t::number_float)
        {
            return static_cast<number_float_t>(lhs.m_value.number_integer) < rhs.m_value.number_float;
        }
        else if (lhs_type == value_t::number_float && rhs_type == value_t::number_integer)
        {
            return lhs.m_value.number_float < static_cast<number_float_t>(rhs.m_value.number_integer);
        }
        else if (lhs_type == value_t::number_unsigned && rhs_type == value_t::number_float)
        {
            return static_cast<number_float_t>(lhs.m_value.number_unsigned) < rhs.m_value.number_float;
        }
        else if (lhs_type == value_t::number_float && rhs_type == value_t::number_unsigned)
        {
            return lhs.m_value.number_float < static_cast<number_float_t>(rhs.m_value.number_unsigned);
        }
        else if (lhs_type == value_t::number_integer && rhs_type == value_t::number_unsigned)
        {
            return lhs.m_value.number_integer < static_cast<number_integer_t>(rhs.m_value.number_unsigned);
        }
        else if (lhs_type == value_t::number_unsigned && rhs_type == value_t::number_integer)
        {
            return static_cast<number_integer_t>(lhs.m_value.number_unsigned) < rhs.m_value.number_integer;
        }

        // We only reach this line if we cannot compare values. In that case,
        // we compare types. Note we have to call the operator explicitly,
        // because MSVC has problems otherwise.
        return operator<(lhs_type, rhs_type);
    }

    /*!
    @brief comparison: less than
    @copydoc operator<(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<(const_reference lhs, const ScalarType rhs) noexcept
    {
        return lhs < basic_json(rhs);
    }

    /*!
    @brief comparison: less than
    @copydoc operator<(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<(const ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) < rhs;
    }

    /*!
    @brief comparison: less than or equal

    Compares whether one JSON value @a lhs is less than or equal to another
    JSON value by calculating `not (rhs < lhs)`.

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether @a lhs is less than or equal to @a rhs

    @complexity Linear.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__greater}

    @since version 1.0.0
    */
    friend bool operator<=(const_reference lhs, const_reference rhs) noexcept
    {
        return !(rhs < lhs);
    }

    /*!
    @brief comparison: less than or equal
    @copydoc operator<=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<=(const_reference lhs, const ScalarType rhs) noexcept
    {
        return lhs <= basic_json(rhs);
    }

    /*!
    @brief comparison: less than or equal
    @copydoc operator<=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<=(const ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) <= rhs;
    }

    /*!
    @brief comparison: greater than

    Compares whether one JSON value @a lhs is greater than another
    JSON value by calculating `not (lhs <= rhs)`.

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether @a lhs is greater than to @a rhs

    @complexity Linear.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__lessequal}

    @since version 1.0.0
    */
    friend bool operator>(const_reference lhs, const_reference rhs) noexcept
    {
        return !(lhs <= rhs);
    }

    /*!
    @brief comparison: greater than
    @copydoc operator>(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>(const_reference lhs, const ScalarType rhs) noexcept
    {
        return lhs > basic_json(rhs);
    }

    /*!
    @brief comparison: greater than
    @copydoc operator>(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>(const ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) > rhs;
    }

    /*!
    @brief comparison: greater than or equal

    Compares whether one JSON value @a lhs is greater than or equal to another
    JSON value by calculating `not (lhs < rhs)`.

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether @a lhs is greater than or equal to @a rhs

    @complexity Linear.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__greaterequal}

    @since version 1.0.0
    */
    friend bool operator>=(const_reference lhs, const_reference rhs) noexcept
    {
        return !(lhs < rhs);
    }

    /*!
    @brief comparison: greater than or equal
    @copydoc operator>=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>=(const_reference lhs, const ScalarType rhs) noexcept
    {
        return lhs >= basic_json(rhs);
    }

    /*!
    @brief comparison: greater than or equal
    @copydoc operator>=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>=(const ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) >= rhs;
    }

    /// @}

    ///////////////////
    // serialization //
    ///////////////////

    /// @name serialization
    /// @{

    /*!
    @brief serialize to stream

    Serialize the given JSON value @a j to the output stream @a o. The JSON
    value will be serialized using the @ref dump member function.

    - The indentation of the output can be controlled with the member variable
      `width` of the output stream @a o. For instance, using the manipulator
      `std::setw(4)` on @a o sets the indentation level to `4` and the
      serialization result is the same as calling `dump(4)`.

    - The indentation character can be controlled with the member variable
      `fill` of the output stream @a o. For instance, the manipulator
      `std::setfill('\\t')` sets indentation to use a tab character rather than
      the default space character.

    @param[in,out] o  stream to serialize to
    @param[in] j  JSON value to serialize

    @return the stream @a o

    @throw type_error.316 if a string stored inside the JSON value is not
                          UTF-8 encoded

    @complexity Linear.

    @liveexample{The example below shows the serialization with different
    parameters to `width` to adjust the indentation level.,operator_serialize}

    @since version 1.0.0; indentation character added in version 3.0.0
    */
    friend std::ostream& operator<<(std::ostream& o, const basic_json& j)
    {
        // read width member and use it as indentation parameter if nonzero
        const bool pretty_print = o.width() > 0;
        const auto indentation = pretty_print ? o.width() : 0;

        // reset width to 0 for subsequent calls to this stream
        o.width(0);

        // do the actual serialization
        serializer s(detail::output_adapter<char>(o), o.fill());
        s.dump(j, pretty_print, false, static_cast<unsigned int>(indentation));
        return o;
    }

    /*!
    @brief serialize to stream
    @deprecated This stream operator is deprecated and will be removed in
                future 4.0.0 of the library. Please use
                @ref operator<<(std::ostream&, const basic_json&)
                instead; that is, replace calls like `j >> o;` with `o << j;`.
    @since version 1.0.0; deprecated since version 3.0.0
    */
    JSON_HEDLEY_DEPRECATED_FOR(3.0.0, operator<<(std::ostream&, const basic_json&))
    friend std::ostream& operator>>(const basic_json& j, std::ostream& o)
    {
        return o << j;
    }

    /// @}


    /////////////////////
    // deserialization //
    /////////////////////

    /// @name deserialization
    /// @{

    /*!
    @brief deserialize from a compatible input

    @tparam InputType A compatible input, for instance
    - an std::istream object
    - a FILE pointer
    - a C-style array of characters
    - a pointer to a null-terminated string of single byte characters
    - an object obj for which begin(obj) and end(obj) produces a valid pair of
      iterators.

    @param[in] i  input to read from
    @param[in] cb  a parser callback function of type @ref parser_callback_t
    which is used to control the deserialization by filtering unwanted values
    (optional)
    @param[in] allow_exceptions  whether to throw exceptions in case of a
    parse error (optional, true by default)
    @param[in] ignore_comments  whether comments should be ignored and treated
    like whitespace (true) or yield a parse error (true); (optional, false by
    default)

    @return deserialized JSON value; in case of a parse error and
            @a allow_exceptions set to `false`, the return value will be
            value_t::discarded.

    @throw parse_error.101 if a parse error occurs; example: `""unexpected end
    of input; expected string literal""`
    @throw parse_error.102 if to_unicode fails or surrogate error
    @throw parse_error.103 if to_unicode fails

    @complexity Linear in the length of the input. The parser is a predictive
    LL(1) parser. The complexity can be higher if the parser callback function
    @a cb or reading from the input @a i has a super-linear complexity.

    @note A UTF-8 byte order mark is silently ignored.

    @liveexample{The example below demonstrates the `parse()` function reading
    from an array.,parse__array__parser_callback_t}

    @liveexample{The example below demonstrates the `parse()` function with
    and without callback function.,parse__string__parser_callback_t}

    @liveexample{The example below demonstrates the `parse()` function with
    and without callback function.,parse__istream__parser_callback_t}

    @liveexample{The example below demonstrates the `parse()` function reading
    from a contiguous container.,parse__contiguouscontainer__parser_callback_t}

    @since version 2.0.3 (contiguous containers); version 3.9.0 allowed to
    ignore comments.
    */
    template<typename InputType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json parse(InputType&& i,
                            const parser_callback_t cb = nullptr,
                            const bool allow_exceptions = true,
                            const bool ignore_comments = false)
    {
        basic_json result;
        parser(detail::input_adapter(std::forward<InputType>(i)), cb, allow_exceptions, ignore_comments).parse(true, result);
        return result;
    }

    /*!
    @brief deserialize from a pair of character iterators

    The value_type of the iterator must be a integral type with size of 1, 2 or
    4 bytes, which will be interpreted respectively as UTF-8, UTF-16 and UTF-32.

    @param[in] first iterator to start of character range
    @param[in] last  iterator to end of character range
    @param[in] cb  a parser callback function of type @ref parser_callback_t
    which is used to control the deserialization by filtering unwanted values
    (optional)
    @param[in] allow_exceptions  whether to throw exceptions in case of a
    parse error (optional, true by default)
    @param[in] ignore_comments  whether comments should be ignored and treated
    like whitespace (true) or yield a parse error (true); (optional, false by
    default)

    @return deserialized JSON value; in case of a parse error and
            @a allow_exceptions set to `false`, the return value will be
            value_t::discarded.

    @throw parse_error.101 if a parse error occurs; example: `""unexpected end
    of input; expected string literal""`
    @throw parse_error.102 if to_unicode fails or surrogate error
    @throw parse_error.103 if to_unicode fails
    */
    template<typename IteratorType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json parse(IteratorType first,
                            IteratorType last,
                            const parser_callback_t cb = nullptr,
                            const bool allow_exceptions = true,
                            const bool ignore_comments = false)
    {
        basic_json result;
        parser(detail::input_adapter(std::move(first), std::move(last)), cb, allow_exceptions, ignore_comments).parse(true, result);
        return result;
    }

    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, parse(ptr, ptr + len))
    static basic_json parse(detail::span_input_adapter&& i,
                            const parser_callback_t cb = nullptr,
                            const bool allow_exceptions = true,
                            const bool ignore_comments = false)
    {
        basic_json result;
        parser(i.get(), cb, allow_exceptions, ignore_comments).parse(true, result);
        return result;
    }

    /*!
    @brief check if the input is valid JSON

    Unlike the @ref parse(InputType&&, const parser_callback_t,const bool)
    function, this function neither throws an exception in case of invalid JSON
    input (i.e., a parse error) nor creates diagnostic information.

    @tparam InputType A compatible input, for instance
    - an std::istream object
    - a FILE pointer
    - a C-style array of characters
    - a pointer to a null-terminated string of single byte characters
    - an object obj for which begin(obj) and end(obj) produces a valid pair of
      iterators.

    @param[in] i input to read from
    @param[in] ignore_comments  whether comments should be ignored and treated
    like whitespace (true) or yield a parse error (true); (optional, false by
    default)

    @return Whether the input read from @a i is valid JSON.

    @complexity Linear in the length of the input. The parser is a predictive
    LL(1) parser.

    @note A UTF-8 byte order mark is silently ignored.

    @liveexample{The example below demonstrates the `accept()` function reading
    from a string.,accept__string}
    */
    template<typename InputType>
    static bool accept(InputType&& i,
                       const bool ignore_comments = false)
    {
        return parser(detail::input_adapter(std::forward<InputType>(i)), nullptr, false, ignore_comments).accept(true);
    }

    template<typename IteratorType>
    static bool accept(IteratorType first, IteratorType last,
                       const bool ignore_comments = false)
    {
        return parser(detail::input_adapter(std::move(first), std::move(last)), nullptr, false, ignore_comments).accept(true);
    }

    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, accept(ptr, ptr + len))
    static bool accept(detail::span_input_adapter&& i,
                       const bool ignore_comments = false)
    {
        return parser(i.get(), nullptr, false, ignore_comments).accept(true);
    }

    /*!
    @brief generate SAX events

    The SAX event lister must follow the interface of @ref json_sax.

    This function reads from a compatible input. Examples are:
    - an std::istream object
    - a FILE pointer
    - a C-style array of characters
    - a pointer to a null-terminated string of single byte characters
    - an object obj for which begin(obj) and end(obj) produces a valid pair of
      iterators.

    @param[in] i  input to read from
    @param[in,out] sax  SAX event listener
    @param[in] format  the format to parse (JSON, CBOR, MessagePack, or UBJSON)
    @param[in] strict  whether the input has to be consumed completely
    @param[in] ignore_comments  whether comments should be ignored and treated
    like whitespace (true) or yield a parse error (true); (optional, false by
    default); only applies to the JSON file format.

    @return return value of the last processed SAX event

    @throw parse_error.101 if a parse error occurs; example: `""unexpected end
    of input; expected string literal""`
    @throw parse_error.102 if to_unicode fails or surrogate error
    @throw parse_error.103 if to_unicode fails

    @complexity Linear in the length of the input. The parser is a predictive
    LL(1) parser. The complexity can be higher if the SAX consumer @a sax has
    a super-linear complexity.

    @note A UTF-8 byte order mark is silently ignored.

    @liveexample{The example below demonstrates the `sax_parse()` function
    reading from string and processing the events with a user-defined SAX
    event consumer.,sax_parse}

    @since version 3.2.0
    */
    template <typename InputType, typename SAX>
    JSON_HEDLEY_NON_NULL(2)
    static bool sax_parse(InputType&& i, SAX* sax,
                          input_format_t format = input_format_t::json,
                          const bool strict = true,
                          const bool ignore_comments = false)
    {
        auto ia = detail::input_adapter(std::forward<InputType>(i));
        return format == input_format_t::json
               ? parser(std::move(ia), nullptr, true, ignore_comments).sax_parse(sax, strict)
               : detail::binary_reader<basic_json, decltype(ia), SAX>(std::move(ia)).sax_parse(format, sax, strict);
    }

    template<class IteratorType, class SAX>
    JSON_HEDLEY_NON_NULL(3)
    static bool sax_parse(IteratorType first, IteratorType last, SAX* sax,
                          input_format_t format = input_format_t::json,
                          const bool strict = true,
                          const bool ignore_comments = false)
    {
        auto ia = detail::input_adapter(std::move(first), std::move(last));
        return format == input_format_t::json
               ? parser(std::move(ia), nullptr, true, ignore_comments).sax_parse(sax, strict)
               : detail::binary_reader<basic_json, decltype(ia), SAX>(std::move(ia)).sax_parse(format, sax, strict);
    }

    template <typename SAX>
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, sax_parse(ptr, ptr + len, ...))
    JSON_HEDLEY_NON_NULL(2)
    static bool sax_parse(detail::span_input_adapter&& i, SAX* sax,
                          input_format_t format = input_format_t::json,
                          const bool strict = true,
                          const bool ignore_comments = false)
    {
        auto ia = i.get();
        return format == input_format_t::json
               ? parser(std::move(ia), nullptr, true, ignore_comments).sax_parse(sax, strict)
               : detail::binary_reader<basic_json, decltype(ia), SAX>(std::move(ia)).sax_parse(format, sax, strict);
    }

    /*!
    @brief deserialize from stream
    @deprecated This stream operator is deprecated and will be removed in
                version 4.0.0 of the library. Please use
                @ref operator>>(std::istream&, basic_json&)
                instead; that is, replace calls like `j << i;` with `i >> j;`.
    @since version 1.0.0; deprecated since version 3.0.0
    */
    JSON_HEDLEY_DEPRECATED_FOR(3.0.0, operator>>(std::istream&, basic_json&))
    friend std::istream& operator<<(basic_json& j, std::istream& i)
    {
        return operator>>(i, j);
    }

    /*!
    @brief deserialize from stream

    Deserializes an input stream to a JSON value.

    @param[in,out] i  input stream to read a serialized JSON value from
    @param[in,out] j  JSON value to write the deserialized input to

    @throw parse_error.101 in case of an unexpected token
    @throw parse_error.102 if to_unicode fails or surrogate error
    @throw parse_error.103 if to_unicode fails

    @complexity Linear in the length of the input. The parser is a predictive
    LL(1) parser.

    @note A UTF-8 byte order mark is silently ignored.

    @liveexample{The example below shows how a JSON value is constructed by
    reading a serialization from a stream.,operator_deserialize}

    @sa parse(std::istream&, const parser_callback_t) for a variant with a
    parser callback function to filter values while parsing

    @since version 1.0.0
    */
    friend std::istream& operator>>(std::istream& i, basic_json& j)
    {
        parser(detail::input_adapter(i)).parse(false, j);
        return i;
    }

    /// @}

    ///////////////////////////
    // convenience functions //
    ///////////////////////////

    /*!
    @brief return the type as string

    Returns the type name as string to be used in error messages - usually to
    indicate that a function was called on a wrong JSON type.

    @return a string representation of a the @a m_type member:
            Value type  | return value
            ----------- | -------------
            null        | `"null"`
            boolean     | `"boolean"`
            string      | `"string"`
            number      | `"number"` (for all number types)
            object      | `"object"`
            array       | `"array"`
            binary      | `"binary"`
            discarded   | `"discarded"`

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @complexity Constant.

    @liveexample{The following code exemplifies `type_name()` for all JSON
    types.,type_name}

    @sa @ref type() -- return the type of the JSON value
    @sa @ref operator value_t() -- return the type of the JSON value (implicit)

    @since version 1.0.0, public since 2.1.0, `const char*` and `noexcept`
    since 3.0.0
    */
    JSON_HEDLEY_RETURNS_NON_NULL
    const char* type_name() const noexcept
    {
        {
            switch (m_type)
            {
                case value_t::null:
                    return "null";
                case value_t::object:
                    return "object";
                case value_t::array:
                    return "array";
                case value_t::string:
                    return "string";
                case value_t::boolean:
                    return "boolean";
                case value_t::binary:
                    return "binary";
                case value_t::discarded:
                    return "discarded";
                default:
                    return "number";
            }
        }
    }


  private:
    //////////////////////
    // member variables //
    //////////////////////

    /// the type of the current element
    value_t m_type = value_t::null;

    /// the value of the current element
    json_value m_value = {};

    //////////////////////////////////////////
    // binary serialization/deserialization //
    //////////////////////////////////////////

    /// @name binary serialization/deserialization support
    /// @{

  public:
    /*!
    @brief create a CBOR serialization of a given JSON value

    Serializes a given JSON value @a j to a byte vector using the CBOR (Concise
    Binary Object Representation) serialization format. CBOR is a binary
    serialization format which aims to be more compact than JSON itself, yet
    more efficient to parse.

    The library uses the following mapping from JSON values types to
    CBOR types according to the CBOR specification (RFC 7049):

    JSON value type | value/range                                | CBOR type                          | first byte
    --------------- | ------------------------------------------ | ---------------------------------- | ---------------
    null            | `null`                                     | Null                               | 0xF6
    boolean         | `true`                                     | True                               | 0xF5
    boolean         | `false`                                    | False                              | 0xF4
    number_integer  | -9223372036854775808..-2147483649          | Negative integer (8 bytes follow)  | 0x3B
    number_integer  | -2147483648..-32769                        | Negative integer (4 bytes follow)  | 0x3A
    number_integer  | -32768..-129                               | Negative integer (2 bytes follow)  | 0x39
    number_integer  | -128..-25                                  | Negative integer (1 byte follow)   | 0x38
    number_integer  | -24..-1                                    | Negative integer                   | 0x20..0x37
    number_integer  | 0..23                                      | Integer                            | 0x00..0x17
    number_integer  | 24..255                                    | Unsigned integer (1 byte follow)   | 0x18
    number_integer  | 256..65535                                 | Unsigned integer (2 bytes follow)  | 0x19
    number_integer  | 65536..4294967295                          | Unsigned integer (4 bytes follow)  | 0x1A
    number_integer  | 4294967296..18446744073709551615           | Unsigned integer (8 bytes follow)  | 0x1B
    number_unsigned | 0..23                                      | Integer                            | 0x00..0x17
    number_unsigned | 24..255                                    | Unsigned integer (1 byte follow)   | 0x18
    number_unsigned | 256..65535                                 | Unsigned integer (2 bytes follow)  | 0x19
    number_unsigned | 65536..4294967295                          | Unsigned integer (4 bytes follow)  | 0x1A
    number_unsigned | 4294967296..18446744073709551615           | Unsigned integer (8 bytes follow)  | 0x1B
    number_float    | *any value representable by a float*       | Single-Precision Float             | 0xFA
    number_float    | *any value NOT representable by a float*   | Double-Precision Float             | 0xFB
    string          | *length*: 0..23                            | UTF-8 string                       | 0x60..0x77
    string          | *length*: 23..255                          | UTF-8 string (1 byte follow)       | 0x78
    string          | *length*: 256..65535                       | UTF-8 string (2 bytes follow)      | 0x79
    string          | *length*: 65536..4294967295                | UTF-8 string (4 bytes follow)      | 0x7A
    string          | *length*: 4294967296..18446744073709551615 | UTF-8 string (8 bytes follow)      | 0x7B
    array           | *size*: 0..23                              | array                              | 0x80..0x97
    array           | *size*: 23..255                            | array (1 byte follow)              | 0x98
    array           | *size*: 256..65535                         | array (2 bytes follow)             | 0x99
    array           | *size*: 65536..4294967295                  | array (4 bytes follow)             | 0x9A
    array           | *size*: 4294967296..18446744073709551615   | array (8 bytes follow)             | 0x9B
    object          | *size*: 0..23                              | map                                | 0xA0..0xB7
    object          | *size*: 23..255                            | map (1 byte follow)                | 0xB8
    object          | *size*: 256..65535                         | map (2 bytes follow)               | 0xB9
    object          | *size*: 65536..4294967295                  | map (4 bytes follow)               | 0xBA
    object          | *size*: 4294967296..18446744073709551615   | map (8 bytes follow)               | 0xBB
    binary          | *size*: 0..23                              | byte string                        | 0x40..0x57
    binary          | *size*: 23..255                            | byte string (1 byte follow)        | 0x58
    binary          | *size*: 256..65535                         | byte string (2 bytes follow)       | 0x59
    binary          | *size*: 65536..4294967295                  | byte string (4 bytes follow)       | 0x5A
    binary          | *size*: 4294967296..18446744073709551615   | byte string (8 bytes follow)       | 0x5B

    @note The mapping is **complete** in the sense that any JSON value type
          can be converted to a CBOR value.

    @note If NaN or Infinity are stored inside a JSON number, they are
          serialized properly. This behavior differs from the @ref dump()
          function which serializes NaN or Infinity to `null`.

    @note The following CBOR types are not used in the conversion:
          - UTF-8 strings terminated by "break" (0x7F)
          - arrays terminated by "break" (0x9F)
          - maps terminated by "break" (0xBF)
          - byte strings terminated by "break" (0x5F)
          - date/time (0xC0..0xC1)
          - bignum (0xC2..0xC3)
          - decimal fraction (0xC4)
          - bigfloat (0xC5)
          - expected conversions (0xD5..0xD7)
          - simple values (0xE0..0xF3, 0xF8)
          - undefined (0xF7)
          - half-precision floats (0xF9)
          - break (0xFF)

    @param[in] j  JSON value to serialize
    @return CBOR serialization as byte vector

    @complexity Linear in the size of the JSON value @a j.

    @liveexample{The example shows the serialization of a JSON value to a byte
    vector in CBOR format.,to_cbor}

    @sa http://cbor.io
    @sa @ref from_cbor(detail::input_adapter&&, const bool, const bool, const cbor_tag_handler_t) for the
        analogous deserialization
    @sa @ref to_msgpack(const basic_json&) for the related MessagePack format
    @sa @ref to_ubjson(const basic_json&, const bool, const bool) for the
             related UBJSON format

    @since version 2.0.9; compact representation of floating-point numbers
           since version 3.8.0
    */
    static std::vector<uint8_t> to_cbor(const basic_json& j)
    {
        std::vector<uint8_t> result;
        to_cbor(j, result);
        return result;
    }

    static void to_cbor(const basic_json& j, detail::output_adapter<uint8_t> o)
    {
        binary_writer<uint8_t>(o).write_cbor(j);
    }

    static void to_cbor(const basic_json& j, detail::output_adapter<char> o)
    {
        binary_writer<char>(o).write_cbor(j);
    }

    /*!
    @brief create a MessagePack serialization of a given JSON value

    Serializes a given JSON value @a j to a byte vector using the MessagePack
    serialization format. MessagePack is a binary serialization format which
    aims to be more compact than JSON itself, yet more efficient to parse.

    The library uses the following mapping from JSON values types to
    MessagePack types according to the MessagePack specification:

    JSON value type | value/range                       | MessagePack type | first byte
    --------------- | --------------------------------- | ---------------- | ----------
    null            | `null`                            | nil              | 0xC0
    boolean         | `true`                            | true             | 0xC3
    boolean         | `false`                           | false            | 0xC2
    number_integer  | -9223372036854775808..-2147483649 | int64            | 0xD3
    number_integer  | -2147483648..-32769               | int32            | 0xD2
    number_integer  | -32768..-129                      | int16            | 0xD1
    number_integer  | -128..-33                         | int8             | 0xD0
    number_integer  | -32..-1                           | negative fixint  | 0xE0..0xFF
    number_integer  | 0..127                            | positive fixint  | 0x00..0x7F
    number_integer  | 128..255                          | uint 8           | 0xCC
    number_integer  | 256..65535                        | uint 16          | 0xCD
    number_integer  | 65536..4294967295                 | uint 32          | 0xCE
    number_integer  | 4294967296..18446744073709551615  | uint 64          | 0xCF
    number_unsigned | 0..127                            | positive fixint  | 0x00..0x7F
    number_unsigned | 128..255                          | uint 8           | 0xCC
    number_unsigned | 256..65535                        | uint 16          | 0xCD
    number_unsigned | 65536..4294967295                 | uint 32          | 0xCE
    number_unsigned | 4294967296..18446744073709551615  | uint 64          | 0xCF
    number_float    | *any value representable by a float*     | float 32 | 0xCA
    number_float    | *any value NOT representable by a float* | float 64 | 0xCB
    string          | *length*: 0..31                   | fixstr           | 0xA0..0xBF
    string          | *length*: 32..255                 | str 8            | 0xD9
    string          | *length*: 256..65535              | str 16           | 0xDA
    string          | *length*: 65536..4294967295       | str 32           | 0xDB
    array           | *size*: 0..15                     | fixarray         | 0x90..0x9F
    array           | *size*: 16..65535                 | array 16         | 0xDC
    array           | *size*: 65536..4294967295         | array 32         | 0xDD
    object          | *size*: 0..15                     | fix map          | 0x80..0x8F
    object          | *size*: 16..65535                 | map 16           | 0xDE
    object          | *size*: 65536..4294967295         | map 32           | 0xDF
    binary          | *size*: 0..255                    | bin 8            | 0xC4
    binary          | *size*: 256..65535                | bin 16           | 0xC5
    binary          | *size*: 65536..4294967295         | bin 32           | 0xC6

    @note The mapping is **complete** in the sense that any JSON value type
          can be converted to a MessagePack value.

    @note The following values can **not** be converted to a MessagePack value:
          - strings with more than 4294967295 bytes
          - byte strings with more than 4294967295 bytes
          - arrays with more than 4294967295 elements
          - objects with more than 4294967295 elements

    @note Any MessagePack output created @ref to_msgpack can be successfully
          parsed by @ref from_msgpack.

    @note If NaN or Infinity are stored inside a JSON number, they are
          serialized properly. This behavior differs from the @ref dump()
          function which serializes NaN or Infinity to `null`.

    @param[in] j  JSON value to serialize
    @return MessagePack serialization as byte vector

    @complexity Linear in the size of the JSON value @a j.

    @liveexample{The example shows the serialization of a JSON value to a byte
    vector in MessagePack format.,to_msgpack}

    @sa http://msgpack.org
    @sa @ref from_msgpack for the analogous deserialization
    @sa @ref to_cbor(const basic_json& for the related CBOR format
    @sa @ref to_ubjson(const basic_json&, const bool, const bool) for the
             related UBJSON format

    @since version 2.0.9
    */
    static std::vector<uint8_t> to_msgpack(const basic_json& j)
    {
        std::vector<uint8_t> result;
        to_msgpack(j, result);
        return result;
    }

    static void to_msgpack(const basic_json& j, detail::output_adapter<uint8_t> o)
    {
        binary_writer<uint8_t>(o).write_msgpack(j);
    }

    static void to_msgpack(const basic_json& j, detail::output_adapter<char> o)
    {
        binary_writer<char>(o).write_msgpack(j);
    }

    /*!
    @brief create a UBJSON serialization of a given JSON value

    Serializes a given JSON value @a j to a byte vector using the UBJSON
    (Universal Binary JSON) serialization format. UBJSON aims to be more compact
    than JSON itself, yet more efficient to parse.

    The library uses the following mapping from JSON values types to
    UBJSON types according to the UBJSON specification:

    JSON value type | value/range                       | UBJSON type | marker
    --------------- | --------------------------------- | ----------- | ------
    null            | `null`                            | null        | `Z`
    boolean         | `true`                            | true        | `T`
    boolean         | `false`                           | false       | `F`
    number_integer  | -9223372036854775808..-2147483649 | int64       | `L`
    number_integer  | -2147483648..-32769               | int32       | `l`
    number_integer  | -32768..-129                      | int16       | `I`
    number_integer  | -128..127                         | int8        | `i`
    number_integer  | 128..255                          | uint8       | `U`
    number_integer  | 256..32767                        | int16       | `I`
    number_integer  | 32768..2147483647                 | int32       | `l`
    number_integer  | 2147483648..9223372036854775807   | int64       | `L`
    number_unsigned | 0..127                            | int8        | `i`
    number_unsigned | 128..255                          | uint8       | `U`
    number_unsigned | 256..32767                        | int16       | `I`
    number_unsigned | 32768..2147483647                 | int32       | `l`
    number_unsigned | 2147483648..9223372036854775807   | int64       | `L`
    number_unsigned | 2147483649..18446744073709551615  | high-precision | `H`
    number_float    | *any value*                       | float64     | `D`
    string          | *with shortest length indicator*  | string      | `S`
    array           | *see notes on optimized format*   | array       | `[`
    object          | *see notes on optimized format*   | map         | `{`

    @note The mapping is **complete** in the sense that any JSON value type
          can be converted to a UBJSON value.

    @note The following values can **not** be converted to a UBJSON value:
          - strings with more than 9223372036854775807 bytes (theoretical)

    @note The following markers are not used in the conversion:
          - `Z`: no-op values are not created.
          - `C`: single-byte strings are serialized with `S` markers.

    @note Any UBJSON output created @ref to_ubjson can be successfully parsed
          by @ref from_ubjson.

    @note If NaN or Infinity are stored inside a JSON number, they are
          serialized properly. This behavior differs from the @ref dump()
          function which serializes NaN or Infinity to `null`.

    @note The optimized formats for containers are supported: Parameter
          @a use_size adds size information to the beginning of a container and
          removes the closing marker. Parameter @a use_type further checks
          whether all elements of a container have the same type and adds the
          type marker to the beginning of the container. The @a use_type
          parameter must only be used together with @a use_size = true. Note
          that @a use_size = true alone may result in larger representations -
          the benefit of this parameter is that the receiving side is
          immediately informed on the number of elements of the container.

    @note If the JSON data contains the binary type, the value stored is a list
          of integers, as suggested by the UBJSON documentation.  In particular,
          this means that serialization and the deserialization of a JSON
          containing binary values into UBJSON and back will result in a
          different JSON object.

    @param[in] j  JSON value to serialize
    @param[in] use_size  whether to add size annotations to container types
    @param[in] use_type  whether to add type annotations to container types
                         (must be combined with @a use_size = true)
    @return UBJSON serialization as byte vector

    @complexity Linear in the size of the JSON value @a j.

    @liveexample{The example shows the serialization of a JSON value to a byte
    vector in UBJSON format.,to_ubjson}

    @sa http://ubjson.org
    @sa @ref from_ubjson(detail::input_adapter&&, const bool, const bool) for the
        analogous deserialization
    @sa @ref to_cbor(const basic_json& for the related CBOR format
    @sa @ref to_msgpack(const basic_json&) for the related MessagePack format

    @since version 3.1.0
    */
    static std::vector<uint8_t> to_ubjson(const basic_json& j,
                                          const bool use_size = false,
                                          const bool use_type = false)
    {
        std::vector<uint8_t> result;
        to_ubjson(j, result, use_size, use_type);
        return result;
    }

    static void to_ubjson(const basic_json& j, detail::output_adapter<uint8_t> o,
                          const bool use_size = false, const bool use_type = false)
    {
        binary_writer<uint8_t>(o).write_ubjson(j, use_size, use_type);
    }

    static void to_ubjson(const basic_json& j, detail::output_adapter<char> o,
                          const bool use_size = false, const bool use_type = false)
    {
        binary_writer<char>(o).write_ubjson(j, use_size, use_type);
    }


    /*!
    @brief Serializes the given JSON object `j` to BSON and returns a vector
           containing the corresponding BSON-representation.

    BSON (Binary JSON) is a binary format in which zero or more ordered key/value pairs are
    stored as a single entity (a so-called document).

    The library uses the following mapping from JSON values types to BSON types:

    JSON value type | value/range                       | BSON type   | marker
    --------------- | --------------------------------- | ----------- | ------
    null            | `null`                            | null        | 0x0A
    boolean         | `true`, `false`                   | boolean     | 0x08
    number_integer  | -9223372036854775808..-2147483649 | int64       | 0x12
    number_integer  | -2147483648..2147483647           | int32       | 0x10
    number_integer  | 2147483648..9223372036854775807   | int64       | 0x12
    number_unsigned | 0..2147483647                     | int32       | 0x10
    number_unsigned | 2147483648..9223372036854775807   | int64       | 0x12
    number_unsigned | 9223372036854775808..18446744073709551615| --   | --
    number_float    | *any value*                       | double      | 0x01
    string          | *any value*                       | string      | 0x02
    array           | *any value*                       | document    | 0x04
    object          | *any value*                       | document    | 0x03
    binary          | *any value*                       | binary      | 0x05

    @warning The mapping is **incomplete**, since only JSON-objects (and things
    contained therein) can be serialized to BSON.
    Also, integers larger than 9223372036854775807 cannot be serialized to BSON,
    and the keys may not contain U+0000, since they are serialized a
    zero-terminated c-strings.

    @throw out_of_range.407  if `j.is_number_unsigned() && j.get<std::uint64_t>() > 9223372036854775807`
    @throw out_of_range.409  if a key in `j` contains a NULL (U+0000)
    @throw type_error.317    if `!j.is_object()`

    @pre The input `j` is required to be an object: `j.is_object() == true`.

    @note Any BSON output created via @ref to_bson can be successfully parsed
          by @ref from_bson.

    @param[in] j  JSON value to serialize
    @return BSON serialization as byte vector

    @complexity Linear in the size of the JSON value @a j.

    @liveexample{The example shows the serialization of a JSON value to a byte
    vector in BSON format.,to_bson}

    @sa http://bsonspec.org/spec.html
    @sa @ref from_bson(detail::input_adapter&&, const bool strict) for the
        analogous deserialization
    @sa @ref to_ubjson(const basic_json&, const bool, const bool) for the
             related UBJSON format
    @sa @ref to_cbor(const basic_json&) for the related CBOR format
    @sa @ref to_msgpack(const basic_json&) for the related MessagePack format
    */
    static std::vector<uint8_t> to_bson(const basic_json& j)
    {
        std::vector<uint8_t> result;
        to_bson(j, result);
        return result;
    }

    /*!
    @brief Serializes the given JSON object `j` to BSON and forwards the
           corresponding BSON-representation to the given output_adapter `o`.
    @param j The JSON object to convert to BSON.
    @param o The output adapter that receives the binary BSON representation.
    @pre The input `j` shall be an object: `j.is_object() == true`
    @sa @ref to_bson(const basic_json&)
    */
    static void to_bson(const basic_json& j, detail::output_adapter<uint8_t> o)
    {
        binary_writer<uint8_t>(o).write_bson(j);
    }

    /*!
    @copydoc to_bson(const basic_json&, detail::output_adapter<uint8_t>)
    */
    static void to_bson(const basic_json& j, detail::output_adapter<char> o)
    {
        binary_writer<char>(o).write_bson(j);
    }


    /*!
    @brief create a JSON value from an input in CBOR format

    Deserializes a given input @a i to a JSON value using the CBOR (Concise
    Binary Object Representation) serialization format.

    The library maps CBOR types to JSON value types as follows:

    CBOR type              | JSON value type | first byte
    ---------------------- | --------------- | ----------
    Integer                | number_unsigned | 0x00..0x17
    Unsigned integer       | number_unsigned | 0x18
    Unsigned integer       | number_unsigned | 0x19
    Unsigned integer       | number_unsigned | 0x1A
    Unsigned integer       | number_unsigned | 0x1B
    Negative integer       | number_integer  | 0x20..0x37
    Negative integer       | number_integer  | 0x38
    Negative integer       | number_integer  | 0x39
    Negative integer       | number_integer  | 0x3A
    Negative integer       | number_integer  | 0x3B
    Byte string            | binary          | 0x40..0x57
    Byte string            | binary          | 0x58
    Byte string            | binary          | 0x59
    Byte string            | binary          | 0x5A
    Byte string            | binary          | 0x5B
    UTF-8 string           | string          | 0x60..0x77
    UTF-8 string           | string          | 0x78
    UTF-8 string           | string          | 0x79
    UTF-8 string           | string          | 0x7A
    UTF-8 string           | string          | 0x7B
    UTF-8 string           | string          | 0x7F
    array                  | array           | 0x80..0x97
    array                  | array           | 0x98
    array                  | array           | 0x99
    array                  | array           | 0x9A
    array                  | array           | 0x9B
    array                  | array           | 0x9F
    map                    | object          | 0xA0..0xB7
    map                    | object          | 0xB8
    map                    | object          | 0xB9
    map                    | object          | 0xBA
    map                    | object          | 0xBB
    map                    | object          | 0xBF
    False                  | `false`         | 0xF4
    True                   | `true`          | 0xF5
    Null                   | `null`          | 0xF6
    Half-Precision Float   | number_float    | 0xF9
    Single-Precision Float | number_float    | 0xFA
    Double-Precision Float | number_float    | 0xFB

    @warning The mapping is **incomplete** in the sense that not all CBOR
             types can be converted to a JSON value. The following CBOR types
             are not supported and will yield parse errors (parse_error.112):
             - date/time (0xC0..0xC1)
             - bignum (0xC2..0xC3)
             - decimal fraction (0xC4)
             - bigfloat (0xC5)
             - expected conversions (0xD5..0xD7)
             - simple values (0xE0..0xF3, 0xF8)
             - undefined (0xF7)

    @warning CBOR allows map keys of any type, whereas JSON only allows
             strings as keys in object values. Therefore, CBOR maps with keys
             other than UTF-8 strings are rejected (parse_error.113).

    @note Any CBOR output created @ref to_cbor can be successfully parsed by
          @ref from_cbor.

    @param[in] i  an input in CBOR format convertible to an input adapter
    @param[in] strict  whether to expect the input to be consumed until EOF
                       (true by default)
    @param[in] allow_exceptions  whether to throw exceptions in case of a
    parse error (optional, true by default)
    @param[in] tag_handler how to treat CBOR tags (optional, error by default)

    @return deserialized JSON value; in case of a parse error and
            @a allow_exceptions set to `false`, the return value will be
            value_t::discarded.

    @throw parse_error.110 if the given input ends prematurely or the end of
    file was not reached when @a strict was set to true
    @throw parse_error.112 if unsupported features from CBOR were
    used in the given input @a v or if the input is not valid CBOR
    @throw parse_error.113 if a string was expected as map key, but not found

    @complexity Linear in the size of the input @a i.

    @liveexample{The example shows the deserialization of a byte vector in CBOR
    format to a JSON value.,from_cbor}

    @sa http://cbor.io
    @sa @ref to_cbor(const basic_json&) for the analogous serialization
    @sa @ref from_msgpack(detail::input_adapter&&, const bool, const bool) for the
        related MessagePack format
    @sa @ref from_ubjson(detail::input_adapter&&, const bool, const bool) for the
        related UBJSON format

    @since version 2.0.9; parameter @a start_index since 2.1.1; changed to
           consume input adapters, removed start_index parameter, and added
           @a strict parameter since 3.0.0; added @a allow_exceptions parameter
           since 3.2.0; added @a tag_handler parameter since 3.9.0.
    */
    template<typename InputType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_cbor(InputType&& i,
                                const bool strict = true,
                                const bool allow_exceptions = true,
                                const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = detail::input_adapter(std::forward<InputType>(i));
        const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::cbor, &sdp, strict, tag_handler);
        return res ? result : basic_json(value_t::discarded);
    }

    /*!
    @copydoc from_cbor(detail::input_adapter&&, const bool, const bool, const cbor_tag_handler_t)
    */
    template<typename IteratorType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_cbor(IteratorType first, IteratorType last,
                                const bool strict = true,
                                const bool allow_exceptions = true,
                                const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = detail::input_adapter(std::move(first), std::move(last));
        const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::cbor, &sdp, strict, tag_handler);
        return res ? result : basic_json(value_t::discarded);
    }

    template<typename T>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_cbor(ptr, ptr + len))
    static basic_json from_cbor(const T* ptr, std::size_t len,
                                const bool strict = true,
                                const bool allow_exceptions = true,
                                const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
    {
        return from_cbor(ptr, ptr + len, strict, allow_exceptions, tag_handler);
    }


    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_cbor(ptr, ptr + len))
    static basic_json from_cbor(detail::span_input_adapter&& i,
                                const bool strict = true,
                                const bool allow_exceptions = true,
                                const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = i.get();
        const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::cbor, &sdp, strict, tag_handler);
        return res ? result : basic_json(value_t::discarded);
    }

    /*!
    @brief create a JSON value from an input in MessagePack format

    Deserializes a given input @a i to a JSON value using the MessagePack
    serialization format.

    The library maps MessagePack types to JSON value types as follows:

    MessagePack type | JSON value type | first byte
    ---------------- | --------------- | ----------
    positive fixint  | number_unsigned | 0x00..0x7F
    fixmap           | object          | 0x80..0x8F
    fixarray         | array           | 0x90..0x9F
    fixstr           | string          | 0xA0..0xBF
    nil              | `null`          | 0xC0
    false            | `false`         | 0xC2
    true             | `true`          | 0xC3
    float 32         | number_float    | 0xCA
    float 64         | number_float    | 0xCB
    uint 8           | number_unsigned | 0xCC
    uint 16          | number_unsigned | 0xCD
    uint 32          | number_unsigned | 0xCE
    uint 64          | number_unsigned | 0xCF
    int 8            | number_integer  | 0xD0
    int 16           | number_integer  | 0xD1
    int 32           | number_integer  | 0xD2
    int 64           | number_integer  | 0xD3
    str 8            | string          | 0xD9
    str 16           | string          | 0xDA
    str 32           | string          | 0xDB
    array 16         | array           | 0xDC
    array 32         | array           | 0xDD
    map 16           | object          | 0xDE
    map 32           | object          | 0xDF
    bin 8            | binary          | 0xC4
    bin 16           | binary          | 0xC5
    bin 32           | binary          | 0xC6
    ext 8            | binary          | 0xC7
    ext 16           | binary          | 0xC8
    ext 32           | binary          | 0xC9
    fixext 1         | binary          | 0xD4
    fixext 2         | binary          | 0xD5
    fixext 4         | binary          | 0xD6
    fixext 8         | binary          | 0xD7
    fixext 16        | binary          | 0xD8
    negative fixint  | number_integer  | 0xE0-0xFF

    @note Any MessagePack output created @ref to_msgpack can be successfully
          parsed by @ref from_msgpack.

    @param[in] i  an input in MessagePack format convertible to an input
                  adapter
    @param[in] strict  whether to expect the input to be consumed until EOF
                       (true by default)
    @param[in] allow_exceptions  whether to throw exceptions in case of a
    parse error (optional, true by default)

    @return deserialized JSON value; in case of a parse error and
            @a allow_exceptions set to `false`, the return value will be
            value_t::discarded.

    @throw parse_error.110 if the given input ends prematurely or the end of
    file was not reached when @a strict was set to true
    @throw parse_error.112 if unsupported features from MessagePack were
    used in the given input @a i or if the input is not valid MessagePack
    @throw parse_error.113 if a string was expected as map key, but not found

    @complexity Linear in the size of the input @a i.

    @liveexample{The example shows the deserialization of a byte vector in
    MessagePack format to a JSON value.,from_msgpack}

    @sa http://msgpack.org
    @sa @ref to_msgpack(const basic_json&) for the analogous serialization
    @sa @ref from_cbor(detail::input_adapter&&, const bool, const bool, const cbor_tag_handler_t) for the
        related CBOR format
    @sa @ref from_ubjson(detail::input_adapter&&, const bool, const bool) for
        the related UBJSON format
    @sa @ref from_bson(detail::input_adapter&&, const bool, const bool) for
        the related BSON format

    @since version 2.0.9; parameter @a start_index since 2.1.1; changed to
           consume input adapters, removed start_index parameter, and added
           @a strict parameter since 3.0.0; added @a allow_exceptions parameter
           since 3.2.0
    */
    template<typename InputType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_msgpack(InputType&& i,
                                   const bool strict = true,
                                   const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = detail::input_adapter(std::forward<InputType>(i));
        const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::msgpack, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    /*!
    @copydoc from_msgpack(detail::input_adapter&&, const bool, const bool)
    */
    template<typename IteratorType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_msgpack(IteratorType first, IteratorType last,
                                   const bool strict = true,
                                   const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = detail::input_adapter(std::move(first), std::move(last));
        const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::msgpack, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }


    template<typename T>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_msgpack(ptr, ptr + len))
    static basic_json from_msgpack(const T* ptr, std::size_t len,
                                   const bool strict = true,
                                   const bool allow_exceptions = true)
    {
        return from_msgpack(ptr, ptr + len, strict, allow_exceptions);
    }

    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_msgpack(ptr, ptr + len))
    static basic_json from_msgpack(detail::span_input_adapter&& i,
                                   const bool strict = true,
                                   const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = i.get();
        const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::msgpack, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }


    /*!
    @brief create a JSON value from an input in UBJSON format

    Deserializes a given input @a i to a JSON value using the UBJSON (Universal
    Binary JSON) serialization format.

    The library maps UBJSON types to JSON value types as follows:

    UBJSON type | JSON value type                         | marker
    ----------- | --------------------------------------- | ------
    no-op       | *no value, next value is read*          | `N`
    null        | `null`                                  | `Z`
    false       | `false`                                 | `F`
    true        | `true`                                  | `T`
    float32     | number_float                            | `d`
    float64     | number_float                            | `D`
    uint8       | number_unsigned                         | `U`
    int8        | number_integer                          | `i`
    int16       | number_integer                          | `I`
    int32       | number_integer                          | `l`
    int64       | number_integer                          | `L`
    high-precision number | number_integer, number_unsigned, or number_float - depends on number string | 'H'
    string      | string                                  | `S`
    char        | string                                  | `C`
    array       | array (optimized values are supported)  | `[`
    object      | object (optimized values are supported) | `{`

    @note The mapping is **complete** in the sense that any UBJSON value can
          be converted to a JSON value.

    @param[in] i  an input in UBJSON format convertible to an input adapter
    @param[in] strict  whether to expect the input to be consumed until EOF
                       (true by default)
    @param[in] allow_exceptions  whether to throw exceptions in case of a
    parse error (optional, true by default)

    @return deserialized JSON value; in case of a parse error and
            @a allow_exceptions set to `false`, the return value will be
            value_t::discarded.

    @throw parse_error.110 if the given input ends prematurely or the end of
    file was not reached when @a strict was set to true
    @throw parse_error.112 if a parse error occurs
    @throw parse_error.113 if a string could not be parsed successfully

    @complexity Linear in the size of the input @a i.

    @liveexample{The example shows the deserialization of a byte vector in
    UBJSON format to a JSON value.,from_ubjson}

    @sa http://ubjson.org
    @sa @ref to_ubjson(const basic_json&, const bool, const bool) for the
             analogous serialization
    @sa @ref from_cbor(detail::input_adapter&&, const bool, const bool, const cbor_tag_handler_t) for the
        related CBOR format
    @sa @ref from_msgpack(detail::input_adapter&&, const bool, const bool) for
        the related MessagePack format
    @sa @ref from_bson(detail::input_adapter&&, const bool, const bool) for
        the related BSON format

    @since version 3.1.0; added @a allow_exceptions parameter since 3.2.0
    */
    template<typename InputType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_ubjson(InputType&& i,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = detail::input_adapter(std::forward<InputType>(i));
        const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::ubjson, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    /*!
    @copydoc from_ubjson(detail::input_adapter&&, const bool, const bool)
    */
    template<typename IteratorType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_ubjson(IteratorType first, IteratorType last,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = detail::input_adapter(std::move(first), std::move(last));
        const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::ubjson, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    template<typename T>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_ubjson(ptr, ptr + len))
    static basic_json from_ubjson(const T* ptr, std::size_t len,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        return from_ubjson(ptr, ptr + len, strict, allow_exceptions);
    }

    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_ubjson(ptr, ptr + len))
    static basic_json from_ubjson(detail::span_input_adapter&& i,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = i.get();
        const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::ubjson, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }


    /*!
    @brief Create a JSON value from an input in BSON format

    Deserializes a given input @a i to a JSON value using the BSON (Binary JSON)
    serialization format.

    The library maps BSON record types to JSON value types as follows:

    BSON type       | BSON marker byte | JSON value type
    --------------- | ---------------- | ---------------------------
    double          | 0x01             | number_float
    string          | 0x02             | string
    document        | 0x03             | object
    array           | 0x04             | array
    binary          | 0x05             | still unsupported
    undefined       | 0x06             | still unsupported
    ObjectId        | 0x07             | still unsupported
    boolean         | 0x08             | boolean
    UTC Date-Time   | 0x09             | still unsupported
    null            | 0x0A             | null
    Regular Expr.   | 0x0B             | still unsupported
    DB Pointer      | 0x0C             | still unsupported
    JavaScript Code | 0x0D             | still unsupported
    Symbol          | 0x0E             | still unsupported
    JavaScript Code | 0x0F             | still unsupported
    int32           | 0x10             | number_integer
    Timestamp       | 0x11             | still unsupported
    128-bit decimal float | 0x13       | still unsupported
    Max Key         | 0x7F             | still unsupported
    Min Key         | 0xFF             | still unsupported

    @warning The mapping is **incomplete**. The unsupported mappings
             are indicated in the table above.

    @param[in] i  an input in BSON format convertible to an input adapter
    @param[in] strict  whether to expect the input to be consumed until EOF
                       (true by default)
    @param[in] allow_exceptions  whether to throw exceptions in case of a
    parse error (optional, true by default)

    @return deserialized JSON value; in case of a parse error and
            @a allow_exceptions set to `false`, the return value will be
            value_t::discarded.

    @throw parse_error.114 if an unsupported BSON record type is encountered

    @complexity Linear in the size of the input @a i.

    @liveexample{The example shows the deserialization of a byte vector in
    BSON format to a JSON value.,from_bson}

    @sa http://bsonspec.org/spec.html
    @sa @ref to_bson(const basic_json&) for the analogous serialization
    @sa @ref from_cbor(detail::input_adapter&&, const bool, const bool, const cbor_tag_handler_t) for the
        related CBOR format
    @sa @ref from_msgpack(detail::input_adapter&&, const bool, const bool) for
        the related MessagePack format
    @sa @ref from_ubjson(detail::input_adapter&&, const bool, const bool) for the
        related UBJSON format
    */
    template<typename InputType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_bson(InputType&& i,
                                const bool strict = true,
                                const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = detail::input_adapter(std::forward<InputType>(i));
        const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::bson, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    /*!
    @copydoc from_bson(detail::input_adapter&&, const bool, const bool)
    */
    template<typename IteratorType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_bson(IteratorType first, IteratorType last,
                                const bool strict = true,
                                const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = detail::input_adapter(std::move(first), std::move(last));
        const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::bson, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    template<typename T>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_bson(ptr, ptr + len))
    static basic_json from_bson(const T* ptr, std::size_t len,
                                const bool strict = true,
                                const bool allow_exceptions = true)
    {
        return from_bson(ptr, ptr + len, strict, allow_exceptions);
    }

    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_bson(ptr, ptr + len))
    static basic_json from_bson(detail::span_input_adapter&& i,
                                const bool strict = true,
                                const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = i.get();
        const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::bson, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }
    /// @}

    //////////////////////////
    // JSON Pointer support //
    //////////////////////////

    /// @name JSON Pointer functions
    /// @{

    /*!
    @brief access specified element via JSON Pointer

    Uses a JSON pointer to retrieve a reference to the respective JSON value.
    No bound checking is performed. Similar to @ref operator[](const typename
    object_t::key_type&), `null` values are created in arrays and objects if
    necessary.

    In particular:
    - If the JSON pointer points to an object key that does not exist, it
      is created an filled with a `null` value before a reference to it
      is returned.
    - If the JSON pointer points to an array index that does not exist, it
      is created an filled with a `null` value before a reference to it
      is returned. All indices between the current maximum and the given
      index are also filled with `null`.
    - The special value `-` is treated as a synonym for the index past the
      end.

    @param[in] ptr  a JSON pointer

    @return reference to the element pointed to by @a ptr

    @complexity Constant.

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.404  if the JSON pointer can not be resolved

    @liveexample{The behavior is shown in the example.,operatorjson_pointer}

    @since version 2.0.0
    */
    reference operator[](const json_pointer& ptr)
    {
        return ptr.get_unchecked(this);
    }

    /*!
    @brief access specified element via JSON Pointer

    Uses a JSON pointer to retrieve a reference to the respective JSON value.
    No bound checking is performed. The function does not change the JSON
    value; no `null` values are created. In particular, the special value
    `-` yields an exception.

    @param[in] ptr  JSON pointer to the desired element

    @return const reference to the element pointed to by @a ptr

    @complexity Constant.

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved

    @liveexample{The behavior is shown in the example.,operatorjson_pointer_const}

    @since version 2.0.0
    */
    const_reference operator[](const json_pointer& ptr) const
    {
        return ptr.get_unchecked(this);
    }

    /*!
    @brief access specified element via JSON Pointer

    Returns a reference to the element at with specified JSON pointer @a ptr,
    with bounds checking.

    @param[in] ptr  JSON pointer to the desired element

    @return reference to the element pointed to by @a ptr

    @throw parse_error.106 if an array index in the passed JSON pointer @a ptr
    begins with '0'. See example below.

    @throw parse_error.109 if an array index in the passed JSON pointer @a ptr
    is not a number. See example below.

    @throw out_of_range.401 if an array index in the passed JSON pointer @a ptr
    is out of range. See example below.

    @throw out_of_range.402 if the array index '-' is used in the passed JSON
    pointer @a ptr. As `at` provides checked access (and no elements are
    implicitly inserted), the index '-' is always invalid. See example below.

    @throw out_of_range.403 if the JSON pointer describes a key of an object
    which cannot be found. See example below.

    @throw out_of_range.404 if the JSON pointer @a ptr can not be resolved.
    See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @since version 2.0.0

    @liveexample{The behavior is shown in the example.,at_json_pointer}
    */
    reference at(const json_pointer& ptr)
    {
        return ptr.get_checked(this);
    }

    /*!
    @brief access specified element via JSON Pointer

    Returns a const reference to the element at with specified JSON pointer @a
    ptr, with bounds checking.

    @param[in] ptr  JSON pointer to the desired element

    @return reference to the element pointed to by @a ptr

    @throw parse_error.106 if an array index in the passed JSON pointer @a ptr
    begins with '0'. See example below.

    @throw parse_error.109 if an array index in the passed JSON pointer @a ptr
    is not a number. See example below.

    @throw out_of_range.401 if an array index in the passed JSON pointer @a ptr
    is out of range. See example below.

    @throw out_of_range.402 if the array index '-' is used in the passed JSON
    pointer @a ptr. As `at` provides checked access (and no elements are
    implicitly inserted), the index '-' is always invalid. See example below.

    @throw out_of_range.403 if the JSON pointer describes a key of an object
    which cannot be found. See example below.

    @throw out_of_range.404 if the JSON pointer @a ptr can not be resolved.
    See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @since version 2.0.0

    @liveexample{The behavior is shown in the example.,at_json_pointer_const}
    */
    const_reference at(const json_pointer& ptr) const
    {
        return ptr.get_checked(this);
    }

    /*!
    @brief return flattened JSON value

    The function creates a JSON object whose keys are JSON pointers (see [RFC
    6901](https://tools.ietf.org/html/rfc6901)) and whose values are all
    primitive. The original JSON value can be restored using the @ref
    unflatten() function.

    @return an object that maps JSON pointers to primitive values

    @note Empty objects and arrays are flattened to `null` and will not be
          reconstructed correctly by the @ref unflatten() function.

    @complexity Linear in the size the JSON value.

    @liveexample{The following code shows how a JSON object is flattened to an
    object whose keys consist of JSON pointers.,flatten}

    @sa @ref unflatten() for the reverse function

    @since version 2.0.0
    */
    basic_json flatten() const
    {
        basic_json result(value_t::object);
        json_pointer::flatten("", *this, result);
        return result;
    }

    /*!
    @brief unflatten a previously flattened JSON value

    The function restores the arbitrary nesting of a JSON value that has been
    flattened before using the @ref flatten() function. The JSON value must
    meet certain constraints:
    1. The value must be an object.
    2. The keys must be JSON pointers (see
       [RFC 6901](https://tools.ietf.org/html/rfc6901))
    3. The mapped values must be primitive JSON types.

    @return the original JSON from a flattened version

    @note Empty objects and arrays are flattened by @ref flatten() to `null`
          values and can not unflattened to their original type. Apart from
          this example, for a JSON value `j`, the following is always true:
          `j == j.flatten().unflatten()`.

    @complexity Linear in the size the JSON value.

    @throw type_error.314  if value is not an object
    @throw type_error.315  if object values are not primitive

    @liveexample{The following code shows how a flattened JSON object is
    unflattened into the original nested JSON object.,unflatten}

    @sa @ref flatten() for the reverse function

    @since version 2.0.0
    */
    basic_json unflatten() const
    {
        return json_pointer::unflatten(*this);
    }

    /// @}

    //////////////////////////
    // JSON Patch functions //
    //////////////////////////

    /// @name JSON Patch functions
    /// @{

    /*!
    @brief applies a JSON patch

    [JSON Patch](http://jsonpatch.com) defines a JSON document structure for
    expressing a sequence of operations to apply to a JSON) document. With
    this function, a JSON Patch is applied to the current JSON value by
    executing all operations from the patch.

    @param[in] json_patch  JSON patch document
    @return patched document

    @note The application of a patch is atomic: Either all operations succeed
          and the patched document is returned or an exception is thrown. In
          any case, the original value is not changed: the patch is applied
          to a copy of the value.

    @throw parse_error.104 if the JSON patch does not consist of an array of
    objects

    @throw parse_error.105 if the JSON patch is malformed (e.g., mandatory
    attributes are missing); example: `"operation add must have member path"`

    @throw out_of_range.401 if an array index is out of range.

    @throw out_of_range.403 if a JSON pointer inside the patch could not be
    resolved successfully in the current JSON value; example: `"key baz not
    found"`

    @throw out_of_range.405 if JSON pointer has no parent ("add", "remove",
    "move")

    @throw other_error.501 if "test" operation was unsuccessful

    @complexity Linear in the size of the JSON value and the length of the
    JSON patch. As usually only a fraction of the JSON value is affected by
    the patch, the complexity can usually be neglected.

    @liveexample{The following code shows how a JSON patch is applied to a
    value.,patch}

    @sa @ref diff -- create a JSON patch by comparing two JSON values

    @sa [RFC 6902 (JSON Patch)](https://tools.ietf.org/html/rfc6902)
    @sa [RFC 6901 (JSON Pointer)](https://tools.ietf.org/html/rfc6901)

    @since version 2.0.0
    */
    basic_json patch(const basic_json& json_patch) const
    {
        // make a working copy to apply the patch to
        basic_json result = *this;

        // the valid JSON Patch operations
        enum class patch_operations {add, remove, replace, move, copy, test, invalid};

        const auto get_op = [](const std::string & op)
        {
            if (op == "add")
            {
                return patch_operations::add;
            }
            if (op == "remove")
            {
                return patch_operations::remove;
            }
            if (op == "replace")
            {
                return patch_operations::replace;
            }
            if (op == "move")
            {
                return patch_operations::move;
            }
            if (op == "copy")
            {
                return patch_operations::copy;
            }
            if (op == "test")
            {
                return patch_operations::test;
            }

            return patch_operations::invalid;
        };

        // wrapper for "add" operation; add value at ptr
        const auto operation_add = [&result](json_pointer & ptr, basic_json val)
        {
            // adding to the root of the target document means replacing it
            if (ptr.empty())
            {
                result = val;
                return;
            }

            // make sure the top element of the pointer exists
            json_pointer top_pointer = ptr.top();
            if (top_pointer != ptr)
            {
                result.at(top_pointer);
            }

            // get reference to parent of JSON pointer ptr
            const auto last_path = ptr.back();
            ptr.pop_back();
            basic_json& parent = result[ptr];

            switch (parent.m_type)
            {
                case value_t::null:
                case value_t::object:
                {
                    // use operator[] to add value
                    parent[last_path] = val;
                    break;
                }

                case value_t::array:
                {
                    if (last_path == "-")
                    {
                        // special case: append to back
                        parent.push_back(val);
                    }
                    else
                    {
                        const auto idx = json_pointer::array_index(last_path);
                        if (JSON_HEDLEY_UNLIKELY(idx > parent.size()))
                        {
                            // avoid undefined behavior
                            JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range"));
                        }

                        // default case: insert add offset
                        parent.insert(parent.begin() + static_cast<difference_type>(idx), val);
                    }
                    break;
                }

                // if there exists a parent it cannot be primitive
                default:            // LCOV_EXCL_LINE
                    JSON_ASSERT(false);  // LCOV_EXCL_LINE
            }
        };

        // wrapper for "remove" operation; remove value at ptr
        const auto operation_remove = [&result](json_pointer & ptr)
        {
            // get reference to parent of JSON pointer ptr
            const auto last_path = ptr.back();
            ptr.pop_back();
            basic_json& parent = result.at(ptr);

            // remove child
            if (parent.is_object())
            {
                // perform range check
                auto it = parent.find(last_path);
                if (JSON_HEDLEY_LIKELY(it != parent.end()))
                {
                    parent.erase(it);
                }
                else
                {
                    JSON_THROW(out_of_range::create(403, "key '" + last_path + "' not found"));
                }
            }
            else if (parent.is_array())
            {
                // note erase performs range check
                parent.erase(json_pointer::array_index(last_path));
            }
        };

        // type check: top level value must be an array
        if (JSON_HEDLEY_UNLIKELY(!json_patch.is_array()))
        {
            JSON_THROW(parse_error::create(104, 0, "JSON patch must be an array of objects"));
        }

        // iterate and apply the operations
        for (const auto& val : json_patch)
        {
            // wrapper to get a value for an operation
            const auto get_value = [&val](const std::string & op,
                                          const std::string & member,
                                          bool string_type) -> basic_json &
            {
                // find value
                auto it = val.m_value.object->find(member);

                // context-sensitive error message
                const auto error_msg = (op == "op") ? "operation" : "operation '" + op + "'";

                // check if desired value is present
                if (JSON_HEDLEY_UNLIKELY(it == val.m_value.object->end()))
                {
                    JSON_THROW(parse_error::create(105, 0, error_msg + " must have member '" + member + "'"));
                }

                // check if result is of type string
                if (JSON_HEDLEY_UNLIKELY(string_type && !it->second.is_string()))
                {
                    JSON_THROW(parse_error::create(105, 0, error_msg + " must have string member '" + member + "'"));
                }

                // no error: return value
                return it->second;
            };

            // type check: every element of the array must be an object
            if (JSON_HEDLEY_UNLIKELY(!val.is_object()))
            {
                JSON_THROW(parse_error::create(104, 0, "JSON patch must be an array of objects"));
            }

            // collect mandatory members
            const auto op = get_value("op", "op", true).template get<std::string>();
            const auto path = get_value(op, "path", true).template get<std::string>();
            json_pointer ptr(path);

            switch (get_op(op))
            {
                case patch_operations::add:
                {
                    operation_add(ptr, get_value("add", "value", false));
                    break;
                }

                case patch_operations::remove:
                {
                    operation_remove(ptr);
                    break;
                }

                case patch_operations::replace:
                {
                    // the "path" location must exist - use at()
                    result.at(ptr) = get_value("replace", "value", false);
                    break;
                }

                case patch_operations::move:
                {
                    const auto from_path = get_value("move", "from", true).template get<std::string>();
                    json_pointer from_ptr(from_path);

                    // the "from" location must exist - use at()
                    basic_json v = result.at(from_ptr);

                    // The move operation is functionally identical to a
                    // "remove" operation on the "from" location, followed
                    // immediately by an "add" operation at the target
                    // location with the value that was just removed.
                    operation_remove(from_ptr);
                    operation_add(ptr, v);
                    break;
                }

                case patch_operations::copy:
                {
                    const auto from_path = get_value("copy", "from", true).template get<std::string>();
                    const json_pointer from_ptr(from_path);

                    // the "from" location must exist - use at()
                    basic_json v = result.at(from_ptr);

                    // The copy is functionally identical to an "add"
                    // operation at the target location using the value
                    // specified in the "from" member.
                    operation_add(ptr, v);
                    break;
                }

                case patch_operations::test:
                {
                    bool success = false;
                    JSON_TRY
                    {
                        // check if "value" matches the one at "path"
                        // the "path" location must exist - use at()
                        success = (result.at(ptr) == get_value("test", "value", false));
                    }
                    JSON_INTERNAL_CATCH (out_of_range&)
                    {
                        // ignore out of range errors: success remains false
                    }

                    // throw an exception if test fails
                    if (JSON_HEDLEY_UNLIKELY(!success))
                    {
                        JSON_THROW(other_error::create(501, "unsuccessful: " + val.dump()));
                    }

                    break;
                }

                default:
                {
                    // op must be "add", "remove", "replace", "move", "copy", or
                    // "test"
                    JSON_THROW(parse_error::create(105, 0, "operation value '" + op + "' is invalid"));
                }
            }
        }

        return result;
    }

    /*!
    @brief creates a diff as a JSON patch

    Creates a [JSON Patch](http://jsonpatch.com) so that value @a source can
    be changed into the value @a target by calling @ref patch function.

    @invariant For two JSON values @a source and @a target, the following code
    yields always `true`:
    @code {.cpp}
    source.patch(diff(source, target)) == target;
    @endcode

    @note Currently, only `remove`, `add`, and `replace` operations are
          generated.

    @param[in] source  JSON value to compare from
    @param[in] target  JSON value to compare against
    @param[in] path    helper value to create JSON pointers

    @return a JSON patch to convert the @a source to @a target

    @complexity Linear in the lengths of @a source and @a target.

    @liveexample{The following code shows how a JSON patch is created as a
    diff for two JSON values.,diff}

    @sa @ref patch -- apply a JSON patch
    @sa @ref merge_patch -- apply a JSON Merge Patch

    @sa [RFC 6902 (JSON Patch)](https://tools.ietf.org/html/rfc6902)

    @since version 2.0.0
    */
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json diff(const basic_json& source, const basic_json& target,
                           const std::string& path = "")
    {
        // the patch
        basic_json result(value_t::array);

        // if the values are the same, return empty patch
        if (source == target)
        {
            return result;
        }

        if (source.type() != target.type())
        {
            // different types: replace value
            result.push_back(
            {
                {"op", "replace"}, {"path", path}, {"value", target}
            });
            return result;
        }

        switch (source.type())
        {
            case value_t::array:
            {
                // first pass: traverse common elements
                std::size_t i = 0;
                while (i < source.size() && i < target.size())
                {
                    // recursive call to compare array values at index i
                    auto temp_diff = diff(source[i], target[i], path + "/" + std::to_string(i));
                    result.insert(result.end(), temp_diff.begin(), temp_diff.end());
                    ++i;
                }

                // i now reached the end of at least one array
                // in a second pass, traverse the remaining elements

                // remove my remaining elements
                const auto end_index = static_cast<difference_type>(result.size());
                while (i < source.size())
                {
                    // add operations in reverse order to avoid invalid
                    // indices
                    result.insert(result.begin() + end_index, object(
                    {
                        {"op", "remove"},
                        {"path", path + "/" + std::to_string(i)}
                    }));
                    ++i;
                }

                // add other remaining elements
                while (i < target.size())
                {
                    result.push_back(
                    {
                        {"op", "add"},
                        {"path", path + "/-"},
                        {"value", target[i]}
                    });
                    ++i;
                }

                break;
            }

            case value_t::object:
            {
                // first pass: traverse this object's elements
                for (auto it = source.cbegin(); it != source.cend(); ++it)
                {
                    // escape the key name to be used in a JSON patch
                    const auto key = json_pointer::escape(it.key());

                    if (target.find(it.key()) != target.end())
                    {
                        // recursive call to compare object values at key it
                        auto temp_diff = diff(it.value(), target[it.key()], path + "/" + key);
                        result.insert(result.end(), temp_diff.begin(), temp_diff.end());
                    }
                    else
                    {
                        // found a key that is not in o -> remove it
                        result.push_back(object(
                        {
                            {"op", "remove"}, {"path", path + "/" + key}
                        }));
                    }
                }

                // second pass: traverse other object's elements
                for (auto it = target.cbegin(); it != target.cend(); ++it)
                {
                    if (source.find(it.key()) == source.end())
                    {
                        // found a key that is not in this -> add it
                        const auto key = json_pointer::escape(it.key());
                        result.push_back(
                        {
                            {"op", "add"}, {"path", path + "/" + key},
                            {"value", it.value()}
                        });
                    }
                }

                break;
            }

            default:
            {
                // both primitive type: replace value
                result.push_back(
                {
                    {"op", "replace"}, {"path", path}, {"value", target}
                });
                break;
            }
        }

        return result;
    }

    /// @}

    ////////////////////////////////
    // JSON Merge Patch functions //
    ////////////////////////////////

    /// @name JSON Merge Patch functions
    /// @{

    /*!
    @brief applies a JSON Merge Patch

    The merge patch format is primarily intended for use with the HTTP PATCH
    method as a means of describing a set of modifications to a target
    resource's content. This function applies a merge patch to the current
    JSON value.

    The function implements the following algorithm from Section 2 of
    [RFC 7396 (JSON Merge Patch)](https://tools.ietf.org/html/rfc7396):

    ```
    define MergePatch(Target, Patch):
      if Patch is an Object:
        if Target is not an Object:
          Target = {} // Ignore the contents and set it to an empty Object
        for each Name/Value pair in Patch:
          if Value is null:
            if Name exists in Target:
              remove the Name/Value pair from Target
          else:
            Target[Name] = MergePatch(Target[Name], Value)
        return Target
      else:
        return Patch
    ```

    Thereby, `Target` is the current object; that is, the patch is applied to
    the current value.

    @param[in] apply_patch  the patch to apply

    @complexity Linear in the lengths of @a patch.

    @liveexample{The following code shows how a JSON Merge Patch is applied to
    a JSON document.,merge_patch}

    @sa @ref patch -- apply a JSON patch
    @sa [RFC 7396 (JSON Merge Patch)](https://tools.ietf.org/html/rfc7396)

    @since version 3.0.0
    */
    void merge_patch(const basic_json& apply_patch)
    {
        if (apply_patch.is_object())
        {
            if (!is_object())
            {
                *this = object();
            }
            for (auto it = apply_patch.begin(); it != apply_patch.end(); ++it)
            {
                if (it.value().is_null())
                {
                    erase(it.key());
                }
                else
                {
                    operator[](it.key()).merge_patch(it.value());
                }
            }
        }
        else
        {
            *this = apply_patch;
        }
    }

    /// @}
};

/*!
@brief user-defined to_string function for JSON values

This function implements a user-defined to_string  for JSON objects.

@param[in] j  a JSON object
@return a std::string object
*/

NLOHMANN_BASIC_JSON_TPL_DECLARATION
std::string to_string(const NLOHMANN_BASIC_JSON_TPL& j)
{
    return j.dump();
}
} // namespace nlohmann

///////////////////////
// nonmember support //
///////////////////////

// specialization of std::swap, and std::hash
namespace std
{

/// hash value for JSON objects
template<>
struct hash<nlohmann::json>
{
    /*!
    @brief return a hash value for a JSON object

    @since version 1.0.0
    */
    std::size_t operator()(const nlohmann::json& j) const
    {
        return nlohmann::detail::hash(j);
    }
};

/// specialization for std::less<value_t>
/// @note: do not remove the space after '<',
///        see https://github.com/nlohmann/json/pull/679
template<>
struct less<::nlohmann::detail::value_t>
{
    /*!
    @brief compare two value_t enum values
    @since version 3.0.0
    */
    bool operator()(nlohmann::detail::value_t lhs,
                    nlohmann::detail::value_t rhs) const noexcept
    {
        return nlohmann::detail::operator<(lhs, rhs);
    }
};

// C++20 prohibit function specialization in the std namespace.
#ifndef JSON_HAS_CPP_20

/*!
@brief exchanges the values of two JSON objects

@since version 1.0.0
*/
template<>
inline void swap<nlohmann::json>(nlohmann::json& j1, nlohmann::json& j2) noexcept(
    is_nothrow_move_constructible<nlohmann::json>::value&&
    is_nothrow_move_assignable<nlohmann::json>::value
                              )
{
    j1.swap(j2);
}

#endif

} // namespace std

/*!
@brief user-defined string literal for JSON values

This operator implements a user-defined string literal for JSON objects. It
can be used by adding `"_json"` to a string literal and returns a JSON object
if no parse error occurred.

@param[in] s  a string representation of a JSON object
@param[in] n  the length of string @a s
@return a JSON object

@since version 1.0.0
*/
JSON_HEDLEY_NON_NULL(1)
inline nlohmann::json operator "" _json(const char* s, std::size_t n)
{
    return nlohmann::json::parse(s, s + n);
}

/*!
@brief user-defined string literal for JSON pointer

This operator implements a user-defined string literal for JSON Pointers. It
can be used by adding `"_json_pointer"` to a string literal and returns a JSON pointer
object if no parse error occurred.

@param[in] s  a string representation of a JSON Pointer
@param[in] n  the length of string @a s
@return a JSON pointer object

@since version 2.0.0
*/
JSON_HEDLEY_NON_NULL(1)
inline nlohmann::json::json_pointer operator "" _json_pointer(const char* s, std::size_t n)
{
    return nlohmann::json::json_pointer(std::string(s, n));
}

// #include <nlohmann/detail/macro_unscope.hpp>


// restore GCC/clang diagnostic settings
#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
    #pragma GCC diagnostic pop
#endif
#if defined(__clang__)
    #pragma GCC diagnostic pop
#endif

// clean up
#undef JSON_ASSERT
#undef JSON_INTERNAL_CATCH
#undef JSON_CATCH
#undef JSON_THROW
#undef JSON_TRY
#undef JSON_HAS_CPP_14
#undef JSON_HAS_CPP_17
#undef NLOHMANN_BASIC_JSON_TPL_DECLARATION
#undef NLOHMANN_BASIC_JSON_TPL
#undef JSON_EXPLICIT

// #include <nlohmann/thirdparty/hedley/hedley_undef.hpp>
#undef JSON_HEDLEY_ALWAYS_INLINE
#undef JSON_HEDLEY_ARM_VERSION
#undef JSON_HEDLEY_ARM_VERSION_CHECK
#undef JSON_HEDLEY_ARRAY_PARAM
#undef JSON_HEDLEY_ASSUME
#undef JSON_HEDLEY_BEGIN_C_DECLS
#undef JSON_HEDLEY_CLANG_HAS_ATTRIBUTE
#undef JSON_HEDLEY_CLANG_HAS_BUILTIN
#undef JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE
#undef JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE
#undef JSON_HEDLEY_CLANG_HAS_EXTENSION
#undef JSON_HEDLEY_CLANG_HAS_FEATURE
#undef JSON_HEDLEY_CLANG_HAS_WARNING
#undef JSON_HEDLEY_COMPCERT_VERSION
#undef JSON_HEDLEY_COMPCERT_VERSION_CHECK
#undef JSON_HEDLEY_CONCAT
#undef JSON_HEDLEY_CONCAT3
#undef JSON_HEDLEY_CONCAT3_EX
#undef JSON_HEDLEY_CONCAT_EX
#undef JSON_HEDLEY_CONST
#undef JSON_HEDLEY_CONSTEXPR
#undef JSON_HEDLEY_CONST_CAST
#undef JSON_HEDLEY_CPP_CAST
#undef JSON_HEDLEY_CRAY_VERSION
#undef JSON_HEDLEY_CRAY_VERSION_CHECK
#undef JSON_HEDLEY_C_DECL
#undef JSON_HEDLEY_DEPRECATED
#undef JSON_HEDLEY_DEPRECATED_FOR
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
#undef JSON_HEDLEY_DIAGNOSTIC_POP
#undef JSON_HEDLEY_DIAGNOSTIC_PUSH
#undef JSON_HEDLEY_DMC_VERSION
#undef JSON_HEDLEY_DMC_VERSION_CHECK
#undef JSON_HEDLEY_EMPTY_BASES
#undef JSON_HEDLEY_EMSCRIPTEN_VERSION
#undef JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK
#undef JSON_HEDLEY_END_C_DECLS
#undef JSON_HEDLEY_FLAGS
#undef JSON_HEDLEY_FLAGS_CAST
#undef JSON_HEDLEY_GCC_HAS_ATTRIBUTE
#undef JSON_HEDLEY_GCC_HAS_BUILTIN
#undef JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE
#undef JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE
#undef JSON_HEDLEY_GCC_HAS_EXTENSION
#undef JSON_HEDLEY_GCC_HAS_FEATURE
#undef JSON_HEDLEY_GCC_HAS_WARNING
#undef JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK
#undef JSON_HEDLEY_GCC_VERSION
#undef JSON_HEDLEY_GCC_VERSION_CHECK
#undef JSON_HEDLEY_GNUC_HAS_ATTRIBUTE
#undef JSON_HEDLEY_GNUC_HAS_BUILTIN
#undef JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE
#undef JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE
#undef JSON_HEDLEY_GNUC_HAS_EXTENSION
#undef JSON_HEDLEY_GNUC_HAS_FEATURE
#undef JSON_HEDLEY_GNUC_HAS_WARNING
#undef JSON_HEDLEY_GNUC_VERSION
#undef JSON_HEDLEY_GNUC_VERSION_CHECK
#undef JSON_HEDLEY_HAS_ATTRIBUTE
#undef JSON_HEDLEY_HAS_BUILTIN
#undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE
#undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS
#undef JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE
#undef JSON_HEDLEY_HAS_EXTENSION
#undef JSON_HEDLEY_HAS_FEATURE
#undef JSON_HEDLEY_HAS_WARNING
#undef JSON_HEDLEY_IAR_VERSION
#undef JSON_HEDLEY_IAR_VERSION_CHECK
#undef JSON_HEDLEY_IBM_VERSION
#undef JSON_HEDLEY_IBM_VERSION_CHECK
#undef JSON_HEDLEY_IMPORT
#undef JSON_HEDLEY_INLINE
#undef JSON_HEDLEY_INTEL_VERSION
#undef JSON_HEDLEY_INTEL_VERSION_CHECK
#undef JSON_HEDLEY_IS_CONSTANT
#undef JSON_HEDLEY_IS_CONSTEXPR_
#undef JSON_HEDLEY_LIKELY
#undef JSON_HEDLEY_MALLOC
#undef JSON_HEDLEY_MESSAGE
#undef JSON_HEDLEY_MSVC_VERSION
#undef JSON_HEDLEY_MSVC_VERSION_CHECK
#undef JSON_HEDLEY_NEVER_INLINE
#undef JSON_HEDLEY_NON_NULL
#undef JSON_HEDLEY_NO_ESCAPE
#undef JSON_HEDLEY_NO_RETURN
#undef JSON_HEDLEY_NO_THROW
#undef JSON_HEDLEY_NULL
#undef JSON_HEDLEY_PELLES_VERSION
#undef JSON_HEDLEY_PELLES_VERSION_CHECK
#undef JSON_HEDLEY_PGI_VERSION
#undef JSON_HEDLEY_PGI_VERSION_CHECK
#undef JSON_HEDLEY_PREDICT
#undef JSON_HEDLEY_PRINTF_FORMAT
#undef JSON_HEDLEY_PRIVATE
#undef JSON_HEDLEY_PUBLIC
#undef JSON_HEDLEY_PURE
#undef JSON_HEDLEY_REINTERPRET_CAST
#undef JSON_HEDLEY_REQUIRE
#undef JSON_HEDLEY_REQUIRE_CONSTEXPR
#undef JSON_HEDLEY_REQUIRE_MSG
#undef JSON_HEDLEY_RESTRICT
#undef JSON_HEDLEY_RETURNS_NON_NULL
#undef JSON_HEDLEY_SENTINEL
#undef JSON_HEDLEY_STATIC_ASSERT
#undef JSON_HEDLEY_STATIC_CAST
#undef JSON_HEDLEY_STRINGIFY
#undef JSON_HEDLEY_STRINGIFY_EX
#undef JSON_HEDLEY_SUNPRO_VERSION
#undef JSON_HEDLEY_SUNPRO_VERSION_CHECK
#undef JSON_HEDLEY_TINYC_VERSION
#undef JSON_HEDLEY_TINYC_VERSION_CHECK
#undef JSON_HEDLEY_TI_ARMCL_VERSION
#undef JSON_HEDLEY_TI_ARMCL_VERSION_CHECK
#undef JSON_HEDLEY_TI_CL2000_VERSION
#undef JSON_HEDLEY_TI_CL2000_VERSION_CHECK
#undef JSON_HEDLEY_TI_CL430_VERSION
#undef JSON_HEDLEY_TI_CL430_VERSION_CHECK
#undef JSON_HEDLEY_TI_CL6X_VERSION
#undef JSON_HEDLEY_TI_CL6X_VERSION_CHECK
#undef JSON_HEDLEY_TI_CL7X_VERSION
#undef JSON_HEDLEY_TI_CL7X_VERSION_CHECK
#undef JSON_HEDLEY_TI_CLPRU_VERSION
#undef JSON_HEDLEY_TI_CLPRU_VERSION_CHECK
#undef JSON_HEDLEY_TI_VERSION
#undef JSON_HEDLEY_TI_VERSION_CHECK
#undef JSON_HEDLEY_UNAVAILABLE
#undef JSON_HEDLEY_UNLIKELY
#undef JSON_HEDLEY_UNPREDICTABLE
#undef JSON_HEDLEY_UNREACHABLE
#undef JSON_HEDLEY_UNREACHABLE_RETURN
#undef JSON_HEDLEY_VERSION
#undef JSON_HEDLEY_VERSION_DECODE_MAJOR
#undef JSON_HEDLEY_VERSION_DECODE_MINOR
#undef JSON_HEDLEY_VERSION_DECODE_REVISION
#undef JSON_HEDLEY_VERSION_ENCODE
#undef JSON_HEDLEY_WARNING
#undef JSON_HEDLEY_WARN_UNUSED_RESULT
#undef JSON_HEDLEY_WARN_UNUSED_RESULT_MSG
#undef JSON_HEDLEY_FALL_THROUGH



#endif  // INCLUDE_NLOHMANN_JSON_HPP_

```

`include/vendor/singleton.hpp`:

```hpp
#pragma once

template<typename T>
class c_singleton
{
protected:
    c_singleton() {}
    ~c_singleton() {}

    c_singleton(const c_singleton&) = delete;
    c_singleton& operator=(const c_singleton&) = delete;

    c_singleton(c_singleton&&) = delete;
    c_singleton& operator=(c_singleton&&) = delete;

public:
    static T& get()
    {
        static T instance{};
        return instance;
    }
};
```

`include/vendor/xor.hpp`:

```hpp
#pragma once
#include <string>

namespace
{
	constexpr int const_atoi(const char c)
	{
		return c - '0';
	}
}

#ifdef _MSC_VER
#define ALWAYS_INLINE __forceinline
#else
#define ALWAYS_INLINE __attribute__((always_inline))
#endif

template<typename _string_type, size_t _length>
class _Basic_XorStr
{
	using value_type = typename _string_type::value_type;
	static constexpr auto _length_minus_one = _length - 1;

public:
	constexpr ALWAYS_INLINE _Basic_XorStr(value_type const (&str)[_length])
		: _Basic_XorStr(str, std::make_index_sequence<_length_minus_one>())
	{

	}

	inline auto c_str() const
	{
		decrypt();

		return data;
	}

	inline auto str() const
	{
		decrypt();

		return _string_type(data, data + _length_minus_one);
	}

	inline operator _string_type() const
	{
		return str();
	}

private:
	template<size_t... indices>
	constexpr ALWAYS_INLINE _Basic_XorStr(value_type const (&str)[_length], std::index_sequence<indices...>)
		: data{ crypt(str[indices], indices)..., '\0' },
		encrypted(true)
	{

	}

	static constexpr auto XOR_KEY = static_cast<value_type>(
		const_atoi(__TIME__[7]) +
		const_atoi(__TIME__[6]) * 10 +
		const_atoi(__TIME__[4]) * 60 +
		const_atoi(__TIME__[3]) * 600 +
		const_atoi(__TIME__[1]) * 3600 +
		const_atoi(__TIME__[0]) * 36000
		);

	static ALWAYS_INLINE constexpr auto crypt(value_type c, size_t i)
	{
		return static_cast<value_type>(c ^ (XOR_KEY + i));
	}

	inline void decrypt() const
	{
		if (encrypted)
		{
			for (size_t t = 0; t < _length_minus_one; t++)
			{
				data[t] = crypt(data[t], t);
			}
			encrypted = false;
		}
	}

	mutable value_type data[_length];
	mutable bool encrypted;
};
//---------------------------------------------------------------------------
template<size_t _length>
using XorStrA = class _Basic_XorStr<std::string, _length>;
template<size_t _length>
using XorStrW = class _Basic_XorStr<std::wstring, _length>;
template<size_t _length>
using XorStrU16 = class _Basic_XorStr<std::u16string, _length>;
template<size_t _length>
using XorStrU32 = class _Basic_XorStr<std::u32string, _length>;
//---------------------------------------------------------------------------
template<typename _string_type, size_t _length, size_t _length2>
inline auto operator==(const _Basic_XorStr<_string_type, _length>& lhs, const _Basic_XorStr<_string_type, _length2>& rhs)
{
	static_assert(_length == _length2, "xor == different length");

	return _length == _length2 && lhs.str() == rhs.str();
}
//---------------------------------------------------------------------------
template<typename _string_type, size_t _length>
inline auto operator==(const _string_type& lhs, const _Basic_XorStr<_string_type, _length>& rhs)
{
	return lhs.size() == _length && lhs == rhs.str();
}
//---------------------------------------------------------------------------
template<typename _stream_type, typename _string_type, size_t _length>
inline auto& operator<<(_stream_type& lhs, const _Basic_XorStr<_string_type, _length>& rhs)
{
	lhs << rhs.c_str();

	return lhs;
}
//---------------------------------------------------------------------------
template<typename _string_type, size_t _length, size_t _length2>
inline auto operator+(const _Basic_XorStr<_string_type, _length>& lhs, const _Basic_XorStr<_string_type, _length2>& rhs)
{
	return lhs.str() + rhs.str();
}
//---------------------------------------------------------------------------
template<typename _string_type, size_t _length>
inline auto operator+(const _string_type& lhs, const _Basic_XorStr<_string_type, _length>& rhs)
{
	return lhs + rhs.str();
}
//---------------------------------------------------------------------------
template<size_t _length>
constexpr ALWAYS_INLINE auto _xor_(char const (&str)[_length])
{
	return _Basic_XorStr<std::string, _length>(str);
}

template<size_t _length>
constexpr ALWAYS_INLINE auto _wxor_(wchar_t const (&str)[_length])
{
	return _Basic_XorStr<std::wstring, _length>(str);
}

```

`src/anticheat/anticheat.cpp`:

```cpp
#include <anticheat\anticheat.hpp>
#include <anticheat\detections.hpp>

// Cheat-Signatures:
// 0xCheats: E8 ? ? ? ? 41 52 49 89 E2

void anticheat_main::run_service()
{
	/*
	 * These are just basic tests (poc).
	 * TODO: create classes for hooking & other stuff.
	 */

	anticheat_detections::get().run_service();
}
```

`src/anticheat/detections.cpp`:

```cpp
#include <anticheat\anticheat.hpp>
#include <anticheat\detections.hpp>

/**
 * Detection-Rate: 100%
 * False-Flag Rate: 0-0.5%
 *
 * Before any cheat creates their thread, they call 'DisableThreadLibraryCalls'.
 * Currently only tested during runtime. Needs to be tested at game start to see how it behaves.
 */
BOOL WINAPI hook_disable_thread_library_calls(_In_ HMODULE lib_module) {
	char module_file_name[MAX_PATH] = { 0 };
	GetModuleFileNameA(lib_module, module_file_name, MAX_PATH);

	MODULEINFO module_info = { 0 };
	GetModuleInformation(GetCurrentProcess(), lib_module, &module_info, sizeof(MODULEINFO));

	DWORD base_address = (DWORD)module_info.lpBaseOfDll;
	DWORD base_size = (DWORD)module_info.SizeOfImage;

	/*
	//-- DUMP SHIT --
	// Enjoy cheat for free >:(

	LPVOID dll_buffer;
	LPDWORD  bytes_written;
	HANDLE handle_drop;

	dll_buffer = VirtualAlloc(NULL, module_info.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	if (dll_buffer == NULL) return;
	ReadProcessMemory(GetCurrentProcess(), module_info.lpBaseOfDll, dll_buffer, module_info.SizeOfImage, NULL);

	handle_drop = CreateFile("C:\\cheat.dump", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	if (handle_drop != INVALID_HANDLE_VALUE)
	{
		WriteFile(handle_drop, dll_buffer, module_info.SizeOfImage, bytes_written, NULL);
	}

	VirtualFree(dll_buffer, NULL, MEM_RELEASE);
	CloseHandle(handle_drop);
	*/

	std::string string_module_file_name = std::string(module_file_name);

	if (string_module_file_name.find("COMCTL32.dll") == std::string::npos && string_module_file_name.find("XAudio2_7.dll") == std::string::npos)
		anticheat_detections::get().detect_by_type(anticheat_detections::_DetectionTypes::DETECTION_DISABLE_THREAD_LIBRARY_CALLS, string_module_file_name);

	return anticheat_detections::get().o_disable_thread_library_calls(lib_module);
}


/**
 * Detection-Rate: 50-60%
 * False-Flag Rate: 0-5%
 *
 * Some cheats create a file to pass data from loader to client.
 * NVIDIA & ReShade may also this.
 */
HANDLE WINAPI hook_create_file(_In_ LPCWSTR lpFileName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwShareMode, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, _In_ DWORD dwCreationDisposition, _In_ DWORD dwFlagsAndAttributes, _In_opt_ HANDLE hTemplateFile) {
	wstring w_string(lpFileName);
	string file_name = string(w_string.begin(), w_string.end());

	if (file_name.find(".ini") != std::string::npos) {
		if (file_name.find("ReShade") == std::string::npos) {
			anticheat_detections::get().detect_by_type(anticheat_detections::_DetectionTypes::DETECTION_CREATE_FILE, file_name);
		}
	}

	return anticheat_detections::get().o_create_file(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
}

/**
 * Detection-Rate: 95%
 * False-Flag Rate: 0%
 *
 * Detects loading & writing any types of config or authentification files.
 * Usually theres no module who uses std::ifstream.
 */
FILE* __cdecl hook_fs_open(_In_z_ char const* _FileName, _In_z_ char const* _Mode, _In_ int _ShFlag) {
	string file_name = _FileName;

	if (file_name.find(".ini") != std::string::npos || file_name.find(".token") != std::string::npos || file_name.find(".cfg") != std::string::npos) {
		anticheat_detections::get().detect_by_type(anticheat_detections::_DetectionTypes::DETECTION_FS_OPEN, file_name);
	}

	return anticheat_detections::get().o_fs_open(_FileName, _Mode, _ShFlag);
}

/**
 * Detection-Rate: 100%
 * False-Flag Rate: 0%
 *
 * Detects common internal cheat overlays.
 */
HWND WINAPI hook_create_window(_In_ DWORD ex_style, _In_opt_ LPCSTR class_name, _In_opt_ LPCSTR window_name, _In_ DWORD style, _In_ int x, _In_ int y, _In_ int width, _In_ int height, _In_opt_ HWND parent, _In_opt_ HMENU menu, _In_opt_ HINSTANCE instance, _In_opt_ LPVOID param) {
	auto result = anticheat_detections::get().o_create_window(ex_style, class_name, window_name, style, x, y, width, height, parent, menu, instance, param);
	if (class_name == NULL) return result;

	std::string string_window_name(class_name);

	if (string_window_name != "DXGIWatchdogThreadWindow" && string_window_name != "D3DProxyWindow")
		anticheat_detections::get().detect_by_type(anticheat_detections::_DetectionTypes::DETECTION_CREATE_WINDOW, string_window_name);

	return result;
}

/**
 * Detection-Rate: 100%
 * False-Flag Rate: 0%
 *
 * FlushInstructionCache is getting called by MinHook.
 * It detects blacklisted hooks (e.g. Game-Thread & ScriptHook) in realtime.
 */
BOOL WINAPI hook_flush_instruction_cache(_In_ HANDLE process, _In_reads_bytes_opt_(size) LPCVOID base_address, _In_ SIZE_T size) {
	uintptr_t blacklisted_hooks[] = {
		(uintptr_t)GetModuleHandleA(NULL) + 0x6770
	};

	for (auto target_hook : blacklisted_hooks) {
		if ((uintptr_t)base_address == target_hook) {
			anticheat_detections::get().detect_by_type(anticheat_detections::_DetectionTypes::DETECTION_MINHOOK_FLUSH_CACHE);

			break;
		}
	}

	return anticheat_detections::get().o_flush_instruction_cache(process, base_address, size);
}

bool __fastcall hook_world_to_screen(Vector3* world_position, float* out_x, float* out_y) {
	DWORD64 current_tick = GetTickCount64();

	static DWORD64 current_tick_world2screen = 0x0;
	static DWORD64 latest_tick_world2screen = 0x0;

	if ((current_tick_world2screen - latest_tick_world2screen) > 10 * 1000) {
		anticheat_detections::get().detect_by_type(anticheat_detections::_DetectionTypes::DETECTION_WORLD_TO_SCREEN);
		
		latest_tick_world2screen = current_tick_world2screen;
	}
	current_tick_world2screen = current_tick;

	return anticheat_detections::get().o_world_to_screen(world_position, out_x, out_y);
}

/**
 * Detection-Rate: 100%
 * False-Flag Rate: 0%
 *
 * Detects standard LoadLibrary injections.
 * Example: GH-Injector, Xenos-64, etc.
 */
NTSTATUS NTAPI main_dll_manifest_prober_callback(IN HMODULE dll_base, IN PCWSTR full_dll_path, OUT PHANDLE activation_context) {
	DWORD64 current_tick = GetTickCount64();

	static DWORD64 current_tick_prober_callback = 0x0;
	static DWORD64 latest_tick_prober_callback = 0x0;

	if ((current_tick_prober_callback - latest_tick_prober_callback) > 4 * 1000) {
		anticheat_detections::get().detect_by_type(anticheat_detections::_DetectionTypes::DETECTION_DLL_MANIFEST_PROBER_CALLBACK);

		latest_tick_prober_callback = current_tick_prober_callback;
	}
	current_tick_prober_callback = current_tick;

	if (!*activation_context) return STATUS_INVALID_PARAMETER;

	HANDLE actx = NULL;
	ACTCTXW act = { 0 };

	act.cbSize = sizeof(act);
	act.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID | ACTCTX_FLAG_HMODULE_VALID;
	act.lpSource = full_dll_path;
	act.hModule = dll_base;

	*activation_context = 0;

	actx = CreateActCtxW(&act);

	if (actx == INVALID_HANDLE_VALUE) return 0xC0000234;
	*activation_context = actx;

	return 0x0;
}

void anticheat_detections::run_service()
{

	MH_CreateHook(&DisableThreadLibraryCalls, &hook_disable_thread_library_calls, reinterpret_cast<LPVOID*>(&o_disable_thread_library_calls));
	MH_EnableHook(&DisableThreadLibraryCalls);

	MH_CreateHook(&CreateFileW, &hook_create_file, reinterpret_cast<LPVOID*>(&o_create_file));
	MH_EnableHook(&CreateFileW);

	MH_CreateHook(&_fsopen, &hook_fs_open, reinterpret_cast<LPVOID*>(&o_fs_open));
	MH_EnableHook(&_fsopen);

	MH_CreateHook(&FlushInstructionCache, &hook_flush_instruction_cache, reinterpret_cast<LPVOID*>(&o_flush_instruction_cache));
	MH_EnableHook(&FlushInstructionCache);

	MH_CreateHook(&CreateWindowExA, &hook_create_window, reinterpret_cast<LPVOID*>(&o_create_window));
	MH_EnableHook(&CreateWindowExA);

	MH_CreateHook(pointers::get().ptr_gta_world_to_screen, &hook_world_to_screen, reinterpret_cast<LPVOID*>(&o_world_to_screen));
	MH_EnableHook(pointers::get().ptr_gta_world_to_screen);

	//	auto ldr_set_dll_manifest_prober = GetProcAddress(GetModuleHandleA("ntdll.dll"), "LdrSetDllManifestProber");
	//	if (ldr_set_dll_manifest_prober != NULL) reinterpret_cast<ldr_set_dll_manifest_prober_t>(ldr_set_dll_manifest_prober)(&main_dll_manifest_prober_callback, NULL, &ReleaseActCtx);
}

void anticheat_detections::detect_by_type(_DetectionTypes detection_type) {
	Log::Error("[", this->detection_to_string(detection_type), "] Detected forbidden module.");

	// TODO: send detection to server etc.
	// >:(
}

void anticheat_detections::detect_by_type(_DetectionTypes detection_type, std::string optional_information) {
	Log::Error("[", this->detection_to_string(detection_type), "] Detected forbidden module.");

	if (optional_information.length() > 0)
		Log::Error("[", this->detection_to_string(detection_type), "] Information:", optional_information);

	// TODO: send detection to server etc.
	// >:(
}

const char* anticheat_detections::detection_to_string(_DetectionTypes detection_type)
{
#define ST2STR(x)    \
    case x:             \
        return #x;

	switch (detection_type) {
		ST2STR(DETECTION_UNKNOWN)
			ST2STR(DETECTION_DISABLE_THREAD_LIBRARY_CALLS)
			ST2STR(DETECTION_CREATE_FILE)
			ST2STR(DETECTION_FS_OPEN)
			ST2STR(DETECTION_DLL_MANIFEST_PROBER_CALLBACK)
			ST2STR(DETECTION_MINHOOK_FLUSH_CACHE)
			ST2STR(DETECTION_CREATE_WINDOW)
			ST2STR(DETECTION_WORLD_TO_SCREEN)
			ST2STR(DETECTION_ANTICHEAT_SECURITY)
	}

#undef ST2STR

	return "(unknown)";
}

```

`src/inject.cpp`:

```cpp
#include "imports.hpp"
#include "nemo.hpp"

inline HMODULE g_hModule = nullptr;
DWORD WINAPI start_thread(LPVOID lParameter)
{
	Log::Push(new Log::ConsoleStream());
	MH_Initialize();

	nemo_ac::get().run_service(g_hModule);

	while (true)
	{
		// External Cheat Test
		/*if (GetAsyncKeyState(VK_ADD) & 0x1) {
			auto hwnd = GetTopWindow((HWND)GetForegroundWindow());

			std::wstring title(GetWindowTextLength(hwnd) + 1, L'\0');
			GetWindowTextW(hwnd, &title[0], title.size());

			Log::Info(title.c_str());
		}*/

		if (GetAsyncKeyState(VK_PRIOR) & 0x8000)
			break;

		std::this_thread::sleep_for(std::chrono::milliseconds(10));
		std::this_thread::yield();
	}

	nemo_ac::get().shutdown_service();

	fclose(stdin);
	fclose(stdout);

	FreeConsole();

	FreeLibraryAndExitThread(g_hModule, 0);

	return TRUE;
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
	if (ul_reason_for_call == DLL_PROCESS_ATTACH) {

		g_hModule = hModule;
		AllocConsole();

		SetConsoleTitleA("NEMO | Developer-Output Console");

		freopen_s((FILE**)stdin, "conin$", "r", stdin);
		freopen_s((FILE**)stdout, "conout$", "w", stdout);

		CreateThread(nullptr, 0, (LPTHREAD_START_ROUTINE)start_thread, nullptr, 0, nullptr);
	}

	return TRUE;
}
```

`src/nemo.cpp`:

```cpp
#include "nemo.hpp"
#include "networking/networking.hpp"
#include "anticheat/anticheat.hpp"
#include "renderer/renderer.hpp"
#include "pointers/pointers.hpp"
#include "utilities/security.hpp"

void nemo_ac::run_service(HMODULE module)
{
	Log::Debug(_xor_("nemo:V Anti-Cheat started."));

	security::get().hide_thread();

	// initialize security in own thread
	std::thread([]() {
		security::get().hide_thread();
		security::get().initialize();
	}).detach();

	pointers::get().initialize();

	if (IsValidPtr(pointers::get().ptr_ragemp_get_name)) {
		Log::Info("RAGE-MP Name:", *pointers::get().ptr_ragemp_get_name);
	}
	//renderer::get().initialize();
	anticheat_main::get().run_service();
}


void nemo_ac::shutdown_service()
{
	Log::Error(_xor_("nemo:V Anti-Cheat shutdown."));

	MH_DisableHook(MH_ALL_HOOKS);
	MH_Uninitialize();

	std::this_thread::sleep_for(std::chrono::milliseconds(1000));
}
```

`src/networking/data/packet.cpp`:

```cpp
// Copyright 2017 Citra Emulator Project
// Licensed under GPLv2 or any later version
// Refer to the license.txt file included.

#ifdef _WIN32
#include <winsock2.h>
#else
#include <arpa/inet.h>
#endif
#include <cstring>
#include <string>
#include "networking/data/packet.h"

namespace Network {

#ifndef htonll
    u64 htonll(u64 x) {
        return ((1 == htonl(1)) ? (x) : ((uint64_t)htonl((x) & 0xFFFFFFFF) << 32) | htonl((x) >> 32));
    }
#endif

#ifndef ntohll
    u64 ntohll(u64 x) {
        return ((1 == ntohl(1)) ? (x) : ((uint64_t)ntohl((x) & 0xFFFFFFFF) << 32) | ntohl((x) >> 32));
    }
#endif

    void Packet::Append(const void* in_data, std::size_t size_in_bytes) {
        if (in_data && (size_in_bytes > 0)) {
            std::size_t start = data.size();
            data.resize(start + size_in_bytes);
            std::memcpy(&data[start], in_data, size_in_bytes);
        }
    }

    void Packet::Read(void* out_data, std::size_t size_in_bytes) {
        if (out_data && CheckSize(size_in_bytes)) {
            std::memcpy(out_data, &data[read_pos], size_in_bytes);
            read_pos += size_in_bytes;
        }
    }

    void Packet::Clear() {
        data.clear();
        read_pos = 0;
        is_valid = true;
    }

    const void* Packet::GetData() const {
        return !data.empty() ? &data[0] : nullptr;
    }

    void Packet::IgnoreBytes(u32 length) {
        read_pos += length;
    }

    std::size_t Packet::GetDataSize() const {
        return data.size();
    }

    bool Packet::EndOfPacket() const {
        return read_pos >= data.size();
    }

    Packet::operator bool() const {
        return is_valid;
    }

    Packet& Packet::operator>>(bool& out_data) {
        u8 value;
        if (*this >> value) {
            out_data = (value != 0);
        }
        return *this;
    }

    Packet& Packet::operator>>(s8& out_data) {
        Read(&out_data, sizeof(out_data));
        return *this;
    }

    Packet& Packet::operator>>(u8& out_data) {
        Read(&out_data, sizeof(out_data));
        return *this;
    }

    Packet& Packet::operator>>(s16& out_data) {
        s16 value;
        Read(&value, sizeof(value));
        out_data = ntohs(value);
        return *this;
    }

    Packet& Packet::operator>>(u16& out_data) {
        u16 value;
        Read(&value, sizeof(value));
        out_data = ntohs(value);
        return *this;
    }

    Packet& Packet::operator>>(s32& out_data) {
        s32 value;
        Read(&value, sizeof(value));
        out_data = ntohl(value);
        return *this;
    }

    Packet& Packet::operator>>(u32& out_data) {
        u32 value;
        Read(&value, sizeof(value));
        out_data = ntohl(value);
        return *this;
    }

    Packet& Packet::operator>>(s64& out_data) {
        s64 value;
        Read(&value, sizeof(value));
        out_data = ntohll(value);
        return *this;
    }

    Packet& Packet::operator>>(u64& out_data) {
        u64 value;
        Read(&value, sizeof(value));
        out_data = ntohll(value);
        return *this;
    }

    Packet& Packet::operator>>(float& out_data) {
        Read(&out_data, sizeof(out_data));
        return *this;
    }

    Packet& Packet::operator>>(double& out_data) {
        Read(&out_data, sizeof(out_data));
        return *this;
    }

    Packet& Packet::operator>>(char* out_data) {
        // First extract string length
        u32 length = 0;
        *this >> length;

        if ((length > 0) && CheckSize(length)) {
            // Then extract characters
            std::memcpy(out_data, &data[read_pos], length);
            out_data[length] = '\0';

            // Update reading position
            read_pos += length;
        }

        return *this;
    }

    Packet& Packet::operator>>(std::string& out_data) {
        // First extract string length
        u32 length = 0;
        *this >> length;

        out_data.clear();
        if ((length > 0) && CheckSize(length)) {
            // Then extract characters
            out_data.assign(&data[read_pos], length);

            // Update reading position
            read_pos += length;
        }

        return *this;
    }

    Packet& Packet::operator<<(bool in_data) {
        *this << static_cast<u8>(in_data);
        return *this;
    }

    Packet& Packet::operator<<(s8 in_data) {
        Append(&in_data, sizeof(in_data));
        return *this;
    }

    Packet& Packet::operator<<(u8 in_data) {
        Append(&in_data, sizeof(in_data));
        return *this;
    }

    Packet& Packet::operator<<(s16 in_data) {
        s16 toWrite = htons(in_data);
        Append(&toWrite, sizeof(toWrite));
        return *this;
    }

    Packet& Packet::operator<<(u16 in_data) {
        u16 toWrite = htons(in_data);
        Append(&toWrite, sizeof(toWrite));
        return *this;
    }

    Packet& Packet::operator<<(s32 in_data) {
        s32 toWrite = htonl(in_data);
        Append(&toWrite, sizeof(toWrite));
        return *this;
    }

    Packet& Packet::operator<<(u32 in_data) {
        u32 toWrite = htonl(in_data);
        Append(&toWrite, sizeof(toWrite));
        return *this;
    }

    Packet& Packet::operator<<(s64 in_data) {
        s64 toWrite = htonll(in_data);
        Append(&toWrite, sizeof(toWrite));
        return *this;
    }

    Packet& Packet::operator<<(u64 in_data) {
        u64 toWrite = htonll(in_data);
        Append(&toWrite, sizeof(toWrite));
        return *this;
    }

    Packet& Packet::operator<<(float in_data) {
        Append(&in_data, sizeof(in_data));
        return *this;
    }

    Packet& Packet::operator<<(double in_data) {
        Append(&in_data, sizeof(in_data));
        return *this;
    }

    Packet& Packet::operator<<(const char* in_data) {
        // First insert string length
        u32 length = static_cast<u32>(std::strlen(in_data));
        *this << length;

        // Then insert characters
        Append(in_data, length * sizeof(char));

        return *this;
    }

    Packet& Packet::operator<<(const std::string& in_data) {
        // First insert string length
        u32 length = static_cast<u32>(in_data.size());
        *this << length;

        // Then insert characters
        if (length > 0)
            Append(in_data.c_str(), length * sizeof(std::string::value_type));

        return *this;
    }

    bool Packet::CheckSize(std::size_t size) {
        is_valid = is_valid && (read_pos + size <= data.size());

        return is_valid;
    }

} // namespace Network
```

`src/networking/networking.cpp`:

```cpp
#define ENET_IMPLEMENTATION
#include "networking/networking.hpp"

void networking::start()
{
	std::thread([&] {
		if (enet_initialize() != 0) return;

		this->client = enet_host_create(NULL, 1, 2, 0, 0);
		if (this->client == NULL) {
			Log::Error("[!] Networking", "Failed to create client.");
			return;
		}

		enet_address_set_host(&address, this->nemo_server_ip);
		address.port = 3004;

		peer = enet_host_connect(client, &address, 2, 0);
		if (peer == NULL) {
			Log::Error("[!] Networking >>", "Failed to connect to server.");
		}

		ENetEvent e;
		if (enet_host_service(client, &e, 5000) > 0 && e.type == ENET_EVENT_TYPE_CONNECT) {
			Log::Warning("[!] Networking >>", "Connected to server.");
		}
		else {
			enet_peer_reset(peer);
			Log::Error("[!] Networking >>", "Failed to connect to server.");
			Log::Info((uintptr_t)client->address.port);
		}

		/*ENetPacket* packet = enet_packet_create("REQUEST_LOGIN", strlen("test") + 1, ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet);*/

		while (true) {
			this->pulse();
			std::this_thread::sleep_for(std::chrono::milliseconds(10));
		}
		}).detach();
}

void networking::pulse()
{
	ENetEvent e;

	while (enet_host_service(client, &e, 3000) > 0) {
		switch (e.type) {
		case ENET_EVENT_TYPE_RECEIVE:
			switch (e.packet->data[0]) {
				//TODO: add packet receive
			}

			enet_packet_destroy(e.packet);
			break;
		case ENET_EVENT_TYPE_DISCONNECT:
			Log::Error("[!] Networking >>", "Connection disconnected.");
			break;
		case ENET_EVENT_TYPE_DISCONNECT_TIMEOUT:
			Log::Error("[!] Networking >>", "Connection timed out.");
			break;
		}
	}

	//enet_peer_reset(peer);
}

void networking::send_packet(Network::Packet buffer)
{
	ENetPacket* packet = enet_packet_create(buffer.GetData(), buffer.GetDataSize(), ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet);
}
```

`src/pointers/pointers.cpp`:

```cpp
#include <pointers\pointers.hpp>
#include <Psapi.h>

using namespace memory;

void pointers::initialize()
{
	this->gta5_module = memory::module_t(nullptr);
	this->ragemp_module = memory::module_t("multiplayer.dll");

	if (!this->ragemp_module.base()) {
		MessageBoxA(0, "Es ist ein Fehler aufgetreten. Bitte starte das Spiel neu!", "GVMP Anti-Cheat", 0);
		exit(0);

		return;
	}

	//TODO: _xor_ all strings

	this->ptr_gta_game_state = as_relative<game_state_t*>(find_pattern(this->gta5_module, "Game-State", "48 85 C9 74 4B 83 3D"), 7);
	this->ptr_gta_world_factory = as_relative<CWorldFactory*>(find_pattern(this->gta5_module, "WorldFactory", "48 8B C3 48 83 C4 20 5B C3 0F B7 05 ? ? ? ?", -0xB));
	this->ptr_gta_viewport = *as_relative<CViewPort**>(find_pattern(this->gta5_module, "Viewport", "48 8B 15 ? ? ? ? 48 8D 2D ? ? ? ? 48 8B CD"));
	this->ptr_gta_camera = as_relative<uintptr_t>(find_pattern(this->gta5_module, "Camera", "48 8B 05 ? ? ? ? 48 8B 98 ? ? ? ? EB"));
	this->ptr_gta_get_bone_position = find_pattern<get_bone_position_t>(this->gta5_module, "GetBone", "48 89 5C 24 ? 48 89 6C 24 ? 48 89 74 24 ? 57 48 83 EC 60 48 8B 01 41 8B E8 48 8B F2 48 8B F9 33 DB");
	this->ptr_gta_world_to_screen = find_pattern<world_to_screen_t>(this->gta5_module, "WorldToScreen", "48 89 5C 24 ? 55 56 57 48 83 EC 70 65 4C 8B 0C 25 ? 00 00 00 8B");
	this->ptr_gta_pointer_to_handle = find_pattern<pointer_to_handle_t>(this->gta5_module, "PointerToHandle", "48 89 5C 24 ? 48 89 74 24 ? 57 48 83 EC 20 8B 15 ? ? ? ? 48 8B F9 48 83 C1 10 33 DB");

	this->ptr_ragemp_get_name = find_pattern<std::string*>(this->ragemp_module, "PlayerName", "70 78 46 ? 70 78 46 ? 40 1C 45 ? FF ? ?", 0xF);

	// dauert lange, da er alle module durchscannt  :p
	//if (find_pattern_outside_module<uintptr_t>("0xCheats", "E8 ? ? ? ? 41 52 49 89 E2") != 0)
	//	Log::Info("FOUND");
	// find_pattern_outside_module<uintptr_t>("Hags", "65 6E 65 6D 79 5F 76 69");
}

```

`src/renderer/renderer.cpp`:

```cpp
#include <renderer\renderer.hpp>
#include <DirectXPackedVector.h>
#include "pointers/pointers.hpp"

HRESULT __stdcall d3d11_present(IDXGISwapChain* swap_chain, UINT sync_interval, UINT flags) {
	auto& renderer = renderer::get();

	std::call_once(renderer.already_initialized, [&]() {
		swap_chain->GetDevice(__uuidof(renderer.ptr_device), (void**)&renderer.ptr_device);
		renderer.ptr_device->GetImmediateContext(&renderer.ptr_device_context);

		IFW1Factory* font_factory = NULL;
		FW1CreateFactory(FW1_VERSION, &font_factory);

		if (font_factory != NULL && renderer.ptr_device != NULL) {
			font_factory->CreateFontWrapper(renderer.ptr_device, L"Hero Light", &renderer.font_wrapper);
			font_factory->Release();
		}

		ID3D11Texture2D* pBackBuffer = NULL;
		swap_chain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&pBackBuffer);

		if (pBackBuffer != NULL)
			renderer.ptr_device->CreateRenderTargetView(pBackBuffer, NULL, &renderer.target_view);
		});

	renderer.ptr_device_context->OMSetRenderTargets(1, &renderer.target_view, NULL);

	// TODO: add client & game-thread
	//		 add timeouts

	// COLOR FORMAT: 0xAARRGGBB
	if (IsValidPtr(pointers::get().ptr_gta_world_factory)) {
		auto local_world = pointers::get().ptr_gta_world_factory->world;
		if (IsValidPtr(local_world)) {
			renderer.font_wrapper->DrawString(renderer.ptr_device_context, L"GVMP Anti-Cheat", 12, 8, 5, 0x9fffffff, FW1_RESTORESTATE);
			renderer.font_wrapper->DrawString(renderer.ptr_device_context, L"GVMP Anti-Cheat", 12, 8, 8, 0x59ffffff, FW1_RESTORESTATE);
		}
	}

	return renderer.o_d3d11_present(swap_chain, sync_interval, flags);
}

bool renderer::initialize()
{
	HWND window = GetForegroundWindow();

	if (!window)
		return false;

	D3D_FEATURE_LEVEL feature_level = D3D_FEATURE_LEVEL_11_0;
	DXGI_SWAP_CHAIN_DESC swap_chain_desc;

	ZeroMemory(&swap_chain_desc, sizeof(swap_chain_desc));
	swap_chain_desc.BufferCount = 1;
	swap_chain_desc.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
	swap_chain_desc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
	swap_chain_desc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
	swap_chain_desc.OutputWindow = window;
	swap_chain_desc.SampleDesc.Count = 1;
	swap_chain_desc.Windowed = (GetWindowLong(window, GWL_STYLE) & WS_POPUP) != 0 ? FALSE : TRUE;
	swap_chain_desc.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
	swap_chain_desc.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;
	swap_chain_desc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

	HRESULT create_result = D3D11CreateDeviceAndSwapChain(NULL, D3D_DRIVER_TYPE_HARDWARE, NULL, NULL, &feature_level, 1, D3D11_SDK_VERSION, &swap_chain_desc, &ptr_swap_chain, &ptr_device, NULL, &ptr_device_context);

	if (FAILED(create_result))
		return false;

	v_table_swap_chain = (DWORD_PTR*)(ptr_swap_chain);
	v_table_swap_chain = (DWORD_PTR*)(v_table_swap_chain[0]);

	v_table_device = (DWORD_PTR*)(ptr_device);
	v_table_device = (DWORD_PTR*)(v_table_device[0]);

	v_table_device_context = (DWORD_PTR*)(ptr_device_context);
	v_table_device_context = (DWORD_PTR*)(v_table_device_context[0]);

	auto ptr_d3d11_present = (d3d11_present_t)v_table_swap_chain[8];

	if (MH_CreateHook(ptr_d3d11_present, &d3d11_present, reinterpret_cast<LPVOID*>(&o_d3d11_present)) != MH_OK)
		Log::Error("Renderer /", "Failed to create hook.");

	if (MH_EnableHook(ptr_d3d11_present) != MH_OK)
		Log::Error("Renderer /", "Failed to enable hook.");

	ptr_swap_chain->Release();
	ptr_device->Release();
	ptr_device_context->Release();

	Log::Error("Renderer /", "Successfully initialized renderer.");

	return true;
}
```

`src/utilities/security.cpp`:

```cpp
#include <utilities\security.hpp>

void security::hide_thread() {
	HMODULE h_ntdll = GetModuleHandleA("ntdll.dll");
	if (h_ntdll == INVALID_HANDLE_VALUE || h_ntdll == NULL) return;

	auto nt_set_information_thread = GetProcAddress(h_ntdll, "NtSetInformationThread");
	if (nt_set_information_thread != NULL) reinterpret_cast<nt_set_information_thread_t>(nt_set_information_thread)(GetCurrentThread(), thread_hide_from_debugger, 0, 0);
}

void security::check_heartbeart() {
	// check to networking server if client is connected
}

bool security::check_debug_string()
{
	DWORD last_error = GetLastError();
	OutputDebugStringA("GVMP Anti-Cheat Security Check");

	return GetLastError() != last_error;
}

bool security::check_remote_debugger()
{
	BOOL is_debugger_present = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &is_debugger_present);

	return is_debugger_present;
}

bool security::check_registry()
{
	HKEY h_key = 0;
	return RegOpenKeyExA(HKEY_LOCAL_MACHINE, "HARDWARE\\ACPI\\DSDT\\VBOX__", 0, KEY_READ, &h_key) == ERROR_SUCCESS;
}

std::string security::check_blacklisted_windows()
{
	// Hier beliebige Namen einfügen die ihr geblacklisted haben wollt.
	std::string names[] = {
		"Scylla x86 v0.9.8", "Scylla x64 v0.9.8", "Scylla x64 v0.9.8c", "Scylla x64 v0.9.8c", "Scylla x64 v0.9.7", "Scylla x64 v0.9.7", "Scylla x64 v0.9.7c", "Scylla x64 v0.9.7c",
		"OLLYDBG", "x64dbg"
		"SunAwtFrame",
		"IDA Pro 7.1", "IDA Pro 7.2", "IDA Pro 7.3", "IDA Pro 7.4", "IDA Pro 7.5",
		"Cheat Engine 7.1", "Cheat Engine 7.2",
		"GH Injector x64", "GH Injector x32", "GH Injector V3.2 (64-bit)"
		"Xenos-64",
		"immunity",
	};

	for (auto name : names) {
		auto hwnd = FindWindowA(name.c_str(), NULL);
		if (hwnd) {
			std::string title(GetWindowTextLengthA(hwnd) + 1, L'\0');
			GetWindowTextA(hwnd, &title[0], title.size());

			DestroyWindow(hwnd);
			return title;
		}
		else if (hwnd = FindWindowA(NULL, name.c_str()); hwnd) {
			std::string title(GetWindowTextLengthA(hwnd) + 1, L'\0');
			GetWindowTextA(hwnd, &title[0], title.size());

			DestroyWindow(hwnd);
			return title;
		}
	}

	return "";
}

void security::initialize()
{
	while (true) {
		check_heartbeart();
		if (check_debug_string()) anticheat_detections::get().detect_by_type(anticheat_detections::DETECTION_ANTICHEAT_SECURITY, "DEBUGGER (string)");
		else if (check_remote_debugger()) anticheat_detections::get().detect_by_type(anticheat_detections::DETECTION_ANTICHEAT_SECURITY, "DEBUGGER (remote)");
		else if (IsDebuggerPresent()) anticheat_detections::get().detect_by_type(anticheat_detections::DETECTION_ANTICHEAT_SECURITY, "DEBUGGER");
		else if (check_registry()) anticheat_detections::get().detect_by_type(anticheat_detections::DETECTION_ANTICHEAT_SECURITY, "REGISTRY");
		else if (auto blacklisted_window = check_blacklisted_windows(); blacklisted_window.length() > 1) anticheat_detections::get().detect_by_type(anticheat_detections::DETECTION_ANTICHEAT_SECURITY, blacklisted_window);

		std::this_thread::sleep_for(std::chrono::seconds(4000));
	}
}
```

`src/vendor/fontwrapper/CFW1ColorRGBA.cpp`:

```cpp
// CFW1ColorRGBA.cpp

#include <vendor/fontwrapper/FW1Precompiled.h>

#include <vendor/fontwrapper/CFW1ColorRGBA.h>


namespace FW1FontWrapper {


// Construct
CFW1ColorRGBA::CFW1ColorRGBA() :
	m_color32(0xffffffff)
{
}


// Destruct
CFW1ColorRGBA::~CFW1ColorRGBA() {
}


// Init
HRESULT CFW1ColorRGBA::initColor(IFW1Factory *pFW1Factory, UINT32 initialColor32) {
	HRESULT hResult = initBaseObject(pFW1Factory);
	if(FAILED(hResult))
		return hResult;
	
	m_color32 = initialColor32;
	
	return S_OK;
}


}// namespace FW1FontWrapper

```

`src/vendor/fontwrapper/CFW1ColorRGBAInterface.cpp`:

```cpp
// CFW1ColorRGBAInterface.cpp

#include <vendor/fontwrapper/FW1Precompiled.h>

#include <vendor/fontwrapper/CFW1ColorRGBA.h>


namespace FW1FontWrapper {


// Query interface
HRESULT STDMETHODCALLTYPE CFW1ColorRGBA::QueryInterface(REFIID riid, void **ppvObject) {
	if(ppvObject == NULL)
		return E_INVALIDARG;
	
	if(IsEqualIID(riid, __uuidof(IFW1ColorRGBA))) {
		*ppvObject = static_cast<IFW1ColorRGBA*>(this);
		AddRef();
		return S_OK;
	}
	
	return CFW1Object::QueryInterface(riid, ppvObject);
}


// Set the color
void STDMETHODCALLTYPE CFW1ColorRGBA::SetColor(UINT32 Color) {
	m_color32 = Color;
}


// Set the color
void STDMETHODCALLTYPE CFW1ColorRGBA::SetColor(FLOAT Red, FLOAT Green, FLOAT Blue, FLOAT Alpha) {
	UINT32 color32;
	BYTE *colorBytes = reinterpret_cast<BYTE*>(&color32);
	colorBytes[0] = static_cast<BYTE>(Red * 255.0f + 0.5f);
	colorBytes[1] = static_cast<BYTE>(Green * 255.0f + 0.5f);
	colorBytes[2] = static_cast<BYTE>(Blue * 255.0f + 0.5f);
	colorBytes[3] = static_cast<BYTE>(Alpha * 255.0f + 0.5f);
	
	m_color32 = color32;
}


// Set the color
void STDMETHODCALLTYPE CFW1ColorRGBA::SetColor(const FLOAT *pColor) {
	SetColor(pColor[0], pColor[1], pColor[2], pColor[3]);
}


// Set the color
void STDMETHODCALLTYPE CFW1ColorRGBA::SetColor(const BYTE *pColor) {
	UINT32 color32;
	BYTE *colorBytes = reinterpret_cast<BYTE*>(&color32);
	for(int i=0; i < 4; ++i)
		colorBytes[i] = pColor[i];
	
	m_color32 = color32;
}


// Get the color
UINT32 STDMETHODCALLTYPE CFW1ColorRGBA::GetColor32() {
	return m_color32;
}


}// namespace FW1FontWrapper

```

`src/vendor/fontwrapper/CFW1DWriteRenderTarget.cpp`:

```cpp
// CFW1DWriteRenderTarget.cpp

#include <vendor/fontwrapper/FW1Precompiled.h>

#include <vendor/fontwrapper/CFW1DWriteRenderTarget.h>

#define SAFE_RELEASE(pObject) { if(pObject) { (pObject)->Release(); (pObject) = NULL; } }


namespace FW1FontWrapper {


// Construct
CFW1DWriteRenderTarget::CFW1DWriteRenderTarget() :
	m_pRenderTarget(NULL),
	m_hDC(NULL),
	m_hBlackBrush(NULL),
	m_bmWidthBytes(0),
	m_bmBytesPixel(0),
	m_renderTargetWidth(0),
	m_renderTargetHeight(0)
{
}


// Destruct
CFW1DWriteRenderTarget::~CFW1DWriteRenderTarget() {
	if(m_hBlackBrush != NULL)
		DeleteObject(m_hBlackBrush);
	
	SAFE_RELEASE(m_pRenderTarget);
	
	for(RenderingParamsMap::iterator it = m_renderingParams.begin(); it != m_renderingParams.end(); ++it)
		it->second->Release();
}


// Init
HRESULT CFW1DWriteRenderTarget::initRenderTarget(
	IFW1Factory *pFW1Factory,
	IDWriteFactory *pDWriteFactory,
	UINT renderTargetWidth,
	UINT renderTargetHeight
) {
	HRESULT hResult = initBaseObject(pFW1Factory);
	if(FAILED(hResult))
		return hResult;
	
	if(pDWriteFactory == NULL)
		return E_INVALIDARG;
	
	m_renderTargetWidth = 384;
	if(renderTargetWidth > 0)
		m_renderTargetWidth = renderTargetWidth;
	
	m_renderTargetHeight = 384;
	if(renderTargetHeight > 0)
		m_renderTargetHeight = renderTargetHeight;
	
	// Create render target
	hResult = createRenderTarget(pDWriteFactory);
	
	if(SUCCEEDED(hResult))
		hResult = S_OK;
	
	return hResult;
}


// Create render target
HRESULT CFW1DWriteRenderTarget::createRenderTarget(IDWriteFactory *pDWriteFactory) {
	IDWriteGdiInterop *pGDIInterop;
	HRESULT hResult = pDWriteFactory->GetGdiInterop(&pGDIInterop);
	if(FAILED(hResult)) {
		m_lastError = L"Failed to get GDI interop";
	}
	else {
		IDWriteBitmapRenderTarget *pRenderTarget;
		hResult = pGDIInterop->CreateBitmapRenderTarget(
			NULL,
			m_renderTargetWidth,
			m_renderTargetHeight,
			&pRenderTarget
		);
		if(FAILED(hResult)) {
			m_lastError = L"Failed to create bitmap render target";
		}
		else {
			hResult = pRenderTarget->SetPixelsPerDip(1.0f);
			hResult = S_OK;
			
			HDC hDC = pRenderTarget->GetMemoryDC();
			if(hDC == NULL) {
				m_lastError = L"Failed to get render target DC";
				hResult = E_FAIL;
			}
			else {
				HBRUSH hBrush = CreateSolidBrush(RGB(0, 0, 0));
				if(hBrush == NULL) {
					m_lastError = L"Failed to create brush";
					hResult = E_FAIL;
				}
				else {
					HBITMAP hBitmap = static_cast<HBITMAP>(GetCurrentObject(hDC, OBJ_BITMAP));
					if(hBitmap == NULL) {
						m_lastError = L"GetCurrentObject failed";
						hResult = E_FAIL;
					}
					else {
						DIBSECTION dib;
						int iResult = GetObject(hBitmap, sizeof(dib), &dib);
						if(iResult < sizeof(dib)) {
							m_lastError = L"GetObject failed";
							hResult = E_FAIL;
						}
						else {
							// Store render target resources and info
							m_pRenderTarget = pRenderTarget;
							
							m_hDC = hDC;
							m_hBlackBrush = hBrush;
							
							m_bmBits = dib.dsBm.bmBits;
							m_bmWidthBytes = static_cast<UINT>(dib.dsBm.bmWidthBytes);
							m_bmBytesPixel = static_cast<UINT>(dib.dsBm.bmBitsPixel) / 8;
							
							hResult = S_OK;
						}
					}
					
					if(FAILED(hResult))
						DeleteObject(hBrush);
				}
			}
			
			if(FAILED(hResult))
				pRenderTarget->Release();
		}
		
		pGDIInterop->Release();
	}
	
	// Create rendering params for all accepted rendering modes
	if(SUCCEEDED(hResult)) {
		const UINT renderingModeCount = 2;
		DWRITE_RENDERING_MODE renderingModes[renderingModeCount] = {
			DWRITE_RENDERING_MODE_DEFAULT,
			DWRITE_RENDERING_MODE_ALIASED
		};
		
		for(UINT i=0; i < renderingModeCount; ++i) {
			DWRITE_RENDERING_MODE renderingMode = renderingModes[i];
			IDWriteRenderingParams *pRenderingParams;
			
			hResult = pDWriteFactory->CreateCustomRenderingParams(
				1.0f,
				0.0f,
				0.0f,
				DWRITE_PIXEL_GEOMETRY_FLAT,
				renderingMode,
				&pRenderingParams
			);
			if(SUCCEEDED(hResult))
				m_renderingParams.insert(std::make_pair(renderingMode, pRenderingParams));
		}
		
		if(m_renderingParams.empty()) {
			m_lastError = L"Failed to create rendering params";
			hResult = E_FAIL;
		}
		else
			hResult = S_OK;
	}
	
	return hResult;
}


// Init glyph data
void CFW1DWriteRenderTarget::initGlyphData(
	const DWRITE_FONT_METRICS *fontMetrics,
	const DWRITE_GLYPH_METRICS *glyphMetrics,
	FLOAT fontSize,
	DWGlyphData *outGlyphData
) {
	// Calculate pixel-space coordinates
	FLOAT fscale = fontSize / static_cast<FLOAT>(fontMetrics->designUnitsPerEm);
	
	FLOAT l = static_cast<FLOAT>(glyphMetrics->leftSideBearing) * fscale;
	FLOAT t = static_cast<FLOAT>(glyphMetrics->topSideBearing) * fscale;
	
	FLOAT r = static_cast<FLOAT>(glyphMetrics->rightSideBearing) * fscale;
	FLOAT b = static_cast<FLOAT>(glyphMetrics->bottomSideBearing) * fscale;
	
	FLOAT v = static_cast<FLOAT>(glyphMetrics->verticalOriginY) * fscale;
	
	FLOAT aw = static_cast<FLOAT>(glyphMetrics->advanceWidth) * fscale;
	FLOAT ah = static_cast<FLOAT>(glyphMetrics->advanceHeight) * fscale;
	
	// Set up glyph data
	outGlyphData->offsetX = floor(l);
	outGlyphData->offsetY = floor(t) - floor(v);
	outGlyphData->maxWidth = static_cast<LONG>(aw - r - l + 2.0f);
	outGlyphData->maxHeight = static_cast<LONG>(ah - b - t + 2.0f);
}


}// namespace FW1FontWrapper

```

`src/vendor/fontwrapper/CFW1DWriteRenderTargetInterface.cpp`:

```cpp
// CFW1DWriteRenderTargetInterface.cpp

#include <vendor/fontwrapper/FW1Precompiled.h>

#include <vendor/fontwrapper/CFW1DWriteRenderTarget.h>


namespace FW1FontWrapper {


// Query interface
HRESULT STDMETHODCALLTYPE CFW1DWriteRenderTarget::QueryInterface(REFIID riid, void **ppvObject) {
	if(ppvObject == NULL)
		return E_INVALIDARG;
	
	if(IsEqualIID(riid, __uuidof(IFW1DWriteRenderTarget))) {
		*ppvObject = static_cast<IFW1DWriteRenderTarget*>(this);
		AddRef();
		return S_OK;
	}
	
	return CFW1Object::QueryInterface(riid, ppvObject);
}


// Draw glyph to temporary storage
HRESULT STDMETHODCALLTYPE CFW1DWriteRenderTarget::DrawGlyphTemp(
	IDWriteFontFace *pFontFace,
	UINT16 GlyphIndex,
	FLOAT FontSize,
	DWRITE_RENDERING_MODE RenderingMode,
	DWRITE_MEASURING_MODE MeasuringMode,
	FW1_GLYPHIMAGEDATA *pOutData
) {
	// Font metrics
	DWRITE_FONT_METRICS fontMetrics;
	pFontFace->GetMetrics(&fontMetrics);
	
	// Glyph metrics
	DWRITE_GLYPH_METRICS glyphMetrics;
	HRESULT hResult = pFontFace->GetDesignGlyphMetrics(&GlyphIndex, 1, &glyphMetrics, FALSE);
	if(FAILED(hResult))
		return hResult;
	
	// Calculate pixel measurements
	DWGlyphData dwGlyphData;
	initGlyphData(&fontMetrics, &glyphMetrics, FontSize, &dwGlyphData);
	
	// Set up drawing
	FLOAT glyphAdvance = 0.0f;
	DWRITE_GLYPH_OFFSET glyphOffset = {0.0f, 0.0f};
	
	DWRITE_GLYPH_RUN glyphRun;
	ZeroMemory(&glyphRun, sizeof(glyphRun));
	glyphRun.fontFace = pFontFace;
	glyphRun.fontEmSize = FontSize;
	glyphRun.glyphCount = 1;
	glyphRun.glyphIndices = &GlyphIndex;
	glyphRun.glyphAdvances = &glyphAdvance;
	glyphRun.glyphOffsets = &glyphOffset;
	
	// Clear background
	RECT rect;
	SetRect(&rect, 0, 0, 2+dwGlyphData.maxWidth+5, 2+dwGlyphData.maxHeight+5);
	int iRet = FillRect(m_hDC, &rect, m_hBlackBrush);
	if(iRet == 0) {
	}
	
	// Rendering mode
	IDWriteRenderingParams *pRenderingParams;
	
	RenderingParamsMap::iterator it = m_renderingParams.find(RenderingMode);
	if(it != m_renderingParams.end())
		pRenderingParams = it->second;
	else
		pRenderingParams = m_renderingParams.begin()->second;
	
	// Draw
	hResult = m_pRenderTarget->DrawGlyphRun(
		2.0f - dwGlyphData.offsetX,
		2.0f - dwGlyphData.offsetY,
		MeasuringMode,
		&glyphRun,
		pRenderingParams,
		RGB(255, 255, 255),
		&rect
	);
	if(FAILED(hResult))
		return hResult;
	
	// Clip to valid render target to avoid buffer overruns in case the glyph was too large
	rect.left = std::max(rect.left, 0L);
	rect.top = std::max(rect.top, 0L);
	rect.right = std::min(static_cast<LONG>(m_renderTargetWidth), rect.right);
	rect.bottom = std::min(static_cast<LONG>(m_renderTargetHeight), rect.bottom);
	
	// Return glyph data
	pOutData->Metrics.OffsetX = dwGlyphData.offsetX + static_cast<FLOAT>(rect.left) - 2.0f;
	pOutData->Metrics.OffsetY = dwGlyphData.offsetY + static_cast<FLOAT>(rect.top) - 2.0f;
	pOutData->Metrics.Width = static_cast<UINT>(rect.right - rect.left);
	pOutData->Metrics.Height = static_cast<UINT>(rect.bottom - rect.top);
	pOutData->pGlyphPixels =
		static_cast<const char*>(m_bmBits)
		+ rect.top * m_bmWidthBytes
		+ rect.left * m_bmBytesPixel;
	pOutData->RowPitch = m_bmWidthBytes;
	pOutData->PixelStride = m_bmBytesPixel;
	
	return S_OK;
}


}// namespace FW1FontWrapper

```

`src/vendor/fontwrapper/CFW1Factory.cpp`:

```cpp
// CFW1Factory.cpp

#include <vendor/fontwrapper/FW1Precompiled.h>

#include <vendor/fontwrapper/CFW1Factory.h>


namespace FW1FontWrapper {


// Construct
CFW1Factory::CFW1Factory() :
	m_cRefCount(1)
{
	InitializeCriticalSection(&m_errorStringCriticalSection);
}


// Destruct
CFW1Factory::~CFW1Factory() {
	DeleteCriticalSection(&m_errorStringCriticalSection);
}


// Init
HRESULT CFW1Factory::initFactory() {
	return S_OK;
}


// Create a DWrite factory
HRESULT CFW1Factory::createDWriteFactory(IDWriteFactory **ppDWriteFactory) {
	HRESULT hResult = E_FAIL;
	
	typedef HRESULT (WINAPI * PFN_DWRITECREATEFACTORY)(__in DWRITE_FACTORY_TYPE factoryType, __in REFIID iid, __out IUnknown **factory);
	PFN_DWRITECREATEFACTORY pfnDWriteCreateFactory = NULL;
	
#ifdef FW1_DELAYLOAD_DWRITE_DLL
	HMODULE hDWriteLib = LoadLibrary(TEXT("DWrite.dll"));
	if(hDWriteLib == NULL) {
		DWORD dwErr = GetLastError();
		dwErr;
		setErrorString(L"Failed to load DWrite.dll");
	}
	else {
		pfnDWriteCreateFactory =
			reinterpret_cast<PFN_DWRITECREATEFACTORY>(GetProcAddress(hDWriteLib, "DWriteCreateFactory"));
		if(pfnDWriteCreateFactory == NULL) {
			DWORD dwErr = GetLastError();
			dwErr;
			setErrorString(L"Failed to load DWriteCreateFactory");
		}
	}
#else
	pfnDWriteCreateFactory = DWriteCreateFactory;
#endif
	
	if(pfnDWriteCreateFactory != NULL) {
		IDWriteFactory *pDWriteFactory;
		
		hResult = pfnDWriteCreateFactory(
			DWRITE_FACTORY_TYPE_SHARED,
			__uuidof(IDWriteFactory),
			reinterpret_cast<IUnknown**>(&pDWriteFactory)
		);
		if(FAILED(hResult)) {
			setErrorString(L"DWriteCreateFactory failed");
		}
		else {
			*ppDWriteFactory = pDWriteFactory;
				
			hResult = S_OK;
		}
	}
	
	return hResult;
}


// Set error string
void CFW1Factory::setErrorString(const wchar_t *str) {
	EnterCriticalSection(&m_errorStringCriticalSection);
	m_lastError = str;
	LeaveCriticalSection(&m_errorStringCriticalSection);
}


}// namespace FW1FontWrapper

```

`src/vendor/fontwrapper/CFW1FactoryInterface.cpp`:

```cpp
// CFW1FactoryInterface.cpp

#include <vendor/fontwrapper/FW1Precompiled.h>

#include <vendor/fontwrapper/CFW1Factory.h>

#include <vendor/fontwrapper/CFW1FontWrapper.h>
#include <vendor/fontwrapper/CFW1GlyphVertexDrawer.h>
#include <vendor/fontwrapper/CFW1GlyphRenderStates.h>
#include <vendor/fontwrapper/CFW1TextRenderer.h>
#include <vendor/fontwrapper/CFW1TextGeometry.h>
#include <vendor/fontwrapper/CFW1GlyphProvider.h>
#include <vendor/fontwrapper/CFW1DWriteRenderTarget.h>
#include <vendor/fontwrapper/CFW1GlyphAtlas.h>
#include <vendor/fontwrapper/CFW1GlyphSheet.h>
#include <vendor/fontwrapper/CFW1ColorRGBA.h>


namespace FW1FontWrapper {


// Query interface
HRESULT STDMETHODCALLTYPE CFW1Factory::QueryInterface(REFIID riid, void **ppvObject) {
	if(ppvObject == NULL)
		return E_INVALIDARG;
	
	if(IsEqualIID(riid, __uuidof(IUnknown))) {
		*ppvObject = static_cast<IUnknown*>(this);
		AddRef();
		return S_OK;
	}
	else if(IsEqualIID(riid, __uuidof(IFW1Factory))) {
		*ppvObject = static_cast<IFW1Factory*>(this);
		AddRef();
		return S_OK;
	}
	
	*ppvObject = NULL;
	return E_NOINTERFACE;
}


// Add reference
ULONG STDMETHODCALLTYPE CFW1Factory::AddRef() {
	return static_cast<ULONG>(InterlockedIncrement(reinterpret_cast<LONG*>(&m_cRefCount)));
}


// Release
ULONG STDMETHODCALLTYPE CFW1Factory::Release() {
	ULONG newCount = static_cast<ULONG>(InterlockedDecrement(reinterpret_cast<LONG*>(&m_cRefCount)));
	
	if(newCount == 0)
		delete this;
	
	return newCount;
}


// Create font wrapper with default settings
HRESULT STDMETHODCALLTYPE CFW1Factory::CreateFontWrapper(
	ID3D11Device *pDevice,
	LPCWSTR pszFontFamily,
	IFW1FontWrapper **ppFontWrapper
) {
	FW1_FONTWRAPPERCREATEPARAMS createParams;
	ZeroMemory(&createParams, sizeof(createParams));
	
	createParams.GlyphSheetWidth = 512;
	createParams.GlyphSheetHeight = 512;
	createParams.MaxGlyphCountPerSheet = 2048;
	createParams.SheetMipLevels = 1;
	createParams.AnisotropicFiltering = FALSE;
	createParams.MaxGlyphWidth = 384;
	createParams.MaxGlyphHeight = 384;
	createParams.DisableGeometryShader = FALSE;
	createParams.VertexBufferSize = 0;
	createParams.DefaultFontParams.pszFontFamily = pszFontFamily;
	createParams.DefaultFontParams.FontWeight = DWRITE_FONT_WEIGHT_NORMAL;
	createParams.DefaultFontParams.FontStyle = DWRITE_FONT_STYLE_NORMAL;
	createParams.DefaultFontParams.FontStretch = DWRITE_FONT_STRETCH_NORMAL;
	createParams.DefaultFontParams.pszLocale = L"";
	
	return CreateFontWrapper(pDevice, NULL, &createParams, ppFontWrapper);
}


// Create font wrapper
HRESULT STDMETHODCALLTYPE CFW1Factory::CreateFontWrapper(
	ID3D11Device *pDevice,
	IDWriteFactory *pDWriteFactory,
	const FW1_FONTWRAPPERCREATEPARAMS *pCreateParams,
	IFW1FontWrapper **ppFontWrapper
) {
	if(pCreateParams == NULL || ppFontWrapper == NULL)
		return E_INVALIDARG;
	
	HRESULT hResult;
	
	// If no DWrite factory is provided, attempt to create one
	if(pDWriteFactory == NULL)
		hResult = createDWriteFactory(&pDWriteFactory);
	else {
		pDWriteFactory->AddRef();
		hResult = S_OK;
	}
	if(FAILED(hResult)) {
	}
	else {
		// Get system font collection
		IDWriteFontCollection *pFontCollection;
		
		hResult = pDWriteFactory->GetSystemFontCollection(&pFontCollection, FALSE);
		if(FAILED(hResult)) {
			setErrorString(L"GetSystemFontCollection failed");
		}
		else {
			// Create glyph atlas
			IFW1GlyphAtlas *pGlyphAtlas;
			
			hResult = CreateGlyphAtlas(
				pDevice,
				pCreateParams->GlyphSheetWidth,
				pCreateParams->GlyphSheetHeight,
				(pCreateParams->DisableGeometryShader == FALSE) ? TRUE : FALSE,
				TRUE,
				pCreateParams->MaxGlyphCountPerSheet,
				pCreateParams->SheetMipLevels,
				4096,
				&pGlyphAtlas
			);
			if(FAILED(hResult)) {
			}
			else {
				// Create glyph provider
				IFW1GlyphProvider *pGlyphProvider;
				
				hResult = CreateGlyphProvider(
					pGlyphAtlas,
					pDWriteFactory,
					pFontCollection,
					pCreateParams->MaxGlyphWidth,
					pCreateParams->MaxGlyphHeight,
					&pGlyphProvider
				);
				if(FAILED(hResult)) {
				}
				else {
					// Create glyph vertex drawer
					IFW1GlyphVertexDrawer *pGlyphVertexDrawer;
					
					hResult = CreateGlyphVertexDrawer(
						pDevice,
						pCreateParams->VertexBufferSize,
						&pGlyphVertexDrawer
					);
					if(FAILED(hResult)) {
					}
					else {
						// Create glyph render states
						IFW1GlyphRenderStates *pGlyphRenderStates;
						
						hResult = CreateGlyphRenderStates(
							pDevice,
							pCreateParams->DisableGeometryShader,
							pCreateParams->AnisotropicFiltering,
							&pGlyphRenderStates
						);
						if(FAILED(hResult)) {
						}
						else {
							// Create font wrapper
							IFW1FontWrapper *pFontWrapper;
							
							hResult = CreateFontWrapper(
								pDevice,
								pGlyphAtlas,
								pGlyphProvider,
								pGlyphVertexDrawer,
								pGlyphRenderStates,
								pDWriteFactory,
								&pCreateParams->DefaultFontParams,
								&pFontWrapper
							);
							if(FAILED(hResult)) {
							}
							else {
								// Success
								*ppFontWrapper = pFontWrapper;
								
								hResult = S_OK;
							}
							
							pGlyphRenderStates->Release();
						}
						
						pGlyphVertexDrawer->Release();
					}
					
					pGlyphProvider->Release();
				}
				
				pGlyphAtlas->Release();
			}
			
			pFontCollection->Release();
		}
		
		pDWriteFactory->Release();
	}
	
	return hResult;
}


// Create font wrapper
HRESULT STDMETHODCALLTYPE CFW1Factory::CreateFontWrapper(
	ID3D11Device *pDevice,
	IFW1GlyphAtlas *pGlyphAtlas,
	IFW1GlyphProvider *pGlyphProvider,
	IFW1GlyphVertexDrawer *pGlyphVertexDrawer,
	IFW1GlyphRenderStates *pGlyphRenderStates,
	IDWriteFactory *pDWriteFactory,
	const FW1_DWRITEFONTPARAMS *pDefaultFontParams,
	IFW1FontWrapper **ppFontWrapper
) {
	if(ppFontWrapper == NULL)
		return E_INVALIDARG;
	
	CFW1FontWrapper *pFontWrapper = new CFW1FontWrapper;
	HRESULT hResult = pFontWrapper->initFontWrapper(
		this,
		pDevice,
		pGlyphAtlas,
		pGlyphProvider,
		pGlyphVertexDrawer,
		pGlyphRenderStates,
		pDWriteFactory,
		pDefaultFontParams
	);
	if(FAILED(hResult)) {
		pFontWrapper->Release();
		setErrorString(L"initFontWrapper failed");
	}
	else {
		*ppFontWrapper = pFontWrapper;
		
		hResult = S_OK;
	}
	
	return hResult;
}


// Create glyph vertex drawer
HRESULT STDMETHODCALLTYPE CFW1Factory::CreateGlyphVertexDrawer(
	ID3D11Device *pDevice,
	UINT VertexBufferSize,
	IFW1GlyphVertexDrawer **ppGlyphVertexDrawer
) {
	if(ppGlyphVertexDrawer == NULL)
		return E_INVALIDARG;
	
	CFW1GlyphVertexDrawer *pGlyphVertexDrawer = new CFW1GlyphVertexDrawer;
	HRESULT hResult = pGlyphVertexDrawer->initVertexDrawer(
		this,
		pDevice,
		VertexBufferSize
	);
	if(FAILED(hResult)) {
		pGlyphVertexDrawer->Release();
		setErrorString(L"initVertexDrawer failed");
	}
	else {
		*ppGlyphVertexDrawer = pGlyphVertexDrawer;
		
		hResult = S_OK;
	}
	
	return hResult;
}


// Create glyph render states
HRESULT STDMETHODCALLTYPE CFW1Factory::CreateGlyphRenderStates(
	ID3D11Device *pDevice,
	BOOL DisableGeometryShader,
	BOOL AnisotropicFiltering,
	IFW1GlyphRenderStates **ppGlyphRenderStates
) {
	if(ppGlyphRenderStates == NULL)
		return E_INVALIDARG;
	
	CFW1GlyphRenderStates *pGlyphRenderStates = new CFW1GlyphRenderStates;
	HRESULT hResult = pGlyphRenderStates->initRenderResources(
		this,
		pDevice,
		(DisableGeometryShader == FALSE),
		(AnisotropicFiltering != FALSE)
	);
	if(FAILED(hResult)) {
		pGlyphRenderStates->Release();
		setErrorString(L"initRenderResources failed");
	}
	else {
		*ppGlyphRenderStates = pGlyphRenderStates;
		
		hResult = S_OK;
	}
	
	return hResult;
}


// Create DWrite text renderer
HRESULT STDMETHODCALLTYPE CFW1Factory::CreateTextRenderer(
	IFW1GlyphProvider *pGlyphProvider,
	IFW1TextRenderer **ppTextRenderer
) {
	if(ppTextRenderer == NULL)
		return E_INVALIDARG;
	
	CFW1TextRenderer *pTextRenderer = new CFW1TextRenderer;
	HRESULT hResult = pTextRenderer->initTextRenderer(this, pGlyphProvider);
	if(FAILED(hResult)) {
		pTextRenderer->Release();
		setErrorString(L"initTextRenderer failed");
	}
	else {
		*ppTextRenderer = pTextRenderer;
		
		hResult = S_OK;
	}
	
	return hResult;
}


// Create text geometry
HRESULT STDMETHODCALLTYPE CFW1Factory::CreateTextGeometry(
	IFW1TextGeometry **ppTextGeometry
) {
	if(ppTextGeometry == NULL)
		return E_INVALIDARG;
	
	CFW1TextGeometry *pTextGeometry = new CFW1TextGeometry;
	HRESULT hResult = pTextGeometry->initTextGeometry(this);
	if(FAILED(hResult)) {
		pTextGeometry->Release();
		setErrorString(L"initTextGeometry failed");
	}
	else {
		*ppTextGeometry = pTextGeometry;
		
		hResult = S_OK;
	}
	
	return hResult;
}


// Create glyph provider
HRESULT STDMETHODCALLTYPE CFW1Factory::CreateGlyphProvider(
	IFW1GlyphAtlas *pGlyphAtlas,
	IDWriteFactory *pDWriteFactory,
	IDWriteFontCollection *pFontCollection,
	UINT MaxGlyphWidth,
	UINT MaxGlyphHeight,
	IFW1GlyphProvider **ppGlyphProvider
) {
	if(ppGlyphProvider == NULL)
		return E_INVALIDARG;
	
	CFW1GlyphProvider *pGlyphProvider = new CFW1GlyphProvider;
	HRESULT hResult = pGlyphProvider->initGlyphProvider(
		this,
		pGlyphAtlas,
		pDWriteFactory,
		pFontCollection,
		MaxGlyphWidth,
		MaxGlyphHeight
	);
	if(FAILED(hResult)) {
		pGlyphProvider->Release();
		setErrorString(L"initGlyphProvider failed");
	}
	else {
		*ppGlyphProvider = pGlyphProvider;
		
		hResult = S_OK;
	}
	
	return hResult;
}


// Create DWrite render target
HRESULT STDMETHODCALLTYPE CFW1Factory::CreateDWriteRenderTarget(
	IDWriteFactory *pDWriteFactory,
	UINT RenderTargetWidth,
	UINT RenderTargetHeight,
	IFW1DWriteRenderTarget **ppRenderTarget
) {
	if(ppRenderTarget == NULL)
		return E_INVALIDARG;
	
	CFW1DWriteRenderTarget *pRenderTarget = new CFW1DWriteRenderTarget;
	HRESULT hResult = pRenderTarget->initRenderTarget(this, pDWriteFactory, RenderTargetWidth, RenderTargetHeight);
	if(FAILED(hResult)) {
		pRenderTarget->Release();
		setErrorString(L"initRenderTarget failed");
	}
	else {
		*ppRenderTarget = pRenderTarget;
		
		hResult = S_OK;
	}
	
	return hResult;
}


// Create glyph atlas
HRESULT STDMETHODCALLTYPE CFW1Factory::CreateGlyphAtlas(
	ID3D11Device *pDevice,
	UINT GlyphSheetWidth,
	UINT GlyphSheetHeight,
	BOOL HardwareCoordBuffer,
	BOOL AllowOversizedGlyph,
	UINT MaxGlyphCountPerSheet,
	UINT MipLevels,
	UINT MaxGlyphSheetCount,
	IFW1GlyphAtlas **ppGlyphAtlas
) {
	if(ppGlyphAtlas == NULL)
		return E_INVALIDARG;
	
	CFW1GlyphAtlas *pGlyphAtlas = new CFW1GlyphAtlas;
	HRESULT hResult = pGlyphAtlas->initGlyphAtlas(
		this,
		pDevice,
		GlyphSheetWidth,
		GlyphSheetHeight,
		(HardwareCoordBuffer != FALSE),
		(AllowOversizedGlyph != FALSE),
		MaxGlyphCountPerSheet,
		MipLevels,
		MaxGlyphSheetCount
	);
	if(FAILED(hResult)) {
		pGlyphAtlas->Release();
		setErrorString(L"initGlyphAtlas failed");
	}
	else {
		*ppGlyphAtlas = pGlyphAtlas;
		
		hResult = S_OK;
	}
	
	return hResult;
}


// Create glyph sheet
HRESULT STDMETHODCALLTYPE CFW1Factory::CreateGlyphSheet(
	ID3D11Device *pDevice,
	UINT GlyphSheetWidth,
	UINT GlyphSheetHeight,
	BOOL HardwareCoordBuffer,
	BOOL AllowOversizedGlyph,
	UINT MaxGlyphCount,
	UINT MipLevels,
	IFW1GlyphSheet **ppGlyphSheet
) {
	if(ppGlyphSheet == NULL)
		return E_INVALIDARG;
	
	CFW1GlyphSheet *pGlyphSheet = new CFW1GlyphSheet;
	HRESULT hResult = pGlyphSheet->initGlyphSheet(
		this,
		pDevice,
		GlyphSheetWidth,
		GlyphSheetHeight,
		(HardwareCoordBuffer != FALSE),
		(AllowOversizedGlyph != FALSE),
		MaxGlyphCount,
		MipLevels
	);
	if(FAILED(hResult)) {
		pGlyphSheet->Release();
		setErrorString(L"initGlyphSheet failed");
	}
	else {
		*ppGlyphSheet = pGlyphSheet;
		
		hResult = S_OK;
	}
	
	return hResult;
}


// Create color
HRESULT STDMETHODCALLTYPE CFW1Factory::CreateColor(UINT32 Color, IFW1ColorRGBA **ppColor) {
	if(ppColor == NULL)
		return E_INVALIDARG;
	
	CFW1ColorRGBA *pColor = new CFW1ColorRGBA;
	HRESULT hResult = pColor->initColor(this, Color);
	if(FAILED(hResult)) {
		pColor->Release();
		setErrorString(L"initColor failed");
	}
	else {
		*ppColor = pColor;
		
		hResult = S_OK;
	}
	
	return hResult;
}


}// namespace FW1FontWrapper

```

`src/vendor/fontwrapper/CFW1FontWrapper.cpp`:

```cpp
// CFW1FontWrapper.cpp

#include <vendor/fontwrapper/FW1Precompiled.h>

#include <vendor/fontwrapper/CFW1FontWrapper.h>

#define SAFE_RELEASE(pObject) { if(pObject) { (pObject)->Release(); (pObject) = NULL; } }


namespace FW1FontWrapper {


// Construct
CFW1FontWrapper::CFW1FontWrapper() :
	m_pDevice(NULL),
	m_featureLevel(D3D_FEATURE_LEVEL_9_1),
	m_pDWriteFactory(NULL),
	
	m_pGlyphAtlas(NULL),
	m_pGlyphProvider(NULL),
	
	m_pGlyphRenderStates(NULL),
	m_pGlyphVertexDrawer(NULL),
	
	m_defaultTextInited(false),
	m_pDefaultTextFormat(NULL)
{
	InitializeCriticalSection(&m_textRenderersCriticalSection);
	InitializeCriticalSection(&m_textGeometriesCriticalSection);
}


// Destruct
CFW1FontWrapper::~CFW1FontWrapper() {
	SAFE_RELEASE(m_pFW1Factory);
	
	SAFE_RELEASE(m_pDevice);
	SAFE_RELEASE(m_pDWriteFactory);
	
	SAFE_RELEASE(m_pGlyphAtlas);
	SAFE_RELEASE(m_pGlyphProvider);
	
	SAFE_RELEASE(m_pGlyphRenderStates);
	SAFE_RELEASE(m_pGlyphVertexDrawer);
	
	while(!m_textRenderers.empty()) {
		m_textRenderers.top()->Release();
		m_textRenderers.pop();
	}
	
	while(!m_textGeometries.empty()) {
		m_textGeometries.top()->Release();
		m_textGeometries.pop();
	}
	
	SAFE_RELEASE(m_pDefaultTextFormat);
	
	DeleteCriticalSection(&m_textRenderersCriticalSection);
	DeleteCriticalSection(&m_textGeometriesCriticalSection);
}


// Init
HRESULT CFW1FontWrapper::initFontWrapper(
	IFW1Factory *pFW1Factory,
	ID3D11Device *pDevice,
	IFW1GlyphAtlas *pGlyphAtlas,
	IFW1GlyphProvider *pGlyphProvider,
	IFW1GlyphVertexDrawer *pGlyphVertexDrawer,
	IFW1GlyphRenderStates *pGlyphRenderStates,
	IDWriteFactory *pDWriteFactory,
	const FW1_DWRITEFONTPARAMS *pDefaultFontParams
) {
	HRESULT hResult = initBaseObject(pFW1Factory);
	if(FAILED(hResult))
		return hResult;
	
	if(
		pDevice == NULL ||
		pGlyphAtlas == NULL ||
		pGlyphProvider == NULL ||
		pGlyphVertexDrawer == NULL ||
		pGlyphRenderStates == NULL ||
		pDWriteFactory == NULL
	)
		return E_INVALIDARG;
	
	pDevice->AddRef();
	m_pDevice = pDevice;
	m_featureLevel = m_pDevice->GetFeatureLevel();
	
	pDWriteFactory->AddRef();
	m_pDWriteFactory = pDWriteFactory;
	
	pGlyphAtlas->AddRef();
	m_pGlyphAtlas = pGlyphAtlas;
	pGlyphProvider->AddRef();
	m_pGlyphProvider = pGlyphProvider;
	
	pGlyphRenderStates->AddRef();
	m_pGlyphRenderStates = pGlyphRenderStates;
	pGlyphVertexDrawer->AddRef();
	m_pGlyphVertexDrawer = pGlyphVertexDrawer;
	
	// Create default text format for strings, if provided
	if(pDefaultFontParams->pszFontFamily != NULL && pDefaultFontParams->pszFontFamily[0] != 0) {
		IDWriteTextFormat *pTextFormat;
		hResult = m_pDWriteFactory->CreateTextFormat(
			pDefaultFontParams->pszFontFamily,
			NULL,
			pDefaultFontParams->FontWeight,
			pDefaultFontParams->FontStyle,
			pDefaultFontParams->FontStretch,
			32.0f,
			(pDefaultFontParams->pszLocale != NULL) ? pDefaultFontParams->pszLocale : L"",
			&pTextFormat
		);
		if(FAILED(hResult)) {
			m_lastError = L"Failed to create DWrite text format";
		}
		else {
			m_pDefaultTextFormat = pTextFormat;
			m_defaultTextInited = true;
			
			hResult = S_OK;
		}
	}
	
	return hResult;
}


// Create text layout from string
IDWriteTextLayout* CFW1FontWrapper::createTextLayout(
	const WCHAR *pszString,
	const WCHAR *pszFontFamily,
	FLOAT fontSize,
	const FW1_RECTF *pLayoutRect,
	UINT flags
) {
	if(m_defaultTextInited) {
		UINT32 stringLength = 0;
		while(pszString[stringLength] != 0)
			++stringLength;
		
		// Create DWrite text layout for the string
		IDWriteTextLayout *pTextLayout;
		HRESULT hResult = m_pDWriteFactory->CreateTextLayout(
			pszString,
			stringLength,
			m_pDefaultTextFormat,
			pLayoutRect->Right - pLayoutRect->Left,
			pLayoutRect->Bottom - pLayoutRect->Top,
			&pTextLayout
		);
		if(SUCCEEDED(hResult)) {
			// Layout settings
			DWRITE_TEXT_RANGE allText = {0, stringLength};
			pTextLayout->SetFontSize(fontSize, allText);
			
			if(pszFontFamily != NULL)
				pTextLayout->SetFontFamilyName(pszFontFamily, allText);
			
			if((flags & FW1_NOWORDWRAP) != 0)
				pTextLayout->SetWordWrapping(DWRITE_WORD_WRAPPING_NO_WRAP);
			
			if(flags & FW1_RIGHT)
				pTextLayout->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_TRAILING);
			else if(flags & FW1_CENTER)
				pTextLayout->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
			if(flags & FW1_BOTTOM)
				pTextLayout->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_FAR);
			else if(flags & FW1_VCENTER)
				pTextLayout->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
			
			return pTextLayout;
		}
	}
	
	return NULL;
}


}// namespace FW1FontWrapper

```

`src/vendor/fontwrapper/CFW1FontWrapperInterface.cpp`:

```cpp
// CFW1FontWrapperInterface.cpp

#include <vendor/fontwrapper/FW1Precompiled.h>
#include <vendor/fontwrapper/CFW1FontWrapper.h>
#include <vendor/fontwrapper/CFW1StateSaver.h>


namespace FW1FontWrapper {


// Query interface
HRESULT STDMETHODCALLTYPE CFW1FontWrapper::QueryInterface(REFIID riid, void **ppvObject) {
	if(ppvObject == NULL)
		return E_INVALIDARG;
	
	if(IsEqualIID(riid, __uuidof(IFW1FontWrapper))) {
		*ppvObject = static_cast<IFW1FontWrapper*>(this);
		AddRef();
		return S_OK;
	}
	
	return CFW1Object::QueryInterface(riid, ppvObject);
}


// Get the factory that created this object
HRESULT STDMETHODCALLTYPE CFW1FontWrapper::GetFactory(IFW1Factory **ppFactory) {
	if(ppFactory == NULL)
		return E_INVALIDARG;
	
	m_pFW1Factory->AddRef();
	*ppFactory = m_pFW1Factory;
	
	return S_OK;
}


// Get D3D11 device
HRESULT STDMETHODCALLTYPE CFW1FontWrapper::GetDevice(ID3D11Device **ppDevice) {
	if(ppDevice == NULL)
		return E_INVALIDARG;
	
	m_pDevice->AddRef();
	*ppDevice = m_pDevice;
	
	return S_OK;
}


// Get DWrite factory
HRESULT STDMETHODCALLTYPE CFW1FontWrapper::GetDWriteFactory(IDWriteFactory **ppDWriteFactory) {
	if(ppDWriteFactory == NULL)
		return E_INVALIDARG;
	
	m_pDWriteFactory->AddRef();
	*ppDWriteFactory = m_pDWriteFactory;
	
	return S_OK;
}


// Get glyph atlas
HRESULT STDMETHODCALLTYPE CFW1FontWrapper::GetGlyphAtlas(IFW1GlyphAtlas **ppGlyphAtlas) {
	if(ppGlyphAtlas == NULL)
		return E_INVALIDARG;
	
	m_pGlyphAtlas->AddRef();
	*ppGlyphAtlas = m_pGlyphAtlas;
	
	return S_OK;
}


// Get glyph provider
HRESULT STDMETHODCALLTYPE CFW1FontWrapper::GetGlyphProvider(IFW1GlyphProvider **ppGlyphProvider) {
	if(ppGlyphProvider == NULL)
		return E_INVALIDARG;
	
	m_pGlyphProvider->AddRef();
	*ppGlyphProvider = m_pGlyphProvider;
	
	return S_OK;
}


// Get render states
HRESULT STDMETHODCALLTYPE CFW1FontWrapper::GetRenderStates(IFW1GlyphRenderStates **ppRenderStates) {
	if(ppRenderStates == NULL)
		return E_INVALIDARG;
	
	m_pGlyphRenderStates->AddRef();
	*ppRenderStates = m_pGlyphRenderStates;
	
	return S_OK;
}


// Get vertex drawer
HRESULT STDMETHODCALLTYPE CFW1FontWrapper::GetVertexDrawer(IFW1GlyphVertexDrawer **ppVertexDrawer) {
	if(ppVertexDrawer == NULL)
		return E_INVALIDARG;
	
	m_pGlyphVertexDrawer->AddRef();
	*ppVertexDrawer = m_pGlyphVertexDrawer;
	
	return S_OK;
}


// Draw text layout
void STDMETHODCALLTYPE CFW1FontWrapper::DrawTextLayout(
	ID3D11DeviceContext *pContext,
	IDWriteTextLayout *pTextLayout,
	FLOAT OriginX,
	FLOAT OriginY,
	UINT32 Color,
	UINT Flags
) {
	DrawTextLayout(pContext, pTextLayout, OriginX, OriginY, Color, NULL, NULL, Flags);
}


// Draw text layout
void STDMETHODCALLTYPE CFW1FontWrapper::DrawTextLayout(
	ID3D11DeviceContext *pContext,
	IDWriteTextLayout *pTextLayout,
	FLOAT OriginX,
	FLOAT OriginY,
	UINT32 Color,
	const FW1_RECTF *pClipRect,
	const FLOAT *pTransformMatrix,
	UINT Flags
) {
	IFW1TextGeometry *pTextGeometry = NULL;
	
	// If needed, get a text geometry to store vertices in
	if((Flags & FW1_ANALYZEONLY) == 0 && (Flags & FW1_CACHEONLY) == 0) {
		EnterCriticalSection(&m_textGeometriesCriticalSection);
		if(!m_textGeometries.empty()) {
			pTextGeometry = m_textGeometries.top();
			m_textGeometries.pop();
		}
		LeaveCriticalSection(&m_textGeometriesCriticalSection);
		
		if(pTextGeometry == NULL) {
			IFW1TextGeometry *pNewTextGeometry;
			HRESULT hResult = m_pFW1Factory->CreateTextGeometry(&pNewTextGeometry);
			if(FAILED(hResult)) {
			}
			else {
				pTextGeometry = pNewTextGeometry;
			}
		}
		
		if(pTextGeometry != NULL)
			pTextGeometry->Clear();
	}
	
	// Draw
	AnalyzeTextLayout(pContext, pTextLayout, OriginX, OriginY, Color, Flags, pTextGeometry);
	if((Flags & FW1_ANALYZEONLY) == 0 && (Flags & FW1_CACHEONLY) == 0) {
		DrawGeometry(pContext, pTextGeometry, pClipRect, pTransformMatrix, Flags);
	}
	
	if(pTextGeometry != NULL) {
		// Keep the text geometry for future use
		EnterCriticalSection(&m_textGeometriesCriticalSection);
		m_textGeometries.push(pTextGeometry);
		LeaveCriticalSection(&m_textGeometriesCriticalSection);
	}
}


// Draw text
void STDMETHODCALLTYPE CFW1FontWrapper::DrawString(
	ID3D11DeviceContext *pContext,
	const WCHAR *pszString,
	FLOAT FontSize,
	FLOAT X,
	FLOAT Y,
	UINT32 Color,
	UINT Flags
) {
	FW1_RECTF rect;
	
	rect.Left = rect.Right = X;
	rect.Top = rect.Bottom = Y;
	
	DrawString(pContext, pszString, NULL, FontSize, &rect, Color, NULL, NULL, Flags | FW1_NOWORDWRAP);
}


// Draw text
void STDMETHODCALLTYPE CFW1FontWrapper::DrawString(
	ID3D11DeviceContext *pContext,
	const WCHAR *pszString,
	const WCHAR *pszFontFamily,
	FLOAT FontSize,
	FLOAT X,
	FLOAT Y,
	UINT32 Color,
	UINT Flags
) {
	FW1_RECTF rect;
	
	rect.Left = rect.Right = X;
	rect.Top = rect.Bottom = Y;
	
	DrawString(pContext, pszString, pszFontFamily, FontSize, &rect, Color, NULL, NULL, Flags | FW1_NOWORDWRAP);
}


// Draw text
void STDMETHODCALLTYPE CFW1FontWrapper::DrawString(
	ID3D11DeviceContext *pContext,
	const WCHAR *pszString,
	const WCHAR *pszFontFamily,
	FLOAT FontSize,
	const FW1_RECTF *pLayoutRect,
	UINT32 Color,
	const FW1_RECTF *pClipRect,
	const FLOAT *pTransformMatrix,
	UINT Flags
) {
	IDWriteTextLayout *pTextLayout = createTextLayout(pszString, pszFontFamily, FontSize, pLayoutRect, Flags);
	if(pTextLayout != NULL) {
		// Draw
		DrawTextLayout(
			pContext,
			pTextLayout,
			pLayoutRect->Left,
			pLayoutRect->Top,
			Color,
			pClipRect,
			pTransformMatrix,
			Flags
		);
		
		pTextLayout->Release();
	}
}


// Measure text
FW1_RECTF STDMETHODCALLTYPE CFW1FontWrapper::MeasureString(
	const WCHAR *pszString,
	const WCHAR *pszFontFamily,
	FLOAT FontSize,
	const FW1_RECTF *pLayoutRect,
	UINT Flags
) {
	FW1_RECTF stringRect = {pLayoutRect->Left, pLayoutRect->Top, pLayoutRect->Left, pLayoutRect->Top};
	
	IDWriteTextLayout *pTextLayout = createTextLayout(pszString, pszFontFamily, FontSize, pLayoutRect, Flags);
	if(pTextLayout != NULL) {
		// Get measurements
		DWRITE_OVERHANG_METRICS overhangMetrics;
		HRESULT hResult = pTextLayout->GetOverhangMetrics(&overhangMetrics);
		if(SUCCEEDED(hResult)) {
			stringRect.Left = floor(pLayoutRect->Left - overhangMetrics.left);
			stringRect.Top = floor(pLayoutRect->Top - overhangMetrics.top);
			stringRect.Right = ceil(pLayoutRect->Left + overhangMetrics.right);
			stringRect.Bottom = ceil(pLayoutRect->Top + overhangMetrics.bottom);
		}
		
		pTextLayout->Release();
	}
	
	return stringRect;
}


// Create geometry from a string
void STDMETHODCALLTYPE CFW1FontWrapper::AnalyzeString(
	ID3D11DeviceContext *pContext,
	const WCHAR *pszString,
	const WCHAR *pszFontFamily,
	FLOAT FontSize,
	const FW1_RECTF *pLayoutRect,
	UINT32 Color,
	UINT Flags,
	IFW1TextGeometry *pTextGeometry
) {
	IDWriteTextLayout *pTextLayout = createTextLayout(pszString, pszFontFamily, FontSize, pLayoutRect, Flags);
	if(pTextLayout != NULL) {
		AnalyzeTextLayout(
			pContext,
			pTextLayout,
			pLayoutRect->Left,
			pLayoutRect->Top,
			Color,
			Flags,
			pTextGeometry
		);
		
		pTextLayout->Release();
	}
}


// Create geometry from a text layout
void STDMETHODCALLTYPE CFW1FontWrapper::AnalyzeTextLayout(
	ID3D11DeviceContext *pContext,
	IDWriteTextLayout *pTextLayout,
	FLOAT OriginX,
	FLOAT OriginY,
	UINT32 Color,
	UINT Flags,
	IFW1TextGeometry *pTextGeometry
) {
	// Get a text renderer
	IFW1TextRenderer *pTextRenderer = NULL;
	
	EnterCriticalSection(&m_textRenderersCriticalSection);
	if(!m_textRenderers.empty()) {
		pTextRenderer = m_textRenderers.top();
		m_textRenderers.pop();
	}
	LeaveCriticalSection(&m_textRenderersCriticalSection);
	
	if(pTextRenderer == NULL) {
		IFW1TextRenderer *pNewTextRenderer;
		HRESULT hResult = m_pFW1Factory->CreateTextRenderer(m_pGlyphProvider, &pNewTextRenderer);
		if(FAILED(hResult)) {
		}
		else {
			pTextRenderer = pNewTextRenderer;
		}
	}
	
	// Create geometry
	if(pTextRenderer != NULL) {
		HRESULT hResult = pTextRenderer->DrawTextLayout(pTextLayout, OriginX, OriginY, Color, Flags, pTextGeometry);
		if(FAILED(hResult)) {
		}
		
		// Flush the glyph atlas in case any new glyphs were added
		if((Flags & FW1_NOFLUSH) == 0)
			m_pGlyphAtlas->Flush(pContext);
		
		// Keep the text renderer for future use
		EnterCriticalSection(&m_textRenderersCriticalSection);
		m_textRenderers.push(pTextRenderer);
		LeaveCriticalSection(&m_textRenderersCriticalSection);
	}
}


// Draw vertices
void STDMETHODCALLTYPE CFW1FontWrapper::DrawGeometry(
	ID3D11DeviceContext *pContext,
	IFW1TextGeometry *pGeometry,
	const FW1_RECTF *pClipRect,
	const FLOAT *pTransformMatrix,
	UINT Flags
) {
	FW1_VERTEXDATA vertexData = pGeometry->GetGlyphVerticesTemp();
	if(vertexData.TotalVertexCount > 0 || (Flags & FW1_RESTORESTATE) == 0) {
		if(m_featureLevel < D3D_FEATURE_LEVEL_10_0 || m_pGlyphRenderStates->HasGeometryShader() == FALSE)
			Flags |= FW1_NOGEOMETRYSHADER;
		
		// Save state
		CFW1StateSaver stateSaver;
		bool restoreState = false;
		if((Flags & FW1_RESTORESTATE) != 0) {
			if(SUCCEEDED(stateSaver.saveCurrentState(pContext)))
				restoreState = true;
		}
		
		// Set shaders etc.
		if((Flags & FW1_STATEPREPARED) == 0)
			m_pGlyphRenderStates->SetStates(pContext, Flags);
		if((Flags & FW1_CONSTANTSPREPARED) == 0)
			m_pGlyphRenderStates->UpdateShaderConstants(pContext, pClipRect, pTransformMatrix);
		
		// Draw glyphs
		UINT temp = m_pGlyphVertexDrawer->DrawVertices(pContext, m_pGlyphAtlas, &vertexData, Flags, 0xffffffff);
		temp;
		
		// Restore state
		if(restoreState)
			stateSaver.restoreSavedState();
	}
}


// Flush the glyph atlas
void STDMETHODCALLTYPE CFW1FontWrapper::Flush(ID3D11DeviceContext *pContext) {
	m_pGlyphAtlas->Flush(pContext);
}


}// namespace FW1FontWrapper

```

`src/vendor/fontwrapper/CFW1GlyphAtlas.cpp`:

```cpp
// CFW1GlyphAtlas.cpp

#include <vendor/fontwrapper/FW1Precompiled.h>

#include <vendor/fontwrapper/CFW1GlyphAtlas.h>

#define SAFE_RELEASE(pObject) { if(pObject) { (pObject)->Release(); (pObject) = NULL; } }


namespace FW1FontWrapper {


// Construct
CFW1GlyphAtlas::CFW1GlyphAtlas() :
	m_pDevice(NULL),
	m_sheetWidth(0),
	m_sheetHeight(0),
	m_hardwareCoordBuffer(false),
	m_allowOversizedGlyph(false),
	m_maxGlyphCount(0),
	m_mipLevelCount(0),
	
	m_glyphSheets(0),
	m_sheetCount(0),
	m_maxSheetCount(0),
	m_currentSheetIndex(0),
	m_flushedSheetIndex(0)
{
	InitializeCriticalSection(&m_glyphSheetsCriticalSection);
}


// Destruct
CFW1GlyphAtlas::~CFW1GlyphAtlas() {
	SAFE_RELEASE(m_pDevice);
	
	for(UINT i=0; i < m_sheetCount; ++i)
		m_glyphSheets[i]->Release();
	delete[] m_glyphSheets;
	
	DeleteCriticalSection(&m_glyphSheetsCriticalSection);
}


// Init
HRESULT CFW1GlyphAtlas::initGlyphAtlas(
	IFW1Factory *pFW1Factory,
	ID3D11Device *pDevice,
	UINT sheetWidth,
	UINT sheetHeight,
	bool coordBuffer,
	bool allowOversizedGlyph,
	UINT maxGlyphCount,
	UINT mipLevelCount,
	UINT maxSheetCount
) {
	HRESULT hResult = initBaseObject(pFW1Factory);
	if(FAILED(hResult))
		return hResult;
	
	if(pDevice == NULL)
		return E_INVALIDARG;
	
	pDevice->AddRef();
	m_pDevice = pDevice;
	
	m_sheetWidth = sheetWidth;
	m_sheetHeight = sheetHeight;
	m_hardwareCoordBuffer = coordBuffer;
	m_allowOversizedGlyph = allowOversizedGlyph;
	m_mipLevelCount = mipLevelCount;
	m_maxGlyphCount = maxGlyphCount;
	
	m_maxSheetCount = 4096;
	if(maxSheetCount > 0 && maxSheetCount < 655536)
		m_maxSheetCount = maxSheetCount;
	m_glyphSheets = new IFW1GlyphSheet* [m_maxSheetCount];
	
	// Default glyph
	BYTE glyph0Pixels[256];
	FillMemory(glyph0Pixels, 256, 0xff);
	
	FW1_GLYPHMETRICS glyph0Metrics;
	glyph0Metrics.OffsetX = 0.0f;
	glyph0Metrics.OffsetY = 0.0f;
	glyph0Metrics.Width = 16;
	glyph0Metrics.Height = 16;
	
	UINT glyph0 = InsertGlyph(&glyph0Metrics, glyph0Pixels, 16, 1);
	if(glyph0 == 0xffffffff)
		return E_FAIL;
	else
		return S_OK;
}


// Create new glyph sheet
HRESULT CFW1GlyphAtlas::createGlyphSheet(IFW1GlyphSheet **ppGlyphSheet) {
	IFW1GlyphSheet *pGlyphSheet;
	HRESULT hResult = m_pFW1Factory->CreateGlyphSheet(
		m_pDevice,
		m_sheetWidth,
		m_sheetHeight,
		m_hardwareCoordBuffer,
		m_allowOversizedGlyph,
		m_maxGlyphCount,
		m_mipLevelCount,
		&pGlyphSheet
	);
	if(FAILED(hResult)) {
	}
	else {
		*ppGlyphSheet = pGlyphSheet;
		
		hResult = S_OK;
	}
	
	return hResult;
}


}// namespace FW1FontWrapper

```

`src/vendor/fontwrapper/CFW1GlyphAtlasInterface.cpp`:

```cpp
// CFW1GlyphAtlasInterface.cpp

#include <vendor/fontwrapper/FW1Precompiled.h>

#include <vendor/fontwrapper/CFW1GlyphAtlas.h>


namespace FW1FontWrapper {


// Query interface
HRESULT STDMETHODCALLTYPE CFW1GlyphAtlas::QueryInterface(REFIID riid, void **ppvObject) {
	if(ppvObject == NULL)
		return E_INVALIDARG;
	
	if(IsEqualIID(riid, __uuidof(IFW1GlyphAtlas))) {
		*ppvObject = static_cast<IFW1GlyphAtlas*>(this);
		AddRef();
		return S_OK;
	}
	
	return CFW1Object::QueryInterface(riid, ppvObject);
}


// Get the D3D11 device used by this atlas
HRESULT STDMETHODCALLTYPE CFW1GlyphAtlas::GetDevice(ID3D11Device **ppDevice) {
	if(ppDevice == NULL)
		return E_INVALIDARG;
	
	m_pDevice->AddRef();
	*ppDevice = m_pDevice;
	
	return S_OK;
}


// Get total glyph count in atlas
UINT STDMETHODCALLTYPE CFW1GlyphAtlas::GetTotalGlyphCount() {
	UINT total = 0;
	
	for(UINT i=0; i < m_sheetCount; ++i) {
		FW1_GLYPHSHEETDESC desc;
		m_glyphSheets[i]->GetDesc(&desc);
		
		total += desc.GlyphCount;
	}
	
	return total;
}


// Get sheet count
UINT STDMETHODCALLTYPE CFW1GlyphAtlas::GetSheetCount() {
	return m_sheetCount;
}


// Get sheet
HRESULT STDMETHODCALLTYPE CFW1GlyphAtlas::GetSheet(UINT SheetIndex, IFW1GlyphSheet **ppGlyphSheet) {
	if(ppGlyphSheet == NULL)
		return E_INVALIDARG;
	
	if(SheetIndex < m_sheetCount) {
		*ppGlyphSheet = m_glyphSheets[SheetIndex];
		
		return S_OK;
	}
	
	*ppGlyphSheet = NULL;
	
	return E_INVALIDARG;
}

// Get texture coordinates
const FW1_GLYPHCOORDS* STDMETHODCALLTYPE CFW1GlyphAtlas::GetGlyphCoords(UINT SheetIndex) {
	if(SheetIndex < m_sheetCount)
		return m_glyphSheets[SheetIndex]->GetGlyphCoords();
	
	return 0;
}


// Set sheet shader resources
HRESULT STDMETHODCALLTYPE CFW1GlyphAtlas::BindSheet(ID3D11DeviceContext *pContext, UINT SheetIndex, UINT Flags) {
	if(SheetIndex < m_sheetCount)
		return m_glyphSheets[SheetIndex]->BindSheet(pContext, Flags);
	
	return E_INVALIDARG;
}


// Insert texture into atlas
UINT STDMETHODCALLTYPE CFW1GlyphAtlas::InsertGlyph(
	const FW1_GLYPHMETRICS *pGlyphMetrics,
	const void *pGlyphData,
	UINT RowPitch,
	UINT PixelStride
) {
	UINT glyphIndex = 0xffffffff;
	UINT sheetIndex = 0;
	
	// Get open sheet range
	EnterCriticalSection(&m_glyphSheetsCriticalSection);
	UINT start = m_currentSheetIndex;
	UINT end = m_sheetCount;
	LeaveCriticalSection(&m_glyphSheetsCriticalSection);
	
	// Attempt to insert glyph
	for(UINT i=start; i < end; ++i) {
		IFW1GlyphSheet *pGlyphSheet = m_glyphSheets[i];
		
		glyphIndex = pGlyphSheet->InsertGlyph(pGlyphMetrics, pGlyphData, RowPitch, PixelStride);
		if(glyphIndex != 0xffffffff) {
			sheetIndex = i;
			break;
		}
	}
	
	// Try to create a new glyph sheet on failure
	if(glyphIndex == 0xffffffff && m_sheetCount < m_maxSheetCount) {
		IFW1GlyphSheet *pGlyphSheet;
		if(SUCCEEDED(createGlyphSheet(&pGlyphSheet))) {
			glyphIndex = pGlyphSheet->InsertGlyph(pGlyphMetrics, pGlyphData, RowPitch, PixelStride);
			
			UINT newSheetIndex = InsertSheet(pGlyphSheet);
			if(newSheetIndex != 0xffffffff)
				sheetIndex = newSheetIndex;
			else
				glyphIndex = 0xffffffff;
			
			pGlyphSheet->Release();
		}
	}
	
	if(glyphIndex == 0xffffffff)
		return 0xffffffff;
	
	return (sheetIndex << 16) | glyphIndex;
}


// Insert glyph sheets
UINT STDMETHODCALLTYPE CFW1GlyphAtlas::InsertSheet(IFW1GlyphSheet *pGlyphSheet) {
	if(pGlyphSheet == NULL)
		return 0xffffffff;
	
	UINT sheetIndex = 0xffffffff;
	
	EnterCriticalSection(&m_glyphSheetsCriticalSection);
	if(m_sheetCount < m_maxSheetCount) {
		pGlyphSheet->AddRef();
		
		sheetIndex = m_sheetCount;
		
		m_glyphSheets[sheetIndex] = pGlyphSheet;
		
		_WriteBarrier();
		MemoryBarrier();
		
		++m_sheetCount;
		
		// Restrict the number of open sheets
		UINT numActiveSheets = 4;
		
		if(m_sheetCount > m_currentSheetIndex + numActiveSheets) {
			m_glyphSheets[m_currentSheetIndex]->CloseSheet();
			
			++m_currentSheetIndex;
		}
	}
	LeaveCriticalSection(&m_glyphSheetsCriticalSection);
	
	return sheetIndex;
}


// Flush all sheets with possible new glyphs
void STDMETHODCALLTYPE CFW1GlyphAtlas::Flush(ID3D11DeviceContext *pContext) {
	UINT first = 0;
	UINT end = 0;
	
	EnterCriticalSection(&m_glyphSheetsCriticalSection);
	
	first = m_flushedSheetIndex;
	end = m_sheetCount;
	
	m_flushedSheetIndex = m_currentSheetIndex;
	
	LeaveCriticalSection(&m_glyphSheetsCriticalSection);
	
	for(UINT i=first; i < end; ++i)
		m_glyphSheets[i]->Flush(pContext);
}


}// namespace FW1FontWrapper

```

`src/vendor/fontwrapper/CFW1GlyphProvider.cpp`:

```cpp
// CFW1GlyphProvider.cpp

#include <vendor/fontwrapper/FW1Precompiled.h>

#include <vendor/fontwrapper/CFW1GlyphProvider.h>

#define SAFE_RELEASE(pObject) { if(pObject) { (pObject)->Release(); (pObject) = NULL; } }


namespace FW1FontWrapper {


// Construct
CFW1GlyphProvider::CFW1GlyphProvider() :
	m_pGlyphAtlas(NULL),
	
	m_pDWriteFactory(NULL),
	m_maxGlyphWidth(0),
	m_maxGlyphHeight(0),
	
	m_pFontCollection(NULL)
{
	InitializeCriticalSection(&m_renderTargetsCriticalSection);
	InitializeCriticalSection(&m_glyphMapsCriticalSection);
	InitializeCriticalSection(&m_fontsCriticalSection);
	InitializeCriticalSection(&m_insertGlyphCriticalSection);
}


// Destruct
CFW1GlyphProvider::~CFW1GlyphProvider() {
	SAFE_RELEASE(m_pGlyphAtlas);
	
	SAFE_RELEASE(m_pDWriteFactory);
	
	while(!m_glyphRenderTargets.empty()) {
		m_glyphRenderTargets.top()->Release();
		m_glyphRenderTargets.pop();
	}
	
	SAFE_RELEASE(m_pFontCollection);
	for(size_t i=0; i < m_fonts.size(); ++i)
		SAFE_RELEASE(m_fonts[i].pFontFace);
	
	for(FontMap::iterator it = m_fontMap.begin(); it != m_fontMap.end(); ++it) {
		GlyphMap *glyphMap = (*it).second;
		
		delete[] glyphMap->glyphs;
		delete glyphMap;
	}
	
	DeleteCriticalSection(&m_renderTargetsCriticalSection);
	DeleteCriticalSection(&m_glyphMapsCriticalSection);
	DeleteCriticalSection(&m_fontsCriticalSection);
	DeleteCriticalSection(&m_insertGlyphCriticalSection);
}


// Init glyph provider
HRESULT CFW1GlyphProvider::initGlyphProvider(
	IFW1Factory *pFW1Factory,
	IFW1GlyphAtlas *pGlyphAtlas,
	IDWriteFactory *pDWriteFactory,
	IDWriteFontCollection *pFontCollection,
	UINT maxGlyphWidth,
	UINT maxGlyphHeight
) {
	HRESULT hResult = initBaseObject(pFW1Factory);
	if(FAILED(hResult))
		return hResult;
	
	if(pGlyphAtlas == NULL || pDWriteFactory == NULL || pFontCollection == NULL)
		return E_INVALIDARG;
	
	pGlyphAtlas->AddRef();
	m_pGlyphAtlas = pGlyphAtlas;
	
	pDWriteFactory->AddRef();
	m_pDWriteFactory = pDWriteFactory;
	
	m_maxGlyphWidth = 384;
	if(maxGlyphWidth > 0 && maxGlyphWidth <= 8192)
		m_maxGlyphWidth = maxGlyphWidth;
	m_maxGlyphHeight = 384;
	if(maxGlyphHeight > 0 && maxGlyphHeight <= 8192)
		m_maxGlyphHeight = maxGlyphHeight;
	
	pFontCollection->AddRef();
	m_pFontCollection = pFontCollection;
	
	return S_OK;
}


// Get font index from DWrite font-face
UINT CFW1GlyphProvider::getFontIndexFromFontFace(IDWriteFontFace *pFontFace) {
	UINT fontIndex = 0xffffffff;
	
	EnterCriticalSection(&m_fontsCriticalSection);
	
	// Search for a matching fontface by pointer
	for(size_t i=0; i < m_fonts.size(); ++i) {
		const FontInfo &fontInfo = m_fonts[i];
		
		if(pFontFace == fontInfo.pFontFace) {
			fontIndex = static_cast<UINT>(i);
			break;
		}
	}
	
	LeaveCriticalSection(&m_fontsCriticalSection);
	
	// Get font-face name
	if(fontIndex == 0xffffffff) {
		std::wstring uniqueName = getUniqueNameFromFontFace(pFontFace);
		if(uniqueName.size() > 0) {
			IDWriteFontFace *pOldFontFace = NULL;
			
			pFontFace->AddRef();
			
			EnterCriticalSection(&m_fontsCriticalSection);
			
			// Search for a matching fontface by name
			for(size_t i=0; i < m_fonts.size(); ++i) {
				FontInfo &fontInfo = m_fonts[i];
				
				if(fontInfo.uniqueName == uniqueName) {
					pOldFontFace = fontInfo.pFontFace;
					fontInfo.pFontFace = pFontFace;
					fontIndex = static_cast<UINT>(i);
					break;
				}
			}
			
			// Add new font
			if(fontIndex == 0xffffffff) {
				FontInfo fontInfo;
				
				fontInfo.pFontFace = pFontFace;
				fontInfo.uniqueName = uniqueName;
				
				fontIndex = static_cast<UINT>(m_fonts.size());
				m_fonts.push_back(fontInfo);
			}
			
			LeaveCriticalSection(&m_fontsCriticalSection);
			
			SAFE_RELEASE(pOldFontFace);
		}
		else
			fontIndex = 0;
	}
	
	return fontIndex;
}


// Get unique name for a DWrite font-face
std::wstring CFW1GlyphProvider::getUniqueNameFromFontFace(IDWriteFontFace *pFontFace) {
	std::wstring uniqueName;
	
	IDWriteFont *pFont;
	HRESULT hResult = m_pFontCollection->GetFontFromFontFace(pFontFace, &pFont);
	if(SUCCEEDED(hResult)) {
		// Family name
		IDWriteFontFamily *pFontFamily;
		hResult = pFont->GetFontFamily(&pFontFamily);
		if(SUCCEEDED(hResult)) {
			IDWriteLocalizedStrings *pFamilyNames;
			hResult = pFontFamily->GetFamilyNames(&pFamilyNames);
			if(SUCCEEDED(hResult)) {
				UINT32 index;
				BOOL exists;
				hResult = pFamilyNames->FindLocaleName(L"en-us", &index, &exists);
				if(FAILED(hResult) || !exists)
					index = 0;
					
				if(pFamilyNames->GetCount() > index) {
					UINT32 length;
					hResult = pFamilyNames->GetStringLength(index, &length);
					if(SUCCEEDED(hResult)) {
						std::vector<WCHAR> str(length+1);
						
						hResult = pFamilyNames->GetString(index, &str[0], length+1);
						if(SUCCEEDED(hResult))
							uniqueName = &str[0];
					}
				}
				
				pFamilyNames->Release();
			}
			
			pFontFamily->Release();
		}
		
		// Face name
		IDWriteLocalizedStrings *pFaceNames;
		hResult = pFont->GetFaceNames(&pFaceNames);
		if(SUCCEEDED(hResult)) {
			UINT32 index;
			BOOL exists;
			hResult = pFaceNames->FindLocaleName(L"en-us", &index, &exists);
			if(FAILED(hResult) || !exists)
				index = 0;
					
			if(pFaceNames->GetCount() > index) {
				UINT32 length;
				hResult = pFaceNames->GetStringLength(index, &length);
				if(SUCCEEDED(hResult)) {
					std::vector<WCHAR> str(length+1);
						
					hResult = pFaceNames->GetString(index, &str[0], length+1);
					if(SUCCEEDED(hResult))
						uniqueName.append(&str[0]);
				}
			}
				
			pFaceNames->Release();
		}
		
		// Simulations
		if(uniqueName.size() > 0) {
			DWRITE_FONT_SIMULATIONS simulations = pFontFace->GetSimulations();
			if(simulations == DWRITE_FONT_SIMULATIONS_BOLD)
				uniqueName += L"SimBold";
			else if(simulations == DWRITE_FONT_SIMULATIONS_OBLIQUE)
				uniqueName += L"SimOblique";
		}
	}
	
	return uniqueName;
}


// Render and insert new glyph into a glyph-map
UINT CFW1GlyphProvider::insertNewGlyph(GlyphMap *glyphMap, UINT16 glyphIndex, IDWriteFontFace *pFontFace) {
	UINT glyphAtlasId = 0xffffffff;
	
	// Get a render target
	IFW1DWriteRenderTarget *pRenderTarget = NULL;
	
	EnterCriticalSection(&m_renderTargetsCriticalSection);
	
	if(!m_glyphRenderTargets.empty()) {
		pRenderTarget = m_glyphRenderTargets.top();
		m_glyphRenderTargets.pop();
	}
	
	LeaveCriticalSection(&m_renderTargetsCriticalSection);
	
	if(pRenderTarget == NULL) {
		IFW1DWriteRenderTarget *pNewRenderTarget;
		HRESULT hResult = m_pFW1Factory->CreateDWriteRenderTarget(
			m_pDWriteFactory,
			m_maxGlyphWidth,
			m_maxGlyphHeight,
			&pNewRenderTarget
		);
		if(FAILED(hResult)) {
		}
		else {
			pRenderTarget = pNewRenderTarget;
		}
	}
	
	if(pRenderTarget != NULL) {
		// Draw the glyph image
		DWRITE_RENDERING_MODE renderingMode = DWRITE_RENDERING_MODE_DEFAULT;
		DWRITE_MEASURING_MODE measuringMode = DWRITE_MEASURING_MODE_NATURAL;
		if((glyphMap->fontFlags & FW1_ALIASED) != 0) {
			renderingMode = DWRITE_RENDERING_MODE_ALIASED;
			measuringMode = DWRITE_MEASURING_MODE_GDI_CLASSIC;
		}
		
		FW1_GLYPHIMAGEDATA glyphData;
		HRESULT hResult = pRenderTarget->DrawGlyphTemp(
			pFontFace,
			glyphIndex,
			glyphMap->fontSize,
			renderingMode,
			measuringMode,
			&glyphData
		);
		if(FAILED(hResult)) {
		}
		else {
			// Insert into the atlas and the glyph-map
			EnterCriticalSection(&m_insertGlyphCriticalSection);
			
			glyphAtlasId = glyphMap->glyphs[glyphIndex];
			if(glyphAtlasId == 0xffffffff) {
				glyphAtlasId = m_pGlyphAtlas->InsertGlyph(
					&glyphData.Metrics,
					glyphData.pGlyphPixels,
					glyphData.RowPitch,
					glyphData.PixelStride
				);
				if(glyphAtlasId != 0xffffffff)
					glyphMap->glyphs[glyphIndex] = glyphAtlasId;
			}
			
			LeaveCriticalSection(&m_insertGlyphCriticalSection);
		}
		
		// Keep the render target for future use
		EnterCriticalSection(&m_renderTargetsCriticalSection);
		m_glyphRenderTargets.push(pRenderTarget);
		LeaveCriticalSection(&m_renderTargetsCriticalSection);
	}
	
	return glyphAtlasId;
}


}// namespace FW1FontWrapper

```

`src/vendor/fontwrapper/CFW1GlyphProviderInterface.cpp`:

```cpp
// CFW1GlyphProviderInterface.cpp

#include <vendor/fontwrapper/FW1Precompiled.h>

#include <vendor/fontwrapper/CFW1GlyphProvider.h>


namespace FW1FontWrapper {


// Query interface
HRESULT STDMETHODCALLTYPE CFW1GlyphProvider::QueryInterface(REFIID riid, void **ppvObject) {
	if(ppvObject == NULL)
		return E_INVALIDARG;
	
	if(IsEqualIID(riid, __uuidof(IFW1GlyphProvider))) {
		*ppvObject = static_cast<IFW1GlyphProvider*>(this);
		AddRef();
		return S_OK;
	}
	
	return CFW1Object::QueryInterface(riid, ppvObject);
}


// Get glyph atlas
HRESULT STDMETHODCALLTYPE CFW1GlyphProvider::GetGlyphAtlas(IFW1GlyphAtlas **ppGlyphAtlas) {
	if(ppGlyphAtlas == NULL)
		return E_INVALIDARG;
	
	m_pGlyphAtlas->AddRef();
	*ppGlyphAtlas = m_pGlyphAtlas;
	
	return S_OK;
}


// Get DWrite factory
HRESULT STDMETHODCALLTYPE CFW1GlyphProvider::GetDWriteFactory(IDWriteFactory **ppDWriteFactory) {
	if(ppDWriteFactory == NULL)
		return E_INVALIDARG;
	
	m_pDWriteFactory->AddRef();
	*ppDWriteFactory = m_pDWriteFactory;
	
	return S_OK;
}


// Get DWrite font collection
HRESULT STDMETHODCALLTYPE CFW1GlyphProvider::GetDWriteFontCollection(IDWriteFontCollection **ppFontCollection) {
	if(ppFontCollection == NULL)
		return E_INVALIDARG;
	
	m_pFontCollection->AddRef();
	*ppFontCollection = m_pFontCollection;
	
	return S_OK;
}


// Get glyph map
const void* STDMETHODCALLTYPE CFW1GlyphProvider::GetGlyphMapFromFont(
	IDWriteFontFace *pFontFace,
	FLOAT FontSize,
	UINT FontFlags
) {
	// Get font id
	UINT fontIndex = getFontIndexFromFontFace(pFontFace);
	FontId fontId = makeFontId(fontIndex, FontFlags, FontSize);
	
	const void *glyphMap = 0;
	
	// Get the glyph-map
	EnterCriticalSection(&m_glyphMapsCriticalSection);
	FontMap::iterator it = m_fontMap.find(fontId);
	if(it != m_fontMap.end())
		glyphMap = (*it).second;
	LeaveCriticalSection(&m_glyphMapsCriticalSection);
	
	if(glyphMap == 0 && (FontFlags & FW1_NONEWGLYPHS) == 0) {
		// Create a new glyph-map
		GlyphMap *newGlyphMap = new GlyphMap;
		newGlyphMap->fontSize = FontSize;
		newGlyphMap->fontFlags = FontFlags;
		newGlyphMap->glyphCount = pFontFace->GetGlyphCount();
		newGlyphMap->glyphs = new UINT[newGlyphMap->glyphCount];
		for(UINT i=0; i < newGlyphMap->glyphCount; ++i)
			newGlyphMap->glyphs[i] = 0xffffffff;
		
		bool needless = false;
		
		// Inert the new glyph-map and map the font-id to its index
		EnterCriticalSection(&m_glyphMapsCriticalSection);
		
		it = m_fontMap.find(fontId);
		if(it != m_fontMap.end()) {
			glyphMap = (*it).second;
			needless = true;
		}
		else {
			m_fontMap.insert(std::make_pair(fontId, newGlyphMap));
			glyphMap = newGlyphMap;
		}
		
		LeaveCriticalSection(&m_glyphMapsCriticalSection);
		
		if(needless) {// Simultaneous creation on two threads
			delete[] newGlyphMap->glyphs;
			delete newGlyphMap;
		}
		else {
			UINT glyphAtlasId = insertNewGlyph(newGlyphMap, 0, pFontFace);
			glyphAtlasId;
		}
	}
	
	return glyphMap;
}


// Get atlas id of a glyph
UINT STDMETHODCALLTYPE CFW1GlyphProvider::GetAtlasIdFromGlyphIndex(
	const void *pGlyphMap,
	UINT16 GlyphIndex,
	IDWriteFontFace *pFontFace,
	UINT FontFlags
) {
	GlyphMap *glyphMap = static_cast<GlyphMap*>(const_cast<void*>(pGlyphMap));
	
	if(glyphMap == 0)
		return 0;
	
	if(GlyphIndex >= glyphMap->glyphCount)
		return 0;
	
	// Get the atlas id for this glyph
	UINT glyphAtlasId = glyphMap->glyphs[GlyphIndex];
	if(glyphAtlasId == 0xffffffff && (FontFlags & FW1_NONEWGLYPHS) == 0)
		glyphAtlasId = insertNewGlyph(glyphMap, GlyphIndex, pFontFace);
	
	// Fall back to the font default-glyph or the atlas default-glyph on failure
	if(glyphAtlasId == 0xffffffff) {
		glyphAtlasId = glyphMap->glyphs[0];
		
		if((FontFlags & FW1_NONEWGLYPHS) == 0) {
			if(glyphAtlasId == 0xffffffff) {
				if(GlyphIndex == 0)
					glyphAtlasId = 0;
				else
					glyphAtlasId = GetAtlasIdFromGlyphIndex(pGlyphMap, 0, pFontFace, FontFlags);
			}
			
			EnterCriticalSection(&m_insertGlyphCriticalSection);
			if(glyphMap->glyphs[GlyphIndex] == 0xffffffff)
				glyphMap->glyphs[GlyphIndex] = glyphAtlasId;
			LeaveCriticalSection(&m_insertGlyphCriticalSection);
		}
		
		if(glyphAtlasId == 0xffffffff)
			glyphAtlasId = 0;
	}
	
	return glyphAtlasId;
}


}// namespace FW1FontWrapper

```

`src/vendor/fontwrapper/CFW1GlyphRenderStates.cpp`:

```cpp
// CFW1GlyphRenderStates.cpp

#include <vendor/fontwrapper/FW1Precompiled.h>

#include <vendor/fontwrapper/CFW1GlyphRenderStates.h>

#define SAFE_RELEASE(pObject) { if(pObject) { (pObject)->Release(); (pObject) = NULL; } }


namespace FW1FontWrapper {


// Construct
CFW1GlyphRenderStates::CFW1GlyphRenderStates() :
	m_pfnD3DCompile(NULL),
	
	m_pDevice(NULL),
	m_featureLevel(D3D_FEATURE_LEVEL_9_1),
	
	m_pVertexShaderQuad(NULL),
	m_pVertexShaderClipQuad(NULL),
	m_pQuadInputLayout(NULL),
	
	m_pVertexShaderPoint(NULL),
	m_pPointInputLayout(NULL),
	m_pGeometryShaderPoint(NULL),
	m_pGeometryShaderClipPoint(NULL),
	m_hasGeometryShader(false),
	
	m_pPixelShader(NULL),
	m_pPixelShaderClip(NULL),
	
	m_pConstantBuffer(NULL),
	
	m_pBlendState(NULL),
	m_pSamplerState(NULL),
	m_pRasterizerState(NULL),
	m_pDepthStencilState(NULL)
{
}


// Destruct
CFW1GlyphRenderStates::~CFW1GlyphRenderStates() {
	SAFE_RELEASE(m_pDevice);
	
	SAFE_RELEASE(m_pVertexShaderQuad);
	SAFE_RELEASE(m_pVertexShaderClipQuad);
	SAFE_RELEASE(m_pQuadInputLayout);
	
	SAFE_RELEASE(m_pVertexShaderPoint);
	SAFE_RELEASE(m_pPointInputLayout);
	SAFE_RELEASE(m_pGeometryShaderPoint);
	SAFE_RELEASE(m_pGeometryShaderClipPoint);
	
	SAFE_RELEASE(m_pPixelShader);
	SAFE_RELEASE(m_pPixelShaderClip);
	
	SAFE_RELEASE(m_pConstantBuffer);
	
	SAFE_RELEASE(m_pBlendState);
	SAFE_RELEASE(m_pSamplerState);
	SAFE_RELEASE(m_pRasterizerState);
	SAFE_RELEASE(m_pDepthStencilState);
}


// Init
HRESULT CFW1GlyphRenderStates::initRenderResources(
	IFW1Factory *pFW1Factory,
	ID3D11Device *pDevice,
	bool wantGeometryShader,
	bool anisotropicFiltering
) {
	HRESULT hResult = initBaseObject(pFW1Factory);
	if(FAILED(hResult))
		return hResult;
	
	if(pDevice == NULL)
		return E_INVALIDARG;
	
	pDevice->AddRef();
	m_pDevice = pDevice;
	m_featureLevel = m_pDevice->GetFeatureLevel();
	
	// D3DCompiler
#ifdef FW1_DELAYLOAD_D3DCOMPILER_XX_DLL
	HMODULE hD3DCompiler = LoadLibrary(D3DCOMPILER_DLL);
	if(hD3DCompiler == NULL) {
		DWORD dwErr = GetLastError();
		dwErr;
		m_lastError = std::wstring(L"Failed to load ") + D3DCOMPILER_DLL_W;
		hResult = E_FAIL;
	}
	else {
		m_pfnD3DCompile = reinterpret_cast<pD3DCompile>(GetProcAddress(hD3DCompiler, "D3DCompile"));
		if(m_pfnD3DCompile == NULL) {
			DWORD dwErr = GetLastError();
			dwErr;
			m_lastError = std::wstring(L"Failed to load D3DCompile from ") + D3DCOMPILER_DLL_W;
			hResult = E_FAIL;
		}
		else {
			hResult = S_OK;
		}
	}
#else
	m_pfnD3DCompile = D3DCompile;
	hResult = S_OK;
#endif
	
	// Create all needed resources
	if(SUCCEEDED(hResult))
		hResult = createQuadShaders();
	if(SUCCEEDED(hResult))
		hResult = createPixelShaders();
	if(SUCCEEDED(hResult))
		hResult = createConstantBuffer();
	if(SUCCEEDED(hResult))
		hResult = createRenderStates(anisotropicFiltering);
	if(SUCCEEDED(hResult) && wantGeometryShader) {
		hResult = createGlyphShaders();
		if(FAILED(hResult))
			hResult = S_OK;
	}
	
	if(SUCCEEDED(hResult))
		hResult = S_OK;
	
#ifdef FW1_DELAYLOAD_D3DCOMPILER_XX_DLL
	FreeLibrary(hD3DCompiler);
#endif
	
	return hResult;
}


// Create quad shaders
HRESULT CFW1GlyphRenderStates::createQuadShaders() {
	// Vertex shaders
	const char vsSimpleStr[] =
	"cbuffer ShaderConstants : register(b0) {\r\n"
	"	float4x4 TransformMatrix : packoffset(c0);\r\n"
	"};\r\n"
	"\r\n"
	"struct VSIn {\r\n"
	"	float4 Position : POSITION;\r\n"
	"	float4 GlyphColor : GLYPHCOLOR;\r\n"
	"};\r\n"
	"\r\n"
	"struct VSOut {\r\n"
	"	float4 Position : SV_Position;\r\n"
	"	float4 GlyphColor : COLOR;\r\n"
	"	float2 TexCoord : TEXCOORD;\r\n"
	"};\r\n"
	"\r\n"
	"VSOut VS(VSIn Input) {\r\n"
	"	VSOut Output;\r\n"
	"	\r\n"
	"	Output.Position = mul(TransformMatrix, float4(Input.Position.xy, 0.0f, 1.0f));\r\n"
	"	Output.GlyphColor = Input.GlyphColor;\r\n"
	"	Output.TexCoord = Input.Position.zw;\r\n"
	"	\r\n"
	"	return Output;\r\n"
	"}\r\n"
	"";
	
	const char vsClipStr[] =
	"cbuffer ShaderConstants : register(b0) {\r\n"
	"	float4x4 TransformMatrix : packoffset(c0);\r\n"
	"	float4 ClipRect : packoffset(c4);\r\n"
	"};\r\n"
	"\r\n"
	"struct VSIn {\r\n"
	"	float4 Position : POSITION;\r\n"
	"	float4 GlyphColor : GLYPHCOLOR;\r\n"
	"};\r\n"
	"\r\n"
	"struct VSOut {\r\n"
	"	float4 Position : SV_Position;\r\n"
	"	float4 GlyphColor : COLOR;\r\n"
	"	float2 TexCoord : TEXCOORD;\r\n"
	"	float4 ClipDistance : CLIPDISTANCE;\r\n"
	"};\r\n"
	"\r\n"
	"VSOut VS(VSIn Input) {\r\n"
	"	VSOut Output;\r\n"
	"	\r\n"
	"	Output.Position = mul(TransformMatrix, float4(Input.Position.xy, 0.0f, 1.0f));\r\n"
	"	Output.GlyphColor = Input.GlyphColor;\r\n"
	"	Output.TexCoord = Input.Position.zw;\r\n"
	"	Output.ClipDistance = ClipRect + float4(Input.Position.xy, -Input.Position.xy);\r\n"
	"	\r\n"
	"	return Output;\r\n"
	"}\r\n"
	"";
	
	// Shader compile profile
	const char *vs_profile = "vs_4_0_level_9_1";
	if(m_featureLevel >= D3D_FEATURE_LEVEL_11_0)
		vs_profile = "vs_5_0";
	else if(m_featureLevel >= D3D_FEATURE_LEVEL_10_0)
		vs_profile = "vs_4_0";
	else if(m_featureLevel >= D3D_FEATURE_LEVEL_9_3)
		vs_profile = "vs_4_0_level_9_3";
	
	// Compile vertex shader
	ID3DBlob *pVSCode;
	
	HRESULT hResult = m_pfnD3DCompile(
		vsSimpleStr,
		sizeof(vsSimpleStr),
		NULL,
		NULL,
		NULL,
		"VS",
		vs_profile,
		D3DCOMPILE_OPTIMIZATION_LEVEL3,
		0,
		&pVSCode,
		NULL
	);
	if(FAILED(hResult)) {
		m_lastError = L"Failed to compile vertex shader";
	}
	else {
		// Create vertex shader
		ID3D11VertexShader *pVS;
		
		hResult = m_pDevice->CreateVertexShader(pVSCode->GetBufferPointer(), pVSCode->GetBufferSize(), NULL, &pVS);
		if(FAILED(hResult)) {
			m_lastError = L"Failed to create vertex shader";
		}
		else {
			// Compile clipping vertex shader
			ID3DBlob *pVSClipCode;
			
			hResult = m_pfnD3DCompile(
				vsClipStr,
				sizeof(vsClipStr),
				NULL,
				NULL,
				NULL,
				"VS",
				vs_profile,
				D3DCOMPILE_OPTIMIZATION_LEVEL3,
				0,
				&pVSClipCode,
				NULL
			);
			if(FAILED(hResult)) {
				m_lastError = L"Failed to compile clipping vertex shader";
			}
			else {
				// Create vertex shader
				ID3D11VertexShader *pVSClip;
				
				hResult = m_pDevice->CreateVertexShader(
					pVSClipCode->GetBufferPointer(),
					pVSClipCode->GetBufferSize(),
					NULL,
					&pVSClip
				);
				if(FAILED(hResult)) {
					m_lastError = L"Failed to create clipping vertex shader";
				}
				else {
					// Create input layout
					ID3D11InputLayout *pInputLayout;
					
					// Quad vertex input layout
					D3D11_INPUT_ELEMENT_DESC inputElements[] = {
						{"POSITION", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0},
						{"GLYPHCOLOR", 0, DXGI_FORMAT_R8G8B8A8_UNORM, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0}
					};
					
					hResult = m_pDevice->CreateInputLayout(
						inputElements,
						2,
						pVSCode->GetBufferPointer(),
						pVSCode->GetBufferSize(),
						&pInputLayout
					);
					if(FAILED(hResult)) {
						m_lastError = L"Failed to create input layout";
					}
					else {
						// Success
						m_pVertexShaderQuad = pVS;
						m_pVertexShaderClipQuad = pVSClip;
						m_pQuadInputLayout = pInputLayout;
						
						hResult = S_OK;
					}
					
					if(FAILED(hResult))
						pVSClip->Release();
				}
				
				pVSClipCode->Release();
			}
			
			if(FAILED(hResult))
				pVS->Release();
		}
		
		pVSCode->Release();
	}
	
	return hResult;
}

// Create point to quad geometry shader
HRESULT CFW1GlyphRenderStates::createGlyphShaders() {
	if(m_featureLevel < D3D_FEATURE_LEVEL_10_0)
		return E_FAIL;
	
	// Geometry shader constructing glyphs from point input and texture buffer
	const char gsSimpleStr[] =
	"cbuffer ShaderConstants : register(b0) {\r\n"
	"	float4x4 TransformMatrix : packoffset(c0);\r\n"
	"};\r\n"
	"\r\n"
	"Buffer<float4> tex0 : register(t0);\r\n"
	"\r\n"
	"struct GSIn {\r\n"
	"	float3 PositionIndex : POSITIONINDEX;\r\n"
	"	float4 GlyphColor : GLYPHCOLOR;\r\n"
	"};\r\n"
	"\r\n"
	"struct GSOut {\r\n"
	"	float4 Position : SV_Position;\r\n"
	"	float4 GlyphColor : COLOR;\r\n"
	"	float2 TexCoord : TEXCOORD;\r\n"
	"};\r\n"
	"\r\n"
	"[maxvertexcount(4)]\r\n"
	"void GS(point GSIn Input[1], inout TriangleStream<GSOut> TriStream) {\r\n"
	"	const float2 basePosition = Input[0].PositionIndex.xy;\r\n"
	"	const uint glyphIndex = asuint(Input[0].PositionIndex.z);\r\n"
	"	\r\n"
	"	float4 texCoords = tex0.Load(uint2(glyphIndex*2, 0));\r\n"
	"	float4 offsets = tex0.Load(uint2(glyphIndex*2+1, 0));\r\n"
	"	\r\n"
	"	GSOut Output;\r\n"
	"	Output.GlyphColor = Input[0].GlyphColor;\r\n"
	"	\r\n"
	"	float4 positions = basePosition.xyxy + offsets;\r\n"
	"	\r\n"
	"	Output.Position = mul(TransformMatrix, float4(positions.xy, 0.0f, 1.0f));\r\n"
	"	Output.TexCoord = texCoords.xy;\r\n"
	"	TriStream.Append(Output);\r\n"
	"	\r\n"
	"	Output.Position = mul(TransformMatrix, float4(positions.zy, 0.0f, 1.0f));\r\n"
	"	Output.TexCoord = texCoords.zy;\r\n"
	"	TriStream.Append(Output);\r\n"
	"	\r\n"
	"	Output.Position = mul(TransformMatrix, float4(positions.xw, 0.0f, 1.0f));\r\n"
	"	Output.TexCoord = texCoords.xw;\r\n"
	"	TriStream.Append(Output);\r\n"
	"	\r\n"
	"	Output.Position = mul(TransformMatrix, float4(positions.zw, 0.0f, 1.0f));\r\n"
	"	Output.TexCoord = texCoords.zw;\r\n"
	"	TriStream.Append(Output);\r\n"
	"	\r\n"
	"	TriStream.RestartStrip();\r\n"
	"}\r\n"
	"";
	
	// Geometry shader with rect clipping
	const char gsClipStr[] =
	"cbuffer ShaderConstants : register(b0) {\r\n"
	"	float4x4 TransformMatrix : packoffset(c0);\r\n"
	"	float4 ClipRect : packoffset(c4);\r\n"
	"};\r\n"
	"\r\n"
	"Buffer<float4> tex0 : register(t0);\r\n"
	"\r\n"
	"struct GSIn {\r\n"
	"	float3 PositionIndex : POSITIONINDEX;\r\n"
	"	float4 GlyphColor : GLYPHCOLOR;\r\n"
	"};\r\n"
	"\r\n"
	"struct GSOut {\r\n"
	"	float4 Position : SV_Position;\r\n"
	"	float4 GlyphColor : COLOR;\r\n"
	"	float2 TexCoord : TEXCOORD;\r\n"
	"	float4 ClipDistance : SV_ClipDistance;\r\n"
	"};\r\n"
	"\r\n"
	"[maxvertexcount(4)]\r\n"
	"void GS(point GSIn Input[1], inout TriangleStream<GSOut> TriStream) {\r\n"
	"	const float2 basePosition = Input[0].PositionIndex.xy;\r\n"
	"	const uint glyphIndex = asuint(Input[0].PositionIndex.z);\r\n"
	"	\r\n"
	"	float4 texCoords = tex0.Load(uint2(glyphIndex*2, 0));\r\n"
	"	float4 offsets = tex0.Load(uint2(glyphIndex*2+1, 0));\r\n"
	"	\r\n"
	"	GSOut Output;\r\n"
	"	Output.GlyphColor = Input[0].GlyphColor;\r\n"
	"	\r\n"
	"	float4 positions = basePosition.xyxy + offsets;\r\n"
	"	\r\n"
	"	Output.Position = mul(TransformMatrix, float4(positions.xy, 0.0f, 1.0f));\r\n"
	"	Output.TexCoord = texCoords.xy;\r\n"
	"	Output.ClipDistance = ClipRect + float4(positions.xy, -positions.xy);\r\n"
	"	TriStream.Append(Output);\r\n"
	"	\r\n"
	"	Output.Position = mul(TransformMatrix, float4(positions.zy, 0.0f, 1.0f));\r\n"
	"	Output.TexCoord = texCoords.zy;\r\n"
	"	Output.ClipDistance = ClipRect + float4(positions.zy, -positions.zy);\r\n"
	"	TriStream.Append(Output);\r\n"
	"	\r\n"
	"	Output.Position = mul(TransformMatrix, float4(positions.xw, 0.0f, 1.0f));\r\n"
	"	Output.TexCoord = texCoords.xw;\r\n"
	"	Output.ClipDistance = ClipRect + float4(positions.xw, -positions.xw);\r\n"
	"	TriStream.Append(Output);\r\n"
	"	\r\n"
	"	Output.Position = mul(TransformMatrix, float4(positions.zw, 0.0f, 1.0f));\r\n"
	"	Output.TexCoord = texCoords.zw;\r\n"
	"	Output.ClipDistance = ClipRect + float4(positions.zw, -positions.zw);\r\n"
	"	TriStream.Append(Output);\r\n"
	"	\r\n"
	"	TriStream.RestartStrip();\r\n"
	"}\r\n"
	"";
	
	// Vertex shader
	const char vsEmptyStr[] =
	"struct GSIn {\r\n"
	"	float3 PositionIndex : POSITIONINDEX;\r\n"
	"	float4 GlyphColor : GLYPHCOLOR;\r\n"
	"};\r\n"
	"\r\n"
	"GSIn VS(GSIn Input) {\r\n"
	"	return Input;\r\n"
	"}\r\n"
	"";
	
	// Shader compile profiles
	const char *vs_profile = "vs_4_0";
	const char *gs_profile = "gs_4_0";
	if(m_featureLevel >= D3D_FEATURE_LEVEL_11_0) {
		vs_profile = "vs_5_0";
		gs_profile = "gs_5_0";
	}
	
	// Compile geometry shader
	ID3DBlob *pGSCode;
	
	HRESULT hResult = m_pfnD3DCompile(
		gsSimpleStr,
		sizeof(gsSimpleStr),
		NULL,
		NULL,
		NULL,
		"GS",
		gs_profile,
		D3DCOMPILE_OPTIMIZATION_LEVEL3,
		0,
		&pGSCode,
		NULL
	);
	if(FAILED(hResult)) {
		m_lastError = L"Failed to compile geometry shader";
	}
	else {
		// Create geometry shader
		ID3D11GeometryShader *pGS;
		
		hResult = m_pDevice->CreateGeometryShader(pGSCode->GetBufferPointer(), pGSCode->GetBufferSize(), NULL, &pGS);
		if(FAILED(hResult)) {
			m_lastError = L"Failed to create geometry shader";
		}
		else {
			// Compile clipping geometry shader
			ID3DBlob *pGSClipCode;
			
			hResult = m_pfnD3DCompile(
				gsClipStr,
				sizeof(gsClipStr),
				NULL,
				NULL,
				NULL,
				"GS",
				gs_profile,
				D3DCOMPILE_OPTIMIZATION_LEVEL3,
				0,
				&pGSClipCode,
				NULL
			);
			if(FAILED(hResult)) {
				m_lastError = L"Failed to compile clipping geometry shader";
			}
			else {
				// Create clipping geometry shader
				ID3D11GeometryShader *pGSClip;
				
				hResult = m_pDevice->CreateGeometryShader(
					pGSClipCode->GetBufferPointer(),
					pGSClipCode->GetBufferSize(),
					NULL,
					&pGSClip
				);
				if(FAILED(hResult)) {
					m_lastError = L"Failed to create clipping geometry shader";
				}
				else {
					ID3DBlob *pVSEmptyCode;
					
					// Compile vertex shader
					hResult = m_pfnD3DCompile(
						vsEmptyStr,
						sizeof(vsEmptyStr),
						NULL,
						NULL,
						NULL,
						"VS",
						vs_profile,
						D3DCOMPILE_OPTIMIZATION_LEVEL3,
						0,
						&pVSEmptyCode,
						NULL
					);
					if(FAILED(hResult)) {
						m_lastError = L"Failed to compile empty vertex shader";
					}
					else {
						// Create vertex shader
						ID3D11VertexShader *pVSEmpty;
						
						hResult = m_pDevice->CreateVertexShader(
							pVSEmptyCode->GetBufferPointer(),
							pVSEmptyCode->GetBufferSize(),
							NULL,
							&pVSEmpty
						);
						if(FAILED(hResult)) {
							m_lastError = L"Failed to create empty vertex shader";
						}
						else {
							ID3D11InputLayout *pInputLayout;
							
							// Input layout for geometry shader
							D3D11_INPUT_ELEMENT_DESC inputElements[] = {
								{"POSITIONINDEX", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0},
								{"GLYPHCOLOR", 0, DXGI_FORMAT_R8G8B8A8_UNORM, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0}
							};
							
							hResult = m_pDevice->CreateInputLayout(
								inputElements,
								2,
								pVSEmptyCode->GetBufferPointer(),
								pVSEmptyCode->GetBufferSize(),
								&pInputLayout
							);
							if(FAILED(hResult)) {
								m_lastError = L"Failed to create input layout for geometry shader";
							}
							else {
								// Success
								m_pVertexShaderPoint = pVSEmpty;
								m_pGeometryShaderPoint = pGS;
								m_pGeometryShaderClipPoint = pGSClip;
								m_pPointInputLayout = pInputLayout;
								m_hasGeometryShader = true;
								
								hResult = S_OK;
							}
							
							if(FAILED(hResult))
								pVSEmpty->Release();
						}
						
						pVSEmptyCode->Release();
					}
					
					if(FAILED(hResult))
						pGSClip->Release();
				}
				
				pGSClipCode->Release();
			}
			
			if(FAILED(hResult))
				pGS->Release();
		}
		
		pGSCode->Release();
	}
	
	return hResult;
}

// Create pixel shaders
HRESULT CFW1GlyphRenderStates::createPixelShaders() {
	// Pixel shader
	const char psStr[] =
	"SamplerState sampler0 : register(s0);\r\n"
	"Texture2D<float> tex0 : register(t0);\r\n"
	"\r\n"
	"struct PSIn {\r\n"
	"	float4 Position : SV_Position;\r\n"
	"	float4 GlyphColor : COLOR;\r\n"
	"	float2 TexCoord : TEXCOORD;\r\n"
	"};\r\n"
	"\r\n"
	"float4 PS(PSIn Input) : SV_Target {\r\n"
	"	float a = tex0.Sample(sampler0, Input.TexCoord);\r\n"
	"	\r\n"
	"	if(a == 0.0f)\r\n"
	"		discard;\r\n"
	"	\r\n"
	"	return (a * Input.GlyphColor.a) * float4(Input.GlyphColor.rgb, 1.0f);\r\n"
	"}\r\n"
	"";
	
	// Clipping pixel shader
	const char psClipStr[] =
	"SamplerState sampler0 : register(s0);\r\n"
	"Texture2D<float> tex0 : register(t0);\r\n"
	"\r\n"
	"struct PSIn {\r\n"
	"	float4 Position : SV_Position;\r\n"
	"	float4 GlyphColor : COLOR;\r\n"
	"	float2 TexCoord : TEXCOORD;\r\n"
	"	float4 ClipDistance : CLIPDISTANCE;\r\n"
	"};\r\n"
	"\r\n"
	"float4 PS(PSIn Input) : SV_Target {\r\n"
	"	clip(Input.ClipDistance);\r\n"
	"	\r\n"
	"	float a = tex0.Sample(sampler0, Input.TexCoord);\r\n"
	"	\r\n"
	"	if(a == 0.0f)\r\n"
	"		discard;\r\n"
	"	\r\n"
	"	return (a * Input.GlyphColor.a) * float4(Input.GlyphColor.rgb, 1.0f);\r\n"
	"}\r\n"
	"";
	
	// Shader compile profile
	const char *ps_profile = "ps_4_0_level_9_1";
	if(m_featureLevel >= D3D_FEATURE_LEVEL_11_0)
		ps_profile = "ps_5_0";
	else if(m_featureLevel >= D3D_FEATURE_LEVEL_10_0)
		ps_profile = "ps_4_0";
	else if(m_featureLevel >= D3D_FEATURE_LEVEL_9_3)
		ps_profile = "ps_4_0_level_9_3";
	
	// Compile pixel shader
	ID3DBlob *pPSCode;
	
	HRESULT hResult = m_pfnD3DCompile(
		psStr,
		sizeof(psStr),
		NULL,
		NULL,
		NULL,
		"PS",
		ps_profile,
		D3DCOMPILE_OPTIMIZATION_LEVEL3,
		0,
		&pPSCode,
		NULL
	);
	if(FAILED(hResult)) {
		m_lastError = L"Failed to compile pixel shader";
	}
	else {
		// Create pixel shader
		ID3D11PixelShader *pPS;
		
		hResult = m_pDevice->CreatePixelShader(pPSCode->GetBufferPointer(), pPSCode->GetBufferSize(), NULL, &pPS);
		if(FAILED(hResult)) {
			m_lastError = L"Failed to create pixel shader";
		}
		else {
			// Compile clipping pixel shader
			ID3DBlob *pPSClipCode;
			
			HRESULT hResult = m_pfnD3DCompile(
				psClipStr,
				sizeof(psClipStr),
				NULL,
				NULL,
				NULL,
				"PS",
				ps_profile,
				D3DCOMPILE_OPTIMIZATION_LEVEL3,
				0,
				&pPSClipCode,
				NULL
			);
			if(FAILED(hResult)) {
				m_lastError = L"Failed to compile clipping pixel shader";
			}
			else {
				// Create pixel shader
				ID3D11PixelShader *pPSClip;
				
				hResult = m_pDevice->CreatePixelShader(
					pPSClipCode->GetBufferPointer(),
					pPSClipCode->GetBufferSize(),
					NULL, &pPSClip
				);
				if(FAILED(hResult)) {
					m_lastError = L"Failed to create clipping pixel shader";
				}
				else {
					// Success
					m_pPixelShader = pPS;
					m_pPixelShaderClip = pPSClip;
					
					hResult = S_OK;
				}
				
				pPSClipCode->Release();
			}
			
			if(FAILED(hResult))
				pPS->Release();
		}
		
		pPSCode->Release();
	}
	
	return hResult;
}


// Create constant buffer
HRESULT CFW1GlyphRenderStates::createConstantBuffer() {
	// Create constant buffer
	D3D11_BUFFER_DESC constantBufferDesc;
	ID3D11Buffer *pConstantBuffer;
			
	ZeroMemory(&constantBufferDesc, sizeof(constantBufferDesc));
	constantBufferDesc.ByteWidth = sizeof(ShaderConstants);
	constantBufferDesc.Usage = D3D11_USAGE_DYNAMIC;
	constantBufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constantBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
			
	HRESULT hResult = m_pDevice->CreateBuffer(&constantBufferDesc, NULL, &pConstantBuffer);
	if(FAILED(hResult)) {
		m_lastError = L"Failed to create constant buffer";
	}
	else {
		// Success
		m_pConstantBuffer = pConstantBuffer;
				
		hResult = S_OK;
	}

	return hResult;
}


// Create render states
HRESULT CFW1GlyphRenderStates::createRenderStates(bool anisotropicFiltering) {
	// Create blend-state
	D3D11_BLEND_DESC blendDesc;
	ID3D11BlendState *pBlendState;
	
	ZeroMemory(&blendDesc, sizeof(blendDesc));
	for(int i=0; i < 4; ++i) {
		blendDesc.RenderTarget[i].BlendEnable = TRUE;
		blendDesc.RenderTarget[i].SrcBlend = D3D11_BLEND_ONE;
		blendDesc.RenderTarget[i].DestBlend = D3D11_BLEND_INV_SRC_ALPHA;
		blendDesc.RenderTarget[i].BlendOp = D3D11_BLEND_OP_ADD;
		blendDesc.RenderTarget[i].SrcBlendAlpha = D3D11_BLEND_ONE;
		blendDesc.RenderTarget[i].DestBlendAlpha = D3D11_BLEND_ZERO;
		blendDesc.RenderTarget[i].BlendOpAlpha = D3D11_BLEND_OP_ADD;
		blendDesc.RenderTarget[i].RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;
	}
	
	HRESULT hResult = m_pDevice->CreateBlendState(&blendDesc, &pBlendState);
	if(FAILED(hResult)) {
		m_lastError = L"Failed to create blend state";
	}
	else {
		// Create sampler state
		D3D11_SAMPLER_DESC samplerDesc;
		ID3D11SamplerState *pSamplerState;
		
		ZeroMemory(&samplerDesc, sizeof(samplerDesc));
		if(anisotropicFiltering) {
			samplerDesc.Filter = D3D11_FILTER_ANISOTROPIC;
			samplerDesc.MaxAnisotropy = 2;
			if(m_featureLevel >= D3D_FEATURE_LEVEL_9_2)
				samplerDesc.MaxAnisotropy = 5;
		}
		else
			samplerDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
		samplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;
		samplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;
		samplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;
		samplerDesc.MaxLOD = D3D11_FLOAT32_MAX;
		
		hResult = m_pDevice->CreateSamplerState(&samplerDesc, &pSamplerState);
		if(FAILED(hResult)) {
			m_lastError = L"Failed to create sampler state";
		}
		else {
			// Create rasterizer state
			D3D11_RASTERIZER_DESC rasterizerDesc;
			ID3D11RasterizerState *pRasterizerState;
			
			ZeroMemory(&rasterizerDesc, sizeof(rasterizerDesc));
			rasterizerDesc.FillMode = D3D11_FILL_SOLID;
			rasterizerDesc.CullMode = D3D11_CULL_NONE;
			rasterizerDesc.FrontCounterClockwise = FALSE;
			rasterizerDesc.DepthClipEnable = TRUE;
			
			hResult = m_pDevice->CreateRasterizerState(&rasterizerDesc, &pRasterizerState);
			if(FAILED(hResult)) {
				m_lastError = L"Failed to create rasterizer state";
			}
			else {
				// Create depth-stencil state
				D3D11_DEPTH_STENCIL_DESC depthStencilDesc;
				ID3D11DepthStencilState *pDepthStencilState;
				
				ZeroMemory(&depthStencilDesc, sizeof(depthStencilDesc));
				depthStencilDesc.DepthEnable = FALSE;
				
				hResult = m_pDevice->CreateDepthStencilState(&depthStencilDesc, &pDepthStencilState);
				if(FAILED(hResult)) {
					m_lastError = L"Failed to create depth stencil state";
				}
				else {
					// Success
					m_pBlendState = pBlendState;
					m_pSamplerState = pSamplerState;
					m_pRasterizerState = pRasterizerState;
					m_pDepthStencilState = pDepthStencilState;
					
					hResult = S_OK;
				}
				
				if(FAILED(hResult))
					pRasterizerState->Release();
			}
			
			if(FAILED(hResult))
				pSamplerState->Release();
		}
		
		if(FAILED(hResult))
			pBlendState->Release();
	}
	
	return hResult;
}


}// namespace FW1FontWrapper

```

`src/vendor/fontwrapper/CFW1GlyphRenderStatesInterface.cpp`:

```cpp
// CFW1GlyphRenderStatesInterface.cpp

#include <vendor/fontwrapper/FW1Precompiled.h>

#include <vendor/fontwrapper/CFW1GlyphRenderStates.h>


namespace FW1FontWrapper {


// Query interface
HRESULT STDMETHODCALLTYPE CFW1GlyphRenderStates::QueryInterface(REFIID riid, void **ppvObject) {
	if(ppvObject == NULL)
		return E_INVALIDARG;
	
	if(IsEqualIID(riid, __uuidof(IFW1GlyphRenderStates))) {
		*ppvObject = static_cast<IFW1GlyphRenderStates*>(this);
		AddRef();
		return S_OK;
	}
	
	return CFW1Object::QueryInterface(riid, ppvObject);
}


// Get the D3D11 device used by the render states
HRESULT STDMETHODCALLTYPE CFW1GlyphRenderStates::GetDevice(ID3D11Device **ppDevice) {
	if(ppDevice == NULL)
		return E_INVALIDARG;
	
	m_pDevice->AddRef();
	*ppDevice = m_pDevice;
	
	return S_OK;
}


// Set render states for glyph drawing
void STDMETHODCALLTYPE CFW1GlyphRenderStates::SetStates(ID3D11DeviceContext *pContext, UINT Flags) {
	if(m_hasGeometryShader && ((Flags & FW1_NOGEOMETRYSHADER) == 0)) {
		// Point vertices with geometry shader
		pContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_POINTLIST);
		pContext->IASetInputLayout(m_pPointInputLayout);
		pContext->VSSetShader(m_pVertexShaderPoint, NULL, 0);
		if((Flags & FW1_CLIPRECT) != 0)
			pContext->GSSetShader(m_pGeometryShaderClipPoint, NULL, 0);
		else
			pContext->GSSetShader(m_pGeometryShaderPoint, NULL, 0);
		pContext->PSSetShader(m_pPixelShader, NULL, 0);
		pContext->GSSetConstantBuffers(0, 1, &m_pConstantBuffer);
	}
	else {
		// Quads constructed on the CPU
		pContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
		pContext->IASetInputLayout(m_pQuadInputLayout);
		if((Flags & FW1_CLIPRECT) != 0) {
			pContext->VSSetShader(m_pVertexShaderClipQuad, NULL, 0);
			pContext->PSSetShader(m_pPixelShaderClip, NULL, 0);
		}
		else {
			pContext->VSSetShader(m_pVertexShaderQuad, NULL, 0);
			pContext->PSSetShader(m_pPixelShader, NULL, 0);
		}
		pContext->VSSetConstantBuffers(0, 1, &m_pConstantBuffer);
		
		if(m_featureLevel >= D3D_FEATURE_LEVEL_10_0)
			pContext->GSSetShader(NULL, NULL, 0);
	}
	
	if(m_featureLevel >= D3D_FEATURE_LEVEL_11_0) {
		pContext->DSSetShader(NULL, NULL, 0);
		pContext->HSSetShader(NULL, NULL, 0);
	}
	
	pContext->OMSetBlendState(m_pBlendState, NULL, 0xffffffff);
	pContext->OMSetDepthStencilState(m_pDepthStencilState, 0);
	
	pContext->RSSetState(m_pRasterizerState);
	
	pContext->PSSetSamplers(0, 1, &m_pSamplerState);
}


// Update constant buffer
void STDMETHODCALLTYPE CFW1GlyphRenderStates::UpdateShaderConstants(
	ID3D11DeviceContext *pContext,
	const FW1_RECTF *pClipRect,
	const FLOAT *pTransformMatrix
) {
	// Shader constants
	ShaderConstants constants;
	ZeroMemory(&constants, sizeof(constants));
	
	// Transform matrix
	if(pTransformMatrix != NULL)
		CopyMemory(constants.TransformMatrix, pTransformMatrix, 16*sizeof(FLOAT));
	else {
		// Get viewport size for orthographic transform
		FLOAT w = 512.0f;
		FLOAT h = 512.0f;
		
		D3D11_VIEWPORT vp;
		UINT nvp = 1;
		pContext->RSGetViewports(&nvp, &vp);
		if(nvp > 0) {
			if(vp.Width >= 1.0f && vp.Height >= 1.0f) {
				w = vp.Width;
				h = vp.Height;
			}
		}
		
		constants.TransformMatrix[0] = 2.0f / w;
		constants.TransformMatrix[12] = -1.0f;
		constants.TransformMatrix[5] = -2.0f / h;
		constants.TransformMatrix[13] = 1.0f;
		constants.TransformMatrix[10] = 1.0f;
		constants.TransformMatrix[15] = 1.0f;
	}
	
	// Clip rect
	if(pClipRect != NULL) {
		constants.ClipRect[0] = -pClipRect->Left;
		constants.ClipRect[1] = -pClipRect->Top;
		constants.ClipRect[2] = pClipRect->Right;
		constants.ClipRect[3] = pClipRect->Bottom;
	}
	else {
		constants.ClipRect[0] = FLT_MAX;
		constants.ClipRect[1] = FLT_MAX;
		constants.ClipRect[2] = FLT_MAX;
		constants.ClipRect[3] = FLT_MAX;
	}
	
	// Update constant buffer
	D3D11_MAPPED_SUBRESOURCE msr;
	HRESULT hResult = pContext->Map(m_pConstantBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &msr);
	if(SUCCEEDED(hResult)) {
		CopyMemory(msr.pData, &constants, sizeof(constants));
		
		pContext->Unmap(m_pConstantBuffer, 0);
	}
}


// Check for geometry shader
BOOL STDMETHODCALLTYPE CFW1GlyphRenderStates::HasGeometryShader() {
	return (m_hasGeometryShader ? TRUE : FALSE);
}


}// namespace FW1FontWrapper

```

`src/vendor/fontwrapper/CFW1GlyphSheet.cpp`:

```cpp
// CFW1GlyphSheet.cpp

#include <vendor/fontwrapper/FW1Precompiled.h>

#include <vendor/fontwrapper/CFW1GlyphSheet.h>

#define SAFE_RELEASE(pObject) { if(pObject) { (pObject)->Release(); (pObject) = NULL; } }


namespace FW1FontWrapper {


// Construct
CFW1GlyphSheet::CFW1GlyphSheet() :
	m_sheetWidth(0),
	m_sheetHeight(0),
	m_hardwareCoordBuffer(false),
	m_allowOversizedGlyph(false),
	
	m_textureData(0),
	m_glyphCoords(0),
	m_maxGlyphCount(0),
	m_glyphCount(0),
	m_mipLevelCount(0),
	m_alignWidth(0),
	
	m_pDevice(NULL),
	
	m_pTexture(NULL),
	m_pTextureSRV(NULL),
	m_pCoordBuffer(NULL),
	m_pCoordBufferSRV(NULL),
	
	m_closed(false),
	m_static(false),
	
	m_heightRange(0),
	
	m_updatedGlyphCount(0)
{
	ZeroMemory(&m_dirtyRect, sizeof(m_dirtyRect));
	InitializeCriticalSection(&m_sheetCriticalSection);
	InitializeCriticalSection(&m_flushCriticalSection);
}


// Destruct
CFW1GlyphSheet::~CFW1GlyphSheet() {
	delete[] m_textureData;
	delete[] m_glyphCoords;
	
	SAFE_RELEASE(m_pDevice);
	
	SAFE_RELEASE(m_pTexture);
	SAFE_RELEASE(m_pTextureSRV);
	SAFE_RELEASE(m_pCoordBuffer);
	SAFE_RELEASE(m_pCoordBufferSRV);
	
	delete m_heightRange;
	
	DeleteCriticalSection(&m_sheetCriticalSection);
	DeleteCriticalSection(&m_flushCriticalSection);
}


// Init
HRESULT CFW1GlyphSheet::initGlyphSheet(
	IFW1Factory *pFW1Factory,
	ID3D11Device *pDevice,
	UINT sheetWidth,
	UINT sheetHeight,
	bool coordBuffer,
	bool allowOversizedGlyph,
	UINT maxGlyphCount,
	UINT mipLevelCount
) {
	HRESULT hResult = initBaseObject(pFW1Factory);
	if(FAILED(hResult))
		return hResult;
	
	if(pDevice == NULL)
		return E_INVALIDARG;
	
	pDevice->AddRef();
	m_pDevice = pDevice;
	
	// Sheet metrics
	m_sheetWidth = 512;
	if(sheetWidth > 0)
		m_sheetWidth = sheetWidth;
	m_sheetHeight = 512;
	if(sheetHeight > 0)
		m_sheetHeight = sheetHeight;
	
	if(coordBuffer) {
		D3D_FEATURE_LEVEL featureLevel = m_pDevice->GetFeatureLevel();
		if(featureLevel >= D3D_FEATURE_LEVEL_10_0)
			m_hardwareCoordBuffer = true;
	}
	
	m_allowOversizedGlyph = allowOversizedGlyph;
	
	m_maxGlyphCount = 2048;
	if(maxGlyphCount > 0 && maxGlyphCount < 65535)
		m_maxGlyphCount = maxGlyphCount;
	
	if(mipLevelCount > 1) {
		m_mipLevelCount = std::min(mipLevelCount, 5U);// Reasonable mip limit considering borders
		m_alignWidth = (1 << (m_mipLevelCount - 1));
	}
	else {// 0 defaults to 1
		m_mipLevelCount = 1;
		m_alignWidth = 1;
	}
	
	// Storage
	UINT textureSize = m_sheetWidth * m_sheetHeight;
	UINT mipSize = textureSize;
	for(UINT i=1;i<m_mipLevelCount;++i) {
		mipSize >>= 2;
		textureSize += mipSize;
	}
	
	m_textureData = new UINT8[textureSize];
	ZeroMemory(m_textureData, textureSize);
	
	m_glyphCoords = new FW1_GLYPHCOORDS[m_maxGlyphCount];
	
	m_heightRange = new HeightRange(m_sheetWidth / m_alignWidth);
	
	// Device texture/coord-buffer
	hResult = createDeviceResources();
	
	if(SUCCEEDED(hResult))
		hResult = S_OK;
	
	return hResult;
}


// Create sheet texture and (optionally) coord buffer
HRESULT CFW1GlyphSheet::createDeviceResources() {
	// Create sheet texture
	D3D11_TEXTURE2D_DESC textureDesc;
	ID3D11Texture2D *pTexture;
	
	ZeroMemory(&textureDesc, sizeof(textureDesc));
	textureDesc.Width = m_sheetWidth;
	textureDesc.Height = m_sheetHeight;
	textureDesc.ArraySize = 1;
	textureDesc.Format = DXGI_FORMAT_R8_UNORM;
	textureDesc.SampleDesc.Count = 1;
	textureDesc.Usage = D3D11_USAGE_DEFAULT;
	textureDesc.MipLevels = m_mipLevelCount;
	textureDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	
	HRESULT hResult = m_pDevice->CreateTexture2D(&textureDesc, NULL, &pTexture);
	if(FAILED(hResult)) {
		m_lastError = L"Failed to create glyph sheet texture";
	}
	else {
		ID3D11ShaderResourceView *pTextureSRV;
		
		hResult = m_pDevice->CreateShaderResourceView(pTexture, NULL, &pTextureSRV);
		if(FAILED(hResult)) {
			m_lastError = L"Failed to create shader resource view for glyph sheet texture";
		}
		else {
			// Create coord buffer if enabled
			if(m_hardwareCoordBuffer) {
				D3D11_BUFFER_DESC bufferDesc;
				ID3D11Buffer *pBuffer;
				
				ZeroMemory(&bufferDesc, sizeof(bufferDesc));
				bufferDesc.ByteWidth = m_maxGlyphCount * sizeof(FW1_GLYPHCOORDS);
				bufferDesc.Usage = D3D11_USAGE_DEFAULT;
				bufferDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
				
				hResult = m_pDevice->CreateBuffer(&bufferDesc, NULL, &pBuffer);
				if(FAILED(hResult)) {
					m_lastError = L"Failed to create glyph coord buffer";
				}
				else {
					D3D11_SHADER_RESOURCE_VIEW_DESC bufferSRVDesc;
					ID3D11ShaderResourceView *pBufferSRV;
					
					ZeroMemory(&bufferSRVDesc, sizeof(bufferSRVDesc));
					bufferSRVDesc.Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
					bufferSRVDesc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
					bufferSRVDesc.Buffer.ElementOffset = 0;
					bufferSRVDesc.Buffer.ElementWidth = m_maxGlyphCount * 2;// Two float4 per glyphcoords
					
					hResult = m_pDevice->CreateShaderResourceView(pBuffer, &bufferSRVDesc, &pBufferSRV);
					if(FAILED(hResult)) {
						m_lastError = L"Failed to create shader resource view for glyph coord buffer";
					}
					else {
						m_pCoordBuffer = pBuffer;
						m_pCoordBufferSRV = pBufferSRV;
					}
					
					if(FAILED(hResult))
						pBuffer->Release();
				}
			}
			
			if(SUCCEEDED(hResult)) {
				m_pTexture = pTexture;
				m_pTextureSRV = pTextureSRV;
			}
			else
				pTextureSRV->Release();
		}
		
		if(FAILED(hResult))
			pTexture->Release();
	}
	
	return hResult;
}


// Height-range helper class, used to fit glyphs in the sheet

CFW1GlyphSheet::HeightRange::HeightRange(UINT totalWidth) : m_totalWidth(totalWidth) {
	m_heights = new UINT[m_totalWidth];
	ZeroMemory(m_heights, m_totalWidth * sizeof(UINT));
}

CFW1GlyphSheet::HeightRange::~HeightRange() {
	delete[] m_heights;
}

UINT CFW1GlyphSheet::HeightRange::findMin(UINT width, UINT *outMin) {
	if(width > m_totalWidth)
		width = m_totalWidth;
	
	UINT currentMax = findMax(0, width);
	UINT currentMin = currentMax;
	UINT minX = 0;
	
	for(UINT i=1; i < m_totalWidth-width; ++i) {
		if(m_heights[i+width-1] >= currentMax)
			currentMax = m_heights[i+width-1];
		else if(m_heights[i-1] == currentMax) {
			currentMax = findMax(i, width);
			if(currentMax < currentMin) {
				currentMin = currentMax;
				minX = i;
			}
		}
	}
	
	*outMin = currentMin;
	return minX;
}

void CFW1GlyphSheet::HeightRange::update(UINT startX, UINT width, UINT newHeight) {
	if(width > m_totalWidth)
		width = m_totalWidth;
	
	for(UINT i=0; i < width; ++i)
		m_heights[startX+i] = newHeight;
}

UINT CFW1GlyphSheet::HeightRange::findMax(UINT startX, UINT width) {
	UINT currentMax = m_heights[startX];
	for(UINT i=1; i < width; ++i)
		currentMax = std::max(currentMax, m_heights[startX+i]);
	
	return currentMax;
}


}// namespace FW1FontWrapper

```

`src/vendor/fontwrapper/CFW1GlyphSheetInterface.cpp`:

```cpp
// CFW1GlyphSheetInterface.cpp

#include <vendor/fontwrapper/FW1Precompiled.h>

#include <vendor/fontwrapper/CFW1GlyphSheet.h>


namespace FW1FontWrapper {


// Query interface
HRESULT STDMETHODCALLTYPE CFW1GlyphSheet::QueryInterface(REFIID riid, void **ppvObject) {
	if(ppvObject == NULL)
		return E_INVALIDARG;
	
	if(IsEqualIID(riid, __uuidof(IFW1GlyphSheet))) {
		*ppvObject = static_cast<IFW1GlyphSheet*>(this);
		AddRef();
		return S_OK;
	}
	
	return CFW1Object::QueryInterface(riid, ppvObject);
}


// Get the D3D11 device used by this sheet
HRESULT STDMETHODCALLTYPE CFW1GlyphSheet::GetDevice(ID3D11Device **ppDevice) {
	if(ppDevice == NULL)
		return E_INVALIDARG;
	
	m_pDevice->AddRef();
	*ppDevice = m_pDevice;
	
	return S_OK;
}


// Get sheet desc
void STDMETHODCALLTYPE CFW1GlyphSheet::GetDesc(FW1_GLYPHSHEETDESC *pDesc) {
	pDesc->GlyphCount = m_glyphCount;
	pDesc->Width = m_sheetWidth;
	pDesc->Height = m_sheetHeight;
	pDesc->MipLevels = m_mipLevelCount;
}


// Get the sheet texture
HRESULT STDMETHODCALLTYPE CFW1GlyphSheet::GetSheetTexture(ID3D11ShaderResourceView **ppSheetTextureSRV) {
	if(ppSheetTextureSRV == NULL)
		return E_INVALIDARG;
	
	m_pTextureSRV->AddRef();
	*ppSheetTextureSRV = m_pTextureSRV;
	
	return S_OK;
}


// Get the glyph coordinate buffer
HRESULT STDMETHODCALLTYPE CFW1GlyphSheet::GetCoordBuffer(ID3D11ShaderResourceView **ppCoordBufferSRV) {
	if(ppCoordBufferSRV == NULL)
		return E_INVALIDARG;
	
	if(m_pCoordBufferSRV != NULL)
		m_pCoordBufferSRV->AddRef();
	*ppCoordBufferSRV = m_pCoordBufferSRV;
	
	return S_OK;
}


// Get glyph coordinate array for all glyphs in the sheet
const FW1_GLYPHCOORDS* STDMETHODCALLTYPE CFW1GlyphSheet::GetGlyphCoords() {
	return m_glyphCoords;
}


// Set sheet shader resources
HRESULT STDMETHODCALLTYPE CFW1GlyphSheet::BindSheet(ID3D11DeviceContext *pContext, UINT Flags) {
	pContext->PSSetShaderResources(0, 1, &m_pTextureSRV);
	if((Flags & FW1_NOGEOMETRYSHADER) == 0 && m_hardwareCoordBuffer)
		pContext->GSSetShaderResources(0, 1, &m_pCoordBufferSRV);
	
	return S_OK;
}


// Insert a new glyph in the sheet
UINT STDMETHODCALLTYPE CFW1GlyphSheet::InsertGlyph(
	const FW1_GLYPHMETRICS *pGlyphMetrics,
	LPCVOID pGlyphData,
	UINT RowPitch,
	UINT PixelStride
) {
	if(m_closed)
		return 0xffffffff;
	if(m_glyphCount >= m_maxGlyphCount)
		return 0xffffffff;
	
	CriticalSectionLock lock(&m_sheetCriticalSection);
	
	if(m_closed)
		return 0xffffffff;
	if(m_glyphCount >= m_maxGlyphCount)
		return 0xffffffff;
	
	const UINT &width = pGlyphMetrics->Width;
	const UINT &height = pGlyphMetrics->Height;
	
	// Position the glyph if it fits
	UINT blockWidth = width / m_alignWidth + 1;
	if(width % m_alignWidth != 0)
		++blockWidth;
	UINT blockHeight = height / m_alignWidth + 1;
	if(height % m_alignWidth != 0)
		++blockHeight;
	
	UINT blockX;
	UINT blockY;
	UINT positionX;
	UINT positionY;
	
	if(m_glyphCount > 0 || !m_allowOversizedGlyph) {
		if(m_alignWidth + width + m_alignWidth > m_sheetWidth)
			return 0xffffffff;
		
		// Position the glyph at the lowest Y possible (fills reasonably well with different sized glyphs)
		blockX = m_heightRange->findMin(blockWidth, &blockY);
		
		positionX = m_alignWidth + blockX * m_alignWidth;
		positionY = m_alignWidth + blockY * m_alignWidth;
		
		if(positionY + height + m_alignWidth > m_sheetHeight)
			return 0xffffffff;
	}
	else {
		blockX = 0;
		blockY = 0;
		
		positionX = m_alignWidth;
		positionY = m_alignWidth;
	}
	
	m_heightRange->update(blockX, blockWidth, blockY + blockHeight);
	
	// Store glyph coordinates
	FLOAT coordOffset = static_cast<FLOAT>(m_alignWidth) * 0.5f;
	
	UINT alignedWidth = (blockWidth - 1) * m_alignWidth;
	UINT alignedHeight = (blockHeight - 1) * m_alignWidth;
	
	FW1_GLYPHCOORDS glyphCoords;
	glyphCoords.TexCoordLeft = (static_cast<FLOAT>(positionX) - coordOffset) / static_cast<FLOAT>(m_sheetWidth);
	glyphCoords.TexCoordTop = (static_cast<FLOAT>(positionY) - coordOffset) / static_cast<FLOAT>(m_sheetHeight);
	glyphCoords.TexCoordRight =
		(static_cast<FLOAT>(positionX + alignedWidth) + coordOffset) / static_cast<FLOAT>(m_sheetWidth);
	glyphCoords.TexCoordBottom =
		(static_cast<FLOAT>(positionY + alignedHeight) + coordOffset) / static_cast<FLOAT>(m_sheetHeight);
	glyphCoords.PositionLeft = pGlyphMetrics->OffsetX - coordOffset;
	glyphCoords.PositionTop = pGlyphMetrics->OffsetY - coordOffset;
	glyphCoords.PositionRight = pGlyphMetrics->OffsetX + static_cast<FLOAT>(alignedWidth) + coordOffset;
	glyphCoords.PositionBottom = pGlyphMetrics->OffsetY + static_cast<FLOAT>(alignedHeight) + coordOffset;
	
	UINT glyphIndex = m_glyphCount;
	
	m_glyphCoords[glyphIndex] = glyphCoords;
	
	// Glyph pixels
	for(UINT i=0; i < height && i < m_sheetHeight-positionY; ++i) {
		const UINT8 *src = static_cast<const UINT8*>(pGlyphData) + i*RowPitch;
		UINT8 *dst = m_textureData + (positionY+i)*m_sheetWidth + positionX;
		for(UINT j=0; j < width && j < m_sheetWidth-positionX; ++j)
			dst[j] = src[j*PixelStride];
	}
	
	// Update dirty rect to be flushed to device texture
	if(m_updatedGlyphCount == 0) {
		m_dirtyRect.left = positionX - m_alignWidth;
		m_dirtyRect.top = positionY - m_alignWidth;
		m_dirtyRect.right = std::min(positionX + width + m_alignWidth, m_sheetWidth);
		m_dirtyRect.bottom = std::min(positionY + height + m_alignWidth, m_sheetHeight);
	}
	else {
		m_dirtyRect.left = std::min(m_dirtyRect.left, positionX - m_alignWidth);
		m_dirtyRect.top = std::min(m_dirtyRect.top, positionY - m_alignWidth);
		m_dirtyRect.right = std::min(std::max(m_dirtyRect.right, positionX + width + m_alignWidth), m_sheetWidth);
		m_dirtyRect.bottom = std::min(std::max(m_dirtyRect.bottom, positionY + height + m_alignWidth), m_sheetHeight);
	}
	
	_WriteBarrier();
	MemoryBarrier();
	
	++m_glyphCount;
	++m_updatedGlyphCount;
	
	return glyphIndex;
}


// Disallow insertion of additional glyphs in this sheet
void STDMETHODCALLTYPE CFW1GlyphSheet::CloseSheet() {
	EnterCriticalSection(&m_sheetCriticalSection);
	m_closed = true;
	LeaveCriticalSection(&m_sheetCriticalSection);
}


// Flush any inserted glyphs
void STDMETHODCALLTYPE CFW1GlyphSheet::Flush(ID3D11DeviceContext *pContext) {
	EnterCriticalSection(&m_flushCriticalSection);
	if(!m_static) {
		EnterCriticalSection(&m_sheetCriticalSection);
		
		UINT glyphCount = m_glyphCount;
		RectUI dirtyRect = m_dirtyRect;
		
		UINT updatedGlyphCount = m_updatedGlyphCount;
		m_updatedGlyphCount = 0;
		
		if(m_closed)
			m_static = true;
		
		LeaveCriticalSection(&m_sheetCriticalSection);
		
		if(updatedGlyphCount > 0) {
			// Update coord buffer
			if(m_hardwareCoordBuffer) {
				UINT startIndex = glyphCount - updatedGlyphCount;
				UINT endIndex = glyphCount;
				
				D3D11_BOX dstBox;
				ZeroMemory(&dstBox, sizeof(dstBox));
				dstBox.left = startIndex * sizeof(FW1_GLYPHCOORDS);
				dstBox.right = endIndex * sizeof(FW1_GLYPHCOORDS);
				dstBox.top = 0;
				dstBox.bottom = 1;
				dstBox.front = 0;
				dstBox.back = 1;
				
				pContext->UpdateSubresource(
					m_pCoordBuffer,
					0,
					&dstBox,
					m_glyphCoords + startIndex,
					0,
					0
				);
			}
			
			// Update texture
			if(dirtyRect.right > dirtyRect.left && dirtyRect.bottom > dirtyRect.top) {
				UINT8 *srcMem = m_textureData;
				
				D3D11_BOX dstBox;
				ZeroMemory(&dstBox, sizeof(dstBox));
				dstBox.left = dirtyRect.left;
				dstBox.right = dirtyRect.right;
				dstBox.top = dirtyRect.top;
				dstBox.bottom = dirtyRect.bottom;
				dstBox.front = 0;
				dstBox.back = 1;
				
				// Update each mip-level
				for(UINT i=0; i < m_mipLevelCount; ++i) {
					pContext->UpdateSubresource(
						m_pTexture,
						D3D11CalcSubresource(i, 0, m_mipLevelCount),
						&dstBox,
						srcMem + dstBox.top * (m_sheetWidth >> i) + dstBox.left,
						m_sheetWidth >> i,
						0
					);
					
					if(i+1 < m_mipLevelCount) {
						UINT8 *nextMip = srcMem + (m_sheetWidth >> i) * (m_sheetHeight >> i);
						
						dstBox.left >>= 1;
						dstBox.right >>= 1;
						dstBox.top >>= 1;
						dstBox.bottom >>= 1;
						
						// Calculate the next mip-level for the current dirty-rect
						for(UINT j = dstBox.top; j < dstBox.bottom; ++j) {
							const UINT8 *src0 = srcMem + j * 2 * (m_sheetWidth >> i);
							const UINT8 *src1 = src0 + (m_sheetWidth >> i);
							UINT8 *dst = nextMip + j * (m_sheetWidth >> (i+1));
							
							for(UINT k = dstBox.left; k < dstBox.right; ++k) {
								UINT src = src0[k*2] + src0[k*2+1] + src1[k*2] + src1[k*2+1];
								dst[k] = static_cast<UINT8>(src >> 2);
							}
						}
						
						srcMem = nextMip;
					}
				}
			}
		}
		
		// This sheet is now static, save some memory
		if(m_static) {
			delete[] m_textureData;
			m_textureData = 0;
		}
	}
	
	LeaveCriticalSection(&m_flushCriticalSection);
}


}// namespace FW1FontWrapper

```

`src/vendor/fontwrapper/CFW1GlyphVertexDrawer.cpp`:

```cpp
// CFW1GlyphVertexDrawer.cpp

#include <vendor/fontwrapper/FW1Precompiled.h>

#include <vendor/fontwrapper/CFW1GlyphVertexDrawer.h>

#define SAFE_RELEASE(pObject) { if(pObject) { (pObject)->Release(); (pObject) = NULL; } }


namespace FW1FontWrapper {


// Construct
CFW1GlyphVertexDrawer::CFW1GlyphVertexDrawer() :
	m_pDevice(NULL),
	
	m_pVertexBuffer(NULL),
	m_pIndexBuffer(NULL),
	m_vertexBufferSize(0),
	m_maxIndexCount(0)
{
}


// Destruct
CFW1GlyphVertexDrawer::~CFW1GlyphVertexDrawer() {
	SAFE_RELEASE(m_pDevice);
	
	SAFE_RELEASE(m_pVertexBuffer);
	SAFE_RELEASE(m_pIndexBuffer);
}


// Init
HRESULT CFW1GlyphVertexDrawer::initVertexDrawer(
	IFW1Factory *pFW1Factory,
	ID3D11Device *pDevice,
	UINT vertexBufferSize
) {
	HRESULT hResult = initBaseObject(pFW1Factory);
	if(FAILED(hResult))
		return hResult;
	
	if(pDevice == NULL)
		return E_INVALIDARG;
	
	pDevice->AddRef();
	m_pDevice = pDevice;
	D3D_FEATURE_LEVEL featureLevel = m_pDevice->GetFeatureLevel();
	
	m_vertexBufferSize = 4096 * 16;
	if(vertexBufferSize >= 1024) {
		if(featureLevel < D3D_FEATURE_LEVEL_9_2)
			vertexBufferSize = std::min(vertexBufferSize, 512U*1024U);
		m_vertexBufferSize = vertexBufferSize;
	}
	
	m_maxIndexCount = (m_vertexBufferSize * 3) / (2 * sizeof(QuadVertex));
	if(m_maxIndexCount < 64)
		m_maxIndexCount = 64;
	
	// Create device buffers
	hResult = createBuffers();
	
	if(SUCCEEDED(hResult))
		hResult = S_OK;
	
	return hResult;
}


// Create vertex/index buffers
HRESULT CFW1GlyphVertexDrawer::createBuffers() {
	// Create vertex buffer
	D3D11_BUFFER_DESC vertexBufferDesc;
	ID3D11Buffer *pVertexBuffer;
	
	ZeroMemory(&vertexBufferDesc, sizeof(vertexBufferDesc));
	vertexBufferDesc.ByteWidth = m_vertexBufferSize;
	vertexBufferDesc.Usage = D3D11_USAGE_DYNAMIC;
	vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
	vertexBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
	
	HRESULT hResult = m_pDevice->CreateBuffer(&vertexBufferDesc, NULL, &pVertexBuffer);
	if(FAILED(hResult)) {
		m_lastError = L"Failed to create vertex buffer";
	}
	else {
		// Create index buffer
		D3D11_BUFFER_DESC indexBufferDesc;
		D3D11_SUBRESOURCE_DATA initData;
		ID3D11Buffer *pIndexBuffer;
		
		ZeroMemory(&indexBufferDesc, sizeof(indexBufferDesc));
		indexBufferDesc.ByteWidth = sizeof(UINT16) * m_maxIndexCount;
		indexBufferDesc.Usage = D3D11_USAGE_IMMUTABLE;
		indexBufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;
		
		UINT16 *indices = new UINT16[m_maxIndexCount];
		for(UINT i=0; i < m_maxIndexCount/6; ++i) {
			indices[i*6] = static_cast<UINT16>(i*4);
			indices[i*6+1] = static_cast<UINT16>(i*4+1);
			indices[i*6+2] = static_cast<UINT16>(i*4+2);
			indices[i*6+3] = static_cast<UINT16>(i*4+1);
			indices[i*6+4] = static_cast<UINT16>(i*4+3);
			indices[i*6+5] = static_cast<UINT16>(i*4+2);
		}
		
		ZeroMemory(&initData, sizeof(initData));
		initData.pSysMem = indices;
		
		hResult = m_pDevice->CreateBuffer(&indexBufferDesc, &initData, &pIndexBuffer);
		if(FAILED(hResult)) {
			m_lastError = L"Failed to create index buffer";
		}
		else {
			// Success
			m_pVertexBuffer = pVertexBuffer;
			m_pIndexBuffer = pIndexBuffer;
			
			hResult = S_OK;
		}
		
		delete[] indices;
		
		if(FAILED(hResult))
			pVertexBuffer->Release();
	}
	
	return hResult;
}


// Draw vertices
UINT CFW1GlyphVertexDrawer::drawVertices(
	ID3D11DeviceContext *pContext,
	IFW1GlyphAtlas *pGlyphAtlas,
	const FW1_VERTEXDATA *vertexData,
	UINT preboundSheet
) {
	if(vertexData->SheetCount == 0 || vertexData->TotalVertexCount == 0)
		return preboundSheet;
	
	UINT maxVertexCount = m_vertexBufferSize / sizeof(FW1_GLYPHVERTEX);
	
	UINT currentSheet = 0;
	UINT activeSheet = preboundSheet;
	UINT currentVertex = 0;
	UINT nextSheetStart = vertexData->pVertexCounts[0];
	
	while(currentVertex < vertexData->TotalVertexCount) {
		// Fill the vertex buffer
		UINT vertexCount = std::min(vertexData->TotalVertexCount - currentVertex, maxVertexCount);
		
		D3D11_MAPPED_SUBRESOURCE msr;
		HRESULT hResult = pContext->Map(m_pVertexBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &msr);
		if(SUCCEEDED(hResult)) {
			CopyMemory(msr.pData, vertexData->pVertices + currentVertex, vertexCount * sizeof(FW1_GLYPHVERTEX));
			
			pContext->Unmap(m_pVertexBuffer, 0);
			
			// Draw all glyphs in the buffer
			UINT drawnVertices = 0;
			while(drawnVertices < vertexCount) {
				while(currentVertex >= nextSheetStart) {
					++currentSheet;
					nextSheetStart += vertexData->pVertexCounts[currentSheet];
				}
				
				if(currentSheet != activeSheet) {
					// Bind sheet shader resources
					pGlyphAtlas->BindSheet(pContext, currentSheet, 0);
					activeSheet = currentSheet;
				}
				
				UINT drawCount = std::min(vertexCount - drawnVertices, nextSheetStart - currentVertex);
				pContext->Draw(drawCount, drawnVertices);
				
				drawnVertices += drawCount;
				currentVertex += drawCount;
			}
		}
		else
			break;
	}
	
	return activeSheet;
}


// Draw vertices as quads
UINT CFW1GlyphVertexDrawer::drawGlyphsAsQuads(
	ID3D11DeviceContext *pContext,
	IFW1GlyphAtlas *pGlyphAtlas,
	const FW1_VERTEXDATA *vertexData,
	UINT preboundSheet
) {
	if(vertexData->SheetCount == 0 || vertexData->TotalVertexCount == 0)
		return preboundSheet;
	
	UINT maxVertexCount = m_vertexBufferSize / sizeof(QuadVertex);
	if(maxVertexCount > 4 * (m_maxIndexCount / 6))
		maxVertexCount = 4 * (m_maxIndexCount / 6);
	if(maxVertexCount % 4 != 0)
		maxVertexCount -= (maxVertexCount % 4);
	
	UINT currentSheet = 0;
	UINT activeSheet = preboundSheet;
	const FW1_GLYPHCOORDS *sheetGlyphCoords = 0;
	if(activeSheet < vertexData->SheetCount)
		sheetGlyphCoords = pGlyphAtlas->GetGlyphCoords(activeSheet);
	UINT currentVertex = 0;
	UINT nextSheetStart = vertexData->pVertexCounts[0];
	
	while(currentVertex < vertexData->TotalVertexCount) {
		// Fill the vertex buffer
		UINT vertexCount = std::min((vertexData->TotalVertexCount - currentVertex) * 4, maxVertexCount);
		
		D3D11_MAPPED_SUBRESOURCE msr;
		HRESULT hResult = pContext->Map(m_pVertexBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &msr);
		if(SUCCEEDED(hResult)) {
			QuadVertex *bufferVertices = static_cast<QuadVertex*>(msr.pData);
			
			// Convert to quads when filling the buffer
			UINT savedCurrentSheet = currentSheet;
			UINT savedActiveSheet = activeSheet;
			UINT savedNextSheetStart = nextSheetStart;
			UINT savedCurrentVertex = currentVertex;
			
			UINT drawnVertices = 0;
			while(drawnVertices < vertexCount) {
				while(currentVertex >= nextSheetStart) {
					++currentSheet;
					nextSheetStart += vertexData->pVertexCounts[currentSheet];
				}
				
				if(currentSheet != activeSheet) {
					sheetGlyphCoords = pGlyphAtlas->GetGlyphCoords(currentSheet);
					activeSheet = currentSheet;
				}
				
				UINT drawCount = std::min(vertexCount - drawnVertices, (nextSheetStart - currentVertex) * 4);
				
				for(UINT i=0; i < drawCount/4; ++i) {
					FW1_GLYPHVERTEX glyphVertex = vertexData->pVertices[currentVertex + i];
					glyphVertex.PositionX = glyphVertex.PositionX;
					glyphVertex.PositionY = glyphVertex.PositionY;
					
					const FW1_GLYPHCOORDS &glyphCoords = sheetGlyphCoords[glyphVertex.GlyphIndex];
					
					QuadVertex quadVertex;
					
					quadVertex.color = glyphVertex.GlyphColor;
					
					quadVertex.positionX = glyphVertex.PositionX + glyphCoords.PositionLeft;
					quadVertex.positionY = glyphVertex.PositionY + glyphCoords.PositionTop;
					quadVertex.texCoordX = glyphCoords.TexCoordLeft;
					quadVertex.texCoordY = glyphCoords.TexCoordTop;
					bufferVertices[drawnVertices + i*4 + 0] = quadVertex;
					
					quadVertex.positionX = glyphVertex.PositionX + glyphCoords.PositionRight;
					quadVertex.texCoordX = glyphCoords.TexCoordRight;
					bufferVertices[drawnVertices + i*4 + 1] = quadVertex;
					
					quadVertex.positionY = glyphVertex.PositionY + glyphCoords.PositionBottom;
					quadVertex.texCoordY = glyphCoords.TexCoordBottom;
					bufferVertices[drawnVertices + i*4 + 3] = quadVertex;
					
					quadVertex.positionX = glyphVertex.PositionX + glyphCoords.PositionLeft;
					quadVertex.texCoordX = glyphCoords.TexCoordLeft;
					bufferVertices[drawnVertices + i*4 + 2] = quadVertex;
				}
				
				drawnVertices += drawCount;
				currentVertex += drawCount / 4;
			}
			
			pContext->Unmap(m_pVertexBuffer, 0);
			
			// Draw all glyphs in the buffer
			currentSheet = savedCurrentSheet;
			activeSheet = savedActiveSheet;
			nextSheetStart = savedNextSheetStart;
			currentVertex = savedCurrentVertex;
			
			drawnVertices = 0;
			while(drawnVertices < vertexCount) {
				while(currentVertex >= nextSheetStart) {
					++currentSheet;
					nextSheetStart += vertexData->pVertexCounts[currentSheet];
				}
				
				if(currentSheet != activeSheet) {
					// Bind sheet shader resources
					pGlyphAtlas->BindSheet(pContext, currentSheet, FW1_NOGEOMETRYSHADER);
					activeSheet = currentSheet;
				}
				
				UINT drawCount = std::min(vertexCount - drawnVertices, (nextSheetStart - currentVertex) * 4);
				pContext->DrawIndexed((drawCount/2)*3, 0, drawnVertices);
				
				drawnVertices += drawCount;
				currentVertex += drawCount / 4;
			}
		}
		else
			break;
	}
	
	return activeSheet;
}


}// namespace FW1FontWrapper

```

`src/vendor/fontwrapper/CFW1GlyphVertexDrawerInterface.cpp`:

```cpp
// CFW1GlyphVertexDrawerInterface.cpp

#include <vendor/fontwrapper/FW1Precompiled.h>

#include <vendor/fontwrapper/CFW1GlyphVertexDrawer.h>


namespace FW1FontWrapper {


// Query interface
HRESULT STDMETHODCALLTYPE CFW1GlyphVertexDrawer::QueryInterface(REFIID riid, void **ppvObject) {
	if(ppvObject == NULL)
		return E_INVALIDARG;
	
	if(IsEqualIID(riid, __uuidof(IFW1GlyphVertexDrawer))) {
		*ppvObject = static_cast<IFW1GlyphVertexDrawer*>(this);
		AddRef();
		return S_OK;
	}
	
	return CFW1Object::QueryInterface(riid, ppvObject);
}


// Get the D3D11 device used by this vetex drawer
HRESULT STDMETHODCALLTYPE CFW1GlyphVertexDrawer::GetDevice(ID3D11Device **ppDevice) {
	if(ppDevice == NULL)
		return E_INVALIDARG;
	
	m_pDevice->AddRef();
	*ppDevice = m_pDevice;
	
	return S_OK;
}


// Draw vertices
UINT STDMETHODCALLTYPE CFW1GlyphVertexDrawer::DrawVertices(
	ID3D11DeviceContext *pContext,
	IFW1GlyphAtlas *pGlyphAtlas,
	const FW1_VERTEXDATA *pVertexData,
	UINT Flags,
	UINT PreboundSheet
) {
	UINT stride;
	UINT offset = 0;
	
	if((Flags & FW1_NOGEOMETRYSHADER) == 0)
		stride = sizeof(FW1_GLYPHVERTEX);
	else {
		stride = sizeof(QuadVertex);
		if((Flags & FW1_BUFFERSPREPARED) == 0)
			pContext->IASetIndexBuffer(m_pIndexBuffer, DXGI_FORMAT_R16_UINT, 0);
	}
	if((Flags & FW1_BUFFERSPREPARED) == 0)
		pContext->IASetVertexBuffers(0, 1, &m_pVertexBuffer, &stride, &offset);
	
	if((Flags & FW1_NOGEOMETRYSHADER) == 0)
		return drawVertices(pContext, pGlyphAtlas, pVertexData, PreboundSheet);
	else
		return drawGlyphsAsQuads(pContext, pGlyphAtlas, pVertexData, PreboundSheet);
}


}// namespace FW1FontWrapper

```

`src/vendor/fontwrapper/CFW1StateSaver.cpp`:

```cpp
// CFW1StateSaver.cpp

#include <vendor/fontwrapper/FW1Precompiled.h>
#include <vendor/fontwrapper/CFW1StateSaver.h>

#define SAFE_RELEASE(pObject) { if(pObject) { (pObject)->Release(); (pObject) = NULL; } }


namespace FW1FontWrapper {


// Construct
CFW1StateSaver::CFW1StateSaver() :
	m_savedState(false),
	m_featureLevel(D3D_FEATURE_LEVEL_11_0),
	m_pContext(NULL),
	m_primitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_UNDEFINED),
	m_pInputLayout(NULL),
	m_pBlendState(NULL),
	m_sampleMask(0xffffffff),
	m_pDepthStencilState(NULL),
	m_stencilRef(0),
	m_pRasterizerState(NULL),
	m_pPSSRV(NULL),
	m_pSamplerState(NULL),
	m_pVS(NULL),
	m_numVSClassInstances(0),
	m_pVSConstantBuffer(NULL),
	m_pGS(NULL),
	m_numGSClassInstances(0),
	m_pGSConstantBuffer(NULL),
	m_pGSSRV(NULL),
	m_pPS(NULL),
	m_numPSClassInstances(0),
	m_pHS(NULL),
	m_numHSClassInstances(0),
	m_pDS(NULL),
	m_numDSClassInstances(0),
	m_pVB(NULL),
	m_vertexStride(0),
	m_vertexOffset(0),
	m_pIndexBuffer(NULL),
	m_indexFormat(DXGI_FORMAT_UNKNOWN),
	m_indexOffset(0)
{
	for(int i=0; i < 4; ++i)
		m_blendFactor[i] = 0.0f;
	for(int i=0; i < 256; ++i) {
		m_pVSClassInstances[i] = NULL;
		m_pGSClassInstances[i] = NULL;
		m_pPSClassInstances[i] = NULL;
		m_pHSClassInstances[i] = NULL;
		m_pDSClassInstances[i] = NULL;
	}
}


// Destruct
CFW1StateSaver::~CFW1StateSaver() {
	releaseSavedState();
}


// Save all states that are changed by the font-wrapper when drawing a string
HRESULT CFW1StateSaver::saveCurrentState(ID3D11DeviceContext *pContext) {
	if(m_savedState)
		releaseSavedState();
	if(pContext == NULL)
		return E_INVALIDARG;
	
	ID3D11Device *pDevice;
	pContext->GetDevice(&pDevice);
	if(pDevice != NULL) {
		m_featureLevel = pDevice->GetFeatureLevel();
		pDevice->Release();
	}
	
	pContext->AddRef();
	m_pContext = pContext;
	
	m_pContext->IAGetPrimitiveTopology(&m_primitiveTopology);
	m_pContext->IAGetInputLayout(&m_pInputLayout);
	
	m_pContext->OMGetBlendState(&m_pBlendState, m_blendFactor, &m_sampleMask);
	m_pContext->OMGetDepthStencilState(&m_pDepthStencilState, &m_stencilRef);
	
	m_pContext->RSGetState(&m_pRasterizerState);
	
	m_numVSClassInstances = 256;
	m_pContext->VSGetShader(&m_pVS, m_pVSClassInstances, &m_numVSClassInstances);
	m_pContext->VSGetConstantBuffers(0, 1, &m_pVSConstantBuffer);
	
	m_numPSClassInstances = 256;
	m_pContext->PSGetShader(&m_pPS, m_pPSClassInstances, &m_numPSClassInstances);
	m_pContext->PSGetShaderResources(0, 1, &m_pPSSRV);
	pContext->PSGetSamplers(0, 1, &m_pSamplerState);
	
	if(m_featureLevel >= D3D_FEATURE_LEVEL_10_0) {
		m_numGSClassInstances = 256;
		m_pContext->GSGetShader(&m_pGS, m_pGSClassInstances, &m_numGSClassInstances);
		m_pContext->GSGetConstantBuffers(0, 1, &m_pGSConstantBuffer);
		
		m_pContext->GSGetShaderResources(0, 1, &m_pGSSRV);
		
		if(m_featureLevel >= D3D_FEATURE_LEVEL_11_0) {
			m_numHSClassInstances = 256;
			m_pContext->HSGetShader(&m_pHS, m_pHSClassInstances, &m_numHSClassInstances);
			
			m_numDSClassInstances = 256;
			m_pContext->DSGetShader(&m_pDS, m_pDSClassInstances, &m_numDSClassInstances);
		}
	}
	
	m_pContext->IAGetVertexBuffers(0, 1, &m_pVB, &m_vertexStride, &m_vertexOffset);
	
	m_pContext->IAGetIndexBuffer(&m_pIndexBuffer, &m_indexFormat, &m_indexOffset);
	
	m_savedState = true;
	
	return S_OK;
}


// Restore state
HRESULT CFW1StateSaver::restoreSavedState() {
	if(!m_savedState)
		return E_FAIL;
	
	m_pContext->IASetPrimitiveTopology(m_primitiveTopology);
	m_pContext->IASetInputLayout(m_pInputLayout);
	
	m_pContext->OMSetBlendState(m_pBlendState, m_blendFactor, m_sampleMask);
	m_pContext->OMSetDepthStencilState(m_pDepthStencilState, m_stencilRef);
	
	m_pContext->RSSetState(m_pRasterizerState);
	
	m_pContext->VSSetShader(m_pVS, m_pVSClassInstances, m_numVSClassInstances);
	m_pContext->VSSetConstantBuffers(0, 1, &m_pVSConstantBuffer);
	
	m_pContext->PSSetShader(m_pPS, m_pPSClassInstances, m_numPSClassInstances);
	m_pContext->PSSetShaderResources(0, 1, &m_pPSSRV);
	m_pContext->PSSetSamplers(0, 1, &m_pSamplerState);
	
	if(m_featureLevel >= D3D_FEATURE_LEVEL_10_0) {
		m_pContext->GSSetShader(m_pGS, m_pGSClassInstances, m_numGSClassInstances);
		m_pContext->GSSetConstantBuffers(0, 1, &m_pGSConstantBuffer);
		
		m_pContext->GSSetShaderResources(0, 1, &m_pGSSRV);
		
		if(m_featureLevel >= D3D_FEATURE_LEVEL_11_0) {
			m_pContext->HSSetShader(m_pHS, m_pHSClassInstances, m_numHSClassInstances);
			
			m_pContext->DSSetShader(m_pDS, m_pDSClassInstances, m_numDSClassInstances);
		}
	}
	
	m_pContext->IASetVertexBuffers(0, 1, &m_pVB, &m_vertexStride, &m_vertexOffset);
	
	m_pContext->IASetIndexBuffer(m_pIndexBuffer, m_indexFormat, m_indexOffset);
	
	return S_OK;
}


// Release state
void CFW1StateSaver::releaseSavedState() {
	m_primitiveTopology = D3D11_PRIMITIVE_TOPOLOGY_UNDEFINED;
	SAFE_RELEASE(m_pInputLayout);
	SAFE_RELEASE(m_pBlendState);
	for(int i=0; i < 4; ++i)
		m_blendFactor[i] = 0.0f;
	m_sampleMask = 0xffffffff;
	SAFE_RELEASE(m_pDepthStencilState);
	m_stencilRef = 0;
	SAFE_RELEASE(m_pRasterizerState);
	SAFE_RELEASE(m_pPSSRV);
	SAFE_RELEASE(m_pSamplerState);
	SAFE_RELEASE(m_pVS);
	for(UINT i=0; i < m_numVSClassInstances; ++i)
		SAFE_RELEASE(m_pVSClassInstances[i]);
	m_numVSClassInstances = 0;
	SAFE_RELEASE(m_pVSConstantBuffer);
	SAFE_RELEASE(m_pGS);
	for(UINT i=0; i < m_numGSClassInstances; ++i)
		SAFE_RELEASE(m_pGSClassInstances[i]);
	m_numGSClassInstances = 0;
	SAFE_RELEASE(m_pGSConstantBuffer);
	SAFE_RELEASE(m_pGSSRV);
	SAFE_RELEASE(m_pPS);
	for(UINT i=0; i < m_numPSClassInstances; ++i)
		SAFE_RELEASE(m_pPSClassInstances[i]);
	m_numPSClassInstances = 0;
	SAFE_RELEASE(m_pHS);
	for(UINT i=0; i < m_numHSClassInstances; ++i)
		SAFE_RELEASE(m_pHSClassInstances[i]);
	m_numHSClassInstances = 0;
	SAFE_RELEASE(m_pDS);
	for(UINT i=0; i < m_numDSClassInstances; ++i)
		SAFE_RELEASE(m_pDSClassInstances[i]);
	m_numDSClassInstances = 0;
	SAFE_RELEASE(m_pVB);
	m_vertexStride = 0;
	m_vertexOffset = 0;
	SAFE_RELEASE(m_pIndexBuffer);
	m_indexFormat = DXGI_FORMAT_UNKNOWN;
	m_indexOffset = 0;
	
	SAFE_RELEASE(m_pContext);
	m_featureLevel = D3D_FEATURE_LEVEL_11_0;
	
	m_savedState = false;
}


}// namespace FW1FontWrapper

```

`src/vendor/fontwrapper/CFW1TextGeometry.cpp`:

```cpp
// CFW1TextGeometry.cpp

#include <vendor/fontwrapper/FW1Precompiled.h>

#include <vendor/fontwrapper/CFW1TextGeometry.h>


namespace FW1FontWrapper {


// Construct
CFW1TextGeometry::CFW1TextGeometry() :
	m_maxSheetIndex(0),
	m_sorted(false)
{
}


// Destruct
CFW1TextGeometry::~CFW1TextGeometry() {
}


// Init glyph provider
HRESULT CFW1TextGeometry::initTextGeometry(IFW1Factory *pFW1Factory) {
	HRESULT hResult = initBaseObject(pFW1Factory);
	if(FAILED(hResult))
		return hResult;
	
	return hResult;
}


}// namespace FW1FontWrapper

```

`src/vendor/fontwrapper/CFW1TextGeometryInterface.cpp`:

```cpp
// CFW1TextGeometryInterface.cpp

#include <vendor/fontwrapper/FW1Precompiled.h>

#include <vendor/fontwrapper/CFW1TextGeometry.h>


namespace FW1FontWrapper {


// Query interface
HRESULT STDMETHODCALLTYPE CFW1TextGeometry::QueryInterface(REFIID riid, void **ppvObject) {
	if(ppvObject == NULL)
		return E_INVALIDARG;
	
	if(IsEqualIID(riid, __uuidof(IFW1TextGeometry))) {
		*ppvObject = static_cast<IFW1TextGeometry*>(this);
		AddRef();
		return S_OK;
	}
	
	return CFW1Object::QueryInterface(riid, ppvObject);
}


// Clear geometry
void STDMETHODCALLTYPE CFW1TextGeometry::Clear() {
	m_vertices.clear();
	m_maxSheetIndex = 0;
	
	m_sorted = false;
}


// Add a vertex
void STDMETHODCALLTYPE CFW1TextGeometry::AddGlyphVertex(const FW1_GLYPHVERTEX *pVertex) {
	m_vertices.push_back(*pVertex);
	
	UINT sheetIndex = pVertex->GlyphIndex >> 16;
	m_maxSheetIndex = std::max(m_maxSheetIndex, sheetIndex);
	
	m_sorted = false;
}


// Get current glyph vertices
FW1_VERTEXDATA STDMETHODCALLTYPE CFW1TextGeometry::GetGlyphVerticesTemp() {
	FW1_VERTEXDATA vertexData;
	
	if(!m_vertices.empty()) {
		UINT32 sheetCount = m_maxSheetIndex + 1;
		
		// Sort and prepare vertices
		if(!m_sorted) {
			m_sortedVertices.resize(m_vertices.size());
			m_vertexCounts.resize(sheetCount);
			m_vertexStartIndices.resize(sheetCount);
			
			std::fill(m_vertexCounts.begin(), m_vertexCounts.end(), 0);
			
			UINT * const vertexCounts = &m_vertexCounts[0];
			const FW1_GLYPHVERTEX * const vertices = &m_vertices[0];
			const UINT32 vertexCount = static_cast<UINT32>(m_vertices.size());
			
			for(UINT32 i=0; i < vertexCount; ++i) {
				UINT32 sheetIndex = vertices[i].GlyphIndex >> 16;
				
				++vertexCounts[sheetIndex];
			}
			
			UINT * const vertexStartIndices = &m_vertexStartIndices[0];
			
			UINT currentStartIndex = 0;
			for(UINT32 i=0; i < sheetCount; ++i) {
				vertexStartIndices[i] = currentStartIndex;
				
				currentStartIndex += vertexCounts[i];
			}
			
			FW1_GLYPHVERTEX * const sortedVertices = &m_sortedVertices[0];
			
			for(UINT32 i=0; i < vertexCount; ++i) {
				const FW1_GLYPHVERTEX &vertex = vertices[i];
				UINT32 sheetIndex = vertex.GlyphIndex >> 16;
				
				UINT &vertexIndex = vertexStartIndices[sheetIndex];
				
				sortedVertices[vertexIndex] = vertex;
				sortedVertices[vertexIndex].GlyphIndex &= 0xffff;
				
				++vertexIndex;
			}
			
			m_sorted = true;
		}
		
		vertexData.SheetCount = sheetCount;
		vertexData.pVertexCounts = &m_vertexCounts[0];
		vertexData.TotalVertexCount = static_cast<UINT>(m_vertices.size());
		vertexData.pVertices = &m_sortedVertices[0];
	}
	else {
		vertexData.SheetCount = 0;
		vertexData.pVertexCounts = 0;
		vertexData.TotalVertexCount = 0;
		vertexData.pVertices = 0;
	}
	
	return vertexData;
}


}// namespace FW1FontWrapper

```

`src/vendor/fontwrapper/CFW1TextRenderer.cpp`:

```cpp
// CFW1TextRenderer.cpp

#include <vendor/fontwrapper/FW1Precompiled.h>

#include <vendor/fontwrapper/CFW1TextRenderer.h>

#define SAFE_RELEASE(pObject) { if(pObject) { (pObject)->Release(); (pObject) = NULL; } }


namespace FW1FontWrapper {


// Construct
CFW1TextRenderer::CFW1TextRenderer() :
	m_pGlyphProvider(NULL),
	
	m_currentFlags(0),
	m_currentColor(0xff000000),
	
	m_cachedGlyphMap(0),
	m_pCachedGlyphMapFontFace(NULL),
	m_cachedGlyphMapFontSize(0),
	
	m_pDWriteTextRendererProxy(0)
{
}


// Destruct
CFW1TextRenderer::~CFW1TextRenderer() {
	SAFE_RELEASE(m_pGlyphProvider);
	
	delete m_pDWriteTextRendererProxy;
}


// Init
HRESULT CFW1TextRenderer::initTextRenderer(
	IFW1Factory *pFW1Factory,
	IFW1GlyphProvider *pGlyphProvider
) {
	HRESULT hResult = initBaseObject(pFW1Factory);
	if(FAILED(hResult))
		return hResult;
	
	if(pGlyphProvider == NULL)
		return E_INVALIDARG;
	
	pGlyphProvider->AddRef();
	m_pGlyphProvider = pGlyphProvider;
	
	m_pDWriteTextRendererProxy = new CDWriteTextRendererProxy(this);
	
	return S_OK;
}


}// namespace FW1FontWrapper

```

`src/vendor/fontwrapper/CFW1TextRendererInterface.cpp`:

```cpp
// CFW1TextRendererInterface.cpp

#include <vendor/fontwrapper/FW1Precompiled.h>

#include <vendor/fontwrapper/CFW1TextRenderer.h>


namespace FW1FontWrapper {


// Query interface
HRESULT STDMETHODCALLTYPE CFW1TextRenderer::QueryInterface(REFIID riid, void **ppvObject) {
	if(ppvObject == NULL)
		return E_INVALIDARG;
	
	if(IsEqualIID(riid, __uuidof(IDWritePixelSnapping))) {
		*ppvObject = static_cast<IDWritePixelSnapping*>(m_pDWriteTextRendererProxy);
		AddRef();
		return S_OK;
	}
	else if(IsEqualIID(riid, __uuidof(IDWriteTextRenderer))) {
		*ppvObject = static_cast<IDWriteTextRenderer*>(m_pDWriteTextRendererProxy);
		AddRef();
		return S_OK;
	}
	else if(IsEqualIID(riid, __uuidof(IFW1TextRenderer))) {
		*ppvObject = static_cast<IFW1TextRenderer*>(this);
		AddRef();
		return S_OK;
	}
	
	return CFW1Object::QueryInterface(riid, ppvObject);
}


// IDWritePixelSnapping method
HRESULT CFW1TextRenderer::IsPixelSnappingDisabled(
	void *clientDrawingContext,
	BOOL *isDisabled
) {
	clientDrawingContext;
	
	*isDisabled = FALSE;
	
	return S_OK;
}


// IDWritePixelSnapping method
HRESULT CFW1TextRenderer::GetCurrentTransform(
	void *clientDrawingContext,
	DWRITE_MATRIX *transform
) {
	clientDrawingContext;
	
	transform->dx = 0.0f;
	transform->dy = 0.0f;
	transform->m11 = 1.0f;
	transform->m12 = 0.0f;
	transform->m21 = 0.0f;
	transform->m22 = 1.0f;
	
	return S_OK;
}


// IDWritePixelSnapping method
HRESULT CFW1TextRenderer::GetPixelsPerDip(void *clientDrawingContext, FLOAT *pixelsPerDip) {
	clientDrawingContext;
	
	*pixelsPerDip = 96.0f;
	
	return S_OK;
}


// IDWriteTextRenderer method
// Convert a run of glyphs to vertices
HRESULT CFW1TextRenderer::DrawGlyphRun(
	void *clientDrawingContext,
	FLOAT baselineOriginX,
	FLOAT baselineOriginY,
	DWRITE_MEASURING_MODE measuringMode,
	const DWRITE_GLYPH_RUN *glyphRun,
	const DWRITE_GLYPH_RUN_DESCRIPTION *glyphRunDescription,
	IUnknown *clientDrawingEffect
) {
	glyphRunDescription;
	measuringMode;
	
	const UINT flags = m_currentFlags;
	
	// Get glyph map for the current font
	const void *glyphMap;
	if(glyphRun->fontFace == m_pCachedGlyphMapFontFace && glyphRun->fontEmSize == m_cachedGlyphMapFontSize)
		glyphMap = m_cachedGlyphMap;
	else {
		glyphMap = m_pGlyphProvider->GetGlyphMapFromFont(glyphRun->fontFace, glyphRun->fontEmSize, flags);
		
		// Cache the glyph map as it's likely to be used in subsequent glyph runs
		m_cachedGlyphMap = glyphMap;
		m_pCachedGlyphMapFontFace = glyphRun->fontFace;
		m_cachedGlyphMapFontSize = glyphRun->fontEmSize;
	}
	
	// Skip if not interested in the actual glyphs
	if((flags & FW1_ANALYZEONLY) != 0)
		return S_OK;
	
	if((flags & FW1_CACHEONLY) != 0) {
		// Only request the glyphs from the provider to have them drawn to the atlas
		for(UINT i=0; i < glyphRun->glyphCount; ++i) {
			UINT atlasId = m_pGlyphProvider->GetAtlasIdFromGlyphIndex(
				glyphMap,
				glyphRun->glyphIndices[i],
				glyphRun->fontFace,
				flags
			);
			atlasId;
		}
	}
	else {
		// Glyph vertex
		FW1_GLYPHVERTEX glyphVertex;
		glyphVertex.PositionY = floor(baselineOriginY + 0.5f);
		glyphVertex.GlyphColor = m_currentColor;
		
		float positionX = floor(baselineOriginX + 0.5f);
		
		// Optional drawing effect
		if(clientDrawingEffect != NULL) {
			IFW1ColorRGBA *pColor;
			HRESULT hResult = clientDrawingEffect->QueryInterface(&pColor);
			if(SUCCEEDED(hResult)) {
				glyphVertex.GlyphColor = pColor->GetColor32();
				pColor->Release();
			}
		}
		
		// Add a vertex for each glyph in the run
		IFW1TextGeometry *pTextGeometry = static_cast<IFW1TextGeometry*>(clientDrawingContext);
		if(pTextGeometry != NULL) {
			for(UINT i=0; i < glyphRun->glyphCount; ++i) {
				glyphVertex.GlyphIndex = m_pGlyphProvider->GetAtlasIdFromGlyphIndex(
					glyphMap,
					glyphRun->glyphIndices[i],
					glyphRun->fontFace,
					flags
				);
				
				if((glyphRun->bidiLevel & 0x1) != 0)
					positionX -= glyphRun->glyphAdvances[i];
				
				glyphVertex.PositionX = floor(positionX + 0.5f);
				pTextGeometry->AddGlyphVertex(&glyphVertex);
				
				if((glyphRun->bidiLevel & 0x1) == 0)
					positionX += glyphRun->glyphAdvances[i];
			}
		}
	}
	
	return S_OK;
}


// IDWriteTextRenderer method
HRESULT CFW1TextRenderer::DrawUnderline(
	void *clientDrawingContext,
	FLOAT baselineOriginX,
	FLOAT baselineOriginY,
	const DWRITE_UNDERLINE *underline,
	IUnknown *clientDrawingEffect
) {
	clientDrawingContext;
	baselineOriginX;
	baselineOriginY;
	underline;
	clientDrawingEffect;
	
	return E_NOTIMPL;
}


// IDWriteTextRenderer method
HRESULT CFW1TextRenderer::DrawStrikethrough(
	void *clientDrawingContext,
	FLOAT baselineOriginX,
	FLOAT baselineOriginY,
	const DWRITE_STRIKETHROUGH *strikethrough,
	IUnknown *clientDrawingEffect
) {
	clientDrawingContext;
	baselineOriginX;
	baselineOriginY;
	strikethrough;
	clientDrawingEffect;
	
	return E_NOTIMPL;
}


// IDWriteTextRenderer method
HRESULT CFW1TextRenderer::DrawInlineObject(
	void *clientDrawingContext,
	FLOAT originX,
	FLOAT originY,
	IDWriteInlineObject *inlineObject,
	BOOL isSideways,
	BOOL isRightToLeft,
	IUnknown *clientDrawingEffect
) {
	clientDrawingContext;
	originX;
	originY;
	inlineObject;
	isSideways;
	isRightToLeft;
	clientDrawingEffect;
	
	return E_NOTIMPL;
}


// Get glyph provider
HRESULT STDMETHODCALLTYPE CFW1TextRenderer::GetGlyphProvider(IFW1GlyphProvider **ppGlyphProvider) {
	if(ppGlyphProvider == NULL)
		return E_INVALIDARG;
	
	m_pGlyphProvider->AddRef();
	*ppGlyphProvider = m_pGlyphProvider;
	
	return S_OK;
}


// Draw a text layout
HRESULT STDMETHODCALLTYPE CFW1TextRenderer::DrawTextLayout(
	IDWriteTextLayout *pTextLayout,
	FLOAT OriginX,
	FLOAT OriginY,
	UINT32 Color,
	UINT Flags,
	IFW1TextGeometry *pTextGeometry
) {
	m_currentFlags = Flags;
	m_currentColor = Color;
	
	m_cachedGlyphMap = 0;
	m_pCachedGlyphMapFontFace = NULL;
	m_cachedGlyphMapFontSize = 0.0f;
	
	return pTextLayout->Draw(pTextGeometry, m_pDWriteTextRendererProxy, OriginX, OriginY);
}


}// namespace FW1FontWrapper

```

`src/vendor/fontwrapper/FW1FontWrapper.cpp`:

```cpp
// FW1FontWrapper.cpp

#include <vendor/fontwrapper/FW1Precompiled.h>

#include <vendor/fontwrapper/CFW1Factory.h>

#ifndef FW1_DELAYLOAD_DWRITE_DLL
	#pragma comment (lib, "DWrite.lib")
#endif

#ifndef FW1_DELAYLOAD_D3DCOMPILER_XX_DLL
	#pragma comment (lib, "DWrite.lib")
#endif

#ifdef FW1_COMPILETODLL
	#ifndef _M_X64
		#pragma comment (linker, "/EXPORT:FW1CreateFactory=_FW1CreateFactory@8,@1")
	#endif
#endif


// Create FW1 factory
extern "C" HRESULT STDMETHODCALLTYPE FW1CreateFactory(UINT32 Version, IFW1Factory **ppFactory) {
	if(Version != FW1_VERSION)
		return E_FAIL;
	
	if(ppFactory == NULL)
		return E_INVALIDARG;
	
	FW1FontWrapper::CFW1Factory *pFactory = new FW1FontWrapper::CFW1Factory;
	HRESULT hResult = pFactory->initFactory();
	if(FAILED(hResult)) {
		pFactory->Release();
	}
	else {
		*ppFactory = pFactory;
		
		hResult = S_OK;
	}
	
	return hResult;
}

```

`src/vendor/fontwrapper/FW1Precompiled.cpp`:

```cpp
// FW1Precompiled.cpp

#include <vendor/fontwrapper/FW1Precompiled.h>


```