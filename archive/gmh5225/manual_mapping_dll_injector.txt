Project Path: arc_gmh5225_manual_mapping_dll_injector_9gaap3x_

Source Tree:

```txt
arc_gmh5225_manual_mapping_dll_injector_9gaap3x_
├── NT Defs.h
├── NT Funcs.h
├── README.md
├── Win10.h
├── Win11.h
├── Win7.h
├── Win8.h
├── Win81.h
├── dll_main.cpp
├── externs.hpp
├── globals.hpp
├── hijack_handle.cpp
├── hijack_handle.hpp
├── hijack_thread.cpp
├── hook_scanner.cpp
├── hook_scanner.hpp
├── import_handler.cpp
├── import_handler.hpp
├── includes.hpp
├── inject_internal.cpp
├── inject_internal.hpp
├── injection.cpp
├── injection.hpp
├── manual_map.cpp
├── manual_map.hpp
├── manual_mapping_injector.sln
├── manual_mapping_injector.vcxproj
├── manual_mapping_injector.vcxproj.filters
├── namespaces.hpp
├── nt_create_thread_ex.cpp
├── process_info.cpp
├── process_info.hpp
├── start_routine.cpp
├── start_routine.hpp
├── symbol_loader.cpp
├── symbol_loader.hpp
├── symbol_parser.cpp
├── symbol_parser.hpp
├── tools.cpp
├── tools.hpp
├── veh_shell.cpp
└── veh_shell.hpp

```

`NT Defs.h`:

```h
#pragma once

#include "includes.hpp"

#pragma region nt (un)defines

#ifndef NT_FAIL
#define NT_FAIL(status) (status < 0)
#endif

#ifndef NT_SUCCESS
#define NT_SUCCESS(status) (status >= 0)
#endif

#ifdef memmove
#undef memmove
#endif

#ifdef RtlZeroMemory
#undef RtlZeroMemory
#endif

#define THREAD_CREATE_FLAGS_CREATE_SUSPENDED	0x00000001
#define THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH	0x00000002 //broken?!
#define THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER	0x00000004

#define OBJ_CASE_INSENSITIVE 0x00000040

#define STATUS_SUCCESS				0x00000000
#define STATUS_UNSUCCESSFUL			0xC0000001
#define STATUS_NOT_IMPLEMENTED		0xC0000002
#define STATUS_INFO_LENGTH_MISMATCH 0xC0000004
#define STATUS_ALREADY_COMMITTED    0xC0000021

#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020

#define InitializeObjectAttributes(p, n, a, r, s) \
{ \
	(p)->Length = sizeof(OBJECT_ATTRIBUTES); \
	(p)->RootDirectory				= r; \
	(p)->Attributes					= a; \
	(p)->ObjectName					= n; \
	(p)->SecurityDescriptor			= s; \
	(p)->SecurityQualityOfService	= NULL; \
}

struct PEB;

typedef PEB* PPEB;
typedef LONG KPRIORITY;

#define KUSER_SHARED_DATA (DWORD)0x7FFE0000
#define P_KUSER_SHARED_DATA_COOKIE (DWORD*)(KUSER_SHARED_DATA + 0x0330)

#define NtCurrentProcess() ( (HANDLE)(LONG_PTR) -1 ) 

#pragma endregion

#pragma region enums

typedef enum class _PROCESSINFOCLASS
{
	ProcessBasicInformation			= 0,
	ProcessSessionInformation		= 24,
	ProcessWow64Information			= 26,
	ProcessCookie					= 36,
	ProcessProtectionInformation	= 61
} PROCESSINFOCLASS;

typedef enum class _SYSTEM_INFORMATION_CLASS {

	SystemBasicInformation,
	SystemProcessorInformation,
	SystemPerformanceInformation,
	SystemTimeOfDayInformation,
	SystemPathInformation,
	SystemProcessInformation,
	SystemCallCountInformation,
	SystemDeviceInformation,
	SystemProcessorPerformanceInformation,
	SystemFlagsInformation,
	SystemCallTimeInformation,
	SystemModuleInformation,
	SystemLocksInformation,
	SystemStackTraceInformation,
	SystemPagedPoolInformation,
	SystemNonPagedPoolInformation,
	SystemHandleInformation,
	SystemObjectInformation,
	SystemPageFileInformation,
	SystemVdmInstemulInformation,
	SystemVdmBopInformation,
	SystemFileCacheInformation,
	SystemPoolTagInformation,
	SystemInterruptInformation,
	SystemDpcBehaviorInformation,
	SystemFullMemoryInformation,
	SystemLoadGdiDriverInformation,
	SystemUnloadGdiDriverInformation,
	SystemTimeAdjustmentInformation,
	SystemSummaryMemoryInformation,
	SystemNextEventIdInformation,
	SystemEventIdsInformation,
	SystemCrashDumpInformation,
	SystemExceptionInformation,
	SystemCrashDumpStateInformation,
	SystemKernelDebuggerInformation,
	SystemContextSwitchInformation,
	SystemRegistryQuotaInformation,
	SystemExtendServiceTableInformation,
	SystemPrioritySeperation,
	SystemPlugPlayBusInformation,
	SystemDockInformation,
	SystemPowerInformation,
	SystemProcessorSpeedInformation,
	SystemCurrentTimeZoneInformation,
	SystemLookasideInformation

} SYSTEM_INFORMATION_CLASS, * PSYSTEM_INFORMATION_CLASS;

typedef enum class _THREADINFOCLASS
{
	ThreadBasicInformation			= 0,
	ThreadQuerySetWin32StartAddress = 9
} THREADINFOCLASS;

typedef enum class _THREAD_STATE
{
	Running = 0x02,
	Waiting = 0x05
} THREAD_STATE;

typedef enum class _KWAIT_REASON
{
	Executive,
	FreePage,
	PageIn,
	PoolAllocation,
	DelayExecution,
	Suspended,
	UserRequest,
	WrExecutive,
	WrFreePage,
	WrPageIn,
	WrPoolAllocation,
	WrDelayExecution,
	WrSuspended,
	WrUserRequest,
	WrEventPair,
	WrQueue,
	WrLpcReceive,
	WrLpcReply,
	WrVirtualMemory,
	WrPageOut,
	WrRendezvous,
	Spare2,
	Spare3,
	Spare4,
	Spare5,
	Spare6,
	WrKernel,
	MaximumWaitReason
} KWAIT_REASON;

typedef enum class _OBEJECT_TYPE_NUMBER
{
	Process = 0x07
} OBJECT_TYPE_NUMBER;

typedef enum _FILE_INFORMATION_CLASS
{
	FileStandardInformation = 5,
	FilePositionInformation = 14
} FILE_INFORMATION_CLASS, * PFILE_INFORMATION_CLASS;

typedef enum _LDR_DDAG_STATE : int
{
	LdrModulesMerged					= -5,
	LdrModulesInitError					= -4,
	LdrModulesSnapError					= -3,
	LdrModulesUnloaded					= -2,
	LdrModulesUnloading					= -1,
	LdrModulesPlaceHolder				= 0,
	LdrModulesMapping					= 1,
	LdrModulesMapped					= 2,
	LdrModulesWaitingForDependencies	= 3,
	LdrModulesSnapping					= 4,
	LdrModulesSnapped					= 5,
	LdrModulesCondensed					= 6,
	LdrModulesReadyToInit				= 7,
	LdrModulesInitializing				= 8,
	LdrModulesReadyToRun				= 9
} LDR_DDAG_STATE, * PLDR_DDAG_STATE;

typedef enum _LDR_DLL_LOAD_REASON : int
{
	LoadReasonUnknown						= -1,
	LoadReasonStaticDependency				= 0,
	LoadReasonStaticForwarderDependency		= 1,
	LoadReasonDynamicForwarderDependency	= 2,
	LoadReasonDelayloadDependency			= 3,
	LoadReasonDynamicLoad					= 4,
	LoadReasonAsImageLoad					= 5,
	LoadReasonAsDataLoad					= 6,
	LoadReasonEnclavePrimary				= 7,
	LoadReasonEnclaveDependency				= 8
} LDR_DLL_LOAD_REASON, * PLDR_DLL_LOAD_REASON;

typedef enum _SECTION_INHERIT
{
	ViewShare = 1,
	ViewUnmap = 2
} SECTION_INHERIT, * PSECTION_INHERIT;

typedef enum _LDR_HOT_PATCH_STATE
{
    LdrHotPatchBaseImage		= 0,
    LdrHotPatchNotApplied		= 1,
    LdrHotPatchAppliedReverse	= 2,
    LdrHotPatchAppliedForward	= 3,
    LdrHotPatchFailedToPatch	= 4,
    LdrHotPatchStateMax			= 5
} LDR_HOT_PATCH_STATE, *PLDR_HOT_PATCH_STATE;

#pragma endregion

typedef struct _ANSI_STRING
{
	USHORT	Length;
	USHORT	MaxLength;
	char *	szBuffer;
} ANSI_STRING, * PANSI_STRING;

typedef struct _UNICODE_STRING
{
	WORD		Length;
	WORD		MaxLength;
	wchar_t *	szBuffer;
} UNICODE_STRING, * PUNICODE_STRING;

typedef struct _RTL_BALANCED_NODE
{
	union
	{
		struct _RTL_BALANCED_NODE * Children[2];
		struct
		{
			struct _RTL_BALANCED_NODE * Left;
			struct _RTL_BALANCED_NODE * Right;
		};
	};

	union
	{
		UCHAR Red		: 1;
		UCHAR Balance	: 2;
		ULONG_PTR ParentValue;
	};
} RTL_BALANCED_NODE, * PRTL_BALANCED_NODE;

typedef struct _RTL_RB_TREE
{
	RTL_BALANCED_NODE * Root;
	RTL_BALANCED_NODE * Min;
} RTL_RB_TREE, * PRTL_RB_TREE;

typedef struct _CLIENT_ID
{
	HANDLE UniqueProcess;
	HANDLE UniqueThread;
} CLIENT_ID, * PCLIENT_ID;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
	WORD		UniqueProcessId;
	WORD		CreateBackTraceIndex;
	BYTE		ObjectTypeIndex;
	BYTE		HandleAttributes;
	WORD		HandleValue;
	void	*	Object;
	ULONG		GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
	ULONG NumberOfHandles;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

typedef struct _THREAD_BASIC_INFORMATION
{
	NTSTATUS	ExitStatus;
	PVOID		TebBaseAddress;
	CLIENT_ID	ClientId;
	KAFFINITY	AffinityMask;
	KPRIORITY	Priority;
	KPRIORITY	BasePriority;
} THREAD_BASIC_INFORMATION, * PTHREAD_BASIC_INFORMATION;

typedef struct _PROCESS_BASIC_INFORMATION
{
	NTSTATUS	ExitStatus;
	PEB	*		pPEB;
	ULONG_PTR	AffinityMask;
	LONG		BasePriority;
	HANDLE		UniqueProcessId;
	HANDLE		InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION, * PPROCESS_BASIC_INFORMATION;

typedef struct _PROCESS_SESSION_INFORMATION
{
	ULONG SessionId;
} PROCESS_SESSION_INFORMATION, * PPROCESS_SESSION_INFORMATION;

typedef struct _SYSTEM_THREAD_INFORMATION
{
	LARGE_INTEGER	KernelTime;
	LARGE_INTEGER	UserTime;
	LARGE_INTEGER	CreateTime;
	ULONG			WaitTime;
	PVOID			StartAddress;
	CLIENT_ID		ClientId;
	KPRIORITY		Priority;
	LONG			BasePriority;
	ULONG			ContextSwitches;
	THREAD_STATE	ThreadState;
	KWAIT_REASON	WaitReason;
} SYSTEM_THREAD_INFORMATION, * PSYSTEM_THREAD_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFORMATION
{
	ULONG			NextEntryOffset;
	ULONG			NumberOfThreads;
	LARGE_INTEGER	WorkingSetPrivateSize;
	ULONG			HardFaultCount;
	ULONG			NumberOfThreadsHighWatermark;
	ULONGLONG		CycleTime;
	LARGE_INTEGER	CreateTime;
	LARGE_INTEGER	UserTime;
	LARGE_INTEGER	KernelTime;
	UNICODE_STRING	ImageName;
	KPRIORITY		BasePriority;
	HANDLE			UniqueProcessId;
	HANDLE			InheritedFromUniqueProcessId;
	ULONG			HandleCount;
	ULONG			SessionId;
	ULONG_PTR		UniqueProcessKey;
	SIZE_T			PeakVirtualSize;
	SIZE_T			VirtualSize;
	ULONG			PageFaultCount;
	SIZE_T 			PeakWorkingSetSize;
	SIZE_T			WorkingSetSize;
	SIZE_T			QuotaPeakPagedPoolUsage;
	SIZE_T 			QuotaPagedPoolUsage;
	SIZE_T 			QuotaPeakNonPagedPoolUsage;
	SIZE_T 			QuotaNonPagedPoolUsage;
	SIZE_T 			PagefileUsage;
	SIZE_T 			PeakPagefileUsage;
	SIZE_T 			PrivatePageCount;
	LARGE_INTEGER	ReadOperationCount;
	LARGE_INTEGER	WriteOperationCount;
	LARGE_INTEGER	OtherOperationCount;
	LARGE_INTEGER 	ReadTransferCount;
	LARGE_INTEGER	WriteTransferCount;
	LARGE_INTEGER	OtherTransferCount;
	SYSTEM_THREAD_INFORMATION Threads[1];
} SYSTEM_PROCESS_INFORMATION, * PSYSTEM_PROCESS_INFORMATION;

typedef struct _FILE_STANDARD_INFORMATION
{
	LARGE_INTEGER AllocationSize;
	LARGE_INTEGER EndOfFile;
	ULONG         NumberOfLinks;
	BOOLEAN       DeletePending;
	BOOLEAN       Directory;
} FILE_STANDARD_INFORMATION, * PFILE_STANDARD_INFORMATION;

typedef struct _FILE_POSITION_INFORMATION
{
	LARGE_INTEGER CurrentByteOffset;
} FILE_POSITION_INFORMATION, * PFILE_POSITION_INFORMATION;

typedef struct _OBJECT_ATTRIBUTES
{
	ULONG				Length;
	HANDLE				RootDirectory;
	UNICODE_STRING *	ObjectName;
	ULONG				Attributes;
	PVOID				SecurityDescriptor;
	PVOID				SecurityQualityOfService;
}  OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES;

typedef struct _IO_STATUS_BLOCK
{
	union
	{
		NTSTATUS	Status;
		PVOID		Pointer;
	} DUMMYUNIONNAME;

	ULONG_PTR Information;
} IO_STATUS_BLOCK, * PIO_STATUS_BLOCK;
                
typedef struct _PEB_LDR_DATA
{
	ULONG		Length;
	ULONG		Initialized; // may be BOOLEAN but in my system this 4 bytes long
	HANDLE		SsHandle;
	LIST_ENTRY	InLoadOrderModuleListHead;
	LIST_ENTRY	InMemoryOrderModuleListHead;
	LIST_ENTRY	InInitializationOrderModuleListHead;
	PVOID		EntryInProgress;
	BYTE		ShutdownInProgress;
	HANDLE		ShutdownThreadId;
} PEB_LDR_DATA, * PPEB_LDR_DATA;

struct PEB
{
	BOOLEAN InheritedAddressSpace;
	BOOLEAN ReadImageFileExecOptions;
	BOOLEAN BeingDebugged;

	union
	{
		UCHAR BitField;
		struct
		{
			UCHAR ImageUsedLargePages			: 1;
			UCHAR IsProtectedProcess			: 1;
			UCHAR IsImageDynamicallyRelocated	: 1;
			UCHAR SkipPatchingUser32Forwarders	: 1;
			UCHAR IsPackagedProcess				: 1;
			UCHAR IsAppContainer				: 1;
			UCHAR IsProtectedProcessLight		: 1;
			UCHAR IsLongPathAwareProcess		: 1;
		};
	};

	HANDLE Mutant;

	PVOID ImageBaseAddress;

	PEB_LDR_DATA * Ldr;

	PVOID					*	ProcessParameters;
	PVOID						SubSystemData;
	HANDLE						ProcessHeap;
	RTL_CRITICAL_SECTION	*	FastPebLock;
	PVOID						AtlThunkSListPtr;
	PVOID						IFEOKey;

	union
	{
		ULONG CrossProcessFlags;
		struct
		{
			ULONG ProcessInJob					: 1;
			ULONG ProcessInitializing			: 1;
			ULONG ProcessUsingVEH				: 1;
			ULONG ProcessUsingVCH				: 1;
			ULONG ProcessUsingFTH				: 1;
			ULONG ProcessPreviouslyThrottled	: 1;
			ULONG ProcessCurrentlyThrottled		: 1;
			ULONG ProcessImagesHotPatched		: 1;
			ULONG ReservedBits0					: 24;
		};
	};

#ifdef _WIN64
	UCHAR Padding1[4];
#endif

	union
	{
		PVOID KernelCallbackTable;
		PVOID UserSharedInfoPtr;
	};

	ULONG SystemReserved;
	ULONG AtlThunkSListPtr32;
	PVOID ApiSetMap;
	ULONG TlsExpansionCounter;

#ifdef _WIN64
	UCHAR Padding2[4];
#endif

	PVOID TlsBitmap;
	ULONG TlsBitmapBits[2];
	PVOID ReadOnlySharedMemoryBase;

	union
	{
		PVOID HotpatchInformation;	// till Win8
		PVOID SparePvoid0;			// Win8.1 -> Win10 (1607)
		PVOID SharedData;			// Win10 (1703) +
	};

	PVOID * ReadOnlyStaticServerData;
	PVOID AnsiCodePageData;
	PVOID OemCodePageData;
	PVOID UnicodeCaseTableData;
	ULONG NumberOfProcessors;
	ULONG NtGlobalFlag;
	LARGE_INTEGER CriticalSectionTimeout;
	ULONG_PTR HeapSegmentReserve;
	ULONG_PTR HeapSegmentCommit;
	ULONG_PTR HeapDeCommitTotalFreeThreshold;
	ULONG_PTR HeapDeCommitFreeBlockThreshold;
	ULONG NumberOfHeaps;
	ULONG MaximumNumberOfHeaps;
	PVOID * ProcessHeaps;
	PVOID GdiSharedHandleTable;
	PVOID ProcessStarterHelper;
	ULONG GdiDCAttributeList;

#ifdef _WIN64
	UCHAR Padding3[4];
#endif

	RTL_CRITICAL_SECTION * LoaderLock;
	ULONG OSMajorVersion;
	ULONG OSMinorVersion;

	USHORT OSBuildNumber;
	USHORT OSCSDVersion;
};

typedef struct _LDR_SERVICE_TAG_RECORD
{
	struct _LDR_SERVICE_TAG_RECORD * Next;
	ULONG ServiceTag;
} LDR_SERVICE_TAG_RECORD, * PLDR_SERVICE_TAG_RECORD;

typedef struct _LDRP_CSLIST
{
	struct _SINGLE_LIST_ENTRY * Tail;
} LDRP_CSLIST, * PLDRP_CSLIST;

typedef struct _LDRP_UNICODE_STRING_BUNDLE
{
	UNICODE_STRING	String;
	WCHAR			StaticBuffer[128];
} LDRP_UNICODE_STRING_BUNDLE, * PLDRP_UNICODE_STRING_BUNDLE;

typedef struct _RTL_INVERTED_FUNCTION_TABLE_ENTRY
{
	IMAGE_RUNTIME_FUNCTION_ENTRY *	ExceptionDirectory;
	PVOID							ImageBase;
	ULONG							ImageSize;
	ULONG							ExceptionDirectorySize;
} RTL_INVERTED_FUNCTION_TABLE_ENTRY, * PRTL_INVERTED_FUNCTION_TABLE_ENTRY;

typedef struct _RTL_INVERTED_FUNCTION_TABLE
{
	ULONG Count;
	ULONG MaxCount;
	ULONG Epoch;
	UCHAR Overflow;
	RTL_INVERTED_FUNCTION_TABLE_ENTRY Entries[ANYSIZE_ARRAY];
} RTL_INVERTED_FUNCTION_TABLE, * PRTL_INVERTED_FUNCTION_TABLE;

typedef union _LDR_SEARCH_PATH
{
	BOOLEAN NoPath : 1;
	wchar_t * szSearchPath;
} LDR_SEARCH_PATH, * PLDR_SEARCH_PATH;

//Win10 1511
typedef struct _LDRP_PATH_SEARCH_CONTEXT_1511
{
	wchar_t *	DllSearchPathOut;
	void	*	Unknown_0[2];
	wchar_t *	OriginalFullDllName;
	void	*	unknown_1[7];
	ULONG64		unknown_2[4];
} LDRP_PATH_SEARCH_CONTEXT_1511, * PLDRP_PATH_SEARCH_CONTEXT_1511; //x86 size = 0x4C, x64 size = 0x78

//Win10 1507, 1607+
typedef struct _LDRP_PATH_SEARCH_CONTEXT
{
	wchar_t *	DllSearchPathOut;
	void	*	Unknown_0[3];
	wchar_t *	OriginalFullDllName;
	void	*	unknown_1[7];
	ULONG64		unknown_2[4];
} LDRP_PATH_SEARCH_CONTEXT, * PLDRP_PATH_SEARCH_CONTEXT; //x86 size <= 0x50, x64 size <= 0x80

typedef union _LDRP_LOAD_CONTEXT_FLAGS
{
	ULONG32 Flags;
	struct
	{
		ULONG32 Redirected					: 1;
		ULONG32 Static						: 1;
		ULONG32 BaseNameOnly				: 1;
		ULONG32 HasFullPath					: 1;
		ULONG32 KnownDll					: 1;
		ULONG32 SystemImage					: 1;
		ULONG32 ExecutableImage				: 1;
		ULONG32 AppContainerImage			: 1;
		ULONG32 CallInit					: 1;
		ULONG32 UserAllocated				: 1;
		ULONG32 SearchOnlyFirstPathSegment	: 1;
		ULONG32 RedirectedByAPISet			: 1;
	};
} LDRP_LOAD_CONTEXT_FLAGS, * PLDRP_LOAD_CONTEXT_FLAGS;

typedef struct _RTL_VECTORED_HANDLER_LIST
{
	SRWLOCK     Lock;
	LIST_ENTRY  List;
} RTL_VECTORED_HANDLER_LIST, * PRTL_VECTORED_HANDLER_LIST;

typedef struct _RTL_VECTORED_EXCEPTION_ENTRY //Win7 till Win10 1909
{
	LIST_ENTRY					List;
	DWORD						Flag;
	PVECTORED_EXCEPTION_HANDLER	VectoredHandler;
} RTL_VECTORED_EXCEPTION_ENTRY, * PRTL_VECTORED_EXCEPTION_ENTRY;

typedef struct _RTL_VECTORED_EXCEPTION_ENTRY_WIN10_2004 //Win10 2004+
{
	LIST_ENTRY                  List;
	PULONG_PTR                  pFlag; //points to Flag
	ULONG                       RefCount;
	PVECTORED_EXCEPTION_HANDLER VectoredHandler;
	ULONG_PTR					Flag; //normally allocated somewhere else on LdrpMrdataHeap, just for convenience
} RTL_VECTORED_EXCEPTION_ENTRY_WIN10_2004, * PRTL_VECTORED_EXCEPTION_ENTRY_WIN10_2004;

typedef struct _TLS_ENTRY
{
	LIST_ENTRY				TlsEntryLinks;
	IMAGE_TLS_DIRECTORY		TlsDirectory;
	PVOID 					ModuleEntry; //LdrDataTableEntry
	SIZE_T					TlsIndex;
} TLS_ENTRY, * PTLS_ENTRY;

typedef struct _TEB
{
	NT_TIB                  Tib;
	PVOID                   EnvironmentPointer;
	CLIENT_ID               Cid;
	PVOID                   ActiveRpcInfo;
	PVOID                   ThreadLocalStoragePointer;
	PPEB                    Peb;
	ULONG                   LastErrorValue;
	ULONG                   CountOfOwnedCriticalSections;
	PVOID                   CsrClientThread;
	PVOID                   Win32ThreadInfo;
	ULONG                   Win32ClientInfo[0x1F];
	PVOID                   WOW32Reserved;
	ULONG                   CurrentLocale;
	ULONG                   FpSoftwareStatusRegister;
	PVOID                   SystemReserved1[0x36];
	PVOID                   Spare1;
	ULONG                   ExceptionCode;
	ULONG                   SpareBytes1[0x28];
	PVOID                   SystemReserved2[0xA];
	ULONG                   GdiRgn;
	ULONG                   GdiPen;
	ULONG                   GdiBrush;
	CLIENT_ID               RealClientId;
	PVOID                   GdiCachedProcessHandle;
	ULONG                   GdiClientPID;
	ULONG                   GdiClientTID;
	PVOID                   GdiThreadLocaleInfo;
	PVOID                   UserReserved[5];
	PVOID                   GlDispatchTable[0x118];
	ULONG                   GlReserved1[0x1A];
	PVOID                   GlReserved2;
	PVOID                   GlSectionInfo;
	PVOID                   GlSection;
	PVOID                   GlTable;
	PVOID                   GlCurrentRC;
	PVOID                   GlContext;
	NTSTATUS                LastStatusValue;
	UNICODE_STRING          StaticUnicodeString;
	WCHAR                   StaticUnicodeBuffer[0x105];
	PVOID                   DeallocationStack;
	PVOID                   TlsSlots[0x40];
	LIST_ENTRY              TlsLinks;
	PVOID                   Vdm;
	PVOID                   ReservedForNtRpc;
	PVOID                   DbgSsReserved[0x2];
	ULONG                   HardErrorDisabled;
	PVOID                   Instrumentation[0x10];
	PVOID                   WinSockData;
	ULONG                   GdiBatchCount;
	ULONG                   Spare2;
	ULONG                   Spare3;
	ULONG                   Spare4;
	PVOID                   ReservedForOle;
	ULONG                   WaitingOnLoaderLock;
	PVOID                   StackCommit;
	PVOID                   StackCommitMax;
	PVOID                   StackReserved;

} TEB, * PTEB;

typedef struct _PUBLIC_OBJECT_BASIC_INFORMATION {
	ULONG       Attributes;
	ACCESS_MASK GrantedAccess;
	ULONG       HandleCount;
	ULONG       PointerCount;
	ULONG       Reserved[10];
} PUBLIC_OBJECT_BASIC_INFORMATION, * PPUBLIC_OBJECT_BASIC_INFORMATION;

typedef enum _OBJECT_INFORMATION_CLASS {
	ObjectBasicInformation,
	ObjectTypeInformation
} OBJECT_INFORMATION_CLASS;

#ifdef _WIN64

typedef __declspec(align(4)) struct _UNICODE_STRING_32
{
	WORD	Length;
	WORD	MaxLength;
	DWORD	szBuffer;
} UNICODE_STRING_32, * PUNICODE_STRING_32;

typedef __declspec(align(4)) struct _RTL_BALANCED_NODE_32
{
	union
	{
		DWORD Children[2];
		struct
		{
			DWORD Left;
			DWORD Right;
		};
	};

	union
	{
		UCHAR Red		: 1;
		UCHAR Balance	: 2;
		DWORD ParentValue;
	};
} RTL_BALANCED_NODE_32, * PRTL_BALANCED_NODE_32;

typedef struct _SINGLE_LIST_ENTRY_32
{
	DWORD Next; // -> SINGLE_LIST_ENTRY_32
} SINGLE_LIST_ENTRY_32, * PSINGLE_LIST_ENTRY_32;

typedef __declspec(align(4)) struct _LDR_SERVICE_TAG_RECORD_32
{
	DWORD Next; // -> LDR_SERVICE_TAG_RECORD_32
	ULONG ServiceTag;
} LDR_SERVICE_TAG_RECORD_32, * PLDR_SERVICE_TAG_RECORD_32;

typedef __declspec(align(4)) struct _LDRP_CSLIST_32
{
	DWORD Tail; // -> SINGLE_LIST_ENTRY_32
} LDRP_CSLIST_32, * PLDRP_CSLIST_32;

typedef __declspec(align(4)) struct _RTL_CRITICAL_SECTION_32
{
	DWORD	DebugInfo; // -> RTL_CRITICAL_SECTION_DEBUG_32
	LONG	LockCount;
	LONG	RecursionCount;
	DWORD	OwningThread;
	DWORD	LockSemaphore;
	DWORD	SpinCount;
} RTL_CRITICAL_SECTION_32, * PRTL_CRITICAL_SECTION_32;

typedef __declspec(align(4)) struct _RTL_CRITICAL_SECTION_DEBUG_32
{
	WORD			Type;
	WORD			CreatorBackTraceIndex;
	DWORD			CriticalSection; // -> RTL_CRITICAL_SECTION_32
	LIST_ENTRY32	ProcessLocksList;
	DWORD			EntryCount;
	DWORD			ContentionCount;
	DWORD			Flags;
	WORD			CreatorBackTraceIndexHigh;
	WORD			SpareWORD;
} RTL_CRITICAL_SECTION_DEBUG_32, * PRTL_CRITICAL_SECTION_DEBUG_32, _RTL_RESOURCE_DEBUG_32, RTL_RESOURCE_DEBUG_32, * PRTL_RESOURCE_DEBUG_32;

typedef __declspec(align(4)) struct _PEB_LDR_DATA_32
{
	ULONG			Length;
	BYTE			Initialized;
	DWORD			SsHandle;
	LIST_ENTRY32	InLoadOrderModuleListHead;
	LIST_ENTRY32	InMemoryOrderModuleListHead;
	LIST_ENTRY32	InInitializationOrderModuleListHead;
	DWORD			EntryInProgress;
	BYTE			ShutdownInProgress;
	DWORD			ShutdownThreadId;
} PEB_LDR_DATA_32, * PPEB_LDR_DATA_32;

typedef struct _PEB_32
{
	BOOLEAN InheritedAddressSpace;
	BOOLEAN ReadImageFileExecOptions;
	BOOLEAN BeingDebugged;

	union
	{
		UCHAR BitField;
		struct
		{
			UCHAR ImageUsedLargePages			: 1;
			UCHAR IsProtectedProcess			: 1;
			UCHAR IsImageDynamicallyRelocated	: 1;
			UCHAR SkipPatchingUser32Forwarders	: 1;
			UCHAR IsPackagedProcess				: 1;
			UCHAR IsAppContainer				: 1;
			UCHAR IsProtectedProcessLight		: 1;
			UCHAR IsLongPathAwareProcess		: 1;
		};
	};

	DWORD Mutant;

	DWORD ImageBaseAddress;
	DWORD Ldr; // -> PEB_LDR_DATA_32

	DWORD ProcessParameters;
	DWORD SubSystemData;
	DWORD ProcessHeap;
	DWORD FastPebLock; // -> RTL_CRITICAL_SECTION_32
	DWORD AtlThunkSListPtr;
	DWORD IFEOKey;

	union
	{
		ULONG CrossProcessFlags;
		struct
		{
			ULONG ProcessInJob					: 1;
			ULONG ProcessInitializing			: 1;
			ULONG ProcessUsingVEH				: 1;
			ULONG ProcessUsingVCH				: 1;
			ULONG ProcessUsingFTH				: 1;
			ULONG ProcessPreviouslyThrottled	: 1;
			ULONG ProcessCurrentlyThrottled		: 1;
			ULONG ProcessImagesHotPatched		: 1;
			ULONG ReservedBits0					: 24;
		};
	};

	union
	{
		DWORD KernelCallbackTable;
		DWORD UserSharedInfoPtr;
	};

	ULONG SystemReserved;
	ULONG AtlThunkSListPtr32;
	DWORD ApiSetMap;
	ULONG TlsExpansionCounter;

	DWORD TlsBitmap;
	ULONG TlsBitmapBits[2];
	DWORD ReadOnlySharedMemoryBase;

	union
	{
		DWORD HotpatchInformation;	// till Win8
		DWORD SparePvoid0;			// Win8.1 -> Win10 (1607)
		DWORD SharedData;			// Win10 (1703) +
	};

	DWORD ReadOnlyStaticServerData;
	DWORD AnsiCodePageData;
	DWORD OemCodePageData;
	DWORD UnicodeCaseTableData;
	ULONG NumberOfProcessors;
	ULONG NtGlobalFlag;
	LARGE_INTEGER CriticalSectionTimeout;
	DWORD HeapSegmentReserve;
	DWORD HeapSegmentCommit;
	DWORD HeapDeCommitTotalFreeThreshold;
	DWORD HeapDeCommitFreeBlockThreshold;
	ULONG NumberOfHeaps;
	ULONG MaximumNumberOfHeaps;
	DWORD ProcessHeaps;
	DWORD GdiSharedHandleTable;
	DWORD ProcessStarterHelper;
	ULONG GdiDCAttributeList;

	DWORD LoaderLock; // -> RTL_CRITICAL_SECTION_32
	ULONG OSMajorVersion;
	ULONG OSMinorVersion;
	USHORT OSBuildNumber;
	USHORT OSCSDVersion;
} PEB_32, * PPEB_32;

typedef __declspec(align(4)) struct _LDRP_UNICODE_STRING_BUNDLE_32
{
	UNICODE_STRING_32	String;
	WCHAR				StaticBuffer[128];
} LDRP_UNICODE_STRING_BUNDLE_32, * PLDRP_UNICODE_STRING_BUNDLE_32;

typedef __declspec(align(4)) struct _LDRP_PATH_SEARCH_CONTEXT_32 //dummy structure, needs to be at least 0x50 bytes in size, members don't matter
{
	DWORD DllSearchPathOut; // wchar_t *
	DWORD unknown_0[3];
	DWORD OriginalFullDllName; // wchar_t *
	DWORD unknown_1[15];
} LDRP_PATH_SEARCH_CONTEXT_32, * PLDRP_PATH_SEARCH_CONTEXT_32;

typedef __declspec(align(4)) struct _RTL_INVERTED_FUNCTION_TABLE_ENTRY_32
{
	DWORD ExceptionDirectory; // -> IMAGE_RUNTIME_FUNCTION_ENTRY
	DWORD ImageBase;
	ULONG ImageSize;
	ULONG ExceptionDirectorySize;
} RTL_INVERTED_FUNCTION_TABLE_ENTRY_32, * PRTL_INVERTED_FUNCTION_TABLE_ENTRY_32;

typedef __declspec(align(4)) struct _RTL_INVERTED_FUNCTION_TABLE_32
{
	ULONG Count;
	ULONG MaxCount;
	ULONG Epoch;
	UCHAR Overflow;
	RTL_INVERTED_FUNCTION_TABLE_ENTRY_32 Entries[ANYSIZE_ARRAY];
} RTL_INVERTED_FUNCTION_TABLE_32, * PRTL_INVERTED_FUNCTION_TABLE_32;

typedef __declspec(align(4)) union _LDRP_PATH_SEARCH_OPTIONS_32
{
	ULONG32 Flags;

	struct
	{
		ULONG32 Unknown;
	};
} LDRP_PATH_SEARCH_OPTIONS_32, * PLDRP_PATH_SEARCH_OPTIONS_32;

typedef __declspec(align(4)) union _LDRP_LOAD_CONTEXT_FLAGS_32
{
	ULONG32 Flags;
	struct
	{
		ULONG32 Redirected					: 1;
		ULONG32 BaseNameOnly				: 1;
		ULONG32 HasFullPath					: 1;
		ULONG32 KnownDll					: 1;
		ULONG32 SystemImage					: 1;
		ULONG32 ExecutableImage				: 1;
		ULONG32 AppContainerImage			: 1;
		ULONG32 CallInit					: 1;
		ULONG32 UserAllocated				: 1;
		ULONG32 SearchOnlyFirstPathSegment	: 1;
		ULONG32 RedirectedByAPISet			: 1;
	};
} LDRP_LOAD_CONTEXT_FLAGS_32, * PLDRP_LOAD_CONTEXT_FLAGS_32;

typedef struct _RTL_VECTORED_HANDLER_LIST_32
{
	DWORD			Lock;
	LIST_ENTRY32	List;
} RTL_VECTORED_HANDLER_LIST_32, * PRTL_VECTORED_HANDLER_LIST_32;

typedef struct _RTL_VECTORED_EXCEPTION_ENTRY_32 //Win7 till Win10 1909
{
	LIST_ENTRY32	List;
	DWORD			Flag;
	DWORD			VectoredHandler;
} RTL_VECTORED_EXCEPTION_ENTRY_32, * PRTL_VECTORED_EXCEPTION_ENTRY_32;

typedef struct _RTL_VECTORED_EXCEPTION_ENTRY_WIN10_2004_32 //Win10 2004+
{
	LIST_ENTRY32	List;
	DWORD			pFlag; //DWORD *
	ULONG			RefCount;
	DWORD			VectoredHandler; //PVECTORED_EXCEPTION_HANDLER
	DWORD			Flag;
} RTL_VECTORED_EXCEPTION_ENTRY_WIN10_2004_32, * PRTL_VECTORED_EXCEPTION_ENTRY_WIN10_2004_32;

#endif
```

`NT Funcs.h`:

```h
#pragma once

#include "Win7.h"
#include "Win8.h"
#include "Win81.h"
#include "Win10.h"
#include "Win11.h"

#define DEF_STRUCT_DEFAULT(name, suffix)	\
using name		= name##suffix;				\
using P##name	= P##name##suffix;			\
using _##name	= _##name##suffix;

#define DEF_STRUCT_DEFAULT_32(name, suffix)	\
using name##_32		= name##suffix##_32;	\
using P##name##_32	= P##name##suffix##_32;	\
using _##name##_32	= _##name##suffix##_32;

#ifndef _WIN32_WINNT
	#error Not supported
#else
	#if(_WIN32_WINNT == _WIN32_WINNT_WIN7)
		DEF_STRUCT_DEFAULT(LDR_DATA_TABLE_ENTRY, _WIN7)
		DEF_STRUCT_DEFAULT(LDR_DDAG_NODE, _WIN7)

		#ifdef _WIN64
			DEF_STRUCT_DEFAULT_32(LDR_DATA_TABLE_ENTRY, _WIN7)
			DEF_STRUCT_DEFAULT_32(LDR_DDAG_NODE, _WIN7)
		#endif
	#elif (_WIN32_WINNT == _WIN32_WINNT_WIN8)
		DEF_STRUCT_DEFAULT(LDR_DATA_TABLE_ENTRY, _WIN8)
		DEF_STRUCT_DEFAULT(LDR_DDAG_NODE, _WIN8)

		#ifdef _WIN64
			DEF_STRUCT_DEFAULT_32(LDR_DATA_TABLE_ENTRY, _WIN8)
			DEF_STRUCT_DEFAULT_32(LDR_DDAG_NODE, _WIN8)
		#endif
	#elif (_WIN32_WINNT == _WIN32_WINNT_WINBLUE)
		DEF_STRUCT_DEFAULT(LDR_DATA_TABLE_ENTRY, _WIN81)
		DEF_STRUCT_DEFAULT(LDR_DDAG_NODE, _WIN81)

		#ifdef _WIN64
			DEF_STRUCT_DEFAULT_32(LDR_DATA_TABLE_ENTRY, _WIN81)
			DEF_STRUCT_DEFAULT_32(LDR_DDAG_NODE, _WIN81)
		#endif
	#elif (_WIN32_WINNT == _WIN32_WINNT_WIN10) //includes Win11
		#if (WDK_NTDDI_VERSION == NTDDI_WIN10_CO) //Win11 SDK is called NTDDI_WIN10_CO
			DEF_STRUCT_DEFAULT(LDR_DATA_TABLE_ENTRY, _WIN11)
			DEF_STRUCT_DEFAULT(LDR_DDAG_NODE, _WIN11)

			#ifdef _WIN64
				DEF_STRUCT_DEFAULT_32(LDR_DATA_TABLE_ENTRY, _WIN11)
				DEF_STRUCT_DEFAULT_32(LDR_DDAG_NODE, _WIN11)
			#endif
		#else
			DEF_STRUCT_DEFAULT(LDR_DATA_TABLE_ENTRY, _WIN10)
			DEF_STRUCT_DEFAULT(LDR_DDAG_NODE, _WIN10)

			#ifdef _WIN64
				DEF_STRUCT_DEFAULT_32(LDR_DATA_TABLE_ENTRY, _WIN10)
				DEF_STRUCT_DEFAULT_32(LDR_DDAG_NODE, _WIN10)
			#endif
		#endif
	#else
		#error Not supported
	#endif
#endif

#pragma region function prototypes

using f_NtCreateThreadEx = NTSTATUS (__stdcall *)	
(
	HANDLE		*	pHandle, 
	ACCESS_MASK		DesiredAccess, 
	void		*	pAttr, 
	HANDLE			hTargetProc, 
	void		*	pFunc, 
	void		*	pArg,
	ULONG			Flags, 
	SIZE_T			ZeroBits, 
	SIZE_T			StackSize, 
	SIZE_T			MaxStackSize, 
	void		*	pAttrListOut
);

using f_LdrLoadDll = NTSTATUS (__stdcall *)
(
	LDR_SEARCH_PATH		ldrSearchPath,
	ULONG			*	pFlags,
	UNICODE_STRING	*	pModuleFileName, 
	HANDLE			*	pOut
);

using f_LdrLoadDll_WIN8 = NTSTATUS (__stdcall *)
(
	BOOLEAN Unknown1, //set to TRUE
	ULONG * LoadFlags,
	UNICODE_STRING	*	pModuleFileName,
	HANDLE			*	pOut
);

using f_LdrUnloadDll = NTSTATUS (__stdcall *)
(
	HANDLE DllHandle
);

using f_LdrpLoadDll_WIN7 = NTSTATUS (__stdcall *)
(
	UNICODE_STRING				*	dll_path,
	UNICODE_STRING				*	search_path,
	LDRP_LOAD_CONTEXT_FLAGS			Flags,
	BOOLEAN							Unknown1, //set to TRUE
	PVOID							Unknown2, //can be nullptr
	LDR_DATA_TABLE_ENTRY_WIN7	**	ldr_out
);

using f_LdrpLoadDll_WIN8 = NTSTATUS (__stdcall *)
(
	UNICODE_STRING					*	dll_path,
	LDRP_PATH_SEARCH_CONTEXT_WIN8	*	search_ctx,
	LDRP_LOAD_CONTEXT_FLAGS				Flags,
	BOOLEAN								Unknown, //set to TRUE
	LDR_DATA_TABLE_ENTRY_WIN8		**	entry_out,
	LDR_DDAG_NODE_WIN8				**	ddag_out
);

using f_LdrpLoadDll_WIN81 = NTSTATUS (__fastcall *)
(
	UNICODE_STRING					*	dll_path,
	LDRP_PATH_SEARCH_CONTEXT_WIN81	*	search_ctx,
	LDRP_LOAD_CONTEXT_FLAGS				Flags,
	BOOLEAN								Unknown, //set to TRUE
	LDR_DATA_TABLE_ENTRY_WIN81		**	entry_out,
	LDR_DDAG_NODE_WIN81				**	ddag_out
);

//1507-1803
using f_LdrpLoadDll_1507 = NTSTATUS (__fastcall *)
(
	UNICODE_STRING				*	dll_path,
	LDRP_PATH_SEARCH_CONTEXT	*	search_path,
	LDRP_LOAD_CONTEXT_FLAGS			Flags,
	BOOLEAN							bUnknown, //set to TRUE
	LDR_DATA_TABLE_ENTRY_WIN10	**	ldr_out
);

//1809+
using f_LdrpLoadDll = NTSTATUS (__fastcall *)
(
	UNICODE_STRING				*	dll_path, 
	LDRP_PATH_SEARCH_CONTEXT	*	search_path,
	LDRP_LOAD_CONTEXT_FLAGS			Flags,
	LDR_DATA_TABLE_ENTRY		**	ldr_out
);

using f_LdrpLoadDllInternal = NTSTATUS (__fastcall *)
(
	UNICODE_STRING				*	dll_path, 
	LDRP_PATH_SEARCH_CONTEXT	*	search_path,
	LDRP_LOAD_CONTEXT_FLAGS			Flags,
	ULONG32							Unknown0,	//set to 4
	LDR_DATA_TABLE_ENTRY_WIN10	*	Unknown1,	//set to nullptr
	LDR_DATA_TABLE_ENTRY_WIN10	*	Unknown2,	//set to nullptr
	LDR_DATA_TABLE_ENTRY_WIN10	**	ldr_out,
	ULONG_PTR					*	Unknown3	//set to pointer to nullptr
);

using f_LdrpLoadDllInternal_WIN11 = NTSTATUS (__fastcall *)
(
	UNICODE_STRING				*	dll_path, 
	LDRP_PATH_SEARCH_CONTEXT	*	search_path,
	LDRP_LOAD_CONTEXT_FLAGS			Flags,
	ULONG32							Unknown0,	//set to 4
	LDR_DATA_TABLE_ENTRY_WIN11	*	Unknown1,	//set to nullptr
	LDR_DATA_TABLE_ENTRY_WIN11	*	Unknown2,	//set to nullptr
	LDR_DATA_TABLE_ENTRY_WIN11	**	ldr_out,
	ULONG_PTR					*	Unknown3,	//set to pointer to nullptr
	ULONG							Unknown4	//set to 0
);

using f_LdrGetDllHandleEx = NTSTATUS (__stdcall *)
(
	ULONG				Flags,
	PWSTR				OptDllPath,
	PULONG				OptDllCharacteristics,
	UNICODE_STRING	*	DllName,
	PVOID			*	DllHandle
);

using f_LdrGetProcedureAddress = NTSTATUS (__stdcall *)
(
	PVOID				BaseAddress,
	ANSI_STRING		*	Name,
	ULONG				Ordinal,
	PVOID			*	ProcedureAddress
);

using f_NtQueryInformationProcess = NTSTATUS (__stdcall *)
(
	HANDLE					hTargetProc, 
	PROCESSINFOCLASS		PIC, 
	void				*	pBuffer, 
	ULONG					BufferSize, 
	ULONG				*	SizeOut
);

using f_NtQuerySystemInformation = NTSTATUS	(__stdcall *)
(
	SYSTEM_INFORMATION_CLASS		SIC, 
	void						*	pBuffer, 
	ULONG							BufferSize, 
	ULONG						*	SizeOut
);

using f_NtQueryInformationThread = NTSTATUS (__stdcall *)
(
	HANDLE				hThread, 
	THREADINFOCLASS		TIC, 
	void			*	pBuffer, 
	ULONG				BufferSize, 
	ULONG			*	SizeOut
);

using f_RtlQueueApcWow64Thread = NTSTATUS (__stdcall *)
(
	HANDLE		hThread, 
	void	*	pRoutine, 
	void	*	pArg1, 
	void	*	pArg2, 
	void	*	pArg3
);

using f_LdrpPreprocessDllName = NTSTATUS (__fastcall *)
(
	UNICODE_STRING				* DllName,
	LDRP_UNICODE_STRING_BUNDLE	* OutputDllName,
	LDR_DATA_TABLE_ENTRY		* pOptParentEntry,
	LDRP_LOAD_CONTEXT_FLAGS		* LoadContextFlags
);

using f_RtlInsertInvertedFunctionTable_WIN7 = NTSTATUS (__stdcall *)
(
	RTL_INVERTED_FUNCTION_TABLE_WIN7 *	pTable,
	void *								ImageBase,
	DWORD								SizeOfImage
);

using f_RtlInsertInvertedFunctionTable_WIN8 = NTSTATUS (__stdcall *)
(
	void *	ImageBase,
	DWORD	SizeOfImage
);

using f_RtlInsertInvertedFunctionTable = BOOL (__fastcall *)
(
	void *	ImageBase,
	DWORD	SizeOfImage
);

#ifdef _WIN64
using f_RtlAddFunctionTable = BOOL (__stdcall *)
(
	RUNTIME_FUNCTION *	FunctionTable,
	DWORD				EntryCount,
	DWORD64				BaseAddress
);
#endif

using f_LdrpHandleTlsData_WIN8 = NTSTATUS (__stdcall *)
(
	LDR_DATA_TABLE_ENTRY_WIN8 * pEntry
);

using f_LdrpHandleTlsData = NTSTATUS (__fastcall *)
(
	LDR_DATA_TABLE_ENTRY * pEntry
);

using f_LdrLockLoaderLock = NTSTATUS (__stdcall *)
(
	ULONG			Flags, 
	ULONG		*	State, 
	ULONG_PTR	*	Cookie
);

using f_LdrUnlockLoaderLock = NTSTATUS (__stdcall *)
(
	ULONG		Flags, 
	ULONG_PTR	Cookie
);

using f_memmove = VOID (__cdecl *)
(
	PVOID	UNALIGNED	Destination,
	LPCVOID	UNALIGNED	Source,
	SIZE_T				Length
);

using f_RtlZeroMemory = VOID (__stdcall *)
(
	PVOID	UNALIGNED	Destination,
	SIZE_T				Length
);

using f_RtlAllocateHeap = PVOID (__stdcall *)
(
	PVOID	HeapHandle,
	ULONG	Flags,
	SIZE_T	Size
);

using f_RtlFreeHeap = BOOLEAN (__stdcall *)
(
	PVOID	HeapHandle,
	ULONG	Flags,
	PVOID	BaseAddress
);

using f_RtlAnsiStringToUnicodeString = NTSTATUS (__stdcall *)
(
	UNICODE_STRING	*	DestinationString,
	ANSI_STRING		*	SourceString,
	BOOLEAN				AllocateDestinationString
);

using f_RtlRbInsertNodeEx = VOID (__stdcall *)
(
	RTL_RB_TREE			*	Tree,
	RTL_BALANCED_NODE	*	Parent,
	BOOLEAN					Right,
	RTL_BALANCED_NODE	*	Node
);

using f_RtlRbRemoveNode = VOID (__stdcall *)
(
	RTL_RB_TREE			* pTree,
	RTL_BALANCED_NODE	* pNode
);

using f_NtOpenFile = NTSTATUS (__stdcall *)
(
	HANDLE				*	hFileOut,
	ACCESS_MASK				DesiredAccess,
	OBJECT_ATTRIBUTES	*	pAtrributes,
	IO_STATUS_BLOCK		*	pIoStatusBlock,
	ULONG					ShareAccess,
	ULONG					OpenOptions
);

using f_NtReadFile = NTSTATUS (__stdcall *)
(
	HANDLE					FileHandle,
	HANDLE					hOptEvent,
	PVOID					pOptApc,
	PVOID					pOptApcContext,
	IO_STATUS_BLOCK		*	IoStatusBlock,
	PVOID					Buffer,
	ULONG					Length,
	LARGE_INTEGER		*	pOptByteOffset,
	ULONG				*	pOptKey
);

using f_NtSetInformationFile = NTSTATUS (__stdcall *)
(
	HANDLE						FileHandle,
	IO_STATUS_BLOCK			*	IoStatusBlock,
	PVOID						FileInformation,
	ULONG						Length,
	FILE_INFORMATION_CLASS		FileInformationClass
);

using f_NtQueryInformationFile = NTSTATUS (__stdcall *)
(
	HANDLE						FileHandle,
	IO_STATUS_BLOCK			*	pIoStatusBlock,
	PVOID						FileInformation,
	ULONG						Length,
	FILE_INFORMATION_CLASS		FileInformationClass
);

using f_NtClose = NTSTATUS (__stdcall *)
(
	HANDLE Handle
);

using f_NtAllocateVirtualMemory = NTSTATUS (__stdcall *)
(
	HANDLE			ProcessHandle,
	PVOID		*	BaseAddress,
	ULONG_PTR		ZeroBits,
	SIZE_T		*	RegionSize,
	ULONG			AllocationType,
	ULONG			Protect
);

using f_NtFreeVirtualMemory = NTSTATUS (__stdcall *)
(
	HANDLE		ProcessHandle,
	PVOID	*	BaseAddress,
	SIZE_T	*	RegionSize,
	ULONG		FreeType
);

using f_NtProtectVirtualMemory = NTSTATUS (__stdcall *)
(
	HANDLE		ProcessHandle,
	PVOID	*	BaseAddress,
	SIZE_T	*	Size,
	ULONG		NewAccess,
	ULONG	*	OldAccess
);

using f_NtCreateSection = NTSTATUS (__stdcall *)
(
	HANDLE				*	SectionHandle,
	ACCESS_MASK				DesiredAccess,
	OBJECT_ATTRIBUTES	*	ObjectAttributes,
	LARGE_INTEGER		*	MaximumSize,
	ULONG					SectionPageProtection,
	ULONG					AllocationAttributes,
	HANDLE					FileHandle
);

using f_NtMapViewOfSection = NTSTATUS (__stdcall *)
(
	HANDLE				SectionHandle,
	HANDLE				ProcessHandle,
	PVOID			*	BaseAddress,
	ULONG_PTR			ZeroBits,
	SIZE_T				CommitSize,
	LARGE_INTEGER	*	SectionOffset,
	SIZE_T			*	ViewSize,
	SECTION_INHERIT		InheritDisposition,
	ULONG				AllocationType,
	ULONG				Win32Protect
);

using f_LdrProtectMrdata = VOID (__stdcall *)
(
	BOOL bProtected
);

using f_RtlAddVectoredExceptionHandler = PVOID (__stdcall *)
(
	ULONG						FirstHandler,
	PVECTORED_EXCEPTION_HANDLER VectoredHandler
);

using f_RtlRemoveVectoredExceptionHandler = ULONG (__stdcall *)
(
	PVOID Handle
);

using f_NtDelayExecution = NTSTATUS (__stdcall *)
(
	BOOLEAN			Alertable,
	LARGE_INTEGER * DelayInterval
);

using f_NtQueryObject = NTSTATUS (__stdcall *)
(
	HANDLE                   Handle,
	OBJECT_INFORMATION_CLASS ObjectInformationClass,
	PVOID                    ObjectInformation,
	ULONG                    ObjectInformationLength,
	PULONG                   ReturnLength
);

using f_memset = decltype(memset)*;

using f_LdrpModuleBaseAddressIndex	= RTL_RB_TREE *;
using f_LdrpMappingInfoIndex		= RTL_RB_TREE *;
using f_LdrpHeap					= PVOID *;
using f_LdrpInvertedFunctionTable	= RTL_INVERTED_FUNCTION_TABLE *;
using f_LdrpDefaultPath				= UNICODE_STRING *;
using f_LdrpVectorHandlerList		= RTL_VECTORED_HANDLER_LIST *;
using f_LdrpTlsList					= LIST_ENTRY *;

//ntdll.dll:
using f_RtlpUnhandledExceptionFilter	= ULONG_PTR *; //encrypted with RtlEncodePointer, points to kernel32.UnhandledExceptionFilter

//kernel32.dll:
using f_UnhandledExceptionFilter		= ULONG_PTR *; //PTOP_LEVEL_EXCEPTION_FILTER 
using f_SingleHandler					= ULONG_PTR *; //encrypted with RtlEncodePointer, points to kernel32.DefaultHandler
using f_DefaultHandler					= ULONG_PTR *; //PTOP_LEVEL_EXCEPTION_FILTER 

#pragma endregion
```

`README.md`:

```md
# manual_mapping_dll_injector

Imitates Win32 dll loader (LoadLibrary func). 

Not completed product, development in progress...

```

`Win10.h`:

```h
#pragma once

#include "NT Defs.h"

typedef struct _LDR_DDAG_NODE_WIN10
{
	LIST_ENTRY				Modules;
	PLDR_SERVICE_TAG_RECORD	ServiceTagList;
	ULONG					LoadCount;
	ULONG					LoadWhileUnloadingCount;
	ULONG					LowestLink;
	PLDRP_CSLIST			Dependencies;
	PLDRP_CSLIST			IncomingDependencies;
	LDR_DDAG_STATE			State;
	SINGLE_LIST_ENTRY		CondenseLink;
	ULONG					PreorderNumber;
} LDR_DDAG_NODE_WIN10, * PLDR_DDAG_NODE_WIN10;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN10
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;

	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;

	union
	{
		UCHAR FlagGroup[4];
		ULONG Flags;

		struct
		{
			ULONG PackagedBinary			: 1;
			ULONG MarkedForRemoval			: 1;
			ULONG ImageDll					: 1;
			ULONG LoadNotificationsSent		: 1;
			ULONG TelemetryEntryProcessed	: 1;
			ULONG ProcessStaticImport		: 1;
			ULONG InLegacyLists				: 1;
			ULONG InIndexes					: 1;
			ULONG ShimDll					: 1;
			ULONG InExceptionTable			: 1;
			ULONG ReservedFlags1			: 2;
			ULONG LoadInProgress			: 1;
			ULONG LoadConfigProcessed		: 1;
			ULONG EntryProcessed			: 1;
			ULONG ProtectDelayLoad			: 1;
			ULONG ReservedFlags3			: 2;
			ULONG DontCallForThreads		: 1;
			ULONG ProcessAttachCalled		: 1;
			ULONG ProcessAttachFailed		: 1;
			ULONG CorDeferredValidate		: 1;
			ULONG CorImage					: 1;
			ULONG DontRelocate				: 1;
			ULONG CorILOnly					: 1;
			ULONG ChpeImage					: 1;
			ULONG ReservedFlags5			: 2;
			ULONG Redirected				: 1;
			ULONG ReservedFlags6			: 2;
			ULONG CompatDatabaseProcessed	: 1;
		};
	};

	WORD ObsoleteLoadCount;
	WORD TlsIndex;

	LIST_ENTRY HashLinks;

	ULONG TimedateStamp;
	PVOID EntryPointActivationContext;
	PVOID Lock;

	LDR_DDAG_NODE_WIN10 * DdagNode;

	LIST_ENTRY	NodeModuleLink;
	PVOID		LoadContext;
	PVOID		ParentDllBase;
	PVOID		SwitchBackContext;

	RTL_BALANCED_NODE BaseAddressIndexNode;
	RTL_BALANCED_NODE MappingInfoIndexNode;

	ULONG_PTR			OriginalBase;
	LARGE_INTEGER		LoadTime;
	ULONG				BaseNameHashValue;
	LDR_DLL_LOAD_REASON	LoadReason;
	ULONG				ImplicitPathOptions;

	ULONG ReferenceCount;

	//1607+
	ULONG DependentLoadFlags;

	//1703+
	UCHAR SigningLevel;
} LDR_DATA_TABLE_ENTRY_WIN10, * PLDR_DATA_TABLE_ENTRY_WIN10;

#ifdef _WIN64

typedef __declspec(align(4)) struct _LDR_DDAG_NODE_WIN10_32
{
	LIST_ENTRY32			Modules;
	DWORD					ServiceTagList; // -> LDR_SERVICE_TAG_RECORD_32
	ULONG					LoadCount;
	ULONG					LoadWhileUnloadingCount;
	ULONG					LowestLink;
	DWORD					Dependencies; // -> LDRP_CSLIST_32
	DWORD					IncomingDependencies; // -> LDRP_CSLIST_32
	LDR_DDAG_STATE			State;
	SINGLE_LIST_ENTRY_32	CondenseLink;
	ULONG					PreorderNumber;
} LDR_DDAG_NODE_WIN10_32, * PLDR_DDAG_NODE_WIN10_32;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN10_32
{
	LIST_ENTRY32 InLoadOrderLinks;
	LIST_ENTRY32 InMemoryOrderLinks;
	LIST_ENTRY32 InInitializationOrderLinks;

	DWORD DllBase;
	DWORD EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING_32 FullDllName;
	UNICODE_STRING_32 BaseDllName;

	union
	{
		UCHAR FlagGroup[4];
		ULONG Flags;

		struct
		{
			ULONG PackagedBinary			: 1;
			ULONG MarkedForRemoval			: 1;
			ULONG ImageDll					: 1;
			ULONG LoadNotificationsSent		: 1;
			ULONG TelemetryEntryProcessed	: 1;
			ULONG ProcessStaticImport		: 1;
			ULONG InLegacyLists				: 1;
			ULONG InIndexes					: 1;
			ULONG ShimDll					: 1;
			ULONG InExceptionTable			: 1;
			ULONG ReservedFlags1			: 2;
			ULONG LoadInProgress			: 1;
			ULONG LoadConfigProcessed		: 1;
			ULONG EntryProcessed			: 1;
			ULONG ProtectDelayLoad			: 1;
			ULONG ReservedFlags3			: 2;
			ULONG DontCallForThreads		: 1;
			ULONG ProcessAttachCalled		: 1;
			ULONG ProcessAttachFailed		: 1;
			ULONG CorDeferredValidate		: 1;
			ULONG CorImage					: 1;
			ULONG DontRelocate				: 1;
			ULONG CorILOnly					: 1;
			ULONG ChpeImage					: 1;
			ULONG ReservedFlags5			: 2;
			ULONG Redirected				: 1;
			ULONG ReservedFlags6			: 2;
			ULONG CompatDatabaseProcessed	: 1;
		};
	};

	WORD ObsoleteLoadCount;
	WORD TlsIndex;

	LIST_ENTRY32 HashLinks;

	ULONG TimedateStamp;
	DWORD EntryPointActivationContext;
	DWORD Spare;

	DWORD DdagNode; // -> LDR_DDAG_NODE_WIN10_32

	LIST_ENTRY32	NodeModuleLink;
	DWORD			LoadContext;
	DWORD			ParentDllBase;
	DWORD			SwitchBackContext;

	RTL_BALANCED_NODE_32 BaseAddressIndexNode;
	RTL_BALANCED_NODE_32 MappingInfoIndexNode;

	DWORD				OriginalBase;
	LARGE_INTEGER		LoadTime;
	ULONG				BaseNameHashValue;
	LDR_DLL_LOAD_REASON	LoadReason;
	ULONG				ImplicitPathOptions;

	ULONG ReferenceCount;
	ULONG DependentLoadFlags;
	UCHAR SigningLevel;
} LDR_DATA_TABLE_ENTRY_WIN10_32, * PLDR_DATA_TABLE_ENTRY_WIN10_32;

#endif
```

`Win11.h`:

```h
#pragma once

#include "NT Defs.h"

typedef struct _LDR_DDAG_NODE_WIN11
{
	LIST_ENTRY				Modules;
	PLDR_SERVICE_TAG_RECORD	ServiceTagList;
	ULONG					LoadCount;
	ULONG					LoadWhileUnloadingCount;
	ULONG					LowestLink;
	PLDRP_CSLIST			Dependencies;
	PLDRP_CSLIST			IncomingDependencies;
	LDR_DDAG_STATE			State;
	SINGLE_LIST_ENTRY		CondenseLink;
	ULONG					PreorderNumber;
} LDR_DDAG_NODE_WIN11, * PLDR_DDAG_NODE_WIN11;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN11
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;

	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;

	union
	{
		UCHAR FlagGroup[4];
		ULONG Flags;

		struct
		{
			ULONG PackagedBinary			: 1;
			ULONG MarkedForRemoval			: 1;
			ULONG ImageDll					: 1;
			ULONG LoadNotificationsSent		: 1;
			ULONG TelemetryEntryProcessed	: 1;
			ULONG ProcessStaticImport		: 1;
			ULONG InLegacyLists				: 1;
			ULONG InIndexes					: 1;
			ULONG ShimDll					: 1;
			ULONG InExceptionTable			: 1;
			ULONG ReservedFlags1			: 2;
			ULONG LoadInProgress			: 1;
			ULONG LoadConfigProcessed		: 1;
			ULONG EntryProcessed			: 1;
			ULONG ProtectDelayLoad			: 1;
			ULONG ReservedFlags3			: 2;
			ULONG DontCallForThreads		: 1;
			ULONG ProcessAttachCalled		: 1;
			ULONG ProcessAttachFailed		: 1;
			ULONG CorDeferredValidate		: 1;
			ULONG CorImage					: 1;
			ULONG DontRelocate				: 1;
			ULONG CorILOnly					: 1;
			ULONG ChpeImage					: 1;
			ULONG ReservedFlags5			: 2;
			ULONG Redirected				: 1;
			ULONG ReservedFlags6			: 2;
			ULONG CompatDatabaseProcessed	: 1;
		};
	};

	WORD ObsoleteLoadCount;
	WORD TlsIndex;

	LIST_ENTRY HashLinks;

	ULONG TimedateStamp;
	PVOID EntryPointActivationContext;
	PVOID Lock;

	LDR_DDAG_NODE_WIN11 * DdagNode;

	LIST_ENTRY	NodeModuleLink;
	PVOID		LoadContext;
	PVOID		ParentDllBase;
	PVOID		SwitchBackContext;

	RTL_BALANCED_NODE BaseAddressIndexNode;
	RTL_BALANCED_NODE MappingInfoIndexNode;

	ULONG_PTR			OriginalBase;
	LARGE_INTEGER		LoadTime;
	ULONG				BaseNameHashValue;
	LDR_DLL_LOAD_REASON	LoadReason;
	ULONG				ImplicitPathOptions;

	ULONG ReferenceCount;
	ULONG DependentLoadFlags;
	UCHAR SigningLevel;

	ULONG CheckSum;
	PVOID ActivePathImageBase;
	LDR_HOT_PATCH_STATE HotPatchState;
} LDR_DATA_TABLE_ENTRY_WIN11, * PLDR_DATA_TABLE_ENTRY_WIN11;

#ifdef _WIN64

typedef struct _LDR_DDAG_NODE_WIN11_32
{
	LIST_ENTRY32			Modules;
	DWORD					ServiceTagList; // -> LDR_SERVICE_TAG_RECORD_32
	ULONG					LoadCount;
	ULONG					LoadWhileUnloadingCount;
	ULONG					LowestLink;
	DWORD					Dependencies; // -> LDRP_CSLIST_32
	DWORD					IncomingDependencies; // -> LDRP_CSLIST_32
	LDR_DDAG_STATE			State;
	SINGLE_LIST_ENTRY_32	CondenseLink;
	ULONG					PreorderNumber;
} LDR_DDAG_NODE_WIN11_32, * PLDR_DDAG_NODE_WIN11_32;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN11_32
{
	LIST_ENTRY32 InLoadOrderLinks;
	LIST_ENTRY32 InMemoryOrderLinks;
	LIST_ENTRY32 InInitializationOrderLinks;

	DWORD DllBase;
	DWORD EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING_32 FullDllName;
	UNICODE_STRING_32 BaseDllName;

	union
	{
		UCHAR FlagGroup[4];
		ULONG Flags;

		struct
		{
			ULONG PackagedBinary			: 1;
			ULONG MarkedForRemoval			: 1;
			ULONG ImageDll					: 1;
			ULONG LoadNotificationsSent		: 1;
			ULONG TelemetryEntryProcessed	: 1;
			ULONG ProcessStaticImport		: 1;
			ULONG InLegacyLists				: 1;
			ULONG InIndexes					: 1;
			ULONG ShimDll					: 1;
			ULONG InExceptionTable			: 1;
			ULONG ReservedFlags1			: 2;
			ULONG LoadInProgress			: 1;
			ULONG LoadConfigProcessed		: 1;
			ULONG EntryProcessed			: 1;
			ULONG ProtectDelayLoad			: 1;
			ULONG ReservedFlags3			: 2;
			ULONG DontCallForThreads		: 1;
			ULONG ProcessAttachCalled		: 1;
			ULONG ProcessAttachFailed		: 1;
			ULONG CorDeferredValidate		: 1;
			ULONG CorImage					: 1;
			ULONG DontRelocate				: 1;
			ULONG CorILOnly					: 1;
			ULONG ChpeImage					: 1;
			ULONG ReservedFlags5			: 2;
			ULONG Redirected				: 1;
			ULONG ReservedFlags6			: 2;
			ULONG CompatDatabaseProcessed	: 1;
		};
	};

	WORD ObsoleteLoadCount;
	WORD TlsIndex;

	LIST_ENTRY32 HashLinks;

	ULONG TimedateStamp;
	DWORD EntryPointActivationContext;
	DWORD Spare;

	DWORD DdagNode; // -> LDR_DDAG_NODE_WIN11_32

	LIST_ENTRY32	NodeModuleLink;
	DWORD			LoadContext;
	DWORD			ParentDllBase;
	DWORD			SwitchBackContext;

	RTL_BALANCED_NODE_32 BaseAddressIndexNode;
	RTL_BALANCED_NODE_32 MappingInfoIndexNode;

	DWORD				OriginalBase;
	LARGE_INTEGER		LoadTime;
	ULONG				BaseNameHashValue;
	LDR_DLL_LOAD_REASON	LoadReason;
	ULONG				ImplicitPathOptions;

	ULONG ReferenceCount;
	ULONG DependentLoadFlags;
	UCHAR SigningLevel;

	ULONG CheckSum;
	DWORD ActivePathImageBase;
	LDR_HOT_PATCH_STATE HotPatchState;
} LDR_DATA_TABLE_ENTRY_WIN11_32, * PLDR_DATA_TABLE_ENTRY_WIN11_32;

#endif
```

`Win7.h`:

```h
#pragma once

#include "NT Defs.h"

//some flags might not be Win7 but w/e, stolen from here:
//https://doxygen.reactos.org/d1/d97/ldrtypes_8h_source.html#l00034

//0x00000001
#define LDRP_STATIC_LINK				0x00000002
#define LDRP_IMAGE_DLL					0x00000004
#define LDRP_SHIMENG_ENTRY_PROCESSED	0x00000008
#define LDRP_TELEMETRY_ENTRY_PROCESSED	0x00000010
#define LDRP_IMAGE_INTEGRITY_FORCED		0x00000020
//0x00000040 - 0x00000800
#define LDRP_LOAD_IN_PROGRESS			0x00001000
#define LDRP_UNLOAD_IN_PROGRESS			0x00002000
#define LDRP_ENTRY_PROCESSED			0x00004000
#define LDRP_ENTRY_INSERTED				0x00008000  
#define LDRP_CURRENT_LOAD				0x00010000
#define LDRP_FAILED_BUILTIN_LOAD		0x00020000
#define LDRP_DONT_CALL_FOR_THREADS		0x00040000
#define LDRP_PROCESS_ATTACH_CALLED		0x00080000
#define LDRP_DEBUG_SYMBOLS_LOADED		0x00100000 
#define LDRP_IMAGE_NOT_AT_BASE			0x00200000 
#define LDRP_COR_IMAGE					0x00400000 
#define LDR_COR_OWNS_UNMAP				0x00800000 
#define LDRP_SYSTEM_MAPPED				0x01000000 
#define LDRP_IMAGE_VERIFYING			0x02000000 
#define LDRP_DRIVER_DEPENDENT_DLL		0x04000000 
#define LDRP_ENTRY_NATIVE				0x08000000 
#define LDRP_REDIRECTED					0x10000000 
#define LDRP_NON_PAGED_DEBUG_INFO		0x20000000 
#define LDRP_MM_LOADED					0x40000000 
#define LDRP_COMPAT_DATABASE_PROCESSED	0x80000000

typedef struct _LDR_DDAG_NODE_WIN7 //dummy for macros
{
} LDR_DDAG_NODE_WIN7, * PLDR_DDAG_NODE_WIN7;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN7
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;

	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING	FullDllName;
	UNICODE_STRING	BaseDllName;

	ULONG	Flags;
	WORD	LoadCount;
	WORD	TlsIndex;

	union
	{
		LIST_ENTRY HashLinks;
		struct
		{
			PVOID SectionPointer;
			ULONG CheckSum;
		};
	};

	union
	{
		ULONG TimeDateStamp;
		PVOID LoadedImports;
	};

	PVOID EntryPointActivationContext;
	PVOID PatchInformation;

	LIST_ENTRY ForwarderLinks;
	LIST_ENTRY ServiceTagLinks;
	LIST_ENTRY StaticLinks;

	PVOID			ContextInformation;
	ULONG_PTR		OriginalBase;
	LARGE_INTEGER	LoadTime;
} LDR_DATA_TABLE_ENTRY_WIN7, * PLDR_DATA_TABLE_ENTRY_WIN7;

typedef struct _RTL_INVERTED_FUNCTION_TABLE_WIN7
{
	ULONG Count;
	ULONG MaxCount;
	ULONG Epoch;
	RTL_INVERTED_FUNCTION_TABLE_ENTRY Entries[ANYSIZE_ARRAY];
} RTL_INVERTED_FUNCTION_TABLE_WIN7, * PRTL_INVERTED_FUNCTION_TABLE_WIN7;

#ifdef _WIN64

typedef struct _LDR_DDAG_NODE_WIN7_32 //dummy for macros
{
} LDR_DDAG_NODE_WIN7_32, * PLDR_DDAG_NODE_WIN7_32;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN7_32
{
	LIST_ENTRY32 InLoadOrderLinks;
	LIST_ENTRY32 InMemoryOrderLinks;
	LIST_ENTRY32 InInitializationOrderLinks;

	DWORD DllBase;
	DWORD EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING_32 FullDllName;
	UNICODE_STRING_32 BaseDllName;

	ULONG	Flags;
	WORD	LoadCount;
	WORD	TlsIndex;

	union
	{
		LIST_ENTRY32 HashLinks;
		struct
		{
			DWORD SectionPointer;
			ULONG CheckSum;
		};
	};

	union
	{
		ULONG TimeDateStamp;
		DWORD LoadedImports;
	};

	DWORD EntryPointActivationContext;
	DWORD PatchInformation;

	LIST_ENTRY32 ForwarderLinks;
	LIST_ENTRY32 ServiceTagLinks;
	LIST_ENTRY32 StaticLinks;

	DWORD			ContextInformation;
	DWORD			OriginalBase;
	LARGE_INTEGER	LoadTime;
} LDR_DATA_TABLE_ENTRY_WIN7_32, * PLDR_DATA_TABLE_ENTRY_WIN7_32;

typedef struct _RTL_VECTORED_EXCEPTION_ENTRY_WIN7_32 //prototype
{
	LIST_ENTRY32	List;
	DWORD			Flag;
	DWORD			VectoredHandler; //PVECTORED_EXCEPTION_HANDLER
} RTL_VECTORED_EXCEPTION_ENTRY_WIN7_32, * PRTL_VECTORED_EXCEPTION_ENTRY_WIN7_32;

#endif
```

`Win8.h`:

```h
#pragma once

#include "NT Defs.h"

typedef struct _LDR_DDAG_NODE_WIN8
{
	LIST_ENTRY				Modules;
	PLDR_SERVICE_TAG_RECORD	ServiceTagList;
	ULONG					LoadCount;
	ULONG					ReferenceCount;
	ULONG					DependencyCount;
	union
	{
		LDRP_CSLIST			Dependencies;
		SINGLE_LIST_ENTRY * RemovalLink;
	};
	PLDRP_CSLIST			IncomingDependencies;
	LDR_DDAG_STATE			State;
	SINGLE_LIST_ENTRY		CondenseLink;
	ULONG					PreorderNumber;
	ULONG					LowestLink;
} LDR_DDAG_NODE_WIN8, * PLDR_DDAG_NODE_WIN8;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN8
{
	LIST_ENTRY		InLoadOrderLinks;
	LIST_ENTRY		InMemoryOrderLinks;
	union
	{
		LIST_ENTRY InInitializationOrderLinks;
		LIST_ENTRY InProgressLinks;
	};

	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING	FullDllName;
	UNICODE_STRING	BaseDllName;

	union
	{
		UCHAR FlagGroup[4];
		ULONG Flags;

		struct
		{
			ULONG PackagedBinary			: 1;
			ULONG MarkedForRemoval			: 1;
			ULONG ImageDll					: 1;
			ULONG LoadNotificationsSent		: 1;
			ULONG TelemetryEntryProcessed	: 1;
			ULONG ProcessStaticImport		: 1;
			ULONG InLegacyLists				: 1;
			ULONG InIndexes					: 1;
			ULONG ShimDll					: 1;
			ULONG InExceptionTable			: 1;
			ULONG ReservedFlags1			: 2;
			ULONG LoadInProgress			: 1;
			ULONG ReservedFlags2			: 1; 
			ULONG EntryProcessed			: 1;
			ULONG ReservedFlags3			: 3;
			ULONG DontCallForThreads		: 1;
			ULONG ProcessAttachCalled		: 1;
			ULONG ProcessAttachFailed		: 1;
			ULONG CorDeferredValidate		: 1;
			ULONG CorImage					: 1;
			ULONG DontRelocate				: 1;
			ULONG CorILOnly					: 1;
			ULONG ReservedFlags5			: 3;
			ULONG Redirected				: 1;
			ULONG ReservedFlags6			: 2;
			ULONG CompatDatabaseProcessed	: 1;
		};
	};

	WORD ObsoleteLoadCount;
	WORD TlsIndex;

	LIST_ENTRY HashLinks;

	ULONG TimedateStamp;
	PVOID EntryPointActivationContext;
	PVOID PatchInformation;

	LDR_DDAG_NODE_WIN8 * DdagNode;

	LIST_ENTRY	NodeModuleLink;
	PVOID		SnapContext;
	PVOID		ParentDllBase;
	PVOID		SwitchBackContext;

	RTL_BALANCED_NODE BaseAddressIndexNode;
	RTL_BALANCED_NODE MappingInfoIndexNode;

	ULONG_PTR			OriginalBase;
	LARGE_INTEGER		LoadTime;
	ULONG				BaseNameHashValue;
	LDR_DLL_LOAD_REASON	LoadReason;
} LDR_DATA_TABLE_ENTRY_WIN8, * PLDR_DATA_TABLE_ENTRY_WIN8;

typedef struct _LDRP_PATH_SEARCH_CONTEXT_WIN8
{
	ULONG_PTR Flags; //probably LDRP_LOAD_CONTEXT_FLAGS
	wchar_t * OriginalFullDllName; //can be path
	BOOLEAN		unknown2; //only low byte relevant
	ULONG_PTR	unknown3[3]; //sometimes imagebase?
} LDRP_PATH_SEARCH_CONTEXT_WIN8, * PLDRP_PATH_SEARCH_CONTEXT_WIN8;

#ifdef _WIN64

typedef __declspec(align(4)) struct _LDR_DDAG_NODE_WIN8_32
{
	LIST_ENTRY32	Modules;
	DWORD			ServiceTagList; // -> LDR_SERVICE_TAG_RECORD_32
	ULONG			LoadCount;
	ULONG			ReferenceCount;
	ULONG			DependencyCount;
	union
	{
		LDRP_CSLIST_32	Dependencies;
		DWORD			RemovalLink; // -> SINGLE_LIST_ENTRY_32
	};
	DWORD					IncomingDependencies; // -> LDRP_CSLIST_32
	LDR_DDAG_STATE			State;
	SINGLE_LIST_ENTRY_32	CondenseLink;
	ULONG					PreorderNumber;
	ULONG					LowestLink;
} LDR_DDAG_NODE_WIN8_32, * PLDR_DDAG_NODE_WIN8_32;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN8_32
{
	LIST_ENTRY32 InLoadOrderLinks;
	LIST_ENTRY32 InMemoryOrderLinks;
	union
	{
		LIST_ENTRY32 InInitializationOrderLinks;
		LIST_ENTRY32 InProgressLinks;
	};

	DWORD DllBase;
	DWORD EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING_32 FullDllName;
	UNICODE_STRING_32 BaseDllName;

	union
	{
		UCHAR FlagGroup[4];
		ULONG Flags;

		struct
		{
			ULONG PackagedBinary			: 1;
			ULONG MarkedForRemoval			: 1;
			ULONG ImageDll					: 1;
			ULONG LoadNotificationsSent		: 1;
			ULONG TelemetryEntryProcessed	: 1;
			ULONG ProcessStaticImport		: 1;
			ULONG InLegacyLists				: 1;
			ULONG InIndexes					: 1;
			ULONG ShimDll					: 1;
			ULONG InExceptionTable			: 1;
			ULONG ReservedFlags1			: 2;
			ULONG LoadInProgress			: 1;
			ULONG ReservedFlags2			: 1;
			ULONG EntryProcessed			: 1;
			ULONG ReservedFlags3			: 3;
			ULONG DontCallForThreads		: 1;
			ULONG ProcessAttachCalled		: 1;
			ULONG ProcessAttachFailed		: 1;
			ULONG CorDeferredValidate		: 1;
			ULONG CorImage					: 1;
			ULONG DontRelocate				: 1;
			ULONG CorILOnly					: 1;
			ULONG ReservedFlags5			: 3;
			ULONG Redirected				: 1;
			ULONG ReservedFlags6			: 2;
			ULONG CompatDatabaseProcessed	: 1;
		};
	};

	WORD ObsoleteLoadCount;
	WORD TlsIndex;

	LIST_ENTRY32 HashLinks;

	ULONG TimedateStamp;
	DWORD EntryPointActivationContext;
	DWORD PatchInformation;

	DWORD DdagNode; // -> LDR_DDAG_NODE_WIN8_32

	LIST_ENTRY32	NodeModuleLink;
	DWORD			SnapContext;
	DWORD			ParentDllBase;
	DWORD			SwitchBackContext;

	RTL_BALANCED_NODE_32 BaseAddressIndexNode;
	RTL_BALANCED_NODE_32 MappingInfoIndexNode;

	DWORD				OriginalBase;
	LARGE_INTEGER		LoadTime;
	ULONG				BaseNameHashValue;
	LDR_DLL_LOAD_REASON	LoadReason;
} LDR_DATA_TABLE_ENTRY_WIN8_32, * PLDR_DATA_TABLE_ENTRY_WIN8_32;

#endif
```

`Win81.h`:

```h
#pragma once

#include "NT Defs.h"

typedef struct _LDR_DDAG_NODE_WIN81
{
	LIST_ENTRY				Modules;
	PLDR_SERVICE_TAG_RECORD	ServiceTagList;
	ULONG					LoadCount;
	ULONG					ReferenceCount;
	ULONG					DependencyCount;
	union
	{
		LDRP_CSLIST			Dependencies;
		SINGLE_LIST_ENTRY * RemovalLink;
	};
	PLDRP_CSLIST			IncomingDependencies;
	LDR_DDAG_STATE			State;
	SINGLE_LIST_ENTRY		CondenseLink;
	ULONG					PreorderNumber;
	ULONG					LowestLink;
} LDR_DDAG_NODE_WIN81, * PLDR_DDAG_NODE_WIN81;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN81
{
	LIST_ENTRY		InLoadOrderLinks;
	LIST_ENTRY		InMemoryOrderLinks;
	union
	{
		LIST_ENTRY InInitializationOrderLinks;
		LIST_ENTRY InProgressLinks;
	};

	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING	FullDllName;
	UNICODE_STRING	BaseDllName;

	union
	{
		UCHAR FlagGroup[4];
		ULONG Flags;

		struct
		{
			ULONG PackagedBinary			: 1;
			ULONG MarkedForRemoval			: 1;
			ULONG ImageDll					: 1;
			ULONG LoadNotificationsSent		: 1;
			ULONG TelemetryEntryProcessed	: 1;
			ULONG ProcessStaticImport		: 1;
			ULONG InLegacyLists				: 1;
			ULONG InIndexes					: 1;
			ULONG ShimDll					: 1;
			ULONG InExceptionTable			: 1;
			ULONG ReservedFlags1			: 2;
			ULONG LoadInProgress			: 1;
			ULONG ReservedFlags2			: 1; 
			ULONG EntryProcessed			: 1;
			ULONG ReservedFlags3			: 3;
			ULONG DontCallForThreads		: 1;
			ULONG ProcessAttachCalled		: 1;
			ULONG ProcessAttachFailed		: 1;
			ULONG CorDeferredValidate		: 1;
			ULONG CorImage					: 1;
			ULONG DontRelocate				: 1;
			ULONG CorILOnly					: 1;
			ULONG ReservedFlags5			: 3;
			ULONG Redirected				: 1;
			ULONG ReservedFlags6			: 2;
			ULONG CompatDatabaseProcessed	: 1;
		};
	};

	WORD ObsoleteLoadCount;
	WORD TlsIndex;

	LIST_ENTRY HashLinks;

	ULONG TimedateStamp;
	PVOID EntryPointActivationContext;
	PVOID Spare;

	LDR_DDAG_NODE_WIN81 * DdagNode;

	LIST_ENTRY	NodeModuleLink;
	PVOID		SnapContext;
	PVOID		ParentDllBase;
	PVOID		SwitchBackContext;

	RTL_BALANCED_NODE BaseAddressIndexNode;
	RTL_BALANCED_NODE MappingInfoIndexNode;

	ULONG_PTR			OriginalBase;
	LARGE_INTEGER		LoadTime;
	ULONG				BaseNameHashValue;
	LDR_DLL_LOAD_REASON	LoadReason;

	ULONG ImplicitPathOptions;
} LDR_DATA_TABLE_ENTRY_WIN81, * PLDR_DATA_TABLE_ENTRY_WIN81;

typedef struct _LDRP_PATH_SEARCH_CONTEXT_WIN81
{
	UINT_PTR unknown_0[3];
	wchar_t * OriginalFullDllName;
	UINT_PTR unknown_1[1];
} LDRP_PATH_SEARCH_CONTEXT_WIN81, * PLDRP_PATH_SEARCH_CONTEXT_WIN81; //x86 size = 0x14, x64 size = 0x28

#ifdef _WIN64

typedef __declspec(align(4)) struct _LDR_DDAG_NODE_WIN81_32
{
	LIST_ENTRY32	Modules;
	DWORD			ServiceTagList; // -> LDR_SERVICE_TAG_RECORD_32
	ULONG			LoadCount;
	ULONG			ReferenceCount;
	ULONG			DependencyCount;
	union
	{
		LDRP_CSLIST_32	Dependencies;
		DWORD			RemovalLink; // -> SINGLE_LIST_ENTRY_32
	};
	DWORD					IncomingDependencies; // -> LDRP_CSLIST_32
	LDR_DDAG_STATE			State;
	SINGLE_LIST_ENTRY_32	CondenseLink;
	ULONG					PreorderNumber;
	ULONG					LowestLink;
} LDR_DDAG_NODE_WIN81_32, * PLDR_DDAG_NODE_WIN81_32;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN81_32
{
	LIST_ENTRY32 InLoadOrderLinks;
	LIST_ENTRY32 InMemoryOrderLinks;
	union
	{
		LIST_ENTRY32 InInitializationOrderLinks;
		LIST_ENTRY32 InProgressLinks;
	};

	DWORD DllBase;
	DWORD EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING_32 FullDllName;
	UNICODE_STRING_32 BaseDllName;

	union
	{
		UCHAR FlagGroup[4];
		ULONG Flags;

		struct
		{
			ULONG PackagedBinary			: 1;
			ULONG MarkedForRemoval			: 1;
			ULONG ImageDll					: 1;
			ULONG LoadNotificationsSent		: 1;
			ULONG TelemetryEntryProcessed	: 1;
			ULONG ProcessStaticImport		: 1;
			ULONG InLegacyLists				: 1;
			ULONG InIndexes					: 1;
			ULONG ShimDll					: 1;
			ULONG InExceptionTable			: 1;
			ULONG ReservedFlags1			: 2;
			ULONG LoadInProgress			: 1;
			ULONG ReservedFlags2			: 1;
			ULONG EntryProcessed			: 1;
			ULONG ReservedFlags3			: 3;
			ULONG DontCallForThreads		: 1;
			ULONG ProcessAttachCalled		: 1;
			ULONG ProcessAttachFailed		: 1;
			ULONG CorDeferredValidate		: 1;
			ULONG CorImage					: 1;
			ULONG DontRelocate				: 1;
			ULONG CorILOnly					: 1;
			ULONG ReservedFlags5			: 3;
			ULONG Redirected				: 1;
			ULONG ReservedFlags6			: 2;
			ULONG CompatDatabaseProcessed	: 1;
		};
	};

	WORD ObsoleteLoadCount;
	WORD TlsIndex;

	LIST_ENTRY32 HashLinks;

	ULONG TimedateStamp;
	DWORD EntryPointActivationContext;
	DWORD Spare;

	DWORD DdagNode; // -> LDR_DDAG_NODE_WIN81_32

	LIST_ENTRY32	NodeModuleLink;
	DWORD			SnapContext;
	DWORD			ParentDllBase;
	DWORD			SwitchBackContext;

	RTL_BALANCED_NODE_32 BaseAddressIndexNode;
	RTL_BALANCED_NODE_32 MappingInfoIndexNode;

	DWORD				OriginalBase;
	LARGE_INTEGER		LoadTime;
	ULONG				BaseNameHashValue;
	LDR_DLL_LOAD_REASON	LoadReason;

	ULONG ImplicitPathOptions;
} LDR_DATA_TABLE_ENTRY_WIN81_32, * PLDR_DATA_TABLE_ENTRY_WIN81_32;

#endif
```

`dll_main.cpp`:

```cpp
#include "includes.hpp"

DLLEXPORT int WINAPI Start(INJECTION_DATA* data)
{
	bool fail_flag = false;
	wchar_t* windows_dir = nullptr;
	std::wstring ntdll_path;
	SymbolLoader loader;

	g_h_current_module = data->start_args.hinstance;

	if (!GetOwnModuleFullPathW(g_path_to_this_module))
	{
		ERRLOG("Cannot get own module full path");

		fail_flag = true;

		goto FINISH;
	}

	if (_wdupenv_s(&windows_dir, nullptr, L"WINDIR") || !windows_dir)
	{
		if (windows_dir)
		{
			free(windows_dir);
		}

		fail_flag = true;

		goto FINISH;
	}

	ntdll_path = windows_dir;
	ntdll_path += L"\\System32\\ntdll.dll";

	free(windows_dir);

	if (!loader.Initialize(ntdll_path.c_str(), g_path_to_this_module.parent_path().c_str(), false, SL_DEFAULT_TIMEOUT))
	{
		ERRLOG("Cannot initialize ntdll.pdb file");
		
		fail_flag = true;

		goto FINISH;
	}

	if (!ResolveImports(&loader))
	{
		ERRLOG("Cannot resolve imports");

		fail_flag = true;

		goto FINISH;
	}

	if (!Inject(data))
	{
		ERRLOG("Inject error");

		fail_flag = true;

		goto FINISH;
	}

FINISH:

	g_executing_finished = true;

	if (fail_flag)
	{
		LOG("Executing finished with failure!");

		return 0;
	}

	LOG("Executing finished successfully!");
	
	return 1;
}

BOOL WINAPI DllMain(HINSTANCE inst, DWORD reason, LPVOID reserved)
{
	switch (reason)
	{
	case DLL_PROCESS_ATTACH:
		break;
	case DLL_PROCESS_DETACH:
		break;
	case DLL_THREAD_ATTACH:
		break;
	case DLL_THREAD_DETACH:
		break;
	default:
		return FALSE;
	}

	return TRUE;
}
```

`externs.hpp`:

```hpp
#pragma once

#define DLLEXPORT __declspec(dllexport)

DLLEXPORT int WINAPI Start(INJECTION_DATA* data);
```

`globals.hpp`:

```hpp
#pragma once

#include "namespaces.hpp"

inline HINSTANCE g_h_NTDLL;
inline HINSTANCE g_h_KERNEL32;
inline HINSTANCE g_h_current_module;

inline DWORD g_os_version;
inline DWORD g_os_build_number;

inline bool g_executing_finished;

inline fs::path g_path_to_this_module;

#define g_Win8	62
#define g_Win7	61
#define g_Win81	63
#define g_Win10	100
#define g_Win11	100

#define g_Win7_SP1   7601
#define g_Win8_SP1   9600
#define g_Win10_1507 10240
#define g_Win10_1511 10586
#define g_Win10_1607 14393
#define g_Win10_1703 15063
#define g_Win10_1709 16299
#define g_Win10_1803 17134
#define g_Win10_1809 17763
#define g_Win10_1903 18362
#define g_Win10_1909 18363
#define g_Win10_2004 19041
#define g_Win10_20H2 19042
#define g_Win10_21H1 19043
#define g_Win10_21H2 19044
#define g_Win11_21H2 22000
```

`hijack_handle.cpp`:

```cpp
#include "includes.hpp"

bool EnumProcessHandles(std::vector<SYSTEM_HANDLE_TABLE_ENTRY_INFO>* out_proc_handles_vec)
{
	if (!out_proc_handles_vec)
	{
		return false;
	}

	if (!out_proc_handles_vec->empty())
	{
		out_proc_handles_vec->clear();
	}

	size_t size = PAGE_SIZE * 5;
	size_t size_out = 0;

	BYTE* handles_buf = new BYTE[size];

	if (!handles_buf)
	{
		return false;
	}

	while (NATIVE::NtQuerySystemInformation(SYSTEM_INFORMATION_CLASS::SystemHandleInformation, handles_buf, size, (ULONG*)&size_out) == STATUS_INFO_LENGTH_MISMATCH)
	{
		delete[size] handles_buf;

		size = size_out + PAGE_SIZE;
		handles_buf = new BYTE[size];

		if (!handles_buf)
		{
			return false;
		}
	}

	SYSTEM_HANDLE_INFORMATION* handle_info = (SYSTEM_HANDLE_INFORMATION*)handles_buf;
	size_t handles_count = handle_info->NumberOfHandles;

	if (!handles_count)
	{
		delete[size] handles_buf;

		return false;
	}

	SYSTEM_HANDLE_TABLE_ENTRY_INFO* handle_entry = handle_info->Handles;
	for (DWORD i = 0; i < handles_count; ++i, ++handle_entry)
	{
		if ((OBJECT_TYPE_NUMBER)handle_entry->ObjectTypeIndex == OBJECT_TYPE_NUMBER::Process)
		{
			out_proc_handles_vec->push_back(*handle_entry);
		}
	}

	delete[size] handles_buf;

	return true;
}

bool FindProcessHandles(const std::vector<SYSTEM_HANDLE_TABLE_ENTRY_INFO>* sys_handles_vec, DWORD target_pid, std::vector<HANDLE_INFO>* out_proc_handles_vec, ACCESS_MASK desired_access)
{
	if (!sys_handles_vec || sys_handles_vec->empty() || !out_proc_handles_vec)
	{
		return false;
	}

	if (!out_proc_handles_vec->empty())
	{
		out_proc_handles_vec->clear();
	}

	for (auto& h_info : *sys_handles_vec)
	{
		WORD current_pid = h_info.UniqueProcessId;

		if (current_pid == target_pid || current_pid == GetCurrentProcessId())
		{
			continue;
		}

		if (desired_access != HJ_HANDLE_ANY_ACCESS && (h_info.GrantedAccess & desired_access) != desired_access)
		{
			continue;
		}

		HANDLE h_current_proc = OpenProcess(PROCESS_DUP_HANDLE, NULL, current_pid);
		if (!h_current_proc)
		{
			continue;
		}

		HANDLE src_handle = (HANDLE)h_info.HandleValue;
		HANDLE dst_handle = 0;
		if (!DuplicateHandle(h_current_proc, src_handle, GetCurrentProcess(), &dst_handle, PROCESS_QUERY_LIMITED_INFORMATION, NULL, NULL))
		{
			CloseHandle(h_current_proc);

			continue;
		}

		if (GetProcessId(dst_handle) != target_pid)
		{
			CloseHandle(h_current_proc);
			
			CloseHandle(dst_handle);

			continue;
		}

		CloseHandle(h_current_proc);

		CloseHandle(dst_handle);

		HANDLE_INFO hi = { 0 };

		hi.granted_access = h_info.GrantedAccess;
		hi.handle = (HANDLE)h_info.HandleValue;
		hi.owner_pid = h_info.UniqueProcessId;

		out_proc_handles_vec->push_back(hi);
	}

	return true;
}
```

`hijack_handle.hpp`:

```hpp
#pragma once

#define HJ_HANDLE_ANY_ACCESS -1

struct HANDLE_INFO
{
	ACCESS_MASK		granted_access	= 0;
	DWORD			owner_pid		= 0;
	HANDLE			handle			= 0;
};

bool EnumProcessHandles(std::vector<SYSTEM_HANDLE_TABLE_ENTRY_INFO>* out_proc_handles_vec);
bool FindProcessHandles(const std::vector<SYSTEM_HANDLE_TABLE_ENTRY_INFO>* sys_handles_vec, DWORD target_pid, std::vector<HANDLE_INFO>* out_proc_handles_vec, ACCESS_MASK desired_access);
```

`hijack_thread.cpp`:

```cpp
#include "includes.hpp"

DWORD ThreadHijack(HANDLE h_proc, f_Routine routine, void* arg_routine, DWORD* out, DWORD timeout)
{
	if (!h_proc || !routine || !arg_routine || !out || !timeout)
	{
		return 0;
	}

	ProcessInfo PI;

	if (!PI.SetProcess(h_proc))
	{
		ERRLOG("ThreadHijack: SetProcess error");

		return 0;
	}

	DWORD ThreadId = 0;
	do
	{
		THREAD_STATE state;
		KWAIT_REASON reason;
		
		if (!PI.GetThreadState(&state, &reason) || reason == KWAIT_REASON::WrQueue)
		{
			continue;
		}

		if (!PI.IsThreadWorkerThread() && (PI.IsThreadInAlertableState() || state == THREAD_STATE::Running) && PI.GetTID() != GetCurrentThreadId())
		{
			ThreadId = PI.GetTID();

			break;
		}
	
	} while (PI.NextThread());

	if (!ThreadId)
	{
		ERRLOG("ThreadHijack: no compatible thread found");
	
		return 0;
	}

	HANDLE h_thread = OpenThread(THREAD_GET_CONTEXT | THREAD_SET_CONTEXT | THREAD_SUSPEND_RESUME, NULL, ThreadId);
	if (!h_thread)
	{
		ERRLOG("ThreadHijack: OpenThread: %d", GetLastError());

		return 0;
	}

	if (SUSP_ERR(SuspendThread(h_thread)))
	{
		ERRLOG("ThreadHijack: SuspendThread: %d", GetLastError());

		CloseHandle(h_thread);

		return 0;
	}

	CONTEXT ctx = { 0 };
	ctx.ContextFlags = CONTEXT_CONTROL;

	if (!GetThreadContext(h_thread, &ctx))
	{
		ERRLOG("ThreadHijack: GetThreadContext: %d", GetLastError());

		ResumeThread(h_thread);
		CloseHandle(h_thread);

		return 0;
	}

	void* shellcode_loc = VirtualAllocEx(h_proc, NULL, 0x100, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (!shellcode_loc)
	{
		ERRLOG("ThreadHijack: VirtualAllocEx: %d", GetLastError());

		ResumeThread(h_thread);
		CloseHandle(h_thread);

		return 0;
	}

	void* shellcode_data = VirtualAllocEx(h_proc, NULL, sizeof(SR_REMOTE_DATA), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if (!shellcode_data)
	{
		ERRLOG("ThreadHijack: VirtualAllocEx: %d", GetLastError());
		
		VirtualFreeEx(h_proc, shellcode_loc, NULL, MEM_RELEASE);

		ResumeThread(h_thread);
		CloseHandle(h_thread);

		return 0;
	}

	SR_REMOTE_DATA data;

	_ZeroMemory(&data, sizeof(data));

	data.routine			= routine;
	data.arg_routine		= arg_routine;

	if (!WriteProcessMemory(h_proc, shellcode_data, &data, sizeof(data), NULL))
	{
		ERRLOG("ThreadHijack: WriteProcessMemory: %d", GetLastError());

		ResumeThread(h_thread);
		
		VirtualFreeEx(h_proc, shellcode_loc, NULL, MEM_RELEASE);
		VirtualFreeEx(h_proc, shellcode_data, NULL, MEM_RELEASE);

		CloseHandle(h_thread);

		return 0;
	}

#ifdef _WIN64
#else
	BYTE shellcode[] =
	{
		0x83, 0xEC, 0x04,                           // sub esp, 0x04
		0xC7, 0x04, 0x24, 0x00, 0x00, 0x00, 0x00,   // mov [esp], old_eip           ; save old eip into stack to return

		0x53, 0x52, 0x50, 0x51,                     // push e(b/d/a/c)x
		0x9C,										// pushfd

		0xBA, 0x00, 0x00, 0x00, 0x00,				// mov edx, SR_REMOTE_DATA
		
		0xC6, 0x02, 0x01,							// mov BYTE PTR [edx], 0x01     ; SR_WR_EXECUTING
		
		0x52,										// push edx                     ; save edx
		0xFF, 0x72, 0x08,							// push [edx + 0x08]            ; push arg to f_Routine
		0xFF, 0x52, 0x0C,							// call DWORD PTR [edx + 0x0C]  ; call f_Routine
		0x5A,										// pop edx                      ; restore edx
		0x89, 0x42, 0x10,							// mov [edx + 0x10], eax        ; store returned value

		0x64, 0xA1, 0x18, 0x00, 0x00, 0x00,			// mov eax, fs:[0x18]			; GetLastError
		0x8B, 0x40, 0x34,							// mov eax, [eax + 0x34]
		0x89, 0x42, 0x04,							// mov [edx + 0x04], eax        ; save last error

		0xC6, 0x02, 0x02,							// mov BYTE PTR [edx], 0x02     ; SR_WR_EXECUTING_FINISHED
		
		0x9D,										// popfd
		0x59, 0x58, 0x5A, 0x5B,						// pop e(c/a/d/b)x
		0xC3										// ret                          ; return to old eip
	};

	DWORD old_eip = ctx.Eip;
	*(DWORD*)(shellcode + 0x06) = old_eip;
	*(DWORD*)(shellcode + 0x10) = (DWORD)shellcode_data;

	ctx.Eip = (DWORD)shellcode_loc;

#endif

	if (!WriteProcessMemory(h_proc, shellcode_loc, shellcode, sizeof(shellcode), NULL))
	{
		ERRLOG("ThreadHijack: WriteProcessMemory: %d", GetLastError());

		ResumeThread(h_thread);

		VirtualFreeEx(h_proc, shellcode_data, NULL, MEM_RELEASE);
		VirtualFreeEx(h_proc, shellcode_loc, NULL, MEM_RELEASE);

		CloseHandle(h_thread);

		return 0;
	}

	if (!SetThreadContext(h_thread, &ctx))
	{
		ERRLOG("ThreadHijack: SetThreadContext: %d", GetLastError());

		ResumeThread(h_thread);
		
		VirtualFreeEx(h_proc, shellcode_data, NULL, MEM_RELEASE);
		VirtualFreeEx(h_proc, shellcode_loc, NULL, MEM_RELEASE);
		
		CloseHandle(h_thread);

		return 0;
	}

	if (SUSP_ERR(ResumeThread(h_thread)))
	{
		ERRLOG("ThreadHijack: SetThreadContext: %d", GetLastError());

#ifdef _WIN64
		ctx.Rip = old_rip;
#else
		ctx.Eip = old_eip;
#endif
		SetThreadContext(h_thread, &ctx);

		ResumeThread(h_thread);
		
		VirtualFreeEx(h_proc, shellcode_data, NULL, MEM_RELEASE);
		VirtualFreeEx(h_proc, shellcode_loc, NULL, MEM_RELEASE);
		
		CloseHandle(h_thread);

		return 0;
	}

	ULONGLONG time = GetTickCount64();
	while (GetTickCount64() - time < timeout)
	{
		if (!ReadProcessMemory(h_proc, shellcode_data, &data, sizeof(data), NULL))
		{
			ERRLOG("ThreadHijack: ReadProcessMemory: %d", GetLastError());

#ifdef _WIN64
			ctx.Rip = old_rip;
#else
			ctx.Eip = old_eip;
#endif
			if (!SUSP_ERR(SuspendThread(h_thread)) && SetThreadContext(h_thread, &ctx) && !SUSP_ERR(ResumeThread(h_thread)))
			{
				VirtualFreeEx(h_proc, shellcode_data, NULL, MEM_RELEASE);
				VirtualFreeEx(h_proc, shellcode_loc, NULL, MEM_RELEASE);
			}

			CloseHandle(h_thread);

			return 0;
		}
		
		if (data.status == SR_WORK_STATUS::WS_EXECUTING_FINISHED)
		{
			break;
		}
	}

	if (data.status != SR_WORK_STATUS::WS_EXECUTING_FINISHED)
	{
		if (data.status == SR_WORK_STATUS::WS_PENDING)
		{
			ERRLOG("ThreadHijack: shellcode execute timeout");
#ifdef _WIN64
			ctx.Rip = old_rip;
#else
			ctx.Eip = old_eip;
#endif
			if (!SUSP_ERR(SuspendThread(h_thread)) && SetThreadContext(h_thread, &ctx) && !SUSP_ERR(ResumeThread(h_thread)))
			{
				VirtualFreeEx(h_proc, shellcode_data, NULL, MEM_RELEASE);
				VirtualFreeEx(h_proc, shellcode_loc, NULL, MEM_RELEASE);
			}

			CloseHandle(h_thread);

			return 0;
		}

		ERRLOG("ThreadHijack: timeout");

		CloseHandle(h_thread);
		
		return 0;
	}

	*out = data.ret;

	VirtualFreeEx(h_proc, shellcode_data, NULL, MEM_RELEASE);
	VirtualFreeEx(h_proc, shellcode_loc, NULL, MEM_RELEASE);

	CloseHandle(h_thread);

	printf("[ SUCCESS ] ThreadHijack: execution finished\n");

	return 1;
}
```

`hook_scanner.cpp`:

```cpp
#include "includes.hpp"

bool HookScanAndPatch(std::vector<HOOK_SCAN_DATA>* hk_vec, HANDLE h_proc)
{
	if (!hk_vec || !h_proc)
	{
		return false;
	}

	if (!hk_vec->empty())
	{
		hk_vec->clear();
	}

	ProcessInfo PI;

	if (!PI.SetProcess(h_proc))
	{
		return false;
	}

	DWORD modules_count	 = sizeof(modules) / sizeof(modules[0]);
	DWORD funcs_count	 = sizeof(to_hk_scan) / sizeof(to_hk_scan[0]);

	for (DWORD i = 0; i < modules_count; ++i)
	{
		HMODULE mod			= GetModuleHandleW(modules[i]);
		HMODULE remote_mod  = PI._GetModuleHandle(modules[i]);
		
		if (!mod || !remote_mod)
		{
			if (!hk_vec->empty())
			{
				hk_vec->clear();
			}
		
			return false;
		}
		
		for (DWORD j = 0; j < funcs_count; ++j)
		{
			DWORD func_addr = (DWORD)GetProcAddress(mod, to_hk_scan[j]);
			
			if (func_addr)
			{
				HOOK_SCAN_DATA data;

				data.func_addr = (void*)(func_addr - (DWORD)mod + (DWORD)remote_mod);
				data.func_name = to_hk_scan[j];
				
				memcpy(data.orig_bytes, (void*)func_addr, SCAN_BYTES_COUNT);

				if (!ReadProcessMemory(h_proc, data.func_addr, data.remote_bytes, SCAN_BYTES_COUNT, NULL))
				{
					if (!hk_vec->empty())
					{
						hk_vec->clear();
					}

					return false;
				}

				hk_vec->push_back(data);
			}
		}
	}

	if (hk_vec->empty())
	{
		return false;
	}

	if (hk_vec->size() != funcs_count)
	{
		hk_vec->clear();

		return false;
	}

	CompareFuncs(hk_vec);

	if (!RestoreHookedFuncs(hk_vec, h_proc, HOOK_RESTORE_MODE::HRM_RESTORE_ORIG))
	{
		hk_vec->clear();

		return false;
	}

	return true;
}

bool CompareFuncs(std::vector<HOOK_SCAN_DATA>* hk_vec)
{
	if (!hk_vec || hk_vec->empty())
	{
		return false;
	}

	for (auto& el : *hk_vec)
	{
		el.hooked = false;

		for (DWORD i = 0; i < SCAN_BYTES_COUNT; ++i)
		{
			if (el.orig_bytes[i] != el.remote_bytes[i])
			{
				el.hooked = true;
			
				LOG("%s hooked", el.func_name.c_str());

				break;
			}
		}
	}

	return true;
}

bool RestoreHookedFuncs(std::vector<HOOK_SCAN_DATA>* hk_vec, HANDLE h_proc, HOOK_RESTORE_MODE mode)
{
	if (!hk_vec || hk_vec->empty() || !h_proc)
	{
		return false;
	}

	for (auto& el : *hk_vec)
	{
		if (el.hooked)
		{
			if (mode == HOOK_RESTORE_MODE::HRM_RESTORE_ORIG)
			{
				if (!WriteProcessMemory(h_proc, el.func_addr, el.orig_bytes, SCAN_BYTES_COUNT, NULL))
				{
					return false;
				}

				LOG("%s original bytes restored", el.func_name.c_str());
			}
			else
			{
				if (!WriteProcessMemory(h_proc, el.func_addr, el.remote_bytes, SCAN_BYTES_COUNT, NULL))
				{
					return false;
				}

				LOG("%s hook bytes restored", el.func_name.c_str());
			}
		}
	}

	return true;
}
```

`hook_scanner.hpp`:

```hpp
#pragma once

#define SCAN_BYTES_COUNT 0x10

static const wchar_t* modules[] =
{
	L"kernel32.dll",
	L"ntdll.dll"
};

static const char* to_hk_scan[] =
{
	"NtQueryObject",
	"LdrGetProcedureAddress",
	"LdrLoadDll",
	"LdrUnloadDll",
	"RtlFreeHeap",
	"RtlAllocateHeap",
	"NtAllocateVirtualMemory",
	"NtFreeVirtualMemory",
	"memmove",
	"NtOpenFile",
	"NtSetInformationFile",
	"NtClose",
	"NtSetInformationFile",
	"NtQueryInformationFile",
	"NtReadFile",
	"LdrLockLoaderLock",
	"LdrUnlockLoaderLock",
	"memset",
	"RtlRbRemoveNode",
	"NtCreateThreadEx",
	"NtQuerySystemInformation",

	"LoadLibraryExW",
	"LoadLibraryA",
	"FreeLibrary",
	"GetLastError",
};

enum class HOOK_RESTORE_MODE
{
	HRM_RESTORE_ORIG,
	HRM_RESTORE_HOOK
};

struct HOOK_SCAN_DATA
{
	BYTE			orig_bytes[SCAN_BYTES_COUNT]	= { 0 };
	BYTE			remote_bytes[SCAN_BYTES_COUNT]	= { 0 };
	std::string		func_name						= { 0 };
	void*			func_addr						= 0;
	bool			hooked							= false;
};

bool HookScanAndPatch(std::vector<HOOK_SCAN_DATA>* hk_vec, HANDLE h_proc);
bool CompareFuncs(std::vector<HOOK_SCAN_DATA>* hk_vec);
bool RestoreHookedFuncs(std::vector<HOOK_SCAN_DATA>* hk_vec, HANDLE h_proc, HOOK_RESTORE_MODE mode);
```

`import_handler.cpp`:

```cpp
#include "includes.hpp"

DWORD GetOSVersion()
{
	if (g_os_build_number)
	{
		return g_os_build_number;
	}

#ifdef _WIN64
	PEB* peb = (PEB*)__readgsqword(0x60);
#else
	PEB* peb = (PEB*)__readfsdword(0x30);
#endif

	if (!peb)
	{
		return 0;
	}

	DWORD v_hi = peb->OSMajorVersion;
	DWORD v_lo = peb->OSMinorVersion;

	for (; v_lo >= 10; v_lo /= 10);

	g_os_version = v_hi * 10 + v_lo;
	g_os_build_number = peb->OSBuildNumber;

	return g_os_version;
}

DWORD GetOSBuildVersion()
{
	return g_os_build_number;
}

bool IsWin7OrGreater()
{
	return (GetOSVersion() >= g_Win7);
}

bool IsWin8OrGreater()
{
	return (GetOSVersion() >= g_Win8);
}

bool IsWin81OrGreater()
{
	return (GetOSVersion() >= g_Win81);
}

bool IsWin10OrGreater()
{
	return (GetOSVersion() >= g_Win10);

}

bool IsWin11OrGreater()
{
	return (GetOSVersion() >= g_Win11 && GetOSBuildVersion() >= g_Win11_21H2);
}

template <typename T>
DWORD GetSymAddressNative(const wchar_t* sym_name, T& func, IMPORT_INDEX mode = IMPORT_INDEX::II_NTDLL)
{
	if (!sym_parser.IsReady())
	{
		return 0;
	}

	DWORD RVA = sym_parser.GetSymbolAddress(sym_name);
	if (!RVA)
	{
		return 0;
	}

	DWORD ret = 0;
	switch (mode)
	{
	case IMPORT_INDEX::II_NTDLL:
		ret = RVA + (DWORD)g_h_NTDLL;
		break;

	case IMPORT_INDEX::II_KERNEL32:
		ret = RVA + (DWORD)g_h_KERNEL32;
		break;
	}

	if (ret)
	{
		func = (T)ret;
	}

	return ret;
}

bool ResolveImports(SymbolLoader* loader)
{
	if (!loader)
	{
		return false;
	}

	if (!loader->IsReady())
	{
		return false;
	}

	if (!g_h_NTDLL)
	{
		g_h_NTDLL = LoadLibraryW(L"ntdll.dll");

		if (!g_h_NTDLL)
		{
			return false;
		}
	}
	
	if (!g_h_KERNEL32)
	{
		g_h_KERNEL32 = LoadLibraryW(L"kernel32.dll");

		if (!g_h_KERNEL32)
		{
			return false;
		}
	}

	if (!sym_parser.Initialize(loader))
	{
		return false;
	}

	INIT_WIN32_FUNC(LoadLibraryA, g_h_KERNEL32);
	INIT_WIN32_FUNC(LoadLibraryExW, g_h_KERNEL32);
	INIT_WIN32_FUNC(GetLastError, g_h_KERNEL32);
	INIT_WIN32_FUNC(FreeLibrary, g_h_KERNEL32);

	if (!NATIVE::p_LoadLibraryA || !NATIVE::p_FreeLibrary || !NATIVE::p_GetLastError || !NATIVE::p_LoadLibraryExW)
	{
		return false;
	}

	if (!GetSymAddressNative(_FUNC_(NtQueryObject)))						return false;
	if (!GetSymAddressNative(_FUNC_(NtQuerySystemInformation)))				return false;

	if (!GetSymAddressNative(_FUNC_(LdrGetProcedureAddress)))				return false;

	if (!GetSymAddressNative(_FUNC_(LdrLoadDll)))							return false;
	if (!GetSymAddressNative(_FUNC_(LdrUnloadDll)))							return false;

	if (!GetSymAddressNative(_FUNC_(LdrpHeap)))								return false;
	if (!GetSymAddressNative(_FUNC_(LdrpInvertedFunctionTable)))			return false;
	if (!GetSymAddressNative(_FUNC_(LdrpMappingInfoIndex)))					return false;
	if (!GetSymAddressNative(_FUNC_(LdrpModuleBaseAddressIndex)))			return false;

	if (!GetSymAddressNative(_FUNC_(RtlFreeHeap)))							return false;

	if (!GetSymAddressNative(_FUNC_(RtlAllocateHeap)))						return false;
	if (!GetSymAddressNative(_FUNC_(NtAllocateVirtualMemory)))				return false;
	if (!GetSymAddressNative(_FUNC_(NtFreeVirtualMemory)))					return false;
	if (!GetSymAddressNative(_FUNC_(NtProtectVirtualMemory)))				return false;
	if (!GetSymAddressNative(_FUNC_(LdrProtectMrdata)))						return false;

	if (!GetSymAddressNative(_FUNC_(memmove)))								return false;
	if (!GetSymAddressNative(_FUNC_(memset)))								return false;

	if (!GetSymAddressNative(_FUNC_(NtOpenFile)))							return false;
	if (!GetSymAddressNative(_FUNC_(NtClose)))								return false;
	if (!GetSymAddressNative(_FUNC_(NtSetInformationFile)))					return false;
	if (!GetSymAddressNative(_FUNC_(NtQueryInformationFile)))				return false;
	if (!GetSymAddressNative(_FUNC_(NtReadFile)))							return false;

	if (!GetSymAddressNative(_FUNC_(LdrLockLoaderLock)))					return false;
	if (!GetSymAddressNative(_FUNC_(LdrUnlockLoaderLock)))					return false;

	if (!GetSymAddressNative(_FUNC_(NtCreateThreadEx)))						return false;
	
	if (!GetSymAddressNative(_FUNC_(RtlRbRemoveNode)))						return false;
	if (!GetSymAddressNative(_FUNC_(RtlAddVectoredExceptionHandler)))		return false;
	if (!GetSymAddressNative(_FUNC_(RtlRemoveVectoredExceptionHandler)))	return false;
	if (!GetSymAddressNative(_FUNC_(RtlInsertInvertedFunctionTable)))		return false;
	
	return true;
}
```

`import_handler.hpp`:

```hpp
#pragma once

#define NT_FUNC(func) inline f_##func func = nullptr
#define NT_LOCAL(func) f_##func func = nullptr
#define INIT_CONSTRUCTOR_NATIVE(func) func = NATIVE::##func

#define WIN32_FUNC(func) inline decltype(func)* p_##func = nullptr
#define WIN32_LOCAL(func) decltype(func)* p_##func = nullptr
#define INIT_WIN32_FUNC(func, h_k32) NATIVE::p_##func = (decltype(func)*)GetProcAddress(h_k32, #func)
#define INIT_CONSTRUCTOR_NATIVE_WIN32(func) p_##func = NATIVE::p_##func

#define _FUNC_(func) L#func, NATIVE::##func

DWORD GetOSVersion();
DWORD GetOSBuildVersion();

bool IsWin7OrGreater();
bool IsWin8OrGreater();
bool IsWin81OrGreater();
bool IsWin10OrGreater();
bool IsWin11OrGreater();

enum class IMPORT_INDEX
{
	II_NTDLL,
	II_KERNEL32
};

namespace NATIVE
{
	NT_FUNC(NtQueryObject);
	NT_FUNC(LdrGetProcedureAddress);
	NT_FUNC(LdrLoadDll);
	NT_FUNC(LdrUnloadDll);
	NT_FUNC(RtlFreeHeap);
	NT_FUNC(LdrpHeap);
	NT_FUNC(RtlAllocateHeap);
	NT_FUNC(NtAllocateVirtualMemory);
	NT_FUNC(NtProtectVirtualMemory);
	NT_FUNC(NtFreeVirtualMemory);
	NT_FUNC(memmove);
	NT_FUNC(NtOpenFile);
	NT_FUNC(NtClose);
	NT_FUNC(NtSetInformationFile);
	NT_FUNC(NtQueryInformationFile);
	NT_FUNC(NtQuerySystemInformation);
	NT_FUNC(NtReadFile);
	NT_FUNC(LdrLockLoaderLock);
	NT_FUNC(LdrUnlockLoaderLock);
	NT_FUNC(NtCreateThreadEx);
	NT_FUNC(RtlRbRemoveNode);
	NT_FUNC(LdrpModuleBaseAddressIndex);
	NT_FUNC(LdrpMappingInfoIndex);
	NT_FUNC(memset);
	NT_FUNC(LdrProtectMrdata);
	NT_FUNC(RtlAddVectoredExceptionHandler);
	NT_FUNC(LdrpInvertedFunctionTable);
	NT_FUNC(RtlInsertInvertedFunctionTable);
	NT_FUNC(RtlRemoveVectoredExceptionHandler);

	WIN32_FUNC(LoadLibraryA);
	WIN32_FUNC(FreeLibrary);
	WIN32_FUNC(LoadLibraryExW);
	WIN32_FUNC(GetLastError);
}

bool ResolveImports(class SymbolLoader* loader);
```

`includes.hpp`:

```hpp
#pragma once

#include <Windows.h>
#include <WinInet.h>
#include <dbghelp.h>
#include <iostream>
#include <fstream>
#include <TlHelp32.h>
#include <vector>
#include <locale>
#include <codecvt>
#include <map>
#include <string>
#include <filesystem>
#include "NT Defs.h"
#include "NT Funcs.h"
#include "Win10.h"
#include "Win8.h"
#include "Win7.h"
#include "Win81.h"
#include "Win11.h"
#include "globals.hpp"
#include "tools.hpp"
#include "process_info.hpp"
#include "start_routine.hpp"
#include "hijack_handle.hpp"
#include "injection.hpp"
#include "hook_scanner.hpp"
#include "import_handler.hpp"
#include "manual_map.hpp"
#include "symbol_loader.hpp"
#include "symbol_parser.hpp"
#include "externs.hpp"
#include "inject_internal.hpp"
#include "namespaces.hpp"
#include "veh_shell.hpp"

#pragma warning(disable: 4201) // unnamed union (nt structures)
#pragma warning(disable: 4324) // structure member alignment resulting in additional bytes being added as padding
#pragma warning(disable: 6001) // uninitialized memory & handles (false positive in for loops with continue statements)
#pragma warning(disable: 6258) // TerminateThread warning
#pragma warning(disable: 4996) // some deprications
```

`inject_internal.cpp`:

```cpp
#include "includes.hpp"

INJECT_INTERNAL_FUNCTION_TABLE::INJECT_INTERNAL_FUNCTION_TABLE()
{
	INIT_CONSTRUCTOR_NATIVE(RtlRbRemoveNode);
	INIT_CONSTRUCTOR_NATIVE(memmove);
	INIT_CONSTRUCTOR_NATIVE(memset);
	INIT_CONSTRUCTOR_NATIVE(NtProtectVirtualMemory);
	INIT_CONSTRUCTOR_NATIVE(LdrpMappingInfoIndex);
	INIT_CONSTRUCTOR_NATIVE(LdrpModuleBaseAddressIndex);
	
	INIT_CONSTRUCTOR_NATIVE_WIN32(LoadLibraryExW);
	INIT_CONSTRUCTOR_NATIVE_WIN32(FreeLibrary);
	INIT_CONSTRUCTOR_NATIVE_WIN32(GetLastError);
}

DWORD CODE_SEG(".inj_int$1") __stdcall InjectInternal(INJECT_INTERNAL_DATA* data)
{
	if (!data)
	{
		return 0;
	}

	INJECT_INTERNAL_FUNCTION_TABLE* f = &data->f;
	DWORD flags = data->flags;

	HMODULE h_dll = f->p_LoadLibraryExW(data->dll_path, NULL, NULL);
	if (!h_dll)
	{
		data->last_error = f->p_GetLastError();

		return 0;
	}

	if (flags & (INJ_ERASE_HEADER | INJ_FAKE_HEADER))
	{
		HANDLE h_proc = NtCurrentProcess();

		DWORD old_protect = 0;
		SIZE_T size = PAGE_SIZE;

		data->last_error = f->NtProtectVirtualMemory(h_proc, (void**)&h_dll, &size, PAGE_EXECUTE_READWRITE, &old_protect);

		if (NT_FAIL(data->last_error))
		{
			f->p_FreeLibrary(h_dll);

			return 0;
		}

		if (flags & INJ_ERASE_HEADER)
		{
			f->_ZeroMemory(h_dll, size);
		}
		else
		{
			wchar_t nt_dll[10] = { 0 };

			nt_dll[0] = L'n';
			nt_dll[1] = L't';
			nt_dll[2] = L'd';
			nt_dll[3] = L'l';
			nt_dll[4] = L'l';
			nt_dll[5] = L'.';
			nt_dll[6] = L'd';
			nt_dll[7] = L'l';
			nt_dll[8] = L'l';
			nt_dll[9] = L'\0';

			HMODULE h_nt = f->p_LoadLibraryExW(nt_dll, NULL, NULL);
			
			if (!h_nt)
			{
				data->last_error = f->p_GetLastError();

				f->p_FreeLibrary(h_dll);

				return 0;
			}

			f->memmove(h_dll, h_nt, size);

			f->p_FreeLibrary(h_nt);
		}

		data->last_error = f->NtProtectVirtualMemory(h_proc, (void**)&h_dll, &size, old_protect, &old_protect);

		if (NT_FAIL(data->last_error))
		{
			f->p_FreeLibrary(h_dll);

			return 0;
		}
	}

	if (flags & INJ_UNLINK_FROM_PEB)
	{

#ifdef _WIN64
		PEB* peb = (PEB*)__readgsqword(0x60);
#else
		PEB* peb = (PEB*)__readfsdword(0x30);
#endif

		if (!peb)
		{
			f->p_FreeLibrary(h_dll);

			return 0;
		}

		LIST_ENTRY* head		= &peb->Ldr->InLoadOrderModuleListHead;
		LIST_ENTRY* current		= peb->Ldr->InLoadOrderModuleListHead.Flink;

		while (current != head)
		{
			if (((LDR_DATA_TABLE_ENTRY*)current)->DllBase == h_dll)
			{
				break;
			}

			current = current->Flink;
		}

		if (((LDR_DATA_TABLE_ENTRY*)current)->DllBase != h_dll)
		{
			f->p_FreeLibrary(h_dll);

			return 0;
		}

		LDR_DATA_TABLE_ENTRY* entry = (LDR_DATA_TABLE_ENTRY*)current;

		UNLINK_IF(entry->InMemoryOrderLinks);
		UNLINK_IF(entry->InLoadOrderLinks);
		UNLINK_IF(entry->InInitializationOrderLinks);

		DWORD ldr_size		= 0;
		DWORD ddag_size		= 0;
		void* ddag			= nullptr;

		if (data->os_version == g_Win7)
		{
			LDR_DATA_TABLE_ENTRY_WIN7* entry_w7 = (LDR_DATA_TABLE_ENTRY_WIN7*)current;

			UNLINK_IF(entry_w7->ServiceTagLinks);
			UNLINK_IF(entry_w7->StaticLinks);
			UNLINK_IF(entry_w7->ForwarderLinks);

			ldr_size = sizeof(LDR_DATA_TABLE_ENTRY_WIN7);
		}
		else
		{
			f->RtlRbRemoveNode(f->LdrpModuleBaseAddressIndex,	&entry->BaseAddressIndexNode);
			f->RtlRbRemoveNode(f->LdrpMappingInfoIndex,			&entry->MappingInfoIndexNode);

			ddag = (void*)&entry->DdagNode;

			if (data->os_version == g_Win8)
			{
				ldr_size = sizeof(LDR_DATA_TABLE_ENTRY_WIN8);
				ddag_size = sizeof(LDR_DDAG_NODE_WIN8);
			}
			else if (data->os_version == g_Win81)
			{
				ldr_size = sizeof(LDR_DATA_TABLE_ENTRY_WIN81);
				ddag_size = sizeof(LDR_DDAG_NODE_WIN81);
			}
			else if (data->os_version >= g_Win10)
			{
				ddag_size = sizeof(LDR_DDAG_NODE_WIN10);

				if (data->os_build_version <= g_Win10_1511)
				{
					ldr_size = offsetof(LDR_DATA_TABLE_ENTRY_WIN10, DependentLoadFlags);
				}
				else if (data->os_build_version <= g_Win10_1607)
				{
					ldr_size = offsetof(LDR_DATA_TABLE_ENTRY_WIN10, SigningLevel);
				}
				else if (data->os_build_version <= g_Win10_21H2)
				{
					ldr_size = sizeof(LDR_DATA_TABLE_ENTRY_WIN10);
				}
				else
				{
					ldr_size = sizeof(LDR_DATA_TABLE_ENTRY_WIN11);
					ddag_size = sizeof(LDR_DDAG_NODE_WIN11);
				}
			}
		}

		f->_ZeroMemory(entry->BaseDllName.szBuffer, entry->BaseDllName.MaxLength);
		f->_ZeroMemory(entry->FullDllName.szBuffer, entry->FullDllName.MaxLength);

		f->_ZeroMemory(entry, ldr_size);

		if (ddag)
		{
			f->_ZeroMemory(ddag, ddag_size);
		}
	}

	data->h_dll_out = h_dll;

	return 1;
}

DWORD CODE_SEG(".inj_int$2") __stdcall InjectInternal_End()
{
	return 0;
}

INJECT_INTERNAL_DATA::INJECT_INTERNAL_DATA(INJECTION_DATA* data, DWORD os_ver, DWORD os_build_ver)
{
	wcscpy(dll_path, data->dll_path);
	flags = data->flags;
	os_version = os_ver;
	os_build_version = os_build_ver;
}
```

`inject_internal.hpp`:

```hpp
#pragma once

#define UNLINK_IF(e) if (e.Flink && e.Blink) { e.Flink->Blink = e.Blink; e.Blink->Flink = e.Flink; }

struct INJECT_INTERNAL_FUNCTION_TABLE
{
	NT_LOCAL(RtlRbRemoveNode);
	NT_LOCAL(LdrpModuleBaseAddressIndex);
	NT_LOCAL(LdrpMappingInfoIndex);
	NT_LOCAL(NtProtectVirtualMemory);
	NT_LOCAL(memmove);
	NT_LOCAL(memset);
	
	WIN32_LOCAL(LoadLibraryExW);
	WIN32_LOCAL(FreeLibrary);
	WIN32_LOCAL(GetLastError);

	INJECT_INTERNAL_FUNCTION_TABLE();
};

struct INJECT_INTERNAL_DATA
{
	HMODULE		h_dll_out			= 0;
	DWORD		flags				= 0;
	DWORD		last_error			= 0;
	DWORD		os_version			= 0;
	DWORD		os_build_version	= 0; 
	wchar_t		dll_path[MAX_PATH]	= { 0 };

	INJECT_INTERNAL_FUNCTION_TABLE f;

	INJECT_INTERNAL_DATA(INJECTION_DATA* data, DWORD os_ver, DWORD os_build_ver);
};

DWORD CODE_SEG(".inj_int$1") __stdcall InjectInternal(INJECT_INTERNAL_DATA* data);
DWORD CODE_SEG(".inj_int$2") __stdcall InjectInternal_End();
```

`injection.cpp`:

```cpp
#include "includes.hpp"

DWORD Inject(INJECTION_DATA* data)
{
	if (!data)
	{
		return 0;
	}

	wchar_t* dll_path = data->dll_path;

	if (!dll_path)
	{
		return 0;
	}

	if (!fs::exists(dll_path))
	{
		return 0;
	}
	
	DWORD flags = data->flags;

	DWORD		target_id	= 0;
	HANDLE		h_proc		= 0;
	wchar_t*	proc_name	= nullptr;

	if (flags & INJ_BY_PROCESS_ID)
	{
		if (flags & (INJ_BY_HANDLE_HIJACK_AND_ID | INJ_BY_PROCESS_NAME | INJ_BY_HANDLE | INJ_BY_HANDLE_HIJACK_AND_NAME))
		{
			return 0;
		}

		target_id = *(DWORD*)data->data_buf;
	}
	else if (flags & INJ_BY_HANDLE_HIJACK_AND_ID)
	{
		if (flags & (INJ_BY_PROCESS_NAME | INJ_BY_PROCESS_ID | INJ_BY_HANDLE | INJ_BY_HANDLE_HIJACK_AND_NAME))
		{
			return 0;
		}
	
		target_id = *(DWORD*)data->data_buf;
	}
	else if (flags & INJ_BY_HANDLE_HIJACK_AND_NAME)
	{
		if (flags & (INJ_BY_PROCESS_NAME | INJ_BY_PROCESS_ID | INJ_BY_HANDLE | INJ_BY_HANDLE_HIJACK_AND_ID))
		{
			return 0;
		}

		proc_name = (wchar_t*)data->data_buf;
	}
	else if (flags & INJ_BY_PROCESS_NAME)
	{
		if (flags & (INJ_BY_PROCESS_ID | INJ_BY_HANDLE | INJ_BY_HANDLE_HIJACK_AND_ID | INJ_BY_HANDLE_HIJACK_AND_NAME))
		{
			return 0;
		}

		proc_name = (wchar_t*)data->data_buf;
	}
	else if (flags & INJ_BY_HANDLE)
	{
		if (flags & (INJ_BY_PROCESS_ID | INJ_BY_PROCESS_NAME | INJ_BY_HANDLE_HIJACK_AND_ID | INJ_BY_HANDLE_HIJACK_AND_NAME))
		{
			return 0;
		}

		h_proc = *(HANDLE*)data->data_buf;
	}
	else
	{
		return 0;
	}

	if (flags & (INJ_BY_PROCESS_NAME | INJ_BY_HANDLE_HIJACK_AND_NAME))
	{
		if (!proc_name)
		{
			return 0;
		}

		if (!wcslen(proc_name))
		{
			return 0;
		}

		target_id = GetProcId(proc_name);

		if (!target_id)
		{
			return 0;
		}
	}

	ACCESS_MASK access_mask = PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION | PROCESS_QUERY_LIMITED_INFORMATION;
	if (data->method == LAUNCH_METHOD::LM_NT_CREATE_THREAD_EX)
	{
		access_mask |= PROCESS_CREATE_THREAD;
	}

	if (flags & (INJ_BY_HANDLE_HIJACK_AND_NAME | INJ_BY_HANDLE_HIJACK_AND_ID)) // handle hijacking procedure
	{
		return HijackHandle(data, access_mask, target_id);
	}
	else if (flags & (INJ_BY_PROCESS_ID | INJ_BY_PROCESS_NAME))
	{
		h_proc = OpenProcess(access_mask, NULL, target_id);
	}

	DWORD info_flags = 0;
	if (!h_proc || !GetHandleInformation(h_proc, &info_flags))
	{
		return 0;
	}

	bool is_native = IsNativeProcess(h_proc);
#ifdef _WIN64
	if (is_native)
	{
		if (!VerifyDLL(dll_path, IMAGE_FILE_MACHINE_AMD64))
		{
			return 0;
		}
	}
	else
	{
		if (!VerifyDLL(dll_path, IMAGE_FILE_MACHINE_I386))
		{
			return 0;
		}
	}
#else
	if (!VerifyDLL(dll_path, IMAGE_FILE_MACHINE_I386))
	{
		return 0;
	}
#endif

	if (flags & INJ_LOAD_DLL_COPY)
	{
		wchar_t* temp_dir = new wchar_t[MAX_PATH];
		
		if (!temp_dir)
		{
			return 0;
		}

		if (!GetTempPathW(MAX_PATH, temp_dir))
		{
			delete[] temp_dir;
			
			return 0;
		}

		std::wstring new_path = temp_dir;

		delete[] temp_dir;

		new_path += fs::path(data->dll_path).filename();

		try
		{
			if (!fs::copy_file(data->dll_path, new_path))
			{
				return 0;
			}
		}
		catch (fs::filesystem_error& err)
		{
			if (err.code().value() != 80)
			{
				return 0;
			}
		}
	
		wcscpy(data->dll_path, new_path.c_str());
	}
	
	if (flags & INJ_SCRAMBLE_DLL_NAME)
	{
		wchar_t* scrambled_name = new wchar_t[11];

		if (!scrambled_name)
		{
			return 0;
		}

		srand(time(NULL));

		for (DWORD i = 0; i < 10; ++i)
		{
			int rand_choose = _random(1, 3);

			switch (rand_choose)
			{
			case 1:
				scrambled_name[i] = wchar_t('a' + _random(0, 25));
				break;

			case 2:
				scrambled_name[i] = wchar_t('A' + _random(0, 25));
				break;

			case 3:
				scrambled_name[i] = wchar_t('0' + _random(0, 8));
				break;
			}
		}

		scrambled_name[10] = L'\0';

		fs::path scrambled_path(data->dll_path);

		scrambled_path.remove_filename();
		scrambled_path += scrambled_name;
		scrambled_path += L".dll";
		
		delete[] scrambled_name;

		fs::rename(data->dll_path, scrambled_path);

		wcscpy(data->dll_path, scrambled_path.c_str());
	}

	DWORD result = 0;

	std::vector<HOOK_SCAN_DATA> hk_vec;

	if (!HookScanAndPatch(&hk_vec, h_proc))
	{
		return 0;
	}

	if (data->mode == INJECTION_MODE::IM_MANUAL_MAPPING)
	{
		BYTE* mm_data_base		= nullptr;
		BYTE* mm_shell_base		= nullptr;
		BYTE* veh_shell_base	= nullptr;
		
		MANUAL_MAPPING_SHELL_DATA* mm_data = nullptr;

		size_t mm_size			= (size_t)ManualMapShellEnd - (size_t)ManualMapShell;
		size_t veh_shell_size	= (size_t)VEHShell_End - (size_t)VEHShell;
		
		veh_shell_base = (BYTE*)VirtualAllocEx(h_proc, NULL, veh_shell_size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
		if (!veh_shell_base)
		{
			result = 0;

			goto MM_FAIL;
		}

		if (!WriteProcessMemory(h_proc, veh_shell_base, VEHShell, veh_shell_size, NULL))
		{
			result = 0;

			goto MM_FAIL;
		}

		mm_data = new MANUAL_MAPPING_SHELL_DATA(data, GetOSVersion(), veh_shell_base, veh_shell_size);
		if (!mm_data)
		{
			result = 0;

			goto MM_FAIL;
		}

		mm_data_base = (BYTE*)VirtualAllocEx(h_proc, NULL, sizeof(MANUAL_MAPPING_SHELL_DATA), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
		if (!mm_data_base)
		{
			result = 0;
		
			goto MM_FAIL;
		}

		if (!WriteProcessMemory(h_proc, mm_data_base, mm_data, sizeof(MANUAL_MAPPING_SHELL_DATA), NULL))
		{
			ERRLOG("Inject: WriteProcessMemory error: %d", GetLastError());
			
			result = 0;

			goto MM_FAIL;
		}


		mm_shell_base = (BYTE*)VirtualAllocEx(h_proc, NULL, mm_size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
		if (!mm_shell_base)
		{
			result = 0;
			
			goto MM_FAIL;
		}

		if (!WriteProcessMemory(h_proc, mm_shell_base, ManualMapShell, mm_size, NULL))
		{
			result = 0;
		
			goto MM_FAIL;
		}

		result = StartRoutine(data->method, h_proc, (f_Routine)mm_shell_base, data->flags, mm_data_base, &data->out, START_ROUTINE_DEFAULT_TIMEOUT);
		
		if (result)
		{
			if (!ReadProcessMemory(h_proc, mm_data_base, &data->h_dll_out, sizeof(HMODULE), NULL))
			{
				result = 0;

				goto MM_FAIL;
			}
		}
		else
		{
			data->h_dll_out = 0;
		}

	MM_FAIL:

		if (mm_data)
		{
			delete mm_data;
		}

		if (mm_data_base)
		{
			VirtualFreeEx(h_proc, mm_data_base, NULL, MEM_RELEASE);
		}

		if (mm_shell_base)
		{
			VirtualFreeEx(h_proc, mm_shell_base, NULL, MEM_RELEASE);
		}
	}
	else // LoadLibraryExW
	{
		INJECT_INTERNAL_DATA llib_data(data, GetOSVersion(), GetOSBuildVersion());

		size_t llib_size = (size_t)InjectInternal_End - (size_t)InjectInternal;

		BYTE* llib_data_base = nullptr;
		BYTE* llib_shell_base = nullptr;

		llib_data_base = (BYTE*)VirtualAllocEx(h_proc, NULL, sizeof(INJECT_INTERNAL_DATA), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
		if (!llib_data_base)
		{
			result = 0;
	
			goto LLIB_FAIL;
		}

		if (!WriteProcessMemory(h_proc, llib_data_base, &llib_data, sizeof(INJECT_INTERNAL_DATA), NULL))
		{
			result = 0;
			
			goto LLIB_FAIL;
		}

		llib_shell_base = (BYTE*)VirtualAllocEx(h_proc, NULL, llib_size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
		if (!llib_shell_base)
		{
			result = 0;
			
			goto LLIB_FAIL;
		}

		if (!WriteProcessMemory(h_proc, llib_shell_base, InjectInternal, llib_size, NULL))
		{
			result = 0;

			goto LLIB_FAIL;
		}

		result = StartRoutine(data->method, h_proc, (f_Routine)llib_shell_base, data->flags, llib_data_base, &data->out, START_ROUTINE_DEFAULT_TIMEOUT);

		if (result)
		{
			if (!ReadProcessMemory(h_proc, llib_data_base, &data->h_dll_out, sizeof(HMODULE), NULL))
			{
				result = 0;
			}
		}
		else
		{
			data->h_dll_out = 0;
		}

	LLIB_FAIL:

		if (llib_data_base)
		{
			VirtualFreeEx(h_proc, llib_data_base, NULL, MEM_RELEASE);
		}

		if (llib_shell_base)
		{
			VirtualFreeEx(h_proc, llib_shell_base, NULL, MEM_RELEASE);
		}
	}

	RestoreHookedFuncs(&hk_vec, h_proc, HOOK_RESTORE_MODE::HRM_RESTORE_HOOK);

	return result;
}

DWORD HijackHandle(INJECTION_DATA* data, ACCESS_MASK desired_access, DWORD target_pid)
{
	std::vector<SYSTEM_HANDLE_TABLE_ENTRY_INFO> sys_proc_handles;

	if (!EnumProcessHandles(&sys_proc_handles))
	{
		return 0;
	}

	std::vector<HANDLE_INFO> handles_to_target_process;

	if (!FindProcessHandles(&sys_proc_handles, target_pid, &handles_to_target_process, desired_access))
	{
		return 0;
	}

	if (handles_to_target_process.empty())
	{
		return 0;
	}

	bool is_target_elevated = false;

	{
		HANDLE h_hijack_proc = OpenProcess(PROCESS_DUP_HANDLE, NULL, handles_to_target_process[0].owner_pid);
		if (!h_hijack_proc)
		{
			return 0;
		}

		HANDLE h_dup = nullptr;
		if (!DuplicateHandle(h_hijack_proc, handles_to_target_process[0].handle, GetCurrentProcess(), &h_dup, PROCESS_QUERY_INFORMATION, NULL, NULL))
		{
			return 0;
		}

		DWORD result = IsElevatedProcess(h_dup);
		if (result == -1)
		{
			CloseHandle(h_dup);

			return 0;
		}

		CloseHandle(h_dup);

		is_target_elevated = result != 0;
	}

	ACCESS_MASK proc_access = PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION;

	INJECTION_DATA this_module_inj_data;
	INJECTION_DATA new_data;

	this_module_inj_data.method			= LAUNCH_METHOD::LM_NT_CREATE_THREAD_EX;
	this_module_inj_data.flags			= (INJ_CTX_ALL ^ INJ_CTX_FAKE_START_ADDRESS) | INJ_BY_PROCESS_ID;
	this_module_inj_data.mode			= INJECTION_MODE::IM_LOAD_LIBRARY_EX_W;

	wcscpy(this_module_inj_data.dll_path, g_path_to_this_module.c_str());

	new_data.flags									= data->flags;
	new_data.method									= data->method;

	wcscpy(new_data.dll_path, data->dll_path);

	if (new_data.flags & INJ_BY_HANDLE_HIJACK_AND_ID)
	{
		new_data.flags ^= INJ_BY_HANDLE_HIJACK_AND_ID;
	}
	else
	{
		new_data.flags ^= INJ_BY_HANDLE_HIJACK_AND_NAME;
	}

	new_data.flags |= INJ_BY_HANDLE;

	for (auto& h : handles_to_target_process)
	{
		bool			fail_flag				= false;
		void*			remote_data				= nullptr;
		DWORD			result					= 0;
		f_Routine		remote_start			= nullptr;
		bool			execute_finished_flag	= false;

		_ZeroMemory(new_data.data_buf, sizeof(new_data.data_buf));

		HANDLE h_proc = OpenProcess(proc_access, NULL, h.owner_pid);
		
		if (!h_proc)
		{
			fail_flag = true;

			goto HHIJACK_END;
		}

		if (is_target_elevated)
		{
			DWORD result = IsElevatedProcess(h_proc);
			if (result != -1 && result == 0)
			{
				fail_flag = true;

				goto HHIJACK_END;
			}
		}

		memcpy(this_module_inj_data.data_buf, &h.owner_pid, sizeof(h.owner_pid));

		if (!Inject(&this_module_inj_data))
		{
			fail_flag = true;

			goto HHIJACK_END;
		}

		if (!this_module_inj_data.h_dll_out)
		{
			fail_flag = true;

			goto HHIJACK_END;
		}
		
		remote_data = VirtualAllocEx(h_proc, NULL, sizeof(INJECTION_DATA), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
		if (!remote_data)
		{
			fail_flag = true;

			goto HHIJACK_END;
		}

		*(HANDLE*)new_data.data_buf = h.handle;

		if (!WriteProcessMemory(h_proc, remote_data, &new_data, sizeof(INJECTION_DATA), NULL))
		{
			fail_flag = true;

			goto HHIJACK_END;
		}

		remote_start = (f_Routine)((DWORD)&Start - (DWORD)g_h_current_module + (DWORD)this_module_inj_data.h_dll_out);

		result = StartRoutine(LAUNCH_METHOD::LM_NT_CREATE_THREAD_EX, h_proc, remote_start, (INJ_CTX_ALL ^ INJ_CTX_FAKE_START_ADDRESS) ^ INJ_CTX_HIDE_FROM_DEBUGGER, remote_data, &data->out, START_ROUTINE_DEFAULT_TIMEOUT * 5);
		if (!result)
		{
			fail_flag = true;

			goto HHIJACK_END;
		}

		if (!ReadProcessMemory(h_proc, (void*)(&g_executing_finished - (DWORD)g_h_current_module + (DWORD)this_module_inj_data.h_dll_out), &execute_finished_flag, sizeof(bool), NULL))
		{
			fail_flag = true;

			goto HHIJACK_END;
		}
		
	HHIJACK_END:

		if (remote_data)
		{
			VirtualFreeEx(h_proc, remote_data, NULL, MEM_RELEASE);

			remote_data = nullptr;
		}

		if (h_proc)
		{
			CloseHandle(h_proc);
		
			h_proc = 0;
		}

		if (fail_flag)
		{
			continue;
		}

		return result;
	}

	return 0;
}
```

`injection.hpp`:

```hpp
#pragma once

#include "start_routine.hpp"

// cloaking options:
#define INJ_ERASE_HEADER            0x01 // replaces first 1000 bytes of the dll with 0`s (high priority than INJ_FAKE_HEADER)
#define INJ_FAKE_HEADER             0x02 // replaces original dll header with ntdll.dll header
#define INJ_UNLINK_FROM_PEB         0x04 // unlinks library from process environment block
#define INJ_SCRAMBLE_DLL_NAME       0x08 // randomize name of a dll before load it
#define INJ_LOAD_DLL_COPY           0x20 // load copy of a dll from TEMP dir

// thread cloaking options (ignored if launch method not NtCreateThreadEx): 
#define INJ_CTX_HIDE_FROM_DEBUGGER  0x0040
#define INJ_CTX_FAKE_THREAD_ID      0x0080
#define INJ_CTX_FAKE_START_ADDRESS  0x0100
#define INJ_CTX_SKIP_TRHEAD_ATTACH  0x0200

#define INJ_CTX_ALL (INJ_CTX_HIDE_FROM_DEBUGGER | INJ_CTX_FAKE_THREAD_ID | INJ_CTX_FAKE_START_ADDRESS | INJ_CTX_SKIP_TRHEAD_ATTACH)

// way to getting a handle of a process
#define INJ_BY_PROCESS_ID				0x0400
#define INJ_BY_PROCESS_NAME				0x0800
#define INJ_BY_HANDLE_HIJACK_AND_NAME	0x2000
#define INJ_BY_HANDLE_HIJACK_AND_ID		0x4000
#define INJ_BY_HANDLE					0x8000

// manual mapping flags
#define INJ_MM_RUN_DLL_MAIN						0x010000
#define INJ_MM_RUN_DLL_MAIN_UNDER_LOADER_LOCK	0x020000
#define INJ_MM_RESOLVE_IMPORTS					0x040000
#define INJ_MM_EXECUTE_TLS_CALLBACKS			0x080000
#define INJ_MM_ENABLE_EXCEPTIONS				0x100000
#define INJ_MM_RESOLVE_RELOCATIONS				0x200000

#define INJ_MM_DEFAULT (INJ_MM_RUN_DLL_MAIN_UNDER_LOADER_LOCK | INJ_MM_EXECUTE_TLS_CALLBACKS | INJ_MM_ENABLE_EXCEPTIONS | INJ_MM_RESOLVE_RELOCATIONS)

enum class INJECTION_MODE
{
	IM_MANUAL_MAPPING,
	IM_LOAD_LIBRARY_EX_W
};

enum class INJ_GET_HANDLE_METHOD
{
	IGHM_BY_PROCESS_ID,
	IGHM_BY_PROCESS_NAME,
	IGHM_BY_HANDLE_HIJACK,
	IGHM_BY_HANDLE
};

struct INJECTION_DATA
{
	DWORD					out								= 0;
	HMODULE					h_dll_out						= 0;
	BYTE					data_buf[0x500]					= { 0 };
	wchar_t					dll_path[MAX_PATH]				= { 0 };
	INJECTION_MODE			mode							= INJECTION_MODE::IM_MANUAL_MAPPING;
	DWORD					flags							= 0;
	LAUNCH_METHOD			method							= LAUNCH_METHOD::LM_THREAD_HIJACK;

	struct START_ARGS
	{
		HINSTANCE hinstance = 0;
	} start_args;
};

DWORD Inject(INJECTION_DATA* data);
DWORD HijackHandle(INJECTION_DATA* data, ACCESS_MASK desired_access, DWORD target_pid);
```

`manual_map.cpp`:

```cpp
#include "includes.hpp"

__forceinline int _wcslen(const wchar_t* str)
{
	if (!str)
	{
		return -1;
	}

	int i = 0;

	for (; *str != L'\0'; ++str, ++i);

	return i * sizeof(wchar_t);
}

__forceinline int _strlen(const char* str)
{
	if (!str)
	{
		return -1;
	}
	
	int i = 0;

	for (; *str; ++str, ++i);
	
	return i * sizeof(char);
}

template <typename T>
__forceinline T* _HeapAlloc(MANUAL_MAP_FUNCTION_TABLE* f, size_t size = 1)
{
	return (T*)f->RtlAllocateHeap(f->p_LdrpHeap, HEAP_ZERO_MEMORY, size * sizeof(T));
}


__forceinline bool _FreeHeap(MANUAL_MAP_FUNCTION_TABLE* f, void* addr)
{
	return (bool)f->RtlFreeHeap(f->p_LdrpHeap, NULL, addr);
}

__forceinline void AddDependency(MANUAL_MAP_FUNCTION_TABLE* f, MM_DEPENDENCY_RECORD** rec, HMODULE new_handle)
{
	if (!rec)
	{
		return;
	}

	if (!(*rec))
	{
		*rec = _HeapAlloc<MM_DEPENDENCY_RECORD>(f, 1);

		(*rec)->f_link = nullptr;
		(*rec)->h_dll = new_handle;

		return;
	}

	MM_DEPENDENCY_RECORD* cur = *rec;
	while (cur->f_link != nullptr)
	{
		cur = cur->f_link;
	}

	cur->f_link = _HeapAlloc<MM_DEPENDENCY_RECORD>(f, 1);
	cur->f_link->h_dll = new_handle;
	cur->f_link->f_link = nullptr;
}

__forceinline void DeleteAllDependencies(MANUAL_MAP_FUNCTION_TABLE* f, MM_DEPENDENCY_RECORD* rec)
{
	if (!rec)
	{
		return;
	}

	MM_DEPENDENCY_RECORD* tmp = nullptr;
	while (rec)
	{
		f->p_FreeLibrary(rec->h_dll);
		tmp = rec->f_link;
		_FreeHeap(f, rec);
		rec = tmp;
	}
}

DWORD CODE_SEG(".mmap_seg$1") __stdcall ManualMapShell(MANUAL_MAPPING_SHELL_DATA* mp_data)
{
	if (!mp_data)
	{
		return 0;
	}

	DWORD flags = mp_data->flags;

	MANUAL_MAP_FUNCTION_TABLE* f = &mp_data->f_table;

	IMAGE_DOS_HEADER*		dos_header	 = nullptr;
	IMAGE_NT_HEADERS*		pe_header	 = nullptr;
	IMAGE_FILE_HEADER*		file_header	 = nullptr;
	IMAGE_OPTIONAL_HEADER*	opt_header	 = nullptr;
	f_DLL_ENTRY_POINT		DllMain		 = nullptr;

	HANDLE h_proc = NtCurrentProcess();

	if (!f)
	{
		return 0;
	}

	f->p_LdrpHeap = *f->LdrpHeap;
	if (!f->p_LdrpHeap)
	{
		return 0;
	}

	MM_DEPENDENCY_RECORD* imports = nullptr;

	UNICODE_STRING* u_str = _HeapAlloc<UNICODE_STRING>(f);
	
	if (!u_str)
	{
		return 0;
	}

	u_str->Length = _wcslen(mp_data->dll_path);
	u_str->MaxLength = sizeof(wchar_t[MAX_PATH + 4]);
	u_str->szBuffer = mp_data->dll_path;

	OBJECT_ATTRIBUTES* obj_attr = _HeapAlloc<OBJECT_ATTRIBUTES>(f);
	
	if (!obj_attr)
	{
		_FreeHeap(f, u_str);

		return 0;
	}

	obj_attr->Length = sizeof(OBJECT_ATTRIBUTES);
	obj_attr->ObjectName = u_str;
	obj_attr->Attributes = OBJ_CASE_INSENSITIVE;

	IO_STATUS_BLOCK* io_status = _HeapAlloc<IO_STATUS_BLOCK>(f);

	if (!io_status)
	{
		_FreeHeap(f, u_str);
		_FreeHeap(f, obj_attr);

		return 0;
	}

	HANDLE h_file = 0;
	if (NT_FAIL(f->NtOpenFile(&h_file, FILE_GENERIC_READ, obj_attr, io_status, FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT)))
	{
		_FreeHeap(f, obj_attr);
		_FreeHeap(f, io_status);

		return 0;
	}

	_FreeHeap(f, u_str);
	_FreeHeap(f, obj_attr);

	FILE_STANDARD_INFO* fsi = _HeapAlloc<FILE_STANDARD_INFO>(f);
	if (!fsi)
	{
		f->NtClose(h_file);

		_FreeHeap(f, io_status);

		return 0;
	}

	if (NT_FAIL(f->NtQueryInformationFile(h_file, io_status, fsi, sizeof(FILE_STANDARD_INFO), FILE_INFORMATION_CLASS::FileStandardInformation)))
	{
		f->NtClose(h_file);

		_FreeHeap(f, io_status);
		_FreeHeap(f, fsi);

		return 0;
	}

	DWORD file_size = fsi->AllocationSize.LowPart;

	_FreeHeap(f, fsi);

	FILE_POSITION_INFORMATION* f_pos = _HeapAlloc<FILE_POSITION_INFORMATION>(f);
	if (!f_pos)
	{
		f->NtClose(h_file);

		_FreeHeap(f, io_status);

		return 0;
	}

	if (NT_FAIL(f->NtSetInformationFile(h_file, io_status, f_pos, sizeof(FILE_POSITION_INFORMATION), FILE_INFORMATION_CLASS::FilePositionInformation)))
	{
		f->NtClose(h_file);

		_FreeHeap(f, io_status);
		_FreeHeap(f, f_pos);

		return 0;
	}

	_FreeHeap(f, f_pos);

	BYTE* dll_raw = nullptr;
	if (NT_FAIL(f->NtAllocateVirtualMemory(h_proc, (void**)&dll_raw, NULL, &file_size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE)) || !dll_raw)
	{
		f->NtClose(h_file);

		_FreeHeap(f, io_status);

		return 0;
	}

	if (NT_FAIL(f->NtReadFile(h_file, NULL, NULL, NULL, io_status, dll_raw, file_size, NULL, NULL)))
	{
		f->NtClose(h_file);

		file_size = 0;
		f->NtFreeVirtualMemory(h_proc, (void**)&dll_raw, &file_size, MEM_RELEASE);

		_FreeHeap(f, io_status);

		return 0;
	}

	f->NtClose(h_file);

	_FreeHeap(f, io_status);

	dos_header   = (IMAGE_DOS_HEADER*)dll_raw;
	pe_header    = (IMAGE_NT_HEADERS*)(dll_raw + dos_header->e_lfanew);
	file_header  = &pe_header->FileHeader;
	opt_header   = &pe_header->OptionalHeader;

	BYTE*   image_base      = (BYTE*)opt_header->ImageBase;
	DWORD   image_size      = opt_header->SizeOfImage;
	size_t  sections_count  = file_header->NumberOfSections;

	if (NT_FAIL(f->NtAllocateVirtualMemory(h_proc, (void**)&image_base, NULL, &image_size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE)))
	{
		image_base = nullptr;
		if (NT_FAIL(f->NtAllocateVirtualMemory(h_proc, (void**)&image_base, NULL, &image_size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE)) || !image_base)
		{
			file_size = 0;
			f->NtFreeVirtualMemory(h_proc, (void**)&dll_raw, &file_size, MEM_RELEASE);

			return 0;
		}
	}

	// sections mapping
	IMAGE_SECTION_HEADER* sec = IMAGE_FIRST_SECTION(pe_header);
	for (DWORD i = 0; i < sections_count; ++i, ++sec)
	{
		if (sec->SizeOfRawData)
		{
			f->memmove(image_base + sec->VirtualAddress, dll_raw + sec->PointerToRawData, sec->SizeOfRawData);
		}
	}

	f->memmove(image_base, dll_raw, PAGE_SIZE); // move headers

	file_size = 0;
	f->NtFreeVirtualMemory(h_proc, (void**)&dll_raw, &file_size, MEM_RELEASE);

	dos_header	 = (IMAGE_DOS_HEADER*)image_base;
	pe_header    = (IMAGE_NT_HEADERS*)(image_base + dos_header->e_lfanew);
	file_header  = &pe_header->FileHeader;
	opt_header	 = &pe_header->OptionalHeader;

	DllMain = (f_DLL_ENTRY_POINT)(image_base + opt_header->AddressOfEntryPoint);

	if (flags & INJ_MM_RESOLVE_RELOCATIONS)
	{
		DWORD location_delta = (DWORD)image_base - opt_header->ImageBase;
		if (location_delta)
		{
			if (!opt_header->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size)
			{
				image_size = 0;
				f->NtFreeVirtualMemory(h_proc, (void**)&image_base, &image_size, MEM_RELEASE);

				return 0;
			}

			IMAGE_BASE_RELOCATION* reloc_data = (IMAGE_BASE_RELOCATION*)(image_base + opt_header->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
			while (reloc_data->VirtualAddress)
			{
				DWORD amount_of_entries = (reloc_data->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
				WORD* relative_info = (WORD*)(reloc_data + 1);

				for (DWORD i = 0; i < amount_of_entries; ++i, ++relative_info)
				{
					if (RELOC_FLAG(*relative_info))
					{
						DWORD* patch = (DWORD*)(image_base + reloc_data->VirtualAddress + (*relative_info & 0xFFF));
						*patch += (DWORD)location_delta;
					}
				}

				reloc_data = (IMAGE_BASE_RELOCATION*)((BYTE*)reloc_data + reloc_data->SizeOfBlock);
			}

			opt_header->ImageBase += location_delta;
		}
	}

	if (flags & (INJ_MM_RUN_DLL_MAIN_UNDER_LOADER_LOCK | INJ_MM_RUN_DLL_MAIN | INJ_MM_RESOLVE_IMPORTS))
	{
		if (opt_header->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size)
		{
			IMAGE_IMPORT_DESCRIPTOR* import_descriptor = (IMAGE_IMPORT_DESCRIPTOR*)(opt_header->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress + image_base);

			bool err_break = false;

			while (import_descriptor->Name)
			{
				char* dll_name = (char*)(image_base + import_descriptor->Name);
				HMODULE h_dll = f->p_LoadLibraryA(dll_name);

				if (!h_dll)
				{
					err_break = true;
					goto ERR_BREAK;
				}

				AddDependency(f, &imports, h_dll);

				IMAGE_THUNK_DATA* thunk_ref = (IMAGE_THUNK_DATA*)(image_base + import_descriptor->OriginalFirstThunk);
				IMAGE_THUNK_DATA* func_ref = (IMAGE_THUNK_DATA*)(image_base + import_descriptor->FirstThunk);

				if (!thunk_ref)
				{
					thunk_ref = func_ref;
				}

				for (; thunk_ref->u1.AddressOfData; ++thunk_ref, ++func_ref)
				{
					if (IMAGE_SNAP_BY_ORDINAL(thunk_ref->u1.Ordinal))
					{
						if (NT_FAIL(f->LdrGetProcedureAddress(h_dll, NULL, IMAGE_ORDINAL(thunk_ref->u1.Ordinal), (void**)&func_ref->u1.Function)))
						{
							err_break = true;
							goto ERR_BREAK;
						}
					}
					else
					{
						IMAGE_IMPORT_BY_NAME* _import = (IMAGE_IMPORT_BY_NAME*)(thunk_ref->u1.AddressOfData + image_base);

						ANSI_STRING* ansi_str = _HeapAlloc<ANSI_STRING>(f);

						if (!ansi_str)
						{
							err_break = true;
							goto ERR_BREAK;
						}

						ansi_str->Length = _strlen(_import->Name);

						if (ansi_str->Length == -1)
						{
							_FreeHeap(f, ansi_str);

							err_break = true;
							goto ERR_BREAK;
						}

						ansi_str->szBuffer = _import->Name;
						ansi_str->MaxLength = ansi_str->Length + 1 * sizeof(char);

						if (NT_FAIL(f->LdrGetProcedureAddress(h_dll, ansi_str, NULL, (void**)&func_ref->u1.Function)))
						{
							_FreeHeap(f, ansi_str);

							err_break = true;
							goto ERR_BREAK;
						}

						_FreeHeap(f, ansi_str);
					}
				}
				++import_descriptor;
			}

		ERR_BREAK:
			if (err_break)
			{
				DeleteAllDependencies(f, imports);

				image_size = 0;
				f->NtFreeVirtualMemory(h_proc, (void**)&image_base, &image_size, MEM_RELEASE);

				return 0;
			}
		}
	}

	if (flags & INJ_MM_EXECUTE_TLS_CALLBACKS)
	{
		if (opt_header->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size)
		{
			IMAGE_TLS_DIRECTORY* TLS_dir = (IMAGE_TLS_DIRECTORY*)(opt_header->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress + image_base);
			PIMAGE_TLS_CALLBACK* TLS_callback = (PIMAGE_TLS_CALLBACK*)(TLS_dir->AddressOfCallBacks + image_base);

			for (; TLS_callback && *TLS_callback; ++TLS_callback)
			{
				(*TLS_callback)(image_base, DLL_PROCESS_ATTACH, NULL);
			}
		}
	}

	if (flags & INJ_MM_ENABLE_EXCEPTIONS)
	{
		VEH_SHELL_DATA* veh_shell_data = _HeapAlloc<VEH_SHELL_DATA>(f);

		if (!veh_shell_data)
		{
			DeleteAllDependencies(f, imports);
			 
			f->NtFreeVirtualMemory(h_proc, (void**)&image_base, &image_size, MEM_RELEASE);

			return 0;
		}

		veh_shell_data->image_base					= image_base;
		veh_shell_data->image_size					= image_size;
		veh_shell_data->os_version					= mp_data->os_version;
		veh_shell_data->_LdrpInvertedFunctionTable	= f->LdrpInvertedFunctionTable;
		veh_shell_data->_LdrProtectMrdata			= f->LdrProtectMrdata;

		if (!FindAndReplacePointers((BYTE*)mp_data->veh_shell, mp_data->veh_shell_size, VEH_DATA_SIG, (UINT_PTR)veh_shell_data))
		{
			DeleteAllDependencies(f, imports);

			f->NtFreeVirtualMemory(h_proc, (void**)&image_base, &image_size, MEM_RELEASE);

			return 0;
		}
		
		if (mp_data->os_version >= g_Win8)
		{
			f->RtlInsertInvertedFunctionTable(image_base, image_size);
		}
		else
		{
			auto RtlInsertInvertedFunctionTable_WIN7 = (f_RtlInsertInvertedFunctionTable_WIN7)f->RtlInsertInvertedFunctionTable;
			RtlInsertInvertedFunctionTable_WIN7((RTL_INVERTED_FUNCTION_TABLE_WIN7*)f->LdrpInvertedFunctionTable, image_base, image_size);
		}

		NTSTATUS nt_ret = STATUS_SUCCESS;
		
		RTL_INVERTED_FUNCTION_TABLE_ENTRY* entry = nullptr;

		if (mp_data->os_version == g_Win7)
		{
			entry = &((RTL_INVERTED_FUNCTION_TABLE_WIN7*)f->LdrpInvertedFunctionTable)->Entries[0];

		}
		else
		{
			entry = &f->LdrpInvertedFunctionTable->Entries[0];
		}

		for (DWORD i = 0; i < f->LdrpInvertedFunctionTable->Count; ++i)
		{
			if (entry[i].ImageBase != image_base)
			{
				continue;
			}

			if (entry[i].ExceptionDirectorySize)
			{
				break;
			}

			void* fake_dir = nullptr;
			DWORD dir_size = 0x800 * sizeof(void*);

			nt_ret = f->NtAllocateVirtualMemory(h_proc, (void**)&fake_dir, NULL, &dir_size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

			if (NT_FAIL(nt_ret) || !fake_dir)
			{
				break;
			}

			DWORD p_encoded = EncodeSystemPtr((DWORD)fake_dir);

			if (mp_data->os_version >= g_Win81)
			{
				f->LdrProtectMrdata(FALSE);
			}

			entry[i].ExceptionDirectory = (IMAGE_RUNTIME_FUNCTION_ENTRY*)p_encoded;
			
			if (mp_data->os_version >= g_Win81)
			{
				f->LdrProtectMrdata(TRUE);
			}

			if (!mp_data->h_veh)
			{
				mp_data->h_veh = f->RtlAddVectoredExceptionHandler(NULL, (PVECTORED_EXCEPTION_HANDLER)mp_data->veh_shell);
			}

			break;
		}

		if (NT_FAIL(nt_ret))
		{
			if (mp_data->h_veh)
			{
				f->RtlRemoveVectoredExceptionHandler(mp_data->h_veh);
			}

			DeleteAllDependencies(f, imports);

			f->NtFreeVirtualMemory(h_proc, (void**)&image_base, &image_size, MEM_RELEASE);

			return 0;
		}
	}

	if (flags & (INJ_MM_RUN_DLL_MAIN | INJ_MM_RUN_DLL_MAIN_UNDER_LOADER_LOCK))
	{
		bool failed = false;

		if (flags & INJ_MM_RUN_DLL_MAIN_UNDER_LOADER_LOCK)
		{
			ULONG		state	= 0;
			ULONG_PTR	cookie	= 0;
			bool		locked	= false;
			
			locked = f->LdrLockLoaderLock(NULL, &state, &cookie) == 0;

			if (!DllMain((HINSTANCE)image_base, DLL_PROCESS_ATTACH, NULL))
			{
				failed = true;
			}

			if (locked)
			{
				f->LdrUnlockLoaderLock(NULL, cookie);
			}
		}
		else
		{
			if (!DllMain((HINSTANCE)image_base, DLL_PROCESS_ATTACH, NULL))
			{
				failed = true;
			}
		}

		if (failed)
		{
			f->RtlRemoveVectoredExceptionHandler(mp_data->h_veh);

			DeleteAllDependencies(f, imports);

			image_size = 0;
			f->NtFreeVirtualMemory(h_proc, (void**)&image_base, &image_size, MEM_RELEASE);

			return 0;
		}
	}

	mp_data->out_module_base = (HMODULE)image_base;

	return 1;
}

DWORD CODE_SEG(".mmap_seg$2") __stdcall ManualMapShellEnd()
{
	return 0;
}

MANUAL_MAP_FUNCTION_TABLE::MANUAL_MAP_FUNCTION_TABLE()
{
	INIT_CONSTRUCTOR_NATIVE(LdrGetProcedureAddress);
	//INIT_CONSTRUCTOR_NATIVE(LdrLoadDll);
	//INIT_CONSTRUCTOR_NATIVE(LdrUnloadDll);
	INIT_CONSTRUCTOR_NATIVE(RtlFreeHeap);
	INIT_CONSTRUCTOR_NATIVE(LdrpHeap);
	INIT_CONSTRUCTOR_NATIVE(RtlAllocateHeap);
	INIT_CONSTRUCTOR_NATIVE(NtAllocateVirtualMemory);
	INIT_CONSTRUCTOR_NATIVE(NtFreeVirtualMemory);
	INIT_CONSTRUCTOR_NATIVE(memmove);
	INIT_CONSTRUCTOR_NATIVE(NtOpenFile);
	INIT_CONSTRUCTOR_NATIVE(NtClose);
	INIT_CONSTRUCTOR_NATIVE(NtSetInformationFile);
	INIT_CONSTRUCTOR_NATIVE(NtQueryInformationFile);
	INIT_CONSTRUCTOR_NATIVE(NtReadFile);
	INIT_CONSTRUCTOR_NATIVE(LdrLockLoaderLock);
	INIT_CONSTRUCTOR_NATIVE(LdrUnlockLoaderLock);
	INIT_CONSTRUCTOR_NATIVE(LdrProtectMrdata);
	INIT_CONSTRUCTOR_NATIVE(RtlAddVectoredExceptionHandler);
	INIT_CONSTRUCTOR_NATIVE(LdrpInvertedFunctionTable);
	INIT_CONSTRUCTOR_NATIVE(RtlInsertInvertedFunctionTable);
	INIT_CONSTRUCTOR_NATIVE(RtlRemoveVectoredExceptionHandler);

	INIT_CONSTRUCTOR_NATIVE_WIN32(LoadLibraryA);
	INIT_CONSTRUCTOR_NATIVE_WIN32(FreeLibrary);
}

MANUAL_MAPPING_SHELL_DATA::MANUAL_MAPPING_SHELL_DATA(INJECTION_DATA* data, DWORD os_version, void* veh_shell_base, DWORD veh_shell_size)
{
	flags = data->flags;
	this->os_version = os_version;
	this->veh_shell_size = veh_shell_size;
	veh_shell = veh_shell_base;

	wcscat(dll_path, L"\\??\\");
	wcscat(dll_path, data->dll_path);
}
```

`manual_map.hpp`:

```hpp
#pragma once

#define RELOC_FLAG64(rel_info) ((rel_info >> 12) == IMAGE_REL_BASED_DIR64)
#define RELOC_FLAG32(rel_info) ((rel_info >> 12) == IMAGE_REL_BASED_HIGHLOW)

#ifdef _WIN64
#define RELOC_FLAG RELOC_FLAG64
#else
#define RELOC_FLAG RELOC_FLAG32
#endif

using f_DLL_ENTRY_POINT = BOOL (WINAPI*) (HINSTANCE hDll, DWORD dwReason, HINSTANCE pReserved);

struct MANUAL_MAP_FUNCTION_TABLE
{
	NT_LOCAL(LdrGetProcedureAddress);
	//NT_LOCAL(LdrLoadDll);
	//NT_LOCAL(LdrUnloadDll);
	NT_LOCAL(RtlFreeHeap);
	NT_LOCAL(LdrpHeap);
	NT_LOCAL(RtlAllocateHeap);
	NT_LOCAL(NtAllocateVirtualMemory);
	NT_LOCAL(NtFreeVirtualMemory);
	NT_LOCAL(memmove);
	NT_LOCAL(NtOpenFile);
	NT_LOCAL(NtClose);
	NT_LOCAL(NtSetInformationFile);
	NT_LOCAL(NtQueryInformationFile);
	NT_LOCAL(NtReadFile);
	NT_LOCAL(LdrLockLoaderLock);
	NT_LOCAL(LdrUnlockLoaderLock);
	NT_LOCAL(LdrProtectMrdata);
	NT_LOCAL(RtlAddVectoredExceptionHandler);
	NT_LOCAL(LdrpInvertedFunctionTable);
	NT_LOCAL(RtlInsertInvertedFunctionTable);
	NT_LOCAL(RtlRemoveVectoredExceptionHandler);

	WIN32_LOCAL(LoadLibraryA); // used temporary
	WIN32_LOCAL(FreeLibrary); // used temporary

	void* p_LdrpHeap = nullptr;

	MANUAL_MAP_FUNCTION_TABLE();
};

struct MANUAL_MAPPING_SHELL_DATA
{
	HMODULE			out_module_base		= 0;
	DWORD			flags				= 0;
	DWORD			os_version			= 0;
	void*			veh_shell			= nullptr;
	DWORD			veh_shell_size		= 0;
	HANDLE			h_veh				= 0;
	wchar_t         dll_path[MAX_PATH]  = { 0 };
	

	MANUAL_MAP_FUNCTION_TABLE f_table;

	MANUAL_MAPPING_SHELL_DATA(INJECTION_DATA* data, DWORD os_version, void* veh_shell_base, DWORD veh_shell_size);
};


struct MM_DEPENDENCY_RECORD
{
	struct MM_DEPENDENCY_RECORD* f_link;

	HMODULE h_dll;
};

DWORD CODE_SEG(".mmap_seg$1") __stdcall ManualMapShell(MANUAL_MAPPING_SHELL_DATA* mp_data);
DWORD CODE_SEG(".mmap_seg$2") __stdcall ManualMapShellEnd();
```

`manual_mapping_injector.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.32014.148
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "manual_mapping_injector", "manual_mapping_injector.vcxproj", "{4752526E-B194-403B-837D-EA0EA26001EA}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "manual_mapping_injector_loader", "..\manual_mapping_injector_loader\manual_mapping_injector_loader.vcxproj", "{971154AC-6969-44BB-8BBE-6102BEE2C24F}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4752526E-B194-403B-837D-EA0EA26001EA}.Debug|x64.ActiveCfg = Debug|x64
		{4752526E-B194-403B-837D-EA0EA26001EA}.Debug|x64.Build.0 = Debug|x64
		{4752526E-B194-403B-837D-EA0EA26001EA}.Debug|x86.ActiveCfg = Debug|Win32
		{4752526E-B194-403B-837D-EA0EA26001EA}.Debug|x86.Build.0 = Debug|Win32
		{4752526E-B194-403B-837D-EA0EA26001EA}.Release|x64.ActiveCfg = Release|x64
		{4752526E-B194-403B-837D-EA0EA26001EA}.Release|x64.Build.0 = Release|x64
		{4752526E-B194-403B-837D-EA0EA26001EA}.Release|x86.ActiveCfg = Release|Win32
		{4752526E-B194-403B-837D-EA0EA26001EA}.Release|x86.Build.0 = Release|Win32
		{971154AC-6969-44BB-8BBE-6102BEE2C24F}.Debug|x64.ActiveCfg = Debug|x64
		{971154AC-6969-44BB-8BBE-6102BEE2C24F}.Debug|x64.Build.0 = Debug|x64
		{971154AC-6969-44BB-8BBE-6102BEE2C24F}.Debug|x86.ActiveCfg = Debug|Win32
		{971154AC-6969-44BB-8BBE-6102BEE2C24F}.Debug|x86.Build.0 = Debug|Win32
		{971154AC-6969-44BB-8BBE-6102BEE2C24F}.Release|x64.ActiveCfg = Release|x64
		{971154AC-6969-44BB-8BBE-6102BEE2C24F}.Release|x64.Build.0 = Release|x64
		{971154AC-6969-44BB-8BBE-6102BEE2C24F}.Release|x86.ActiveCfg = Release|Win32
		{971154AC-6969-44BB-8BBE-6102BEE2C24F}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {97A46CC1-BD50-4E04-87AC-F3F4A012A64C}
	EndGlobalSection
EndGlobal

```

`manual_mapping_injector.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{4752526e-b194-403b-837d-ea0ea26001ea}</ProjectGuid>
    <RootNamespace>manualmappinginjector</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <UndefinePreprocessorDefinitions>
      </UndefinePreprocessorDefinitions>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies);Urlmon.lib;Wininet.lib;Dbghelp.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>
      </FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <SDLCheck>
      </SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <UndefinePreprocessorDefinitions>
      </UndefinePreprocessorDefinitions>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
      <Optimization>MaxSpeed</Optimization>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>
      </EnableCOMDATFolding>
      <OptimizeReferences>
      </OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies);Urlmon.lib;Wininet.lib;Dbghelp.lib</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies);Urlmon.lib;Wininet.lib;Dbghelp.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies);Urlmon.lib;Wininet.lib;Dbghelp.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="hijack_handle.cpp" />
    <ClCompile Include="hijack_thread.cpp" />
    <ClCompile Include="hook_scanner.cpp" />
    <ClCompile Include="import_handler.cpp" />
    <ClCompile Include="injection.cpp" />
    <ClCompile Include="dll_main.cpp" />
    <ClCompile Include="inject_internal.cpp" />
    <ClCompile Include="manual_map.cpp" />
    <ClCompile Include="nt_create_thread_ex.cpp" />
    <ClCompile Include="process_info.cpp" />
    <ClCompile Include="start_routine.cpp" />
    <ClCompile Include="symbol_loader.cpp" />
    <ClCompile Include="symbol_parser.cpp" />
    <ClCompile Include="tools.cpp" />
    <ClCompile Include="veh_shell.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="externs.hpp" />
    <ClInclude Include="globals.hpp" />
    <ClInclude Include="hijack_handle.hpp" />
    <ClInclude Include="hook_scanner.hpp" />
    <ClInclude Include="import_handler.hpp" />
    <ClInclude Include="includes.hpp" />
    <ClInclude Include="injection.hpp" />
    <ClInclude Include="inject_internal.hpp" />
    <ClInclude Include="manual_map.hpp" />
    <ClInclude Include="namespaces.hpp" />
    <ClInclude Include="NT Defs.h" />
    <ClInclude Include="NT Funcs.h" />
    <ClInclude Include="process_info.hpp" />
    <ClInclude Include="start_routine.hpp" />
    <ClInclude Include="symbol_loader.hpp" />
    <ClInclude Include="symbol_parser.hpp" />
    <ClInclude Include="tools.hpp" />
    <ClInclude Include="veh_shell.hpp" />
    <ClInclude Include="Win10.h" />
    <ClInclude Include="Win11.h" />
    <ClInclude Include="Win7.h" />
    <ClInclude Include="Win8.h" />
    <ClInclude Include="Win81.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`manual_mapping_injector.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Header Files\NT">
      <UniqueIdentifier>{73c1e24f-9adc-4011-9242-1d2a0a684e48}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Start Routine Methods">
      <UniqueIdentifier>{cf07f31f-124b-4cd4-8639-556a035fcd36}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Injection Methods">
      <UniqueIdentifier>{3a8473fc-a1a1-443b-8aae-b4fb9ffcdac9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\Injection Methods">
      <UniqueIdentifier>{af8cf08a-45b5-45af-878f-f3f51cdce243}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dll_main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="injection.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="process_info.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="import_handler.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hijack_thread.cpp">
      <Filter>Source Files\Start Routine Methods</Filter>
    </ClCompile>
    <ClCompile Include="start_routine.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="manual_map.cpp">
      <Filter>Source Files\Injection Methods</Filter>
    </ClCompile>
    <ClCompile Include="symbol_loader.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="tools.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="symbol_parser.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hook_scanner.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="nt_create_thread_ex.cpp">
      <Filter>Source Files\Start Routine Methods</Filter>
    </ClCompile>
    <ClCompile Include="hijack_handle.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="inject_internal.cpp">
      <Filter>Source Files\Injection Methods</Filter>
    </ClCompile>
    <ClCompile Include="veh_shell.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="injection.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="includes.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Win8.h">
      <Filter>Header Files\NT</Filter>
    </ClInclude>
    <ClInclude Include="Win10.h">
      <Filter>Header Files\NT</Filter>
    </ClInclude>
    <ClInclude Include="Win11.h">
      <Filter>Header Files\NT</Filter>
    </ClInclude>
    <ClInclude Include="Win81.h">
      <Filter>Header Files\NT</Filter>
    </ClInclude>
    <ClInclude Include="NT Defs.h">
      <Filter>Header Files\NT</Filter>
    </ClInclude>
    <ClInclude Include="NT Funcs.h">
      <Filter>Header Files\NT</Filter>
    </ClInclude>
    <ClInclude Include="Win7.h">
      <Filter>Header Files\NT</Filter>
    </ClInclude>
    <ClInclude Include="process_info.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="import_handler.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="start_routine.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="manual_map.hpp">
      <Filter>Header Files\Injection Methods</Filter>
    </ClInclude>
    <ClInclude Include="symbol_loader.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="tools.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="globals.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="symbol_parser.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hook_scanner.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="externs.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hijack_handle.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="inject_internal.hpp">
      <Filter>Header Files\Injection Methods</Filter>
    </ClInclude>
    <ClInclude Include="namespaces.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="veh_shell.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`namespaces.hpp`:

```hpp
#pragma once

namespace fs = std::filesystem;
```

`nt_create_thread_ex.cpp`:

```cpp
#include "includes.hpp"

void CODE_SEG(".nt_thrd$1") __stdcall NtCreateThreadEx_Shellcode(SR_REMOTE_DATA* data);
void CODE_SEG(".nt_thrd$2") __stdcall NtCreateThreadEx_Shellcode_End();

DWORD _NtCreateThreadEx(HANDLE h_proc, f_Routine routine, DWORD flags, void* arg_routine, DWORD* out, DWORD timeout)
{
	if (!h_proc || !routine || !arg_routine || !out || !timeout)
	{
		return 0;
	}

	ProcessInfo PI;

	if (!PI.SetProcess(h_proc))
	{
		return 0;
	}

	void* fake_start_addr = nullptr;
	if (flags & INJ_CTX_FAKE_START_ADDRESS)
	{
		fake_start_addr = (void*)PI.GetEntryPoint();
		
		if (!fake_start_addr)
		{
			return 0;
		}
	}

	DWORD thread_id = 0;
	if (flags & INJ_CTX_FAKE_THREAD_ID)
	{
		thread_id = PI.GetTID();

		if (!thread_id)
		{
			return 0;
		}
	}

	DWORD nt_flags = 0;

	if (flags & INJ_CTX_HIDE_FROM_DEBUGGER)
	{
		nt_flags |= THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER;
	}

	if (flags & INJ_CTX_SKIP_TRHEAD_ATTACH)
	{
		nt_flags |= THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH;
	}

	if (fake_start_addr)
	{
		nt_flags |= THREAD_CREATE_FLAGS_CREATE_SUSPENDED;
	}

	void* remote_func_data = VirtualAllocEx(h_proc, NULL, sizeof(SR_REMOTE_DATA), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if (!remote_func_data)
	{
		return 0;
	}

	SR_REMOTE_DATA data;
	
	_ZeroMemory(&data, sizeof(data));
	
	data.routine = routine;
	data.arg_routine = arg_routine;
	data.arg_remote_func = (void*)thread_id;

	if (!WriteProcessMemory(h_proc, remote_func_data, &data, sizeof(data), NULL))
	{
		VirtualFreeEx(h_proc, remote_func_data, NULL, MEM_RELEASE);

		return 0;
	}

	size_t remote_func_size = (DWORD)NtCreateThreadEx_Shellcode_End - (DWORD)NtCreateThreadEx_Shellcode;

	void* remote_func = VirtualAllocEx(h_proc, NULL, remote_func_size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (!remote_func)
	{
		VirtualFreeEx(h_proc, remote_func_data, NULL, MEM_RELEASE);

		return 0;
	}

	if (!WriteProcessMemory(h_proc, remote_func, NtCreateThreadEx_Shellcode, remote_func_size, NULL))
	{
		VirtualFreeEx(h_proc, remote_func_data, NULL, MEM_RELEASE);
		VirtualFreeEx(h_proc, remote_func, NULL, MEM_RELEASE);
	
		return 0;
	}

	HANDLE h_thread = 0;
	if (NT_FAIL(NATIVE::NtCreateThreadEx(&h_thread, THREAD_ALL_ACCESS, NULL, h_proc, fake_start_addr ? fake_start_addr : remote_func, remote_func_data, nt_flags, NULL, NULL, NULL, NULL)) || !h_thread)
	{
		VirtualFreeEx(h_proc, remote_func_data, NULL, MEM_RELEASE);
		VirtualFreeEx(h_proc, remote_func, NULL, MEM_RELEASE);

		return 0;
	}

	if (fake_start_addr)
	{
		bool failed = false;

		CONTEXT ctx;
		ctx.ContextFlags = CONTEXT_INTEGER;

		if (!GetThreadContext(h_thread, &ctx))
		{
			failed = true;

			goto FAIL;
		}

#ifdef _WIN64
		ctx.Rcx = (DWORD64)remote_func;
#else
		ctx.Eax = (DWORD)remote_func;
#endif

		if (!SetThreadContext(h_thread, &ctx))
		{
			failed = true;

			goto FAIL;
		}

		if (SUSP_ERR(ResumeThread(h_thread)))
		{
			failed = true;
		}

	FAIL:

		if (failed)
		{
			TerminateThread(h_thread, 0);

			VirtualFreeEx(h_proc, remote_func_data, NULL, MEM_RELEASE);
			VirtualFreeEx(h_proc, remote_func, NULL, MEM_RELEASE);

			return 0;
		}
	}

	LOG("%d", GetThreadId(h_thread));

	DWORD wait_ret = WaitForSingleObject(h_thread, timeout);
	if (wait_ret != WAIT_OBJECT_0)
	{
		TerminateThread(h_thread, 0);

		VirtualFreeEx(h_proc, remote_func_data, NULL, MEM_RELEASE);
		VirtualFreeEx(h_proc, remote_func, NULL, MEM_RELEASE);

		return 0;
	}

	VirtualFreeEx(h_proc, remote_func, NULL, MEM_RELEASE);

	if (!ReadProcessMemory(h_proc, remote_func_data, &data, sizeof(data), NULL))
	{
		VirtualFreeEx(h_proc, remote_func_data, NULL, MEM_RELEASE);

		return 0;
	}

	VirtualFreeEx(h_proc, remote_func_data, NULL, MEM_RELEASE);

	if (data.status != SR_WORK_STATUS::WS_EXECUTING_FINISHED)
	{
		return 0;
	}

	*out = data.ret;

	return 1;
}

void CODE_SEG(".nt_thrd$1") __stdcall NtCreateThreadEx_Shellcode(SR_REMOTE_DATA* data)
{
	if (!data)
	{
		return;
	}

	data->status = SR_WORK_STATUS::WS_EXECUTING;

#ifdef _WIN64
	TEB* teb = (TEB*)__readgsqword(0x30);
#else
	TEB* teb = (TEB*)__readfsdword(0x18);
#endif

	HANDLE tid = data->arg_remote_func;

	if (tid)
	{
#ifdef _WIN64
		__writegsqword(0x48, (DWORD)tid);
#else
		__writefsdword(0x24, (DWORD)tid);
#endif
		teb->Cid.UniqueThread = tid;
		teb->RealClientId.UniqueThread = tid;
	}

	data->ret = data->routine(data->arg_routine);

#ifdef _WIN64
	data->last_error = __readgsqword(0x68);
#else 
	data->last_error = __readfsdword(0x34);
#endif

	data->status = SR_WORK_STATUS::WS_EXECUTING_FINISHED;

	return;
}

void CODE_SEG(".nt_thrd$2") __stdcall NtCreateThreadEx_Shellcode_End()
{
	return;
}
```

`process_info.cpp`:

```cpp
#include "includes.hpp"
#include "process_info.hpp"

#define NEXT_SYSTEM_PROCESS_ENTRY(entry) ((SYSTEM_PROCESS_INFORMATION*)((BYTE*)entry + entry->NextEntryOffset))

void ProcessInfo::ClearModulesVec()
{
	if (!process_modules.empty())
	{
		for (auto& el : process_modules)
		{
			if (el)
			{
				delete el;
			}
		}

		process_modules.clear();
	}
}

ProcessInfo::ProcessInfo()
{
	HMODULE h_NTDLL = GetModuleHandle(L"ntdll.dll");

	if (!h_NTDLL)
	{
		h_NTDLL = LoadLibrary(L"ntdll.dll");
		
		if (!h_NTDLL)
			throw std::exception("[ERROR] ProcessInfo(): can`t get HMODULE of ntdll.dll");
	}

	buffer_size = PI_INIT_BUFFER_SIZE;

	NtQueryInformationProcess  =  (f_NtQueryInformationProcess) GetProcAddress(h_NTDLL, "NtQueryInformationProcess");
	NtQueryInformationThread   =  (f_NtQueryInformationThread)  GetProcAddress(h_NTDLL, "NtQueryInformationThread");
	NtQuerySystemInformation   =  (f_NtQuerySystemInformation)  GetProcAddress(h_NTDLL, "NtQuerySystemInformation");

	if (!NtQueryInformationProcess || !NtQueryInformationThread || !NtQuerySystemInformation)
		throw std::exception("[ERROR] ProcessInfo(): can`t get address of ntdll.dll function(s)");

	DWORD nt_ret_offset = NULL;

#ifdef _WIN64
	if (GetOSBuildVersion() <= g_Win10_1507)
		nt_ret_offset = NT_RET_OFFSET_64_WIN7;
	else
		nt_ret_offset = NT_RET_OFFSET_64_WIN10_1511;
#else
	if (GetOSVersion() == g_Win7)
		nt_ret_offset = NT_RET_OFFSET_86_WIN7;
	else
		nt_ret_offset = NT_RET_OFFSET_86_WIN8;
#endif

	wait_functions_address[0] = (DWORD)GetProcAddress(h_NTDLL, "NtDelayExecution"               ) + nt_ret_offset;
	wait_functions_address[1] = (DWORD)GetProcAddress(h_NTDLL, "NtWaitForSingleObject"          ) + nt_ret_offset;
	wait_functions_address[2] = (DWORD)GetProcAddress(h_NTDLL, "NtWaitForMultipleObjects"       ) + nt_ret_offset;
	wait_functions_address[3] = (DWORD)GetProcAddress(h_NTDLL, "NtSignalAndWaitForSingleObject" ) + nt_ret_offset;
		
	if (GetOSBuildVersion() >= g_Win10_1607)
	{
		h_win32u = LoadLibrary(L"win32u.dll");
		
		if (!h_win32u)
			throw std::exception("[ERROR] ProcessInfo(): can`t get HMODULE of win32u.dll");

		wait_functions_address[4] = (DWORD)GetProcAddress(h_win32u, "NtUserMsgWaitForMultipleObjectsEx") + nt_ret_offset;
	}

	for (DWORD i = 0; i < sizeof(wait_functions_address) / sizeof(wait_functions_address[0]); ++i)
	{
		if (i == NtUserMsgWaitForMultipleObjectsEx_INDEX_IN_ARRAY && !h_win32u)
		{
			continue;
		}

		if (!wait_functions_address[i])
			throw std::exception("[ERROR] ProcessInfo(): can`t get address of ntdll.dll function(s)");
	}
}

ProcessInfo::~ProcessInfo()
{
	if (h_win32u)
		FreeLibrary(h_win32u);

	if (first_process)
		delete[buffer_size] first_process;

	ClearModulesVec();
}

bool ProcessInfo::SetProcess(HANDLE h_target_proc)
{
	DWORD handle_info = NULL;
	if (!h_target_proc || h_target_proc == INVALID_HANDLE_VALUE || !GetHandleInformation(h_target_proc, &handle_info))
		return false;

	if (!first_process)
	{
		if (!RefreshInformation())
			return false;
	}

	DWORD target_pid = GetProcessId(h_target_proc);
	
	while (NEXT_SYSTEM_PROCESS_ENTRY(current_process) != current_process)
	{
		if ((DWORD)current_process->UniqueProcessId == target_pid)
			break;

		current_process = NEXT_SYSTEM_PROCESS_ENTRY(current_process);
	}

	if ((DWORD)current_process->UniqueProcessId != target_pid)
	{
		current_process		 = first_process;
		current_thread_index = NULL;
		current_thread       = &current_process->Threads[NULL];

		return false;
	}

	h_current_process    = h_target_proc;
	current_thread_index = NULL;
	current_thread       = &current_process->Threads[NULL];

	return true;
}

bool ProcessInfo::SetThread(DWORD TID)
{
	if (!current_process)
		return false;
	
	current_thread = nullptr;
	
	for (DWORD i = 0; i < current_process->NumberOfThreads; ++i)
	{
		if ((DWORD)current_process->Threads[i].ClientId.UniqueThread == TID)
		{
			current_thread = &current_process->Threads[i];
			current_thread_index = i;

			break;
		}
	}

	if (current_thread == nullptr)
	{
		current_thread = &current_process->Threads[NULL];
		current_thread_index = NULL;

		return false;
	}
	
	return true;
}

bool ProcessInfo::FirstThread()
{
	if (!current_process)
		return false;

	current_thread = &current_process->Threads[NULL];
	current_thread_index = NULL;

	return true;
}

bool ProcessInfo::NextThread()
{
	if (!current_process)
		return false;

	if (current_thread_index == current_process->NumberOfThreads - 1)
		return false;

	current_thread = &current_process->Threads[++current_thread_index];

	return true;
}

bool ProcessInfo::RefreshInformation()
{
	ClearModulesVec();

	if (first_process)
	{
		delete[buffer_size] first_process;
		first_process = nullptr;
	}

	first_process = (SYSTEM_PROCESS_INFORMATION*)new BYTE[buffer_size];
		
	if (!first_process)
		return false;

	ULONG size_out = NULL;
	NTSTATUS status = NtQuerySystemInformation(SYSTEM_INFORMATION_CLASS::SystemProcessInformation, first_process, buffer_size, &size_out);
	
	while (status == STATUS_INFO_LENGTH_MISMATCH)
	{
		delete[buffer_size] first_process;
		buffer_size = size_out + PAGE_SIZE;

		first_process = (SYSTEM_PROCESS_INFORMATION*)new BYTE[buffer_size];
		
		if (!first_process)
			return false;

		status = NtQuerySystemInformation(SYSTEM_INFORMATION_CLASS::SystemProcessInformation, first_process, buffer_size, &size_out);
	}


	if (NT_FAIL(status))
	{
		delete[buffer_size] first_process;
		first_process = nullptr;
		h_current_process = NULL;

		return false;
	}

	h_current_process = NULL;
	current_process   = first_process;
	current_thread    = &first_process->Threads[NULL];

	return true;
}

DWORD ProcessInfo::GetPID()
{
	if (!current_process)
		return NULL;

	return GetProcessId(h_current_process);
}

DWORD ProcessInfo::GetTID()
{
	if (!current_thread)
		return NULL;

	return MDWD(current_thread->ClientId.UniqueThread);
}

DWORD ProcessInfo::GetEntryPoint()
{
	if (process_modules.empty())
	{
		if (!ReadAllModules())
		{
			return 0;
		}
	}

	return (DWORD)process_modules[0]->module_entry;
}

bool ProcessInfo::IsProtectedProcess()
{
	BYTE info = NULL;

	if (NT_FAIL(NtQueryInformationProcess(h_current_process, PROCESSINFOCLASS::ProcessProtectionInformation, &info, sizeof(info), NULL)))
		return true;

	return (info != NULL);
}

void* ProcessInfo::GetTEBaddr()
{
	if (!current_thread)
		return nullptr;

	HANDLE h_thread = OpenThread(THREAD_QUERY_LIMITED_INFORMATION | THREAD_QUERY_INFORMATION, NULL, GetTID());
	
	if (!h_thread)
		return nullptr;

	THREAD_BASIC_INFORMATION TBI = { 0 };
	NTSTATUS status = NtQueryInformationThread(h_thread, THREADINFOCLASS::ThreadBasicInformation, &TBI, sizeof(TBI), NULL);

	CloseHandle(h_thread);

	if (NT_FAIL(status))
		return nullptr;

	return TBI.TebBaseAddress;
}

void* ProcessInfo::GetPEBaddr()
{
	if (!current_process || !h_current_process)
	{
		return nullptr;
	}

	PROCESS_BASIC_INFORMATION PBI = { 0 };
	if (NT_FAIL(NtQueryInformationProcess(h_current_process, PROCESSINFOCLASS::ProcessBasicInformation, &PBI, sizeof(PBI), NULL)))
	{
		return nullptr;
	}

	return PBI.pPEB;
}

bool ProcessInfo::ReadAllModules()
{
	if (!h_current_process)
	{
		return false;
	}

	ClearModulesVec();

	void* PEB_addr = GetPEBaddr();

	if (!PEB_addr)
	{
		return false;
	}

	PEB peb = { 0 };

	if (!ReadProcessMemory(h_current_process, PEB_addr, &peb, sizeof(peb), NULL))
	{
		return false;
	}

	PEB_LDR_DATA ldr = { 0 };

	if (!ReadProcessMemory(h_current_process, peb.Ldr, &ldr, sizeof(ldr), NULL))
	{
		return false;
	}

	LIST_ENTRY* last = ldr.InLoadOrderModuleListHead.Blink;
	LIST_ENTRY* current = ldr.InLoadOrderModuleListHead.Flink;

	LDR_DATA_TABLE_ENTRY current_entry_data = { 0 };
	while (true)
	{
		if (!ReadProcessMemory(h_current_process, current, &current_entry_data, sizeof(current_entry_data), NULL))
		{
			return false;
		}
		
		DWORD size = current_entry_data.BaseDllName.Length / sizeof(wchar_t) + 1;
		std::shared_ptr<wchar_t[]> tmp_name_buf(new wchar_t[size]);

		if (!ReadProcessMemory(h_current_process, current_entry_data.BaseDllName.szBuffer, tmp_name_buf.get(), size * sizeof(wchar_t), NULL))
		{
			tmp_name_buf.reset();

			return false;
		}

		_MODULE_INFO* m_info = new _MODULE_INFO;

		m_info->module_base			= (HMODULE)current_entry_data.DllBase;
		m_info->module_entry		= current_entry_data.EntryPoint;
		m_info->module_name_len		= size - 1;
		m_info->module_name.swap(tmp_name_buf);

		process_modules.push_back(m_info);

		if (current == last)
		{
			break;
		}

		current = current_entry_data.InLoadOrderLinks.Flink;
	}

	return true;
}

bool ProcessInfo::GetModuleInfo(const wchar_t* mod_name, _MODULE_INFO* out_module)
{
	if (!mod_name)
	{
		return false;
	}

	if (process_modules.empty())
	{
		if (!ReadAllModules())
		{
			return false;
		}
	}

	for (auto& el : process_modules)
	{
		if (!_wcsicmp(el->module_name.get(), mod_name))
		{
			*out_module = *el;
		
			return true;
		}
	}

	return false;
}

HMODULE ProcessInfo::_GetModuleHandle(const wchar_t* mod_name)
{
	if (!mod_name)
	{
		return 0;
	}

	_MODULE_INFO info;
	if (!GetModuleInfo(mod_name, &info))
	{
		return 0;
	}

	return info.module_base;
}

bool ProcessInfo::IsThreadInAlertableState()
{
	if (!current_thread)
		return false;

	HANDLE h_thread = OpenThread(THREAD_GET_CONTEXT, NULL, GetTID());
	if (!h_thread)
		return false;

	CONTEXT ctx = { 0 };
	ctx.ContextFlags = CONTEXT_ALL;

	if (!GetThreadContext(h_thread, &ctx))
	{
		CloseHandle(h_thread);

		return false;
	}

	CloseHandle(h_thread);

#ifdef _WIN64
#else
	if (!ctx.Eip || !ctx.Esp)
		return false;

	DWORD stack[6] = { 0 };
	if (!ReadProcessMemory(h_current_process, (void*)ctx.Esp, stack, sizeof(stack), NULL))
		return false;

	if (ctx.Eip == wait_functions_address[0]) // NtDelayExecution
	{
		if (GetOSVersion() == g_Win7)
			return stack[2] == true;
		else
			return stack[1] == true;
	}
	else if (ctx.Eip == wait_functions_address[1]) // NtWaitForSingleObject
	{
		if (GetOSVersion() == g_Win7)
			return stack[3] == true;
		else
			return stack[2] == true;
	}
	else if (ctx.Eip == wait_functions_address[2]) // NtWaitForMultipleObjects
	{
		if (GetOSVersion() == g_Win7)
			return stack[5] == true;
		else
			return stack[4] == true;
	}
	else if (ctx.Eip == wait_functions_address[3]) // NtSignalAndWaitForSingleObject
	{
		if (GetOSVersion() == g_Win7)
			return stack[4] == true;
		else
			return stack[3] == true;
	}
	else if (ctx.Eip == wait_functions_address[4]) // NtUserMsgWaitForMultipleObjectsEx
		return (stack[5] & MWMO_ALERTABLE) != 0;
#endif

	return true;
}

bool ProcessInfo::IsThreadWorkerThread()
{
	if (GetOSVersion() < g_Win10 || !current_thread)
		return false;

	BYTE* TEB = (BYTE*)GetTEBaddr();
	if (!TEB)
		return false;

	WORD teb_info;
	if (!ReadProcessMemory(h_current_process, TEB + TEB_SameTebFlags, &teb_info, sizeof(teb_info), NULL))
		return false;

	return (teb_info & TEB_SAMETEB_FLAGS_LoaderWorker) != 0;
}

bool ProcessInfo::GetThreadState(THREAD_STATE* state, KWAIT_REASON* reason)
{
	if (!current_thread || !state || !reason)
		return false;

	*state = current_thread->ThreadState;
	*reason = current_thread->WaitReason;

	return true;
}

const SYSTEM_PROCESS_INFORMATION* ProcessInfo::GetProcessInfo()
{
	return current_process ? current_process : nullptr;
}

const SYSTEM_THREAD_INFORMATION* ProcessInfo::GetThreadInfo()
{
	return current_thread ? current_thread : nullptr;
}

_MODULE_INFO& _MODULE_INFO::operator=(_MODULE_INFO& other)
{
	module_base			= other.module_base;
	module_name			= other.module_name;
	module_entry		= other.module_entry;
	module_name_len		= other.module_name_len;

	return *this;
}
```

`process_info.hpp`:

```hpp
#pragma once

#define PI_INIT_BUFFER_SIZE 0x10000

#define NtUserMsgWaitForMultipleObjectsEx_INDEX_IN_ARRAY 4

#define NT_RET_OFFSET_64_WIN7		0x0A //Win7 - Win10 1507
#define NT_RET_OFFSET_64_WIN10_1511 0x14 //Win10 1511+

#define NT_RET_OFFSET_86_WIN7 0x15 //Win7 only
#define NT_RET_OFFSET_86_WIN8 0x0C //Win8+

#define TEB_SameTebFlags_64 0x17EE
#define TEB_SameTebFlags_86 0xFCA

#define TEB_SAMETEB_FLAGS_LoaderWorker 0x2000

#ifdef _WIN64
#define TEB_SameTebFlags TEB_SameTebFlags_64
#else
#define TEB_SameTebFlags TEB_SameTebFlags_86
#endif

struct _MODULE_INFO
{
	std::shared_ptr<wchar_t[]>	module_name			= { 0 };
	size_t						module_name_len		= 0;
	HMODULE						module_base			= 0;
	PVOID						module_entry		= 0;

	_MODULE_INFO& operator=(_MODULE_INFO& other);
};

class ProcessInfo
{
private:

	SYSTEM_PROCESS_INFORMATION* first_process   = nullptr;
	SYSTEM_PROCESS_INFORMATION* current_process = nullptr;
	SYSTEM_THREAD_INFORMATION*  current_thread  = nullptr;

	f_NtQueryInformationProcess NtQueryInformationProcess = nullptr;
	f_NtQueryInformationThread  NtQueryInformationThread  = nullptr;
	f_NtQuerySystemInformation  NtQuerySystemInformation  = nullptr;

	HANDLE	 h_current_process		= NULL;
	HMODULE  h_win32u				= NULL;
	DWORD	 current_thread_index	= NULL;
	DWORD	 buffer_size			= NULL;
	
	std::vector<_MODULE_INFO*> process_modules;

	DWORD wait_functions_address[5] = { 0 };

	void ClearModulesVec();

public:

	ProcessInfo();
	~ProcessInfo();

	//bool SetProcessByName(const wchar_t* proc_name, DWORD desired_access);
	bool SetProcess(HANDLE h_target_proc);
	bool SetThread(DWORD TID);

	bool FirstThread();
	bool NextThread();

	bool RefreshInformation();

	DWORD GetPID();
	DWORD GetTID();
	
	DWORD GetEntryPoint();

	bool IsProtectedProcess();

	void* GetTEBaddr();
	void* GetPEBaddr();

	bool ReadAllModules();
	bool GetModuleInfo(const wchar_t* mod_name, _MODULE_INFO* out_module);
	HMODULE _GetModuleHandle(const wchar_t* mod_name);

	bool IsThreadInAlertableState();
	bool IsThreadWorkerThread();
	bool GetThreadState(THREAD_STATE* state, KWAIT_REASON* reason);
	
	const SYSTEM_PROCESS_INFORMATION* GetProcessInfo();
	const SYSTEM_THREAD_INFORMATION* GetThreadInfo();
};
```

`start_routine.cpp`:

```cpp
#include "includes.hpp"

DWORD StartRoutine(LAUNCH_METHOD method, HANDLE h_proc, f_Routine routine, DWORD flags, void* arg_routine, DWORD* out, DWORD timeout)
{
	switch (method)
	{
	case LAUNCH_METHOD::LM_THREAD_HIJACK:
		return ThreadHijack(h_proc, routine, arg_routine, out, timeout);

	//case LAUNCH_METHOD::LM_FAKE_VEH:

	case LAUNCH_METHOD::LM_NT_CREATE_THREAD_EX:
		return _NtCreateThreadEx(h_proc, routine, flags, arg_routine, out, timeout);

	//case LAUNCH_METHOD::LM_QUEUE_USER_APC:
	
	default:
		return 0;
	};
}
```

`start_routine.hpp`:

```hpp
#pragma once

// broken

//#define PTR_64_ARR 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//#define PTR_86_ARR 0x00, 0x00, 0x00, 0x00,
//
//#define SR_REMOTE_DATA_PLACEHOLDER_64 PTR_64_ARR PTR_64_ARR PTR_64_ARR PTR_64_ARR PTR_64_ARR PTR_64_ARR
//#define SR_REMOTE_DATA_PLACEHOLDER_86 PTR_86_ARR PTR_86_ARR PTR_86_ARR PTR_86_ARR PTR_86_ARR PTR_86_ARR
//
//#ifdef _WIN64
//#define SR_REMOTE_DATA_PLACEHOLDER SR_REMOTE_DATA_PLACEHOLDER_64
//#else
//#define SR_REMOTE_DATA_PLACEHOLDER SR_REMOTE_DATA_PLACEHOLDER_86
//#endif

#define START_ROUTINE_DEFAULT_TIMEOUT 2000

using f_Routine = DWORD (__stdcall*) (void* arg_routine);

enum class SR_WORK_STATUS : DWORD
{
	WS_PENDING             = 0,
	WS_EXECUTING           = 1,
	WS_EXECUTING_FINISHED  = 2
};

enum class LAUNCH_METHOD
{
	LM_THREAD_HIJACK,
	LM_FAKE_VEH,
	LM_QUEUE_USER_APC,
	LM_NT_CREATE_THREAD_EX
};

struct SR_REMOTE_DATA
{
	SR_WORK_STATUS  status			= SR_WORK_STATUS::WS_PENDING;
	DWORD           last_error		= 0;
	void*           arg_routine		= nullptr;
	f_Routine       routine			= nullptr;
	DWORD           ret				= 0;
	void*			arg_remote_func = nullptr;
	
};

DWORD StartRoutine(LAUNCH_METHOD method, HANDLE h_proc, f_Routine routine, DWORD flags, void* arg_routine, DWORD* out, DWORD timeout);

DWORD ThreadHijack(HANDLE h_proc, f_Routine routine, void* arg_routine, DWORD* out, DWORD timeout);
DWORD _NtCreateThreadEx(HANDLE h_proc, f_Routine routine, DWORD flags, void* arg_routine, DWORD* out, DWORD timeout);
```

`symbol_loader.cpp`:

```cpp
#include "includes.hpp"

bool SymbolLoader::VerifyExistingPDB(const GUID* guid)
{
	std::fstream file(pdb_path, std::ios::in | std::ios::binary | std::ios::ate);

	if (!file.good())
	{
		return false;
	}
	
	size_t file_size = (size_t)file.tellg();

	if (!file_size || file_size < sizeof(PDBHeader))
	{
		file.close();

		return false;
	}

	BYTE* file_raw = new BYTE[file_size];

	if (!file_raw)
	{
		file.close();

		return false;
	}

	file.seekg(0, std::ios::beg);
	file.read((char*)file_raw, file_size);
	file.close();

	PDBHeader* pdb_header = (PDBHeader*)file_raw;

	if (memcmp(pdb_header->signature, "Microsoft C/C++ MSF 7.00\r\n\x1A""DS\0\0\0", sizeof(pdb_header->signature) / sizeof(pdb_header->signature[0])))
	{
		delete[file_size] file_raw;

		return false;
	}

	if (file_size < pdb_header->page_size * pdb_header->num_of_file_pages)
	{
		delete[file_size] file_raw;

		return false;
	}

	int*            root_page_number  = (int*)(file_raw + pdb_header->page_number_of_root_stream_number_list * pdb_header->page_size);
	PDBRootStream*  root_stream       = (PDBRootStream*)(file_raw + *root_page_number * pdb_header->page_size);

	std::map<int, std::vector<int>> streams;

	int current_page_number = 0;
	for (int i = 0; i < root_stream->num_of_streams; ++i)
	{
		int current_stream_size         = root_stream->stream_size[i] == 0xFFFFFFFF ? 0 : root_stream->stream_size[i];
		int current_stream_pages_count  = current_stream_size / pdb_header->page_size;

		if (current_stream_size % pdb_header->page_size)
		{
			++current_stream_pages_count;
		}

		std::vector<int> numbers;

		for (int j = 0; j < current_stream_pages_count; ++j, ++current_page_number)
		{
			numbers.push_back(root_stream->stream_size[root_stream->num_of_streams + current_page_number]); // stream_page_number_list[current_page_number]
		}

		streams.insert(std::make_pair(i, numbers));
	}

	int pdb_info_page_index = 0;
	try
	{
		pdb_info_page_index = streams.at(1).at(0);
	}
	catch (const std::exception& ex)
	{
		ERRLOG("%s", ex.what());
		
		delete[file_size] file_raw;

		return false;
	}

	PDBinfoStream1* pdb_info = (PDBinfoStream1*)(file_raw + pdb_info_page_index * pdb_header->page_size);
	
	GUID pdb_GUID = pdb_info->guid;

	delete[file_size] file_raw;

	return (memcmp(&pdb_GUID, guid, sizeof(GUID)) == FALSE);
}

bool SymbolLoader::Initialize(const wchar_t* dll_path, const wchar_t* pdb_path, bool redownload, DWORD connect_timeout)
{
	is_ready = false;

	if (!dll_path || !pdb_path)
	{
		return false;
	}

	this->dll_path = dll_path;
	this->pdb_path = pdb_path;

	std::fstream file(dll_path, std::ios::in | std::ios::binary | std::ios::ate);

	if (!file.good())
	{
		return false;
	}

	size_t file_size = (size_t)file.tellg();

	if (!file_size)
	{
		file.close();

		return false;
	}

	BYTE* file_raw = new BYTE[file_size];

	if (!file_raw)
	{
		file.close();

		return false;
	}

	file.seekg(0, std::ios::beg);
	file.read((char*)file_raw, file_size);
	file.close();

	IMAGE_DOS_HEADER*         dos_header    = nullptr;
	IMAGE_NT_HEADERS*         pe_header     = nullptr;
	IMAGE_FILE_HEADER*		  file_header   = nullptr;
	IMAGE_OPTIONAL_HEADER32*  opt_header86  = nullptr;
	IMAGE_OPTIONAL_HEADER64*  opt_header64  = nullptr;

	dos_header = (IMAGE_DOS_HEADER*)file_raw;

	if (dos_header->e_magic != IMAGE_DOS_SIGNATURE)
	{
		delete[file_size] file_raw;

		return false;
	}

	pe_header = (IMAGE_NT_HEADERS*)(file_raw + dos_header->e_lfanew);

	if (pe_header->Signature != IMAGE_NT_SIGNATURE)
	{
		delete[file_size] file_raw;

		return false;
	}

	bool x86 = false;

	file_header = &pe_header->FileHeader;

	if (file_header->Machine == IMAGE_FILE_MACHINE_I386)
	{
		x86 = true;

		opt_header86 = (IMAGE_OPTIONAL_HEADER32*)&pe_header->OptionalHeader;
	}
	else if (file_header->Machine == IMAGE_FILE_MACHINE_AMD64)
	{
		opt_header64 = (IMAGE_OPTIONAL_HEADER64*)&pe_header->OptionalHeader;
	}
	else
	{
		delete[file_size] file_raw;

		return false;
	}

	DWORD image_size = x86 ? opt_header86->SizeOfImage : opt_header64->SizeOfImage;

	if (!image_size)
	{
		delete[file_size] file_raw;

		return false;
	}

	BYTE* local_image_base = new BYTE[image_size];
	
	if (!local_image_base)
	{
		delete[file_size] file_raw;

		return false;
	}

	IMAGE_SECTION_HEADER* first_section = IMAGE_FIRST_SECTION(pe_header);

	if (!first_section)
	{
		delete[file_size] file_raw;
		delete[image_size] local_image_base;

		return false;
	}

	for (DWORD i = 0; i < file_header->NumberOfSections; ++i)
	{
		if (first_section->SizeOfRawData)
		{
			memcpy(local_image_base + first_section->VirtualAddress, file_raw + first_section->PointerToRawData, first_section->SizeOfRawData);
		}
	}

	IMAGE_DATA_DIRECTORY* data_dir = nullptr;

	if (x86)
	{
		data_dir = &opt_header86->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG];
	}
	else
	{
		data_dir = &opt_header64->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG];
	}

	if (!data_dir->Size)
	{
		delete[image_size] local_image_base;
		delete[file_size] file_raw;

		return false;
	}

	IMAGE_DEBUG_DIRECTORY* debug_dir = (IMAGE_DEBUG_DIRECTORY*)(local_image_base + data_dir->VirtualAddress);

	if (debug_dir->Type != IMAGE_DEBUG_TYPE_CODEVIEW)
	{
		delete[image_size] local_image_base;
		delete[file_size] file_raw;

		return false;
	}

	PDBinfo* pdb_info = (PDBinfo*)(local_image_base + debug_dir->AddressOfRawData);

	if (pdb_info->signature != PDB_INFO_SIGNATURE)
	{
		delete[image_size] local_image_base;
		delete[file_size] file_raw;

		return false;
	}

	GUID pdb_GUID = pdb_info->guid;
	DWORD pdb_age = pdb_info->age;

	std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> conv;
	
	std::wstring pdb_file_name = conv.from_bytes(pdb_info->pdb_file_name);

	delete[image_size] local_image_base;
	delete[file_size] file_raw;

	pdb_info = nullptr;

	if (pdb_file_name.empty())
	{
		return false;
	}

	if (this->pdb_path[this->pdb_path.size() - 1] != '\\')
	{
		this->pdb_path += '\\';
	}

	if (!CreateDirectoryW(this->pdb_path.c_str(), NULL))
	{
		if (GetLastError() == ERROR_PATH_NOT_FOUND)
		{
			return false;
		}
	}

	this->pdb_path += x86 ? L"x86\\" : L"x64\\";

	if (!CreateDirectoryW(this->pdb_path.c_str(), NULL))
	{
		if (GetLastError() == ERROR_PATH_NOT_FOUND)
		{
			return false;
		}
	}

	this->pdb_path += pdb_file_name;

	WIN32_FILE_ATTRIBUTE_DATA file_data = { 0 };
	if (GetFileAttributesExW(this->pdb_path.c_str(), GET_FILEEX_INFO_LEVELS::GetFileExInfoStandard, &file_data))
	{
		if (!redownload && !VerifyExistingPDB(&pdb_GUID))
		{
			redownload = true;
		}

		if (redownload)
		{
			DeleteFileW(this->pdb_path.c_str());
		}
		else
		{
			pdb_size = file_data.nFileSizeLow;
		}
	}
	else
	{
		redownload = true;
	}

	if (redownload)
	{
		wchar_t w_GUID[100] = { 0 };
		if (!StringFromGUID2(pdb_GUID, w_GUID, 100))
		{
			return false;
		}
	
		std::wstring GUID_filtered;
		for (DWORD i = 0; w_GUID[i]; ++i)
		{
			if ((w_GUID[i] >= '0' && w_GUID[i] <= '9') || (w_GUID[i] >= 'A' && w_GUID[i] <= 'F') || (w_GUID[i] >= 'a' && w_GUID[i] <= 'f'))
			{
				GUID_filtered += w_GUID[i];
			}
		}

		std::wstring url = L"https://msdl.microsoft.com/download/symbols/";
		url += pdb_file_name;
		url += '/';
		url += GUID_filtered;
		url += std::to_wstring(pdb_age);
		url += '/';
		url += pdb_file_name;

		bool connected = false;

		ULONGLONG tick = GetTickCount64();
		do
		{
			if (InternetCheckConnectionW(L"https://msdl.microsoft.com", FLAG_ICC_FORCE_CONNECTION, NULL) == FALSE)
			{
				if (GetLastError() == ERROR_INTERNET_CANNOT_CONNECT)
				{
					return false;
				}
			}
			else
			{
				connected = true;

				break;
			}

			Sleep(25);
		} while (GetTickCount64() - tick <= connect_timeout);

		if (!connected)
		{
			return false;
		}

		wchar_t cache_file[MAX_PATH] = { 0 };

		if (FAILED(URLDownloadToCacheFileW(NULL, url.c_str(), cache_file, MAX_PATH, NULL, NULL)))
		{
			if (cache_file[0] != '\0')
			{
				DeleteFileW(cache_file);
			}

			return false;
		}

		if (!CopyFileW(cache_file, this->pdb_path.c_str(), FALSE))
		{
			DeleteFileW(cache_file);
			
			return false;
		}

		DeleteFileW(cache_file);
	}

	if (!pdb_size)
	{
		if (!GetFileAttributesExW(this->pdb_path.c_str(), GET_FILEEX_INFO_LEVELS::GetFileExInfoStandard, &file_data))
		{
			return false;
		}

		pdb_size = file_data.nFileSizeLow;
	}

	is_ready = true;

	return true;
}

bool SymbolLoader::IsReady() const
{
	return is_ready;
}

void SymbolLoader::Cleanup()
{
	dll_path = { 0 };
	pdb_path = { 0 };

	pdb_size = 0;

	is_ready = false;
}

size_t SymbolLoader::GetPDBSize() const
{
	return pdb_size;
}

std::wstring SymbolLoader::GetPDBPath() const
{
	return pdb_path;
}

std::wstring SymbolLoader::GetDLLPath() const
{
	return dll_path;
}
```

`symbol_loader.hpp`:

```hpp
#pragma once

#define PDB_INFO_SIGNATURE 0x53445352
#define SL_DEFAULT_TIMEOUT 10000

class SymbolLoader
{
private:

	std::wstring dll_path = { 0 };
	std::wstring pdb_path = { 0 };

	bool    is_ready = false;
	size_t  pdb_size = 0;

	bool VerifyExistingPDB(const GUID* guid);

public:

	bool Initialize(const wchar_t* dll_path, const wchar_t* pdb_path, bool redownload, DWORD connect_timeout);

	bool IsReady() const;

	void Cleanup();

	size_t		  GetPDBSize() const;
	std::wstring  GetPDBPath() const;
	std::wstring  GetDLLPath() const;
};

struct PDBinfo
{
	DWORD  signature;
	GUID   guid;
	DWORD  age;
	char   pdb_file_name[ANYSIZE_ARRAY];
};

struct PDBHeader
{
	char signature[0x20];
	int page_size;
	int alloc_table_ptr;
	int num_of_file_pages;
	int root_stream_size;
	int reserved;
	int page_number_of_root_stream_number_list;
};

struct PDBRootStream
{
	int num_of_streams;
	int stream_size[ANYSIZE_ARRAY]; // num_of_streams
 // int stream_page_number_list[ANYSIZE_ARRAY]
};

struct PDBinfoStream1
{
	int version;
	int time_date_stamp;
	int age;
	GUID guid;
};
```

`symbol_parser.cpp`:

```cpp
#include "includes.hpp"

SymbolParser::~SymbolParser()
{
	Cleanup();
}

bool SymbolParser::Cleanup()
{
	if (initialized)
	{
		if (sym_table)
		{
			SymUnloadModule64(h_proc, sym_table);

			sym_table = 0;
		}

		SymCleanup(h_proc);

		initialized = false;
	}

	if (h_proc)
	{
		CloseHandle(h_proc);

		h_proc = 0;
	}

	is_ready = false;

	return true;
}

bool SymbolParser::Initialize(const SymbolLoader* loader)
{
	is_ready = false;
	
	if (!loader)
	{
		return false;
	}

	if (!loader->IsReady())
	{
		return false;
	}

	if (sym_table)
	{
		if (!SymUnloadModule64(h_proc, sym_table))
		{
			return false;
		}

		sym_table = 0;
	}

	if (!h_proc)
	{
		h_proc = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, NULL, GetCurrentProcessId());

		if (!h_proc)
		{
			return false;
		}
	}

	if (!initialized)
	{
		SymSetOptions(SYMOPT_UNDNAME | SYMOPT_AUTO_PUBLICS | SYMOPT_DEFERRED_LOADS);

		if (!SymInitialize(h_proc, NULL, NULL))
		{
			CloseHandle(h_proc);

			return false;
		}

		initialized = true;
	}

	sym_table = SymLoadModuleExW(h_proc, NULL, loader->GetPDBPath().c_str(), NULL, 0x10000000, loader->GetPDBSize(), NULL, NULL);
	if (!sym_table)
	{
		SymCleanup(h_proc);

		CloseHandle(h_proc);

		initialized = false;

		return false;
	}

	is_ready = true;

	return true;
}

DWORD SymbolParser::GetSymbolAddress(const wchar_t* sym_name)
{
	if (!is_ready)
	{
		return 0;
	}

	if (!sym_name)
	{
		return 0;
	}

	SYMBOL_INFOW si = { 0 };
	si.SizeOfStruct = sizeof(si);
	if (!SymFromNameW(h_proc, sym_name, &si))
	{
		return 0;
	}

	return (DWORD)(si.Address - si.ModBase);
}

bool SymbolParser::IsReady()
{
	return is_ready;
}

```

`symbol_parser.hpp`:

```hpp
#pragma once

class SymbolParser
{
private:

	HANDLE   h_proc       = 0;
	DWORD64  sym_table    = 0;
	bool	 initialized  = false;
	bool	 is_ready     = false;

public:

	~SymbolParser();

	bool Cleanup();

	bool Initialize(const SymbolLoader* loader);

	DWORD GetSymbolAddress(const wchar_t* sym_name);

	bool IsReady();
};

inline SymbolParser sym_parser;
```

`tools.cpp`:

```cpp
#include "includes.hpp"

DWORD GetProcId(const wchar_t* proc_name)
{
	DWORD proc_id = NULL;
	HANDLE h_snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

	PROCESSENTRY32 p_entry = { 0 };
	p_entry.dwSize = sizeof(p_entry);

	if (h_snap == INVALID_HANDLE_VALUE)
	{
		ERRLOG("CreateToolhelp32Snapshot: % d\n", GetLastError());
		return NULL;
	}

	if (Process32First(h_snap, &p_entry))
	{
		do
		{
			if (!wcscmp(proc_name, p_entry.szExeFile))
			{
				proc_id = p_entry.th32ProcessID;
				break;
			}

		} while (Process32Next(h_snap, &p_entry));
	}

	CloseHandle(h_snap);
	return proc_id;
}

DWORD GetOwnModuleFullPathW(fs::path& mod_name_path)
{
	wchar_t mod_name_buf[MAX_PATH] = { 0 };

	DWORD mod_name_len = GetModuleFileNameW(g_h_current_module, mod_name_buf, sizeof(mod_name_buf) / sizeof(mod_name_buf[0]));

	if (!mod_name_len || GetLastError() == ERROR_INSUFFICIENT_BUFFER)
	{
		return 0;
	}

	mod_name_path = mod_name_buf;

	return mod_name_len;
}

bool VerifyDLL(const wchar_t* file_path, WORD desired_machine)
{
	if (!file_path)
	{
		return false;
	}

	std::fstream file(file_path, std::ios::in | std::ios::binary | std::ios::ate);

	if (!file.good())
	{
		return false;
	}

	DWORD file_size = (DWORD)file.tellg();

	if (!file_size || file_size < PAGE_SIZE)
	{
		file.close();

		return false;
	}

	BYTE* file_raw = new BYTE[PAGE_SIZE];

	if (!file_raw)
	{
		file.close();

		return false;
	}

	file.seekg(0, std::ios::beg);
	file.read((char*)file_raw, PAGE_SIZE);
	file.close();

	IMAGE_DOS_HEADER*		dos_header   = nullptr;
	IMAGE_NT_HEADERS*		pe_header    = nullptr;
	IMAGE_FILE_HEADER*		file_header  = nullptr;

	dos_header = (IMAGE_DOS_HEADER*)file_raw;

	if (dos_header->e_magic != IMAGE_DOS_SIGNATURE || dos_header->e_lfanew > PAGE_SIZE)
	{
		delete[PAGE_SIZE] file_raw;

		return false;
	}

	pe_header = (IMAGE_NT_HEADERS*)(file_raw + dos_header->e_lfanew);

	if (pe_header->Signature != IMAGE_NT_SIGNATURE)
	{
		delete[PAGE_SIZE] file_raw;

		return false;
	}

	file_header = &pe_header->FileHeader;

	if (!(file_header->Machine & desired_machine) || !(file_header->Characteristics & IMAGE_FILE_DLL))
	{
		delete[PAGE_SIZE] file_raw;

		return false;
	}

	delete[PAGE_SIZE] file_raw;

	return true;
}

bool IsNativeProcess(HANDLE h_proc)
{
	BOOL wow64 = FALSE;
	IsWow64Process(h_proc, &wow64);

	return (wow64 == FALSE);
}

DWORD IsElevatedProcess(HANDLE h_proc)
{
	HANDLE h_token = 0;
	if (!OpenProcessToken(h_proc, TOKEN_QUERY, &h_token))
	{
		return -1;
	}

	TOKEN_ELEVATION te = { 0 };
	DWORD size_out = 0;
	if (!GetTokenInformation(h_token, TOKEN_INFORMATION_CLASS::TokenElevation, &te, sizeof(te), &size_out))
	{
		CloseHandle(h_token);
		
		return -1;
	}
	
	CloseHandle(h_token);

	return te.TokenIsElevated != 0;
}

int _random(int begin, int end)
{
	return begin + rand() % (end - begin + 1);
}
```

`tools.hpp`:

```hpp
#pragma once

// macro to convert 64-types into a DWORD without triggereing C4302 or C4311 (also works on 32-bit sized pointers)
#define MDWD(t) ((DWORD)(ULONG_PTR)t & 0xFFFFFFFF)

#define JMP_DST(dst, src) ((DWORD)dst - ((DWORD)src + 5))

#define PAGE_SIZE 0x1000

#define _LOG(format, type, ...) printf("[ "##type" ] "##format"\n", __VA_ARGS__)
#define ERRLOG(format, ...) _LOG(format, "ERROR", __VA_ARGS__)
#define SUCCLOG(format, ...) _LOG(format, "SUCCESS", __VA_ARGS__)
#define LOG(format, ...) _LOG(format, "LOG", __VA_ARGS__)

#define CODE_SEG(seg_name) __declspec(code_seg(seg_name))

#define SUSP_ERR(dword) ((DWORD)dword == -1)

#define _ZeroMemory(ptr, size) memset(ptr, 0, size)

#define ALIGN_64 __declspec(align(8))
#define ALIGN_86 __declspec(align(4))

#ifdef _WIN64
#define ALIGN ALIGN_64
#else
#define ALIGN ALIGN_86
#endif

DWORD GetProcId(const wchar_t* proc_name);

DWORD GetOwnModuleFullPathW(fs::path& mod_name_path);

bool VerifyDLL(const wchar_t* file_path, WORD desired_machine);

bool IsNativeProcess(HANDLE h_proc);

DWORD IsElevatedProcess(HANDLE h_proc);

int _random(int begin, int end);

__forceinline DWORD bit_rotate_r(DWORD val, int count)
{
	return (val >> count) | (val << (-count));
}

__forceinline DWORD bit_rotate_l(DWORD val, int count)
{
	return (val << count) | (val >> (-count));
}

#define EncodeSystemPtr_64(ptr) (bit_rotate_r((*P_KUSER_SHARED_DATA_COOKIE) ^ ptr, (*P_KUSER_SHARED_DATA_COOKIE) & 0x3F))
#define EncodeSystemPtr_32(ptr) (bit_rotate_r((*P_KUSER_SHARED_DATA_COOKIE) ^ ptr, (*P_KUSER_SHARED_DATA_COOKIE) & 0x1F))

#define DecodeSystemPtr_64(ptr) (bit_rotate_l(ptr, (*P_KUSER_SHARED_DATA_COOKIE) & 0x3F) ^ (*P_KUSER_SHARED_DATA_COOKIE))
#define DecodeSystemPtr_32(ptr) (bit_rotate_l(ptr, (*P_KUSER_SHARED_DATA_COOKIE) & 0x1F) ^ (*P_KUSER_SHARED_DATA_COOKIE))

#ifdef _WIN64
#define DecodeSystemPtr DecodeSystemPtr_64
#define EncodeSystemPtr EncodeSystemPtr_64
#else
#define DecodeSystemPtr DecodeSystemPtr_32
#define EncodeSystemPtr EncodeSystemPtr_32
#endif
```

`veh_shell.cpp`:

```cpp
#include "includes.hpp"

LONG CODE_SEG(".veh$1") CALLBACK VEHShell(EXCEPTION_POINTERS* EP)
{
	volatile auto* data = (VEH_SHELL_DATA*)(VEH_DATA_SIG32);
	EXCEPTION_REGISTRATION_RECORD* ex_reg_rec = (EXCEPTION_REGISTRATION_RECORD*)__readfsdword(0x00);

	if (!ex_reg_rec)
	{
		return 0;
	}

	RTL_INVERTED_FUNCTION_TABLE_ENTRY* entry = nullptr;

	if (data->os_version == g_Win7)
	{
		entry = &((RTL_INVERTED_FUNCTION_TABLE_WIN7*)data->_LdrpInvertedFunctionTable)->Entries[0];
	}
	else
	{
		entry = &data->_LdrpInvertedFunctionTable->Entries[0];
	}

	for (DWORD i = 0; i < data->_LdrpInvertedFunctionTable->Count; ++i)
	{
		if (entry[i].ImageBase == data->image_base)
		{
			entry = &entry[i];

			break;
		}
	}

	DWORD ptr_dec = DecodeSystemPtr((DWORD)entry->ExceptionDirectory);

	DWORD* start = (DWORD*)ptr_dec;

	if (data->os_version >= g_Win81)
	{
		data->_LdrProtectMrdata(FALSE);
	}

	for (; ex_reg_rec && ex_reg_rec != (EXCEPTION_REGISTRATION_RECORD*)(0xFFFFFFFF) && ex_reg_rec->Next != (EXCEPTION_REGISTRATION_RECORD*)(0xFFFFFFFF); ex_reg_rec = ex_reg_rec->Next)
	{
		if ((BYTE*)ex_reg_rec->Handler < data->image_base || (BYTE*)ex_reg_rec->Handler >= data->image_base + data->image_size)
		{
			continue;
		}

		bool new_handler = false;

		for (DWORD* rva = start; rva != nullptr && rva < start + 0x100; ++rva)
		{
			if (*rva == 0)
			{
				*rva = (DWORD)ex_reg_rec->Handler - (DWORD)entry->ImageBase;
				
				++entry->ExceptionDirectorySize;

				new_handler = true;

				break;
			}
			else if (*rva == (DWORD)ex_reg_rec->Handler - (DWORD)entry->ImageBase)
			{
				break;
			}
		}

		if (new_handler)
		{
			for (DWORD i = 0; i < entry->ExceptionDirectorySize; ++i)
			{
				for (DWORD j = entry->ExceptionDirectorySize - 1; j > i; --j)
				{
					if (start[j - 1] > start[j])
					{
						start[j - 1] ^= start[j];
						start[j] ^= start[j - 1];
						start[j - 1] ^= start[j];
					}
				}
			}
		}
	}

	if (data->os_version >= g_Win81)
	{
		data->_LdrProtectMrdata(TRUE);
	}

	return EXCEPTION_CONTINUE_SEARCH;
}

LONG CODE_SEG(".veh$2") CALLBACK VEHShell_End()
{
	return 0;
}
```

`veh_shell.hpp`:

```hpp
#pragma once

#define VEH_DATA_SIG32 0x77777777
#define VEH_DATA_SIG64 0x1488133714881337

#ifdef _WIN64
#define VEH_DATA_SIG VEH_DATA_SIG64
#else
#define VEH_DATA_SIG VEH_DATA_SIG32
#endif

// i use this fucking crutch because a compiler does some shit with volatile pointer to VEH_SHELL_DATA in the VEHShell function
__forceinline bool FindAndReplacePointers(BYTE* start, size_t len, UINT_PTR signature, UINT_PTR value)
{
	if (!start || !len)
	{
		return false;
	}

	BYTE* _start = start;

	bool found = false;

	for (; start < (_start + len) - sizeof(UINT_PTR);)
	{
		found = true;
		DWORD i = 0;

		for (; start[i] == ((BYTE*)&signature)[(sizeof(UINT_PTR) - 1) - i] && i < sizeof(UINT_PTR); ++i);

		if (i < sizeof(UINT_PTR) / 2)
		{
			found = false;
		}

		if (found)
		{
			DWORD offset = (*(DWORD*)(start - (sizeof(UINT_PTR) - i))) - signature;

			*(DWORD*)(start - (sizeof(UINT_PTR) - i)) = value + offset;

			start += i;
		}
		else
		{
			++start;
		}
	}

	return true;
}

struct VEH_SHELL_DATA
{
	DWORD os_version	= 0;
	BYTE* image_base	= 0;
	DWORD image_size	= 0;

	f_LdrProtectMrdata				_LdrProtectMrdata;
	f_LdrpInvertedFunctionTable		_LdrpInvertedFunctionTable;
};

LONG CODE_SEG(".veh$1") CALLBACK VEHShell(EXCEPTION_POINTERS* EP);
LONG CODE_SEG(".veh$2") CALLBACK VEHShell_End();
```