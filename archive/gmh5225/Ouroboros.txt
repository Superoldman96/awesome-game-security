Project Path: arc_gmh5225_Ouroboros_mite0iz6

Source Tree:

```txt
arc_gmh5225_Ouroboros_mite0iz6
├── Cargo.lock
├── Cargo.toml
├── LICENSE-APACHE
├── LICENSE-MIT
├── README.md
├── assets
│   └── screenshot.png
└── src
    ├── ir
    │   ├── abstract_syntax_tree.rs
    │   ├── address.rs
    │   ├── basic_block.rs
    │   ├── control_flow_graph.rs
    │   ├── expression.rs
    │   ├── high_function.rs
    │   ├── mod.rs
    │   ├── program_tree_structure.rs
    │   ├── scope.rs
    │   └── utils.rs
    ├── main.rs
    ├── memory.rs
    ├── symbol_resolver.rs
    ├── tab_viewer
    │   ├── bb_graph.rs
    │   ├── decompiler.rs
    │   ├── instruction_view.rs
    │   ├── mod.rs
    │   └── theme.rs
    └── test.rs

```

`Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "ab_glyph"
version = "0.2.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e074464580a518d16a7126262fffaaa47af89d4099d4cb403f8ed938ba12ee7d"
dependencies = [
 "ab_glyph_rasterizer",
 "owned_ttf_parser",
]

[[package]]
name = "ab_glyph_rasterizer"
version = "0.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "366ffbaa4442f4684d91e2cd7c5ea7c4ed8add41959a31447066e279e432b618"

[[package]]
name = "accesskit"
version = "0.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e25ae84c0260bdf5df07796d7cc4882460de26a2b406ec0e6c42461a723b271b"
dependencies = [
 "enumn",
 "serde",
]

[[package]]
name = "accesskit_atspi_common"
version = "0.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "29bd41de2e54451a8ca0dd95ebf45b54d349d29ebceb7f20be264eee14e3d477"
dependencies = [
 "accesskit",
 "accesskit_consumer",
 "atspi-common",
 "serde",
 "thiserror 1.0.69",
 "zvariant",
]

[[package]]
name = "accesskit_consumer"
version = "0.28.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8bfae7c152994a31dc7d99b8eeac7784a919f71d1b306f4b83217e110fd3824c"
dependencies = [
 "accesskit",
 "hashbrown",
]

[[package]]
name = "accesskit_macos"
version = "0.20.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "692dd318ff8a7a0ffda67271c4bd10cf32249656f4e49390db0b26ca92b095f2"
dependencies = [
 "accesskit",
 "accesskit_consumer",
 "hashbrown",
 "objc2 0.5.2",
 "objc2-app-kit 0.2.2",
 "objc2-foundation 0.2.2",
]

[[package]]
name = "accesskit_unix"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c5f7474c36606d0fe4f438291d667bae7042ea2760f506650ad2366926358fc8"
dependencies = [
 "accesskit",
 "accesskit_atspi_common",
 "async-channel",
 "async-executor",
 "async-task",
 "atspi",
 "futures-lite",
 "futures-util",
 "serde",
 "zbus",
]

[[package]]
name = "accesskit_windows"
version = "0.27.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70a042b62c9c05bf7b616f015515c17d2813f3ba89978d6f4fc369735d60700a"
dependencies = [
 "accesskit",
 "accesskit_consumer",
 "hashbrown",
 "static_assertions",
 "windows 0.61.3",
 "windows-core 0.61.2",
]

[[package]]
name = "accesskit_winit"
version = "0.27.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c1f0d3d13113d8857542a4f8d1a1c24d1dc1527b77aee8426127f4901588708"
dependencies = [
 "accesskit",
 "accesskit_macos",
 "accesskit_unix",
 "accesskit_windows",
 "raw-window-handle",
 "winit",
]

[[package]]
name = "adler2"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "320119579fcad9c21884f5c4861d16174d0e06250625266f50fe6898340abefa"

[[package]]
name = "ahash"
version = "0.8.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a15f179cd60c4584b8a8c596927aadc462e27f2ca70c04e0071964a73ba7a75"
dependencies = [
 "cfg-if",
 "getrandom 0.3.3",
 "once_cell",
 "serde",
 "version_check",
 "zerocopy",
]

[[package]]
name = "allocator-api2"
version = "0.2.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "683d7910e743518b0e34f1186f92494becacb047c7b6bf616c96772180fef923"

[[package]]
name = "android-activity"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ef6978589202a00cd7e118380c448a08b6ed394c3a8df3a430d0898e3a42d046"
dependencies = [
 "android-properties",
 "bitflags 2.9.2",
 "cc",
 "cesu8",
 "jni",
 "jni-sys",
 "libc",
 "log",
 "ndk",
 "ndk-context",
 "ndk-sys 0.6.0+11769913",
 "num_enum",
 "thiserror 1.0.69",
]

[[package]]
name = "android-properties"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc7eb209b1518d6bb87b283c20095f5228ecda460da70b44f0802523dea6da04"

[[package]]
name = "android_system_properties"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
dependencies = [
 "libc",
]

[[package]]
name = "arboard"
version = "3.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "55f533f8e0af236ffe5eb979b99381df3258853f00ba2e44b6e1955292c75227"
dependencies = [
 "clipboard-win",
 "image",
 "log",
 "objc2 0.6.2",
 "objc2-app-kit 0.3.1",
 "objc2-core-foundation",
 "objc2-core-graphics",
 "objc2-foundation 0.3.1",
 "parking_lot",
 "percent-encoding",
 "windows-sys 0.59.0",
 "x11rb",
]

[[package]]
name = "arrayref"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "76a2e8124351fda1ef8aaaa3bbd7ebbcb486bbcd4225aca0aa0d84bb2db8fecb"

[[package]]
name = "arrayvec"
version = "0.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7c02d123df017efcdfbd739ef81735b36c5ba83ec3c59c80a9d7ecc718f92e50"

[[package]]
name = "as-raw-xcb-connection"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "175571dd1d178ced59193a6fc02dde1b972eb0bc56c892cde9beeceac5bf0f6b"

[[package]]
name = "ash"
version = "0.38.0+1.3.281"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0bb44936d800fea8f016d7f2311c6a4f97aebd5dc86f09906139ec848cf3a46f"
dependencies = [
 "libloading",
]

[[package]]
name = "async-broadcast"
version = "0.7.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "435a87a52755b8f27fcf321ac4f04b2802e337c8c4872923137471ec39c37532"
dependencies = [
 "event-listener",
 "event-listener-strategy",
 "futures-core",
 "pin-project-lite",
]

[[package]]
name = "async-channel"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "924ed96dd52d1b75e9c1a3e6275715fd320f5f9439fb5a4a11fa51f4221158d2"
dependencies = [
 "concurrent-queue",
 "event-listener-strategy",
 "futures-core",
 "pin-project-lite",
]

[[package]]
name = "async-executor"
version = "1.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bb812ffb58524bdd10860d7d974e2f01cc0950c2438a74ee5ec2e2280c6c4ffa"
dependencies = [
 "async-task",
 "concurrent-queue",
 "fastrand",
 "futures-lite",
 "pin-project-lite",
 "slab",
]

[[package]]
name = "async-io"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "19634d6336019ef220f09fd31168ce5c184b295cbf80345437cc36094ef223ca"
dependencies = [
 "async-lock",
 "cfg-if",
 "concurrent-queue",
 "futures-io",
 "futures-lite",
 "parking",
 "polling",
 "rustix 1.0.8",
 "slab",
 "windows-sys 0.60.2",
]

[[package]]
name = "async-lock"
version = "3.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5fd03604047cee9b6ce9de9f70c6cd540a0520c813cbd49bae61f33ab80ed1dc"
dependencies = [
 "event-listener",
 "event-listener-strategy",
 "pin-project-lite",
]

[[package]]
name = "async-process"
version = "2.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "65daa13722ad51e6ab1a1b9c01299142bc75135b337923cfa10e79bbbd669f00"
dependencies = [
 "async-channel",
 "async-io",
 "async-lock",
 "async-signal",
 "async-task",
 "blocking",
 "cfg-if",
 "event-listener",
 "futures-lite",
 "rustix 1.0.8",
]

[[package]]
name = "async-recursion"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b43422f69d8ff38f95f1b2bb76517c91589a924d1559a0e935d7c8ce0274c11"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "async-signal"
version = "0.2.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f567af260ef69e1d52c2b560ce0ea230763e6fbb9214a85d768760a920e3e3c1"
dependencies = [
 "async-io",
 "async-lock",
 "atomic-waker",
 "cfg-if",
 "futures-core",
 "futures-io",
 "rustix 1.0.8",
 "signal-hook-registry",
 "slab",
 "windows-sys 0.60.2",
]

[[package]]
name = "async-task"
version = "4.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b75356056920673b02621b35afd0f7dda9306d03c79a30f5c56c44cf256e3de"

[[package]]
name = "async-trait"
version = "0.1.89"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9035ad2d096bed7955a320ee7e2230574d28fd3c3a0f186cbea1ff3c7eed5dbb"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "atomic-waker"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1505bd5d3d116872e7271a6d4e16d81d0c8570876c8de68093a09ac269d8aac0"

[[package]]
name = "atspi"
version = "0.25.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c83247582e7508838caf5f316c00791eee0e15c0bf743e6880585b867e16815c"
dependencies = [
 "atspi-common",
 "atspi-connection",
 "atspi-proxies",
]

[[package]]
name = "atspi-common"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33dfc05e7cdf90988a197803bf24f5788f94f7c94a69efa95683e8ffe76cfdfb"
dependencies = [
 "enumflags2",
 "serde",
 "static_assertions",
 "zbus",
 "zbus-lockstep",
 "zbus-lockstep-macros",
 "zbus_names",
 "zvariant",
]

[[package]]
name = "atspi-connection"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4193d51303d8332304056ae0004714256b46b6635a5c556109b319c0d3784938"
dependencies = [
 "atspi-common",
 "atspi-proxies",
 "futures-lite",
 "zbus",
]

[[package]]
name = "atspi-proxies"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d2eebcb9e7e76f26d0bcfd6f0295e1cd1e6f33bedbc5698a971db8dc43d7751c"
dependencies = [
 "atspi-common",
 "serde",
 "zbus",
]

[[package]]
name = "autocfg"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c08606f8c3cbf4ce6ec8e28fb0014a2c086708fe954eaa885384a6165172e7e8"

[[package]]
name = "base64"
version = "0.22.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b3254f16251a8381aa12e40e3c4d2f0199f8c6508fbecb9d91f575e0fbb8c6"

[[package]]
name = "bin_ast"
version = "0.1.0"
dependencies = [
 "eframe",
 "egui",
 "egui_dock",
 "egui_extras",
 "egui_graphs",
 "emath",
 "enum-map",
 "enumset",
 "iced-x86",
 "nodit",
 "petgraph",
 "rayon",
]

[[package]]
name = "bit-set"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08807e080ed7f9d5433fa9b275196cfc35414f66a0c79d864dc51a0d825231a3"
dependencies = [
 "bit-vec",
]

[[package]]
name = "bit-vec"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e764a1d40d510daf35e07be9eb06e75770908c27d411ee6c92109c9840eaaf7"

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.9.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a65b545ab31d687cff52899d4890855fec459eb6afe0da6417b8a18da87aa29"
dependencies = [
 "serde",
]

[[package]]
name = "block"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0d8c1fef690941d3e7788d328517591fecc684c084084702d6ff1641e993699a"

[[package]]
name = "block2"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2c132eebf10f5cad5289222520a4a058514204aed6d791f1cf4fe8088b82d15f"
dependencies = [
 "objc2 0.5.2",
]

[[package]]
name = "blocking"
version = "1.6.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e83f8d02be6967315521be875afa792a316e28d57b5a2d401897e2a7921b7f21"
dependencies = [
 "async-channel",
 "async-task",
 "futures-io",
 "futures-lite",
 "piper",
]

[[package]]
name = "btree_monstrousity"
version = "0.0.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2ec92912346b936c974181a172d9abc81f50d41e40118fc101dac8aa8134bee3"
dependencies = [
 "cfg-if",
 "rustversion",
]

[[package]]
name = "bumpalo"
version = "3.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"

[[package]]
name = "bytemuck"
version = "1.23.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3995eaeebcdf32f91f980d360f78732ddc061097ab4e39991ae7a6ace9194677"
dependencies = [
 "bytemuck_derive",
]

[[package]]
name = "bytemuck_derive"
version = "1.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4f154e572231cb6ba2bd1176980827e3d5dc04cc183a75dea38109fbdd672d29"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "byteorder-lite"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f1fe948ff07f4bd06c30984e69f5b4899c516a3ef74f34df92a2df2ab535495"

[[package]]
name = "bytes"
version = "1.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d71b6127be86fdcfddb610f7182ac57211d4b18a3e9c82eb2d17662f2227ad6a"

[[package]]
name = "calloop"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b99da2f8558ca23c71f4fd15dc57c906239752dd27ff3c00a1d56b685b7cbfec"
dependencies = [
 "bitflags 2.9.2",
 "log",
 "polling",
 "rustix 0.38.44",
 "slab",
 "thiserror 1.0.69",
]

[[package]]
name = "calloop-wayland-source"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "95a66a987056935f7efce4ab5668920b5d0dac4a7c99991a67395f13702ddd20"
dependencies = [
 "calloop",
 "rustix 0.38.44",
 "wayland-backend",
 "wayland-client",
]

[[package]]
name = "cc"
version = "1.2.33"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3ee0f8803222ba5a7e2777dd72ca451868909b1ac410621b676adf07280e9b5f"
dependencies = [
 "jobserver",
 "libc",
 "shlex",
]

[[package]]
name = "cesu8"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6d43a04d8753f35258c91f8ec639f792891f748a1edbd759cf1dcea3382ad83c"

[[package]]
name = "cfg-if"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2fd1289c04a9ea8cb22300a459a72a385d7c73d3259e2ed7dcb2af674838cfa9"

[[package]]
name = "cfg_aliases"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "613afe47fcd5fac7ccf1db93babcb082c5994d996f20b8b159f2ad1658eb5724"

[[package]]
name = "cgl"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ced0551234e87afee12411d535648dd89d2e7f34c78b753395567aff3d447ff"
dependencies = [
 "libc",
]

[[package]]
name = "clipboard-win"
version = "5.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bde03770d3df201d4fb868f2c9c59e66a3e4e2bd06692a0fe701e7103c7e84d4"
dependencies = [
 "error-code",
]

[[package]]
name = "codespan-reporting"
version = "0.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fe6d2e5af09e8c8ad56c969f2157a3d4238cebc7c55f0a517728c38f7b200f81"
dependencies = [
 "serde",
 "termcolor",
 "unicode-width",
]

[[package]]
name = "combine"
version = "4.6.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba5a308b75df32fe02788e748662718f03fde005016435c444eea572398219fd"
dependencies = [
 "bytes",
 "memchr",
]

[[package]]
name = "concurrent-queue"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4ca0197aee26d1ae37445ee532fefce43251d24cc7c166799f4d46817f1d3973"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "core-foundation"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "91e195e091a93c46f7102ec7818a2aa394e1e1771c3ab4825963fa03e45afb8f"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "core-foundation"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b2a6cd9ae233e7f62ba4e9353e81a88df7fc8a5987b8d445b4d90c879bd156f6"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "core-foundation-sys"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"

[[package]]
name = "core-graphics"
version = "0.23.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c07782be35f9e1140080c6b96f0d44b739e2278479f64e02fdab4e32dfd8b081"
dependencies = [
 "bitflags 1.3.2",
 "core-foundation 0.9.4",
 "core-graphics-types",
 "foreign-types",
 "libc",
]

[[package]]
name = "core-graphics-types"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "45390e6114f68f718cc7a830514a96f903cccd70d02a8f6d9f643ac4ba45afaf"
dependencies = [
 "bitflags 1.3.2",
 "core-foundation 0.9.4",
 "libc",
]

[[package]]
name = "crc32fast"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9481c1c90cbf2ac953f07c8d4a58aa3945c425b7185c9154d67a65e4230da511"
dependencies = [
 "cfg-if",
]

[[package]]
name = "crossbeam-deque"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9dd111b7b7f7d55b72c0a6ae361660ee5853c9af73f70c3c2ef6858b950e2e51"
dependencies = [
 "crossbeam-epoch",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-epoch"
version = "0.9.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-utils"
version = "0.8.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d0a5c400df2834b80a4c3327b3aad3a4c4cd4de0629063962b03235697506a28"

[[package]]
name = "crunchy"
version = "0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "460fbee9c2c2f33933d720630a6a0bac33ba7053db5344fac858d4b8952d77d5"

[[package]]
name = "cursor-icon"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f27ae1dd37df86211c42e150270f82743308803d90a6f6e6651cd730d5e1732f"

[[package]]
name = "darling"
version = "0.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9cdf337090841a411e2a7f3deb9187445851f91b309c0c0a29e05f74a00a48c0"
dependencies = [
 "darling_core",
 "darling_macro",
]

[[package]]
name = "darling_core"
version = "0.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1247195ecd7e3c85f83c8d2a366e4210d588e802133e1e355180a9870b517ea4"
dependencies = [
 "fnv",
 "ident_case",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "darling_macro"
version = "0.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d38308df82d1080de0afee5d069fa14b0326a88c14f15c5ccda35b4a6c414c81"
dependencies = [
 "darling_core",
 "quote",
 "syn",
]

[[package]]
name = "dispatch"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bd0c93bb4b0c6d9b77f4435b0ae98c24d17f1c45b2ff844c6151a07256ca923b"

[[package]]
name = "dispatch2"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "89a09f22a6c6069a18470eb92d2298acf25463f14256d24778e1230d789a2aec"
dependencies = [
 "bitflags 2.9.2",
 "objc2 0.6.2",
]

[[package]]
name = "displaydoc"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97369cbbc041bc366949bc74d34658d6cda5621039731c6310521892a3a20ae0"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "dlib"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "330c60081dcc4c72131f8eb70510f1ac07223e5d4163db481a04a0befcffa412"
dependencies = [
 "libloading",
]

[[package]]
name = "document-features"
version = "0.2.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "95249b50c6c185bee49034bcb378a49dc2b5dff0be90ff6616d31d64febab05d"
dependencies = [
 "litrs",
]

[[package]]
name = "downcast-rs"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75b325c5dbd37f80359721ad39aca5a29fb04c89279657cffdda8736d0c0b9d2"

[[package]]
name = "dpi"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d8b14ccef22fc6f5a8f4d7d768562a182c04ce9a3b3157b91390b52ddfdf1a76"

[[package]]
name = "duplicate"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97af9b5f014e228b33e77d75ee0e6e87960124f0f4b16337b586a6bec91867b1"
dependencies = [
 "heck",
 "proc-macro2",
 "proc-macro2-diagnostics",
]

[[package]]
name = "ecolor"
version = "0.32.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6a7fc3172c2ef56966b2ce4f84177e159804c40b9a84de8861558ce4a59f422"
dependencies = [
 "bytemuck",
 "emath",
 "serde",
]

[[package]]
name = "eframe"
version = "0.32.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34037a80dc03a4147e1684bff4e4fdab2b1408d715d7b78470cd3179258964b9"
dependencies = [
 "ahash",
 "bytemuck",
 "document-features",
 "egui",
 "egui-wgpu",
 "egui-winit",
 "egui_glow",
 "glow",
 "glutin",
 "glutin-winit",
 "image",
 "js-sys",
 "log",
 "objc2 0.5.2",
 "objc2-app-kit 0.2.2",
 "objc2-foundation 0.2.2",
 "parking_lot",
 "percent-encoding",
 "profiling",
 "raw-window-handle",
 "static_assertions",
 "wasm-bindgen",
 "wasm-bindgen-futures",
 "web-sys",
 "web-time",
 "winapi",
 "windows-sys 0.59.0",
 "winit",
]

[[package]]
name = "egui"
version = "0.32.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49e2be082f77715496b4a39fdc6f5dc7491fefe2833111781b8697ea6ee919a7"
dependencies = [
 "accesskit",
 "ahash",
 "bitflags 2.9.2",
 "emath",
 "epaint",
 "log",
 "nohash-hasher",
 "profiling",
 "ron",
 "serde",
 "smallvec",
 "unicode-segmentation",
]

[[package]]
name = "egui-wgpu"
version = "0.32.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "64c7277a171ec1b711080ddb3b0bfa1b3aa9358834d5386d39e83fbc16d61212"
dependencies = [
 "ahash",
 "bytemuck",
 "document-features",
 "egui",
 "epaint",
 "log",
 "profiling",
 "thiserror 1.0.69",
 "type-map",
 "web-time",
 "wgpu",
 "winit",
]

[[package]]
name = "egui-winit"
version = "0.32.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fe6d8b0f8d6de4d43e794e343f03bacc3908aada931f0ed6fd7041871388a590"
dependencies = [
 "accesskit_winit",
 "ahash",
 "arboard",
 "bytemuck",
 "egui",
 "log",
 "profiling",
 "raw-window-handle",
 "smithay-clipboard",
 "web-time",
 "webbrowser",
 "winit",
]

[[package]]
name = "egui_dock"
version = "0.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baa7ef4e24fccd35639705ba68a58a5713c19b15a2cd426c0a26901b5954882c"
dependencies = [
 "duplicate",
 "egui",
 "paste",
]

[[package]]
name = "egui_extras"
version = "0.32.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ae8f23013328beb6be7ab29c75807142e8e1c7951643780a813e54cceaa9929"
dependencies = [
 "ahash",
 "egui",
 "enum-map",
 "log",
 "mime_guess2",
 "profiling",
]

[[package]]
name = "egui_glow"
version = "0.32.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ab645760288e42eab70283a5cccf44509a6f43b554351855d3c73594bfe3c23"
dependencies = [
 "ahash",
 "bytemuck",
 "egui",
 "glow",
 "log",
 "memoffset",
 "profiling",
 "wasm-bindgen",
 "web-sys",
 "winit",
]

[[package]]
name = "egui_graphs"
version = "0.28.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f1a4f357adce91fb5fa51edb89d7ea81dd18a2e9a66f01ece7298b1b13eea8d"
dependencies = [
 "egui",
 "getrandom 0.2.16",
 "instant",
 "petgraph",
 "rand 0.9.2",
 "serde",
]

[[package]]
name = "either"
version = "1.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48c757948c5ede0e46177b7add2e67155f70e33c07fea8284df6576da70b3719"

[[package]]
name = "emath"
version = "0.32.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "935df67dc48fdeef132f2f7ada156ddc79e021344dd42c17f066b956bb88dde3"
dependencies = [
 "bytemuck",
 "serde",
]

[[package]]
name = "endi"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a3d8a32ae18130a3c84dd492d4215c3d913c3b07c6b63c2eb3eb7ff1101ab7bf"

[[package]]
name = "enum-map"
version = "2.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6866f3bfdf8207509a033af1a75a7b08abda06bbaaeae6669323fd5a097df2e9"
dependencies = [
 "enum-map-derive",
]

[[package]]
name = "enum-map-derive"
version = "0.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f282cfdfe92516eb26c2af8589c274c7c17681f5ecc03c18255fe741c6aa64eb"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "enumflags2"
version = "0.7.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1027f7680c853e056ebcec683615fb6fbbc07dbaa13b4d5d9442b146ded4ecef"
dependencies = [
 "enumflags2_derive",
 "serde",
]

[[package]]
name = "enumflags2_derive"
version = "0.7.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "67c78a4d8fdf9953a5c9d458f9efe940fd97a0cab0941c075a813ac594733827"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "enumn"
version = "0.1.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2f9ed6b3789237c8a0c1c505af1c7eb2c560df6186f01b098c3a1064ea532f38"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "enumset"
version = "1.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "25b07a8dfbbbfc0064c0a6bdf9edcf966de6b1c33ce344bdeca3b41615452634"
dependencies = [
 "enumset_derive",
]

[[package]]
name = "enumset_derive"
version = "0.14.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f43e744e4ea338060faee68ed933e46e722fb7f3617e722a5772d7e856d8b3ce"
dependencies = [
 "darling",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "epaint"
version = "0.32.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b66fc0a5a9d322917de9bd3ac7d426ca8aa3127fbf1e76fae5b6b25e051e06a3"
dependencies = [
 "ab_glyph",
 "ahash",
 "bytemuck",
 "ecolor",
 "emath",
 "epaint_default_fonts",
 "log",
 "nohash-hasher",
 "parking_lot",
 "profiling",
 "rayon",
 "serde",
]

[[package]]
name = "epaint_default_fonts"
version = "0.32.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4f6cf8ce0fb817000aa24f5e630bda904a353536bd430b83ebc1dceee95b4a3a"

[[package]]
name = "equivalent"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"

[[package]]
name = "errno"
version = "0.3.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "778e2ac28f6c47af28e4907f13ffd1e1ddbd400980a9abd7c8df189bf578a5ad"
dependencies = [
 "libc",
 "windows-sys 0.60.2",
]

[[package]]
name = "error-code"
version = "3.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dea2df4cf52843e0452895c455a1a2cfbb842a1e7329671acf418fdc53ed4c59"

[[package]]
name = "event-listener"
version = "5.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e13b66accf52311f30a0db42147dadea9850cb48cd070028831ae5f5d4b856ab"
dependencies = [
 "concurrent-queue",
 "parking",
 "pin-project-lite",
]

[[package]]
name = "event-listener-strategy"
version = "0.5.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8be9f3dfaaffdae2972880079a491a1a8bb7cbed0b8dd7a347f668b4150a3b93"
dependencies = [
 "event-listener",
 "pin-project-lite",
]

[[package]]
name = "fastrand"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "37909eebbb50d72f9059c3b6d82c0463f2ff062c9e95845c43a6c9c0355411be"

[[package]]
name = "fdeflate"
version = "0.3.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e6853b52649d4ac5c0bd02320cddc5ba956bdb407c4b75a2c6b75bf51500f8c"
dependencies = [
 "simd-adler32",
]

[[package]]
name = "fixedbitset"
version = "0.5.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1d674e81391d1e1ab681a28d99df07927c6d4aa5b027d7da16ba32d1d21ecd99"

[[package]]
name = "flate2"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a3d7db9596fecd151c5f638c0ee5d5bd487b6e0ea232e5dc96d5250f6f94b1d"
dependencies = [
 "crc32fast",
 "miniz_oxide",
]

[[package]]
name = "fnv"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"

[[package]]
name = "foldhash"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d9c4f5dac5e15c24eb999c26181a6ca40b39fe946cbe4c263c7209467bc83af2"

[[package]]
name = "foreign-types"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d737d9aa519fb7b749cbc3b962edcf310a8dd1f4b67c91c4f83975dbdd17d965"
dependencies = [
 "foreign-types-macros",
 "foreign-types-shared",
]

[[package]]
name = "foreign-types-macros"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a5c6c585bc94aaf2c7b51dd4c2ba22680844aba4c687be581871a6f518c5742"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "foreign-types-shared"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aa9a19cbb55df58761df49b23516a86d432839add4af60fc256da840f66ed35b"

[[package]]
name = "form_urlencoded"
version = "1.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cb4cb245038516f5f85277875cdaa4f7d2c9a0fa0468de06ed190163b1581fcf"
dependencies = [
 "percent-encoding",
]

[[package]]
name = "futures-core"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05f29059c0c2090612e8d742178b0580d2dc940c837851ad723096f87af6663e"

[[package]]
name = "futures-io"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e5c1b78ca4aae1ac06c48a526a655760685149f0d465d21f37abfe57ce075c6"

[[package]]
name = "futures-lite"
version = "2.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f78e10609fe0e0b3f4157ffab1876319b5b0db102a2c60dc4626306dc46b44ad"
dependencies = [
 "fastrand",
 "futures-core",
 "futures-io",
 "parking",
 "pin-project-lite",
]

[[package]]
name = "futures-macro"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "162ee34ebcb7c64a8abebc059ce0fee27c2262618d7b60ed8faf72fef13c3650"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "futures-task"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f90f7dce0722e95104fcb095585910c0977252f286e354b5e3bd38902cd99988"

[[package]]
name = "futures-util"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fa08315bb612088cc391249efdc3bc77536f16c91f6cf495e6fbe85b20a4a81"
dependencies = [
 "futures-core",
 "futures-macro",
 "futures-task",
 "pin-project-lite",
 "pin-utils",
 "slab",
]

[[package]]
name = "gethostname"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0176e0459c2e4a1fe232f984bca6890e681076abb9934f6cea7c326f3fc47818"
dependencies = [
 "libc",
 "windows-targets 0.48.5",
]

[[package]]
name = "getrandom"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "335ff9f135e4384c8150d6f27c6daed433577f86b4750418338c01a1a2528592"
dependencies = [
 "cfg-if",
 "js-sys",
 "libc",
 "wasi 0.11.1+wasi-snapshot-preview1",
 "wasm-bindgen",
]

[[package]]
name = "getrandom"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26145e563e54f2cadc477553f1ec5ee650b00862f0a58bcd12cbdc5f0ea2d2f4"
dependencies = [
 "cfg-if",
 "libc",
 "r-efi",
 "wasi 0.14.2+wasi-0.2.4",
]

[[package]]
name = "gl_generator"
version = "0.14.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a95dfc23a2b4a9a2f5ab41d194f8bfda3cabec42af4e39f08c339eb2a0c124d"
dependencies = [
 "khronos_api",
 "log",
 "xml-rs",
]

[[package]]
name = "glow"
version = "0.16.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c5e5ea60d70410161c8bf5da3fdfeaa1c72ed2c15f8bbb9d19fe3a4fad085f08"
dependencies = [
 "js-sys",
 "slotmap",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "glutin"
version = "0.32.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "12124de845cacfebedff80e877bb37b5b75c34c5a4c89e47e1cdd67fb6041325"
dependencies = [
 "bitflags 2.9.2",
 "cfg_aliases",
 "cgl",
 "dispatch2",
 "glutin_egl_sys",
 "glutin_glx_sys",
 "glutin_wgl_sys",
 "libloading",
 "objc2 0.6.2",
 "objc2-app-kit 0.3.1",
 "objc2-core-foundation",
 "objc2-foundation 0.3.1",
 "once_cell",
 "raw-window-handle",
 "wayland-sys",
 "windows-sys 0.52.0",
 "x11-dl",
]

[[package]]
name = "glutin-winit"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85edca7075f8fc728f28cb8fbb111a96c3b89e930574369e3e9c27eb75d3788f"
dependencies = [
 "cfg_aliases",
 "glutin",
 "raw-window-handle",
 "winit",
]

[[package]]
name = "glutin_egl_sys"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4c4680ba6195f424febdc3ba46e7a42a0e58743f2edb115297b86d7f8ecc02d2"
dependencies = [
 "gl_generator",
 "windows-sys 0.52.0",
]

[[package]]
name = "glutin_glx_sys"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a7bb2938045a88b612499fbcba375a77198e01306f52272e692f8c1f3751185"
dependencies = [
 "gl_generator",
 "x11-dl",
]

[[package]]
name = "glutin_wgl_sys"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2c4ee00b289aba7a9e5306d57c2d05499b2e5dc427f84ac708bd2c090212cf3e"
dependencies = [
 "gl_generator",
]

[[package]]
name = "gpu-alloc"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fbcd2dba93594b227a1f57ee09b8b9da8892c34d55aa332e034a228d0fe6a171"
dependencies = [
 "bitflags 2.9.2",
 "gpu-alloc-types",
]

[[package]]
name = "gpu-alloc-types"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "98ff03b468aa837d70984d55f5d3f846f6ec31fe34bbb97c4f85219caeee1ca4"
dependencies = [
 "bitflags 2.9.2",
]

[[package]]
name = "gpu-allocator"
version = "0.27.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c151a2a5ef800297b4e79efa4f4bec035c5f51d5ae587287c9b952bdf734cacd"
dependencies = [
 "log",
 "presser",
 "thiserror 1.0.69",
 "windows 0.58.0",
]

[[package]]
name = "gpu-descriptor"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b89c83349105e3732062a895becfc71a8f921bb71ecbbdd8ff99263e3b53a0ca"
dependencies = [
 "bitflags 2.9.2",
 "gpu-descriptor-types",
 "hashbrown",
]

[[package]]
name = "gpu-descriptor-types"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fdf242682df893b86f33a73828fb09ca4b2d3bb6cc95249707fc684d27484b91"
dependencies = [
 "bitflags 2.9.2",
]

[[package]]
name = "half"
version = "2.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "459196ed295495a68f7d7fe1d84f6c4b7ff0e21fe3017b2f283c6fac3ad803c9"
dependencies = [
 "cfg-if",
 "crunchy",
 "num-traits",
]

[[package]]
name = "hashbrown"
version = "0.15.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9229cfe53dfd69f0609a49f65461bd93001ea1ef889cd5529dd176593f5338a1"
dependencies = [
 "allocator-api2",
 "equivalent",
 "foldhash",
]

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "hermit-abi"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc0fef456e4baa96da950455cd02c081ca953b141298e41db3fc7e36b1da849c"

[[package]]
name = "hex"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"

[[package]]
name = "hexf-parse"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dfa686283ad6dd069f105e5ab091b04c62850d3e4cf5d67debad1933f55023df"

[[package]]
name = "iced-x86"
version = "1.21.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7c447cff8c7f384a7d4f741cfcff32f75f3ad02b406432e8d6c878d56b1edf6b"
dependencies = [
 "lazy_static",
]

[[package]]
name = "icu_collections"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "200072f5d0e3614556f94a9930d5dc3e0662a652823904c3a75dc3b0af7fee47"
dependencies = [
 "displaydoc",
 "potential_utf",
 "yoke",
 "zerofrom",
 "zerovec",
]

[[package]]
name = "icu_locale_core"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0cde2700ccaed3872079a65fb1a78f6c0a36c91570f28755dda67bc8f7d9f00a"
dependencies = [
 "displaydoc",
 "litemap",
 "tinystr",
 "writeable",
 "zerovec",
]

[[package]]
name = "icu_normalizer"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "436880e8e18df4d7bbc06d58432329d6458cc84531f7ac5f024e93deadb37979"
dependencies = [
 "displaydoc",
 "icu_collections",
 "icu_normalizer_data",
 "icu_properties",
 "icu_provider",
 "smallvec",
 "zerovec",
]

[[package]]
name = "icu_normalizer_data"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00210d6893afc98edb752b664b8890f0ef174c8adbb8d0be9710fa66fbbf72d3"

[[package]]
name = "icu_properties"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "016c619c1eeb94efb86809b015c58f479963de65bdb6253345c1a1276f22e32b"
dependencies = [
 "displaydoc",
 "icu_collections",
 "icu_locale_core",
 "icu_properties_data",
 "icu_provider",
 "potential_utf",
 "zerotrie",
 "zerovec",
]

[[package]]
name = "icu_properties_data"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "298459143998310acd25ffe6810ed544932242d3f07083eee1084d83a71bd632"

[[package]]
name = "icu_provider"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "03c80da27b5f4187909049ee2d72f276f0d9f99a42c306bd0131ecfe04d8e5af"
dependencies = [
 "displaydoc",
 "icu_locale_core",
 "stable_deref_trait",
 "tinystr",
 "writeable",
 "yoke",
 "zerofrom",
 "zerotrie",
 "zerovec",
]

[[package]]
name = "ident_case"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9e0384b61958566e926dc50660321d12159025e767c18e043daf26b70104c39"

[[package]]
name = "idna"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b0875f23caa03898994f6ddc501886a45c7d3d62d04d2d90788d47be1b1e4de"
dependencies = [
 "idna_adapter",
 "smallvec",
 "utf8_iter",
]

[[package]]
name = "idna_adapter"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3acae9609540aa318d1bc588455225fb2085b9ed0c4f6bd0d9d5bcd86f1a0344"
dependencies = [
 "icu_normalizer",
 "icu_properties",
]

[[package]]
name = "image"
version = "0.25.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "db35664ce6b9810857a38a906215e75a9c879f0696556a39f59c62829710251a"
dependencies = [
 "bytemuck",
 "byteorder-lite",
 "num-traits",
 "png",
 "tiff",
]

[[package]]
name = "indexmap"
version = "2.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fe4cd85333e22411419a0bcae1297d25e58c9443848b11dc6a86fefe8c78a661"
dependencies = [
 "equivalent",
 "hashbrown",
]

[[package]]
name = "instant"
version = "0.1.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e0242819d153cba4b4b05a5a8f2a7e9bbf97b6055b2a002b395c96b5ff3c0222"
dependencies = [
 "cfg-if",
]

[[package]]
name = "itertools"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "413ee7dfc52ee1a4949ceeb7dbc8a33f2d6c088194d9f922fb8318faf1f01186"
dependencies = [
 "either",
]

[[package]]
name = "jni"
version = "0.21.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a87aa2bb7d2af34197c04845522473242e1aa17c12f4935d5856491a7fb8c97"
dependencies = [
 "cesu8",
 "cfg-if",
 "combine",
 "jni-sys",
 "log",
 "thiserror 1.0.69",
 "walkdir",
 "windows-sys 0.45.0",
]

[[package]]
name = "jni-sys"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8eaf4bc02d17cbdd7ff4c7438cafcdf7fb9a4613313ad11b4f8fefe7d3fa0130"

[[package]]
name = "jobserver"
version = "0.1.33"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38f262f097c174adebe41eb73d66ae9c06b2844fb0da69969647bbddd9b0538a"
dependencies = [
 "getrandom 0.3.3",
 "libc",
]

[[package]]
name = "jpeg-decoder"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00810f1d8b74be64b13dbf3db89ac67740615d6c891f0e7b6179326533011a07"

[[package]]
name = "js-sys"
version = "0.3.77"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1cfaf33c695fc6e08064efbc1f72ec937429614f25eef83af942d0e227c3a28f"
dependencies = [
 "once_cell",
 "wasm-bindgen",
]

[[package]]
name = "khronos-egl"
version = "6.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6aae1df220ece3c0ada96b8153459b67eebe9ae9212258bb0134ae60416fdf76"
dependencies = [
 "libc",
 "libloading",
 "pkg-config",
]

[[package]]
name = "khronos_api"
version = "3.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e2db585e1d738fc771bf08a151420d3ed193d9d895a36df7f6f8a9456b911ddc"

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"

[[package]]
name = "libc"
version = "0.2.175"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a82ae493e598baaea5209805c49bbf2ea7de956d50d7da0da1164f9c6d28543"

[[package]]
name = "libloading"
version = "0.8.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07033963ba89ebaf1584d767badaa2e8fcec21aedea6b8c0346d487d49c28667"
dependencies = [
 "cfg-if",
 "windows-targets 0.53.3",
]

[[package]]
name = "libm"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f9fbbcab51052fe104eb5e5d351cf728d30a5be1fe14d9be8a3b097481fb97de"

[[package]]
name = "libredox"
version = "0.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "391290121bad3d37fbddad76d8f5d1c1c314cfc646d143d7e07a3086ddff0ce3"
dependencies = [
 "bitflags 2.9.2",
 "libc",
 "redox_syscall 0.5.17",
]

[[package]]
name = "linux-raw-sys"
version = "0.4.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d26c52dbd32dccf2d10cac7725f8eae5296885fb5703b261f7d0a0739ec807ab"

[[package]]
name = "linux-raw-sys"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cd945864f07fe9f5371a27ad7b52a172b4b499999f1d97574c9fa68373937e12"

[[package]]
name = "litemap"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "241eaef5fd12c88705a01fc1066c48c4b36e0dd4377dcdc7ec3942cea7a69956"

[[package]]
name = "litrs"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f5e54036fe321fd421e10d732f155734c4e4afd610dd556d9a82833ab3ee0bed"

[[package]]
name = "lock_api"
version = "0.4.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96936507f153605bddfcda068dd804796c84324ed2510809e5b2a624c81da765"
dependencies = [
 "autocfg",
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13dc2df351e3202783a1fe0d44375f7295ffb4049267b0f3018346dc122a1d94"

[[package]]
name = "malloc_buf"
version = "0.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62bb907fe88d54d8d9ce32a3cceab4218ed2f6b7d35617cafe9adf84e43919cb"
dependencies = [
 "libc",
]

[[package]]
name = "memchr"
version = "2.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0"

[[package]]
name = "memmap2"
version = "0.9.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "483758ad303d734cec05e5c12b41d7e93e6a6390c5e9dae6bdeb7c1259012d28"
dependencies = [
 "libc",
]

[[package]]
name = "memoffset"
version = "0.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "488016bfae457b036d996092f6cb448677611ce4449e970ceaf42695203f218a"
dependencies = [
 "autocfg",
]

[[package]]
name = "metal"
version = "0.31.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f569fb946490b5743ad69813cb19629130ce9374034abe31614a36402d18f99e"
dependencies = [
 "bitflags 2.9.2",
 "block",
 "core-graphics-types",
 "foreign-types",
 "log",
 "objc",
 "paste",
]

[[package]]
name = "mime"
version = "0.3.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6877bb514081ee2a7ff5ef9de3281f14a4dd4bceac4c09388074a6b5df8a139a"

[[package]]
name = "mime_guess2"
version = "2.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1706dc14a2e140dec0a7a07109d9a3d5890b81e85bd6c60b906b249a77adf0ca"
dependencies = [
 "mime",
 "phf",
 "phf_shared",
 "unicase",
]

[[package]]
name = "miniz_oxide"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fa76a2c86f704bdb222d66965fb3d63269ce38518b83cb0575fca855ebb6316"
dependencies = [
 "adler2",
 "simd-adler32",
]

[[package]]
name = "naga"
version = "25.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b977c445f26e49757f9aca3631c3b8b836942cb278d69a92e7b80d3b24da632"
dependencies = [
 "arrayvec",
 "bit-set",
 "bitflags 2.9.2",
 "cfg_aliases",
 "codespan-reporting",
 "half",
 "hashbrown",
 "hexf-parse",
 "indexmap",
 "log",
 "num-traits",
 "once_cell",
 "rustc-hash 1.1.0",
 "spirv",
 "strum",
 "thiserror 2.0.16",
 "unicode-ident",
]

[[package]]
name = "ndk"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3f42e7bbe13d351b6bead8286a43aac9534b82bd3cc43e47037f012ebfd62d4"
dependencies = [
 "bitflags 2.9.2",
 "jni-sys",
 "log",
 "ndk-sys 0.6.0+11769913",
 "num_enum",
 "raw-window-handle",
 "thiserror 1.0.69",
]

[[package]]
name = "ndk-context"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "27b02d87554356db9e9a873add8782d4ea6e3e58ea071a9adb9a2e8ddb884a8b"

[[package]]
name = "ndk-sys"
version = "0.5.0+25.2.9519653"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8c196769dd60fd4f363e11d948139556a344e79d451aeb2fa2fd040738ef7691"
dependencies = [
 "jni-sys",
]

[[package]]
name = "ndk-sys"
version = "0.6.0+11769913"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee6cda3051665f1fb8d9e08fc35c96d5a244fb1be711a03b71118828afc9a873"
dependencies = [
 "jni-sys",
]

[[package]]
name = "nix"
version = "0.30.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "74523f3a35e05aba87a1d978330aef40f67b0304ac79c1c00b294c9830543db6"
dependencies = [
 "bitflags 2.9.2",
 "cfg-if",
 "cfg_aliases",
 "libc",
 "memoffset",
]

[[package]]
name = "nodit"
version = "0.9.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f74369f80df24efd2266602fdcd8fcd56a17c2e2c94ab48d2f7a15eaa137bf49"
dependencies = [
 "btree_monstrousity",
 "itertools",
 "smallvec",
]

[[package]]
name = "nohash-hasher"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2bf50223579dc7cdcfb3bfcacf7069ff68243f8c363f62ffa99cf000a6b9c451"

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
 "libm",
]

[[package]]
name = "num_enum"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a973b4e44ce6cad84ce69d797acf9a044532e4184c4f267913d1b546a0727b7a"
dependencies = [
 "num_enum_derive",
 "rustversion",
]

[[package]]
name = "num_enum_derive"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77e878c846a8abae00dd069496dbe8751b16ac1c3d6bd2a7283a938e8228f90d"
dependencies = [
 "proc-macro-crate",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "objc"
version = "0.2.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "915b1b472bc21c53464d6c8461c9d3af805ba1ef837e1cac254428f4a77177b1"
dependencies = [
 "malloc_buf",
]

[[package]]
name = "objc-sys"
version = "0.3.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cdb91bdd390c7ce1a8607f35f3ca7151b65afc0ff5ff3b34fa350f7d7c7e4310"

[[package]]
name = "objc2"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "46a785d4eeff09c14c487497c162e92766fbb3e4059a71840cecc03d9a50b804"
dependencies = [
 "objc-sys",
 "objc2-encode",
]

[[package]]
name = "objc2"
version = "0.6.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "561f357ba7f3a2a61563a186a163d0a3a5247e1089524a3981d49adb775078bc"
dependencies = [
 "objc2-encode",
]

[[package]]
name = "objc2-app-kit"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e4e89ad9e3d7d297152b17d39ed92cd50ca8063a89a9fa569046d41568891eff"
dependencies = [
 "bitflags 2.9.2",
 "block2",
 "libc",
 "objc2 0.5.2",
 "objc2-core-data",
 "objc2-core-image",
 "objc2-foundation 0.2.2",
 "objc2-quartz-core",
]

[[package]]
name = "objc2-app-kit"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6f29f568bec459b0ddff777cec4fe3fd8666d82d5a40ebd0ff7e66134f89bcc"
dependencies = [
 "bitflags 2.9.2",
 "objc2 0.6.2",
 "objc2-core-foundation",
 "objc2-core-graphics",
 "objc2-foundation 0.3.1",
]

[[package]]
name = "objc2-cloud-kit"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "74dd3b56391c7a0596a295029734d3c1c5e7e510a4cb30245f8221ccea96b009"
dependencies = [
 "bitflags 2.9.2",
 "block2",
 "objc2 0.5.2",
 "objc2-core-location",
 "objc2-foundation 0.2.2",
]

[[package]]
name = "objc2-contacts"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a5ff520e9c33812fd374d8deecef01d4a840e7b41862d849513de77e44aa4889"
dependencies = [
 "block2",
 "objc2 0.5.2",
 "objc2-foundation 0.2.2",
]

[[package]]
name = "objc2-core-data"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "617fbf49e071c178c0b24c080767db52958f716d9eabdf0890523aeae54773ef"
dependencies = [
 "bitflags 2.9.2",
 "block2",
 "objc2 0.5.2",
 "objc2-foundation 0.2.2",
]

[[package]]
name = "objc2-core-foundation"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1c10c2894a6fed806ade6027bcd50662746363a9589d3ec9d9bef30a4e4bc166"
dependencies = [
 "bitflags 2.9.2",
 "dispatch2",
 "objc2 0.6.2",
]

[[package]]
name = "objc2-core-graphics"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "989c6c68c13021b5c2d6b71456ebb0f9dc78d752e86a98da7c716f4f9470f5a4"
dependencies = [
 "bitflags 2.9.2",
 "dispatch2",
 "objc2 0.6.2",
 "objc2-core-foundation",
 "objc2-io-surface",
]

[[package]]
name = "objc2-core-image"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "55260963a527c99f1819c4f8e3b47fe04f9650694ef348ffd2227e8196d34c80"
dependencies = [
 "block2",
 "objc2 0.5.2",
 "objc2-foundation 0.2.2",
 "objc2-metal",
]

[[package]]
name = "objc2-core-location"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "000cfee34e683244f284252ee206a27953279d370e309649dc3ee317b37e5781"
dependencies = [
 "block2",
 "objc2 0.5.2",
 "objc2-contacts",
 "objc2-foundation 0.2.2",
]

[[package]]
name = "objc2-encode"
version = "4.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ef25abbcd74fb2609453eb695bd2f860d389e457f67dc17cafc8b8cbc89d0c33"

[[package]]
name = "objc2-foundation"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ee638a5da3799329310ad4cfa62fbf045d5f56e3ef5ba4149e7452dcf89d5a8"
dependencies = [
 "bitflags 2.9.2",
 "block2",
 "dispatch",
 "libc",
 "objc2 0.5.2",
]

[[package]]
name = "objc2-foundation"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "900831247d2fe1a09a683278e5384cfb8c80c79fe6b166f9d14bfdde0ea1b03c"
dependencies = [
 "bitflags 2.9.2",
 "objc2 0.6.2",
 "objc2-core-foundation",
]

[[package]]
name = "objc2-io-surface"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7282e9ac92529fa3457ce90ebb15f4ecbc383e8338060960760fa2cf75420c3c"
dependencies = [
 "bitflags 2.9.2",
 "objc2 0.6.2",
 "objc2-core-foundation",
]

[[package]]
name = "objc2-link-presentation"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1a1ae721c5e35be65f01a03b6d2ac13a54cb4fa70d8a5da293d7b0020261398"
dependencies = [
 "block2",
 "objc2 0.5.2",
 "objc2-app-kit 0.2.2",
 "objc2-foundation 0.2.2",
]

[[package]]
name = "objc2-metal"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dd0cba1276f6023976a406a14ffa85e1fdd19df6b0f737b063b95f6c8c7aadd6"
dependencies = [
 "bitflags 2.9.2",
 "block2",
 "objc2 0.5.2",
 "objc2-foundation 0.2.2",
]

[[package]]
name = "objc2-quartz-core"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e42bee7bff906b14b167da2bac5efe6b6a07e6f7c0a21a7308d40c960242dc7a"
dependencies = [
 "bitflags 2.9.2",
 "block2",
 "objc2 0.5.2",
 "objc2-foundation 0.2.2",
 "objc2-metal",
]

[[package]]
name = "objc2-symbols"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0a684efe3dec1b305badae1a28f6555f6ddd3bb2c2267896782858d5a78404dc"
dependencies = [
 "objc2 0.5.2",
 "objc2-foundation 0.2.2",
]

[[package]]
name = "objc2-ui-kit"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b8bb46798b20cd6b91cbd113524c490f1686f4c4e8f49502431415f3512e2b6f"
dependencies = [
 "bitflags 2.9.2",
 "block2",
 "objc2 0.5.2",
 "objc2-cloud-kit",
 "objc2-core-data",
 "objc2-core-image",
 "objc2-core-location",
 "objc2-foundation 0.2.2",
 "objc2-link-presentation",
 "objc2-quartz-core",
 "objc2-symbols",
 "objc2-uniform-type-identifiers",
 "objc2-user-notifications",
]

[[package]]
name = "objc2-uniform-type-identifiers"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "44fa5f9748dbfe1ca6c0b79ad20725a11eca7c2218bceb4b005cb1be26273bfe"
dependencies = [
 "block2",
 "objc2 0.5.2",
 "objc2-foundation 0.2.2",
]

[[package]]
name = "objc2-user-notifications"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "76cfcbf642358e8689af64cee815d139339f3ed8ad05103ed5eaf73db8d84cb3"
dependencies = [
 "bitflags 2.9.2",
 "block2",
 "objc2 0.5.2",
 "objc2-core-location",
 "objc2-foundation 0.2.2",
]

[[package]]
name = "once_cell"
version = "1.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"

[[package]]
name = "orbclient"
version = "0.3.48"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba0b26cec2e24f08ed8bb31519a9333140a6599b867dac464bb150bdb796fd43"
dependencies = [
 "libredox",
]

[[package]]
name = "ordered-float"
version = "4.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7bb71e1b3fa6ca1c61f383464aaf2bb0e2f8e772a1f01d486832464de363b951"
dependencies = [
 "num-traits",
]

[[package]]
name = "ordered-stream"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9aa2b01e1d916879f73a53d01d1d6cee68adbb31d6d9177a8cfce093cced1d50"
dependencies = [
 "futures-core",
 "pin-project-lite",
]

[[package]]
name = "owned_ttf_parser"
version = "0.25.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "36820e9051aca1014ddc75770aab4d68bc1e9e632f0f5627c4086bc216fb583b"
dependencies = [
 "ttf-parser",
]

[[package]]
name = "parking"
version = "2.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f38d5652c16fde515bb1ecef450ab0f6a219d619a7274976324d5e377f7dceba"

[[package]]
name = "parking_lot"
version = "0.12.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70d58bf43669b5795d1576d0641cfb6fbb2057bf629506267a92807158584a13"
dependencies = [
 "lock_api",
 "parking_lot_core",
]

[[package]]
name = "parking_lot_core"
version = "0.9.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bc838d2a56b5b1a6c25f55575dfc605fabb63bb2365f6c2353ef9159aa69e4a5"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall 0.5.17",
 "smallvec",
 "windows-targets 0.52.6",
]

[[package]]
name = "paste"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "57c0d7b74b563b49d38dae00a0c37d4d6de9b432382b2892f0574ddcae73fd0a"

[[package]]
name = "percent-encoding"
version = "2.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b4f627cb1b25917193a259e49bdad08f671f8d9708acfd5fe0a8c1455d87220"

[[package]]
name = "petgraph"
version = "0.8.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "54acf3a685220b533e437e264e4d932cfbdc4cc7ec0cd232ed73c08d03b8a7ca"
dependencies = [
 "fixedbitset",
 "hashbrown",
 "indexmap",
 "serde",
 "serde_derive",
]

[[package]]
name = "phf"
version = "0.11.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd6780a80ae0c52cc120a26a1a42c1ae51b247a253e4e06113d23d2c2edd078"
dependencies = [
 "phf_macros",
 "phf_shared",
]

[[package]]
name = "phf_generator"
version = "0.11.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c80231409c20246a13fddb31776fb942c38553c51e871f8cbd687a4cfb5843d"
dependencies = [
 "phf_shared",
 "rand 0.8.5",
]

[[package]]
name = "phf_macros"
version = "0.11.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f84ac04429c13a7ff43785d75ad27569f2951ce0ffd30a3321230db2fc727216"
dependencies = [
 "phf_generator",
 "phf_shared",
 "proc-macro2",
 "quote",
 "syn",
 "unicase",
]

[[package]]
name = "phf_shared"
version = "0.11.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "67eabc2ef2a60eb7faa00097bd1ffdb5bd28e62bf39990626a582201b7a754e5"
dependencies = [
 "siphasher",
 "unicase",
]

[[package]]
name = "pin-project"
version = "1.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "677f1add503faace112b9f1373e43e9e054bfdd22ff1a63c1bc485eaec6a6a8a"
dependencies = [
 "pin-project-internal",
]

[[package]]
name = "pin-project-internal"
version = "1.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e918e4ff8c4549eb882f14b3a4bc8c8bc93de829416eacf579f1207a8fbf861"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "pin-project-lite"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b3cff922bd51709b605d9ead9aa71031d81447142d828eb4a6eba76fe619f9b"

[[package]]
name = "pin-utils"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"

[[package]]
name = "piper"
version = "0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96c8c490f422ef9a4efd2cb5b42b76c8613d7e7dfc1caf667b8a3350a5acc066"
dependencies = [
 "atomic-waker",
 "fastrand",
 "futures-io",
]

[[package]]
name = "pkg-config"
version = "0.3.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7edddbd0b52d732b21ad9a5fab5c704c14cd949e5e9a1ec5929a24fded1b904c"

[[package]]
name = "png"
version = "0.17.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "82151a2fc869e011c153adc57cf2789ccb8d9906ce52c0b39a6b5697749d7526"
dependencies = [
 "bitflags 1.3.2",
 "crc32fast",
 "fdeflate",
 "flate2",
 "miniz_oxide",
]

[[package]]
name = "polling"
version = "3.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b5bd19146350fe804f7cb2669c851c03d69da628803dab0d98018142aaa5d829"
dependencies = [
 "cfg-if",
 "concurrent-queue",
 "hermit-abi",
 "pin-project-lite",
 "rustix 1.0.8",
 "windows-sys 0.60.2",
]

[[package]]
name = "portable-atomic"
version = "1.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f84267b20a16ea918e43c6a88433c2d54fa145c92a811b5b047ccbe153674483"

[[package]]
name = "potential_utf"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e5a7c30837279ca13e7c867e9e40053bc68740f988cb07f7ca6df43cc734b585"
dependencies = [
 "zerovec",
]

[[package]]
name = "ppv-lite86"
version = "0.2.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85eae3c4ed2f50dcfe72643da4befc30deadb458a9b590d720cde2f2b1e97da9"
dependencies = [
 "zerocopy",
]

[[package]]
name = "presser"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8cf8e6a8aa66ce33f63993ffc4ea4271eb5b0530a9002db8455ea6050c77bfa"

[[package]]
name = "proc-macro-crate"
version = "3.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "edce586971a4dfaa28950c6f18ed55e0406c1ab88bbce2c6f6293a7aaba73d35"
dependencies = [
 "toml_edit",
]

[[package]]
name = "proc-macro2"
version = "1.0.101"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "89ae43fd86e4158d6db51ad8e2b80f313af9cc74f5c0e03ccb87de09998732de"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "proc-macro2-diagnostics"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "af066a9c399a26e020ada66a034357a868728e72cd426f3adcd35f80d88d88c8"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "version_check",
 "yansi",
]

[[package]]
name = "profiling"
version = "1.0.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3eb8486b569e12e2c32ad3e204dbaba5e4b5b216e9367044f25f1dba42341773"

[[package]]
name = "quick-xml"
version = "0.36.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f7649a7b4df05aed9ea7ec6f628c67c9953a43869b8bc50929569b2999d443fe"
dependencies = [
 "memchr",
 "serde",
]

[[package]]
name = "quick-xml"
version = "0.37.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "331e97a1af0bf59823e6eadffe373d7b27f485be8748f71471c662c1f269b7fb"
dependencies = [
 "memchr",
]

[[package]]
name = "quote"
version = "1.0.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "r-efi"
version = "5.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69cdb34c158ceb288df11e18b4bd39de994f6657d83847bdffdbd7f346754b0f"

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "rand_core 0.6.4",
]

[[package]]
name = "rand"
version = "0.9.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6db2770f06117d490610c7488547d543617b21bfa07796d7a12f6f1bd53850d1"
dependencies = [
 "rand_chacha",
 "rand_core 0.9.3",
]

[[package]]
name = "rand_chacha"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3022b5f1df60f26e1ffddd6c66e8aa15de382ae63b3a0c1bfc0e4d3e3f325cb"
dependencies = [
 "ppv-lite86",
 "rand_core 0.9.3",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"

[[package]]
name = "rand_core"
version = "0.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "99d9a13982dcf210057a8a78572b2217b667c3beacbf3a0d8b454f6f82837d38"
dependencies = [
 "getrandom 0.3.3",
]

[[package]]
name = "range-alloc"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3d6831663a5098ea164f89cff59c6284e95f4e3c76ce9848d4529f5ccca9bde"

[[package]]
name = "raw-window-handle"
version = "0.6.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "20675572f6f24e9e76ef639bc5552774ed45f1c30e2951e1e99c59888861c539"

[[package]]
name = "rayon"
version = "1.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b418a60154510ca1a002a752ca9714984e21e4241e804d32555251faf8b78ffa"
dependencies = [
 "either",
 "rayon-core",
]

[[package]]
name = "rayon-core"
version = "1.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22e18b0f0062d30d4230b2e85ff77fdfe4326feb054b9783a3460d8435c8ab91"
dependencies = [
 "crossbeam-deque",
 "crossbeam-utils",
]

[[package]]
name = "redox_syscall"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4722d768eff46b75989dd134e5c353f0d6296e5aaa3132e776cbdb56be7731aa"
dependencies = [
 "bitflags 1.3.2",
]

[[package]]
name = "redox_syscall"
version = "0.5.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5407465600fb0548f1442edf71dd20683c6ed326200ace4b1ef0763521bb3b77"
dependencies = [
 "bitflags 2.9.2",
]

[[package]]
name = "renderdoc-sys"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "19b30a45b0cd0bcca8037f3d0dc3421eaf95327a17cad11964fb8179b4fc4832"

[[package]]
name = "ron"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "beceb6f7bf81c73e73aeef6dd1356d9a1b2b4909e1f0fc3e59b034f9572d7b7f"
dependencies = [
 "base64",
 "bitflags 2.9.2",
 "serde",
 "serde_derive",
 "unicode-ident",
]

[[package]]
name = "rustc-hash"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2"

[[package]]
name = "rustc-hash"
version = "2.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "357703d41365b4b27c590e3ed91eabb1b663f07c4c084095e60cbed4362dff0d"

[[package]]
name = "rustix"
version = "0.38.44"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fdb5bc1ae2baa591800df16c9ca78619bf65c0488b41b96ccec5d11220d8c154"
dependencies = [
 "bitflags 2.9.2",
 "errno",
 "libc",
 "linux-raw-sys 0.4.15",
 "windows-sys 0.59.0",
]

[[package]]
name = "rustix"
version = "1.0.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "11181fbabf243db407ef8df94a6ce0b2f9a733bd8be4ad02b4eda9602296cac8"
dependencies = [
 "bitflags 2.9.2",
 "errno",
 "libc",
 "linux-raw-sys 0.9.4",
 "windows-sys 0.60.2",
]

[[package]]
name = "rustversion"
version = "1.0.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"

[[package]]
name = "same-file"
version = "1.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502"
dependencies = [
 "winapi-util",
]

[[package]]
name = "scoped-tls"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e1cf6437eb19a8f4a6cc0f7dca544973b0b78843adbfeb3683d1a94a0024a294"

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "sctk-adwaita"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6277f0217056f77f1d8f49f2950ac6c278c0d607c45f5ee99328d792ede24ec"
dependencies = [
 "ab_glyph",
 "log",
 "memmap2",
 "smithay-client-toolkit",
 "tiny-skia",
]

[[package]]
name = "serde"
version = "1.0.219"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f0e2c6ed6606019b4e29e69dbaba95b11854410e5347d525002456dbbb786b6"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.219"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b0276cf7f2c73365f7157c8123c21cd9a50fbbd844757af28ca1f5925fc2a00"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "serde_repr"
version = "0.1.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "175ee3e80ae9982737ca543e96133087cbd9a485eecc3bc4de9c1a37b47ea59c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "signal-hook-registry"
version = "1.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b2a4719bff48cee6b39d12c020eeb490953ad2443b7055bd0b21fca26bd8c28b"
dependencies = [
 "libc",
]

[[package]]
name = "simd-adler32"
version = "0.3.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d66dc143e6b11c1eddc06d5c423cfc97062865baf299914ab64caa38182078fe"

[[package]]
name = "siphasher"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56199f7ddabf13fe5074ce809e7d3f42b42ae711800501b5b16ea82ad029c39d"

[[package]]
name = "slab"
version = "0.4.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a2ae44ef20feb57a68b23d846850f861394c2e02dc425a50098ae8c90267589"

[[package]]
name = "slotmap"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dbff4acf519f630b3a3ddcfaea6c06b42174d9a44bc70c620e9ed1649d58b82a"
dependencies = [
 "version_check",
]

[[package]]
name = "smallvec"
version = "1.15.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "67b1b7a3b5fe4f1376887184045fcf45c69e92af734b7aaddc05fb777b6fbd03"

[[package]]
name = "smithay-client-toolkit"
version = "0.19.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3457dea1f0eb631b4034d61d4d8c32074caa6cd1ab2d59f2327bd8461e2c0016"
dependencies = [
 "bitflags 2.9.2",
 "calloop",
 "calloop-wayland-source",
 "cursor-icon",
 "libc",
 "log",
 "memmap2",
 "rustix 0.38.44",
 "thiserror 1.0.69",
 "wayland-backend",
 "wayland-client",
 "wayland-csd-frame",
 "wayland-cursor",
 "wayland-protocols",
 "wayland-protocols-wlr",
 "wayland-scanner",
 "xkeysym",
]

[[package]]
name = "smithay-clipboard"
version = "0.7.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cc8216eec463674a0e90f29e0ae41a4db573ec5b56b1c6c1c71615d249b6d846"
dependencies = [
 "libc",
 "smithay-client-toolkit",
 "wayland-backend",
]

[[package]]
name = "smol_str"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dd538fb6910ac1099850255cf94a94df6551fbdd602454387d0adb2d1ca6dead"
dependencies = [
 "serde",
]

[[package]]
name = "spirv"
version = "0.3.0+sdk-1.3.268.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eda41003dc44290527a59b13432d4a0379379fa074b70174882adfbdfd917844"
dependencies = [
 "bitflags 2.9.2",
]

[[package]]
name = "stable_deref_trait"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3"

[[package]]
name = "static_assertions"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f"

[[package]]
name = "strict-num"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6637bab7722d379c8b41ba849228d680cc12d0a45ba1fa2b48f2a30577a06731"

[[package]]
name = "strum"
version = "0.26.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8fec0f0aef304996cf250b31b5a10dee7980c85da9d759361292b8bca5a18f06"
dependencies = [
 "strum_macros",
]

[[package]]
name = "strum_macros"
version = "0.26.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4c6bee85a5a24955dc440386795aa378cd9cf82acd5f764469152d2270e581be"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "rustversion",
 "syn",
]

[[package]]
name = "syn"
version = "2.0.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ede7c438028d4436d71104916910f5bb611972c5cfd7f89b8300a8186e6fada6"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "synstructure"
version = "0.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "728a70f3dbaf5bab7f0c4b1ac8d7ae5ea60a4b5549c8a5914361c99147a709d2"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tempfile"
version = "3.21.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "15b61f8f20e3a6f7e0649d825294eaf317edce30f82cf6026e7e4cb9222a7d1e"
dependencies = [
 "fastrand",
 "getrandom 0.3.3",
 "once_cell",
 "rustix 1.0.8",
 "windows-sys 0.60.2",
]

[[package]]
name = "termcolor"
version = "1.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06794f8f6c5c898b3275aebefa6b8a1cb24cd2c6c79397ab15774837a0bc5755"
dependencies = [
 "winapi-util",
]

[[package]]
name = "thiserror"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6aaf5339b578ea85b50e080feb250a3e8ae8cfcdff9a461c9ec2904bc923f52"
dependencies = [
 "thiserror-impl 1.0.69",
]

[[package]]
name = "thiserror"
version = "2.0.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3467d614147380f2e4e374161426ff399c91084acd2363eaf549172b3d5e60c0"
dependencies = [
 "thiserror-impl 2.0.16",
]

[[package]]
name = "thiserror-impl"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4fee6c4efc90059e10f81e6d42c60a18f76588c3d74cb83a0b242a2b6c7504c1"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "thiserror-impl"
version = "2.0.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c5e1be1c48b9172ee610da68fd9cd2770e7a4056cb3fc98710ee6906f0c7960"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tiff"
version = "0.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba1310fcea54c6a9a4fd1aad794ecc02c31682f6bfbecdf460bf19533eed1e3e"
dependencies = [
 "flate2",
 "jpeg-decoder",
 "weezl",
]

[[package]]
name = "tiny-skia"
version = "0.11.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "83d13394d44dae3207b52a326c0c85a8bf87f1541f23b0d143811088497b09ab"
dependencies = [
 "arrayref",
 "arrayvec",
 "bytemuck",
 "cfg-if",
 "log",
 "tiny-skia-path",
]

[[package]]
name = "tiny-skia-path"
version = "0.11.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c9e7fc0c2e86a30b117d0462aa261b72b7a99b7ebd7deb3a14ceda95c5bdc93"
dependencies = [
 "arrayref",
 "bytemuck",
 "strict-num",
]

[[package]]
name = "tinystr"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5d4f6d1145dcb577acf783d4e601bc1d76a13337bb54e6233add580b07344c8b"
dependencies = [
 "displaydoc",
 "zerovec",
]

[[package]]
name = "toml_datetime"
version = "0.6.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22cddaf88f4fbc13c51aebbf5f8eceb5c7c5a9da2ac40a13519eb5b0a0e8f11c"

[[package]]
name = "toml_edit"
version = "0.22.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "41fe8c660ae4257887cf66394862d21dbca4a6ddd26f04a3560410406a2f819a"
dependencies = [
 "indexmap",
 "toml_datetime",
 "winnow",
]

[[package]]
name = "tracing"
version = "0.1.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "784e0ac535deb450455cbfa28a6f0df145ea1bb7ae51b821cf5e7927fdcfbdd0"
dependencies = [
 "pin-project-lite",
 "tracing-attributes",
 "tracing-core",
]

[[package]]
name = "tracing-attributes"
version = "0.1.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "81383ab64e72a7a8b8e13130c49e3dab29def6d0c7d76a03087b3cf71c5c6903"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tracing-core"
version = "0.1.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9d12581f227e93f094d3af2ae690a574abb8a2b9b7a96e7cfe9647b2b617678"
dependencies = [
 "once_cell",
]

[[package]]
name = "ttf-parser"
version = "0.25.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d2df906b07856748fa3f6e0ad0cbaa047052d4a7dd609e231c4f72cee8c36f31"

[[package]]
name = "type-map"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cb30dbbd9036155e74adad6812e9898d03ec374946234fbcebd5dfc7b9187b90"
dependencies = [
 "rustc-hash 2.1.1",
]

[[package]]
name = "uds_windows"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "89daebc3e6fd160ac4aa9fc8b3bf71e1f74fbf92367ae71fb83a037e8bf164b9"
dependencies = [
 "memoffset",
 "tempfile",
 "winapi",
]

[[package]]
name = "unicase"
version = "2.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75b844d17643ee918803943289730bec8aac480150456169e647ed0b576ba539"

[[package]]
name = "unicode-ident"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512"

[[package]]
name = "unicode-segmentation"
version = "1.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6ccf251212114b54433ec949fd6a7841275f9ada20dddd2f29e9ceea4501493"

[[package]]
name = "unicode-width"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a1a07cc7db3810833284e8d372ccdc6da29741639ecc70c9ec107df0fa6154c"

[[package]]
name = "url"
version = "2.5.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "137a3c834eaf7139b73688502f3f1141a0337c5d8e4d9b536f9b8c796e26a7c4"
dependencies = [
 "form_urlencoded",
 "idna",
 "percent-encoding",
]

[[package]]
name = "utf8_iter"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6c140620e7ffbb22c2dee59cafe6084a59b5ffc27a8859a5f0d494b5d52b6be"

[[package]]
name = "version_check"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"

[[package]]
name = "walkdir"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "29790946404f91d9c5d06f9874efddea1dc06c5efe94541a7d6863108e3a5e4b"
dependencies = [
 "same-file",
 "winapi-util",
]

[[package]]
name = "wasi"
version = "0.11.1+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ccf3ec651a847eb01de73ccad15eb7d99f80485de043efb2f370cd654f4ea44b"

[[package]]
name = "wasi"
version = "0.14.2+wasi-0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9683f9a5a998d873c0d21fcbe3c083009670149a8fab228644b8bd36b2c48cb3"
dependencies = [
 "wit-bindgen-rt",
]

[[package]]
name = "wasm-bindgen"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1edc8929d7499fc4e8f0be2262a241556cfc54a0bea223790e71446f2aab1ef5"
dependencies = [
 "cfg-if",
 "once_cell",
 "rustversion",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2f0a0651a5c2bc21487bde11ee802ccaf4c51935d0d3d42a6101f98161700bc6"
dependencies = [
 "bumpalo",
 "log",
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-futures"
version = "0.4.50"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "555d470ec0bc3bb57890405e5d4322cc9ea83cebb085523ced7be4144dac1e61"
dependencies = [
 "cfg-if",
 "js-sys",
 "once_cell",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7fe63fc6d09ed3792bd0897b314f53de8e16568c2b3f7982f468c0bf9bd0b407"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ae87ea40c9f689fc23f209965b6fb8a99ad69aeeb0231408be24920604395de"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a05d73b933a847d6cccdda8f838a22ff101ad9bf93e33684f39c1f5f0eece3d"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "wayland-backend"
version = "0.3.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "673a33c33048a5ade91a6b139580fa174e19fb0d23f396dca9fa15f2e1e49b35"
dependencies = [
 "cc",
 "downcast-rs",
 "rustix 1.0.8",
 "scoped-tls",
 "smallvec",
 "wayland-sys",
]

[[package]]
name = "wayland-client"
version = "0.31.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c66a47e840dc20793f2264eb4b3e4ecb4b75d91c0dd4af04b456128e0bdd449d"
dependencies = [
 "bitflags 2.9.2",
 "rustix 1.0.8",
 "wayland-backend",
 "wayland-scanner",
]

[[package]]
name = "wayland-csd-frame"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "625c5029dbd43d25e6aa9615e88b829a5cad13b2819c4ae129fdbb7c31ab4c7e"
dependencies = [
 "bitflags 2.9.2",
 "cursor-icon",
 "wayland-backend",
]

[[package]]
name = "wayland-cursor"
version = "0.31.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "447ccc440a881271b19e9989f75726d60faa09b95b0200a9b7eb5cc47c3eeb29"
dependencies = [
 "rustix 1.0.8",
 "wayland-client",
 "xcursor",
]

[[package]]
name = "wayland-protocols"
version = "0.32.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "efa790ed75fbfd71283bd2521a1cfdc022aabcc28bdcff00851f9e4ae88d9901"
dependencies = [
 "bitflags 2.9.2",
 "wayland-backend",
 "wayland-client",
 "wayland-scanner",
]

[[package]]
name = "wayland-protocols-plasma"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a07a14257c077ab3279987c4f8bb987851bf57081b93710381daea94f2c2c032"
dependencies = [
 "bitflags 2.9.2",
 "wayland-backend",
 "wayland-client",
 "wayland-protocols",
 "wayland-scanner",
]

[[package]]
name = "wayland-protocols-wlr"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "efd94963ed43cf9938a090ca4f7da58eb55325ec8200c3848963e98dc25b78ec"
dependencies = [
 "bitflags 2.9.2",
 "wayland-backend",
 "wayland-client",
 "wayland-protocols",
 "wayland-scanner",
]

[[package]]
name = "wayland-scanner"
version = "0.31.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "54cb1e9dc49da91950bdfd8b848c49330536d9d1fb03d4bfec8cae50caa50ae3"
dependencies = [
 "proc-macro2",
 "quick-xml 0.37.5",
 "quote",
]

[[package]]
name = "wayland-sys"
version = "0.31.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34949b42822155826b41db8e5d0c1be3a2bd296c747577a43a3e6daefc296142"
dependencies = [
 "dlib",
 "log",
 "once_cell",
 "pkg-config",
]

[[package]]
name = "web-sys"
version = "0.3.77"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33b6dd2ef9186f1f2072e409e99cd22a975331a6b3591b12c764e0e55c60d5d2"
dependencies = [
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "web-time"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a6580f308b1fad9207618087a65c04e7a10bc77e02c8e84e9b00dd4b12fa0bb"
dependencies = [
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "webbrowser"
version = "1.0.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aaf4f3c0ba838e82b4e5ccc4157003fb8c324ee24c058470ffb82820becbde98"
dependencies = [
 "core-foundation 0.10.1",
 "jni",
 "log",
 "ndk-context",
 "objc2 0.6.2",
 "objc2-foundation 0.3.1",
 "url",
 "web-sys",
]

[[package]]
name = "weezl"
version = "0.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a751b3277700db47d3e574514de2eced5e54dc8a5436a3bf7a0b248b2cee16f3"

[[package]]
name = "wgpu"
version = "25.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec8fb398f119472be4d80bc3647339f56eb63b2a331f6a3d16e25d8144197dd9"
dependencies = [
 "arrayvec",
 "bitflags 2.9.2",
 "cfg_aliases",
 "document-features",
 "hashbrown",
 "js-sys",
 "log",
 "naga",
 "parking_lot",
 "portable-atomic",
 "profiling",
 "raw-window-handle",
 "smallvec",
 "static_assertions",
 "wasm-bindgen",
 "wasm-bindgen-futures",
 "web-sys",
 "wgpu-core",
 "wgpu-hal",
 "wgpu-types",
]

[[package]]
name = "wgpu-core"
version = "25.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f7b882196f8368511d613c6aeec80655160db6646aebddf8328879a88d54e500"
dependencies = [
 "arrayvec",
 "bit-set",
 "bit-vec",
 "bitflags 2.9.2",
 "cfg_aliases",
 "document-features",
 "hashbrown",
 "indexmap",
 "log",
 "naga",
 "once_cell",
 "parking_lot",
 "portable-atomic",
 "profiling",
 "raw-window-handle",
 "rustc-hash 1.1.0",
 "smallvec",
 "thiserror 2.0.16",
 "wgpu-core-deps-apple",
 "wgpu-core-deps-emscripten",
 "wgpu-core-deps-windows-linux-android",
 "wgpu-hal",
 "wgpu-types",
]

[[package]]
name = "wgpu-core-deps-apple"
version = "25.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cfd488b3239b6b7b185c3b045c39ca6bf8af34467a4c5de4e0b1a564135d093d"
dependencies = [
 "wgpu-hal",
]

[[package]]
name = "wgpu-core-deps-emscripten"
version = "25.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f09ad7aceb3818e52539acc679f049d3475775586f3f4e311c30165cf2c00445"
dependencies = [
 "wgpu-hal",
]

[[package]]
name = "wgpu-core-deps-windows-linux-android"
version = "25.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cba5fb5f7f9c98baa7c889d444f63ace25574833df56f5b817985f641af58e46"
dependencies = [
 "wgpu-hal",
]

[[package]]
name = "wgpu-hal"
version = "25.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f968767fe4d3d33747bbd1473ccd55bf0f6451f55d733b5597e67b5deab4ad17"
dependencies = [
 "android_system_properties",
 "arrayvec",
 "ash",
 "bit-set",
 "bitflags 2.9.2",
 "block",
 "bytemuck",
 "cfg-if",
 "cfg_aliases",
 "core-graphics-types",
 "glow",
 "glutin_wgl_sys",
 "gpu-alloc",
 "gpu-allocator",
 "gpu-descriptor",
 "hashbrown",
 "js-sys",
 "khronos-egl",
 "libc",
 "libloading",
 "log",
 "metal",
 "naga",
 "ndk-sys 0.5.0+25.2.9519653",
 "objc",
 "ordered-float",
 "parking_lot",
 "portable-atomic",
 "profiling",
 "range-alloc",
 "raw-window-handle",
 "renderdoc-sys",
 "smallvec",
 "thiserror 2.0.16",
 "wasm-bindgen",
 "web-sys",
 "wgpu-types",
 "windows 0.58.0",
 "windows-core 0.58.0",
]

[[package]]
name = "wgpu-types"
version = "25.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2aa49460c2a8ee8edba3fca54325540d904dd85b2e086ada762767e17d06e8bc"
dependencies = [
 "bitflags 2.9.2",
 "bytemuck",
 "js-sys",
 "log",
 "thiserror 2.0.16",
 "web-sys",
]

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-util"
version = "0.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0978bf7171b3d90bac376700cb56d606feb40f251a475a5d6634613564460b22"
dependencies = [
 "windows-sys 0.60.2",
]

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows"
version = "0.58.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dd04d41d93c4992d421894c18c8b43496aa748dd4c081bac0dc93eb0489272b6"
dependencies = [
 "windows-core 0.58.0",
 "windows-targets 0.52.6",
]

[[package]]
name = "windows"
version = "0.61.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9babd3a767a4c1aef6900409f85f5d53ce2544ccdfaa86dad48c91782c6d6893"
dependencies = [
 "windows-collections",
 "windows-core 0.61.2",
 "windows-future",
 "windows-link",
 "windows-numerics",
]

[[package]]
name = "windows-collections"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3beeceb5e5cfd9eb1d76b381630e82c4241ccd0d27f1a39ed41b2760b255c5e8"
dependencies = [
 "windows-core 0.61.2",
]

[[package]]
name = "windows-core"
version = "0.58.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6ba6d44ec8c2591c134257ce647b7ea6b20335bf6379a27dac5f1641fcf59f99"
dependencies = [
 "windows-implement 0.58.0",
 "windows-interface 0.58.0",
 "windows-result 0.2.0",
 "windows-strings 0.1.0",
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-core"
version = "0.61.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0fdd3ddb90610c7638aa2b3a3ab2904fb9e5cdbecc643ddb3647212781c4ae3"
dependencies = [
 "windows-implement 0.60.0",
 "windows-interface 0.59.1",
 "windows-link",
 "windows-result 0.3.4",
 "windows-strings 0.4.2",
]

[[package]]
name = "windows-future"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc6a41e98427b19fe4b73c550f060b59fa592d7d686537eebf9385621bfbad8e"
dependencies = [
 "windows-core 0.61.2",
 "windows-link",
 "windows-threading",
]

[[package]]
name = "windows-implement"
version = "0.58.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2bbd5b46c938e506ecbce286b6628a02171d56153ba733b6c741fc627ec9579b"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "windows-implement"
version = "0.60.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "windows-interface"
version = "0.58.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "053c4c462dc91d3b1504c6fe5a726dd15e216ba718e84a0e46a88fbe5ded3515"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "windows-interface"
version = "0.59.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "windows-link"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e6ad25900d524eaabdbbb96d20b4311e1e7ae1699af4fb28c17ae66c80d798a"

[[package]]
name = "windows-numerics"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9150af68066c4c5c07ddc0ce30421554771e528bde427614c61038bc2c92c2b1"
dependencies = [
 "windows-core 0.61.2",
 "windows-link",
]

[[package]]
name = "windows-result"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1d1043d8214f791817bab27572aaa8af63732e11bf84aa21a45a78d6c317ae0e"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-result"
version = "0.3.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56f42bd332cc6c8eac5af113fc0c1fd6a8fd2aa08a0119358686e5160d0586c6"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-strings"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4cd9b125c486025df0eabcb585e62173c6c9eddcec5d117d3b6e8c30e2ee4d10"
dependencies = [
 "windows-result 0.2.0",
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-strings"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56e6c93f3a0c3b36176cb1327a4958a0353d5d166c2a35cb268ace15e91d3b57"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-sys"
version = "0.45.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75283be5efb2831d37ea142365f009c02ec203cd29a3ebecbc093d52315b66d0"
dependencies = [
 "windows-targets 0.42.2",
]

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-sys"
version = "0.60.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2f500e4d28234f72040990ec9d39e3a6b950f9f22d3dba18416c35882612bcb"
dependencies = [
 "windows-targets 0.53.3",
]

[[package]]
name = "windows-targets"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e5180c00cd44c9b1c88adb3693291f1cd93605ded80c250a75d472756b4d071"
dependencies = [
 "windows_aarch64_gnullvm 0.42.2",
 "windows_aarch64_msvc 0.42.2",
 "windows_i686_gnu 0.42.2",
 "windows_i686_msvc 0.42.2",
 "windows_x86_64_gnu 0.42.2",
 "windows_x86_64_gnullvm 0.42.2",
 "windows_x86_64_msvc 0.42.2",
]

[[package]]
name = "windows-targets"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a2fa6e2155d7247be68c096456083145c183cbbbc2764150dda45a87197940c"
dependencies = [
 "windows_aarch64_gnullvm 0.48.5",
 "windows_aarch64_msvc 0.48.5",
 "windows_i686_gnu 0.48.5",
 "windows_i686_msvc 0.48.5",
 "windows_x86_64_gnu 0.48.5",
 "windows_x86_64_gnullvm 0.48.5",
 "windows_x86_64_msvc 0.48.5",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm 0.52.6",
 "windows_aarch64_msvc 0.52.6",
 "windows_i686_gnu 0.52.6",
 "windows_i686_gnullvm 0.52.6",
 "windows_i686_msvc 0.52.6",
 "windows_x86_64_gnu 0.52.6",
 "windows_x86_64_gnullvm 0.52.6",
 "windows_x86_64_msvc 0.52.6",
]

[[package]]
name = "windows-targets"
version = "0.53.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d5fe6031c4041849d7c496a8ded650796e7b6ecc19df1a431c1a363342e5dc91"
dependencies = [
 "windows-link",
 "windows_aarch64_gnullvm 0.53.0",
 "windows_aarch64_msvc 0.53.0",
 "windows_i686_gnu 0.53.0",
 "windows_i686_gnullvm 0.53.0",
 "windows_i686_msvc 0.53.0",
 "windows_x86_64_gnu 0.53.0",
 "windows_x86_64_gnullvm 0.53.0",
 "windows_x86_64_msvc 0.53.0",
]

[[package]]
name = "windows-threading"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b66463ad2e0ea3bbf808b7f1d371311c80e115c0b71d60efc142cafbcfb057a6"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "597a5118570b68bc08d8d59125332c54f1ba9d9adeedeef5b99b02ba2b0698f8"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b38e32f0abccf9987a4e3079dfb67dcd799fb61361e53e2882c3cbaf0d905d8"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "86b8d5f90ddd19cb4a147a5fa63ca848db3df085e25fee3cc10b39b6eebae764"

[[package]]
name = "windows_aarch64_msvc"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e08e8864a60f06ef0d0ff4ba04124db8b0fb3be5776a5cd47641e942e58c4d43"

[[package]]
name = "windows_aarch64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc35310971f3b2dbbf3f0690a219f40e2d9afcf64f9ab7cc1be722937c26b4bc"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_aarch64_msvc"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c7651a1f62a11b8cbd5e0d42526e55f2c99886c77e007179efff86c2b137e66c"

[[package]]
name = "windows_i686_gnu"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c61d927d8da41da96a81f029489353e68739737d3beca43145c8afec9a31a84f"

[[package]]
name = "windows_i686_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a75915e7def60c94dcef72200b9a8e58e5091744960da64ec734a6c6e9b3743e"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnu"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c1dc67659d35f387f5f6c479dc4e28f1d4bb90ddd1a5d3da2e5d97b42d6272c3"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_gnullvm"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ce6ccbdedbf6d6354471319e781c0dfef054c81fbc7cf83f338a4296c0cae11"

[[package]]
name = "windows_i686_msvc"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "44d840b6ec649f480a41c8d80f9c65108b92d89345dd94027bfe06ac444d1060"

[[package]]
name = "windows_i686_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f55c233f70c4b27f66c523580f78f1004e8b5a8b659e05a4eb49d4166cca406"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_i686_msvc"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "581fee95406bb13382d2f65cd4a908ca7b1e4c2f1917f143ba16efe98a589b5d"

[[package]]
name = "windows_x86_64_gnu"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8de912b8b8feb55c064867cf047dda097f92d51efad5b491dfb98f6bbb70cb36"

[[package]]
name = "windows_x86_64_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "53d40abd2583d23e4718fddf1ebec84dbff8381c07cae67ff7768bbf19c6718e"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnu"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2e55b5ac9ea33f2fc1716d1742db15574fd6fc8dadc51caab1c16a3d3b4190ba"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26d41b46a36d453748aedef1486d5c7a85db22e56aff34643984ea85514e94a3"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b7b52767868a23d5bab768e390dc5f5c55825b6d30b86c844ff2dc7414044cc"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0a6e035dd0599267ce1ee132e51c27dd29437f63325753051e71dd9e42406c57"

[[package]]
name = "windows_x86_64_msvc"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9aec5da331524158c6d1a4ac0ab1541149c0b9505fde06423b02f5ef0106b9f0"

[[package]]
name = "windows_x86_64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed94fce61571a4006852b7389a063ab983c02eb1bb37b47f8272ce92d06d9538"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "windows_x86_64_msvc"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "271414315aff87387382ec3d271b52d7ae78726f5d44ac98b4f4030c91880486"

[[package]]
name = "winit"
version = "0.30.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c66d4b9ed69c4009f6321f762d6e61ad8a2389cd431b97cb1e146812e9e6c732"
dependencies = [
 "ahash",
 "android-activity",
 "atomic-waker",
 "bitflags 2.9.2",
 "block2",
 "bytemuck",
 "calloop",
 "cfg_aliases",
 "concurrent-queue",
 "core-foundation 0.9.4",
 "core-graphics",
 "cursor-icon",
 "dpi",
 "js-sys",
 "libc",
 "memmap2",
 "ndk",
 "objc2 0.5.2",
 "objc2-app-kit 0.2.2",
 "objc2-foundation 0.2.2",
 "objc2-ui-kit",
 "orbclient",
 "percent-encoding",
 "pin-project",
 "raw-window-handle",
 "redox_syscall 0.4.1",
 "rustix 0.38.44",
 "sctk-adwaita",
 "smithay-client-toolkit",
 "smol_str",
 "tracing",
 "unicode-segmentation",
 "wasm-bindgen",
 "wasm-bindgen-futures",
 "wayland-backend",
 "wayland-client",
 "wayland-protocols",
 "wayland-protocols-plasma",
 "web-sys",
 "web-time",
 "windows-sys 0.52.0",
 "x11-dl",
 "x11rb",
 "xkbcommon-dl",
]

[[package]]
name = "winnow"
version = "0.7.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f3edebf492c8125044983378ecb5766203ad3b4c2f7a922bd7dd207f6d443e95"
dependencies = [
 "memchr",
]

[[package]]
name = "wit-bindgen-rt"
version = "0.39.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6f42320e61fe2cfd34354ecb597f86f413484a798ba44a8ca1165c58d42da6c1"
dependencies = [
 "bitflags 2.9.2",
]

[[package]]
name = "writeable"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ea2f10b9bb0928dfb1b42b65e1f9e36f7f54dbdf08457afefb38afcdec4fa2bb"

[[package]]
name = "x11-dl"
version = "2.21.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38735924fedd5314a6e548792904ed8c6de6636285cb9fec04d5b1db85c1516f"
dependencies = [
 "libc",
 "once_cell",
 "pkg-config",
]

[[package]]
name = "x11rb"
version = "0.13.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5d91ffca73ee7f68ce055750bf9f6eca0780b8c85eff9bc046a3b0da41755e12"
dependencies = [
 "as-raw-xcb-connection",
 "gethostname",
 "libc",
 "libloading",
 "once_cell",
 "rustix 0.38.44",
 "x11rb-protocol",
]

[[package]]
name = "x11rb-protocol"
version = "0.13.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec107c4503ea0b4a98ef47356329af139c0a4f7750e621cf2973cd3385ebcb3d"

[[package]]
name = "xcursor"
version = "0.3.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bec9e4a500ca8864c5b47b8b482a73d62e4237670e5b5f1d6b9e3cae50f28f2b"

[[package]]
name = "xkbcommon-dl"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d039de8032a9a8856a6be89cea3e5d12fdd82306ab7c94d74e6deab2460651c5"
dependencies = [
 "bitflags 2.9.2",
 "dlib",
 "log",
 "once_cell",
 "xkeysym",
]

[[package]]
name = "xkeysym"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9cc00251562a284751c9973bace760d86c0276c471b4be569fe6b068ee97a56"

[[package]]
name = "xml-rs"
version = "0.8.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6fd8403733700263c6eb89f192880191f1b83e332f7a20371ddcf421c4a337c7"

[[package]]
name = "yansi"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cfe53a6657fd280eaa890a3bc59152892ffa3e30101319d168b781ed6529b049"

[[package]]
name = "yoke"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f41bb01b8226ef4bfd589436a297c53d118f65921786300e427be8d487695cc"
dependencies = [
 "serde",
 "stable_deref_trait",
 "yoke-derive",
 "zerofrom",
]

[[package]]
name = "yoke-derive"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38da3c9736e16c5d3c8c597a9aaa5d1fa565d0532ae05e27c24aa62fb32c0ab6"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "synstructure",
]

[[package]]
name = "zbus"
version = "5.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4bb4f9a464286d42851d18a605f7193b8febaf5b0919d71c6399b7b26e5b0aad"
dependencies = [
 "async-broadcast",
 "async-executor",
 "async-io",
 "async-lock",
 "async-process",
 "async-recursion",
 "async-task",
 "async-trait",
 "blocking",
 "enumflags2",
 "event-listener",
 "futures-core",
 "futures-lite",
 "hex",
 "nix",
 "ordered-stream",
 "serde",
 "serde_repr",
 "tracing",
 "uds_windows",
 "windows-sys 0.59.0",
 "winnow",
 "zbus_macros",
 "zbus_names",
 "zvariant",
]

[[package]]
name = "zbus-lockstep"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "29e96e38ded30eeab90b6ba88cb888d70aef4e7489b6cd212c5e5b5ec38045b6"
dependencies = [
 "zbus_xml",
 "zvariant",
]

[[package]]
name = "zbus-lockstep-macros"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc6821851fa840b708b4cbbaf6241868cabc85a2dc22f426361b0292bfc0b836"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "zbus-lockstep",
 "zbus_xml",
 "zvariant",
]

[[package]]
name = "zbus_macros"
version = "5.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ef9859f68ee0c4ee2e8cde84737c78e3f4c54f946f2a38645d0d4c7a95327659"
dependencies = [
 "proc-macro-crate",
 "proc-macro2",
 "quote",
 "syn",
 "zbus_names",
 "zvariant",
 "zvariant_utils",
]

[[package]]
name = "zbus_names"
version = "4.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7be68e64bf6ce8db94f63e72f0c7eb9a60d733f7e0499e628dfab0f84d6bcb97"
dependencies = [
 "serde",
 "static_assertions",
 "winnow",
 "zvariant",
]

[[package]]
name = "zbus_xml"
version = "5.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589e9a02bfafb9754bb2340a9e3b38f389772684c63d9637e76b1870377bec29"
dependencies = [
 "quick-xml 0.36.2",
 "serde",
 "static_assertions",
 "zbus_names",
 "zvariant",
]

[[package]]
name = "zerocopy"
version = "0.8.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1039dd0d3c310cf05de012d8a39ff557cb0d23087fd44cad61df08fc31907a2f"
dependencies = [
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.8.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ecf5b4cc5364572d7f4c329661bcc82724222973f2cab6f050a4e5c22f75181"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "zerofrom"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "50cc42e0333e05660c3587f3bf9d0478688e15d870fab3346451ce7f8c9fbea5"
dependencies = [
 "zerofrom-derive",
]

[[package]]
name = "zerofrom-derive"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d71e5d6e06ab090c67b5e44993ec16b72dcbaabc526db883a360057678b48502"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "synstructure",
]

[[package]]
name = "zerotrie"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "36f0bbd478583f79edad978b407914f61b2972f5af6fa089686016be8f9af595"
dependencies = [
 "displaydoc",
 "yoke",
 "zerofrom",
]

[[package]]
name = "zerovec"
version = "0.11.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7aa2bd55086f1ab526693ecbe444205da57e25f4489879da80635a46d90e73b"
dependencies = [
 "yoke",
 "zerofrom",
 "zerovec-derive",
]

[[package]]
name = "zerovec-derive"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b96237efa0c878c64bd89c436f661be4e46b2f3eff1ebb976f7ef2321d2f58f"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "zvariant"
version = "5.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d91b3680bb339216abd84714172b5138a4edac677e641ef17e1d8cb1b3ca6e6f"
dependencies = [
 "endi",
 "enumflags2",
 "serde",
 "winnow",
 "zvariant_derive",
 "zvariant_utils",
]

[[package]]
name = "zvariant_derive"
version = "5.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3a8c68501be459a8dbfffbe5d792acdd23b4959940fc87785fb013b32edbc208"
dependencies = [
 "proc-macro-crate",
 "proc-macro2",
 "quote",
 "syn",
 "zvariant_utils",
]

[[package]]
name = "zvariant_utils"
version = "3.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e16edfee43e5d7b553b77872d99bc36afdda75c223ca7ad5e3fbecd82ca5fc34"
dependencies = [
 "proc-macro2",
 "quote",
 "serde",
 "static_assertions",
 "syn",
 "winnow",
]

```

`Cargo.toml`:

```toml
[package]
name = "bin_ast"
version = "0.1.0"
edition = "2021"

[dependencies]
eframe = "0.32.1"
egui = { version = "0.32.1", features = ["accesskit", "rayon"] }
egui_dock = "0.17.0"
egui_extras = "0.32.1"
egui_graphs = "0.28.0"
emath = "0.32.1"
enum-map = "2.7.3"
enumset = "1.1.10"
iced-x86 = "1.21.0"
nodit = "0.9.2"
petgraph = "0.8.2"
rayon = "=1.10.0"

```

`LICENSE-APACHE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

```

`LICENSE-MIT`:

```
MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Ouroboros — A Symbolic-Execution Decompiler

[![Rust](https://img.shields.io/badge/language-Rust-orange?logo=rust)](https://www.rust-lang.org/)
[![License](https://img.shields.io/badge/license-MIT%2FApache-blue.svg)](https://github.com/Hexorg/Ouroboros#license)
[![egui_version](https://img.shields.io/badge/egui-0.32-blue)](https://github.com/emilk/egui)

A fast, research-friendly decompiler built in Rust that recovers high-level structure from binaries using **symbolic execution**, **constraint tracking** instead of single static assignment IR models (though it can ingest SSA IR). It emphasizes block pre/post conditions, register/memory deltas, dominator/post-dominator analysis, and structured reconstruction (if/else, loops, SESE regions).

![Screenshot](assets/screenshot.png)

---

## Features

- **Symbolic Execution Core**  
  Tracks path constraints and symbolic values to recover call arguments, globals, and side effects.

- **Constraint-Tracking SSA IR**  
  VEX-inspired, def-use chains, register/memory deltas, and expression rewriting for clean lifting.

- **CFG + Structural Recovery**  
  Dominators, post-dominators, and SESE discovery to form `if/else`, loops, and early-exit patterns.

- **Calling Convention Inference**  
  Heuristics + dataflow to infer parameter/return passing across common ABIs.

- **Rust-first Performance & Safety**  
  Zero-cost abstractions where possible; explicit, testable passes.

- **Beautiful UI**
  Thanks and a big shoutout to 
  * [egui](https://github.com/emilk/egui) for this beautiful work.
  * [egui_dock](https://github.com/Adanos020/egui_dock) for managing dockable windows like a boss.
  * [egui_graphs](https://github.com/blitzar-tech/egui_graphs) for CFG drawing

---

## Quick Start

### Prerequisites
- **Rust** (stable). Install via <https://rustup.rs/>
- Recommended: `llvm-objdump`, `gdb`, or your favorite disassembler for comparison.

### Build
```bash
git clone https://github.com/Hexorg/Ouroboros.git
cd Ouroboros
cargo build --release
```

## License

Ouroboros is free, open source and permissively licensed! You can choose from 

* MIT License ([LICENSE-MIT](LICENSE-MIT) or [http://opensource.org/licenses/MIT](http://opensource.org/licenses/MIT))
* Apache License, Version 2.0 ([LICENSE-APACHE](LICENSE-APACHE) or [http://www.apache.org/licenses/LICENSE-2.0](http://www.apache.org/licenses/LICENSE-2.0))

at your option.
This means you can select the license you prefer!
```

`src/ir/abstract_syntax_tree.rs`:

```rs
use std::{collections::HashMap, ops::Index};

use iced_x86::Register;

use crate::{ir::{address, basic_block::NextBlock, high_function::CallingConvention, SymbolMap, VariableType}, memory::Memory};

use super::{BasicBlock, Expression, VariableDefinition, Scope, VariableSymbol, HighFunction, ExpressionOp, Address, SingleEntrySingleExit};

type OpIdx = usize;



pub struct AbstractSyntaxTree{
    pub scope: Scope,
    entry:AstStatement,
}

pub enum AstStatement{
    Block(Vec<AstStatement>),
    Nop,
    Function{
        name:String,
        args: Vec<VariableSymbol>,
        body:Box<AstStatement>
    },
    Assignment{
        sese:SingleEntrySingleExit<Address>,
        destination:Expression, 
        value: Expression
    },
    Call{
        sese:SingleEntrySingleExit<Address>,
        destination:Expression, 
        params:Vec<Expression>,
        call_from:Address,
    },
    If{
        sese:SingleEntrySingleExit<Address>, 
        condition:Expression, 
        true_statement:Box<AstStatement>, 
        true_branch:Address,
        else_statement:Box<AstStatement>,
        else_branch:Address,
    },
    Loop{
        sese:SingleEntrySingleExit<Address>,
        condition:Expression,
        body:Box<AstStatement>,
        body_address:Address,
    },
    Return{
        sese:SingleEntrySingleExit<Address>,
        result:Expression,
    },
    Comment(String),
    MultilineComment(String)
}

impl AstStatement {
    pub fn is_nop(&self) -> bool {
        matches!(self, AstStatement::Nop)
    }
}

impl std::fmt::Debug for AstStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AstStatement::Function{..} => f.write_str("AstNode::FunctionHeader"),
            AstStatement::Call{..} => f.write_str("AstNode::Call"),
            AstStatement::Assignment{..} => f.write_str("AstNode::Assignment"),
            AstStatement::If{..} => f.write_str("AstNode::If"),
            AstStatement::Comment(..) => f.write_str("AstNode::Comment"),
            AstStatement::MultilineComment(..) => f.write_str("AstNode::MultilineComment"),
            AstStatement::Loop{..} => f.write_str("AstNode::Loop"),
            AstStatement::Return{..} => f.write_str("AstNode::Return"),
            AstStatement::Block(_) => f.write_str("AstNode::Block"),
            AstStatement::Nop => f.write_str("AstNode::Nop"),
        }
    }
}


impl std::fmt::Debug for AbstractSyntaxTree {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("AbstractSyntaxTree").field("entry", &self.entry).finish()
    }
}

impl AbstractSyntaxTree {
    pub fn new(hf:&HighFunction, mem:&Memory) -> Self {
        let name = mem.symbols.map.get(&hf.cfg.start.0).unwrap();
        let mut scope = Scope::new();
        scope.fill_parents(&hf.pts, hf.pts.root);

        for call_result in &hf.used_call_results {
            if let VariableSymbol::CallResult { call_from, call_to } = call_result {
                if let Some(section) = hf.pts.get_section(*call_from) {
                    let key = VariableSymbol::CallResult { call_from:*call_from, call_to:call_to.clone() };
                    
                    let symbol_name = if let Some(function) = mem.symbols.resolve_exp(call_to) {
                        format!("{}_result", function.name)
                    } else {
                        format!("{key}")
                    };
                    let value = VariableDefinition{
                        kind:VariableType { name: "void *".to_string() },
                        name: symbol_name,
                        variable: key.clone()
                    };
                    scope.add(section, key, value);
                } else {
                    println!("Can't map call from {call_from} to an SESE");
                }
            }
        }

        let body = AstStatement::Block(build_block(&mut scope, hf.cfg.start, hf, hf.pts.root));
        let mut statements = Vec::new();
        statements.push(AstStatement::Comment(format!("Scope:")));
        statements.push(AstStatement::MultilineComment(scope.pretty_print(&hf.pts)));
        statements.push(AstStatement::Comment(format!("*** Memory reads ***")));
        for read in &hf.memory_read {
            statements.push(AstStatement::Comment(format!("{read}")));
        }
        statements.push(AstStatement::Comment(String::new()));
        statements.push(AstStatement::Comment(format!("*** Memory writes ***")));
        for write in &hf.memory_written {
            statements.push(AstStatement::Comment(format!("{write}")));
        }
        let mut args = Vec::new();
        match hf.calling_convention {
            CallingConvention::Cdecl => {
                for addr in &hf.memory_read {
                    if let ExpressionOp::Variable(VariableSymbol::Register(Register::ESP)) = addr.get(0) {
                        if let ExpressionOp::Value(_) = addr.get(1) {
                            if let ExpressionOp::Add(_,_) = addr.get(2) {
                                args.push(VariableSymbol::Ram(addr.clone()));
                            }
                        }
                    }
                }
            }
        }
        statements.push(AstStatement::Function{ name: name.name.clone(), args, body:Box::new(body)});
        Self{
            scope,
            entry: AstStatement::Block(statements),   
        }
    }

    pub fn entry(&self) -> &AstStatement {
        &self.entry
    }

}

fn build_block(scope:&mut Scope, start:Address, hf:&HighFunction, sese:SingleEntrySingleExit<Address>) -> Vec<AstStatement> {
    let mut ast = Vec::new();
    let mut branch_block = add_assignments(&mut ast, hf.composed_blocks.get_at_point(start).unwrap(), hf, sese);

    if branch_block.address == sese.1 {
        return ast
    }
    
    if let Some(pts_children) = hf.pts.get_children(sese) {
        // print
        while let Some(c_pts) = pts_children.iter().find(|p| p.0 == branch_block.address) {
            // child block fails out to the same address as parent block - no need to draw else branch.
            add_program_segment(scope, &mut ast, hf, *c_pts, c_pts.1 == sese.1 && c_pts.1 != Address::NULL);
            if c_pts.1 != Address::NULL {
                branch_block = add_assignments(&mut ast, hf.composed_blocks.get_at_point(c_pts.1).unwrap(), hf, sese);
            }
            if c_pts.1 == sese.1 { 
                break;
            }
        }
    }
    ast
}

fn define_all_variables(scope:&mut Scope, sese:SingleEntrySingleExit<Address>, expression:&Expression, pos:usize) {
    match &expression[pos] {
        ExpressionOp::Dereference(d) => {
                    let variable = VariableSymbol::Ram(expression.get_sub_expression(*d));
                    if scope.get_symbol(sese, &variable).is_none() {
                        scope.add(sese, variable.clone(), VariableDefinition { 
                            kind: VariableType{name:String::from("void *")}, 
                            name: format!("DAT_{variable}"), 
                            variable});
                    }
                },
        ExpressionOp::Variable(variable_symbol) => {
            if scope.get_symbol(sese, variable_symbol).is_none() {
                scope.add(sese, variable_symbol.clone(), VariableDefinition { 
                            kind: VariableType{name:String::from("void *")}, 
                            name: format!("DAT_{variable_symbol}"), 
                            variable:variable_symbol.clone()});
            }
        }
        ExpressionOp::Value(_) |
        ExpressionOp::DestinationRegister(_) => (),
        
        ExpressionOp::Multiequals(l, r) |
        ExpressionOp::Add(l, r) |
        ExpressionOp::Sub(l, r) |
        ExpressionOp::Multiply(l, r) |
        ExpressionOp::LessOrEquals(l, r) |
        ExpressionOp::Less(l, r) |
        ExpressionOp::GreaterOrEquals(l, r) |
        ExpressionOp::Greater(l, r) |
        ExpressionOp::Equals(l, r) |
        ExpressionOp::NotEquals(l, r) |
        ExpressionOp::BitShiftRight(l, r) |
        ExpressionOp::BitShiftLeft(l, r) |
        ExpressionOp::And(l, r) |
        ExpressionOp::Assign(l, r) => {
            define_all_variables(scope, sese, expression, *l);
            define_all_variables(scope, sese, expression, *r);
        }
    }

}

fn add_program_segment(scope:&mut Scope, ast_block:&mut Vec<AstStatement>, hf:&HighFunction, sese:SingleEntrySingleExit<Address>, is_force_drop_else_branch:bool) {
    let branch_block = hf.composed_blocks.get_at_point(sese.0).unwrap();
    if let NextBlock::ConditionalJump { condition, true_branch, false_branch } = &branch_block.next {
        let true_branch_distance_to_return = *hf.cfg.distance_to_return.get(true_branch).unwrap();
        let false_branch_distance_to_return = *hf.cfg.distance_to_return.get(false_branch).unwrap();

        // (true_branch_distance_to_return == 0 && *true_branch != pts.1) ||
        // (false_branch_distance_to_return == 0  && *false_branch != pts.1) ||
        let (first_branch, else_branch, is_loop, condition) = if *false_branch == sese.1  {
            if *true_branch != sese.0 {
                // if (expr) { do work or return };
                (*true_branch, None, false, condition.clone())
            } else {
                // while (expr) { do work };
                (*true_branch, None, true, condition.clone())
            }
        } else if *true_branch == sese.1 {
            let mut condition = condition.clone();
            condition.not();
            if *false_branch != sese.0 {
                // if (!expr) {do work or return };
                (*false_branch, None, false, condition)
            } else {
                // while (expr) { do work };
                (*false_branch, None, true, condition)
            }
        } else {
            // full if statement
            if false_branch_distance_to_return == 0 { // prefer printing return blocks in the if segment.
                let mut condition = condition.clone();
                condition.not();
                (*false_branch, if is_force_drop_else_branch { None } else { Some(*true_branch) }, false, condition.clone())
            } else {
                (*true_branch, if is_force_drop_else_branch { None } else { Some(*false_branch) }, false, condition.clone())
            }
        };
        
        //define_all_variables(scope, sese, &condition, condition.get_entry_point());
        
        let block = build_block(scope, first_branch, hf, sese);
        if let Some(else_branch) = else_branch {
            let false_block = build_block(scope, else_branch, hf, sese);
            if matches!(false_block.last(), Some(AstStatement::Return{..})) {
                // if it's a return block, we don't need to draw else 
                ast_block.push(AstStatement::If{
                    sese,
                    condition:condition, 
                    true_statement:Box::new(AstStatement::Block(block)), 
                    true_branch:first_branch,
                    else_statement:Box::new(AstStatement::Nop),
                    else_branch,
                });
                ast_block.extend(false_block);
            } else {
                ast_block.push(AstStatement::If{
                    sese,
                    condition:condition, 
                    true_statement:Box::new(AstStatement::Block(block)), 
                    true_branch: first_branch,
                    else_statement:Box::new(AstStatement::Block(false_block)),
                    else_branch
                });
            }
        } else if is_loop {
            ast_block.push(AstStatement::Loop{
                sese,
                condition:condition, 
                body:Box::new(AstStatement::Block(block)),
                body_address:first_branch,
            });
        } else {
            ast_block.push(AstStatement::If{
                sese,
                condition:condition, 
                true_statement:Box::new(AstStatement::Block(block)), 
                true_branch: first_branch,
                else_statement:Box::new(AstStatement::Nop),
                else_branch: Address::NULL
            });
        }
        



    } else {
        panic!("Unexpected start of a program segment.")
    }
    // ast_block.push(super::AstStatement::Block(ast.get_entry_point(), count, hf.pts.root));
}









fn add_return(stmts:&mut Vec<AstStatement>, block:&BasicBlock, hf:&HighFunction, sese:SingleEntrySingleExit<Address>) {
    match hf.calling_convention {
        CallingConvention::Cdecl => {
            stmts.push(AstStatement::Return { sese, result: block.get_register_state_or_none(&iced_x86::Register::EAX).unwrap().clone() });
        }
    }
}


fn add_assignments<'a>(stmts:&mut Vec<AstStatement>, block:&'a BasicBlock, hf:&'a HighFunction, sese:SingleEntrySingleExit<Address>) -> &'a BasicBlock {
    if block.address != sese.1 {
        for (ip, value) in &block.instruction_map {
            if let Some(ExpressionOp::Assign(l, r)) = value.last_op() {
                match value[*l] {
                    ExpressionOp::DestinationRegister(_) => (),
                    ExpressionOp::Dereference(d) => {
                        let sub = value.get_sub_expression(d);
                        if sub.iter_vars().find(|p| *p == &VariableSymbol::Register(iced_x86::Register::ESP)).is_none() {
                            let destination = value.get_sub_expression(*l);
                            let value = value.get_sub_expression(*r);
                            stmts.push(AstStatement::Assignment{sese, destination, value});
                            // stmts.push(AstStatement::Assignment{sese, variable:VariableSymbol::Ram(sub), value:state});
                        }
                    }
                    _ => {
                        let destination = value.get_sub_expression(*l);
                        let value = value.get_sub_expression(*r);
                        stmts.push(AstStatement::Assignment{sese, destination, value});
                    }
                }
            }
        }
        match &block.next {
            NextBlock::Call { origin, destination, return_instruction } => {
                add_call(stmts, block, hf, destination, *origin, sese);
                add_assignments(stmts, hf.composed_blocks.get_at_point(*return_instruction).unwrap(), hf, sese)
            },
            NextBlock::Return{..} => {
                add_return(stmts, block, hf, sese);
                block
            }
            NextBlock::Unconditional(addr) => add_assignments(stmts, hf.composed_blocks.get_at_point(*addr).unwrap(), hf, sese),
            _ => block,
        }
    } else {
        block
    }
}

fn add_call(stmts:&mut Vec<AstStatement>, block:&BasicBlock, hf:&HighFunction, destination:&Expression, call_from:Address, sese:SingleEntrySingleExit<Address>) {
    let mut params = Vec::new();
    if let Some(stack) = block.get_register_state_or_none(&iced_x86::Register::ESP) {
        let mut param_1 = stack.clone();
        loop {
            param_1.add_value(4);
            
            if let Some(state) = block.get_memory_state_or_none(&param_1) {
                if let Some(ExpressionOp::Variable(VariableSymbol::Register(_))) = state.last_op() { break; } else {
                    params.push(state.clone())
                }
            } else {
                break;
            }
        }
    }
    stmts.push(AstStatement::Call { destination: destination.clone(), params, call_from, sese});
}
```

`src/ir/address.rs`:

```rs
use std::ops::{Add, Range, Sub};

use nodit::{DiscreteFinite, PointType};
use petgraph::csr::IndexType;


#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct Address(pub u64);

pub struct AddressIterator(Address, Address);

impl std::fmt::Display for Address {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("0x{:x}", self.0))
    }
}

impl std::fmt::Debug for Address {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("0x{:x}", self.0))
    }
}

impl Into<Address> for u64 {
    fn into(self) -> Address {
        Address(self)
    }
}

impl Into<Address> for u32 {
    fn into(self) -> Address {
        Address(self as u64)
    }
}

impl Into<Address> for usize {
    fn into(self) -> Address {
        Address(self as u64)
    }
}

impl Default for Address {
    fn default() -> Self {
        Address::NULL
    }
}

impl Iterator for AddressIterator {
    type Item = Address;

    fn next(&mut self) -> Option<Self::Item> {
        if self.0 != self.1 {
            self.0.0 += 1;
            Some(self.0)
        } else {
            None
        }
    }
}

impl Address {
    pub const NULL:Self = Self(0);

    fn test() {
    let test = 0..10;
    for i in test {

    }
    }
}

impl DiscreteFinite for Address {
    
    const MIN: Self = Address(0);
    
    const MAX: Self = Address(u64::MAX);
    
    fn up(self) -> Option<Self>
        where
            Self: Sized {
        if self != Self::MAX {
            Some(Address(self.0+1))
        } else {
            None
        }
    }
    
    fn down(self) -> Option<Self>
        where
            Self: Sized {
        if self != Self::MIN {
            Some(Address(self.0-1))
        } else {
            None
        }
    } 
}

impl Add for Address {
    type Output = Address;

    fn add(self, rhs: Self) -> Self::Output {
        Address(self.0 + rhs.0)
    }
}

impl Sub for Address {
    type Output = Address;

    fn sub(self, rhs: Self) -> Self::Output {
        Address(self.0 - rhs.0)
    }
}
```

`src/ir/basic_block.rs`:

```rs

use std::{borrow::Cow, collections::HashMap};
use core::hash::Hash;

use nodit::{interval::ie, Interval};

use crate::ir::{high_function::CallingConvention, BlockPathIterator};

use super::{Address, Expression, Register, VariableSymbol, BlockStorage, BlockFunctionIterator, BlockNeighborsIterator};

#[derive(Clone)]
pub enum NextBlock {
    ConditionalJump{
        condition:Expression,
        true_branch:Address,
        false_branch:Address
    },
    Call{
        origin:Address,
        destination:Expression,
        return_instruction:Address,
    },
    Return,
    ReturnDifferentSite(Expression),
    Unconditional(Address)
}

impl Default for NextBlock {
    fn default() -> Self {
        Self::Return
    }
}


/// A basic block is a straight-line sequence of instructions with only one entry point and one exit point.
/// * One entry → control can only enter the block at its first instruction (no jumps into the middle).
/// * One exit → control leaves only at the last instruction.
/// * Inside the block, instructions always execute sequentially, no branching.
#[derive(Clone)]
pub struct BasicBlock {
    /// Start of a block
    pub address:Address,
    /// Non-inclusive address where the block ends
    pub end:Address,
    /// Address of a function that uses this block.
    /// Used in drawing composed data flow in instruction view.
    pub parent_function: Address,
    /// Stores false branch or return destination.
    pub next:NextBlock,
    /// Symbolic state of registers at the end of this block
    pub registers:HashMap<Register, Expression>,
    /// Symbolic state of memory at the end of this block
    pub memory:HashMap<Expression, Expression>,
    /// Constraints on any symbolic expression in `registers` or `memory` 
    /// These are assigned during conditional jump
    pub constraints:Vec<Expression>,
    /// How does each instruction affect IR
    pub instruction_map: HashMap<Address, Expression>,
}

impl Hash for BasicBlock {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.address.hash(state);
    }
}

impl PartialEq for BasicBlock {
    fn eq(&self, other: &Self) -> bool {
        self.address == other.address
    }
}

impl Eq for BasicBlock {}


impl std::fmt::Debug for BasicBlock {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("Block({}-{})", self.address, self.end))
    }
}

impl BasicBlock {
    pub fn new() -> Self {
        Self { 
            registers: HashMap::new(), 
            memory:HashMap::new(), 
            address:Address::default(), 
            parent_function: Address::default(),
            end:Address::default(), 
            next:NextBlock::default(), 
            constraints:Vec::new(), 
            instruction_map: HashMap::new(),
        }
    }

    pub fn get_register_state(&mut self, reg:Register) -> &Expression {
        self.registers.entry(reg).or_insert(Expression::from(VariableSymbol::Register(reg)))
    }

    pub fn get_register_state_or_none(&self, reg:&Register) -> Option<&Expression> {
        self.registers.get(reg)
    }   

    pub fn get_memory_state<E:Into<Expression>>(&mut self, addr:E) -> &Expression {
        let addr = addr.into();
        self.memory.entry(addr.clone()).or_insert(Expression::from(VariableSymbol::Ram(addr)))
    }

    pub fn get_memory_state_or_none<'e, E:Into<&'e Expression>>(&self, addr:E) -> Option<&Expression> {
        let addr = addr.into();
        self.memory.get(addr)
    }

    pub fn set_register_state<E:Into<Expression>>(&mut self, reg:Register, state:E) {
        self.registers.insert(reg, state.into());
    }

    pub fn set_memory_state<E:Into<Expression>>(&mut self, addr:E, state:E) {
        self.memory.insert(addr.into(), state.into());
    }
    pub fn get_interval(&self) -> Interval<Address> {
        ie(self.address, self.end)
    }

    /// Iterate over every block in a function, starting from this one.
    pub fn iter_function<'i>(&'i self, blocks:&'i BlockStorage) -> BlockFunctionIterator<'i> {
        BlockFunctionIterator::new(self, blocks)
    }

    /// Iterate over this block's direct neighbors. 
    pub fn iter_neighbors<'i>(&'i self, blocks:&'i BlockStorage) -> BlockNeighborsIterator<'i> {
        BlockNeighborsIterator::new(self, blocks)
    }

    pub fn iter_path<'i>(&'i self, blocks:&'i BlockStorage) -> BlockPathIterator<'i> {
        BlockPathIterator::new(self, blocks)
    }

    pub fn is_return(&self) -> bool {
        match self.next {
            NextBlock::Return | NextBlock::ReturnDifferentSite(_) => true,
            _ => false
        }
    }

    /// "execute" this block right after `other` - inheriting `other`'s state and modifying our own state as if the execution continued.
    pub fn inherit_state_from(&self, other:&Self) -> Self {
        let mut registers = other.registers.clone();
        // if self.address == Address(0x4b1642) {
        //     println!("I'm {} Inheriting from previous block {}:", self.address, other.address);
        //     for (r, e) in &registers {
        //         println!("\t{r:?} = {e}");
        //     }
        // }
        let mut memory = other.memory.clone();


        

        fn replace<'a>(other:&'a BasicBlock) -> impl Fn(&VariableSymbol) -> Option<Cow<'a, Expression>> {
            |var:&VariableSymbol|
            match var {
                VariableSymbol::Register(r) => other.registers.get(r).and_then(|v| Some(Cow::Borrowed(v))),
                VariableSymbol::CallResult{..} => None,
                VariableSymbol::Ram(d) => {
                    let mut d = d.clone();
                    d.replace_variable_with(replace(other));
                    if let Some(value) = other.memory.get(&d) {
                        Some(Cow::Borrowed(value))
                    } else {
                        println!("Use without def {d}");
                        let e = Expression::from(VariableSymbol::Ram(d));
                        Some(Cow::Owned(e))
                    }
                }
            }
        }
        
        let mut instruction_map = self.instruction_map.clone();
        for (_addr, expression) in instruction_map.iter_mut() {
            expression.replace_variable_with(replace(other));
        }

       

        for (addr, value) in &self.memory {
            let mut addr = addr.clone();
            addr.replace_variable_with(replace(other));
            let mut value = value.clone();
            value.replace_variable_with(replace(other));
            memory.insert(addr, value);
        }

        let mut constraints = other.constraints.clone();
        for c in &self.constraints {
            let mut c = c.clone();
            c.replace_variable_with(replace(other));
            constraints.push(c);
        }

        let next = match &self.next {
            NextBlock::ConditionalJump { condition, true_branch, false_branch } => {
                let mut condition = condition.clone();
                condition.replace_variable_with(replace(other));
                NextBlock::ConditionalJump { condition, true_branch: *true_branch, false_branch: *false_branch }
            },
            NextBlock::Call { origin, destination, return_instruction } => {
                let mut destination = destination.clone();
                destination.replace_variable_with(replace(other));
                NextBlock::Call { origin:*origin, destination, return_instruction:*return_instruction }
            },
            NextBlock::ReturnDifferentSite(expression) => {
                let mut expression = expression.clone();
                expression.replace_variable_with(replace(other));
                NextBlock::ReturnDifferentSite(expression)
            },
            otherwise => otherwise.clone()
        };

        for (r, state) in &self.registers {
            let mut state = state.clone();
            // if we're referencing a register that previous block didn't have (it won't be in registers) then its variable is an unknown anyway
            // and we don't need to replace it with anything.
            state.replace_variable_with(replace(other));
            registers.insert(*r, state);
        }


        Self { 
            address: self.address,
            end: self.end,
            parent_function: self.parent_function,
            next,
            registers,
            memory,
            instruction_map,
            constraints,
        }
    }
}

impl Default for BasicBlock {
    fn default() -> Self {
        Self::new()
    }
}


```

`src/ir/control_flow_graph.rs`:

```rs
use std::{collections::{HashMap, HashSet},  ops::Deref};

use enumset::{EnumSet, EnumSetType};

use crate::ir::{basic_block::NextBlock, Expression};

use super::{Address, BlockStorage};

use petgraph::{algo::{dijkstra, dominators::{simple_fast as build_dominators, Dominators}}, csr::DefaultIx, prelude::{EdgeRef, StableGraph}, visit::{IntoEdgeReferences, IntoNeighbors, IntoNodeReferences}};
use egui_graphs::Graph as EguiGraph;

pub type Graph = petgraph::csr::Csr<Address, LinkKind>;

#[derive(Clone, Copy, Hash, PartialEq, Eq, Debug)]
pub struct SingleEntrySingleExit<N>(pub N, pub N);

#[derive(EnumSetType, Debug)]
pub enum CFGProperties {
    NeverReturns,
    /// If this CFG has multiple RET blocks, all of them are linked to a fake return block at `Address::NULL`
    MultipleReturns
}


#[derive(Clone)]
pub enum LinkKind {
    Calls(Expression),
    TrueBranch(Expression),
    FalseBranch(Expression),
    Unconditional,
    Return,
}

impl std::fmt::Display for LinkKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            LinkKind::Calls(expression) => f.write_fmt(format_args!("Calls {expression}")),
            LinkKind::TrueBranch(expression) => f.write_fmt(format_args!("{expression} is true")),
            LinkKind::FalseBranch(expression) => f.write_fmt(format_args!("{expression} is false")),
            LinkKind::Unconditional => f.write_str(""),
            LinkKind::Return => f.write_str("returns")
        }
    }
}



pub struct ControlFlowGraph{
    pub start:Address,
    pub ends:Vec<Address>,
    graph_map:HashMap<Address, DefaultIx>,
    forward_graph: Graph,
    pub distance_to_return:HashMap<Address, u32>,
    pub properties: EnumSet<CFGProperties>,
    pub dom: Dominators<DefaultIx>,
    pub pdom: Dominators<DefaultIx>,
}

impl Deref for ControlFlowGraph {
    type Target = Graph;

    fn deref(&self) -> &Self::Target {
        &self.forward_graph
    }
}

impl Into<EguiGraph> for &ControlFlowGraph {
    fn into(self) -> EguiGraph {

        let mut g = EguiGraph::new(StableGraph::default());
        let mut graph_map = HashMap::new();
        for (_, &addr) in self.node_references() {
            let idx = g.add_node_with_label((), format!("{addr}"));
            graph_map.insert(addr, idx);
            
        }
        for edge in self.edge_references() {
            let src_addr = self[edge.source()];
            let dst_addr = self[edge.target()];
            let src = graph_map[&src_addr];
            let dst = graph_map[&dst_addr];
            let label = match edge.weight() {
                LinkKind::Calls(expression) => format!("                    Calls {expression}"),
                LinkKind::TrueBranch(expression) => format!("                    {expression} is true"),
                LinkKind::FalseBranch(expression) => format!("                    {expression} is false"),
                LinkKind::Unconditional => String::new(),
                LinkKind::Return => String::from("returns"),
            };
            g.add_edge_with_label(src, dst, (), label);
        }
        g
    }
}

/// Check if `start` is an ancestor of `find` in a `tree`
pub fn is_ancestor<N>(start:N, find:N, dom:&Dominators<N>) -> bool 
where N: Copy + Eq + std::hash::Hash {
    if start == find {
        return true
    }
    let mut all = false;
    for leaf in dom.immediately_dominated_by(start) {
        // for leaf in nbrs {
            if leaf == find {
                return true
            } else {
                all |= is_ancestor(leaf, find, dom);
            }
        }
        all
}

pub fn preorder<N>(dom:&Dominators<N>, root:N) -> HashMap<N, usize> 
where N: Copy + Eq + std::hash::Hash
{
    let mut result = HashMap::new();
    let mut order = 0;
    let mut stack = vec![root];
    while let Some(node) = stack.pop() {
        result.insert(node, order);
        order += 1;
        for nbr in dom.immediately_dominated_by(node) {
            if !result.contains_key(&nbr) {
                stack.push(nbr);
            }
        }
    }
    result
}

pub fn find_path(a:DefaultIx, tree_root:DefaultIx, dom:&Dominators<DefaultIx>) -> Vec<DefaultIx> {
    // if let Some(iterator) =  {
        for nbr in dom.immediately_dominated_by(tree_root) {
            if nbr == a {
                return vec![a]
            } else {
                let mut path = find_path(a, nbr, dom);
                if path.len() > 0 {
                    path.push(nbr);
                    return path
                }
            }
        }
    // } 
    Vec::new()
}


pub fn least_common_ancestor(u:DefaultIx, v: DefaultIx, tree_root:DefaultIx, tree:&Dominators<DefaultIx>) -> Option<DefaultIx> {
    // TODO: Faster methods exist https://en.wikipedia.org/wiki/Lowest_common_ancestor
    let mut path_to_u = find_path(u, tree_root, tree);
    path_to_u.push(tree_root);
    let mut path_to_v = find_path(v, tree_root, tree);
    path_to_v.push(tree_root);
    path_to_u.reverse();
    path_to_v.reverse();
    let max_pos = path_to_u.len().min(path_to_v.len());
    for idx in 0..max_pos {
        if path_to_u[idx] != path_to_v[idx] {
            if idx > 0 {
                return Some(path_to_u[idx - 1])
            } else {
                return None
            }
        }
    }
    Some(path_to_u[max_pos-1])
}

pub fn is_reachable(graph:&Graph, start:DefaultIx, target:DefaultIx) -> bool {
    let mut stack = vec![start];
    let mut visited = HashSet::new();
    while let Some(current) = stack.pop() {
        if !visited.contains(&current) {
            for nbr in graph.neighbors(current) {
                if nbr == target {
                    return true;
                }
                visited.insert(nbr);
            }
        }
    }
    false
}

impl ControlFlowGraph {
    pub fn new(start:Address, blocks:&BlockStorage) -> Self {
        let mut graph_map: HashMap<Address, DefaultIx> = HashMap::new();
        let mut ends = Vec::new();
        let mut forward_graph:Graph = Graph::new();
        let mut backward_graph:Graph = Graph::new();

        for block in blocks.get_at_point(start).expect("No IR at address").iter_function(blocks) {
            let node_index = *graph_map.entry(block.address).or_insert_with(|| {forward_graph.add_node(block.address); backward_graph.add_node(block.address)});
            graph_map.insert(block.address, node_index);

            if block.is_return() {
                ends.push(block.address);
            }
            
            for nbr in block.iter_neighbors(blocks) {
                let link_kind = match &block.next {
                    NextBlock::Call { destination, .. } => LinkKind::Calls(destination.clone()),
                    NextBlock::ConditionalJump { condition, true_branch, .. } => if nbr.address == *true_branch {
                        LinkKind::TrueBranch(condition.clone())
                    } else {
                        LinkKind::FalseBranch(condition.clone())
                    },
                    NextBlock::Return | NextBlock::ReturnDifferentSite(_) => LinkKind::Return,
                    NextBlock::Unconditional(_) => LinkKind::Unconditional
                };

                let nbr_index = *graph_map.entry(nbr.address).or_insert_with(|| {forward_graph.add_node(nbr.address); backward_graph.add_node(nbr.address)});
                forward_graph.add_edge(node_index, nbr_index, link_kind.clone());
                backward_graph.add_edge(nbr_index, node_index, link_kind);
            }
        }

        
        let mut properties = EnumSet::new();
        let mut pdom_end = Address::NULL;
        if ends.len() == 0 {
            properties.insert(CFGProperties::NeverReturns);
        } else if ends.len() > 1 {
            properties.insert(CFGProperties::MultipleReturns);
            forward_graph.add_node(pdom_end);
            let return_node = backward_graph.add_node(Address::NULL);
            graph_map.insert(pdom_end, return_node);
            for end in &ends {
                // edges.push((end.0, 0));
                forward_graph.add_edge(*graph_map.get(end).unwrap(), return_node, LinkKind::Return);
                backward_graph.add_edge(return_node, *graph_map.get(end).unwrap(), LinkKind::Return);
            }
        } else {
            pdom_end = ends[0];
        }

        let distance_to_return = dijkstra(&backward_graph, *graph_map.get(&pdom_end).unwrap(), None, |e| {
            match e.weight() {
                LinkKind::Calls(_) |
                LinkKind::Return |
                LinkKind::Unconditional => 0,
                LinkKind::TrueBranch(_) |
                LinkKind::FalseBranch(_) => 1,
            }
        }).iter().map(|(k, v)| (backward_graph[*k], *v)).collect::<HashMap<Address, u32>>();
        

        let dom = build_dominators(&forward_graph, *graph_map.get(&start).unwrap());
        let pdom = build_dominators(&backward_graph, *graph_map.get(&pdom_end).unwrap());

        ControlFlowGraph{
            start, 
            ends, 
            graph_map,
            forward_graph,
            distance_to_return,
            properties, 
            dom,
            pdom,
        }
    }

    pub fn single_end(&self) -> Address {
        if self.properties.contains(CFGProperties::MultipleReturns) {
            Address(0)
        } else {
            // TODO: Handle functions that don't return.
            self.ends[0]
        }
    }

    pub fn get_node_idx(&self, addr:Address) -> DefaultIx {
        self.graph_map[&addr]
    }

}


mod test {
    use petgraph::{algo::dominators::simple_fast, csr::DefaultIx};
    
    use crate::ir::least_common_ancestor;

    use super::{Address, Graph};


    /// Graph from [Wikipedia](https://en.wikipedia.org/wiki/Dominator_(graph_theory))
    /// ```
    ///    0
    ///    |
    ///  /--1----\
    ///  |  | \   5
    ///  2  3  ^
    ///   \ | /
    ///     4
    /// ```
    /// Returns (start, end, forward_graph, reverse_graph)
    fn wiki_graph() -> (DefaultIx, DefaultIx, Graph, Graph) {
        let edges = Vec::from([(0, 1), (1, 2), (1, 3), (1, 5), (2, 4), (3, 4), (4, 1)]);
        let mut graph = Graph::new();
        let mut pgraph = Graph::new();
        for _ in 0..6 { graph.add_node(Address::NULL); pgraph.add_node(Address::NULL); }
        for (a, b) in edges {
            graph.add_edge(a, b, super::LinkKind::Return);
            pgraph.add_edge(b, a, super::LinkKind::Return);
        }
        (
            0,
            5,
            graph,
            pgraph
        )
    }

    /// ```
    /// 0
    /// |
    /// 1 --\
    /// |    3--\
    /// 2-\  |  7
    /// | |  6  | 
    /// 4 5   \ |
    /// | /     9
    /// 8      /
    ///  \    /
    ///    \ /
    ///     10
    /// ```
    /// Returns (start, end, forward_graph, reverse_graph)
    fn complex_graph() -> (DefaultIx, DefaultIx, Graph, Graph) {
        let edges = Vec::from([(0, 1), (1, 2), (2, 4), (2, 5), (4, 8), (5, 8), (1, 3), (3, 6), (3, 7), (6, 9), (7, 9), (8, 10), (9, 10)]);
        let mut graph = Graph::new();
        let mut pgraph = Graph::new();
        for _ in 0..11 { graph.add_node(Address::NULL); pgraph.add_node(Address::NULL); }
        for (a, b) in edges {
            graph.add_edge(a, b, super::LinkKind::Return);
            pgraph.add_edge(b, a, super::LinkKind::Return);
        }
        (
            0,
            10,
            graph,
            pgraph
        )
    }


    #[test]
    fn test_lca() {
        let (start, end, graph, pgraph) = wiki_graph();

        let dom = simple_fast(&graph, start);
        let pdom = simple_fast(&pgraph, end);

        println!("{dom:?}");

        let addr = least_common_ancestor(2, 3, start, &dom);
        assert_eq!(addr, Some(1));

        let addr = least_common_ancestor(2, 3, end, &pdom);
        assert_eq!(addr, Some(4));
    }

    // #[test]
    // fn test_sese_pairs() {
    //     let (start, end, graph, pgraph) = complex_graph();

    //     let dom = build_dominators(&graph, start);
    //     let pdom = build_dominators(&pgraph, end);

    //     println!("DOM: {dom:?}");

    //     let seses = make_sese_pairs(&dom, &pdom, &graph, start, end);
    //     for sese in &seses {
    //         println!("{sese:?}");
    //     }
    //     assert_eq!(seses, Vec::from([
    //         // SingleEntrySingleExit(0, 10),
    //         SingleEntrySingleExit(1, 10),
    //         SingleEntrySingleExit(2, 8),
    //         SingleEntrySingleExit(3, 9),
    //         ]))
    // }

    // #[test]
    // fn test_sese_pairs_wiki() {
    //     let (start, end, graph, pgraph) = wiki_graph();

    //     let dom = build_dominators(&graph, start);
    //     let pdom = build_dominators(&pgraph, end);

    //     let seses = make_sese_pairs(&dom, &pdom, &graph, start, end);
    //     assert_eq!(seses, Vec::from([
    //         SingleEntrySingleExit(1, 5),
    //         SingleEntrySingleExit(1, 4),
    //         ]))
    // }
}
```

`src/ir/expression.rs`:

```rs
use std::{borrow::Cow, collections::HashMap, ops::Index};

use iced_x86::Register;


use super::{Address, BlockStorage};


/// SLEIGH defines serveral "Memory Spaces", though usually it uses Memory, Register, and Unique.
/// We too define several memory spaces but in a different way. Eventually I'd like to express overlapping memory spaces
/// E.g. AL is byte of RAX. Or this call is stored on stack at Ram 0xXXX
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum VariableSymbol{
    Register(Register),
    CallResult{
        call_from:Address,
        call_to:Expression,
    },
    Ram(Expression),
}

impl std::fmt::Debug for VariableSymbol {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Register(arg0) => f.write_fmt(format_args!("?{arg0:?}")),
            Self::CallResult{call_to,..} => f.write_fmt(format_args!("call_{call_to:?}_result")),
            Self::Ram(arg0) => f.write_fmt(format_args!("[{arg0:?}]")),
        }
    }
}

impl std::fmt::Display for VariableSymbol {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Register(arg0) => f.write_fmt(format_args!("?{arg0:?}")),
            Self::CallResult{call_to,..} => f.write_fmt(format_args!("call_{call_to}_result")),
            Self::Ram(arg0) => f.write_fmt(format_args!("{arg0}")),
        }
    }
}

impl VariableSymbol {
    pub fn is_above_stack_frame(&self) -> Option<bool> {
        if let Self::Ram(r) = self {
            let result = r.assume(Register::ESP, 0);
            if let Some(ExpressionOp::Value(v)) = result.last_op() {
                return Some(*v > 0)
            } 
        } 
        None
    }

    pub fn get_memory_address_or_null(&self) -> u64 {
        match self {
            VariableSymbol::Register(_) |
            VariableSymbol::CallResult{..} => 0,
            VariableSymbol::Ram(expression) => expression.get_memory_address_or_null(),
        }
    }
}

impl Index<OpIdx> for Expression {
    type Output = ExpressionOp;

    fn index(&self, index: OpIdx) -> &Self::Output {
        self.0.index(index)
    }
}


/// Basic building block of any code. This expression can be symbolic
/// (one of the [`ExpressionOp`] variants is a [`VariableSymbol`]).
/// Stores first operation to do as the last element of the vector - 
/// `Expression::get_entry_point()` returns the index to the last element.
/// 
/// Implements smart in-place patching routines which perform common algebra operations
/// as soon as those operations are added - e.g. stores `?ESP+8` instead of `?ESP+4+4`
/// This approach checks only last operation - `?ESP+4+?EBP+4` will not be simplified,
/// though that can be a nice addition.
/// 
/// `std::fmt::Display` trait prints the expression recursively, e.g. `[?ESP+4]`
/// while `std::fmt::Debug` trait prints the list of [`ExpressionOp`], e.g. `[Variable(ESP), Value(4), Add(0, 1), Dereference(2)]`
#[derive(Clone, PartialEq, Eq, Hash, Default)]
pub struct Expression(Vec<ExpressionOp>);
type OpIdx = usize;

impl From<i64> for Expression {
    fn from(value: i64) -> Self {
        Self(vec![ExpressionOp::Value(value)])
    }
}

impl From<VariableSymbol> for Expression {
    fn from(variable: VariableSymbol) -> Self {
        Self(vec![ExpressionOp::Variable(variable)])
    }
}

impl From<Vec<ExpressionOp>> for Expression {
    fn from(value: Vec<ExpressionOp>) -> Self {
        Self(value)
    }
}

impl From<Register> for Expression {
    fn from(register: Register) -> Self {
        Self(vec![ExpressionOp::DestinationRegister(register)])
    }
}
impl From<ExpressionOp> for Expression {
    fn from(op: ExpressionOp) -> Self {
        Self(vec![op])
    }
}


fn remap_operands<T>(src:&[ExpressionOp], pos:OpIdx, vec:&mut Vec<ExpressionOp>, mut map:T)
where T:Copy + FnMut(&ExpressionOp, &[ExpressionOp]) -> ExpressionOp {
    match &src[pos] {
        e @ ExpressionOp::Variable(_) |
        e @ ExpressionOp::DestinationRegister(_) |
        e @ ExpressionOp::Value(_) => vec.push(map(e, vec)),
        e @ ExpressionOp::Dereference(p) => {
            remap_operands(src, *p, vec, map);
            vec.push(ExpressionOp::Dereference(vec.len() - 1));
        },
        ExpressionOp::Assign(l, r) => {
            remap_operands(src, *l, vec, map);
            let l = vec.len() - 1;
            remap_operands(src, *r, vec, map);
            let r = vec.len() - 1;
            vec.push(ExpressionOp::Assign(l, r));
        },
        ExpressionOp::Multiequals(l, r) => {
            remap_operands(src, *l, vec, map);
            let l = vec.len() - 1;
            remap_operands(src, *r, vec, map);
            let r = vec.len() - 1;
            vec.push(ExpressionOp::Multiequals(l, r));
        },
        ExpressionOp::Add(l, r) => {
            remap_operands(src, *l, vec, map);
            let l = vec.len() - 1;
            remap_operands(src, *r, vec, map);
            let r = vec.len() - 1;
            vec.push(ExpressionOp::Add(l, r));
        },
        ExpressionOp::Sub(l, r) => {
            remap_operands(src, *l, vec, map);
            let l = vec.len() - 1;
            remap_operands(src, *r, vec, map);
            let r = vec.len() - 1;
            vec.push(ExpressionOp::Sub(l, r));
        },
        ExpressionOp::Multiply(l, r) => {
            remap_operands(src, *l, vec, map);
            let l = vec.len() - 1;
            remap_operands(src, *r, vec, map);
            let r = vec.len() - 1;
            vec.push(ExpressionOp::Multiply(l, r));
        },
        ExpressionOp::LessOrEquals(l, r) => {
            remap_operands(src, *l, vec, map);
            let l = vec.len() - 1;
            remap_operands(src, *r, vec, map);
            let r = vec.len() - 1;
            vec.push(ExpressionOp::LessOrEquals(l, r));
        },
        ExpressionOp::Less(l, r) => {
            remap_operands(src, *l, vec, map);
            let l = vec.len() - 1;
            remap_operands(src, *r, vec, map);
            let r = vec.len() - 1;
            vec.push(ExpressionOp::Less(l, r));
        },
        ExpressionOp::GreaterOrEquals(l, r) => {
            remap_operands(src, *l, vec, map);
            let l = vec.len() - 1;
            remap_operands(src, *r, vec, map);
            let r = vec.len() - 1;
            vec.push(ExpressionOp::GreaterOrEquals(l, r));
        },
        ExpressionOp::Greater(l, r) => {
            remap_operands(src, *l, vec, map);
            let l = vec.len() - 1;
            remap_operands(src, *r, vec, map);
            let r = vec.len() - 1;
            vec.push(ExpressionOp::Greater(l, r));
        },
        ExpressionOp::Equals(l, r) => {
            remap_operands(src, *l, vec, map);
            let l = vec.len() - 1;
            remap_operands(src, *r, vec, map);
            let r = vec.len() - 1;
            vec.push(ExpressionOp::Equals(l, r));
        },
        ExpressionOp::NotEquals(l, r) => {
            remap_operands(src, *l, vec, map);
            let l = vec.len() - 1;
            remap_operands(src, *r, vec, map);
            let r = vec.len() - 1;
            vec.push(ExpressionOp::NotEquals(l, r));
        },
        ExpressionOp::BitShiftRight(l, r) => {
            remap_operands(src, *l, vec, map);
            let l = vec.len() - 1;
            remap_operands(src, *r, vec, map);
            let r = vec.len() - 1;
            vec.push(ExpressionOp::BitShiftRight(l, r));
        },
        ExpressionOp::BitShiftLeft(l, r) => {
            remap_operands(src, *l, vec, map);
            let l = vec.len() - 1;
            remap_operands(src, *r, vec, map);
            let r = vec.len() - 1;
            vec.push(ExpressionOp::BitShiftLeft(l, r));
        },
        ExpressionOp::And(l, r) => {
            remap_operands(src, *l, vec, map);
            let l = vec.len() - 1;
            remap_operands(src, *r, vec, map);
            let r = vec.len() - 1;
            vec.push(ExpressionOp::And(l, r));
        },
    }
}

impl Expression {
    pub fn new() -> Self {
        Self(Vec::new())
    }

    pub fn last_op(&self) -> Option<&ExpressionOp> {
        self.0.last()
    }

    pub fn get(&self, idx:OpIdx) -> &ExpressionOp {
        &self.0[idx]
    }

    pub fn iter<'a>(&'a self) -> std::slice::Iter<'a, ExpressionOp> {
        self.0.iter() 
    }

    pub fn get_sub_expression(&self, idx:OpIdx) -> Expression {
        let mut result = Expression::new();
        remap_operands(&self.0, idx, &mut result.0, 
            |e, _| e.clone());
        result
    }

    pub fn multiply(&mut self, other:&Self) {
        if other.0.len() == 1 {
            if let ExpressionOp::Value(v) = other.0[0] {
                self.multiply_value(v);
                return
            }
        }
        let left = self.get_entry_point();
        self.copy_other_to_end(&other.0);
        let right = self.get_entry_point();
        self.0.push(ExpressionOp::Multiply(left, right))
    }

    pub fn add(&mut self, other:&Self) {
        if other.0.len() == 1 {
            if let ExpressionOp::Value(v) = other.0[0] {
                self.add_value(v);
                return
            }
        }
        let left = self.get_entry_point();
        self.copy_other_to_end(&other.0);
        let right = self.get_entry_point();
        self.0.push(ExpressionOp::Add(left, right))
    }

    pub fn sub(&mut self, other:&Self) {
        if other.0.len() == 1 {
            if let ExpressionOp::Value(v) = other.0[0] {
                self.sub_value(v);
                return
            }
        }
        let left = self.get_entry_point();
        self.copy_other_to_end(&other.0);
        let right = self.get_entry_point();
        self.0.push(ExpressionOp::Sub(left, right))
    }

    pub fn add_value(&mut self, value:i64) {
        let expr = self.get_entry_point();
        self.add_value_at(expr, value);
    }

    /// Returns how many instructions have been added to `self.0`
    fn add_value_at(&mut self, expr:OpIdx, value:i64) -> usize {
        use ExpressionOp::*;
        if value == 0 {
            return 0;
        }
        match self.0[expr] {
            Add(l, r) => {
                if let Value(v) = &mut self.0[r] {
                    *v += value;
                    if *v < 0 {
                        *v = -*v;
                        self.0[expr] = Sub(l, r);
                    }
                } else if let Value(v) = &mut self.0[l] {
                    *v += value;
                }
                0
            },
            Sub(l, r) => {
                if let Value(v) = &mut self.0[r] {
                    *v -= value;
                    if *v < 0 {
                        *v = -*v;
                        self.0[expr] = Add(l, r);
                    }
                } else if let Value(v) = &mut self.0[l] {
                    *v += value;
                }
                0
            },
            Value(v) => {
                self.0[expr] = Value(v + value);
                0
            }
            _ => {
                self.0.push(ExpressionOp::Value(value));
                let pos = self.get_entry_point();
                self.0.push(ExpressionOp::Add(expr, pos));
                2
            }
        }
    }

    pub fn sub_value(&mut self, value:i64) {
        let expr = self.get_entry_point();
        self.sub_value_at(expr, value, false);
    }

    fn sub_value_at(&mut self, expr:OpIdx, value:i64, is_invert:bool) -> usize {
        use ExpressionOp::*;
        if value == 0 {
            return 0;
        }
        match self.0[expr] {
            Add(l, r) => {
                if let Value(v) = &mut self.0[r] {
                    *v -= value;
                    if *v < 0 {
                        *v = -*v;
                        self.0[expr] = Sub(l, r);
                    }
                } else if let Value(v) = &mut self.0[l] {
                    *v -= value;
                }
                0
            },
            Sub(l, r) => {
                if let Value(v) = &mut self.0[r] {
                    *v += value;
                    if *v < 0 {
                        *v = -*v;
                        self.0[expr] = Add(l, r);
                    }
                } else if let Value(v) = &mut self.0[l] {
                    *v -= value;
                }
                0
            },
            Value(v) => {
                self.0[expr] = Value(v - value);
                0
            }
            _ => {
                self.0.push(ExpressionOp::Value(value));
                let pos = self.get_entry_point();
                if is_invert {
                    self.0.push(ExpressionOp::Sub(pos, expr));
                } else {
                    self.0.push(ExpressionOp::Sub(expr, pos));
                }
                2
            }
        }
    }

    pub fn multiply_value(&mut self, value:i64) {
        let expr = self.get_entry_point();
        self.multiply_value_at(expr, value);
    }

    fn multiply_value_at(&mut self, expr:OpIdx, value:i64) -> usize{
        use ExpressionOp::*;
        if value == 1 {
            return 0;
        }
        match self.0[expr] {
            Multiply(l, r) => {
                if let Value(v) = &mut self.0[r] {
                    *v *= value;
                } else if let Value(v) = &mut self.0[l] {
                    *v *= value;
                }
                0
            },
            Value(v) => {
                self.0[expr] = Value(v * value);
                0
            }
            _ => {
                self.0.push(ExpressionOp::Value(value));
                let pos = self.get_entry_point();
                self.0.push(ExpressionOp::Multiply(expr, pos));
                2
            }
        }
    }

    pub fn dereference(&mut self) {
        let val = self.get_entry_point();
        self.0.push(ExpressionOp::Dereference(val));
    }

    pub fn bit_shift_right(&mut self, value:i64) {
        let val = self.get_entry_point();
        self.0.push(ExpressionOp::Value(value));
        self.0.push(ExpressionOp::BitShiftRight(val, val+1));
    }

    pub fn bit_shift_left(&mut self, value:i64) {
        let val = self.get_entry_point();
        self.0.push(ExpressionOp::Value(value));
        self.0.push(ExpressionOp::BitShiftLeft(val, val+1));
    }

    pub fn and(&mut self, value:i64) {
        let val = self.get_entry_point();
        self.0.push(ExpressionOp::Value(value));
        self.0.push(ExpressionOp::And(val, val+1));
    }

    pub fn cancel_dereference(&mut self) {
        assert!(matches!(self.0.pop(), Some(ExpressionOp::Dereference(_))));
    }

    pub fn assign(&mut self, other:&Self) {
        let left = self.get_entry_point();
        self.copy_other_to_end(&other.0);
        let right = self.get_entry_point();
        self.0.push(ExpressionOp::Assign(left, right))
    }

    pub fn multiequals(&mut self, other:&Self) {
        let left = self.get_entry_point();
        self.copy_other_to_end(&other.0);
        let right = self.get_entry_point();
        self.0.push(ExpressionOp::Multiequals(left, right))
    }

    pub fn assign_value(&mut self, value:i64) {
        let left = self.get_entry_point();
        self.0.push(ExpressionOp::Value(value));
        self.0.push(ExpressionOp::Assign(left, left+1))
    }

    pub fn check_equals_value(&mut self, value:i64) {
        self.add_value(value);
        let left = self.get_entry_point();
        match self.0[left] {
            ExpressionOp::Sub(l, r) => {
                self.0[left] = ExpressionOp::Equals(l, r)
            },
            _ => {
                self.0.push(ExpressionOp::Value(value));
                self.0.push(ExpressionOp::Equals(left, left+1))
            }
        }
    }

    pub fn check_not_equals_value(&mut self, value:i64) {
        self.add_value(value);
        let left = self.get_entry_point();
        match self.0[left] {
            ExpressionOp::Sub(l, r) => {
                self.0[left] = ExpressionOp::NotEquals(l, r)
            },
            _ => {
                self.0.push(ExpressionOp::Value(value));
                self.0.push(ExpressionOp::NotEquals(left, left+1))
            }
        }
    }

    pub fn check_less_value(&mut self, value:i64) {
        self.add_value(value);
        let left = self.get_entry_point();
        match self.0[left] {
            ExpressionOp::Sub(l, r) => {
                self.0[left] = ExpressionOp::GreaterOrEquals(l, r)
            },
            _ => {
                self.0.push(ExpressionOp::Value(value));
                self.0.push(ExpressionOp::Less(left, left+1))
            }
        }
    }

    pub fn check_greater_value(&mut self, value:i64) {
        self.add_value(value);
        let left = self.get_entry_point();
        match self.0[left] {
            ExpressionOp::Sub(l, r) => {
                self.0[left] = ExpressionOp::LessOrEquals(l, r)
            },
            _ => {
                self.0.push(ExpressionOp::Value(value));
                self.0.push(ExpressionOp::Greater(left, left+1))
            }
        }
    }

    pub fn check_less_or_equals_value(&mut self, value:i64) {
        self.add_value(value);
        let left = self.get_entry_point();
        match self.0[left] {
            ExpressionOp::Sub(l, r) => {
                self.0[left] = ExpressionOp::Greater(l, r)
            },
            _ => {
                self.0.push(ExpressionOp::Value(value));
                self.0.push(ExpressionOp::LessOrEquals(left, left+1))
            }
        }
    }

    pub fn check_greater_or_equals_value(&mut self, value:i64) {
        self.add_value(value);
        let left = self.get_entry_point();
        match self.0[left] {
            ExpressionOp::Sub(l, r) => {
                self.0[left] = ExpressionOp::Less(l, r)
            },
            _ => {
                self.0.push(ExpressionOp::Value(value));
                self.0.push(ExpressionOp::GreaterOrEquals(left, left+1))
            }
        }
    }

    pub fn not(&mut self) {
        let pos = self.get_entry_point();
        match self.0[pos] {
            ExpressionOp::Equals(l, r) => {
                self.0[pos] = ExpressionOp::NotEquals(l, r);
            },
            ExpressionOp::Greater(l, r) => {
                self.0[pos] = ExpressionOp::LessOrEquals(l, r);
            },
            ExpressionOp::GreaterOrEquals(l, r) => {
                self.0[pos] = ExpressionOp::Less(l, r);
            },
            ExpressionOp::Less(l, r) => {
                self.0[pos] = ExpressionOp::GreaterOrEquals(l, r);
            },
            ExpressionOp::LessOrEquals(l, r) => {
                self.0[pos] = ExpressionOp::Greater(l, r);
            }
            ExpressionOp::NotEquals(l, r) => {
                self.0[pos] = ExpressionOp::Equals(l, r);
            }

            _ => {todo!("Invert {:?}", self.0[pos])},
        }
    }




    fn recursive_print(&self, idx:OpIdx, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.0[idx] {
            ExpressionOp::Variable(variable) => f.write_fmt(format_args!("{variable}")),
            ExpressionOp::DestinationRegister(register) => f.write_fmt(format_args!("{register:?}")),
            ExpressionOp::Value(v) => if *v > 0xffff { f.write_fmt(format_args!("0x{v:x}")) } else { f.write_fmt(format_args!("{v}")) },
            ExpressionOp::Dereference(idx) => {f.write_str("[")?; self.recursive_print(*idx, f)?; f.write_str("]")},
            ExpressionOp::Assign(l_idx, r_idx) => {self.recursive_print(*l_idx, f)?; f.write_str(" := ")?; self.recursive_print(*r_idx, f)},
            ExpressionOp::Multiequals(l_idx, r_idx) => {f.write_str("(")?; self.recursive_print(*l_idx, f)?; f.write_str(") OR (")?; self.recursive_print(*r_idx, f)?; f.write_str(")")},
            ExpressionOp::Add(l_idx, r_idx) => {self.recursive_print(*l_idx, f)?; f.write_str(" + ")?; self.recursive_print(*r_idx, f)},
            ExpressionOp::Sub(l_idx, r_idx) => {self.recursive_print(*l_idx, f)?; f.write_str(" - ")?; self.recursive_print(*r_idx, f)},
            ExpressionOp::Multiply(l_idx, r_idx) => {self.recursive_print(*l_idx, f)?; f.write_str(" * ")?; self.recursive_print(*r_idx, f)},
            ExpressionOp::LessOrEquals(l_idx, r_idx) => {self.recursive_print(*l_idx, f)?; f.write_str(" <= ")?; self.recursive_print(*r_idx, f)},
            ExpressionOp::Less(l_idx, r_idx) => {self.recursive_print(*l_idx, f)?; f.write_str(" < ")?; self.recursive_print(*r_idx, f)},
            ExpressionOp::GreaterOrEquals(l_idx, r_idx) => {self.recursive_print(*l_idx, f)?; f.write_str(" >= ")?; self.recursive_print(*r_idx, f)},
            ExpressionOp::Greater(l_idx, r_idx) => {self.recursive_print(*l_idx, f)?; f.write_str(" > ")?; self.recursive_print(*r_idx, f)},
            ExpressionOp::Equals(l_idx, r_idx) => {self.recursive_print(*l_idx, f)?; f.write_str(" == ")?; self.recursive_print(*r_idx, f)},
            ExpressionOp::NotEquals(l_idx, r_idx) => {self.recursive_print(*l_idx, f)?; f.write_str(" != ")?; self.recursive_print(*r_idx, f)},
            ExpressionOp::BitShiftLeft(l_idx, r_idx) => {self.recursive_print(*l_idx, f)?; f.write_str(" << ")?; self.recursive_print(*r_idx, f)},
            ExpressionOp::BitShiftRight(l_idx, r_idx) => {self.recursive_print(*l_idx, f)?; f.write_str(" >> ")?; self.recursive_print(*r_idx, f)},
            ExpressionOp::And(l_idx, r_idx) => {self.recursive_print(*l_idx, f)?; f.write_str(" & ")?; self.recursive_print(*r_idx, f)},
        }
    }

    /// Given a set of tail instructions after substituting a variable - append this tail to
    /// `self.0` while patching pointers to point to the right new values
    fn copy_other(&mut self, new_pos:usize, ignore_under:usize, other:&[ExpressionOp]) {
        use ExpressionOp::*;
        // helper function to calculate new pointer position
        // if the pointer is between `[0; ignore_under]` - it's unchanged, because the expression hasn't been touched there.
        // otherwise the pointer is past the replaced variable and needs to be changed. 
        let s = |p:&usize| if *p >= ignore_under {  p - ignore_under + new_pos } else { *p };
        for op in other {
            self.0.push(match op {
                Dereference(p) => Dereference(s(p)),
                Assign(l, r) => Assign(s(l), s(r)),
                Multiequals(l, r) => Multiequals(s(l), s(r)),
                Add(l, r) => Add(s(l), s(r)),
                Sub(l, r) => Sub(s(l), s(r)),
                Multiply(l, r) => Multiply(s(l), s(r)),
                LessOrEquals(l, r) => LessOrEquals(s(l), s(r)),
                Less(l, r) => Less(s(l), s(r)),
                GreaterOrEquals(l, r) => GreaterOrEquals(s(l), s(r)),
                Greater(l, r) => Greater(s(l), s(r)),
                Equals(l, r) => Equals(s(l), s(r)),
                NotEquals(l, r) => NotEquals(s(l), s(r)),
                BitShiftLeft(l, r) => BitShiftLeft(s(l), s(r)),
                BitShiftRight(l, r) => BitShiftRight(s(l), s(r)),
                And(l, r) => And(s(l), s(r)),
                a => a.clone()
            })
        }
    }

    pub fn top_kind(&self) -> &ExpressionOp {
        self.0.last().unwrap()
    }

    fn copy_other_to_end(&mut self, other:&[ExpressionOp]) {
        self.copy_other(self.0.len(), 0, other);
    }

    pub fn get_destination_register(&self) -> Register {
        match &self.0[0] {
            ExpressionOp::DestinationRegister(r) => *r,
            _ => panic!("Expected a register, got {self:?}")
        }
    }

    pub fn iter_vars<'a>(&'a self) -> impl Iterator<Item = &VariableSymbol> + 'a {
        self.0.iter().filter_map(|p| if let ExpressionOp::Variable(v) = p { Some(v) } else { None })
    }

    pub fn get_value(&self) -> i64 {
        match &self.0[0] {
            ExpressionOp::Value(v) => *v,
            _ => panic!("Exptected a value, got {self:?}")
        }
    }

    pub fn get_memory_address_or_null(&self) -> u64 {
        match &self.0[0] {
            ExpressionOp::Dereference(v) => {
                match &self.0[*v] {
                    ExpressionOp::Value(v) => *v as u64,
                    _ => 0,
                }
            },
            ExpressionOp::Value(v) => {
                *v as u64
            }
            _ => 0,
        }
    }


    pub fn is_symbolic(&self) -> bool {
        self.0.iter().find(|p| matches!(p, ExpressionOp::Variable(_))).is_some()
    }


    /// Returns how many new instructions have been added
    pub fn replace_variable_with_expression(&mut self, var_index:OpIdx, expr:&Expression) -> i32 {
        assert!(matches!(self.0[var_index], ExpressionOp::Variable(_)));
        if expr == self { 
            return 0
        }
        // split the instruction vector
        let shift =  var_index + (expr.0.len() - 1);
        let remainder = self.0.split_off(var_index);
        // copy new instructions instead of the variable
        self.copy_other_to_end(&expr.0);
        // fix old instruction pointers
        if true { // is flattening expressions or not?
            let saved = self.apply(shift as i32, var_index, &remainder[1..]);
            expr.0.len() as i32 - 1 + saved
        } else {
            // If we just do self.copy_other we will crate correct expression, but it'll be expanded - with lots of + and - ops that can be simplified.
            self.copy_other(shift, var_index, &remainder[1..]);
            (expr.0.len() - 1) as i32
        }
    }

    pub fn replace_variable_with<'r, F>(&mut self, replace:F) where F:Fn(&VariableSymbol) -> Option<(Cow<'r, Expression>)> {
        // let mut extended_by = 0;

        let mut pos = 0;
        while pos < self.0.len() {
            if let ExpressionOp::Variable(v) = &self.0[pos] {
                if let Some(expr) = replace(v) {
                    let r = self.replace_variable_with_expression(pos, &expr);
                    if r > 0 { // it is possible we remove more instructions than add in case of nop-algebra. 
                        // in that case position of current variable stays the same. 
                        pos = (pos as i32 + r) as usize;
                    }
                }
            }
            pos += 1;
        }
    }

    pub fn assume(&self, reg:Register, value:i64) -> Expression {
        let mut result = self.clone();
        result.replace_variable_with(|v| {
                match v {
                    VariableSymbol::Register(r) => {
                        if *r == reg {
                            Some(Cow::Owned(Expression::from(value)))
                        } else {
                            None
                        }
                    },
                    _ => None,
                }
            });
        result
    }

    fn decrement_offsets(&mut self, from:usize) {
        for op in &mut self.0[from..] {
            match op {
                ExpressionOp::Dereference(l) => {
                    if *l >= from {
                        *l -= 1
                    }
                },
                ExpressionOp::Assign(l, r) |
                ExpressionOp::Multiequals(l, r) |
                ExpressionOp::Add(l, r) |
                ExpressionOp::Sub(l, r) |
                ExpressionOp::Multiply(l, r) |
                ExpressionOp::LessOrEquals(l, r) |
                ExpressionOp::Less(l, r) |
                ExpressionOp::GreaterOrEquals(l, r) |
                ExpressionOp::Greater(l, r) |
                ExpressionOp::Equals(l, r) |
                ExpressionOp::BitShiftLeft(l, r) |
                ExpressionOp::BitShiftRight(l, r) |
                ExpressionOp::And(l, r) |
                ExpressionOp::NotEquals(l, r) => { 
                    if *l >= from {
                        *l -= 1;
                     }
                    if *r >= from { *r -= 1}
                },
                _ => ()
            }
        }
    }

    fn replace_offsets(&mut self, from:usize, original:usize, new:usize) {
        for op in &mut self.0[from..] {
            match op {
                ExpressionOp::Dereference(l) => {
                    if *l == original {
                        *l = new
                    }
                },
                ExpressionOp::Assign(l, r) |
                ExpressionOp::Multiequals(l, r) |
                ExpressionOp::Add(l, r) |
                ExpressionOp::Sub(l, r) |
                ExpressionOp::Multiply(l, r) |
                ExpressionOp::LessOrEquals(l, r) |
                ExpressionOp::Less(l, r) |
                ExpressionOp::GreaterOrEquals(l, r) |
                ExpressionOp::Greater(l, r) |
                ExpressionOp::Equals(l, r) |
                ExpressionOp::BitShiftLeft(l, r) |
                ExpressionOp::BitShiftRight(l, r) |
                ExpressionOp::And(l, r) |
                ExpressionOp::NotEquals(l, r) => { 
                    if *l == original {
                        *l = new;
                    }
                    if *r == original {
                        *r = new;
                    }
                },
                _ => ()
            }
        }
    }

    fn remove_nop_algebra(&mut self, mut idx:OpIdx) -> i32 {
        let mut left_over = None;
        match &self.0[idx] {
            &ExpressionOp::Add(l, r) |
            &ExpressionOp::Sub(l, r) => {
                if ExpressionOp::Value(0) == self.0[l] {
                    self.0.remove(l);
                    left_over = Some(r);
                    self.decrement_offsets(l);
                    if l < idx {
                        idx -= 1;
                    }
                } else if ExpressionOp::Value(0) == self.0[r] {
                    self.0.remove(r);
                    left_over = Some(l);
                    self.decrement_offsets(r);
                    if r < idx {
                        idx -= 1;
                    }
                }
            },
            &ExpressionOp::Multiply(l, r) => {
                if ExpressionOp::Value(1) == self.0[l] {
                    self.0.remove(l);
                    left_over = Some(r);
                    self.decrement_offsets(l);
                    if l < idx {
                        idx -= 1;
                    }
                } else if ExpressionOp::Value(1) == self.0[r] {
                    self.0.remove(r);
                    left_over = Some(l);
                    self.decrement_offsets(r);
                    if r < idx {
                        idx -= 1;
                    }
                }
            },
            _ => ()
        }

        if let Some(left_over) = left_over {
            self.0.remove(idx);
            self.decrement_offsets(idx);
            self.replace_offsets(idx, idx-1, left_over);
            -2
        } else {
            0
        }

    }

    /// Given the arguments, of an old add/mul/sub instruction, this function modifies the expression
    /// such that immediate values are added/multiplied/subtracted before adding new add/mul/sub instructions.
    /// 
    /// Returns how many instructions have been added to the list. This value is likely to be `-2` (removed 2 instructions) or `0` (didn't remove any)
    fn patch(&mut self, l:usize, r:usize, new_pos:i32, ignore_under:usize, patch_kind:PatchKind) -> i32 {
        /// helper function to calculate new pointer position
        /// if the pointer is between `[0; ignore_under]` - it's unchanged, because the expression hasn't been touched there.
        /// otherwise the pointer is past the replaced variable and needs to be changed. 
        fn s(p:usize, ignore_under:usize, new_pos:i32) -> usize {
            if p >= ignore_under {  ((p - ignore_under) as i32 + new_pos) as usize } else { p }
        }
        let mut patched_l = s(l, ignore_under, new_pos);
        let mut patched_r = s(r, ignore_under, new_pos);
        if let ExpressionOp::Value(left) = self.0[patched_l] {
            // assert_eq!(patched_l, self.entry());
            self.0.remove(patched_l);
            if patched_l < patched_r {
                patched_r -= 1;
            }
            self.decrement_offsets(patched_l);
            let mut r = match patch_kind {
                // values will be attempted to be added and if they can't be - new instructions will be pushed on the stack
                // the count of those instructions will be returned, so we add them to new_pos
                PatchKind::Add => self.add_value_at(patched_r, left),
                PatchKind::Sub => self.sub_value_at(patched_r, left, true),
                PatchKind::Mul => self.multiply_value_at(patched_r, left),
            } as i32 - 2; // overall we removed one instruction from the list, and saved space by not adding a value, therefore, remove 2 from new_pos
            r += self.remove_nop_algebra(patched_r);
            r
        } else if let ExpressionOp::Value(right) = self.0[patched_r] {
            // assert_eq!(patched_r, self.entry());
            self.0.remove(patched_r);
            if patched_r < patched_l {
                patched_l -= 1;
            }
            self.decrement_offsets(patched_r);
            let mut r = match patch_kind {
                PatchKind::Add => self.add_value_at(patched_l, right),
                PatchKind::Sub => self.sub_value_at(patched_l, right, false),
                PatchKind::Mul => self.multiply_value_at(patched_l, right),
            }as i32 - 2;
            r += self.remove_nop_algebra(patched_l);
            r
        } else {
            self.0.push(match patch_kind {
                PatchKind::Add => ExpressionOp::Add(patched_l, patched_r),
                PatchKind::Sub => ExpressionOp::Sub(patched_l, patched_r),
                PatchKind::Mul => ExpressionOp::Multiply(patched_l, patched_r),
            });
            0
        }
    }

    fn apply(&mut self, mut new_pos:i32, ignore_under:usize, other:&[ExpressionOp]) -> i32  {
        use ExpressionOp::*;
        fn s(p:&usize, ignore_under:usize, new_pos:i32) -> usize {
            if *p >= ignore_under {  ((*p - ignore_under) as i32 + new_pos) as usize } else { *p }
        }
        let mut total_saved= 0;
        for op in other {
            match op {
                Dereference(p) => self.0.push(Dereference(s(p, ignore_under, new_pos))),
                Assign(l, r) => self.0.push(Assign(s(l, ignore_under, new_pos), s(r, ignore_under, new_pos))),
                Multiequals(l, r) => self.0.push(Multiequals(s(l, ignore_under, new_pos), s(r, ignore_under, new_pos))),
                Add(l, r) => { 
                    let saved = self.patch(*l, *r, new_pos, ignore_under, PatchKind::Add); 
                    total_saved += saved;
                    new_pos = new_pos as i32 + saved;
                },
                Sub(l, r) => { 
                    let saved = self.patch(*l, *r, new_pos, ignore_under, PatchKind::Sub); 
                    total_saved += saved;
                    new_pos = new_pos as i32 + saved;
                }
                Multiply(l, r) => { 
                    let saved = self.patch(*l, *r, new_pos, ignore_under, PatchKind::Mul); 
                    total_saved += saved;
                    new_pos = new_pos as i32 + saved;
                }
                LessOrEquals(l, r) => self.0.push(LessOrEquals(s(l, ignore_under, new_pos), s(r, ignore_under, new_pos))),
                Less(l, r) => self.0.push(Less(s(l, ignore_under, new_pos), s(r, ignore_under, new_pos))),
                GreaterOrEquals(l, r) => self.0.push(GreaterOrEquals(s(l, ignore_under, new_pos), s(r, ignore_under, new_pos))),
                Greater(l, r) => self.0.push(Greater(s(l, ignore_under, new_pos), s(r, ignore_under, new_pos))),
                Equals(l, r) => self.0.push(Equals(s(l, ignore_under, new_pos), s(r, ignore_under, new_pos))),
                NotEquals(l, r) => self.0.push(NotEquals(s(l, ignore_under, new_pos), s(r, ignore_under, new_pos))),
                BitShiftLeft(l, r) => self.0.push(BitShiftLeft(s(l, ignore_under, new_pos), s(r, ignore_under, new_pos))),
                BitShiftRight(l, r) => self.0.push(BitShiftRight(s(l, ignore_under, new_pos), s(r, ignore_under, new_pos))),
                And(l, r) => self.0.push(And(s(l, ignore_under, new_pos), s(r, ignore_under, new_pos))),
                a => self.0.push(a.clone())
            }
        }
        total_saved
    }

    pub fn get_entry_point(&self) -> OpIdx {
        return self.0.len() - 1
    }
}

#[derive(Debug)]
enum PatchKind{
    Add,
    Sub,
    Mul
}

#[derive(Clone, PartialEq, Eq, Hash, Debug)]
pub enum ExpressionOp{
    Variable(VariableSymbol),
    DestinationRegister(Register), 
    Value(i64),
    Dereference(OpIdx), 
    Assign(OpIdx, OpIdx),
    Multiequals(OpIdx, OpIdx),

    Add(OpIdx, OpIdx),
    Sub(OpIdx, OpIdx),
    Multiply(OpIdx, OpIdx), 
    LessOrEquals(OpIdx, OpIdx),
    Less(OpIdx, OpIdx),
    GreaterOrEquals(OpIdx, OpIdx),
    Greater(OpIdx, OpIdx),
    Equals(OpIdx, OpIdx),
    NotEquals(OpIdx, OpIdx),
    BitShiftRight(OpIdx, OpIdx),
    BitShiftLeft(OpIdx, OpIdx),
    And(OpIdx, OpIdx),
}

impl ExpressionOp {
    fn var_reg(reg:Register) -> Self {
        Self::Variable(VariableSymbol::Register(reg))
    }
}

impl std::fmt::Display for Expression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.0.len() > 0 {
            self.recursive_print(self.get_entry_point(), f)
        } else {
            f.write_str("NOP")
        }
    }
}

impl std::fmt::Debug for Expression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{:?}", self.0))
    }
}

mod test {
    use iced_x86::Register;

    use crate::ir::{expression::{ExpressionOp, VariableSymbol}, Expression};

    #[inline]
    fn var_reg(r:Register) -> ExpressionOp {
        ExpressionOp::Variable(VariableSymbol::Register(r))
    }

    #[test]
    fn test_multiply() {
        let mut e = Expression::from(1);
        e.add(&Expression::from(VariableSymbol::Register(Register::EAX)));
        e.multiply_value(4);
        assert_eq!(e.0, vec![
            ExpressionOp::Value(1),
            var_reg(Register::EAX),
            ExpressionOp::Add(0, 1),
            ExpressionOp::Value(4),
            ExpressionOp::Multiply(2, 3),
            ]);
    }

    #[test]
    fn test_variable_substitution() {
        use ExpressionOp::{Value, Variable as VarOp, Add, Multiply};
        let mut e = Expression::from(1);
        e.add(&Expression::from(VariableSymbol::Register(Register::EAX)));
        e.multiply_value(4); // e = (1 + ?EAX) * 4

        let mut sub = Expression::from(1);
        sub.add(&Expression::from(VariableSymbol::Register(Register::ESP)));
        sub.multiply_value(2); // sub = (1+?ESP) * 2

        e.replace_variable_with_expression(1, &sub);
        
        // This block is correct if we are NOT using expression flattening
        // assert_eq!(e.0, vec![
        //     // (1 + (1 + ?ESP) * 2 ) * 4
        //     Value(1),
        //     Value(1),
        //     VarOp(Variable::Register(Register::ESP)),
        //     Add(1, 2),
        //     Value(2),
        //     Multiply(3, 4),
        //     Add(0, 5),
        //     Value(4),
        //     Multiply(6, 7)
        // ]);

        // this block is correct if we are using expression flatening
        assert_eq!(e.0, vec![
            // (1 + (1 + ?ESP) * 2 ) * 4
            Value(1),
            VarOp(VariableSymbol::Register(Register::ESP)),
            Add(0, 1),
            Value(2),
            Multiply(2, 3),
            Value(1),
            Add(4, 5),
            Value(4),
            Multiply(6, 7)
        ]);
    }

    #[test]
    fn test_replace() {
        use ExpressionOp::{Value, Add, Dereference, Sub, Variable as VarOp};
        let mut first = Expression::from(VariableSymbol::Register(Register::ESP));
        first.add_value(180);
        first.dereference();
        // first = [?ESP + 180]

        let mut second = Expression::from(VariableSymbol::Register(Register::ESP));
        second.sub_value(12);
        second.dereference();
        // second = [?ESP - 12]

        second.replace_variable_with_expression(0, &first);
        // second = [[?ESP - 12] + 180]
        assert_eq!(second.0, vec![
            VarOp(VariableSymbol::Register(Register::ESP)), Value(180), Add(0, 1), Dereference(2), Value(12), Sub(3, 4), Dereference(5)
        ])
    }

    #[test]
    fn test_replace_ptr_to_var() {
        use ExpressionOp::{Value, Dereference, Assign, Add, Variable as VarOp};
        let mut e = Expression::new();
        e.0 = vec![
            Value(6721424), Dereference(0), ExpressionOp::Variable(VariableSymbol::Register(Register::EAX)), Assign(1, 2)
        ];
        // e = [668f90] := ?EAX

        let mut eax = Expression::new();
        eax.0 = vec![
            VarOp(VariableSymbol::Register(Register::EBP)), Value(100), Add(0, 1), Dereference(2)
        ]; // eax = [?EBP + 100]
        e.replace_variable_with_expression(2, &eax);
        assert_eq!(e.0, vec![
            Value(6721424), Dereference(0), VarOp(VariableSymbol::Register(Register::EBP)), Value(100), Add(2, 3), Dereference(4), Assign(1, 5)
        ])
    }

    #[test]
    fn test_replace_complex() {
        use ExpressionOp::{Value, Dereference, Assign, Add, Variable as VarOp};
        let mut ptr = Expression::new();
        ptr.0 = vec![
            VarOp(VariableSymbol::Register(Register::EAX)), Value(20), Add(0, 1), Dereference(2)
        ];


        // e = [?EAX + 20] := ?data@[?EAX + 20] + 1
        let mut e = Expression::new();
        e.0 = vec![
            VarOp(VariableSymbol::Register(Register::EAX)), Value(20), Add(0, 1), Dereference(2), VarOp(VariableSymbol::Ram(ptr)), Value(1), Add(4, 5), Assign(3, 6)
        ]; // e = [?EAX + 20] := ?data@[?EAX + 20] + 1
        


        let val_expr = Expression::from(4917232);
        let call_result = ExpressionOp::Variable(VariableSymbol::CallResult{call_from:crate::ir::Address::NULL, call_to:val_expr});
        let mut eax = Expression::new();
        eax.0 = vec![ 
            call_result.clone()
        ]; // eax = ?call_4b07f0_result


        e.replace_variable_with(|old_e| {
            match old_e {
                VariableSymbol::Register(r) => {
                    if *r == Register::EAX { Some(std::borrow::Cow::Borrowed(&eax)) } else { None }
                },
                VariableSymbol::Ram(d) => {
                    let mut d = d.clone();
                    d.replace_variable_with_expression(0, &eax);
                    Some(std::borrow::Cow::Owned(Expression::from(VariableSymbol::Ram(d))))
                }
                _ => panic!("No such variables should be here")
            }
        });

        let mut new_ptr = Expression::new();
        new_ptr.0 = vec![
            call_result.clone(), Value(20), Add(0, 1), Dereference(2)
        ];

        assert_eq!(e.0, vec![
            call_result.clone(), Value(20), Add(0, 1), Dereference(2), VarOp(VariableSymbol::Ram(Expression::from(new_ptr))), Value(1), Add(4, 5), Assign(3, 6)
        ])
    }

    #[test]
    fn test_replace_flatten() {
        use ExpressionOp::{Value, Add, Dereference, Sub, Variable as VarOp};
        let mut first = Expression::from(VariableSymbol::Register(Register::ESP));
        first.add_value(180);
        // first = ?ESP + 180

        let mut second = Expression::from(VariableSymbol::Register(Register::ESP));
        second.sub_value(12);
        second.dereference();
        // second = [?ESP - 12]

        second.replace_variable_with_expression(0, &first);
        // second = [?ESP +180 - 12]
        assert_eq!(second.0, vec![
            VarOp(VariableSymbol::Register(Register::ESP)), Value(168), Add(0, 1), Dereference(2)
        ])
    }

    #[test]
    fn test_sub_at_end() {
        use ExpressionOp::{Value, Add, Dereference, Sub};
        use Register::EAX;
        let mut e = Expression::from(vec![var_reg(EAX), Value(10), Sub(0, 1)]);
        e.sub_value_at(2, 9, false);
        assert_eq!(e.0, vec![var_reg(EAX), Value(19), Sub(0,1)])
    }

    #[test]
    fn test_sub_at_end_inverted() {
        use ExpressionOp::{Value, Add, Dereference, Sub};
        use Register::EAX;
        let mut e = Expression::from(vec![var_reg(EAX), Value(10), Sub(1, 0)]);
        e.sub_value_at(2, 9, false);
        assert_eq!(e.0, vec![var_reg(EAX), Value(1), Sub(1, 0)]);

        let mut e = Expression::from(vec![var_reg(EAX), Value(10), Sub(1, 0)]);
        e.sub_value_at(2, 9, true); // Doesn't matter because on-stack Sub() operation gets openned anyway.
        assert_eq!(e.0, vec![var_reg(EAX), Value(1), Sub(1, 0)]);

        let mut e = Expression::from(vec![var_reg(EAX), Value(10), Sub(1, 0), Dereference(2)]);
        e.sub_value_at(3, 9, false);
        assert_eq!(e.0, vec![var_reg(EAX), Value(10), Sub(1, 0), Dereference(2), Value(9), Sub(3, 4)]);

        let mut e = Expression::from(vec![var_reg(EAX), Value(10), Sub(1, 0), Dereference(2)]);
        e.sub_value_at(3, 9, true);
        assert_eq!(e.0, vec![var_reg(EAX), Value(10), Sub(1, 0), Dereference(2), Value(9), Sub(4, 3)]);
    }

    #[test]
    fn test_replace_var_with_value() {
        use ExpressionOp::{Value, Add, Dereference, Sub, Assign};
        use Register::EDI;
        let mut expression = Expression::from(vec![Value(6721484), Dereference(0), var_reg(EDI), Sub(1, 2)]);
        let r = expression.replace_variable_with_expression(2, &Expression::from(0));
        assert_eq!(expression.0, vec![Value(6721484), Dereference(0)]);
        assert_eq!(r, -2);
    }

    #[test]
    fn test_replace_flatten_with_value() {
        use ExpressionOp::{Value, Add, Dereference, Sub, Assign};
        use Register::ESP;
        let mut expression = Expression::from(vec![
            var_reg(ESP),                               // 0                                     
            Value(116),                                // 1         
            Add(0, 1),                                 // 2     
            Dereference(2),                            // 3             
            Value(156),                                // 4         
            var_reg(ESP),                               // 5                                     
            Value(76),                                 // 6     
            Add(5, 6),                                 // 7     
            Dereference(7),                            // 8             
            Sub(4, 8),                                 // 9     
            Assign(3, 9)]);                            // 10         

        let sub = Expression::from(vec![var_reg(ESP), Value(172), Sub(0, 1)]);

        expression.replace_variable_with_expression(0, &sub);

        assert_eq!(expression.0, vec![
            var_reg(ESP), 
            Value(56), 
            Sub(0, 1),
            Dereference(2),
            var_reg(ESP), 
            Value(76), 
            Add(4, 5), 
            Dereference(6), 
            Value(156), 
            Sub(8, 7), 
            Assign(3, 9)
        ])

    }

    // #[test]
    // fn test_to_symbol() {
    //     use ExpressionOp::{Sub, Dereference, Variable as VarOp};
    //     let mut e = Expression::from(VariableSymbol::Register(Register::ESP));
    //     e.sub_value(12);
    //     e.dereference();
    //     // e = [?ESP - 12]

    //     let mut symbol_map = std::collections::HashMap::new();
    //     let mut symbols = Vec::new();
    //     let high_e = e.to_high(&mut symbol_map, &mut symbols, e.get_entry_point());

    //     // assert_eq!(high_e.0, vec![VarOp(Variable::Symbol(0)), Dereference(0)]);
    //     assert_eq!(symbols.len(), 1);
    //     // symbols[0].name = "param_1".into();
    //     // println!("{high_e:?}");

    // }
}
```

`src/ir/high_function.rs`:

```rs
use std::collections::{HashMap, HashSet};

use iced_x86::Register;
use nodit::{Interval, NoditMap};

use crate::{ir::{basic_block::NextBlock, program_tree_structure::ProgramTreeStructure, AbstractSyntaxTree, BlockStorage, Expression, ExpressionOp, Scope, VariableSymbol}, memory::Memory};

use super::{Address, BasicBlock, ControlFlowGraph, SingleEntrySingleExit};


#[derive(Copy, Clone, Debug)]
pub enum CallingConvention {
    Cdecl,
}

/// Accumulation of analysis resutls of a single function
pub struct HighFunction {
    pub calling_convention: CallingConvention,
    pub composed_blocks: BlockStorage,
    pub used_call_results: HashSet<VariableSymbol>,
    pub memory_read:HashSet<Expression>,
    pub memory_written:HashSet<Expression>,
    pub function_calls:HashSet<Expression>,
    pub cfg: ControlFlowGraph,
    pub pts: ProgramTreeStructure,
}

fn analysis(composed_block:&BasicBlock, used_call_results:&mut HashSet<VariableSymbol>, memory_read:&mut HashSet<Expression>, memory_written:&mut HashSet<Expression>, function_calls:&mut HashSet<Expression>) {
    for (addr, value) in composed_block.memory.iter() {
        mark_call_return_used(addr,  used_call_results);
        mark_call_return_used(value,  used_call_results);
        memory_written.insert(addr.clone());
        for op in value.iter() {
            if let ExpressionOp::Dereference(d) = op {
                let value = value.get_sub_expression(*d);
                // value.dereference();
                memory_read.insert(value);
            }
        }
    }
    match &composed_block.next {
        NextBlock::ConditionalJump{condition,..} => {
            mark_call_return_used(condition,  used_call_results);
            for op in condition.iter() {
                if let ExpressionOp::Dereference(d) = op {
                    let value = condition.get_sub_expression(*d);
                    // value.dereference();
                    memory_read.insert(value);
                }
            }
        },
        NextBlock::Call {destination, .. } => {
            function_calls.insert(destination.clone());
        },
        NextBlock::Return => {
            
            let stack_state = composed_block.get_register_state_or_none(&Register::ESP).unwrap();
            if stack_state.get_entry_point() != 0 || !matches!(stack_state.get(0), ExpressionOp::Variable(_)) {
                println!("TODO: Function returns at {} Non-initial stack pointer: ESP = {}", composed_block.address, stack_state);
                if composed_block.address.0 == 0x4b1724 {
                    println!("\t this is because MessageBoxA follows stdcall calling convention, not cdecl.")
                }
            }
        }
        _ => ()
    }
}

impl HighFunction {
    pub fn from_mem(addr:impl Into<Address>, mem:&Memory) -> Self {
        let calling_convention = CallingConvention::Cdecl;
        let addr = addr.into();
        

        let block = mem.ir.get_at_point(addr).expect("Unable to get IR at function start");
        let mut composed_blocks = BlockStorage::new();
        let mut used_call_results = HashSet::new();
        let mut memory_read = HashSet::new();
        let mut memory_written = HashSet::new();
        let mut function_calls = HashSet::new();

        composed_blocks.insert_strict(block.get_interval(), block.clone()).unwrap();
        analysis(block, &mut used_call_results, &mut memory_read, &mut memory_written, &mut function_calls);
        let mut visited = std::collections::HashSet::new();
        let mut stack = vec![block];
        let mut copy_vec = Vec::with_capacity(10);

        while let Some(block) = stack.pop() {
            if !visited.contains(block) {
                visited.insert(block);
                let composed_block = composed_blocks.get_at_point(block.address).unwrap();

                


                
                for nbr in block.iter_neighbors(&mem.ir) {
                    stack.push(nbr);
                    let composed = if let NextBlock::Call { origin, destination, .. } = &composed_block.next {
                        let mut after_call = composed_block.clone();
                        match calling_convention {
                            CallingConvention::Cdecl => _ = after_call.registers.insert(Register::EAX, Expression::from(VariableSymbol::CallResult { call_from: *origin, call_to:destination.clone() })),
                        }
                        nbr.inherit_state_from(&after_call)
                    } else {
                        nbr.inherit_state_from(composed_block)
                    };
                    
                    copy_vec.push(composed);
                }
                while let Some(composed) = copy_vec.pop() {
                    if composed_blocks.contains_point(composed.address) {
                        // different paths lead to this composed block. 
                        // the states will be potentially different.
                        let other = composed_blocks.get_at_point_mut(composed.address).unwrap();
                        if other.registers != composed.registers && !composed.is_return() {
                            // diverging states to return block can be either different error handling
                            // or getting different cases of a result
                            let mut printed_regs = HashMap::new();
                            for (k, v) in &other.registers {
                                if let Some(cv) = composed.registers.get(k) {
                                    if v != cv {
                                        let mut e = v.clone();
                                        e.multiequals(cv);
                                        printed_regs.insert(*k, e);
                                    }
                                } else {
                                    // printed_regs.push(*k);
                                    todo!("\tRegister {k:?}: {v} OR Not set");
                                }
                            }
                            for (k, v) in &composed.registers {
                                if !printed_regs.contains_key(k) && !other.registers.contains_key(k) && v != &Expression::from(VariableSymbol::Register(*k)) {
                                    todo!("\tRegister {k:?} Not set OR {v}")
                                }
                            }
                            for (reg, state) in printed_regs {
                                other.registers.insert(reg, state);
                            }
                        }
                    } else {
                        analysis(&composed, &mut used_call_results, &mut memory_read, &mut memory_written, &mut function_calls);
                        composed_blocks.insert_strict(composed.get_interval(), composed).unwrap();
                    }
                }
            }
        }

        assert_eq!(composed_blocks.len(), visited.len());
        let cfg = ControlFlowGraph::new(addr, &composed_blocks);
        let pts = ProgramTreeStructure::new(&cfg, &composed_blocks);
        Self{calling_convention, composed_blocks, cfg, pts, used_call_results, memory_written, memory_read, function_calls}
    }

    pub fn build_ast(&self, mem:&Memory) -> AbstractSyntaxTree {
        AbstractSyntaxTree::new(self, mem)
    }

    pub fn fill_global_symbols(&self, mem:&mut Memory) {

        for (_interval, block) in self.composed_blocks.iter() {
            mem.ir.get_at_point_mut(block.address).and_then(|b| Some(b.parent_function = self.cfg.start));
        }
        let symbols = &mut mem.symbols;
        symbols.add(self.cfg.start.0, format!("FUN_{:X}", self.cfg.start.0));
        for e in &self.memory_read {
            if let Some(ExpressionOp::Value(v)) = e.last_op() {
                symbols.add(*v as u64, format!("DAT_{:X}", v));
            }
        }
        for e in &self.memory_written{
            if let Some(ExpressionOp::Value(v)) = e.last_op() {
                symbols.add(*v as u64, format!("DAT_{:X}", v));
            }
        }
        for e in &self.function_calls{
            if let Some(ExpressionOp::Value(v)) = e.last_op() {
                symbols.add(*v as u64, format!("FUN_{:X}", v));
            }
        }
    }

    pub fn is_state_valid(&self, state:&Expression) -> bool {
        match self.calling_convention {
            CallingConvention::Cdecl => {
                state.iter().find(|p| if let ExpressionOp::Variable(v) = p { 
                    match v {
                        VariableSymbol::Register(r) => { *r != Register::ESP},
                        _ => false
                    }
                } else { false }).is_none()
            }
        }
    }

}


fn mark_call_return_used(e:&Expression, used_call_sites:&mut HashSet<VariableSymbol>) {
    for op in e.iter() {
        if let ExpressionOp::Variable(v) = op {
            match v {
                VariableSymbol::CallResult { .. } => _ = used_call_sites.insert(v.clone()),
                VariableSymbol::Ram(e) => mark_call_return_used(e, used_call_sites),
                _ => (),
            }
        }
    }
}

```

`src/ir/mod.rs`:

```rs
//! The process of lifting code from machine code to C-like:
//! 
//! * For each defined function, convert machine code to [`BasicBlock`], where each block tracks symbolic state of execution.
//! * Compose [`BasicBlock`]s together as-if executing the function. Execute only 1 round of loops.
//! * Generate [`ControlFlowGraph`] by treating [`BasicBlock`]s as nodes.
//! * Perform dominance and post-dominance analysis of basic blocks to generate [`SingleEntrySingleExit`] (SESE) pairs of the graph
//! * Use SESE pairs to generate [`ProgramTreeStructure`] - which SESEs are nested within other SESEs. This allows us 
//! to decide when to omit else statements in if-else blocks, when to use switch/case or loops.
//! * Traverse [`BasicBlock`]s in the SESE order - outer to inner, generating [`AST`] - Abstract Syntax Tree of the logic.
//! * Use [`ProgramTreeStructure`] to keep track of the scope of variables for each program block. 
//! 

use std::{collections::HashMap, fmt::Write, hash::Hash, ops::Add};

use iced_x86::{Code, Instruction, OpKind, Register};
use nodit::{interval::ie, Interval, NoditMap, OverlapError};

use crate::symbol_resolver::SymbolTable;


mod expression;
mod address;
mod basic_block;
mod control_flow_graph;
mod utils;
mod high_function;
mod abstract_syntax_tree;
mod program_tree_structure;
mod scope;

pub use expression::{Expression, ExpressionOp, VariableSymbol};
pub use address::Address;
pub use basic_block::BasicBlock;
pub use utils::*;
pub use control_flow_graph::*;
pub use scope::*;
pub use high_function::HighFunction;
pub use abstract_syntax_tree::{AbstractSyntaxTree, AstStatement};

pub type BlockStorage = NoditMap<Address, Interval<Address>, BasicBlock>;

fn op_to_expression(mut state:Option<&mut BasicBlock>, instr:&Instruction, op_index:u8, ) -> Expression {
    let (kind, reg) = match op_index {
        0 => {(
            instr.op0_kind(),
            instr.op0_register()
        )},
        1 => {(
            instr.op1_kind(),
            instr.op1_register()
        )},
        _ => panic!("Unsupported op count!")
    };
    match kind {
        OpKind::Register => state.and_then(|s| Some(s.get_register_state(reg).clone())).unwrap_or(Expression::from(reg)),
        OpKind::Memory => {
            let mut base = if instr.memory_base() != Register::None {
                state.as_mut().and_then(|s| Some(s.get_register_state(instr.memory_base()).clone())).unwrap_or(Expression::from(reg)) 
            } else {
                Expression::from(0)
            };

            let displacement = match instr.memory_displ_size() {
                4 => instr.memory_displacement32() as i64,
                _ => instr.memory_displacement64() as i64,
                // n => todo!("Unexpected memory displacement size {n}.")
            };
            
            if instr.memory_base().is_ip() {
                Expression::from(displacement)
            } else {
                if instr.memory_index() != Register::None {
                    let mut scale_reg = state.and_then(|s| Some(s.get_register_state(instr.memory_index()).clone())).unwrap_or(Expression::from(reg));
                    let index = if instr.memory_index_scale() == 1 {
                        scale_reg
                    } else {
                        let scale_size = Expression::from(instr.memory_index_scale() as i64);
                        scale_reg.multiply(&scale_size);
                        scale_reg
                    };
                    base.add(&index);
                }
                base.add_value(displacement);
                base.dereference();
                base
            }
        },
        OpKind::Immediate32to64 => {
            Expression::from(instr.immediate64() as i64)
        },
        OpKind::Immediate32 => {
            Expression::from(instr.immediate32() as i64)
        }
        OpKind::Immediate8to32 => {
            Expression::from(instr.immediate8to32() as i64)
        }
        OpKind::Immediate8 => {
            Expression::from(instr.immediate8() as i64)
        }
        _ => todo!("Unexpected op0 kind: {kind:?}")
    }
}


fn panic_with_interval_info<'a>(blocks:&'a BlockStorage) -> impl FnOnce(OverlapError<BasicBlock>) + use<'a> {
    |e:OverlapError<BasicBlock>| {
        let mut s = format!("{e:?}:\n");
        for (_, block) in blocks.overlapping(e.value.get_interval()) {
            s.write_fmt(format_args!("\t{block:?}\n")).unwrap();
        }
        panic!("{s}")
    }
}

    pub fn lift(instr:&[Instruction]) -> BlockStorage {
        let mut blocks = BlockStorage::new();
        let mut current_block = BasicBlock::new();
        for instruction in instr {
            let ip = instruction.ip();
            let ipa = Address(ip);
            if current_block.address == Address::NULL {
                current_block.address = ipa;
            }
            if blocks.contains_point(ipa) {
                // the reason blocks already contains this point is because other block jumps here
                if blocks.get_at_point(ipa).unwrap().address == current_block.address {
                    // remove_overlapping first removes everything. No need to consume iterator just to remove.
                    _ = blocks.remove_overlapping(ie(ipa, Address(ipa.0 + 2)));
                } else {
                    current_block.next = basic_block::NextBlock::Unconditional(ipa);
                    blocks.insert_strict(current_block.get_interval(), current_block).unwrap_or_else(panic_with_interval_info(&blocks));
                    current_block = BasicBlock::new();
                    current_block.address = ipa;
                    _ = blocks.remove_overlapping(ie(ipa, Address(ipa.0 + 2)));
                }
            }
            current_block.end = instruction.next_ip().into();
        
        
            match instruction.code() {
                Code::Mov_r32_rm32 | Code::Mov_r32_imm32 | Code::Mov_EAX_moffs32=> {
                    let mut left = op_to_expression(None, instruction, 0);
                    let right = op_to_expression(Some(&mut current_block),instruction, 1);

                    let target = left.get_destination_register();
                    current_block.set_register_state(target, right.clone());

                    left.assign(&right);
                    current_block.instruction_map.insert(ipa, left);
                },
                Code::Mov_rm32_imm32 | Code::Mov_rm32_r32 | Code::Mov_moffs32_EAX => {
                    let mut left = op_to_expression(Some(&mut current_block), instruction, 0);
                    let right = op_to_expression(Some(&mut current_block),instruction, 1);

                    let mut result = left.clone();
                    result.assign(&right);

                    left.cancel_dereference();
                    current_block.set_memory_state(left, right);

                    current_block.instruction_map.insert(ipa, result);
                },
                Code::Add_rm32_imm8 | Code::Add_rm32_imm32=> {
                    let target = op_to_expression(None, instruction, 0).get_destination_register();
                    let mut left = op_to_expression(Some(&mut current_block), instruction, 0);
                    let right = op_to_expression(Some(&mut current_block),instruction, 1).get_value();

                    left.add_value(right);
                    let mut result = Expression::from(target);
                    result.assign(&left);
                    
                    current_block.instruction_map.insert(ipa, result);
                    current_block.set_register_state(target, left);
                },
                Code::Add_r32_rm32 | Code::Add_EAX_imm32=> {
                    let target = op_to_expression(None, instruction, 0).get_destination_register();
                    let mut left = op_to_expression(Some(&mut current_block), instruction, 0);
                    let right = op_to_expression(Some(&mut current_block), instruction, 1);
                    left.add(&right);
                    let mut result = Expression::from(target);
                    result.assign(&left);
                    current_block.instruction_map.insert(ipa, result);
                    current_block.set_register_state(target, left);
                },
                Code::Sub_rm32_imm32  | Code::Sub_r32_rm32 => {
                    let mut target = op_to_expression(None, instruction, 0);
                    let reg = target.get_destination_register();
                    let mut left = op_to_expression(Some(&mut current_block), instruction, 0);
                    let right = op_to_expression(Some(&mut current_block),instruction, 1);
                    left.sub(&right);
                    target.assign(&left);
                    current_block.instruction_map.insert(ipa, target);
                    current_block.set_register_state(reg, left);

                },
                Code::Push_r32 | Code::Pushd_imm32 | Code::Pushd_imm8 => {
                    let pushed_value = op_to_expression(Some(&mut current_block), instruction, 0);
                    let esp = Register::ESP;
                    let esp_state = current_block.get_register_state(esp).clone();
                    let mut new_esp_state = esp_state.clone();
                    new_esp_state.sub_value(4);

                    let mut instruction_result = esp_state.clone();
                    instruction_result.dereference();
                    instruction_result.assign(&pushed_value);

                    
                    current_block.instruction_map.insert(ipa, instruction_result);
                    current_block.set_memory_state(esp_state, pushed_value);
                    
                    current_block.set_register_state(esp, new_esp_state);
                },

                Code::Pop_r32 => {
                    let pop_destination = op_to_expression(None, instruction, 0).get_destination_register();
                    let mut esp_state = current_block.get_register_state(Register::ESP).clone();
                    let memory_state = current_block.get_memory_state(esp_state.clone()).clone();


                    esp_state.add_value(4);
                    let mut instruction_result = Expression::from(pop_destination);
                    instruction_result.assign(&memory_state);

                    current_block.set_register_state(Register::ESP, esp_state);
                    current_block.instruction_map.insert(ipa, instruction_result);
                    current_block.set_register_state(pop_destination, memory_state);
                },
                Code::Lea_r32_m => {
                    let destination = op_to_expression(None, instruction, 0).get_destination_register();
                    let mut value = op_to_expression(Some(&mut current_block),instruction, 1);
                    value.cancel_dereference();
                    
                    let mut instruction_result = Expression::from(destination);
                    instruction_result.assign(&value);

                    current_block.instruction_map.insert(ipa, instruction_result);
                    current_block.set_register_state(destination, value);
                },

                Code::Xor_r32_rm32 => {
                    let left = op_to_expression(None, instruction, 0).get_destination_register();
                    let right = op_to_expression(None, instruction, 1).get_destination_register();
                    if left == right {
                        let mut instruction_result = Expression::from(left);
                        instruction_result.assign_value(0);
                        current_block.instruction_map.insert(ipa, instruction_result);
                        current_block.set_register_state(left, 0);
                    } else {
                        todo!("Make XOR")
                    }
                },
                Code::Shr_rm32_imm8 => {
                    let mut instruction_result = op_to_expression(None, instruction, 0);
                    let register = instruction_result.get_destination_register();
                    let mut left = op_to_expression(Some(&mut current_block), instruction, 0);
                    let right = op_to_expression(None, instruction, 1).get_value();
                    left.bit_shift_right(right);
                    
                    instruction_result.assign(&left);
                    current_block.instruction_map.insert(ipa, instruction_result);
                    current_block.set_register_state(register, left);
                },
                Code::And_rm32_imm8 => {
                    let mut instruction_result = op_to_expression(None, instruction, 0);
                    let register = instruction_result.get_destination_register();
                    let mut left = op_to_expression(Some(&mut current_block), instruction, 0);
                    let right = op_to_expression(None, instruction, 1).get_value();
                    left.and(right);
                    
                    instruction_result.assign(&left);
                    current_block.instruction_map.insert(ipa, instruction_result);
                    current_block.set_register_state(register, left);
                }

                Code::Inc_rm32 => {
                    let mut addr = op_to_expression(Some(&mut current_block), instruction, 0);
                    let mut value = current_block.get_memory_state(addr.clone()).clone();
                    value.add_value(1);
                    let mut instruction_result = addr.clone();
                    instruction_result.assign(&value);

            
                    current_block.instruction_map.insert(ipa, instruction_result);
                    addr.cancel_dereference();
                    current_block.set_memory_state(addr, value);


                },
                Code::Stosd_m32_EAX => {
                    // Store ECX-count dwords of whatever is in EAX into pointer starting at EDI
                    current_block.next = basic_block::NextBlock::Unconditional(ipa);
                    current_block.end = ipa;
                    blocks.insert_strict(current_block.get_interval(), current_block).unwrap_or_else(panic_with_interval_info(&blocks));

                    let mut loop_block = BasicBlock::new();
                    loop_block.address = ipa;
                    loop_block.end = instruction.next_ip().into();
                    let eax = Expression::from(VariableSymbol::Register(Register::EAX));
                    let mut ecx = Expression::from(VariableSymbol::Register(Register::ECX));
                    let mut edi = Expression::from(VariableSymbol::Register(Register::EDI));
                    
                    loop_block.next = basic_block::NextBlock::ConditionalJump { 
                        condition: ecx.clone(), 
                        true_branch: ipa, 
                        false_branch: instruction.next_ip().into()
                    };

                    loop_block.set_memory_state(edi.clone(), eax.clone());
                    edi.add_value(4);
                    loop_block.set_register_state(Register::EDI, edi);
                    ecx.sub_value(1);
                    loop_block.set_register_state(Register::ECX, ecx);

                    blocks.insert_strict(loop_block.get_interval(), loop_block).unwrap_or_else(panic_with_interval_info(&blocks));
                    

                    current_block = BasicBlock::new();
                },
                Code::Stosb_m8_AL => {
                    // Store ECX-count bytes of whatever is in AL into pointer starting at EDI
                    current_block.next = basic_block::NextBlock::Unconditional(ipa);
                    current_block.end = ipa;
                    blocks.insert_strict(current_block.get_interval(), current_block).unwrap_or_else(panic_with_interval_info(&blocks));

                    let mut loop_block = BasicBlock::new();
                    loop_block.address = ipa;
                    loop_block.end = instruction.next_ip().into();
                    let al = Expression::from(VariableSymbol::Register(Register::EAX)); // TODO: Reason about AL vs AX vs EAX
                    let mut ecx = Expression::from(VariableSymbol::Register(Register::ECX));
                    let mut edi = Expression::from(VariableSymbol::Register(Register::EDI));
                    
                    loop_block.next = basic_block::NextBlock::ConditionalJump { 
                        condition: ecx.clone(), 
                        true_branch: ipa, 
                        false_branch: instruction.next_ip().into()
                    };

                    loop_block.set_memory_state(edi.clone(), al.clone());
                    edi.add_value(1);
                    loop_block.set_register_state(Register::EDI, edi);
                    ecx.sub_value(1);
                    loop_block.set_register_state(Register::ECX, ecx);

                    blocks.insert_strict(loop_block.get_interval(), loop_block).unwrap_or_else(panic_with_interval_info(&blocks));
                    

                    current_block = BasicBlock::new();
                },
                Code::Movsd_m32_m32 => {
                    // Store ECX-count dwords from DS:[ESI] to ES:[EDI]
                    current_block.next = basic_block::NextBlock::Unconditional(ipa);
                    current_block.end = ipa;
                    blocks.insert_strict(current_block.get_interval(), current_block).unwrap_or_else(panic_with_interval_info(&blocks));

                    let mut loop_block = BasicBlock::new();
                    loop_block.address = ipa;
                    loop_block.end = instruction.next_ip().into();
                    let mut esi = Expression::from(VariableSymbol::Register(Register::ESI));
                    let mut ecx = Expression::from(VariableSymbol::Register(Register::ECX));
                    let mut edi = Expression::from(VariableSymbol::Register(Register::EDI));
                    
                    // loop_block.next = Expression::from(instruction.next_ip() as i64);
                    // loop_block.conditional_jump = Some((ecx.clone(), loop_block.address));
                    loop_block.next = basic_block::NextBlock::ConditionalJump { 
                        condition: ecx.clone(), 
                        true_branch: ipa, 
                        false_branch: instruction.next_ip().into()
                    };

                    loop_block.set_memory_state(edi.clone(), esi.clone());
                    edi.add_value(4);
                    esi.add_value(4);
                    loop_block.set_register_state(Register::EDI, edi);
                    loop_block.set_register_state(Register::ESI, esi);
                    ecx.sub_value(1);
                    loop_block.set_register_state(Register::ECX, ecx);

                    blocks.insert_strict(loop_block.get_interval(), loop_block).unwrap_or_else(panic_with_interval_info(&blocks));
                    

                    current_block = BasicBlock::new();
                },
                Code::Movsb_m8_m8 => {
                    // Store ECX-count bytes from DS:[ESI] to ES:[EDI]
                    current_block.next = basic_block::NextBlock::Unconditional(ipa);
                    current_block.end = ipa;
                    blocks.insert_strict(current_block.get_interval(), current_block).unwrap_or_else(panic_with_interval_info(&blocks));

                    let mut loop_block = BasicBlock::new();
                    loop_block.address = ipa;
                    loop_block.end = instruction.next_ip().into();
                    let mut esi = Expression::from(VariableSymbol::Register(Register::ESI));
                    let mut ecx = Expression::from(VariableSymbol::Register(Register::ECX));
                    let mut edi = Expression::from(VariableSymbol::Register(Register::EDI));
                    
                    loop_block.next = basic_block::NextBlock::ConditionalJump { 
                        condition: ecx.clone(), 
                        true_branch: ipa, 
                        false_branch: instruction.next_ip().into()
                    };

                    loop_block.set_memory_state(edi.clone(), esi.clone()); // TODO: Only 1 byte is copied
                    edi.add_value(1);
                    esi.add_value(1);
                    loop_block.set_register_state(Register::EDI, edi);
                    loop_block.set_register_state(Register::ESI, esi);
                    ecx.sub_value(1);
                    loop_block.set_register_state(Register::ECX, ecx);

                    blocks.insert_strict(loop_block.get_interval(), loop_block).unwrap_or_else(panic_with_interval_info(&blocks));
                    

                    current_block = BasicBlock::new();
                },
                Code::Cmp_r32_rm32 | Code::Cmp_rm32_r32 => {
                    let mut left = op_to_expression(Some(&mut current_block), instruction, 0);
                    let right = op_to_expression(Some(&mut current_block),instruction, 1);

                    left.sub(&right);
                    
                    current_block.instruction_map.insert(ipa, left.clone());
                    current_block.next = basic_block::NextBlock::ConditionalJump { condition: left, true_branch: Address::NULL, false_branch: Address::NULL };
                },
                Code::Cmp_EAX_imm32 | Code::Cmp_rm32_imm8 => {
                    let mut left = op_to_expression(Some(&mut current_block), instruction, 0);
                    let right = op_to_expression(Some(&mut current_block),instruction, 1).get_value();

                    left.sub_value(right);
                    current_block.instruction_map.insert(ipa, left.clone());
                    current_block.next = basic_block::NextBlock::ConditionalJump { condition: left, true_branch: Address::NULL, false_branch: Address::NULL };
                },
                Code::Test_rm32_r32 => {
                    let left = op_to_expression(Some(&mut current_block), instruction, 0);
                    let right = op_to_expression(Some(&mut current_block),instruction, 1);
                    if left == right {
                        current_block.next = basic_block::NextBlock::ConditionalJump { condition: left, true_branch: Address::NULL, false_branch: Address::NULL };
                    } else {
                        todo!("Implement Expression::AND")
                    }
                },
                Code::Call_rel32_32 | Code::Call_rm32 => {
                    let call_site = match instruction.op0_kind() {
                        OpKind::NearBranch32 => {
                            Expression::from(instruction.near_branch32() as i64)
                        },
                        OpKind::Memory => {
                            op_to_expression(Some(&mut current_block), instruction, 0)
                        }
                        _ => todo!("Unexpected call kind: {:?}", instruction.op0_kind())
                    };

                    current_block.next = basic_block::NextBlock::Call { origin: ipa, destination: call_site, return_instruction:instruction.next_ip().into() };
                    blocks.insert_strict(current_block.get_interval(), current_block).unwrap_or_else(panic_with_interval_info(&blocks));

                    current_block = BasicBlock::new(); 
                    // current_block.address = instruction.next_ip().into();
                    // // next block has pre-set EAX register, assuming cdecl 
                    // current_block.set_register_state(Register::EAX, VariableSymbol::CallResult{call_from:Address(instruction.ip()), call_to:call_site});

                },
                Code::Retnd => {
                    current_block.next = basic_block::NextBlock::Return;
                    blocks.insert_strict(current_block.get_interval(), current_block).unwrap_or_else(panic_with_interval_info(&blocks));
                    current_block = BasicBlock::new();
                }
                c @ (Code::Je_rel8_32 | Code::Jne_rel8_32 | Code::Jl_rel32_32 | Code::Ja_rel32_32) => {
                    let call_site:Address = match instruction.op0_kind() {
                        OpKind::NearBranch32 => {
                            instruction.near_branch32().into()
                        },
                        _ => todo!("Unexpected call kind: {:?}", instruction.op0_kind())
                    };
                    if let basic_block::NextBlock::ConditionalJump { mut condition,.. } = current_block.next {
                        if let Some(block) = blocks.get_at_point(call_site) {
                            if block.address != call_site {
                                todo!("Jump to a middle of a defined block.")
                            }
                        } else {
                            let mut true_block = BasicBlock::new();
                            true_block.address = call_site;
                            true_block.end = Address(call_site.0 + 1);
                            blocks.insert_strict(true_block.get_interval(), true_block).unwrap_or_else(panic_with_interval_info(&blocks));
                        }
                        let mut false_condition = condition.clone();
                        match c {
                            Code::Je_rel8_32 => {
                                condition.check_equals_value(0);
                                false_condition.check_not_equals_value(0);
                            },
                            Code::Jne_rel8_32 => {
                                condition.check_not_equals_value(0);
                                false_condition.check_equals_value(0);
                            },
                            Code::Jl_rel32_32 => {
                                condition.check_less_value(0);
                                false_condition.check_greater_or_equals_value(0);
                            },
                            Code::Ja_rel32_32 => { // jump grater, unsigned, TODO: How to keep track of signed/unsigned/flags logic?
                                condition.check_greater_value(0);
                                false_condition.check_less_or_equals_value(0);
                            },
                            _ => panic!("Unexpected jump code")
                        };
    
                        let no_jump_addr:Address = instruction.next_ip().into();
                        // current_block.conditional_jump = Some((true_branch.clone(), call_site));
                        // current_block.next = Expression::from(no_jump_addr.0 as i64);
                        current_block.next = basic_block::NextBlock::ConditionalJump{ 
                            condition, 
                            true_branch: call_site, 
                            false_branch: no_jump_addr };
    
                        // self.blocks.insert(call_site, jump_state);
                        let mut no_jump_state = BasicBlock::new();
                        no_jump_state.address = no_jump_addr;
                        no_jump_state.end = Address(no_jump_addr.0 + 1);
                        no_jump_state.constraints.push(false_condition);
                        
                        blocks.insert_strict(current_block.get_interval(), current_block).unwrap_or_else(panic_with_interval_info(&blocks));
                        current_block = no_jump_state;

                    } else {
                        panic!("Conditional jump before condition is set");
                    }
                },
                code => {
                    println!("Process instruction {:x}: {code:?}", instruction.ip());
                }
            }
        }
    blocks 
}
```

`src/ir/program_tree_structure.rs`:

```rs

use std::collections::{HashMap, HashSet};

use nodit::{Interval, NoditMap};
use petgraph::{algo::dominators::Dominators, csr::DefaultIx, visit::IntoNeighbors};

use crate::ir::{basic_block::NextBlock, is_ancestor, is_reachable, least_common_ancestor, preorder, BasicBlock, BlockStorage, HighFunction};

use super::{Address, ControlFlowGraph, SingleEntrySingleExit};

pub struct ProgramTreeStructure {
    pub root:SingleEntrySingleExit<Address>,
    tree:HashMap<SingleEntrySingleExit<Address>, Vec<SingleEntrySingleExit<Address>>>,
    lookup_table:NoditMap<Address, Interval<Address>, SingleEntrySingleExit<Address>>
}

impl ProgramTreeStructure {
    pub fn new(cfg:&ControlFlowGraph, blocks:&BlockStorage) -> Self {
        let start_node = cfg.get_node_idx(cfg.start);
        let end_node = cfg.get_node_idx(cfg.single_end());

        let seses = make_sese_pairs(&cfg.dom, &cfg.pdom, &cfg, start_node, end_node).iter().copied().collect::<Vec<_>>();
        
        let (pts_root, program_tree_structure) = build_program_tree_structure(&cfg.dom, &cfg.pdom, &seses, start_node, end_node);
        
        let mut tree =  HashMap::from_iter(program_tree_structure.iter().map(|(k, v)| {
                (
                    seseix_to_seseaddr(*k, &cfg),
                    Vec::from_iter(v.iter().map(|i| seseix_to_seseaddr(*i, &cfg)))
                )
            }));
        let mut pts_root =  seseix_to_seseaddr(pts_root, &cfg);
        tree.insert(SingleEntrySingleExit(cfg.start, cfg.single_end()), vec![pts_root]); // Add the whole function as a SESE as the used algorithm does not

        pts_root = SingleEntrySingleExit(cfg.start, cfg.single_end());
        let mut lookup_table = NoditMap::new();
        compute_sese_address_ranges(&mut lookup_table, cfg.start, pts_root, &tree, blocks);
        Self { root: pts_root, tree, lookup_table }
    }

    pub fn get_children(&self, entry:SingleEntrySingleExit<Address>) -> Option<&[SingleEntrySingleExit<Address>]> {
        self.tree.get(&entry).map(|v| &v[..])
    }

    pub fn get_section(&self, addr:Address) -> Option<SingleEntrySingleExit<Address>> {
        self.lookup_table.get_at_point(addr).copied()
    }

    pub fn pretty_print<F>(&self, f:&F) -> String where F:Fn(SingleEntrySingleExit<Address>, &str) -> String  {
        draw_pts(self.root, &self.tree, f, 0)
    }
}

fn compute_sese_address_ranges(table:&mut NoditMap<Address, Interval<Address>, SingleEntrySingleExit<Address>>, start:Address, root:SingleEntrySingleExit<Address>, tree:&HashMap<SingleEntrySingleExit<Address>, Vec<SingleEntrySingleExit<Address>>>, blocks:&BlockStorage) {

    fn process_path<'a>(table:&mut NoditMap<Address, Interval<Address>, SingleEntrySingleExit<Address>>, start:Address, root:SingleEntrySingleExit<Address>, blocks:&'a BlockStorage) -> &'a BasicBlock {
        let start = blocks.get_at_point(start).unwrap();
        table.insert_merge_touching_if_values_equal(start.get_interval(), root);
        let mut last_block = start;
        for node in start.iter_path(blocks) {
            table.insert_merge_touching_if_values_equal(node.get_interval(), root);
            last_block = node;
        }
        last_block
    }

    let mut branch_block = process_path(table, start, root, blocks);

    if let Some(children) = tree.get(&root) {
        while let Some(c_pts) = children.iter().find(|p| p.0 == branch_block.address) {
            
            if let NextBlock::ConditionalJump {true_branch, false_branch, .. } = branch_block.next {
                compute_sese_address_ranges(table, true_branch, *c_pts, tree, blocks);
                compute_sese_address_ranges(table, false_branch, *c_pts, tree, blocks);
            } else {
                panic!("Unexpected start of a program segment")
            }

            if c_pts.1 != Address::NULL {
                branch_block = process_path(table, c_pts.1, root, blocks)
            }
            if c_pts.1 == root.1 {
                break;
            }
        }
    }
}

/// Generate single-entry single-exit pairs
fn make_sese_pairs(dom:&Dominators<DefaultIx>, pdom:&Dominators<DefaultIx>, forward_graph:&ControlFlowGraph, start:DefaultIx, end:DefaultIx) -> Vec<SingleEntrySingleExit<DefaultIx>> {
    
    let mut stack = vec![start];
    let mut seses = HashSet::new();
    let mut visited = HashSet::new();
    while let Some(current) = stack.pop() {
        // candidate immediate post-dominator if the neighbor check fails
        let mut candidate = pdom.immediate_dominator(current);
        for nbr in forward_graph.neighbors(current) {
            if !visited.contains(&nbr) {
                visited.insert(nbr);
                // self.current_node is u
                // nbr is v
                // if current is ansestor if nbr in dom - it dominates nbr 
                // and makes a trivial SESE region. We skip those.
                stack.push(nbr);
                if !is_ancestor(current, nbr, &dom) {  
                    let a = least_common_ancestor(current, nbr, start, &dom).unwrap();
                    let b = least_common_ancestor(current, nbr, end, &pdom).unwrap();
                    seses.insert(SingleEntrySingleExit(a, b));
                    candidate = None;
                } 
            }
        }
        if let Some(candidate) = candidate {
            if forward_graph.neighbors(current).count() > 1 {
                let are_all_neighbors_reachable = forward_graph.neighbors(current).fold(true, |acc, v| acc && is_reachable(forward_graph, current, v));
                if are_all_neighbors_reachable {
                    seses.insert(SingleEntrySingleExit(current, candidate));
                }
            }
        }
    }

    // sort SESEs by most encompassing-first
    let dom_pre = preorder(&dom, start);
    let pdom_pre = preorder(&pdom, end);
    let mut seses:Vec<_> = seses.iter().copied().collect();
    seses.sort_by(|l, r| {
        let a_pos = dom_pre[&l.0];
        let c_pos = dom_pre[&r.0];
        if a_pos != c_pos { 
            a_pos.cmp(&c_pos) 
        } else {
            let b_pos = pdom_pre[&l.1];
            let d_pos = pdom_pre[&r.1];
            // let l_size = b_pos - a_pos;
            // let r_size = d_pos - c_pos;
            b_pos.cmp(&d_pos)
        }
    });
    seses
}

fn seseix_to_seseaddr(sese:SingleEntrySingleExit<DefaultIx>, graph:&ControlFlowGraph) -> SingleEntrySingleExit<Address> {
    let a = graph[sese.0];
    let b = graph[sese.1];
    SingleEntrySingleExit(a, b)
}

fn build_program_tree_structure<N>(dom:&Dominators<N>, pdom:&Dominators<N>, seses:&Vec<SingleEntrySingleExit<N>>, start:N, end:N) -> (SingleEntrySingleExit<N>, HashMap<SingleEntrySingleExit<N>, Vec<SingleEntrySingleExit<N>>>) 
where N: Copy + Eq + std::hash::Hash + std::fmt::Debug
{
    let mut pts = HashMap::new();
    let mut stack:Vec<SingleEntrySingleExit<N>> = Vec::new();
    let largest = *seses.first().unwrap();
    for sese in seses {
        while let Some(top) = stack.last() {
            let start_top_dominates_sese = is_ancestor(top.0, sese.0, &dom);
            let end_top_postdominates_sese = is_ancestor(top.1, sese.1, &pdom);
            match (start_top_dominates_sese, end_top_postdominates_sese) {
                // top "encloses" sese
                (true, true) => break,
                // top and sese aren't related
                (false, false) => _= stack.pop(), 

                (true, false) => {
                    if !is_ancestor(sese.1, top.1, &pdom) && sese.0 != top.0 {
                        todo!("Cross-over (irreducible) segment detected: {top:?} and {sese:?}");
                    }
                    stack.pop();
                },
                (false, true) => {
                    if is_ancestor(sese.0, top.0, &pdom) && sese.0 != top.0 {
                        todo!("Cross-over (irreducible) segment detected: {top:?} and {sese:?}");
                    }
                    stack.pop();
                }
            }
        }
        if let Some(top) = stack.last() {
            // sese is child of top
            let children = pts.entry(*top).or_insert(Vec::new());
            children.push(*sese);
        } else {
            pts.insert(*sese, Vec::new());
        }
        stack.push(*sese);
    }
    (largest, pts)
}

pub fn draw_pts<N, F>(root:SingleEntrySingleExit<N>, pts:&HashMap<SingleEntrySingleExit<N>, Vec<SingleEntrySingleExit<N>>>, additional:&F, depth:u8) -> String
where 
    N: std::fmt::Debug + std::hash::Hash + Eq + Copy,
    F: Fn(SingleEntrySingleExit<N>, &str) -> String
{
    let mut tab_prefix = String::with_capacity((depth*2) as usize);
    for _ in 0..(depth*2) { // 2 spaces per depth
        tab_prefix.push(' ');
    }
    let mut output = format!("{tab_prefix}{root:?} {{");
    tab_prefix.push(' ');
    tab_prefix.push(' ');
    let mut has_new_line = false;
    let s = additional(root, &tab_prefix);
    if s.len() > 0 {
        output.push('\n');
        has_new_line = true;
        output.push_str(&s);
        output.push('\n');
    }
    if let Some(children) = pts.get(&root) {
        for child in children {
            let sub = draw_pts(*child, pts, additional, depth+1);
            if sub.len() > 0 {
                if !has_new_line {
                    output.push('\n');
                }
                output.push_str(&sub);
                output.push('\n');
                has_new_line = true;
            }
        }
    }
    tab_prefix.pop();
    tab_prefix.pop();
    if has_new_line {
        output.push_str(&format!("{tab_prefix}}}"));
    } else {
        output.push_str("}");
    }
    output
}
```

`src/ir/scope.rs`:

```rs
use std::collections::HashMap;

use crate::ir::program_tree_structure::ProgramTreeStructure;

use super::{VariableSymbol, SingleEntrySingleExit, Address};


#[derive(Clone, Debug)]
pub struct VariableType {
    pub name:String,
}

#[derive(Clone, Debug)]
pub struct VariableDefinition{
    pub kind: VariableType,
    pub name: String,
    pub variable: VariableSymbol,
}

impl VariableDefinition {
    pub fn new(kind:String, name:String, value:VariableSymbol) -> Self {
        Self{
            kind:VariableType{name:kind},
            name,
            variable: value
        }
    }
}

pub type SymbolMap = HashMap<VariableSymbol, VariableDefinition>;


pub struct Scope {
    /// Map of SESEs to what variables are defined at that level
    map: HashMap<SingleEntrySingleExit<Address>, SymbolMap>,
    pub parents:HashMap<SingleEntrySingleExit<Address>, Vec<SingleEntrySingleExit<Address>>>,
}

impl Scope {
    pub fn new() -> Self {
        Self { 
            map: HashMap::new(),
            parents: HashMap::new(),
         }
    }

    pub fn fill_parents(&mut self, pts:&ProgramTreeStructure, root:SingleEntrySingleExit<Address>) {
        if let Some(children) = pts.get_children(root) {
            for child in children {
                self.parents.entry(*child).or_default().push(root);
                self.fill_parents(pts, *child);
            }
        }
    }

    pub fn insert(&mut self, key:SingleEntrySingleExit<Address>, value:SymbolMap) -> Option<SymbolMap> {
        self.map.insert(key, value)
    }

    pub fn add(&mut self, section:SingleEntrySingleExit<Address>, key:VariableSymbol, value:VariableDefinition) -> Option<VariableDefinition> {
        self.map.entry(section).or_default().insert(key, value)
    }

    pub fn get(&self, section:SingleEntrySingleExit<Address>) -> Option<&SymbolMap> {
        self.map.get(&section)
    }

    pub fn get_symbol(&self, section:SingleEntrySingleExit<Address>, key:&VariableSymbol) -> Option<&VariableDefinition> {
        // println!("Looking for symbol {key:?}");
        if let Some(scope) = self.map.get(&section) {
            if let Some(def) = scope.get(key) {
                return Some(def)
            }
        }
        if let Some(parents) = self.parents.get(&section) {
            for parent in parents {
                if let Some(def) = self.get_symbol(*parent, key) {
                    return Some(def)
                }
            }
        }
        None
    }

    pub fn pretty_print(&self, pts:&ProgramTreeStructure) -> String {
        pts.pretty_print(&|sese, prefix| {
            let mut output = String::new();
            if let Some(vars) = self.get(sese) {
                for (key, value) in vars {
                    output.push_str(&format!("{prefix}{key} = {}", value.name));
                }
            }
            output
        })
    }
} 
```

`src/ir/utils.rs`:

```rs
use std::collections::{HashMap, HashSet};

use nodit::{Interval, NoditMap};

use crate::ir::ControlFlowGraph;

use super::{BasicBlock, Address, BlockStorage};

pub struct BlockFunctionIterator<'i>{
    blocks:&'i BlockStorage,
    stack:Vec<&'i BasicBlock>,
    visited:HashSet<&'i BasicBlock>,
}

impl<'i> BlockFunctionIterator<'i> {
    pub fn new(block:&'i BasicBlock, blocks:&'i BlockStorage) -> Self {
        Self { blocks, stack: vec![block], visited: HashSet::new() }
    }
}

impl<'i> Iterator for BlockFunctionIterator<'i> {
    type Item = &'i BasicBlock;

    fn next(&mut self) -> Option<Self::Item> {
        if let Some(b) = self.stack.pop() {

            self.visited.insert(b);
            for nbr in b.iter_neighbors(self.blocks) {
                    if !self.visited.contains(nbr) {
                    self.stack.push(nbr);
                    self.visited.insert(nbr);
                }
            }
            Some(b)
        } else {
            None
        }
    }
}




pub struct BlockPathIterator<'i>{
    blocks:&'i BlockStorage,
    block:Option<&'i BasicBlock>,
}

impl<'i> BlockPathIterator<'i> {
    pub fn new(block:&'i BasicBlock, blocks:&'i BlockStorage) -> Self {
        Self { blocks, block:Some(block) }
    }
}

impl<'i> Iterator for BlockPathIterator<'i> {
    type Item = &'i BasicBlock;

    fn next(&mut self) -> Option<Self::Item> {
        if let Some(block) = self.block {
            let mut i = block.iter_neighbors(self.blocks);
            if let Some(result) = i.next() {
                if i.next().is_none() {
                    self.block = Some(result);
                    return Some(result)
                } else {
                    self.block = None;
                    return None;
                }
            }
        } 

        None
            
    }
}






pub struct BlockNeighborsIterator<'i> {
    block:&'i BasicBlock,
    blocks:&'i BlockStorage,
    yielded_true_branch:bool,
    yielded_all:bool,
}

impl<'i> BlockNeighborsIterator<'i> {
    pub fn new(block:&'i BasicBlock, blocks:&'i BlockStorage) -> Self {
        Self { blocks, block, yielded_true_branch:false, yielded_all:false}
    }
}

impl<'i> Iterator for BlockNeighborsIterator<'i> {
    type Item = &'i BasicBlock;

    fn next(&mut self) -> Option<Self::Item> {
        use super::basic_block::NextBlock::*;
        if self.yielded_all {
            return None
        }
        match &self.block.next {
            ConditionalJump { true_branch, false_branch, .. } => {
                if !self.yielded_true_branch {
                    self.yielded_true_branch = true;
                    self.blocks.get_at_point(*true_branch)
                } else {
                    self.yielded_all = true;
                    self.blocks.get_at_point(*false_branch)
                }
            },
            Call { return_instruction, ..} => {
                self.yielded_all = true;
                self.blocks.get_at_point(*return_instruction)
            },
            Unconditional(address) => {
                self.yielded_all = true;
                self.blocks.get_at_point(*address)
            },
            Return |
            ReturnDifferentSite(_) => None
        }
    }
}


```

`src/main.rs`:

```rs
// mod listing;

mod test;
mod symbol_resolver;
mod memory;
mod ir;

use std::{collections::BTreeMap, ops::Add, pin::Pin, sync::Arc};

use egui::{text::LayoutJob, Color32, FontFamily, FontId, Key, Layout, RichText, Sense, Stroke, TextStyle, Visuals};

mod tab_viewer;
use iced_x86::Register;
// use listing::Listing;

use eframe::egui;

use egui_dock::{DockArea, DockState, NodeIndex, Style, SurfaceIndex};

use crate::{ir::{lift, Address, Expression, ExpressionOp, HighFunction, VariableDefinition, VariableSymbol}, memory::{LiteralState, Memory}, symbol_resolver::SymbolTable, tab_viewer::{BlockGraph, BlockView, Decompiler, TabKind, TabSignals, TabViewer}};



struct DecompilerApp<'s> {
    memory: Memory<'s>,
    current_function:Option<Address>,
    signals: TabSignals,
    tree: DockState<TabKind>,
    buttons: [(&'static str, TabKind); 3]
}

fn main() -> eframe::Result {
    // env_logger::init(); // Log to stderr (if you run with `RUST_LOG=debug`).
    let options = eframe::NativeOptions {
        viewport: egui::ViewportBuilder::default().with_inner_size([1024., 768.0]),
        ..Default::default()
    };
    let mut memory = Memory::new();
    let state = LiteralState::from_machine_code(test::EXAMPLE_CODE, test::EXAMPLE_CODE_BITNESS, test::EXAMPLE_CODE_RIP);
    let ir = lift(state.get_instructions());
    let f_start = Address(test::EXAMPLE_CODE_RIP);
    memory.literal.insert_strict(state.get_interval(), state).unwrap();
    memory.ir = ir;


    let hf = HighFunction::from_mem(f_start, &memory);
    hf.fill_global_symbols(&mut memory);


    // memory.symbols.add(test::EXAMPLE_CODE_RIP, "openPAK".to_owned());
    // memory.symbols.add(0x611084, "pakFilename".to_owned());
    // memory.symbols.add(0x669218, "pakFilename2".to_owned());
    // memory.symbols.add(0x6128a0, "propName".to_owned());
    // memory.symbols.add(0x4b07f0, "get_pak_cache".to_owned());
    // memory.symbols.add(0x4b0730, "logPAK".to_owned());
    // memory.symbols.add(0x4a1310, "file_OpenEx".to_owned());
    // memory.symbols.add(0x04a1490, "read_last_open_file_into".to_owned());
    // memory.symbols.add(0x49C5C0, "mem_newBlock_inSpecialSegment".to_owned());

    // memory.symbols.add(0x4BCDD0, "_strncpy".to_owned());
    // memory.symbols.add(0x668F94, "pakFlags".to_owned());
    // memory.symbols.add(0x668fcc, "isDebugPak".to_owned());


    // memory.symbols.add(0x4A1220, "close_last_open_fd_if_no_error".to_owned());
    // memory.symbols.add(0x4B0760, "setPalData".to_owned());
    // memory.symbols.add(0x62C124, "IS_READ_PAK_WHOLE_MAYBE".to_owned());
    // memory.symbols.add(0x668F90, "palData".to_owned());
    // memory.symbols.add(0x4A2E40, "setStatics".to_owned());
    // memory.symbols.add(0x52e268, "USER32.DLL::MessageBoxA".to_owned());

    // memory.symbols.add(0x4affb0, "fixObjectPointers".to_owned());
    // memory.symbols.add(0x4b1450, "toRenderable".to_owned());
    // memory.symbols.add(0x49c600, "mem_FreeMem_inSpecialSegment".to_owned());
    // memory.symbols.add(0x4b2370, "curious_s15f16_math".to_owned());
    // memory.symbols.add(0x4afed0, "ui_scaling_related".to_owned());
    // memory.symbols.add(0x4b0840, "cache_pak".to_owned());
    // memory.symbols.add(0x4b0680, "loadTextures".to_owned());
    // memory.symbols.add(0x4ada90, "SetStaticsAndReturnPalCase_1to2_2to3".to_owned());
    // memory.symbols.add(0x4a2e80, "SET_PAK_RELATED_TO_NULL".to_owned());
    // memory.symbols.add(0x4a14f0, "seek_file".to_owned());


    let mut ast = hf.build_ast(&memory);
    

    let var_esp = Expression::from(VariableSymbol::Register(Register::ESP));

    let mut param_1 = var_esp.clone();
    param_1.add_value(4);
    param_1.dereference();

    let mut param_2 = var_esp.clone();
    param_2.add_value(8);
    param_2.dereference();

    let mut param_3 = var_esp;
    param_3.add_value(12);
    param_3.dereference();

    let stack_4 = VariableSymbol::Ram(Expression::from(vec![ExpressionOp::Variable(VariableSymbol::Register(Register::ESP)), ExpressionOp::Value(4), ExpressionOp::Add(0, 1)]));
    let stack_8 = VariableSymbol::Ram(Expression::from(vec![ExpressionOp::Variable(VariableSymbol::Register(Register::ESP)), ExpressionOp::Value(8), ExpressionOp::Add(0, 1)]));
    let stack_12 = VariableSymbol::Ram(Expression::from(vec![ExpressionOp::Variable(VariableSymbol::Register(Register::ESP)), ExpressionOp::Value(12), ExpressionOp::Add(0, 1)]));
    ast.scope.add(hf.pts.root, stack_4.clone(), VariableDefinition::new("char *".to_owned(), "filename_a".to_owned(), stack_4));
    ast.scope.add(hf.pts.root, stack_8.clone(), VariableDefinition::new("char *".to_owned(), "filename_b".to_owned(), stack_8));
    ast.scope.add(hf.pts.root, stack_12.clone(), VariableDefinition::new("char *".to_owned(), "filename_c".to_owned(), stack_12));

    memory.ast.insert(f_start, ast);
    memory.functions.insert(f_start, hf);

    

    eframe::run_native(
        "Ouroboros",
        options,
        Box::new(|cc| {
            let style = &cc.egui_ctx.style();
            let buttons = [
            ("Listing", TabKind::ASM(BlockView::new(style, &memory))),
            ("Decompiler", TabKind::Decompiler(Decompiler::new(style))),
            ("Block Graph", TabKind::BlockGraph(BlockGraph::new())),
            ];


            let mut tree = DockState::new(vec![TabKind::ASM(BlockView::new(style, &memory))]);
            tree.split((SurfaceIndex(0), NodeIndex(0)), egui_dock::Split::Right, 0.5, egui_dock::Node::leaf(TabKind::Decompiler(Decompiler::new(style))));


            

            Ok(Box::new(DecompilerApp{
                current_function: Some(f_start),
                memory,
                tree,
                signals:TabSignals::new(),
                buttons,
            }))
        }),
    )
}






impl<'s> eframe::App for DecompilerApp<'s> {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        egui::TopBottomPanel::top("menu_panel").show(ctx, |panel| {
            let menu_bar = egui::MenuBar::new().ui(panel, |ui| {
                let file = ui.menu_button("File", |file_ui| {
                    
                    let open = file_ui.button("Open...");
                    if open.clicked() || file_ui.ctx().input(|i| i.key_pressed(Key::O)) {
                        println!("Open file");
                    }
                    
                });
                file.response.ctx.enable_accesskit();
                if ui.ctx().input(|i| i.key_pressed(Key::F)) {
                    file.response.request_focus();
                }
                ui.menu_button("Windows", |windows_ui| {
                    let style = windows_ui.style();
                    
                    for (name, tab) in &self.buttons {
                        if windows_ui.button(*name).clicked() {
                            if let Some(index) = self.tree.find_tab_from(|p| p == tab) {
                                self.tree.set_active_tab(index);
                            } else {
                                self.tree.main_surface_mut().push_to_focused_leaf(tab.clone());
                            }
                        }
                    }
                });
            });
            menu_bar.response.ctx.enable_accesskit();
        });
        egui::TopBottomPanel::bottom("status_bar").show(ctx,|panel| {
            panel.label("Status bar...");
        });

        self.signals.new_frame();
        
        let mut tab_viewer = TabViewer::new(&self.memory, self.current_function, &mut self.signals);
        DockArea::new(&mut self.tree)
            .style(Style::from_egui(ctx.style().as_ref()))
            .show(ctx, &mut tab_viewer);


    }
    
}

```

`src/memory.rs`:

```rs
use std::collections::HashMap;
use std::sync::Arc;

use nodit::{InclusiveInterval, Interval, NoditMap};
use nodit::interval::ie;
use iced_x86::{Code, Decoder, DecoderOptions, Formatter, Instruction, NasmFormatter, OpKind, Register, SymbolResolver};

use crate::ir::{AbstractSyntaxTree, Address, BasicBlock, BlockStorage, Expression, HighFunction};
use crate::symbol_resolver::{RefSymbolTable, SymbolTable};

pub enum DataKind{

}

pub enum LiteralKind {
    Data(DataKind),
    Instruction(Vec<Instruction>)
}

impl std::fmt::Debug for LiteralKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Data(arg0) => f.debug_tuple("Data").finish(),
            Self::Instruction(arg0) => f.debug_tuple("Instruction").finish(),
        }
    }
}

pub struct LiteralState<'s> {
    pub addr:Address,
    pub bytes: &'s [u8],
    pub kind: LiteralKind
}

impl std::fmt::Debug for LiteralState<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("LiteralState").field("addr", &self.addr).field("size", &self.bytes.len()).field("kind", &self.kind).finish()
    }
}

pub struct Memory<'s>{
    // We have a choice of granularity, a small state per large interval, or large state per small interval.
    pub literal: NoditMap<Address, nodit::Interval<Address>, LiteralState<'s>>,
    pub ir:BlockStorage,
    /// All analyzed functions
    pub functions:HashMap<Address, HighFunction>,
    /// All decompiled functions
    pub ast:HashMap<Address, AbstractSyntaxTree>,
    /// Global symbols
    pub symbols: SymbolTable, // Need Arc to feed it to iced_x86 disassembly formatter
}

impl<'s> LiteralState<'s> {
    pub fn from_machine_code(bytes:&'s [u8], bitness:u32, ip:u64) -> Self {
        let mut decoder =
            Decoder::with_ip(bitness, bytes, ip, DecoderOptions::NONE);
        let mut instrs = Vec::new();
        while decoder.can_decode() {
            let i = decoder.decode();
            if i.is_invalid() {
                break;
            } else {
                instrs.push(i);
            }
        }
        let bytes = &bytes[0..(decoder.ip()-ip) as usize];
        Self { addr:ip.into(), bytes, kind: LiteralKind::Instruction(instrs)}
    }

    pub fn get_interval(&self) -> Interval<Address> {
        ie(self.addr, self.addr + self.bytes.len().into())
    }

    pub fn get_instructions(&self) -> &[Instruction] {
        match &self.kind {
            LiteralKind::Instruction(v) => v,
            _ => panic!("State is not instructions")
        }
    }
}

impl<'s> Memory<'s> {
    pub fn new() -> Self {
        Self { 
            literal: NoditMap::new(), 
            ir: NoditMap::new(), 
            functions:HashMap::new(),
            ast: HashMap::new(),
            symbols:SymbolTable::new(), 
        }
    }

    // pub fn get_symbol_resolver(&self) -> Option<Box<dyn SymbolResolver>> {
    //     Some(Box::new(RefSymbolTable::new(self.symbols.clone())))
    // }
}
```

`src/symbol_resolver.rs`:

```rs
use std::{collections::HashMap, sync::Arc};

use iced_x86::*;

use crate::ir::{Expression, VariableDefinition, VariableSymbol, VariableType};

pub struct SymbolTable {
    pub map: HashMap<u64, VariableDefinition>
}

pub struct RefSymbolTable(Arc<SymbolTable>);

impl SymbolResolver for RefSymbolTable {
    fn symbol(
            &mut self, instruction: &Instruction, operand: u32, instruction_operand: Option<u32>, address: u64, address_size: u32,
        ) -> Option<SymbolResult<'_>> {
        if let Some(symbol_string) = self.0.map.get(&address) {
            // The 'address' arg is the address of the symbol and doesn't have to be identical
            // to the 'address' arg passed to symbol(). If it's different from the input
            // address, the formatter will add +N or -N, eg. '[rax+symbol+123]'
            Some(SymbolResult::with_str(address, symbol_string.name.as_str()))
        } else {
            None
        }
    }
}

impl Into<RefSymbolTable> for Arc<SymbolTable> {
    fn into(self) -> RefSymbolTable {
        RefSymbolTable(self.clone())
    }
}

impl RefSymbolTable {
    pub fn new(st: Arc<SymbolTable>) -> Self {
        st.into()
    }
}

impl SymbolTable {
    pub fn new() -> Self {
        Self { map: HashMap::new() }
    }

    pub fn add(&mut self, address:u64, symbol:String) {
        self.map.insert(address, VariableDefinition { 
            kind: VariableType { name: String::new() }, 
            name: symbol, 
            variable: VariableSymbol::Ram(Expression::new()) });
    }

    pub fn resolve(&self, e:&VariableSymbol) -> Option<&VariableDefinition> {
        self.map.get(&e.get_memory_address_or_null())
    }

    pub fn resolve_exp(&self, e:&Expression) -> Option<&VariableDefinition> {
        self.map.get(&e.get_memory_address_or_null())
    }
}
```

`src/tab_viewer/bb_graph.rs`:

```rs
use std::collections::HashMap;

use egui::{Color32, Direction, InnerResponse, Layout, MenuBar, Painter, Pos2, Rect, Scene, Stroke, Ui, UiBuilder, Vec2};
use egui_graphs::{
    generate_simple_digraph, DefaultEdgeShape,  DefaultNodeShape, Graph, GraphView, LayoutHierarchical, LayoutStateHierarchical, SettingsInteraction, SettingsNavigation, SettingsStyle
};
use petgraph::{csr::DefaultIx, prelude::StableGraph, Directed};

use crate::{ir::{Address, BasicBlock}, memory::Memory, tab_viewer::{draw_bb, TabSignals}};

pub type FunctGraphView<'a> = GraphView<
    'a,
    (),
    (),
    Directed,
    DefaultIx,
    DefaultNodeShape,
    DefaultEdgeShape,
    LayoutStateHierarchical,
    LayoutHierarchical,
>;

#[derive(Clone)]
pub struct BlockGraph{
    scene_rect: Rect,
    graph: Option<Graph>,
}

pub fn arrow(painter: &Painter, origin: Pos2, vec: Vec2, stroke: impl Into<Stroke>) {
    use emath::Rot2;
    let rot = Rot2::from_angle(std::f32::consts::TAU / 10.0);
    let tip_length = 10.0_f32;
    let tip = origin + vec;
    let dir = vec.normalized();
    let stroke = stroke.into();
    painter.line_segment([origin, tip], stroke);
    painter.line_segment([tip, tip - tip_length * (rot * dir)], stroke);
    painter.line_segment([tip, tip - tip_length * (rot.inverse() * dir)], stroke);
}

impl BlockGraph {
    pub fn new() -> Self {
        Self { scene_rect: Rect::ZERO  , graph:None}
    }
    pub fn draw(&mut self, ui: &mut Ui, mem:&Memory, current_function:Option<Address>, signals:&mut TabSignals) {
        let mut reset_view = false; 
        MenuBar::new().ui(ui, |ui| {
            reset_view = ui.button("Reset view").clicked();
        });

        if self.graph.is_none() {
            let g = if let Some(addr) = current_function {
                let hf = mem.functions.get(&addr).unwrap();
                (&hf.cfg).into()
            } else {
                let g = petgraph::stable_graph::StableGraph::new();
                egui_graphs::Graph::from(&g)
            };
            self.graph = Some(g);
        }

        egui::Frame::group(ui.style())
            .inner_margin(0.0)
            .show(ui, |ui| {
                if let Some(g) = self.graph.as_mut() {

                    if let Some(pos) = signals.is_requested_pos() {
                        let hf = mem.functions.get(&current_function.unwrap()).unwrap();
                        // todo!("Convert arbitrary addresses to CFG node addresses.");
                        let idx = hf.cfg.get_node_idx(pos);
                        let node = g.node(idx.into()).unwrap();
                        let pos = node.display().pos;
                        let min = Pos2::new(pos.x - 1.0, pos.y - 1.0);
                        let max = Pos2::new(pos.x + 1.0, pos.y + 1.0);
                        g.set_bounds(Rect { min, max});

                    }

                    let vis = FunctGraphView::new(g);
                    let mut vis  = vis.with_navigations(&SettingsNavigation::new()
                        .with_fit_to_screen_enabled(false)
                        .with_zoom_and_pan_enabled(true)
                    ).with_styles(&SettingsStyle::new()
                        .with_labels_always(true)
                    ).with_interactions(&SettingsInteraction::new()
                        .with_dragging_enabled(true)
                        .with_node_clicking_enabled(true)
                        .with_edge_clicking_enabled(false)
                    );


                    
                    if ui.add(&mut vis).clicked() {
                        if let Some(n) = g.hovered_node() {
                            if let Some(addr) = current_function {
                                let hf = mem.functions.get(&addr).unwrap();
                                signals.request_pos(hf.cfg[n.index() as u32]);
                            }
                        }
                    }
                }   
            });

    }
}
```

`src/tab_viewer/decompiler.rs`:

```rs
use std::{borrow::Cow, collections::HashMap};

use egui::{text::LayoutJob, Color32, Grid, InnerResponse, Pos2, Rect, Response, RichText, Spacing, Stroke, Style, Ui, Vec2};

use crate::{ir::*, memory::Memory, tab_viewer::TabSignals};

use super::{CodeTheme, TokenType};
    

fn vertical<R>(ui:&mut Ui, add_contents: impl FnOnce(&mut Ui) -> R) -> InnerResponse<R> {
    let ui_builder = egui::UiBuilder::new().layout(egui::Layout::top_down(egui::Align::Min));
    let ui_builder = ui_builder.style(Style{spacing:Spacing{item_spacing:Vec2::new(0.0, 0.0), ..Default::default()}, ..Default::default()});
    ui.scope_builder(
            ui_builder,
            add_contents,
        )
}

#[derive(Clone)]
pub struct Decompiler{
    theme:CodeTheme,
    interned_tokens:HashMap<&'static str, RichText>,
}


impl Decompiler {
    pub fn new(style: &Style) -> Self {
        let theme = CodeTheme::from_style(style);
        let interned_tokens = HashMap::from([
            ("if", theme.make_rich(TokenType::Keyword, "if ")),
            ("else", theme.make_rich(TokenType::Keyword, "else ")),
            ("while", theme.make_rich(TokenType::Keyword, "while ")),
            ("return", theme.make_rich(TokenType::Keyword, "return ")),
            ("deref", theme.make_rich(TokenType::Punctuation, "*")),
            ("(", theme.make_rich(TokenType::Punctuation, "(")),
            (")", theme.make_rich(TokenType::Punctuation, ")")),
            ("{", theme.make_rich(TokenType::Punctuation, "{")),
            ("}", theme.make_rich(TokenType::Punctuation, "}")),
            ("=", theme.make_rich(TokenType::Punctuation, " = ")),
            ("==", theme.make_rich(TokenType::Punctuation, " == ")),
            ("!=", theme.make_rich(TokenType::Punctuation, " != ")),
            ("+", theme.make_rich(TokenType::Punctuation, " + ")),
            ("-", theme.make_rich(TokenType::Punctuation, " - ")),
            (">", theme.make_rich(TokenType::Punctuation, " > ")),
            (">=", theme.make_rich(TokenType::Punctuation, " >= ")),
            ("<", theme.make_rich(TokenType::Punctuation, " < ")),
            ("<=", theme.make_rich(TokenType::Punctuation, " <= ")),
            ("<<", theme.make_rich(TokenType::Punctuation, " << ")),
            (">>", theme.make_rich(TokenType::Punctuation, " >> ")),
            ("&", theme.make_rich(TokenType::Punctuation, " & ")),
            ("|", theme.make_rich(TokenType::Punctuation, " | ")),
            (",", theme.make_rich(TokenType::Punctuation, ", ")),
            (";", theme.make_rich(TokenType::Punctuation, ";")),
            (" ", theme.make_rich(TokenType::Whitespace, " ")),
        ]);
        Self { theme, interned_tokens }
        
    }
    fn mk_color(&self, lbl: &'static str) -> RichText {
        self.interned_tokens[lbl].clone()
    }

    pub fn draw(&mut self, ui: &mut Ui, mem:&Memory, current_function:Option<Address>, signals:&mut TabSignals) {
        if let Some(addr) = current_function {
            let hf = mem.functions.get(&addr).unwrap();
            let entry = mem.ast.get(&addr).unwrap().entry();
            ui.spacing_mut().item_spacing = Vec2::ZERO;
            self.draw_at_pos(ui, signals, mem, hf, entry, 0);
        }
    }

    fn draw_at_pos(&mut self, ui:&mut Ui, signals: &mut TabSignals, mem:&Memory, hf:&HighFunction, stmt:&AstStatement, depth:u8) {
        let mut tab_prefix = String::with_capacity((depth*2) as usize);
        for _ in 0..(depth*2) { // 2 spaces per depth
            tab_prefix.push(' ');
        }
        let tab_prefix = self.theme.make_rich(TokenType::Whitespace, tab_prefix);

        match stmt {
            AstStatement::Block(v) => {
                for stmt in v {
                    self.draw_at_pos(ui, signals, mem, hf, stmt, depth);
                }
            }
            AstStatement::Nop => (),
            AstStatement::If{sese: pts, condition, true_statement, true_branch, else_statement, else_branch} => {
                let mut if_rect = Rect::NOTHING;
                ui.horizontal(|ui| {
                    ui.label(tab_prefix.clone());
                    let if_keyword = ui.label(self.mk_color("if"));
                    if_rect = if_keyword.rect;
                    if if_keyword.clicked() {
                        signals.request_pos(pts.0);
                    }
                    if if_keyword.hovered() {
                        if_keyword.highlight();
                        ui.ctx().set_cursor_icon(egui::CursorIcon::PointingHand);
                    }
                    ui.label(self.mk_color("("));
                    self.draw_expression(ui, signals, mem, hf, condition, *pts, condition.get_entry_point(), false);
                    ui.label(self.mk_color(")"));
                    ui.label(self.mk_color(" "));
                    let block_start = ui.label(self.mk_color("{"));
                    if block_start.clicked() {
                        signals.request_pos(*true_branch);
                    }
                    if block_start.hovered() {
                        block_start.highlight();
                        ui.ctx().set_cursor_icon(egui::CursorIcon::PointingHand);
                    }
                });
                self.draw_at_pos(ui, signals, mem, hf, true_statement, depth+1);
                ui.horizontal(|ui| {
                    ui.label(tab_prefix.clone());
                    let end_rect = ui.label(self.mk_color("}")).rect;
                    if depth != 0 {
                        ui.painter().line(vec![Pos2{x:if_rect.min.x+2., y:if_rect.max.y+2.}, Pos2{x:end_rect.min.x+2., y:end_rect.min.y-2.}], Stroke::new(1.0, Color32::DARK_GRAY));
                    }
                    if_rect = end_rect;
                    ui.label(self.mk_color(" "));
                    if !else_statement.is_nop() {
                        let else_keyword = ui.label(self.mk_color("else"));
                        if else_keyword.clicked() {
                            signals.request_pos(pts.0);
                        }
                        if else_keyword.hovered() {
                            else_keyword.highlight();
                            ui.ctx().set_cursor_icon(egui::CursorIcon::PointingHand);
                        }
                        let block_start = ui.label(self.mk_color("{"));
                        if block_start.clicked() {
                            signals.request_pos(*else_branch);
                        }
                        if block_start.hovered() {
                            block_start.highlight();
                            ui.ctx().set_cursor_icon(egui::CursorIcon::PointingHand);
                        }
                    }
                });
                self.draw_at_pos(ui, signals, mem, hf, else_statement, depth+1);
                if !else_statement.is_nop() {
                    ui.horizontal(|ui| {
                        ui.label(tab_prefix);
                        let else_end_rect = ui.label(self.mk_color("}")).rect;
                        if depth != 0 {
                            ui.painter().line(vec![Pos2{x:if_rect.min.x+2., y:if_rect.max.y+2.}, Pos2{x:else_end_rect.min.x+2., y:else_end_rect.min.y-2.}], Stroke::new(1.0, Color32::DARK_GRAY));
                        }
                    });
                }
            },
            AstStatement::Comment(c) => {
                ui.horizontal(|ui| {
                    ui.label(tab_prefix);
                    ui.label(self.theme.make_rich(TokenType::Comment, format!("// {c}")));
                });
            }
            AstStatement::MultilineComment(c) => {
                ui.horizontal(|ui| {
                    ui.label(tab_prefix);
                    ui.label(self.theme.make_rich(TokenType::Comment, format!("/*\n{c}\n*/")));
                });
            }
            AstStatement::Call { destination, params , call_from, sese: pts} => {
                let result = VariableSymbol::CallResult { call_from:*call_from, call_to:destination.clone() };
                ui.horizontal(|ui| {
                    ui.label(tab_prefix);
                    if let Cow::Borrowed(s) = resolve_symbol(mem, &result, hf, *pts) {
                        ui.label(self.theme.make_rich(TokenType::Type, s.kind.name.clone()));
                        ui.label(self.theme.make_rich(TokenType::Symbol, s.name.clone()));
                        ui.label(self.mk_color("="));
                    }
                    self.draw_expression(ui, signals, mem, hf, destination, *pts, destination.get_entry_point(), true);
                    ui.label(self.mk_color("("));
                    for (idx, param) in params.iter().enumerate() {
                        self.draw_expression(ui, signals, mem, hf, param, *pts, param.get_entry_point(), false);
                        if idx < params.len() - 1 {
                            ui.label(self.mk_color(","));
                        }
                    }
                    ui.label(self.mk_color(")"));
                    ui.label(self.mk_color(";"));
                });
            }
            AstStatement::Assignment{sese: pts, destination,value} => {
                ui.horizontal(|ui| {
                    ui.label(tab_prefix);
                    self.draw_expression(ui, signals, mem, hf, destination, *pts, destination.get_entry_point(), false);
                    ui.label(self.mk_color("="));
                    self.draw_expression(ui, signals, mem, hf, value, *pts, value.get_entry_point(), false);
                    ui.label(self.mk_color(";"));
                });
            }
            AstStatement::Loop { sese: pts, condition, body, body_address } => {
                let mut loop_rect = Rect::NOTHING;
                ui.horizontal(|ui| {
                    ui.label(tab_prefix.clone());
                    let while_keyword = ui.label(self.mk_color("while"));
                    loop_rect = while_keyword.rect;
                    if while_keyword.clicked() {
                        signals.request_pos(pts.0);
                    }
                    if while_keyword.hovered() {
                        while_keyword.highlight();
                        ui.ctx().set_cursor_icon(egui::CursorIcon::PointingHand);
                    }
                    ui.label(self.mk_color("("));
                    self.draw_expression(ui, signals, mem, hf, condition, *pts, condition.get_entry_point(), false);
                    ui.label(self.mk_color(")"));
                    ui.label(self.mk_color(" "));
                    ui.label(self.mk_color("{"));
                });
                self.draw_at_pos(ui, signals, mem, hf, body, depth+1);
                ui.horizontal(|ui| {
                    ui.label(tab_prefix);
                    let end_rect = ui.label(self.mk_color("}")).rect;
                    if depth != 0 {
                        ui.painter().line(vec![Pos2{x:loop_rect.min.x+2., y:loop_rect.max.y+2.}, Pos2{x:end_rect.min.x+2., y:end_rect.min.y-2.}], Stroke::new(1.0, Color32::DARK_GRAY));
                    }
                });
            },
            AstStatement::Return { sese: pts, result } => {
                ui.horizontal(|ui| {
                    ui.label(tab_prefix);
                    ui.label(self.mk_color("return"));
                    // println!("Trying to resolve {result} ({result:?})");
                    self.draw_expression(ui, signals, mem, hf, result, *pts, result.get_entry_point(), false);
                    ui.label(self.mk_color(";"));
                });
            }
            AstStatement::Function { name, args, body} => {
                ui.horizontal(|ui| {
                    ui.label(tab_prefix);
                    ui.label(self.theme.make_rich(TokenType::Symbol, name));
                    ui.label(self.mk_color("("));
                    for (idx, arg) in args.iter().enumerate() {
                        let sym = resolve_symbol(mem, &arg, hf, hf.pts.root);
                        ui.label(self.theme.make_rich(TokenType::Type, sym.kind.name.clone()));
                        ui.label(self.theme.make_rich(TokenType::Symbol, sym.name.clone()));
                        if idx < args.len() - 1 {
                            ui.label(self.mk_color(","));
                        }
                    }
                    ui.label(self.mk_color(")"));
                    ui.label(self.mk_color(" "));
                    ui.label(self.mk_color("{"));
                });
                self.draw_at_pos(ui, signals, mem, hf, body, depth+1);
                ui.label(self.mk_color("}"));
            },
            a => {
                ui.horizontal(|ui| {
                    ui.label(tab_prefix);
                    ui.label(self.theme.make_rich(TokenType::Comment, format!("// unsupported statement: {a:?}")));
                });
            }
        }
    }

    fn draw_dereference(&self, ui:&mut Ui, signals: &mut TabSignals, mem:&Memory, hf:&HighFunction, e:&Expression, ip_block:SingleEntrySingleExit<Address>, pos:usize) {
        match &e[pos] {
            ExpressionOp::Value(v) => {
                let sym = resolve_symbol(mem, &VariableSymbol::Ram(Expression::from(*v)), hf, ip_block);
                let mut label = ui.label(self.theme.make_rich(TokenType::Symbol, sym.name.clone()));
                if label.clicked() {
                    signals.request_pos(Address(*v as u64));
                }
                label = label.on_hover_text("Deference::Value");
                if label.hovered() {
                    label.highlight();
                    ui.ctx().set_cursor_icon(egui::CursorIcon::PointingHand);
                }
            },
            ExpressionOp::Variable(v) => {
                let sym = resolve_symbol(mem, v, hf, ip_block);
                ui.label(self.mk_color("deref"));
                let label = ui.label(self.theme.make_rich(TokenType::Symbol, sym.name.clone()));
                label.on_hover_text("Deference::Variable");
            },
            a => {
                let var = VariableSymbol::Ram(e.get_sub_expression(pos));
                if let Cow::Borrowed(sym) = resolve_symbol(mem, &var, hf, ip_block) {
                    let label = ui.label(self.theme.make_rich(TokenType::Symbol, sym.name.clone()));
                    label.on_hover_text("Deference::ComplexExpression");
                } else {
                    ui.label(self.mk_color("deref"));
                    ui.label(self.mk_color("("));
                    ui.label(self.theme.make_rich(TokenType::Symbol, format!("Todo:Deref{a:?}")));
                    ui.label(self.mk_color(")"));
                }

            }
        }
    }


    fn draw_expression(&self, ui:&mut Ui, signals: &mut TabSignals, mem:&Memory, hf:&HighFunction, e:&Expression, ip_block:SingleEntrySingleExit<Address>, pos:usize, is_call:bool) {
        match &e[pos] {
            ExpressionOp::Dereference(d) => {
                self.draw_dereference(ui, signals, mem, hf, e, ip_block, *d);
            },
            ExpressionOp::Equals(l, r) => {
                self.draw_expression(ui, signals, mem, hf, e, ip_block, *l, is_call);
                ui.label(self.mk_color("=="));
                self.draw_expression(ui, signals, mem, hf, e, ip_block, *r, is_call)

            },
            ExpressionOp::Value(v) => {
                
                if is_call {
                    let sym = resolve_symbol(mem, &VariableSymbol::Ram(Expression::from(*v)), hf, ip_block);
                    let mut label = ui.label(self.theme.make_rich(TokenType::Symbol, sym.name.clone()));
                    if label.clicked() {
                        signals.request_pos(Address(*v as u64));
                    }
                    label = label.on_hover_text("Expression::Value");
                    if label.hovered() {
                        label.highlight();
                        ui.ctx().set_cursor_icon(egui::CursorIcon::PointingHand);
                    }
                } else {
                    ui.label(self.theme.make_rich(TokenType::NumericalLiteral, if *v < 1024 { format!("{v}") } else { format!("0x{v:x}")} ));
                }
            },
            ExpressionOp::Variable(v) => {
                let sym = resolve_symbol(mem, v, hf, ip_block);
                // println!("Resolving {v} to {}", sym.name);
                let label = ui.label(self.theme.make_rich(TokenType::Symbol, sym.name.clone()));
                label.on_hover_text("Expression::Variable");
            },
            ExpressionOp::NotEquals(l, r) => {
                self.draw_expression(ui, signals, mem, hf, e, ip_block, *l, is_call);
                ui.label(self.mk_color("!="));
                self.draw_expression(ui, signals, mem, hf, e, ip_block, *r, is_call);
            },
            ExpressionOp::Add(l, r) => {
                self.draw_expression(ui, signals, mem, hf, e, ip_block, *l, is_call);
                ui.label(self.mk_color("+"));
                self.draw_expression(ui, signals, mem, hf, e, ip_block, *r, is_call);
            },
            ExpressionOp::Sub(l, r) => {
                self.draw_expression(ui, signals, mem, hf, e, ip_block, *l, is_call);
                ui.label(self.mk_color("-"));
                self.draw_expression(ui, signals, mem, hf, e, ip_block, *r, is_call);
            },
            ExpressionOp::And(l, r) => {
                self.draw_expression(ui, signals, mem, hf, e, ip_block, *l, is_call);
                ui.label(self.mk_color("&"));
                self.draw_expression(ui, signals, mem, hf, e, ip_block, *r, is_call);
            },
            ExpressionOp::BitShiftLeft(l, r) => {
                self.draw_expression(ui, signals, mem, hf, e, ip_block, *l, is_call);
                ui.label(self.mk_color("<<"));
                self.draw_expression(ui, signals, mem, hf, e, ip_block, *r, is_call);
            },
            ExpressionOp::BitShiftRight(l, r) => {
                self.draw_expression(ui, signals, mem, hf, e, ip_block, *l, is_call);
                ui.label(self.mk_color(">>"));
                self.draw_expression(ui, signals, mem, hf, e, ip_block, *r, is_call);
            },
            ExpressionOp::Greater(l, r) => {
                self.draw_expression(ui, signals, mem, hf, e, ip_block, *l, is_call);
                ui.label(self.mk_color(">"));
                self.draw_expression(ui, signals, mem, hf, e, ip_block, *r, is_call);
            },
            ExpressionOp::GreaterOrEquals(l, r) => {
                self.draw_expression(ui, signals, mem, hf, e, ip_block, *l, is_call);
                ui.label(self.mk_color(">="));
                self.draw_expression(ui, signals, mem, hf, e, ip_block, *r, is_call);
            },
            ExpressionOp::Less(l, r) => {
                self.draw_expression(ui, signals, mem, hf, e, ip_block, *l, is_call);
                ui.label(self.mk_color("<"));
                self.draw_expression(ui, signals, mem, hf, e, ip_block, *r, is_call);
            },
            ExpressionOp::LessOrEquals(l, r) => {
                self.draw_expression(ui, signals, mem, hf, e, ip_block, *l, is_call);
                ui.label(self.mk_color("<="));
                self.draw_expression(ui, signals, mem, hf, e, ip_block, *r, is_call);
            }
            op => _ = ui.label(self.theme.make_rich(TokenType::Symbol, format!("TODO:Draw{op:?}"))),
        }
    }
}

fn resolve_symbol<'a>(mem:&'a Memory, dst:&VariableSymbol, hf:&'a HighFunction, ip_block:SingleEntrySingleExit<Address>) -> Cow<'a, VariableDefinition> {
    if let Some(def) = mem.symbols.resolve(dst)
        .or_else(|| mem.ast.get(&hf.cfg.start).unwrap().scope.get_symbol(ip_block, dst)) 
    {
        Cow::Borrowed(def)
    } else {
        Cow::Owned(VariableDefinition { kind: VariableType { name: "void *".to_owned() }, name: format!("unresolved_({dst})",), variable: dst.clone() })
    }
}
```

`src/tab_viewer/instruction_view.rs`:

```rs
use std::{collections::HashMap, hash::{Hash, Hasher}};

use eframe::egui;
use egui::{scroll_area, Color32, Grid, Id, InnerResponse, LayerId, NumExt, Rect, Response, ScrollArea, Sense, Spacing, Stroke, Style, Ui, UiBuilder, Vec2};
use egui_extras::{Column, TableBuilder};
use iced_x86::{Code, Formatter, FormatterOutput, Instruction, NasmFormatter};
use nodit::InclusiveInterval;

use crate::{ir::{Address, BasicBlock, Expression, HighFunction}, memory::Memory, tab_viewer::TabSignals};
use super::{CodeTheme, TokenType};
pub struct InstructionsView<'t, T> {
    salt: T,
    theme:&'t CodeTheme,
    block:Option<&'t BasicBlock>,
    function:Option<&'t HighFunction>,
}

struct EguiFormatterOutput<'t>{
    theme:&'t CodeTheme,
    grid:&'t mut  Ui,
}

impl<'t> FormatterOutput for EguiFormatterOutput<'t> {
    fn write(&mut self, text: &str, kind: iced_x86::FormatterTextKind) {
        match kind {
            iced_x86::FormatterTextKind::Text => self.grid.label(self.theme.make_rich(TokenType::StringLiteral, text)),
            iced_x86::FormatterTextKind::Directive => self.grid.label(self.theme.make_rich(TokenType::Keyword, text)),
            iced_x86::FormatterTextKind::Prefix => self.grid.label(self.theme.make_rich(TokenType::Keyword, text)),
            iced_x86::FormatterTextKind::Mnemonic => self.grid.label(self.theme.make_rich(TokenType::Keyword, text)),
            iced_x86::FormatterTextKind::Keyword => self.grid.label(self.theme.make_rich(TokenType::Keyword, text)),
            iced_x86::FormatterTextKind::Operator => self.grid.label(self.theme.make_rich(TokenType::StringLiteral, text)),
            iced_x86::FormatterTextKind::Punctuation => self.grid.label(self.theme.make_rich(TokenType::Punctuation, text)),
            iced_x86::FormatterTextKind::Number => self.grid.label(self.theme.make_rich(TokenType::Symbol, text)),
            iced_x86::FormatterTextKind::Register => self.grid.label(self.theme.make_rich(TokenType::Punctuation, text)),
            iced_x86::FormatterTextKind::Decorator => self.grid.label(self.theme.make_rich(TokenType::Punctuation, text)),
            iced_x86::FormatterTextKind::SelectorValue => self.grid.label(self.theme.make_rich(TokenType::StringLiteral, text)),
            iced_x86::FormatterTextKind::LabelAddress => self.grid.label(self.theme.make_rich(TokenType::StringLiteral, text)),
            iced_x86::FormatterTextKind::FunctionAddress => self.grid.label(self.theme.make_rich(TokenType::Symbol, text)),
            iced_x86::FormatterTextKind::Data => self.grid.label(self.theme.make_rich(TokenType::Punctuation, text)),
            iced_x86::FormatterTextKind::Label => self.grid.label(self.theme.make_rich(TokenType::StringLiteral, text)),
            iced_x86::FormatterTextKind::Function => self.grid.label(self.theme.make_rich(TokenType::Symbol, text)),
            _ => self.grid.label(self.theme.make_rich(TokenType::Comment, text)),
        };
    }
}

fn horizontal<R>(ui:&mut Ui, add_contents: impl FnOnce(&mut Ui) -> R) -> InnerResponse<R> {
    let ui_builder = egui::UiBuilder::new().layout(egui::Layout::left_to_right(egui::Align::Min));
    let ui_builder = ui_builder.style(Style{spacing:Spacing{item_spacing:Vec2::new(0.0, 0.0), ..Default::default()}, ..Default::default()});
    ui.scope_builder(
            ui_builder,
            add_contents,
        )
}

fn draw_line(theme:&CodeTheme, grid:&mut Ui, i:&Instruction, formatter:&mut NasmFormatter, basic_expression:Option<&crate::ir::Expression>, composed_expression:Option<&crate::ir::Expression>) {
    
    grid.label(theme.make_rich(TokenType::Punctuation, format!("{}", Address(i.ip()))));
    
    
    horizontal(grid, |cell| {
        let mut egui = EguiFormatterOutput{theme, grid:cell};
        formatter.format_mnemonic_options(i, &mut egui, 0);
    });
    
   horizontal(grid, |operands| {
        let mut egui = EguiFormatterOutput{
            theme,
            grid:operands,
        };
        formatter.format_all_operands(i, &mut egui);
    });

    
    if let Some(e) = composed_expression {
        grid.label(theme.make_rich(TokenType::Comment, format!(" ; {e}")));
    } else {
        if let Some(e) = basic_expression {
            grid.label(theme.make_rich(TokenType::Comment, format!(" ; {e}")));
        } else {
            grid.label(theme.make_rich(TokenType::Comment, format!(" ; {:?}", i.code())));
        }
    }
    let min = grid.min_rect().width();
    let clip = grid.clip_rect().width();

    if clip > min {
        grid.allocate_at_least(Vec2 { x: clip-min, y: 16.0 }, Sense::empty());
    }
    grid.end_row();
}

impl<'t, T> InstructionsView<'t, T> where T:std::hash::Hash {
    const STROKE:Stroke = Stroke{width:1.0, color:Color32::DARK_RED};
    pub fn new(salt:T, theme:&'t CodeTheme, block:Option<&'t BasicBlock>, function:Option<&'t HighFunction>) -> Self {
        Self { salt, theme, block, function }
    }

    

    pub fn draw(self, ui: &mut Ui, mem:&Memory, addr:Address) -> Response {
        
        ui.scope_builder(UiBuilder::new().sense(Sense::hover() | Sense::click()), |ui| {
                // ui.push_id(self.salt, |ui| {
                let grid = Grid::new(self.salt)
                    .striped(true)
                    .show(ui, |grid| {
                    if let Some(block) = self.block {
                        let mut formatter = NasmFormatter::new();//with_options(mem.get_symbol_resolver(), None);
                        let literals = mem.literal.get_at_point(addr).expect("Unable to get memory literal");
                        let mut iter = literals.get_instructions().iter();
                        let i = iter.find(|i| i.ip() == addr.0).expect("Unable to find instruction at address");
                        let basic_ir = block.instruction_map.get(&i.ip().into());
                        let composed_ir = self.function.and_then(|f| f.composed_blocks.get_at_point(block.address).unwrap().instruction_map.get(&i.ip().into()));
                        draw_line(self.theme, grid, i, &mut formatter, basic_ir, composed_ir);
                        while let Some(i) = iter.next() {
                            if block.get_interval().contains_point(i.ip().into()) {
                                let basic_ir = block.instruction_map.get(&i.ip().into());
                                let composed_ir = self.function.and_then(|f| f.composed_blocks.get_at_point(block.address).unwrap().instruction_map.get(&i.ip().into()));
                                draw_line(self.theme, grid, i, &mut formatter, basic_ir, composed_ir);
                            } else {
                                break;
                            }
                        }
                    }
                }).response;
                if grid.contains_pointer() {
                    ui.painter().rect(grid.interact_rect, 0.0, Color32::from_black_alpha(0), Self::STROKE, egui::StrokeKind::Outside);
                }
            // })
        }).response
    }
}

#[derive(Clone)]
pub struct BlockView{
    // pos:usize,
    theme:CodeTheme,
    addr_row_map:HashMap<Address, usize>,
    row_addr_map:Vec<Address>,
}

pub fn draw_bb(ui:&mut Ui,block:&BasicBlock, id_salt:impl std::hash::Hash) -> InnerResponse<()> {
    let header = ui.label("Known memory state at the end of this block:");
    let width = header.rect.width();
    Grid::new(id_salt).striped(true).show(ui, |ui| {
        for (addr, value) in &block.memory {
            ui.label(format!("{addr}"));
            ui.label(":=");
            ui.label(format!("{value}"));
            let min = ui.min_rect().width();
        
            if width > min {
                ui.allocate_at_least(Vec2 { x: width-min, y: 16.0 }, Sense::empty());
            }
            ui.end_row();
        }
    })
}

impl BlockView {
    const STROKE:Stroke = Stroke{width:1.0, color:Color32::RED};

    /// Needs memory reference to figure out address to display row mapping.
    pub fn new(style: &Style, mem:&Memory) -> Self {
        let (addr_row_map, row_addr_map) = map_addr(mem);
        Self { theme: CodeTheme::from_style(style), addr_row_map, row_addr_map}
    }

    pub fn draw(&mut self, ui: &mut Ui, mem:&Memory, signals:&mut TabSignals) {
        // TODO: Add whole file view:
        let mut area = ScrollArea::both()
        .auto_shrink(false);
        if let Some(addr) = signals.is_requested_pos() {
            area = area.vertical_scroll_offset((ui.spacing().interact_size.y + ui.spacing().item_spacing.y) * self.addr_row_map[&addr] as f32);
        }

        area.show_rows(ui, ui.spacing().interact_size.y, self.addr_row_map.len(), |ui, row_range| {
            let start_addr = self.row_addr_map[row_range.start];
            let last_row = if row_range.end < self.row_addr_map.len() { row_range.end } else { self.row_addr_map.len() - 1};
            let end_addr = self.row_addr_map[last_row];
            let mut current_addr = start_addr;
            while current_addr < end_addr {
                let literal = mem.literal.get_at_point(current_addr).unwrap();
                match &literal.kind {
                    crate::memory::LiteralKind::Data(data_kind) => todo!(),
                    crate::memory::LiteralKind::Instruction(instructions) => {
                        let mut current_block_span: Option<&BasicBlock> = None;
                        let mut current_function: Option<&HighFunction> = None;
                        for instr in instructions {
                            let mut should_draw = false;
                            if instr.ip() >= current_addr.0 && instr.ip() < end_addr.0 {
                                if let Some(block) = current_block_span  {
                                    if !block.get_interval().contains_point(instr.ip().into()) {
                                        current_block_span = mem.ir.get_at_point(instr.ip().into());
                                        current_function = current_block_span.and_then(|b| mem.functions.get(&b.parent_function));
                                        should_draw =  true;
                                    }
                                } else {
                                    current_block_span = mem.ir.get_at_point(instr.ip().into());
                                    current_function = current_block_span.and_then(|b| mem.functions.get(&b.parent_function));
                                    should_draw = true;
                                }

                                if should_draw { // draw single line of the view
                                    let r = InstructionsView::new(instr.ip(), &self.theme, current_block_span, current_function).draw(ui, mem, instr.ip().into());
                                    r.on_hover_ui(|hover| {
                                        if let (Some(bb), Some(hf))  = (current_block_span, current_function) {
                                            let bb = hf.composed_blocks.get_at_point(bb.address).unwrap();
                                            draw_bb(hover, bb, bb.address);
                                        }
                                    });
                                    current_addr = instr.next_ip().into();
                                }
                            }
    
                        }
                    }
                }
            }
        });
    }
}

fn map_addr(mem:&Memory) -> (HashMap<Address, usize>, Vec<Address>) {
    let mut ar_map = HashMap::new();
    let mut ra_map = Vec::new();
    for (_, data) in mem.literal.iter() {
        match &data.kind {
            crate::memory::LiteralKind::Data(data_kind) => todo!(),
            crate::memory::LiteralKind::Instruction(instructions) => {
                for instr in instructions {
                    let row = ar_map.len();
                    let addr = Address(instr.ip());
                    ar_map.insert(addr, row);
                    ra_map.push(addr);
                }
            }
        }
    }
    (ar_map, ra_map)
}
```

`src/tab_viewer/mod.rs`:

```rs
use std::ops::Add;

use egui::Popup;
use egui_dock::tab_viewer::OnCloseResponse;

use crate::{ir::Address,  memory::Memory, DecompilerApp};

mod theme;
mod instruction_view;
mod decompiler;
mod bb_graph;

pub use theme::{CodeTheme, TokenType};

pub use instruction_view::{InstructionsView, BlockView, draw_bb};
pub use decompiler::{Decompiler};
pub use bb_graph::BlockGraph;

enum SignalKind {
    RequestPos(Address),
    Other
}

pub struct TabSignals{
    new_signals:Vec<SignalKind>,
    signals:Vec<SignalKind>,
}

impl TabSignals {
    pub fn new() -> Self {
        Self { 
            new_signals:Vec::new(),
            signals:Vec::new()
        }
    }

    pub fn is_requested_pos(&self) -> Option<Address> {
        self.signals.iter().find_map(|p| if let SignalKind::RequestPos(p) = p { Some(*p) } else { None })
    }

    pub fn request_pos(&mut self, addr:Address) {
        use SignalKind::RequestPos;
        self.new_signals.push(RequestPos(addr));
    }

    pub fn new_frame(&mut self) {
        let new = std::mem::take(&mut self.new_signals);
        let mut old = std::mem::take(&mut self.signals);
        self.signals = new;
        old.clear();
        self.new_signals = old;
    }
}

pub struct TabViewer<'m> {
    pub memory:&'m Memory<'m>,
    pub current_function: Option<Address>,
    pub signals: &'m mut TabSignals
}

#[derive(Clone)]
pub enum TabKind {
    ASM(BlockView),
    Decompiler(Decompiler),
    BlockGraph(BlockGraph),
    // Terminal(Terminal),
}

impl PartialEq for TabKind {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::ASM(_), Self::ASM(_)) |
            (Self::BlockGraph(_), Self::BlockGraph(_)) => true,
            (Self::Decompiler(_), Self::Decompiler(_)) => true,
            _ => false,
        }
    }
}

impl Eq for TabKind {}

impl<'m> TabViewer<'m> {
    pub fn new(memory: &'m Memory, current_function:Option<Address>, signals:&'m mut TabSignals) -> Self {
        Self { memory, current_function, signals}
    }
}

impl<'m> egui_dock::TabViewer for TabViewer<'m> {
    type Tab = TabKind;

    fn title(&mut self, tab: &mut Self::Tab) -> egui::WidgetText {
        match tab {
            TabKind::ASM(_) => "Listing".into(),
            TabKind::Decompiler(d) => self.current_function.map(|f| format!("Decompile: FUN_{:x}", f.0)).unwrap_or("Decompile: No function".into()).into(),
            TabKind::BlockGraph(d) => self.current_function.map(|f| format!("Block graph: FUN_{:x}", f.0)).unwrap_or("Block graph: No function".into()).into()

        }
    }

    fn ui(&mut self, ui: &mut egui::Ui, tab: &mut Self::Tab) {
        match tab {
            TabKind::ASM(l) => {
                l.draw(ui, self.memory, &mut self.signals);
            },
            TabKind::Decompiler(b) => {
                b.draw(ui, self.memory, self.current_function, &mut self.signals);
            },
            TabKind::BlockGraph(b) => b.draw(ui, self.memory, self.current_function, &mut self.signals)
        }
    }
}
```

`src/tab_viewer/theme.rs`:

```rs
use egui::{Color32, RichText};

#[derive(Clone, Copy, PartialEq, enum_map::Enum)]
pub enum TokenType {
    Comment,
    Keyword,
    Symbol,
    Type,
    StringLiteral,
    NumericalLiteral,
    Punctuation,
    Whitespace,
}

#[derive(Clone, Copy)]
struct TokenStyle {
    color:Color32,
    strong:bool,
    underlined:bool
}

#[derive(Clone)]
pub struct CodeTheme {
    dark_mode: bool,
    font_id: egui::FontId,
    formats:enum_map::EnumMap<TokenType, TokenStyle>
}
impl CodeTheme {
    pub fn from_style(style: &egui::Style) -> Self {
        let font_id = style
            .override_font_id
            .clone()
            .unwrap_or_else(|| egui::TextStyle::Monospace.resolve(style));

        if style.visuals.dark_mode {
            Self::dark_with_font_id(font_id)
        } else {
            Self::light_with_font_id(font_id)
        }
    }
    fn dark_with_font_id(font_id: egui::FontId) -> Self {
        use egui::{Color32, TextFormat};
        Self {
            font_id,
            dark_mode: true,
            formats: enum_map::enum_map![
                TokenType::Comment => TokenStyle{color:Color32::from_gray(120), strong:false, underlined:false},
                TokenType::Keyword => TokenStyle{color:Color32::from_rgb(255, 100, 100), strong:true, underlined:false},
                TokenType::Symbol => TokenStyle{color:Color32::from_rgb(200, 200, 171), strong:false, underlined:false},
                TokenType::Type => TokenStyle{color:Color32::from_rgb(109, 147, 226), strong:true, underlined:false},
                TokenType::StringLiteral => TokenStyle{color:Color32::from_rgb(109, 226, 147), strong:false, underlined:false},
                TokenType::NumericalLiteral => TokenStyle{color:Color32::from_rgb(16, 147, 226), strong:false, underlined:false},
                TokenType::Punctuation => TokenStyle{color:Color32::LIGHT_GRAY, strong:false, underlined:false},
                TokenType::Whitespace => TokenStyle{color:Color32::TRANSPARENT, strong:false, underlined:false},
            ],
        }
    }

    fn light_with_font_id(font_id: egui::FontId) -> Self {
        use egui::{Color32, TextFormat};
        Self {
            font_id,
            dark_mode: false,
            formats: enum_map::enum_map![
                TokenType::Comment => TokenStyle{color:Color32::GRAY, strong:false, underlined:false},
                TokenType::Keyword => TokenStyle{color:Color32::from_rgb(235, 0, 0), strong:true, underlined:false},
                TokenType::Symbol => TokenStyle{color:Color32::from_rgb(153, 134, 255), strong:false, underlined:false},
                TokenType::Type => TokenStyle{color:Color32::from_rgb(109, 226, 147), strong:true, underlined:false},
                TokenType::StringLiteral => TokenStyle{color:Color32::from_rgb(37, 203, 105), strong:false, underlined:false},
                TokenType::NumericalLiteral => TokenStyle{color:Color32::from_rgb(16, 147, 226), strong:false, underlined:false},
                TokenType::Punctuation => TokenStyle{color:Color32::DARK_GRAY, strong:false, underlined:false},
                TokenType::Whitespace => TokenStyle{color:Color32::TRANSPARENT, strong:false, underlined:false},
            ],
        }
    }

    pub fn make_rich(&self, token:TokenType, string:impl Into<String>) -> RichText {
        let theme = &self.formats[token];
        let mut r = RichText::new(string).font(self.font_id.clone()).color(theme.color);
        if theme.strong {
            r = r.strong()
        }
        if theme.underlined {
            r = r.underline()
        }
        r
    }
}
```

`src/test.rs`:

```rs

pub const EXAMPLE_CODE_BITNESS: u32 = 32;
pub const EXAMPLE_CODE_RIP: u64 = 0x4b14b0;
pub static EXAMPLE_CODE: &[u8] = &[
 0x8b, 0x44, 0x24, 0x08, 0x81, 0xec, 0xa0, 0x00, 0x00, 0x00, 0x53, 0x55, 0x56, 0x8b, 0xb4, 0x24, 0xb0, 0x00, 0x00, 0x00, 0x57, 0x56, 0x89, 0x35, 0x84, 0x10, 0x61, 0x00, 0x89, 0x35, 0x18, 0x92, 0x66, 0x00, 0xa3, 0xa0, 0x28, 0x61, 0x00, 0xe8, 0x14, 0xf3, 0xff, 0xff, 0x33, 0xff, 0x83, 0xc4, 0x04, 0x3b, 0xc7, 0x74, 0x16, 0xff, 0x40, 0x14, 0x89, 0x3d, 0x18, 0x92, 0x66, 0x00, 0x8b, 0x00, 0x5f, 0x5e, 0x5d, 0x5b, 0x81, 0xc4, 0xa0, 0x00, 0x00, 0x00, 0xc3, 0x39, 0x3d, 0xcc, 0x8f, 0x66, 0x00, 0x74, 0x09, 0x56, 0xe8, 0x27, 0xf2, 0xff, 0xff, 0x83, 0xc4, 0x04, 0x56, 0xe8, 0xfe, 0xfd, 0xfe, 0xff, 0x83, 0xc4, 0x04, 0x83, 0xf8, 0xff, 0x75, 0x13, 0x89, 0x3d, 0x18, 0x92, 0x66, 0x00, 0x5f, 0x5e, 0x5d, 0x33, 0xc0, 0x5b, 0x81, 0xc4, 0xa0, 0x00, 0x00, 0x00, 0xc3, 0x8d, 0x4c, 0x24, 0x14, 0x68, 0x9c, 0x00, 0x00, 0x00, 0x51, 0xe8, 0x54, 0xff, 0xfe, 0xff, 0x8b, 0x54, 0x24, 0x54, 0x57, 0x52, 0xe8, 0xa9, 0xff, 0xfe, 0xff, 0x8b, 0x44, 0x24, 0x24, 0x83, 0xc4, 0x10, 0x3d, 0x33, 0x44, 0x50, 0x4b, 0x74, 0x18, 0xe8, 0xc6, 0xfc, 0xfe, 0xff, 0x89, 0x3d, 0x18, 0x92, 0x66, 0x00, 0x5f, 0x5e, 0x5d, 0x33, 0xc0, 0x5b, 0x81, 0xc4, 0xa0, 0x00, 0x00, 0x00, 0xc3, 0x8b, 0x54, 0x24, 0x4c, 0xb9, 0x9c, 0x00, 0x00, 0x00, 0x2b, 0xca, 0x8d, 0x7c, 0x14, 0x14, 0x8b, 0xd1, 0xc1, 0xe9, 0x02, 0x33, 0xc0, 0xf3, 0xab, 0x8b, 0xca, 0x83, 0xe1, 0x03, 0xf3, 0xaa, 0x8b, 0x4c, 0x24, 0x4c, 0x8b, 0x5c, 0x24, 0x50, 0x8b, 0x6c, 0x24, 0x54, 0xb8, 0x9c, 0x00, 0x00, 0x00, 0x2b, 0xc1, 0x2b, 0xd9, 0x81, 0xc3, 0x9c, 0x00, 0x00, 0x00, 0x03, 0xe8, 0x53, 0x89, 0x44, 0x24, 0x78, 0x89, 0x6c, 0x24, 0x58, 0xc7, 0x44, 0x24, 0x50, 0x9c, 0x00, 0x00, 0x00, 0xe8, 0x01, 0xb0, 0xfe, 0xff, 0x8b, 0x4c, 0x24, 0x50, 0x8b, 0xe8, 0x8b, 0xc1, 0xc1, 0xe9, 0x02, 0x8d, 0x74, 0x24, 0x18, 0x8b, 0xfd, 0xf3, 0xa5, 0x8b, 0xc8, 0x83, 0xe1, 0x03, 0xf3, 0xa4, 0x8b, 0x44, 0x24, 0x50, 0x2b, 0xd8, 0x8d, 0x34, 0x28, 0x53, 0x56, 0x89, 0x74, 0x24, 0x1c, 0xe8, 0xa3, 0xfe, 0xfe, 0xff, 0x8b, 0x9c, 0x24, 0xc0, 0x00, 0x00, 0x00, 0x6a, 0x1f, 0x8d, 0x4d, 0x70, 0x53, 0x51, 0xe8, 0xd0, 0xb7, 0x00, 0x00, 0xa1, 0x24, 0xc1, 0x62, 0x00, 0x8b, 0x55, 0x28, 0x83, 0xc4, 0x18, 0x85, 0xc0, 0x89, 0x15, 0x94, 0x8f, 0x66, 0x00, 0x74, 0x28, 0x8b, 0x44, 0x24, 0x54, 0x2b, 0x44, 0x24, 0x50, 0x50, 0xe8, 0x9d, 0xaf, 0xfe, 0xff, 0x8b, 0x4c, 0x24, 0x58, 0x2b, 0x4c, 0x24, 0x54, 0x51, 0x50, 0x89, 0x44, 0x24, 0x1c, 0xe8, 0x5a, 0xfe, 0xfe, 0xff, 0x8b, 0x74, 0x24, 0x1c, 0x83, 0xc4, 0x0c, 0xe8, 0xde, 0xfb, 0xfe, 0xff, 0x8b, 0x45, 0x04, 0x3d, 0x01, 0x20, 0x00, 0x00, 0x0f, 0x8c, 0xbf, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x00, 0x01, 0x00, 0x0f, 0x87, 0xb4, 0x00, 0x00, 0x00, 0x8b, 0x94, 0x24, 0xbc, 0x00, 0x00, 0x00, 0x52, 0x55, 0xe8, 0xf7, 0xf0, 0xff, 0xff, 0xa1, 0x24, 0xc1, 0x62, 0x00, 0x83, 0xc4, 0x08, 0x85, 0xc0, 0x74, 0x54, 0x8b, 0x45, 0x64, 0x85, 0xc0, 0x74, 0x3e, 0x8d, 0x88, 0x00, 0x06, 0x00, 0x00, 0xa3, 0x90, 0x8f, 0x66, 0x00, 0x51, 0x05, 0x00, 0x03, 0x00, 0x00, 0x50, 0xe8, 0xad, 0x17, 0xff, 0xff, 0xa1, 0x90, 0x8f, 0x66, 0x00, 0x8b, 0xf0, 0x6a, 0x01, 0xb9, 0xc0, 0x00, 0x00, 0x00, 0xbf, 0x80, 0x31, 0x60, 0x00, 0x50, 0xf3, 0xa5, 0xe8, 0xe2, 0xc3, 0xff, 0xff, 0x83, 0xc4, 0x10, 0xe8, 0xca, 0x17, 0xff, 0xff, 0x8b, 0x74, 0x24, 0x10, 0x56, 0xe8, 0xc0, 0xef, 0xff, 0xff, 0x56, 0xe8, 0x3a, 0xaf, 0xfe, 0xff, 0x83, 0xc4, 0x08, 0x55, 0xe8, 0xe1, 0xe8, 0xff, 0xff, 0x55, 0xe8, 0x7b, 0xfd, 0xff, 0xff, 0x55, 0x8b, 0xf0, 0xe8, 0x23, 0xaf, 0xfe, 0xff, 0x6a, 0x00, 0x56, 0xe8, 0x8b, 0x0c, 0x00, 0x00, 0x56, 0x89, 0x46, 0x30, 0xe8, 0xe2, 0xe7, 0xff, 0xff, 0x53, 0x56, 0xe8, 0x4b, 0xf1, 0xff, 0xff, 0x83, 0xc4, 0x20, 0x5f, 0x8b, 0xc6, 0x5e, 0x5d, 0xc7, 0x05, 0x18, 0x92, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5b, 0x81, 0xc4, 0xa0, 0x00, 0x00, 0x00, 0xc3, 0x8b, 0x15, 0x5c, 0x39, 0x60, 0x00, 0x6a, 0x00, 0x53, 0x68, 0x78, 0xec, 0x55, 0x00, 0x52, 0xff, 0x15, 0x68, 0xe2, 0x52, 0x00, 0x5f, 0x5e, 0x5d, 0xc7, 0x05, 0x18, 0x92, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0xc0, 0x5b, 0x81, 0xc4, 0xa0, 0x00, 0x00, 0x00, 0xc3 
];
```