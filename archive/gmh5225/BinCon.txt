Project Path: arc_gmh5225_BinCon_wxgttfpt

Source Tree:

```txt
arc_gmh5225_BinCon_wxgttfpt
├── BinCon
│   ├── BinCon.vcxproj
│   ├── BinCon.vcxproj.filters
│   ├── BinCon.vcxproj.user
│   ├── bc_gen.cpp
│   ├── bc_gen.h
│   ├── bc_gen_struct.h
│   ├── bc_iat.cpp
│   ├── bc_integrity.cpp
│   ├── bc_pe.cpp
│   ├── bc_peb.cpp
│   ├── bc_util.cpp
│   └── bc_windows.cpp
├── BinCon.sln
├── BinConExamples
│   ├── BinConExamples.vcxproj
│   ├── BinConExamples.vcxproj.filters
│   ├── BinConExamples.vcxproj.user
│   ├── bc_examples.cpp
│   └── bc_gen.h
├── BinConPacker
│   ├── BinConPacker.vcxproj
│   ├── BinConPacker.vcxproj.filters
│   ├── BinConPacker.vcxproj.user
│   └── packer.cpp
├── BinConPackerStub
│   ├── BinConPackerStub.vcxproj
│   ├── BinConPackerStub.vcxproj.filters
│   ├── BinConPackerStub.vcxproj.user
│   ├── crt.h
│   ├── load.cpp
│   ├── load.h
│   ├── native.asm
│   ├── packer_stub.cpp
│   ├── stub.h
│   ├── stub_inc.h
│   ├── veh.cpp
│   └── x86_emulator.cpp
├── BinConVm
│   ├── BinConVm.vcxproj
│   ├── BinConVm.vcxproj.filters
│   └── BinConVm.vcxproj.user
├── BitConBuildTime
│   ├── BitConBuildTime.vcxproj
│   ├── BitConBuildTime.vcxproj.filters
│   ├── BitConBuildTime.vcxproj.user
│   ├── bc_build_time.cpp
│   └── bc_gen.h
├── BitConTests
│   ├── BitConTests.vcxproj
│   ├── BitConTests.vcxproj.filters
│   ├── BitConTests.vcxproj.user
│   └── bc_tests.cpp
├── README.md
└── inc
    ├── bc_common.h
    ├── bc_dyn_struct.h
    ├── bc_gen.h
    ├── bc_gen_struct.h
    ├── bc_iat.h
    ├── bc_integrity.h
    ├── bc_log.h
    ├── bc_pe.h
    ├── bc_peb.h
    ├── bc_stub.h
    ├── bc_thirdparty.h
    ├── bc_undocumented.h
    ├── bc_util.h
    ├── bc_var.h
    └── bc_windows.h

```

`BinCon.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31515.178
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BinCon", "BinCon\BinCon.vcxproj", "{F76672D3-353D-4EF3-8933-1575D4F37E0A}"
	ProjectSection(ProjectDependencies) = postProject
		{D6303B99-3C59-4B39-89F2-823D1899EE5D} = {D6303B99-3C59-4B39-89F2-823D1899EE5D}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BitConTests", "BitConTests\BitConTests.vcxproj", "{D264D73C-4923-40F8-A356-289E4D1FBE6F}"
	ProjectSection(ProjectDependencies) = postProject
		{F76672D3-353D-4EF3-8933-1575D4F37E0A} = {F76672D3-353D-4EF3-8933-1575D4F37E0A}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BinConExamples", "BinConExamples\BinConExamples.vcxproj", "{5DDD1B70-C2C3-45FA-8643-DA31B8C9CBF1}"
	ProjectSection(ProjectDependencies) = postProject
		{B303DE66-A224-432A-A33D-4184C1F38324} = {B303DE66-A224-432A-A33D-4184C1F38324}
		{B3B138D3-1441-4D07-979A-663FD29FFC81} = {B3B138D3-1441-4D07-979A-663FD29FFC81}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BitConBuildTime", "BitConBuildTime\BitConBuildTime.vcxproj", "{D6303B99-3C59-4B39-89F2-823D1899EE5D}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BinConPacker", "BinConPacker\BinConPacker.vcxproj", "{B303DE66-A224-432A-A33D-4184C1F38324}"
	ProjectSection(ProjectDependencies) = postProject
		{B3B138D3-1441-4D07-979A-663FD29FFC81} = {B3B138D3-1441-4D07-979A-663FD29FFC81}
		{F76672D3-353D-4EF3-8933-1575D4F37E0A} = {F76672D3-353D-4EF3-8933-1575D4F37E0A}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BinConPackerStub", "BinConPackerStub\BinConPackerStub.vcxproj", "{B3B138D3-1441-4D07-979A-663FD29FFC81}"
	ProjectSection(ProjectDependencies) = postProject
		{D6303B99-3C59-4B39-89F2-823D1899EE5D} = {D6303B99-3C59-4B39-89F2-823D1899EE5D}
		{F76672D3-353D-4EF3-8933-1575D4F37E0A} = {F76672D3-353D-4EF3-8933-1575D4F37E0A}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BinConVm", "BinConVm\BinConVm.vcxproj", "{61E38AEF-8D23-4017-872C-9C4EC7773A42}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F76672D3-353D-4EF3-8933-1575D4F37E0A}.Debug|x64.ActiveCfg = Debug|x64
		{F76672D3-353D-4EF3-8933-1575D4F37E0A}.Debug|x64.Build.0 = Debug|x64
		{F76672D3-353D-4EF3-8933-1575D4F37E0A}.Debug|x86.ActiveCfg = Debug|Win32
		{F76672D3-353D-4EF3-8933-1575D4F37E0A}.Debug|x86.Build.0 = Debug|Win32
		{F76672D3-353D-4EF3-8933-1575D4F37E0A}.Release|x64.ActiveCfg = Release|x64
		{F76672D3-353D-4EF3-8933-1575D4F37E0A}.Release|x64.Build.0 = Release|x64
		{F76672D3-353D-4EF3-8933-1575D4F37E0A}.Release|x86.ActiveCfg = Release|Win32
		{F76672D3-353D-4EF3-8933-1575D4F37E0A}.Release|x86.Build.0 = Release|Win32
		{D264D73C-4923-40F8-A356-289E4D1FBE6F}.Debug|x64.ActiveCfg = Debug|x64
		{D264D73C-4923-40F8-A356-289E4D1FBE6F}.Debug|x64.Build.0 = Debug|x64
		{D264D73C-4923-40F8-A356-289E4D1FBE6F}.Debug|x86.ActiveCfg = Debug|Win32
		{D264D73C-4923-40F8-A356-289E4D1FBE6F}.Debug|x86.Build.0 = Debug|Win32
		{D264D73C-4923-40F8-A356-289E4D1FBE6F}.Release|x64.ActiveCfg = Release|x64
		{D264D73C-4923-40F8-A356-289E4D1FBE6F}.Release|x64.Build.0 = Release|x64
		{D264D73C-4923-40F8-A356-289E4D1FBE6F}.Release|x86.ActiveCfg = Release|Win32
		{D264D73C-4923-40F8-A356-289E4D1FBE6F}.Release|x86.Build.0 = Release|Win32
		{5DDD1B70-C2C3-45FA-8643-DA31B8C9CBF1}.Debug|x64.ActiveCfg = Debug|x64
		{5DDD1B70-C2C3-45FA-8643-DA31B8C9CBF1}.Debug|x64.Build.0 = Debug|x64
		{5DDD1B70-C2C3-45FA-8643-DA31B8C9CBF1}.Debug|x86.ActiveCfg = Debug|Win32
		{5DDD1B70-C2C3-45FA-8643-DA31B8C9CBF1}.Debug|x86.Build.0 = Debug|Win32
		{5DDD1B70-C2C3-45FA-8643-DA31B8C9CBF1}.Release|x64.ActiveCfg = Release|x64
		{5DDD1B70-C2C3-45FA-8643-DA31B8C9CBF1}.Release|x64.Build.0 = Release|x64
		{5DDD1B70-C2C3-45FA-8643-DA31B8C9CBF1}.Release|x86.ActiveCfg = Release|Win32
		{5DDD1B70-C2C3-45FA-8643-DA31B8C9CBF1}.Release|x86.Build.0 = Release|Win32
		{D6303B99-3C59-4B39-89F2-823D1899EE5D}.Debug|x64.ActiveCfg = Debug|x64
		{D6303B99-3C59-4B39-89F2-823D1899EE5D}.Debug|x64.Build.0 = Debug|x64
		{D6303B99-3C59-4B39-89F2-823D1899EE5D}.Debug|x86.ActiveCfg = Debug|Win32
		{D6303B99-3C59-4B39-89F2-823D1899EE5D}.Debug|x86.Build.0 = Debug|Win32
		{D6303B99-3C59-4B39-89F2-823D1899EE5D}.Release|x64.ActiveCfg = Release|x64
		{D6303B99-3C59-4B39-89F2-823D1899EE5D}.Release|x64.Build.0 = Release|x64
		{D6303B99-3C59-4B39-89F2-823D1899EE5D}.Release|x86.ActiveCfg = Release|Win32
		{D6303B99-3C59-4B39-89F2-823D1899EE5D}.Release|x86.Build.0 = Release|Win32
		{B303DE66-A224-432A-A33D-4184C1F38324}.Debug|x64.ActiveCfg = Debug|x64
		{B303DE66-A224-432A-A33D-4184C1F38324}.Debug|x64.Build.0 = Debug|x64
		{B303DE66-A224-432A-A33D-4184C1F38324}.Debug|x86.ActiveCfg = Debug|Win32
		{B303DE66-A224-432A-A33D-4184C1F38324}.Debug|x86.Build.0 = Debug|Win32
		{B303DE66-A224-432A-A33D-4184C1F38324}.Release|x64.ActiveCfg = Release|x64
		{B303DE66-A224-432A-A33D-4184C1F38324}.Release|x64.Build.0 = Release|x64
		{B303DE66-A224-432A-A33D-4184C1F38324}.Release|x86.ActiveCfg = Release|Win32
		{B303DE66-A224-432A-A33D-4184C1F38324}.Release|x86.Build.0 = Release|Win32
		{B3B138D3-1441-4D07-979A-663FD29FFC81}.Debug|x64.ActiveCfg = Debug|x64
		{B3B138D3-1441-4D07-979A-663FD29FFC81}.Debug|x64.Build.0 = Debug|x64
		{B3B138D3-1441-4D07-979A-663FD29FFC81}.Debug|x86.ActiveCfg = Debug|Win32
		{B3B138D3-1441-4D07-979A-663FD29FFC81}.Debug|x86.Build.0 = Debug|Win32
		{B3B138D3-1441-4D07-979A-663FD29FFC81}.Release|x64.ActiveCfg = Release|x64
		{B3B138D3-1441-4D07-979A-663FD29FFC81}.Release|x64.Build.0 = Release|x64
		{B3B138D3-1441-4D07-979A-663FD29FFC81}.Release|x86.ActiveCfg = Release|Win32
		{B3B138D3-1441-4D07-979A-663FD29FFC81}.Release|x86.Build.0 = Release|Win32
		{61E38AEF-8D23-4017-872C-9C4EC7773A42}.Debug|x64.ActiveCfg = Debug|x64
		{61E38AEF-8D23-4017-872C-9C4EC7773A42}.Debug|x64.Build.0 = Debug|x64
		{61E38AEF-8D23-4017-872C-9C4EC7773A42}.Debug|x86.ActiveCfg = Debug|Win32
		{61E38AEF-8D23-4017-872C-9C4EC7773A42}.Debug|x86.Build.0 = Debug|Win32
		{61E38AEF-8D23-4017-872C-9C4EC7773A42}.Release|x64.ActiveCfg = Release|x64
		{61E38AEF-8D23-4017-872C-9C4EC7773A42}.Release|x64.Build.0 = Release|x64
		{61E38AEF-8D23-4017-872C-9C4EC7773A42}.Release|x86.ActiveCfg = Release|Win32
		{61E38AEF-8D23-4017-872C-9C4EC7773A42}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {C0578EDA-32F7-401A-A6E2-2B501DB876B5}
	EndGlobalSection
EndGlobal

```

`BinCon/BinCon.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="bc_gen.cpp" />
    <ClCompile Include="bc_iat.cpp" />
    <ClCompile Include="bc_integrity.cpp" />
    <ClCompile Include="bc_pe.cpp" />
    <ClCompile Include="bc_peb.cpp" />
    <ClCompile Include="bc_util.cpp" />
    <ClCompile Include="bc_windows.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\inc\bc_common.h" />
    <ClInclude Include="..\inc\bc_dyn_struct.h" />
    <ClInclude Include="..\inc\bc_gen.h" />
    <ClInclude Include="..\inc\bc_gen_struct.h" />
    <ClInclude Include="..\inc\bc_iat.h" />
    <ClInclude Include="..\inc\bc_integrity.h" />
    <ClInclude Include="..\inc\bc_log.h" />
    <ClInclude Include="..\inc\bc_pe.h" />
    <ClInclude Include="..\inc\bc_peb.h" />
    <ClInclude Include="..\inc\bc_thirdparty.h" />
    <ClInclude Include="..\inc\bc_undocumented.h" />
    <ClInclude Include="..\inc\bc_util.h" />
    <ClInclude Include="..\inc\bc_var.h" />
    <ClInclude Include="..\inc\bc_windows.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{f76672d3-353d-4ef3-8933-1575d4f37e0a}</ProjectGuid>
    <RootNamespace>BinCon</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir)inc;$(VC_IncludePath);$(WindowsSDK_IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(SolutionDir)inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>DEBUG_LOG;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <Optimization>Full</Optimization>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <PreBuildEvent>
      <Command>"$(TargetDir)BinConBuildTime"
xcopy "$(ProjectDir)bc_gen.h" "$(SolutionDir)inc" /Y
xcopy "$(ProjectDir)bc_gen_struct.h" "$(SolutionDir)inc" /Y
</Command>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`BinCon/BinCon.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Source Files\Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="bc_windows.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="bc_integrity.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="bc_peb.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="bc_util.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="bc_pe.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="bc_gen.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="bc_iat.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\inc\bc_var.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\bc_common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\bc_windows.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\bc_thirdparty.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\bc_integrity.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\bc_peb.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\bc_undocumented.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\bc_util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\bc_pe.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\bc_log.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\bc_gen.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\bc_gen_struct.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\bc_iat.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\bc_dyn_struct.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`BinCon/BinCon.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`BinCon/bc_gen.cpp`:

```cpp
#include "bc_gen.h"

uint32_t dyn_key_32 = *((uint32_t*)(__TIME__)) ^ *((uint32_t*)(__DATE__));
uint64_t dyn_key_64 = *((uint64_t*)(__TIME__)) ^ *((uint32_t*)(__DATE__));
```

`BinCon/bc_gen.h`:

```h
#pragma once
#include <cstdint>
extern uint32_t dyn_key_32;
extern uint64_t dyn_key_64;
#define ENCRYPT(O, X, F, FL) 	O = X; \
	{  \
		uint64_t __a; \
		uint64_t __b; \
	if ((FL % 29) == 0) \
	{ \
		__a = (O & 252) >> 2ull; \
		__b = (O & 277076930199552) >> 42ull; \
		O &= ~252; \
		O &= ~277076930199552; \
		O |= __a << 42ull; \
		O |= __b << 2ull; \
	} \
	else if ((FL % 28) == 0) \
	{ \
		__a = (O & 67108863) >> 0ull; \
		__b = (O & 2305842974853955584) >> 35ull; \
		O &= ~67108863; \
		O &= ~2305842974853955584; \
		O |= __a << 35ull; \
		O |= __b << 0ull; \
	} \
	else if ((FL % 27) == 0) \
	{ \
		*((uint16_t*)&O) *= 17241; \
		*((uint16_t*)&O + 1) *= 11559; \
		*((uint16_t*)&O + 2) *= 10317; \
		*((uint16_t*)&O + 3) *= 5707; \
	} \
	else if ((FL % 26) == 0) \
	{ \
		O ^= 59214714119270; \
	} \
	else if ((FL % 25) == 0) \
	{ \
		O ^= 81067507740925; \
	} \
	else if ((FL % 24) == 0) \
	{ \
		*((uint16_t*)&O) *= 14907; \
		*((uint16_t*)&O + 1) *= 11599; \
		*((uint16_t*)&O + 2) *= 6603; \
		*((uint16_t*)&O + 3) *= 26399; \
	} \
	else if ((FL % 23) == 0) \
	{ \
		O ^= 29115583330276; \
	} \
	else if ((FL % 22) == 0) \
	{ \
		O ^= 14577119022777; \
	} \
	else if ((FL % 21) == 0) \
	{ \
		__a = (O & 8257536) >> 17ull; \
		__b = (O & 8658654068736) >> 37ull; \
		O &= ~8257536; \
		O &= ~8658654068736; \
		O |= __a << 37ull; \
		O |= __b << 17ull; \
	} \
	else if ((FL % 20) == 0) \
	{ \
		__a = (O & 4095) >> 0ull; \
		__b = (O & 9221120237041090560) >> 51ull; \
		O &= ~4095; \
		O &= ~9221120237041090560; \
		O |= __a << 51ull; \
		O |= __b << 0ull; \
	} \
	else if ((FL % 19) == 0) \
	{ \
		*((uint16_t*)&O) *= 17741; \
		*((uint16_t*)&O + 1) *= 27263; \
		*((uint16_t*)&O + 2) *= 3575; \
		*((uint16_t*)&O + 3) *= 17999; \
	} \
	else if ((FL % 18) == 0) \
	{ \
		__a = (O & 268435452) >> 2ull; \
		__b = (O & 1152921487426977792) >> 34ull; \
		O &= ~268435452; \
		O &= ~1152921487426977792; \
		O |= __a << 34ull; \
		O |= __b << 2ull; \
	} \
	else if ((FL % 17) == 0) \
	{ \
		__a = (O & 2046) >> 1ull; \
		__b = (O & 17996806323437568) >> 44ull; \
		O &= ~2046; \
		O &= ~17996806323437568; \
		O |= __a << 44ull; \
		O |= __b << 1ull; \
	} \
	else if ((FL % 16) == 0) \
	{ \
		__a = (O & 4194176) >> 7ull; \
		__b = (O & 281466386776064) >> 33ull; \
		O &= ~4194176; \
		O &= ~281466386776064; \
		O |= __a << 33ull; \
		O |= __b << 7ull; \
	} \
	else if ((FL % 15) == 0) \
	{ \
		O ^= 118657061504053; \
	} \
	else if ((FL % 14) == 0) \
	{ \
		__a = (O & 67108848) >> 4ull; \
		__b = (O & 1152921229728940032) >> 38ull; \
		O &= ~67108848; \
		O &= ~1152921229728940032; \
		O |= __a << 38ull; \
		O |= __b << 4ull; \
	} \
	else if ((FL % 13) == 0) \
	{ \
		O ^= 92698279169073; \
	} \
	else if ((FL % 12) == 0) \
	{ \
		*((uint16_t*)&O) *= 26991; \
		*((uint16_t*)&O + 1) *= 31623; \
		*((uint16_t*)&O + 2) *= 5619; \
		*((uint16_t*)&O + 3) *= 31429; \
	} \
	else if ((FL % 11) == 0) \
	{ \
		O ^= 63123134378578; \
	} \
	else if ((FL % 10) == 0) \
	{ \
		*((uint16_t*)&O) *= 21701; \
		*((uint16_t*)&O + 1) *= 3407; \
		*((uint16_t*)&O + 2) *= 20653; \
		*((uint16_t*)&O + 3) *= 7571; \
	} \
	else if ((FL % 9) == 0) \
	{ \
		*((uint16_t*)&O) *= 2041; \
		*((uint16_t*)&O + 1) *= 6513; \
		*((uint16_t*)&O + 2) *= 8427; \
		*((uint16_t*)&O + 3) *= 29707; \
	} \
	else if ((FL % 8) == 0) \
	{ \
		*((uint16_t*)&O) *= 109; \
		*((uint16_t*)&O + 1) *= 17281; \
		*((uint16_t*)&O + 2) *= 4199; \
		*((uint16_t*)&O + 3) *= 24487; \
	} \
	else if ((FL % 7) == 0) \
	{ \
		*((uint16_t*)&O) *= 21467; \
		*((uint16_t*)&O + 1) *= 30401; \
		*((uint16_t*)&O + 2) *= 23823; \
		*((uint16_t*)&O + 3) *= 18785; \
	} \
	else if ((FL % 6) == 0) \
	{ \
		*((uint16_t*)&O) *= 21661; \
		*((uint16_t*)&O + 1) *= 7687; \
		*((uint16_t*)&O + 2) *= 27731; \
		*((uint16_t*)&O + 3) *= 1793; \
	} \
	else if ((FL % 5) == 0) \
	{ \
		O ^= 28540057695932; \
	} \
	else if ((FL % 4) == 0) \
	{ \
		*((uint16_t*)&O) *= 11041; \
		*((uint16_t*)&O + 1) *= 7183; \
		*((uint16_t*)&O + 2) *= 10627; \
		*((uint16_t*)&O + 3) *= 26771; \
	} \
	else if ((FL % 3) == 0) \
	{ \
		O ^= 100141457498361; \
	} \
	else if ((FL % 2) == 0) \
	{ \
		O ^= 129278515640240; \
	} \
	else if ((FL % 1) == 0) \
	{ \
		O ^= 110612587743925; \
	} \
	else  \
	{ \
		*((uint16_t*)&O) *= 9871; \
		*((uint16_t*)&O + 1) *= 2339; \
		*((uint16_t*)&O + 2) *= 11117; \
		*((uint16_t*)&O + 3) *= 28079; \
	} \
}

#define DECRYPT(O, X, F, FL) 	O = X; \
	{  \
		uint64_t __a; \
		uint64_t __b; \
	if ((FL % 29) == 0) \
	{ \
		__a = (O & 252) >> 2ull; \
		__b = (O & 277076930199552) >> 42ull; \
		O &= ~252; \
		O &= ~277076930199552; \
		O |= __a << 42ull; \
		O |= __b << 2ull; \
	} \
	else if ((FL % 28) == 0) \
	{ \
		__a = (O & 67108863) >> 0ull; \
		__b = (O & 2305842974853955584) >> 35ull; \
		O &= ~67108863; \
		O &= ~2305842974853955584; \
		O |= __a << 35ull; \
		O |= __b << 0ull; \
	} \
	else if ((FL % 27) == 0) \
	{ \
		*((uint16_t*)&O) *= 1137562857; \
		*((uint16_t*)&O + 1) *= 3941495447; \
		*((uint16_t*)&O + 2) *= 3628028037; \
		*((uint16_t*)&O + 3) *= 3937764195; \
	} \
	else if ((FL % 26) == 0) \
	{ \
		O ^= 59214714119270; \
	} \
	else if ((FL % 25) == 0) \
	{ \
		O ^= 81067507740925; \
	} \
	else if ((FL % 24) == 0) \
	{ \
		*((uint16_t*)&O) *= 2888601331; \
		*((uint16_t*)&O + 1) *= 3051538863; \
		*((uint16_t*)&O + 2) *= 2367374307; \
		*((uint16_t*)&O + 3) *= 1387287775; \
	} \
	else if ((FL % 23) == 0) \
	{ \
		O ^= 29115583330276; \
	} \
	else if ((FL % 22) == 0) \
	{ \
		O ^= 14577119022777; \
	} \
	else if ((FL % 21) == 0) \
	{ \
		__a = (O & 8257536) >> 17ull; \
		__b = (O & 8658654068736) >> 37ull; \
		O &= ~8257536; \
		O &= ~8658654068736; \
		O |= __a << 37ull; \
		O |= __b << 17ull; \
	} \
	else if ((FL % 20) == 0) \
	{ \
		__a = (O & 4095) >> 0ull; \
		__b = (O & 9221120237041090560) >> 51ull; \
		O &= ~4095; \
		O &= ~9221120237041090560; \
		O |= __a << 51ull; \
		O |= __b << 0ull; \
	} \
	else if ((FL % 19) == 0) \
	{ \
		*((uint16_t*)&O) *= 4075977605; \
		*((uint16_t*)&O + 1) *= 259741055; \
		*((uint16_t*)&O + 2) *= 521323463; \
		*((uint16_t*)&O + 3) *= 2327646383; \
	} \
	else if ((FL % 18) == 0) \
	{ \
		__a = (O & 268435452) >> 2ull; \
		__b = (O & 1152921487426977792) >> 34ull; \
		O &= ~268435452; \
		O &= ~1152921487426977792; \
		O |= __a << 34ull; \
		O |= __b << 2ull; \
	} \
	else if ((FL % 17) == 0) \
	{ \
		__a = (O & 2046) >> 1ull; \
		__b = (O & 17996806323437568) >> 44ull; \
		O &= ~2046; \
		O &= ~17996806323437568; \
		O |= __a << 44ull; \
		O |= __b << 1ull; \
	} \
	else if ((FL % 16) == 0) \
	{ \
		__a = (O & 4194176) >> 7ull; \
		__b = (O & 281466386776064) >> 33ull; \
		O &= ~4194176; \
		O &= ~281466386776064; \
		O |= __a << 33ull; \
		O |= __b << 7ull; \
	} \
	else if ((FL % 15) == 0) \
	{ \
		O ^= 118657061504053; \
	} \
	else if ((FL % 14) == 0) \
	{ \
		__a = (O & 67108848) >> 4ull; \
		__b = (O & 1152921229728940032) >> 38ull; \
		O &= ~67108848; \
		O &= ~1152921229728940032; \
		O |= __a << 38ull; \
		O |= __b << 4ull; \
	} \
	else if ((FL % 13) == 0) \
	{ \
		O ^= 92698279169073; \
	} \
	else if ((FL % 12) == 0) \
	{ \
		*((uint16_t*)&O) *= 2201556367; \
		*((uint16_t*)&O + 1) *= 501242423; \
		*((uint16_t*)&O + 2) *= 2087226171; \
		*((uint16_t*)&O + 3) *= 1162802189; \
	} \
	else if ((FL % 11) == 0) \
	{ \
		O ^= 63123134378578; \
	} \
	else if ((FL % 10) == 0) \
	{ \
		*((uint16_t*)&O) *= 494668301; \
		*((uint16_t*)&O + 1) *= 801565103; \
		*((uint16_t*)&O + 2) *= 1791333157; \
		*((uint16_t*)&O + 3) *= 846760091; \
	} \
	else if ((FL % 9) == 0) \
	{ \
		*((uint16_t*)&O) *= 3955624521; \
		*((uint16_t*)&O + 1) *= 3348203409; \
		*((uint16_t*)&O + 2) *= 94275523; \
		*((uint16_t*)&O + 3) *= 967669667; \
	} \
	else if ((FL % 8) == 0) \
	{ \
		*((uint16_t*)&O) *= 3545762149; \
		*((uint16_t*)&O + 1) *= 2647260289; \
		*((uint16_t*)&O + 2) *= 1201670999; \
		*((uint16_t*)&O + 3) *= 1530288151; \
	} \
	else if ((FL % 7) == 0) \
	{ \
		*((uint16_t*)&O) *= 1145008211; \
		*((uint16_t*)&O + 1) *= 3163887937; \
		*((uint16_t*)&O + 2) *= 3273585135; \
		*((uint16_t*)&O + 3) *= 2630228641; \
	} \
	else if ((FL % 6) == 0) \
	{ \
		*((uint16_t*)&O) *= 2633486773; \
		*((uint16_t*)&O + 1) *= 2831347639; \
		*((uint16_t*)&O + 2) *= 94156763; \
		*((uint16_t*)&O + 3) *= 481425665; \
	} \
	else if ((FL % 5) == 0) \
	{ \
		O ^= 28540057695932; \
	} \
	else if ((FL % 4) == 0) \
	{ \
		*((uint16_t*)&O) *= 1093605601; \
		*((uint16_t*)&O + 1) *= 2101826287; \
		*((uint16_t*)&O + 2) *= 3964611883; \
		*((uint16_t*)&O + 3) *= 2671048091; \
	} \
	else if ((FL % 3) == 0) \
	{ \
		O ^= 100141457498361; \
	} \
	else if ((FL % 2) == 0) \
	{ \
		O ^= 129278515640240; \
	} \
	else if ((FL % 1) == 0) \
	{ \
		O ^= 110612587743925; \
	} \
	else  \
	{ \
		*((uint16_t*)&O) *= 3931125871; \
		*((uint16_t*)&O + 1) *= 4053429899; \
		*((uint16_t*)&O + 2) *= 3409024613; \
		*((uint16_t*)&O + 3) *= 3133999439; \
	} \
}

#define ENCRYPTM(O, X, F, FL) 	O = X; \
	{  \
		uint64_t __a; \
		uint64_t __b; \
	if ((FL % 29) == 0) \
	{ \
		__a = (O & 252) >> 2ull; \
		__b = (O & 277076930199552) >> 42ull; \
		O &= ~252; \
		O &= ~277076930199552; \
		O |= __a << 42ull; \
		O |= __b << 2ull; \
	} \
	else if ((FL % 28) == 0) \
	{ \
		__a = (O & 67108863) >> 0ull; \
		__b = (O & 2305842974853955584) >> 35ull; \
		O &= ~67108863; \
		O &= ~2305842974853955584; \
		O |= __a << 35ull; \
		O |= __b << 0ull; \
	} \
	else if ((FL % 27) == 0) \
	{ \
		*((uint16_t*)&O) *= 17241; \
		*((uint16_t*)&O + 1) *= 11559; \
		*((uint16_t*)&O + 2) *= 10317; \
		*((uint16_t*)&O + 3) *= 5707; \
	} \
	else if ((FL % 26) == 0) \
	{ \
		O ^= 59214714119270; \
	} \
	else if ((FL % 25) == 0) \
	{ \
		O ^= 81067507740925; \
	} \
	else if ((FL % 24) == 0) \
	{ \
		*((uint16_t*)&O) *= 14907; \
		*((uint16_t*)&O + 1) *= 11599; \
		*((uint16_t*)&O + 2) *= 6603; \
		*((uint16_t*)&O + 3) *= 26399; \
	} \
	else if ((FL % 23) == 0) \
	{ \
		O ^= 29115583330276; \
	} \
	else if ((FL % 22) == 0) \
	{ \
		O ^= 14577119022777; \
	} \
	else if ((FL % 21) == 0) \
	{ \
		__a = (O & 8257536) >> 17ull; \
		__b = (O & 8658654068736) >> 37ull; \
		O &= ~8257536; \
		O &= ~8658654068736; \
		O |= __a << 37ull; \
		O |= __b << 17ull; \
	} \
	else if ((FL % 20) == 0) \
	{ \
		__a = (O & 4095) >> 0ull; \
		__b = (O & 9221120237041090560) >> 51ull; \
		O &= ~4095; \
		O &= ~9221120237041090560; \
		O |= __a << 51ull; \
		O |= __b << 0ull; \
	} \
	else if ((FL % 19) == 0) \
	{ \
		*((uint16_t*)&O) *= 17741; \
		*((uint16_t*)&O + 1) *= 27263; \
		*((uint16_t*)&O + 2) *= 3575; \
		*((uint16_t*)&O + 3) *= 17999; \
	} \
	else if ((FL % 18) == 0) \
	{ \
		__a = (O & 268435452) >> 2ull; \
		__b = (O & 1152921487426977792) >> 34ull; \
		O &= ~268435452; \
		O &= ~1152921487426977792; \
		O |= __a << 34ull; \
		O |= __b << 2ull; \
	} \
	else if ((FL % 17) == 0) \
	{ \
		__a = (O & 2046) >> 1ull; \
		__b = (O & 17996806323437568) >> 44ull; \
		O &= ~2046; \
		O &= ~17996806323437568; \
		O |= __a << 44ull; \
		O |= __b << 1ull; \
	} \
	else if ((FL % 16) == 0) \
	{ \
		__a = (O & 4194176) >> 7ull; \
		__b = (O & 281466386776064) >> 33ull; \
		O &= ~4194176; \
		O &= ~281466386776064; \
		O |= __a << 33ull; \
		O |= __b << 7ull; \
	} \
	else if ((FL % 15) == 0) \
	{ \
		O ^= 118657061504053; \
	} \
	else if ((FL % 14) == 0) \
	{ \
		__a = (O & 67108848) >> 4ull; \
		__b = (O & 1152921229728940032) >> 38ull; \
		O &= ~67108848; \
		O &= ~1152921229728940032; \
		O |= __a << 38ull; \
		O |= __b << 4ull; \
	} \
	else if ((FL % 13) == 0) \
	{ \
		O ^= 92698279169073; \
	} \
	else if ((FL % 12) == 0) \
	{ \
		*((uint16_t*)&O) *= 26991; \
		*((uint16_t*)&O + 1) *= 31623; \
		*((uint16_t*)&O + 2) *= 5619; \
		*((uint16_t*)&O + 3) *= 31429; \
	} \
	else if ((FL % 11) == 0) \
	{ \
		O ^= 63123134378578; \
	} \
	else if ((FL % 10) == 0) \
	{ \
		*((uint16_t*)&O) *= 21701; \
		*((uint16_t*)&O + 1) *= 3407; \
		*((uint16_t*)&O + 2) *= 20653; \
		*((uint16_t*)&O + 3) *= 7571; \
	} \
	else if ((FL % 9) == 0) \
	{ \
		*((uint16_t*)&O) *= 2041; \
		*((uint16_t*)&O + 1) *= 6513; \
		*((uint16_t*)&O + 2) *= 8427; \
		*((uint16_t*)&O + 3) *= 29707; \
	} \
	else if ((FL % 8) == 0) \
	{ \
		*((uint16_t*)&O) *= 109; \
		*((uint16_t*)&O + 1) *= 17281; \
		*((uint16_t*)&O + 2) *= 4199; \
		*((uint16_t*)&O + 3) *= 24487; \
	} \
	else if ((FL % 7) == 0) \
	{ \
		*((uint16_t*)&O) *= 21467; \
		*((uint16_t*)&O + 1) *= 30401; \
		*((uint16_t*)&O + 2) *= 23823; \
		*((uint16_t*)&O + 3) *= 18785; \
	} \
	else if ((FL % 6) == 0) \
	{ \
		*((uint16_t*)&O) *= 21661; \
		*((uint16_t*)&O + 1) *= 7687; \
		*((uint16_t*)&O + 2) *= 27731; \
		*((uint16_t*)&O + 3) *= 1793; \
	} \
	else if ((FL % 5) == 0) \
	{ \
		O ^= 28540057695932; \
	} \
	else if ((FL % 4) == 0) \
	{ \
		*((uint16_t*)&O) *= 11041; \
		*((uint16_t*)&O + 1) *= 7183; \
		*((uint16_t*)&O + 2) *= 10627; \
		*((uint16_t*)&O + 3) *= 26771; \
	} \
	else if ((FL % 3) == 0) \
	{ \
		O ^= 100141457498361; \
	} \
	else if ((FL % 2) == 0) \
	{ \
		O ^= 129278515640240; \
	} \
	else if ((FL % 1) == 0) \
	{ \
		O ^= 110612587743925; \
	} \
	else  \
	{ \
		*((uint16_t*)&O) *= 9871; \
		*((uint16_t*)&O + 1) *= 2339; \
		*((uint16_t*)&O + 2) *= 11117; \
		*((uint16_t*)&O + 3) *= 28079; \
	} \
}

#define DECRYPTM(O, X, F, FL) 	O = X; \
	{  \
		uint64_t __a; \
		uint64_t __b; \
	if ((FL % 29) == 0) \
	{ \
		__a = (O & 252) >> 2ull; \
		__b = (O & 277076930199552) >> 42ull; \
		O &= ~252; \
		O &= ~277076930199552; \
		O |= __a << 42ull; \
		O |= __b << 2ull; \
	} \
	else if ((FL % 28) == 0) \
	{ \
		__a = (O & 67108863) >> 0ull; \
		__b = (O & 2305842974853955584) >> 35ull; \
		O &= ~67108863; \
		O &= ~2305842974853955584; \
		O |= __a << 35ull; \
		O |= __b << 0ull; \
	} \
	else if ((FL % 27) == 0) \
	{ \
		*((uint16_t*)&O) *= 1137562857; \
		*((uint16_t*)&O + 1) *= 3941495447; \
		*((uint16_t*)&O + 2) *= 3628028037; \
		*((uint16_t*)&O + 3) *= 3937764195; \
	} \
	else if ((FL % 26) == 0) \
	{ \
		O ^= 59214714119270; \
	} \
	else if ((FL % 25) == 0) \
	{ \
		O ^= 81067507740925; \
	} \
	else if ((FL % 24) == 0) \
	{ \
		*((uint16_t*)&O) *= 2888601331; \
		*((uint16_t*)&O + 1) *= 3051538863; \
		*((uint16_t*)&O + 2) *= 2367374307; \
		*((uint16_t*)&O + 3) *= 1387287775; \
	} \
	else if ((FL % 23) == 0) \
	{ \
		O ^= 29115583330276; \
	} \
	else if ((FL % 22) == 0) \
	{ \
		O ^= 14577119022777; \
	} \
	else if ((FL % 21) == 0) \
	{ \
		__a = (O & 8257536) >> 17ull; \
		__b = (O & 8658654068736) >> 37ull; \
		O &= ~8257536; \
		O &= ~8658654068736; \
		O |= __a << 37ull; \
		O |= __b << 17ull; \
	} \
	else if ((FL % 20) == 0) \
	{ \
		__a = (O & 4095) >> 0ull; \
		__b = (O & 9221120237041090560) >> 51ull; \
		O &= ~4095; \
		O &= ~9221120237041090560; \
		O |= __a << 51ull; \
		O |= __b << 0ull; \
	} \
	else if ((FL % 19) == 0) \
	{ \
		*((uint16_t*)&O) *= 4075977605; \
		*((uint16_t*)&O + 1) *= 259741055; \
		*((uint16_t*)&O + 2) *= 521323463; \
		*((uint16_t*)&O + 3) *= 2327646383; \
	} \
	else if ((FL % 18) == 0) \
	{ \
		__a = (O & 268435452) >> 2ull; \
		__b = (O & 1152921487426977792) >> 34ull; \
		O &= ~268435452; \
		O &= ~1152921487426977792; \
		O |= __a << 34ull; \
		O |= __b << 2ull; \
	} \
	else if ((FL % 17) == 0) \
	{ \
		__a = (O & 2046) >> 1ull; \
		__b = (O & 17996806323437568) >> 44ull; \
		O &= ~2046; \
		O &= ~17996806323437568; \
		O |= __a << 44ull; \
		O |= __b << 1ull; \
	} \
	else if ((FL % 16) == 0) \
	{ \
		__a = (O & 4194176) >> 7ull; \
		__b = (O & 281466386776064) >> 33ull; \
		O &= ~4194176; \
		O &= ~281466386776064; \
		O |= __a << 33ull; \
		O |= __b << 7ull; \
	} \
	else if ((FL % 15) == 0) \
	{ \
		O ^= 118657061504053; \
	} \
	else if ((FL % 14) == 0) \
	{ \
		__a = (O & 67108848) >> 4ull; \
		__b = (O & 1152921229728940032) >> 38ull; \
		O &= ~67108848; \
		O &= ~1152921229728940032; \
		O |= __a << 38ull; \
		O |= __b << 4ull; \
	} \
	else if ((FL % 13) == 0) \
	{ \
		O ^= 92698279169073; \
	} \
	else if ((FL % 12) == 0) \
	{ \
		*((uint16_t*)&O) *= 2201556367; \
		*((uint16_t*)&O + 1) *= 501242423; \
		*((uint16_t*)&O + 2) *= 2087226171; \
		*((uint16_t*)&O + 3) *= 1162802189; \
	} \
	else if ((FL % 11) == 0) \
	{ \
		O ^= 63123134378578; \
	} \
	else if ((FL % 10) == 0) \
	{ \
		*((uint16_t*)&O) *= 494668301; \
		*((uint16_t*)&O + 1) *= 801565103; \
		*((uint16_t*)&O + 2) *= 1791333157; \
		*((uint16_t*)&O + 3) *= 846760091; \
	} \
	else if ((FL % 9) == 0) \
	{ \
		*((uint16_t*)&O) *= 3955624521; \
		*((uint16_t*)&O + 1) *= 3348203409; \
		*((uint16_t*)&O + 2) *= 94275523; \
		*((uint16_t*)&O + 3) *= 967669667; \
	} \
	else if ((FL % 8) == 0) \
	{ \
		*((uint16_t*)&O) *= 3545762149; \
		*((uint16_t*)&O + 1) *= 2647260289; \
		*((uint16_t*)&O + 2) *= 1201670999; \
		*((uint16_t*)&O + 3) *= 1530288151; \
	} \
	else if ((FL % 7) == 0) \
	{ \
		*((uint16_t*)&O) *= 1145008211; \
		*((uint16_t*)&O + 1) *= 3163887937; \
		*((uint16_t*)&O + 2) *= 3273585135; \
		*((uint16_t*)&O + 3) *= 2630228641; \
	} \
	else if ((FL % 6) == 0) \
	{ \
		*((uint16_t*)&O) *= 2633486773; \
		*((uint16_t*)&O + 1) *= 2831347639; \
		*((uint16_t*)&O + 2) *= 94156763; \
		*((uint16_t*)&O + 3) *= 481425665; \
	} \
	else if ((FL % 5) == 0) \
	{ \
		O ^= 28540057695932; \
	} \
	else if ((FL % 4) == 0) \
	{ \
		*((uint16_t*)&O) *= 1093605601; \
		*((uint16_t*)&O + 1) *= 2101826287; \
		*((uint16_t*)&O + 2) *= 3964611883; \
		*((uint16_t*)&O + 3) *= 2671048091; \
	} \
	else if ((FL % 3) == 0) \
	{ \
		O ^= 100141457498361; \
	} \
	else if ((FL % 2) == 0) \
	{ \
		O ^= 129278515640240; \
	} \
	else if ((FL % 1) == 0) \
	{ \
		O ^= 110612587743925; \
	} \
	else  \
	{ \
		*((uint16_t*)&O) *= 3931125871; \
		*((uint16_t*)&O + 1) *= 4053429899; \
		*((uint16_t*)&O + 2) *= 3409024613; \
		*((uint16_t*)&O + 3) *= 3133999439; \
	} \
}


```

`BinCon/bc_gen_struct.h`:

```h
#pragma once
#include "bc_var.h"

namespace bc
{
#pragma pack(push, 1)
	enum class packed_import_type
	{
		name,
		ordinal,
	};

	struct packed_import
	{
		char padding_0[14];
		obfuscated_string<256, 0x1337, __LINE__> name;
		char padding_1[7];
		obfuscated_prim64<packed_import_type, 0x1337, __LINE__> type;
		char padding_2[13];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> rva;
		char padding_3[65];
		obfuscated_prim64<uint32_t, 0x1337, __LINE__> ordinal;
		char padding_4[31];
		obfuscated_string<256, 0x1337, __LINE__> mod;
	};

	struct packed_section
	{
		char padding_0[60];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> size_of_data;
		char padding_1[55];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> rva;
		char padding_2[53];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> off_to_data;
		char padding_3[37];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> characteristics;
	};

	struct packed_resource
	{
		char padding_0[60];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> size_of_data;
		char padding_1[11];
		obfuscated_prim64<uint16_t, 0x1337, __LINE__> id;
		char padding_2[76];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> off_to_data;
	};

	struct packed_reloc
	{
		char padding_0[53];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> rva;
	};

	struct packed_tls_callback
	{
		char padding_0[72];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> callback;
	};

	struct counted_element
	{
		char padding_0[81];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> off;
		char padding_1[44];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> num_elements;
	};

	struct packed_app
	{
		char padding_0[51];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> preferred_base;
		char padding_1[28];
		obfuscated_prim64<uint8_t, 0x1337, __LINE__> options;
		char padding_2[15];
		counted_element off_to_iat;
		char padding_3[76];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> size_of_app;
		char padding_4[57];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> size_of_img;
		char padding_5[88];
		counted_element off_to_headers;
		char padding_6[14];
		counted_element off_to_relocs;
		char padding_7[79];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> ep;
		char padding_8[1];
		counted_element off_to_sections;
		char padding_9[61];
		counted_element off_to_resources;
	};

}
#pragma pack(pop)

```

`BinCon/bc_iat.cpp`:

```cpp
#include <bc_iat.h>

namespace bc
{
	iat IAT;
}
```

`BinCon/bc_integrity.cpp`:

```cpp
#include <bc_integrity.h>

#define POLYNOMIAL_INIT 0xEDB88320

namespace bc
{
	uint32_t crc32_table[256];

	void init_crc32_table()
	{
		for (auto i = 0u; i < 256; i++)
		{
			auto c = i;
			for (auto j = 0; j < 8; j++)
			{
				if (c & 1)
				{
					c = POLYNOMIAL_INIT ^ (c >> 1);
				}
				else
				{
					c >>= 1;
				}
			}
			crc32_table[i] = c;
		}
	}
}


```

`BinCon/bc_pe.cpp`:

```cpp
#include <bc_pe.h>
#include <bc_integrity.h>
#include <bc_log.h>
#include <bc_iat.h>

#include <Psapi.h>

#include <fstream>
#include <vector>

namespace bc
{
	bool pe_validator::validate(void* original)
	{
		auto dos_header = (PIMAGE_DOS_HEADER)original;
		auto nt_headers = (PIMAGE_NT_HEADERS)((char*)original + dos_header->e_lfanew);

		auto section = IMAGE_FIRST_SECTION(nt_headers);
		auto valid = true;
		for (auto i = 0; i < nt_headers->FileHeader.NumberOfSections; i++, section++)
		{
			if (section->Characteristics & (IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_CNT_CODE))
			{
				auto crc = crc32(section->Name, sizeof(section->Name));
				auto s_crc = crc32((char*)original + section->VirtualAddress, section->SizeOfRawData);
				if (section_checksums.find(crc) == section_checksums.end())
				{
					LOG("Missing section -> " << section->Name);
					valid = false;
				}
				else if (section_checksums[crc] != s_crc)
				{
					LOG("Bad CS -> " << section->Name << ", " << crc << ", " << s_crc << ", " << section_checksums[crc]);
					valid = false;
				}
				else
				{
					LOG("Valid CS -> " << section->Name << ", " << crc << ", " << s_crc << ", " << section_checksums[crc])
				}
			}
		}
		return valid;
	}

	pe_validator pe_validator::map(void* original, void* data)
	{
		pe_validator v;
		v.section_checksums[0] = 0;

		auto dos_header = (PIMAGE_DOS_HEADER)data;
		auto nt_headers = (PIMAGE_NT_HEADERS)((char*)data + dos_header->e_lfanew);

		auto img_size = nt_headers->OptionalHeader.SizeOfImage;
		auto img_base = (char*)VirtualAlloc(NULL, img_size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
		memcpy(img_base, data, nt_headers->OptionalHeader.SizeOfHeaders);

		auto section = IMAGE_FIRST_SECTION(nt_headers);
		for (auto i = 0; i < nt_headers->FileHeader.NumberOfSections; i++, section++)
		{
			memcpy(img_base + section->VirtualAddress, (char*)data + section->PointerToRawData, section->SizeOfRawData);
		}

		auto& reloc_dir = nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
		if (auto rva = reloc_dir.VirtualAddress)
		{
			auto reloc_addr = img_base + rva;
			auto delta = (UINT64)original - (UINT64)nt_headers->OptionalHeader.ImageBase;
			for (auto cur = 0UL; cur < reloc_dir.Size; )
			{
				IMAGE_BASE_RELOCATION reloc;
				memcpy(&reloc, reloc_addr, sizeof(reloc));

				auto reloc_count = (reloc.SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
				auto reloc_data = reloc_addr + sizeof(IMAGE_BASE_RELOCATION);
				auto reloc_base = img_base + reloc.VirtualAddress;

				for (auto i = 0UL; i < reloc_count; ++i, reloc_data += 2)
				{
					UINT16 data;
					memcpy(&data, reloc_data, sizeof(data));

					auto type = data >> 12;
					auto off = data & 0xFFF;

					if (type == IMAGE_REL_BASED_DIR64)
					{
						auto reloc_ptrd = reloc_base + off;
						UINT64 reloc_raw;

						memcpy(&reloc_raw, reloc_ptrd, sizeof(reloc_raw));
						reloc_raw += delta;
						memcpy(reloc_ptrd, &reloc_raw, sizeof(reloc_raw));
					}
				}

				cur += reloc.SizeOfBlock;
				reloc_addr = reloc_data;
			}
		}

		auto& import_dir = nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
		if (auto rva = nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress)
		{
			auto import_desc_addr = img_base + rva;

			IMAGE_IMPORT_DESCRIPTOR import_desc;
			memcpy(&import_desc, import_desc_addr, sizeof(import_desc));

			while (import_desc.FirstThunk)
			{
				auto mod_name_addr = img_base + import_desc.Name;
				CHAR mod_name[MAX_PATH];

				memcpy(mod_name, mod_name_addr, sizeof(mod_name));
				auto mod = LoadLibraryA(mod_name);

				auto thunk_addr = img_base + import_desc.FirstThunk;
				IMAGE_THUNK_DATA thunk;
				memcpy(&thunk, thunk_addr, sizeof(thunk));

				while (thunk.u1.AddressOfData)
				{
					if (thunk.u1.Ordinal & IMAGE_ORDINAL_FLAG)
					{
						thunk.u1.Function = (ULONGLONG)GetProcAddress(mod, (LPCSTR)(thunk.u1.Ordinal & 0xffff));
					}
					else
					{
						auto ibn_addr = img_base + thunk.u1.AddressOfData;
						char ibn_full[sizeof(IMAGE_IMPORT_BY_NAME) + MAX_PATH];
						auto ibn = (PIMAGE_IMPORT_BY_NAME)ibn_full;
						memcpy(ibn, ibn_addr, sizeof(ibn_full));

						thunk.u1.Function = (ULONGLONG)GetProcAddress(mod, ibn->Name);
					}

					memcpy(thunk_addr, &thunk, sizeof(thunk));
					thunk_addr += sizeof(thunk);
					memcpy(&thunk, thunk_addr, sizeof(thunk));
				}

				import_desc_addr += sizeof(import_desc);
				memcpy(&import_desc, import_desc_addr, sizeof(import_desc));
			}
		}

		section = IMAGE_FIRST_SECTION(nt_headers);
		for (auto i = 0; i < nt_headers->FileHeader.NumberOfSections; i++, section++)
		{
			if (section->Characteristics & (IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_CNT_CODE))
			{
				v.section_checksums[crc32(section->Name, sizeof(section->Name))] = crc32(img_base + section->VirtualAddress, section->SizeOfRawData);
			}
		}

		VirtualFree(img_base, img_size, MEM_FREE);
		return v;
	}

	pe_validator pe_validator::map(HMODULE mod)
	{
		char name[MAX_PATH];
		GetModuleFileNameExA(GetCurrentProcess(), mod, name, sizeof(name));

		auto file = IAT.CreateFileA(name, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		auto size = IAT.GetFileSize(file, NULL);
		DWORD bytes_read = 0;
		char* buffer = (char*)malloc(size + 1);
		IAT.ReadFile(file, buffer, size, &bytes_read, NULL);

		auto mapped = map((void*)mod, buffer);
		free(buffer);
		return mapped;
	}
}
```

`BinCon/bc_peb.cpp`:

```cpp
#include <bc_peb.h>
#include <bc_util.h>

#include <cstdint>

#include <xorstr.hpp>

namespace bc
{

	PVOID peb_walker::resolve_module(const wchar_t* name)
	{
		wchar_t tmp_name[64];
		wcscpy_s(tmp_name, name);
		_wcslwr_s(tmp_name);

		void* found = nullptr;

		iterate([&tmp_name, &found](RE_LDR_DATA_TABLE_ENTRY* mod, PLIST_ENTRY list_entry)
		{
			wchar_t tmp_dll[64];
			wcscpy_s(tmp_dll, mod->BaseDllName.Buffer);
			_wcslwr_s(tmp_dll);

			if (!wcscmp(tmp_dll, tmp_name))
			{
				found = mod->DllBase;
			}
		});

		return found;
	}

	void* peb_walker::resolve_function(char* mod, const char* function)
	{
		char tmp_func[256];
		strcpy_s(tmp_func, function);
		_strlwr_s(tmp_func);

		char tmp_name[256];
		char export_module[64];
		char export_function[256];
		wchar_t export_module_wide[64];

		auto dos_header = (PIMAGE_DOS_HEADER)mod;
		auto nt_headers = (PIMAGE_NT_HEADERS)(mod + dos_header->e_lfanew);

		auto file_header = &nt_headers->FileHeader;
		auto opt_header = &nt_headers->OptionalHeader;

		auto export_dir = opt_header->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
		if (!export_dir.VirtualAddress || !export_dir.Size)
		{
			return nullptr;
		}

		if (export_dir.VirtualAddress)
		{
			auto expr = (IMAGE_EXPORT_DIRECTORY*)(mod + export_dir.VirtualAddress);
			if (!expr->AddressOfNames || !expr->AddressOfNameOrdinals || !expr->AddressOfFunctions)
			{
				return nullptr;
			}

			auto names = (INT32*)(mod + expr->AddressOfNames);
			auto ods = (USHORT*)(mod + expr->AddressOfNameOrdinals);
			auto funcs = (INT32*)(mod + expr->AddressOfFunctions);

			for (auto i = 0ul; i < expr->NumberOfNames; i++)
			{
				auto name_off = names[i];
				strcpy_s(tmp_name, (PCSTR)mod + name_off);
				_strlwr_s(tmp_name);

				if (!strcmp(tmp_func, tmp_name))
				{
					auto func = mod + funcs[ods[i]];
					auto forwarded = (func >= (PCHAR)expr && func < ((PCHAR)expr + export_dir.Size));

					if (forwarded)
					{
						char whole[64];
						strcpy_s(whole, sizeof(whole), (PCHAR)func);

						auto period = -1;
						for (INT32 i = 0; i < strlen(whole); i++)
						{
							if (whole[i] == '.')
							{
								period = i;
								break;
							}
						}

						memset(export_module, 0, 64);
						memcpy(export_module, whole, period);

						memset(export_function, 0, 64);
						memcpy(export_function, whole + period + 1, strlen(whole) - period);

						strcat_s(export_module, xorstr_(".dll"));

						ascii_to_wide(export_module, export_module_wide);
						_wcslwr_s(export_module_wide);

						func = (char*)resolve_function(export_module_wide, export_function);
					}

					return func;
				}
			}
		}

		return nullptr;
	}

	void* peb_walker::resolve_function(const wchar_t* module, const char* function)
	{
		auto mod = (char*)resolve_module(module);
		if (!mod)
		{
			return nullptr;
		}

		return resolve_function(mod, function);
	}

	bool peb_walker::is_within_module(void* addr)
	{
		bool within = false;

		iterate([&addr, &within](RE_LDR_DATA_TABLE_ENTRY* mod, PLIST_ENTRY list_entry)
		{
			if (addr >= mod->DllBase && 
				addr < (void*)((uint64_t)mod->DllBase + mod->SizeOfImage))
			{
				within = true;
			}
		});

		return within;
	}


	HMODULE peb_walker::get_hmodule(void* addr)
	{
		HMODULE within = NULL;

		iterate([&addr, &within](RE_LDR_DATA_TABLE_ENTRY* mod, PLIST_ENTRY list_entry)
		{
			if (addr >= mod->DllBase &&
				addr < (void*)((uint64_t)mod->DllBase + mod->SizeOfImage))
			{
				within = (HMODULE)mod->DllBase;
			}
		});

		return within;
	}

	peb_walker peb_walker::query()
	{
		static FnNtQueryInformationProcess NtQueryInformationProcess = NULL;
		if (!NtQueryInformationProcess)
		{
			NtQueryInformationProcess = (FnNtQueryInformationProcess)GetProcAddress(GetModuleHandleA(xorstr_("ntdll.dll")), xorstr_("NtQueryInformationProcess"));
		}

		RE_PROCESS_BASIC_INFORMATION info;
		NTSTATUS status = NtQueryInformationProcess(GetCurrentProcess(), 0, &info, sizeof(info), 0);

		return peb_walker((PRE_PEB)info.PebBaseAddress);
	}

	peb_walker peb_walker::tib()
	{
		return peb_walker((PRE_PEB)get_peb());
	}
}
```

`BinCon/bc_util.cpp`:

```cpp
#include <bc_util.h>
#include <string>

namespace bc
{
	void ascii_to_wide(const char* in, wchar_t* out)
	{
		auto len = strlen(in);
		for (auto i = 0; i < len; i++)
		{
			out[i] = (wchar_t)in[i];
		}
		out[len] = L'\0';
	}

	void wide_to_ascii(const wchar_t* in, char* out)
	{
		auto len = wcslen(in);
		for (auto i = 0; i < len; i++)
		{
			out[i] = (char)in[i];
		}
		out[len] = '\0';
	}
}
```

`BinCon/bc_windows.cpp`:

```cpp
#include <bc_windows.h>
#include <bc_var.h>
#include <bc_integrity.h>
#include <bc_peb.h>
#include <bc_thirdparty.h>
#include <bc_log.h>
#include <bc_iat.h>

#include <cstdint>

#include <xorstr.hpp>

#define DR_MAGIC 0xffff000000000000

namespace bc
{
	static obfuscated_prim64<uint32_t, 0x1337, __LINE__> checksum_DbgUiRemoteBreakin;
	static obfuscated_prim64<void*, 0x1337, __LINE__> addr_DbgUiRemoteBreakin;
	static bool hang_system_in_progress = false;
	static HHOOK dummy_keyboard_hook;
	static uint64_t expected_debug_regs[4];

	/// <summary>
	/// Installs a hook on DbgUiRemoteBreakin so that the process
	/// will crash whenever a debugger is attached.
	/// </summary>
	static INLINE void hook_DbgUiRemoteBreakin()
	{
		char rnd_gen[15];
		for (size_t i = 0; i < 15; i++)
		{
			rnd_gen[i] = (char)rand();
		}
		checksum_DbgUiRemoteBreakin = crc32(rnd_gen, 15);

		auto wrapper_VirtualProtect = peb_walker::func<decltype(VirtualProtect)*>(xorstr_(L"Kernel32.dll"), xorstr_("VirtualProtect"));

		DWORD old_protect;
		wrapper_VirtualProtect(addr_DbgUiRemoteBreakin.get(), 15, PAGE_EXECUTE_READWRITE, &old_protect);
		memcpy(addr_DbgUiRemoteBreakin.get(), rnd_gen, 15);
		wrapper_VirtualProtect(addr_DbgUiRemoteBreakin.get(), 15, old_protect, &old_protect);
	}

	/// <summary>
	/// A keyboard hook handler that does nothing.
	/// </summary>
	static LRESULT CALLBACK dummy_keyboard_handler(int nCode, WPARAM wParam, LPARAM lParam)
	{
		return CallNextHookEx(dummy_keyboard_hook, nCode, wParam, lParam);
	}

	/// <summary>
	/// Hooks the keyboards, and forwards input until a request to hang
	/// the system is made. This will also hang the system when a debugger is attached,
	/// as events will be blocked.
	/// </summary>
	static NOINLINE void hook_keyboard()
	{
		VM({
			dummy_keyboard_hook = SetWindowsHookEx(WH_KEYBOARD_LL, dummy_keyboard_handler, NULL, 0);
			MSG msg;
			while (GetMessage(&msg, NULL, 0, 0) > 0 && !hang_system_in_progress)
			{
				TranslateMessage(&msg);
				DispatchMessage(&msg);
			}
		});
	}

	/// <summary>
	/// Verifies that debug registers have our dummy values in them.
	/// </summary>
	static INLINE bool verify_debug_regs()
	{
		auto ret = false;
		auto thr = IAT.GetCurrentThread();

		CONTEXT thr_ctx;
		thr_ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;

		if (!IAT.GetThreadContext(thr, &thr_ctx))
		{
			goto _ret;
		}

		if (thr_ctx.Dr0 == DR_MAGIC &&
			thr_ctx.Dr1 == DR_MAGIC &&
			thr_ctx.Dr2 == DR_MAGIC &&
			thr_ctx.Dr3 == DR_MAGIC)
		{
			ret = true;
		}

	_ret:
		return ret;
	}
	/// <summary>
	/// Sets dummy values to all debug address registers.
	/// </summary>
	static INLINE bool randomize_debug_regs()
	{
		auto ret = false;
		auto thr = IAT.GetCurrentThread();

		CONTEXT thr_ctx; 
		thr_ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;

		if (!IAT.GetThreadContext(thr, &thr_ctx))
		{
			goto _ret;
		}

		thr_ctx.Dr0 = DR_MAGIC;
		thr_ctx.Dr1 = DR_MAGIC;
		thr_ctx.Dr2 = DR_MAGIC;
		thr_ctx.Dr3 = DR_MAGIC;

		if (!IAT.SetThreadContext(thr, &thr_ctx))
		{
			goto _ret;
		}
		
		ret = true;

	_ret:
		return ret;
	}

	NOINLINE void install_anti_debug()
	{
		VM({
			auto walker = peb_walker::tib();
			addr_DbgUiRemoteBreakin = walker.resolve_function(xorstr_(L"ntdll.dll"), xorstr_("DbgUiRemoteBreakin"));
			hook_DbgUiRemoteBreakin();
			randomize_debug_regs();
			IAT.CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)hook_keyboard, NULL, 0, NULL);
		});
	}

	void verify_anti_debug(fn_integrity_check_failed on_failure)
	{
		VM({
			LOG("Checking IsDebuggerPresent");
			if (IAT.IsDebuggerPresent())
			{
				on_failure(bc_error::debugger_attached);
			}

			LOG("Checking BeingDebugged");
			if (get_peb()->BeingDebugged)
			{
				on_failure(bc_error::debugger_attached);
			}

			LOG("Checking NtGlobalFlag");
			if (get_peb()->NtGlobalFlag)
			{
				on_failure(bc_error::debugger_attached);
			}
			
			LOG("Verifying debug registers");
			if (!verify_debug_regs())
			{
				on_failure(bc_error::debugger_attached);
			}

			LOG("Verifying DbgUiRemoteBreakin hook");
			if (crc32(addr_DbgUiRemoteBreakin.get(), 15) != checksum_DbgUiRemoteBreakin.get())
			{
				on_failure(bc_error::bad_hook_checksum);
			}
		});
	}

	void hang_system()
	{
		hang_system_in_progress = true;
	}

	/// <summary>
	/// Verifies that the provided return address contains a valid call within the provided module beforehand.
	/// 
	/// If the module is NULL, then it must just have a valid call.
	/// </summary>
	static INLINE bool verify_ret_addr_ins(void* func, void* ret, HMODULE mod)
	{
		HMODULE ret_mod = NULL;
		if (mod)
		{
			ret_mod = peb_walker::tib().get_hmodule(ret);
		}

		uint8_t ret_bytes[15];
		memcpy(ret_bytes, (char*)ret - 5, sizeof(ret_bytes));
		if (ret_bytes[0] == 0xe8)
		{
			auto real_call_addr = (void*)((uint64_t)ret + *((int32_t*)(ret_bytes + 1)));
			if (real_call_addr == func)
			{
				return (mod == NULL || mod == ret_mod);
			}
		}
		else if (ret_bytes[5] == 0x68 && ret_bytes[5 + 5] == 0xe8)
		{
			// vmp PUSH bytecode, CALL
			return (mod == NULL || mod == ret_mod);
		}

		// TODO FIXME add support for call reg, etc.
		return false;
	}

	/// <summary>
	/// Verifies that the return address is a valid call within the provided module.
	/// 
	/// If the module is NULL, then it must just be a valid call.
	/// </summary>
	bool verify_ret_addr(void* func, void* ret, HMODULE m)
	{
		auto bret = (uint64_t)ret;
		auto walker = peb_walker::tib();
		auto valid = false;
		walker.iterate([func, ret, m, bret, &valid](RE_LDR_DATA_TABLE_ENTRY* mod, PLIST_ENTRY list_entry)
		{
			auto base = (uint64_t)mod->DllBase;
			auto dos_header = (PIMAGE_DOS_HEADER)base;
			auto nt_headers = (PIMAGE_NT_HEADERS)(base + dos_header->e_lfanew);
			auto end = (base + nt_headers->OptionalHeader.SizeOfImage);
			if (bret >= base && bret < (base + end))
			{
				valid = verify_ret_addr_ins(func, ret, m);
			}
		});
		return valid;
	}

	RE_PEB* get_peb()
	{
		return (RE_PEB*)__readgsqword(offsetof(GS, Peb));
	}

	bc_win_lock::bc_win_lock()
	{
		InitializeCriticalSection(&section);
	}

	void bc_win_lock::enter()
	{
		EnterCriticalSection(&section);
	}

	void bc_win_lock::exit()
	{
		LeaveCriticalSection(&section);
	}
}
```

`BinConExamples/BinConExamples.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{5ddd1b70-c2c3-45fa-8643-da31b8c9cbf1}</ProjectGuid>
    <RootNamespace>BinConExamples</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir)inc;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(SolutionDir)inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>DEBUG_LOG;DEBUG_TRACE;DEBUG_INFO;DEBUG_ERR;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <PreBuildEvent>
      <Command>
      </Command>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="bc_examples.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\BinCon\BinCon.vcxproj">
      <Project>{f76672d3-353d-4ef3-8933-1575d4f37e0a}</Project>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`BinConExamples/BinConExamples.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="bc_examples.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`BinConExamples/BinConExamples.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`BinConExamples/bc_examples.cpp`:

```cpp

#include <iostream>
#include <thread>
#include <chrono>

#include <Windows.h>

#include <xorstr.hpp>

#include <bc_var.h>
#include <bc_windows.h>
#include <bc_thirdparty.h>
#include <bc_integrity.h>
#include <bc_stub.h>
#include <bc_dyn_struct.h>


typedef bc::obfuscated_prim64<uint64_t, 0x1337, __LINE__> health_obf_type;
typedef bc::obfuscated_prim64<uint64_t, 0x1337, __LINE__> start_time_obf_type;
typedef bc::obfuscated_prim64<uint64_t, 0x1337, __LINE__> tick_obf_type;

struct secret
{

	bc::dynamic_struct<0x10> dynamic;
	bc::dynamic_struct_key health_key;
	bc::dynamic_struct_key start_time_key;
	bc::dynamic_struct_key tick_key;
	bc::dynamic_struct_key arr_key;

	__forceinline health_obf_type* health()
	{
		return dynamic.ref_field<health_obf_type>(health_key);
	}

	__forceinline start_time_obf_type* start_time()
	{
		return dynamic.ref_field<start_time_obf_type>(start_time_key);
	}

	__forceinline tick_obf_type* tick()
	{
		return dynamic.ref_field<tick_obf_type>(tick_key);
	}

	__forceinline uint32_t* arr()
	{
		return dynamic.ref_field<uint32_t>(arr_key);
	}

	__forceinline void init()
	{
		health_key = dynamic.add_field_typed<health_obf_type>();
		start_time_key = dynamic.add_field_typed<start_time_obf_type>();
		tick_key = dynamic.add_field_typed<tick_obf_type>();
		arr_key = dynamic.add_field(sizeof(uint32_t) * 4);
	}
};

secret* emulated_secret = nullptr;

void init_secret()
{
	emulated_secret = new(bc::get_chal_entry()->alloc_enc(sizeof(secret)))secret;
	emulated_secret->init();
	*emulated_secret->health() = 100;
	*emulated_secret->start_time() = GetTickCount64();
	*emulated_secret->tick() = 0;
}

void test_encrypted_arr(uint32_t* arr, size_t amount)
{
	for (auto i = 0ull; i < amount; i++)
	{
		arr[i] = 0x69696969;
	}
}

int main()
{
	BEGIN_VM(__FUNCTION__);
	std::srand(std::time(0));
	srand(std::time(0));

	std::cout << "Initializing secret... " << std::endl;
	init_secret();

	std::cout << "Secret: " << std::hex << (uint64_t)emulated_secret << std::endl;

	test_encrypted_arr(emulated_secret->arr(), 4);
	for (auto i = 0; i < 4; i++)
	{
		std::cout << "Test Arr: " << std::hex << emulated_secret->arr()[i] << std::endl;
	}

	auto ce = bc::get_chal_entry();
	ce->verify_anti_debug([](auto err)
	{

	});

	while (true)
	{
		std::cout << "Health: " << emulated_secret->health()->get() << std::endl;
		std::cout << "Start Time: " << emulated_secret->start_time()->get() << std::endl;
		std::cout << "Tick: " << emulated_secret->tick()->get() << std::endl;

		*emulated_secret->tick() += 1;
		std::this_thread::sleep_for(std::chrono::seconds(1));
	}

	END_VM(__FUNCTION__);
}

```

`BinConExamples/bc_gen.h`:

```h
#pragma once

#define ENCRYPT(O, X) O = X; \
{  \
	uint64_t __a; \
	uint64_t __b; \
	O ^= 66980015011682; \
	__a = (O & 15872) >> 9ull; \
	__b = (O & 34902897112121344) >> 50ull; \
	O &= ~15872; \
	O &= ~34902897112121344; \
	O |= __a << 50ull; \
	O |= __b << 9ull; \
	O ^= 59893318947167; \
	__a = (O & 33030144) >> 19ull; \
	__b = (O & 35465847065542656) >> 49ull; \
	O &= ~33030144; \
	O &= ~35465847065542656; \
	O |= __a << 49ull; \
	O |= __b << 19ull; \
}

#define DECRYPT(O, X) O = X; \
{  \
	uint64_t __a; \
	uint64_t __b; \
	__a = (O & 33030144) >> 19ull; \
	__b = (O & 35465847065542656) >> 49ull; \
	O &= ~33030144; \
	O &= ~35465847065542656; \
	O |= __a << 49ull; \
	O |= __b << 19ull; \
	O ^= 59893318947167; \
	__a = (O & 15872) >> 9ull; \
	__b = (O & 34902897112121344) >> 50ull; \
	O &= ~15872; \
	O &= ~34902897112121344; \
	O |= __a << 50ull; \
	O |= __b << 9ull; \
	O ^= 66980015011682; \
}


```

`BinConPacker/BinConPacker.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{b303de66-a224-432a-a33d-4184c1f38324}</ProjectGuid>
    <RootNamespace>BinConPacker</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(SolutionDir)inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>DEBUG_LOG;DEBUG_TRACE;DEBUG_INFO;DEBUG_ERR;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <Optimization>Full</Optimization>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="packer.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\inc\bc_stub.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`BinConPacker/BinConPacker.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="packer.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\inc\bc_stub.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`BinConPacker/BinConPacker.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`BinConPacker/packer.cpp`:

```cpp
#include <iostream>
#include <vector>
#include <istream>
#include <fstream>
#include <Windows.h>
#include <iostream>

#include <bc_stub.h>
#include <bc_log.h>

namespace bc
{
	struct pre_packed_resource
	{
		uint16_t id;
		uint64_t off;
		uint64_t size;
	};

	class byte_allocator
	{
	public:
		void* img = nullptr;
		size_t cur_size = 0;
		size_t max_size = 0;

	public:
		byte_allocator(size_t size)
		{
			img = malloc(size);
			memset(img, 0, size);
			max_size = size;
		}

	public:
		template <typename T>
		T* append(size_t amount)
		{
			auto ret = (char*)img + cur_size;
			if ((ret + amount) > ((char*)img + max_size))
			{
				ERR("Out of bounds! " << cur_size << ":" << max_size << ":" << amount);
			}

			cur_size += amount;
			return (T*)ret;
		}

		uint64_t off(void* v)
		{
			return (uint64_t)v - (uint64_t)img;
		}
	};

    std::vector<char> read_file(const std::string& name)
    {
        std::ifstream f(name, std::ios_base::binary);
        return std::vector<char>(std::istreambuf_iterator<char>(f), std::istreambuf_iterator<char>());
    }

	uint64_t rva_to_fva(PIMAGE_NT_HEADERS nt, uint64_t rva)
	{
		auto sect = IMAGE_FIRST_SECTION(nt);
		for (auto i = 0; i < nt->FileHeader.NumberOfSections; i++, sect++)
		{
			if (rva >= sect->VirtualAddress && rva < (sect->VirtualAddress + sect->SizeOfRawData))
			{
return rva - sect->VirtualAddress + sect->PointerToRawData;
			}
		}

		ERR("failed to resolve rva to fva " << std::hex << rva << std::endl);
		return 0;
	}

	uint64_t fva_to_rva(PIMAGE_NT_HEADERS nt, uint64_t fva)
	{
		auto sect = IMAGE_FIRST_SECTION(nt);
		for (auto i = 0; i < nt->FileHeader.NumberOfSections; i++, sect++)
		{
			if (fva >= sect->PointerToRawData && fva < (sect->PointerToRawData + sect->SizeOfRawData))
			{
				return fva - sect->PointerToRawData + sect->VirtualAddress;
			}
		}

		ERR("failed to resolve fva to rva " << std::hex << fva << std::endl);
		return 0;
	}

	uint64_t packed_rva_to_fva(packed_app* app, uint64_t rva)
	{
		auto sections = (packed_section*)((char*)app + app->off_to_sections.off.get());
		for (auto i = 0; i < app->off_to_sections.num_elements.get(); i++)
		{
			auto section = &sections[i];
			if (rva >= section->rva && rva < (section->rva + section->size_of_data))
			{
				return rva - section->rva + section->off_to_data;
			}
		}
		return 0;
	}

	template<typename FN>
	static __forceinline void parse_rsc_entries(SIZE_T num_tabs, std::vector<uint16_t>& name_stack, PIMAGE_RESOURCE_DIRECTORY directory, PIMAGE_RESOURCE_DIRECTORY_ENTRY entry, FN iterator)
	{
		name_stack.push_back(entry->Name);
		if (entry->OffsetToData & IMAGE_RESOURCE_DATA_IS_DIRECTORY)
		{
			auto new_dir = (PIMAGE_RESOURCE_DIRECTORY)((char*)directory + (entry->OffsetToDirectory));
			auto num_entries = new_dir->NumberOfIdEntries + new_dir->NumberOfNamedEntries;

			if (num_entries)
			{
				auto child = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((char*)new_dir + sizeof(IMAGE_RESOURCE_DIRECTORY));
				for (auto i = 0; i < num_entries; i++)
				{
					parse_rsc_entries(num_tabs + 1, name_stack, directory, &child[i], iterator);
				}
			}
		}
		else
		{
			auto e = (PIMAGE_RESOURCE_DATA_ENTRY)((char*)directory + (entry->OffsetToData));

			iterator(name_stack, e);
		}
		name_stack.erase(name_stack.end() - 1);
	}

	void fill_rng(void* p, size_t sz)
	{
		for (size_t i = 0; i < sz; i++)
		{
			((char*)p)[i] = (char)rand();
		}
	}

	void erase_data_directory(PIMAGE_NT_HEADERS nt, PIMAGE_DATA_DIRECTORY data_directory, packed_app* app)
	{
		if (auto fva = packed_rva_to_fva(app, data_directory->VirtualAddress))
		{
			auto end_fva = fva + data_directory->Size;
			if (fva >= 0 && end_fva < (app->size_of_app.get()))
			{
				fill_rng((char*)app + fva, data_directory->Size);
			}
		}
	}

    void pack(char* input, bool cfg_command_line, bool cfg_lazy_load_code)
    {
        auto read = read_file(input);
        auto dos = (PIMAGE_DOS_HEADER)(read.data());
        auto nt = (PIMAGE_NT_HEADERS)(read.data() + dos->e_lfanew);

		INFO("calculating image size" << std::endl);

		auto reloc_count = 0;
		auto sect_size = 0;
		auto import_count = 0;
		auto tls_callback_count = 0;
		auto rsc_size = 0;
		std::vector<pre_packed_resource> resource_data_entries;
		if (auto rva = nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress)
		{
			auto base_reloc_dir = nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
			auto reloc = (PIMAGE_BASE_RELOCATION)((UINT64)read.data() + rva_to_fva(nt, rva));
			auto reloc_ptr = 0;

			for (auto cs = 0UL; cs < base_reloc_dir.Size;)
			{
				auto c_reloc_count = (reloc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
				auto reloc_data = (PUINT16)((PCHAR)reloc + sizeof(IMAGE_BASE_RELOCATION));

				for (auto i = 0UL; i < c_reloc_count; ++i, ++reloc_data)
				{
					auto data = *reloc_data;
					auto type = data >> 12;
					auto offset = data & 0xFFF;

					if (type == IMAGE_REL_BASED_DIR64)
					{
						reloc_count += 1;
					}
				}

				cs += reloc->SizeOfBlock;
				reloc = (PIMAGE_BASE_RELOCATION)reloc_data;
			}
		}

		auto sect = IMAGE_FIRST_SECTION(nt);
		for (auto i = 0; i < nt->FileHeader.NumberOfSections; i++, sect++)
		{
			sect_size += sect->SizeOfRawData;
		}

		if (auto rva = nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress)
		{
			auto iat_desc = (PIMAGE_IMPORT_DESCRIPTOR)((UINT64)read.data() + rva_to_fva(nt, rva));
			for (; iat_desc->FirstThunk; ++iat_desc)
			{
				if (auto fthunk = iat_desc->FirstThunk)
				{
					auto thunk = (PIMAGE_THUNK_DATA)((UINT64)read.data() + rva_to_fva(nt, fthunk));
					while (thunk->u1.AddressOfData)
					{
						import_count += 1;
						thunk += 1;
					}
				}
			}
		}
		
		if (auto rva = nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress)
		{
			auto tls_dir = (PIMAGE_TLS_DIRECTORY)((UINT64)read.data() + rva_to_fva(nt, rva));
			if (tls_dir->AddressOfCallBacks)
			{
				auto cur = (UINT64*)((UINT64)read.data() + rva_to_fva(nt, tls_dir->AddressOfCallBacks - nt->OptionalHeader.ImageBase));
				while (*cur)
				{
					tls_callback_count += 1;
					cur += 1;
				}
			}
		}

		if (auto rva = nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress)
		{
			auto rsc_dir = (PIMAGE_RESOURCE_DIRECTORY)((UINT64)read.data() + rva_to_fva(nt, rva));
			auto num_entries = rsc_dir->NumberOfIdEntries + rsc_dir->NumberOfNamedEntries;
			if (num_entries)
			{
				auto dir = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((char*)rsc_dir + sizeof(IMAGE_RESOURCE_DIRECTORY));
				for (auto i = 0; i < (rsc_dir->NumberOfIdEntries + rsc_dir->NumberOfNamedEntries); i++)
				{
					std::vector<uint16_t> name_stack;
					parse_rsc_entries(1, name_stack, rsc_dir, &dir[i], [nt, &resource_data_entries, &rsc_size](auto& name_stack, auto entry)
					{
						if (name_stack.size() == 3)
						{
							rsc_size += entry->Size;

							pre_packed_resource rsc;
							rsc.id = name_stack[1];
							rsc.off = rva_to_fva(nt, entry->OffsetToData);
							rsc.size = entry->Size;
							resource_data_entries.push_back(rsc);
						}
					});
				}
			}
		}

        auto size_of_img =
            sizeof(packed_app) +
			nt->OptionalHeader.SizeOfHeaders +
            (nt->FileHeader.NumberOfSections * sizeof(packed_section)) +
			(resource_data_entries.size() * sizeof(packed_resource)) +
			(reloc_count * sizeof(packed_reloc)) +
			(import_count * sizeof(packed_import)) +
			(tls_callback_count * sizeof(packed_tls_callback)) +
			rsc_size +
			sect_size;

		INFO(" -> image_data" << std::endl);
		INFO("  -> section_count= " << nt->FileHeader.NumberOfSections);
		INFO("  -> resource_count= " << resource_data_entries.size());
		INFO("  -> reloc_count= " << reloc_count << ":" << rsc_size);
		INFO("  -> import_count= " << import_count);
		INFO("  -> tls_cb_count= " << tls_callback_count);
		INFO("  -> size_of_img= " << size_of_img);

		byte_allocator allocator(size_of_img);
		auto app = allocator.append<packed_app>(sizeof(packed_app));
		INFO(" -> app sz:" << allocator.cur_size << ":" << allocator.max_size);

		auto headers = allocator.append<char>(nt->OptionalHeader.SizeOfHeaders);
		INFO(" -> headers sz:" << allocator.cur_size << ":" << allocator.max_size);

		auto sections = allocator.append<packed_section>(nt->FileHeader.NumberOfSections * sizeof(packed_section));
		INFO(" -> sections sz:" << allocator.cur_size << ":" << allocator.max_size);

		auto resources = allocator.append<packed_resource>(resource_data_entries.size() * sizeof(packed_resource));
		INFO(" -> resources sz:" << allocator.cur_size << ":" << allocator.max_size);

		auto imports = allocator.append<packed_import>(import_count * sizeof(packed_import));
		INFO(" -> import sz:" << allocator.cur_size << ":" << allocator.max_size);

		auto relocs = allocator.append<packed_reloc>(reloc_count * sizeof(packed_reloc));
		INFO(" -> reloc sz:" << allocator.cur_size << ":" << allocator.max_size);

		auto tls_callbacks = allocator.append<packed_reloc>(tls_callback_count * sizeof(packed_tls_callback));
		INFO(" -> tls cb sz:" << allocator.cur_size << ":" << allocator.max_size);

		if (cfg_command_line)
		{
			app->options |= (uint8_t)packed_app_option::console;
		}

		if (cfg_lazy_load_code)
		{
			app->options |= (uint8_t)packed_app_option::lazy_load_code;
		}

		app->ep = nt->OptionalHeader.AddressOfEntryPoint;
		app->size_of_img = nt->OptionalHeader.SizeOfImage;
		app->size_of_app = size_of_img;
		app->preferred_base = nt->OptionalHeader.ImageBase;

		app->off_to_headers.num_elements = nt->OptionalHeader.SizeOfHeaders;
		app->off_to_headers.off = allocator.off(headers);

		app->off_to_sections.num_elements = nt->FileHeader.NumberOfSections;
		app->off_to_sections.off = allocator.off(sections);

		app->off_to_resources.num_elements = resource_data_entries.size();
		app->off_to_resources.off = allocator.off(resources);

		app->off_to_relocs.num_elements = reloc_count;
		app->off_to_relocs.off = allocator.off(relocs);

		app->off_to_iat.num_elements = import_count;
		app->off_to_iat.off = allocator.off(imports);

		INFO(" -> building headers");
		memcpy(headers, dos, nt->OptionalHeader.SizeOfHeaders);

		INFO(" -> building sections:" << allocator.cur_size << ":" << allocator.max_size);
		sect = IMAGE_FIRST_SECTION(nt);
		for (auto i = 0; i < nt->FileHeader.NumberOfSections; i++, sect++)
		{
			sections[i].size_of_data = sect->SizeOfRawData;
			sections[i].rva = sect->VirtualAddress;

			auto section = allocator.append<void>(sect->SizeOfRawData);
			memcpy(section, read.data() + sect->PointerToRawData, sect->SizeOfRawData);

			obfuscated_byte_array<0x1337, 7> ba(section, sect->SizeOfRawData);
			ba.encrypt();

			sections[i].off_to_data = allocator.off(section);
			sections[i].characteristics = 0;

			if (sect->Characteristics & (IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_CNT_CODE))
			{
				sections[i].characteristics |= (uint64_t)packed_section_characteristic::can_lazy_load;
			}
		}

		INFO(" -> building resources");
		for (auto i = 0; i < resource_data_entries.size(); i++)
		{
			auto rsc_packed = &resources[i];

			auto rsc_entry = resource_data_entries[i];
			auto rsc_data = allocator.append<void>(rsc_entry.size);

			memcpy(rsc_data, read.data() + rsc_entry.off, rsc_entry.size);

			rsc_packed->id = rsc_entry.id;
			rsc_packed->off_to_data = allocator.off(rsc_data);
			rsc_packed->size_of_data = rsc_entry.size;
		}

		INFO(" -> building relocations");
		if (auto rva = nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress)
		{
			auto base_reloc_dir = nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
			auto reloc = (PIMAGE_BASE_RELOCATION)((UINT64)read.data() + rva_to_fva(nt, rva));
			auto reloc_ptr = 0;

			for (auto cs = 0UL; cs < base_reloc_dir.Size;)
			{
				auto reloc_count = (reloc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
				auto reloc_data = (PUINT16)((PCHAR)reloc + sizeof(IMAGE_BASE_RELOCATION));

				for (auto i = 0UL; i < reloc_count; ++i, ++reloc_data)
				{
					auto data = *reloc_data;
					auto type = data >> 12;
					auto offset = data & 0xFFF;

					if (type == IMAGE_REL_BASED_DIR64)
					{
						relocs[reloc_ptr].rva = reloc->VirtualAddress + offset;
						reloc_ptr += 1;
					}
				}

				cs += reloc->SizeOfBlock;
				reloc = (PIMAGE_BASE_RELOCATION)reloc_data;
			}
		}

		INFO("building imports");
		if (auto rva = nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress)
		{
			auto import_ptr = 0;
			auto iat_desc = (PIMAGE_IMPORT_DESCRIPTOR)((UINT64)read.data() + rva_to_fva(nt, rva));
			for (; iat_desc->FirstThunk; ++iat_desc)
			{
				auto module_name = read.data() + rva_to_fva(nt, iat_desc->Name);
				if (auto fthunk = iat_desc->FirstThunk)
				{
					auto thunk = (PIMAGE_THUNK_DATA)((UINT64)read.data() + rva_to_fva(nt, fthunk));
					while (thunk->u1.AddressOfData)
					{
						imports[import_ptr].mod = module_name;
						imports[import_ptr].rva = fva_to_rva(nt, (uint64_t)&thunk->u1.Function - (uint64_t)read.data());
						if (thunk->u1.Ordinal & IMAGE_ORDINAL_FLAG)
						{
							imports[import_ptr].ordinal = thunk->u1.Ordinal & 0xffff;
							imports[import_ptr].type = packed_import_type::ordinal;
						}
						else
						{
							auto name = (PIMAGE_IMPORT_BY_NAME)(read.data() + rva_to_fva(nt, thunk->u1.AddressOfData));
							imports[import_ptr].name = name->Name;
							imports[import_ptr].type = packed_import_type::name;
						}

						thunk += 1;
						import_ptr += 1;
					}
				}
			}
		}

		INFO("building TLS");
		if (auto rva = nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress)
		{
			auto tls_ptr = 0;
			auto tls_dir = (PIMAGE_TLS_DIRECTORY)((UINT64)read.data() + rva_to_fva(nt, rva));
			if (tls_dir->AddressOfCallBacks)
			{
				auto cur = (UINT64*)((UINT64)read.data() + rva_to_fva(nt, tls_dir->AddressOfCallBacks - nt->OptionalHeader.ImageBase));
				while (*cur)
				{
					tls_callbacks[tls_ptr].rva = (*cur - nt->OptionalHeader.ImageBase);
					tls_ptr += 1;
					cur += 1;
				}
			}
		}

		INFO("Allocator: " << size_of_img << ":" << allocator.cur_size);

		INFO("Erasing data directories from sections");
		erase_data_directory(nt, &nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS], app);
		erase_data_directory(nt, &nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC], app);
		erase_data_directory(nt, &nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG], app);
		erase_data_directory(nt, &nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY], app);
		erase_data_directory(nt, &nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT], app);
		erase_data_directory(nt, &nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG], app);

		INFO("Beginning resource update");
		auto rsc = BeginUpdateResource(L"BinConPackerStub.exe", TRUE);

		INFO("Updating resource " << rsc);
		if (UpdateResource(rsc, RT_RCDATA, L"p", MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), (char*)allocator.img, allocator.cur_size))
		{
			EndUpdateResource(rsc, FALSE);
		}

		INFO("Done!");
    }
}

int main(int argc, char* argv[])
{
	
	bool cfg_command_line = false;
	bool cfg_lazy_load_code = false;

	srand(time(NULL));

    if (argc < 2)
    {
		ERR("Correct usage: BinConPacker app.exe [-command_line] [-lazy_load_code]");
		goto _ret;
    }

	for (auto i = 1; i < argc; i++)
	{
		if (!strcmp(argv[i], "-command_line"))
		{
			cfg_command_line = true;
		}
		else if (!strcmp(argv[i], "-lazy_load_code"))
		{
			cfg_lazy_load_code = true;
		}
	}

	bc::pack(argv[1], cfg_command_line, cfg_lazy_load_code);

_ret:
	std::cin.get();
	return 0;
}

```

`BinConPackerStub/BinConPackerStub.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{b3b138d3-1441-4d07-979a-663fd29ffc81}</ProjectGuid>
    <RootNamespace>BinConPackerStub</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(SolutionDir)inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>DEBUG_LOG;DEBUG_TRACE;DEBUG_INFO;DEBUG_ERR;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalDependencies>ntdll.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="crt.h" />
    <ClCompile Include="load.cpp" />
    <ClCompile Include="veh.cpp" />
    <ClCompile Include="x86_emulator.cpp" />
    <ClCompile Include="packer_stub.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\BinCon\BinCon.vcxproj">
      <Project>{f76672d3-353d-4ef3-8933-1575d4f37e0a}</Project>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="native.asm" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stub.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="load.h" />
    <None Include="stub_inc.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`BinConPackerStub/BinConPackerStub.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="packer_stub.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="x86_emulator.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="veh.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="load.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="crt.h">
      <Filter>Header Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="native.asm">
      <Filter>Source Files</Filter>
    </MASM>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stub.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <None Include="load.h">
      <Filter>Header Files</Filter>
    </None>
    <None Include="stub_inc.h">
      <Filter>Header Files</Filter>
    </None>
  </ItemGroup>
</Project>
```

`BinConPackerStub/BinConPackerStub.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`BinConPackerStub/crt.h`:

```h
#pragma once
#include <iostream>
#include <io.h>
#include <fcntl.h>

#include <Windows.h>

#include "stub.h"

#include <bc_stub.h>
#include <bc_peb.h>
#include <bc_util.h>
#include <bc_thirdparty.h>
#include <bc_integrity.h>
#include <bc_windows.h>
#include <bc_log.h>
#include <bc_pe.h>
#include <bc_iat.h>

#include <xorstr.hpp>

namespace bc
{
    /// <summary>
    /// Determines if a thread is still running.
    /// </summary>
    __forceinline bool is_thread_still_running(HANDLE h)
    {
        return WaitForSingleObject(h, 0) != WAIT_TIMEOUT;
    }

    __forceinline void bind_crt_handles_to_std_handles()
    {
        FILE* df_1;
        freopen_s(&df_1, xorstr_("nul"), xorstr_("r"), stdin);

        FILE* df_2;
        freopen_s(&df_2, xorstr_("nul"), xorstr_("w"), stdout);

        FILE* df_3;
        freopen_s(&df_3, xorstr_("nul"), xorstr_("w"), stderr);

        {
            auto std_handle = IAT.GetStdHandle(STD_INPUT_HANDLE);
            if (std_handle != INVALID_HANDLE_VALUE)
            {
                auto file_desc = _open_osfhandle((intptr_t)std_handle, _O_TEXT);
                if (file_desc != -1)
                {
                    auto file = _fdopen(file_desc, xorstr_("r"));
                    if (file != NULL)
                    {
                        auto dup2_res = _dup2(_fileno(file), _fileno(stdin));
                        if (dup2_res == 0)
                        {
                            setvbuf(stdin, NULL, _IONBF, 0);
                        }
                    }
                }
            }
        }

        {
            auto std_handle = IAT.GetStdHandle(STD_OUTPUT_HANDLE);
            if (std_handle != INVALID_HANDLE_VALUE)
            {
                auto file_desc = _open_osfhandle((intptr_t)std_handle, _O_TEXT);
                if (file_desc != -1)
                {
                    auto file = _fdopen(file_desc, xorstr_("w"));
                    if (file != NULL)
                    {
                        int dup2_res = _dup2(_fileno(file), _fileno(stdout));
                        if (dup2_res == 0)
                        {
                            setvbuf(stdout, NULL, _IONBF, 0);
                        }
                    }
                }
            }
        }

        {
            auto std_handle = IAT.GetStdHandle(STD_ERROR_HANDLE);
            if (std_handle != INVALID_HANDLE_VALUE)
            {
                auto file_desc = _open_osfhandle((intptr_t)std_handle, _O_TEXT);
                if (file_desc != -1)
                {
                    auto file = _fdopen(file_desc, xorstr_("w"));
                    if (file != NULL)
                    {
                        auto dup2_res = _dup2(_fileno(file), _fileno(stderr));
                        if (dup2_res == 0)
                        {
                            setvbuf(stderr, NULL, _IONBF, 0);
                        }
                    }
                }
            }
        }

        std::wcin.clear();
        std::cin.clear();

        std::wcout.clear();
        std::cout.clear();

        std::wcerr.clear();
        std::cerr.clear();
    }
}
```

`BinConPackerStub/load.cpp`:

```cpp
#include "stub.h"

#include <bc_iat.h>

namespace bc
{
    HRSRC hook_find_resource(HMODULE m, LPCSTR rsc, LPCSTR type)
    {
        UNREFERENCED_PARAMETER(m);
        UNREFERENCED_PARAMETER(type);

        auto pca = (packed_resource*)((char*)BC.app + BC.app->off_to_resources.off);
        for (auto i = 0ull; i < BC.app->off_to_resources.num_elements; i++)
        {
            auto pc = &pca[i];
            if (pc->id == (uint16_t)rsc)
            {
                return (HRSRC)pc;
            }
        }
        return NULL;
    }

    HGLOBAL hook_load_resource(HMODULE m, HRSRC src)
    {
        UNREFERENCED_PARAMETER(m);
        return (HGLOBAL)src;
    }

    LPVOID hook_lock_resource(HGLOBAL global)
    {
        if (!global)
        {
            return NULL;
        }

        auto packed = (packed_resource*)global;
        return (char*)BC.app + packed->off_to_data.get();
    }

    DWORD hook_sizeof_resource(HMODULE m, HRSRC src)
    {
        UNREFERENCED_PARAMETER(m);

        if (!src)
        {
            return NULL;
        }

        auto packed = (packed_resource*)src;
        return (DWORD)packed->size_of_data;
    }

    /// <summary>
    /// Our hook for GetProcAddress. This allows us to query packer information without
    /// a custom entry-point.
    /// </summary>
    void* hook_get_proc_address(HMODULE m, const char* name)
    {
        BEGIN_VM(__FUNCTION__);

        disable_tf();
        auto peb = peb_walker::tib();
        void* proc = NULL;

        if (m == (HMODULE)0xBC && !strcmp(name, xorstr_("pack_interface")))
        {
            return &BC.cur_chal_entry;
        }

        if (!m)
        {
            goto _ret;
        }

        proc = peb.resolve_function((char*)m, name);
        if (!proc)
        {
            proc = (void*)IAT.GetProcAddress(m, name);
        }

        if (!proc)
        {
            ERR("Failed to get proc address " << m << " " << name);
        }

    _ret:
        END_VM(__FUNCTION__);
        return proc;
    }

}
```

`BinConPackerStub/load.h`:

```h
#pragma once
#include <bc_iat.h>

namespace bc
{
    /// <summary>
    /// Maps the custom image format into the memory of this process as a some-what valid PE image.
    /// </summary>
    static __forceinline void* map()
    {
        auto begin = (uint64_t)BC.app;
        auto sections = (packed_section*)(begin + BC.app->off_to_sections.off);
        auto imports = (packed_import*)(begin + BC.app->off_to_iat.off);
        auto relocs = (packed_reloc*)(begin + BC.app->off_to_relocs.off);
        auto walker = peb_walker::tib();

        HANDLE section;

        LARGE_INTEGER section_size;
        section_size.QuadPart = BC.app->size_of_img.get();

        LARGE_INTEGER section_offset = { 0 };
        SIZE_T section_view_size = 0;
        void* section_view_base = NULL;

        LOG(xorstr_("Size of img: ") << std::hex << BC.app->size_of_img.get());

        IAT.NtCreateSection(&section, SECTION_ALL_ACCESS, NULL, &section_size, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL);

        IAT.NtMapViewOfSection(section, IAT.GetCurrentProcess(), &section_view_base, 0, BC.app->size_of_img, &section_offset, &section_view_size, ViewUnmap, 0, PAGE_READWRITE);
        BC.img_all_perms = (char*)section_view_base;

        section_view_base = NULL;
        section_offset = { 0 };
        section_view_size = 0;

        IAT.NtMapViewOfSection(section, IAT.GetCurrentProcess(), &section_view_base, 0, BC.app->size_of_img, &section_offset, &section_view_size, ViewUnmap, 0, PAGE_EXECUTE_READWRITE);
        BC.img = (char*)section_view_base;

        LOG("Setting image to zero");
        memset(BC.img, 0, BC.app->size_of_img);

        LOG("Filling in headers");
        memcpy(BC.img, (char*)begin + BC.app->off_to_headers.off.get(), BC.app->off_to_headers.num_elements.get());

        LOG("Filling in sections");
        for (auto i = 0; i < BC.app->off_to_sections.num_elements; i++)
        {
            obfuscated_byte_array<0x1337, 7> ba((char*)begin + sections[i].off_to_data.get(), sections[i].size_of_data.get());
            ba.decrypt();

            memcpy(BC.img + sections[i].rva, (char*)begin + sections[i].off_to_data.get(), sections[i].size_of_data.get());
            ba.encrypt();
        }

        LOG("Patching deltas");
        auto delta = (uint64_t)BC.img - (uint64_t)BC.app->preferred_base;
        for (auto i = 0ull; i < BC.app->off_to_relocs.num_elements; i++)
        {
            *((uint64_t*)(BC.img + relocs[i].rva)) += delta;
        }

        LOG("Filling in imports");
        for (auto i = 0ull; i < BC.app->off_to_iat.num_elements; i++)
        {
            auto& import = imports[i];

            wchar_t module_name_wide[256];

            char module_name[256];
            import.mod.get(module_name);

            ascii_to_wide(module_name, module_name_wide);

            auto llw = (decltype(LoadLibraryW)*)walker.resolve_function(xorstr_(L"Kernel32.dll"), xorstr_("LoadLibraryW"));
            auto gpa = (decltype(GetProcAddress)*)walker.resolve_function(xorstr_(L"Kernel32.dll"), xorstr_("GetProcAddress"));
            auto module = llw(module_name_wide);

            uint64_t resolved = 0;
            switch (import.type)
            {
            case packed_import_type::name:
            {
                char dec_name[256];
                import.name.get(dec_name);

                resolved = (uint64_t)walker.resolve_function(module_name_wide, dec_name);
                if (!resolved)
                {
                    resolved = (uint64_t)gpa(module, dec_name);
                }

                LOG("[info] import " << std::hex << (uint64_t)BC.img << " " << import.rva.get() << " " << dec_name << " " << resolved);
                *((uint64_t*)(BC.img + import.rva)) = resolved;
                break;
            }

            case packed_import_type::ordinal:
                LOG("[info] import ordinal " << import.ordinal.get());
                resolved = (uint64_t)gpa(module, MAKEINTRESOURCEA(import.ordinal.get()));
                *((uint64_t*)(BC.img + import.rva)) = resolved;
                break;
            default:
                break;
            }

            if (!resolved)
            {
                ERR("Failed to get proc address " << module_name);
            }
            else if (*((uint64_t*)(BC.img + import.rva)) == (uint64_t)IAT.GetProcAddress.get())
            {
                LOG("[info] hooked GetProcAddress");
                *((uint64_t*)(BC.img + import.rva)) = (uint64_t)hook_get_proc_address;
            }
            else if (*((uint64_t*)(BC.img + import.rva)) == (uint64_t)IAT.FindResourceA.get() ||
                     *((uint64_t*)(BC.img + import.rva)) == (uint64_t)IAT.FindResourceW.get())
            {
                LOG("[info] hooked FindResource");
                *((uint64_t*)(BC.img + import.rva)) = (uint64_t)hook_find_resource;
            }
            else if (*((uint64_t*)(BC.img + import.rva)) == (uint64_t)IAT.LoadResource.get())
            {
                LOG("[info] hooked LoadResource");
                *((uint64_t*)(BC.img + import.rva)) = (uint64_t)hook_load_resource;
            }
            else if (*((uint64_t*)(BC.img + import.rva)) == (uint64_t)IAT.LockResource.get())
            {
                LOG("[info] hooked LockResource");
                *((uint64_t*)(BC.img + import.rva)) = (uint64_t)hook_lock_resource;
            }
            else if (*((uint64_t*)(BC.img + import.rva)) == (uint64_t)IAT.SizeofResource.get())
            {
                LOG("[info] hooked SizeofResource");
                *((uint64_t*)(BC.img + import.rva)) = (uint64_t)hook_sizeof_resource;
            }
        }

        if (has_option(BC.app, packed_app_option::lazy_load_code))
        {
            LOG("Guarding memory");
            for (auto i = 0; i < BC.app->off_to_sections.num_elements; i++)
            {
                uint64_t characteristics = sections[i].characteristics;
                if (characteristics & (uint64_t)packed_section_characteristic::can_lazy_load)
                {
                    DWORD old_protect;
                    IAT.VirtualProtect(BC.img + sections[i].rva, sections[i].size_of_data, PAGE_NOACCESS, &old_protect);

                    obfuscated_byte_array<0x1337, 7> ba((char*)BC.img_all_perms + sections[i].rva, sections[i].size_of_data);
                    ba.encrypt();

                    for (auto j = 0ull; j < sections[i].size_of_data / PAGE_SIZE_4KB; j++)
                    {
                        MappedArea area;
                        area.base = sections[i].rva + (j * PAGE_SIZE_4KB);
                        area.encrypted = true;

                        BC.mapped_areas[area.base] = area;
                    }
                }
            }
        }

        return BC.img;
    }
}
```

`BinConPackerStub/native.asm`:

```asm
.code

disable_tf proc
	pushfq
	and qword ptr[rsp], 0fffffeffh
	popfq
	ret
disable_tf endp

end
```

`BinConPackerStub/packer_stub.cpp`:

```cpp
#include "stub.h"
#include "crt.h"
#include "load.h"

#include <cstdint>
#include <Windows.h>
#include <fstream>
#include <vector>
#include <iostream>
#include <io.h>
#include <fcntl.h>
#include <map>
#include <tlhelp32.h>

#include <bc_iat.h>

#include <xorstr.hpp>

#include <Zydis/Zydis.h>

namespace bc
{
    StubContext BC;

    static void verify_anti_debug_pack(fn_integrity_check_failed on_fail)
    {
        disable_tf();

        auto app_opts = BC.app->options.get();
        auto lazy_load_code = (app_opts & (uint8_t)packed_app_option::lazy_load_code) != 0;

        if (!BC.ntdll_validator.validate((void*)GetModuleHandleA(xorstr_("ntdll.dll"))))
        {
            on_fail(bc_error::bad_module_checksum);
        }

        if (!BC.kernel32_validator.validate((void*)GetModuleHandleA(xorstr_("kernel32.dll"))))
        {
            on_fail(bc_error::bad_module_checksum);
        }

        if (lazy_load_code && !is_thread_still_running(BC.reencrypt_thread_handle))
        {
            on_fail(bc_error::reencrypt_thread_not_running);
        }

        if (has_option(BC.app, packed_app_option::anti_debug))
        {
            verify_anti_debug(on_fail);
        }
    }

    void run()
    {
        BEGIN_VM(__FUNCTION__);
        IAT.InitializeCriticalSection(&BC.veh_section);

        auto rsc = IAT.FindResourceW(NULL, xorstr_(L"p"), RT_RCDATA);
        auto rsc_size = IAT.SizeofResource(NULL, rsc);
        auto rsc_data = IAT.LoadResource(NULL, rsc);
        auto rsc_bin = IAT.LockResource(rsc_data);
        auto copy = malloc(rsc_size);
        memcpy(copy, rsc_bin, rsc_size);
        UnlockResource(rsc_data);
        
        BC.app = (packed_app*)copy;

        if (has_option(BC.app, packed_app_option::console))
        {
            if (AllocConsole())
            {
                IAT.SetConsoleTitleW(xorstr_(L"BinCon"));
                IAT.SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_RED);
                bind_crt_handles_to_std_handles();
            }
        }

        INFO("Adding VEH");
        IAT.AddVectoredExceptionHandler(TRUE, decrypt_code_except_handler);

        if (has_option(BC.app, packed_app_option::anti_debug))
        {
            INFO("Installing anti-debug");
            install_anti_debug();
        }

        INFO("Creating PE validators");
        BC.ntdll_validator = pe_validator::map(IAT.GetModuleHandleA(xorstr_("ntdll.dll")));
        BC.kernel32_validator = pe_validator::map(IAT.GetModuleHandleA(xorstr_("kernel32.dll")));

        INFO("Mapping");
        auto mapped = map();

        INFO("Generating chal entry");
        BC.cur_chal_entry = gen_chal_entry();
        BC.cur_chal_entry.re_encrypt_code = re_encrypt_code;
        BC.cur_chal_entry.alloc_enc = (fn_alloc_encrypted)allocate_encrypted;
        BC.cur_chal_entry.free_enc = (fn_free_encrypted)free_encrypted;
        BC.cur_chal_entry.verify_anti_debug = verify_anti_debug_pack;

        if (has_option(BC.app, packed_app_option::lazy_load_code))
        {
            INFO("Creating re-entry code thread");
            BC.reencrypt_thread_handle = IAT.CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)re_encrypt_code_thread, NULL, 0, NULL);
        }

        INFO("Calling main @ " << std::hex << ((uint64_t)mapped + BC.app->ep));
        if (has_option(BC.app, packed_app_option::chal_entry))
        {
            ((fn_main_chal)((uint64_t)mapped + BC.app->ep))(&BC.cur_chal_entry);
        }
        else
        {
            const char* args[2] =
            {
                "BinCon",
                "Packer"
            };

            ((fn_main)((uint64_t)mapped + BC.app->ep))(2, args);
        }

        END_VM(__FUNCTION__);
    }
}

int APIENTRY wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nCmdShow)
{
    bc::init_crc32_table();
    bc::init_iat();
    bc::run();
    return 0;
}


```

`BinConPackerStub/stub.h`:

```h
#pragma once
#include <cstdint>

#include <iostream>
#include <io.h>
#include <fcntl.h>

#include <Windows.h>

#include <bc_stub.h>
#include <bc_peb.h>
#include <bc_util.h>
#include <bc_thirdparty.h>
#include <bc_integrity.h>
#include <bc_windows.h>
#include <bc_log.h>
#include <bc_pe.h>

#define TIME_BETWEEN_RE_ENCRYPT_CHECKS 1000
#define TIME_BETWEEN_NO_ACCESS_ENCRYPT 7000

namespace bc
{
    struct MappedArea
    {
        uint64_t base = 0;
        uint64_t no_access_time = 0;
        uint64_t decrypt_hits = 0;
        bool no_access = false;
        bool encrypted = false;
    };

    struct StubContext
    {
        packed_app* app = nullptr;
        char* img;
        char* img_all_perms;

        chal_entry cur_chal_entry;

        // PE validators
        pe_validator ntdll_validator;
        pe_validator kernel32_validator;

        CRITICAL_SECTION veh_section;

        HANDLE reencrypt_thread_handle = NULL;

        std::map<uint64_t, MappedArea> mapped_areas;

        
    };

    typedef int (*fn_main)(int argc, const char* argv[]);
    typedef void(*fn_main_chal)(chal_entry* ce);

    void free_encrypted(uint64_t addr);
    uint64_t allocate_encrypted(size_t size);
    bool emulate_encrypted_ins(PCONTEXT context, void* ins);
    uint64_t resolve_mem_ref(PCONTEXT context, void* ins);

    void re_encrypt_code();
    void re_encrypt_code_thread();
    LONG decrypt_code_except_handler(_EXCEPTION_POINTERS* exception_info);

    void* hook_get_proc_address(HMODULE m, const char* name);
    HRSRC hook_find_resource(HMODULE m, LPCSTR rsc, LPCSTR type);
    HGLOBAL hook_load_resource(HMODULE m, HRSRC src);
    LPVOID hook_lock_resource(HGLOBAL global);
    DWORD hook_sizeof_resource(HMODULE m, HRSRC src);

    extern StubContext BC;

    extern "C" void disable_tf();
}
```

`BinConPackerStub/stub_inc.h`:

```h
#pragma once

namespace bc
{
    /// <summary>
    /// Finds a section by a relative virtual address.
    /// </summary>
    static __forceinline bc::packed_section* section_by_rva(uint64_t rva)
    {
        auto begin = (uint64_t)BC.app;
        auto sections = (packed_section*)(begin + BC.app->off_to_sections.off);

        for (auto i = 0ull; i < BC.app->off_to_sections.num_elements.get(); i++)
        {
            auto& section = sections[i];
            if (rva >= section.rva && rva < (section.rva + section.size_of_data))
            {
                return &section;
            }
        }

        return NULL;
    }
}
```

`BinConPackerStub/veh.cpp`:

```cpp
#include "stub.h"

#include <bc_iat.h>

namespace bc
{
    /// <summary>
    /// Re-encrypts all code sections.
    /// </summary>
    void re_encrypt_code()
    {
        disable_tf();
        IAT.EnterCriticalSection(&BC.veh_section);

        auto num_pages_total = BC.mapped_areas.size();
        auto num_pages_encrypted = 0;
        auto num_pages_no_access = 0;
        for (auto kv : BC.mapped_areas)
        {
            auto& ma = kv.second;
            if (ma.encrypted)
            {
                num_pages_encrypted += 1;
            }
            
            if (ma.no_access)
            {
                num_pages_no_access += 1;
            }
        }

        auto iimg = (uint64_t)BC.img;
        auto iapp = (uint64_t)BC.app;
        auto sections = (packed_section*)(iapp + BC.app->off_to_sections.off);
        auto time = IAT.GetTickCount64();

        INFO("re-encrypting code (" << num_pages_total << ":" << num_pages_encrypted << ":" << num_pages_no_access << ")");
        for (auto& kv : BC.mapped_areas)
        {
            auto& ma = kv.second;
            if (!ma.encrypted)
            {
                auto full_addr = (uint64_t)BC.img + ma.base;
                auto full_addr_perms = (uint64_t)BC.img_all_perms + ma.base;

                if (!ma.no_access)
                {
                    DWORD old_protect;
                    IAT.VirtualProtect((void*)full_addr, PAGE_SIZE_4KB, PAGE_NOACCESS, &old_protect);

                    ma.no_access = true;
                    ma.no_access_time = time + TIME_BETWEEN_NO_ACCESS_ENCRYPT;
                }

                if (ma.no_access && time >= ma.no_access_time)
                {
                    obfuscated_byte_array<0x1337, 7> ba((char*)full_addr_perms, PAGE_SIZE_4KB);
                    ba.encrypt();

                    ma.encrypted = true;
                }
            }
        }

        IAT.LeaveCriticalSection(&BC.veh_section);
    }


    /// <summary>
    /// A thread while re-encrypts code periodically.
    /// </summary>
    void re_encrypt_code_thread()
    {
        while (TRUE)
        {
            disable_tf();

            Sleep(TIME_BETWEEN_RE_ENCRYPT_CHECKS);
            re_encrypt_code();
        }
    }

    /// <summary>
    /// Attempts to decrypt a section.
    /// </summary>
    static __forceinline bool decrypt_section(uint64_t rip, uint64_t exception_page)
    {
        auto iimg = (uint64_t)BC.img;
        auto iapp = (uint64_t)BC.app;
        auto sections = (packed_section*)(iapp + BC.app->off_to_sections.off);
        DWORD old_protect;

        TRACE("[exception]");
        TRACE(" -> rip: " << std::hex << rip
            << ", img: " << std::hex << iimg);

        for (auto i = 0; i < BC.app->off_to_sections.num_elements; i++)
        {
            auto& section = sections[i];
            auto characteristics = section.characteristics.get();
            TRACE(xorstr_("[section_search]"));
            TRACE(xorstr_(" -> off: ") << std::hex << section.rva.get() << xorstr_(", size: ") << std::hex << section.size_of_data.get() << xorstr_(", char: "));

            if (exception_page >= (iimg + section.rva) &&
                exception_page < ((iimg + section.rva + section.size_of_data)))
            {
                if (characteristics & (uint64_t)packed_section_characteristic::can_lazy_load)
                {
                    auto page_offset = PAGE_ADDR(exception_page) - (iimg + section.rva);

                    auto& ma = BC.mapped_areas[(uint64_t)section.rva + page_offset];
                    auto target_offset = BC.img + section.rva + page_offset;
                    auto target_offset_perms = BC.img_all_perms + section.rva + page_offset;

                    TRACE(xorstr_("[found]"));
                    TRACE(xorstr_(" -> rip: ") << std::hex << exception_page << xorstr_(", off: ") << std::hex << page_offset);

                    if (ma.encrypted)
                    {
                        obfuscated_byte_array<0x1337, 7> ba(target_offset_perms, PAGE_SIZE_4KB);
                        ba.decrypt();

                        ma.encrypted = false;
                    }

                    IAT.VirtualProtect(target_offset, PAGE_SIZE_4KB, PAGE_EXECUTE_READWRITE, &old_protect);
                    ma.no_access = false;

                    ma.decrypt_hits += 1;
                    return true;
                }
            }
        }

        return false;
    }

    LONG decrypt_code_except_handler(_EXCEPTION_POINTERS* exception_info)
    {
        BEGIN_VM(__FUNCTION__);

        disable_tf();
        LONG ret = EXCEPTION_CONTINUE_SEARCH;

        auto app_opts = BC.app->options.get();
        auto lazy_load_code = (app_opts & (uint8_t)packed_app_option::lazy_load_code) != 0;

        IAT.EnterCriticalSection(&BC.veh_section);

        if (exception_info->ExceptionRecord->ExceptionCode == EXCEPTION_ACCESS_VIOLATION ||
            exception_info->ExceptionRecord->ExceptionCode == EXCEPTION_GUARD_PAGE)
        {
            if (exception_info->ExceptionRecord->ExceptionInformation[0] == 0x0 ||
                exception_info->ExceptionRecord->ExceptionInformation[0] == 0x1)
            {
                if (emulate_encrypted_ins(exception_info->ContextRecord, (void*)exception_info->ContextRecord->Rip))
                {
                    ret = EXCEPTION_CONTINUE_EXECUTION;
                }
                else if (lazy_load_code && decrypt_section(resolve_mem_ref(exception_info->ContextRecord, (void*)exception_info->ContextRecord->Rip), exception_info->ExceptionRecord->ExceptionInformation[1]))
                {
                    ret = EXCEPTION_CONTINUE_EXECUTION;
                }
            }
            else if (exception_info->ExceptionRecord->ExceptionInformation[0] == 0x8)
            {
                if (lazy_load_code && decrypt_section(exception_info->ContextRecord->Rip, exception_info->ExceptionRecord->ExceptionInformation[1]))
                {
                    ret = EXCEPTION_CONTINUE_EXECUTION;
                }
            }
        }

        IAT.LeaveCriticalSection(&BC.veh_section);

        END_VM(__FUNCTION__);
        return ret;
    }
}

```

`BinConPackerStub/x86_emulator.cpp`:

```cpp
#include <Windows.h>
#include <fstream>
#include <vector>
#include <iostream>
#include <io.h>
#include <fcntl.h>
#include <map>

#include <bc_stub.h>
#include <bc_peb.h>
#include <bc_util.h>
#include <bc_thirdparty.h>
#include <bc_integrity.h>
#include <bc_windows.h>
#include <bc_log.h>

#include <xorstr.hpp>

#include <Zydis/Zydis.h>

namespace bc
{
    template<unsigned long long F, unsigned long long FL>
    struct encrypted_ptr
    {
        obfuscated_prim64<uint64_t, F, FL> real;
        obfuscated_prim64<size_t, F, FL> size;

        __forceinline encrypted_ptr(uint64_t real, size_t size)
        {
            this->real = real;
            this->size = size;
        }

        __forceinline encrypted_ptr() : encrypted_ptr(0, 0) { }

        __forceinline void set(uint64_t ptr, size_t size)
        {
            this->real = ptr;
            this->size = size;
        }

        __forceinline void set_ptr(uint64_t ptr)
        {
            this->real = ptr;
        }
    };

    static std::map<uint64_t, encrypted_ptr<0x1337, __LINE__>> encrypted_ptr_map;
    static uint64_t alloc_base = 0xff00000000000000ull;

    uint64_t allocate_encrypted(size_t size)
    {
        auto v = (uint64_t)malloc(size);
        
        auto enc_ptr = alloc_base; 
        encrypted_ptr_map[enc_ptr].set(v, size);

        alloc_base += size;
        return enc_ptr;
    }

    void free_encrypted(uint64_t addr)
    {
        encrypted_ptr_map.erase(addr);
        free((void*)encrypted_ptr_map[addr].real.get());
    }

    static uint64_t translate_encrypted(uint64_t fake_search)
    {
        for (auto& kv : encrypted_ptr_map)
        {
            auto fake_addr = kv.first;
            auto real_addr = kv.second.real.get();
            if (fake_search >= fake_addr && fake_search < (fake_addr + kv.second.size.get()))
            {
                return real_addr + (fake_search - fake_addr);
            }
        }
        return 0;
    }

    /// <summary>
    /// Retrieves the provided register from the context.
    /// </summary>
    static uint64_t retrieve_context(PCONTEXT context, ZydisRegister reg)
    {
        switch (reg)
        {
        case ZydisRegister::ZYDIS_REGISTER_RAX:
            return context->Rax;
        case ZydisRegister::ZYDIS_REGISTER_RCX:
            return context->Rcx;
        case ZydisRegister::ZYDIS_REGISTER_RDX:
            return context->Rdx;
        case ZydisRegister::ZYDIS_REGISTER_RBX:
            return context->Rbx;
        case ZydisRegister::ZYDIS_REGISTER_RDI:
            return context->Rdi;
        case ZydisRegister::ZYDIS_REGISTER_RSI:
            return context->Rsi;
        case ZydisRegister::ZYDIS_REGISTER_R8:
            return context->R8;
        case ZydisRegister::ZYDIS_REGISTER_R9:
            return context->R9;
        case ZydisRegister::ZYDIS_REGISTER_R10:
            return context->R10;
        case ZydisRegister::ZYDIS_REGISTER_R11:
            return context->R11;
        case ZydisRegister::ZYDIS_REGISTER_R12:
            return context->R12;
        case ZydisRegister::ZYDIS_REGISTER_R13:
            return context->R13;
        case ZydisRegister::ZYDIS_REGISTER_R14:
            return context->R14;
        case ZydisRegister::ZYDIS_REGISTER_R15:
            return context->R15;
        }
        return 0;
    }

    /// <summary>
    /// Stores the provided register into the context.
    /// </summary>
    static void update_context(PCONTEXT context, ZydisRegister reg, uint64_t val)
    {
        switch (reg)
        {
        case ZydisRegister::ZYDIS_REGISTER_RAX:
            context->Rax = val;
            break;
        case ZydisRegister::ZYDIS_REGISTER_RCX:
            context->Rcx = val;
            break;
        case ZydisRegister::ZYDIS_REGISTER_RDX:
            context->Rdx = val;
            break;
        case ZydisRegister::ZYDIS_REGISTER_RBX:
            context->Rbx = val;
            break;
        case ZydisRegister::ZYDIS_REGISTER_RDI:
            context->Rdi = val;
            break;
        case ZydisRegister::ZYDIS_REGISTER_RSI:
            context->Rsi = val;
            break;
        case ZydisRegister::ZYDIS_REGISTER_R8:
            context->R8 = val;
            break;
        case ZydisRegister::ZYDIS_REGISTER_R9:
            context->R9 = val;
            break;
        case ZydisRegister::ZYDIS_REGISTER_R10:
            context->R10 = val;
            break;
        case ZydisRegister::ZYDIS_REGISTER_R11:
            context->R11 = val;
            break;
        case ZydisRegister::ZYDIS_REGISTER_R12:
            context->R12 = val;
            break;
        case ZydisRegister::ZYDIS_REGISTER_R13:
            context->R13 = val;
            break;
        case ZydisRegister::ZYDIS_REGISTER_R14:
            context->R14 = val;
            break;
        case ZydisRegister::ZYDIS_REGISTER_R15:
            context->R15 = val;
            break;
        }
    }

    uint64_t resolve_mem_ref(PCONTEXT context, void* ins)
    {
        ZydisDecoder decoder;
        ZydisDecoderInit(&decoder, ZYDIS_MACHINE_MODE_LONG_64, ZydisAddressWidth::ZYDIS_ADDRESS_WIDTH_64);

        ZydisDecodedInstruction instruction;
        auto err = ZydisDecoderDecodeBuffer(&decoder, ins, 15, &instruction);
        auto found = 0ull;
        if (ZYAN_SUCCESS(err))
        {
            for (auto i = 0; i < instruction.operand_count; i++)
            {
                auto& op = instruction.operands[i];
                if (op.type == ZydisOperandType::ZYDIS_OPERAND_TYPE_MEMORY)
                {
                    auto base_r1 = retrieve_context(context, op.mem.base);
                    auto base_r2 = retrieve_context(context, op.mem.index) * op.mem.scale;
                    found = base_r1 + base_r2;
                }
            }
        }

        return found;
    }

    /// <summary>
    /// Attempts to emulate an encrypted memory instruction.
    /// </summary>
    bool emulate_encrypted_ins(PCONTEXT context, void* ins)
    {
        ZydisDecoder decoder;
        ZydisDecoderInit(&decoder, ZYDIS_MACHINE_MODE_LONG_64, ZydisAddressWidth::ZYDIS_ADDRESS_WIDTH_64);

        ZydisDecodedInstruction instruction;
        auto err = ZydisDecoderDecodeBuffer(&decoder, ins, 15, &instruction);
        auto any = false;
        if (ZYAN_SUCCESS(err))
        {
            for (auto i = 0; i < instruction.operand_count; i++)
            {
                auto& op = instruction.operands[i];
                if (op.type == ZydisOperandType::ZYDIS_OPERAND_TYPE_MEMORY)
                {
                    auto base_r1 = retrieve_context(context, op.mem.base);
                    auto base_r2 = retrieve_context(context, op.mem.index) * op.mem.scale;
                    if (base_r1)
                    {
                        if (auto translated = translate_encrypted(base_r1))
                        {
                            update_context(context, op.mem.base, translated);
                            any = true;
                        }
                    }

                    if (base_r2)
                    {
                        if (auto translated = translate_encrypted(base_r2))
                        {
                            update_context(context, op.mem.index, translated);
                            any = true;
                        }
                    }

                    if (!any && base_r1 && base_r2)
                    {
                        // not sure if this is even possible with a normal compiler
                        // but we check to make sure that the fully computed address is not 
                        // pointing into an obfuscated pointer
                        // WARNING: this could also corrupt registers, but in the case this actually happens
                        // we're going to crash either way
                        if (auto translated = translate_encrypted(base_r1 + base_r2))
                        {
                            update_context(context, op.mem.base, translated);
                            update_context(context, op.mem.index, 0);
                            any = true;
                        }
                    }
                }
            }
        }

        return any;
    }
}
```

`BinConVm/BinConVm.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{61e38aef-8d23-4017-872c-9c4ec7773a42}</ProjectGuid>
    <RootNamespace>BinConVm</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`BinConVm/BinConVm.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
</Project>
```

`BinConVm/BinConVm.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`BitConBuildTime/BitConBuildTime.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{d6303b99-3c59-4b39-89f2-823d1899ee5d}</ProjectGuid>
    <RootNamespace>BitConBuildTime</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>BinConBuildTime</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <FloatingPointModel>Strict</FloatingPointModel>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="bc_build_time.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`BitConBuildTime/BitConBuildTime.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="bc_build_time.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`BitConBuildTime/BitConBuildTime.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`BitConBuildTime/bc_build_time.cpp`:

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <algorithm>
#include <fstream>

#include <random>

#define PERMUTATIONS 30

enum class obfuscation_type : int8_t
{
    bswap = 0,
    xxor = 1,
    m_inverse = 2,
    max
};

struct obfuscation_pass
{
    obfuscation_type type;
    uint64_t args[5];

    obfuscation_pass(obfuscation_type type, uint64_t arg_a = 0, uint64_t arg_b = 0, uint64_t arg_c = 0, uint64_t arg_d = 0, uint64_t arg_e = 0)
    {
        this->type = type;
        args[0] = arg_a;
        args[1] = arg_b;
        args[2] = arg_c;
        args[3] = arg_d;
        args[4] = arg_e;
    }
};

struct struct_field
{
    const char* type;
    const char* name;

    struct_field(const char* type, const char* name)
    {
        this->type = type;
        this->name = name;
    }
    struct_field(const char* name)
    {
        this->type = "";
        this->name = name;
    }
};

uint64_t mul_inv(uint64_t n, uint64_t mod)
{
    uint64_t a = mod, b = a, c = 0, d = 0, e = 1, f, g;
    for (n *= a > 1; n > 1 && (n *= a > 0); e = g, c = (c & 3) | (c & 1) << 2) {
        g = d, d *= n / (f = a);
        a = n % a, n = f;
        c = (c & 6) | (c & 2) >> 1;
        f = c > 1 && c < 6;
        c = (c & 5) | (f || e > d ? (c & 4) >> 1 : ~c & 2);
        d = f ? d + e : e > d ? e - d : d - e;
    }

    return n ? c & 4 ? b - e : e : 0;
}

uint64_t build_bit_mask(int num_bits, int off)
{
    uint64_t mask = 0;
    for (int i = 0; i < num_bits; i++)
    {
        mask |= (1ull << (off + i));
    }
    return mask;
}

void generate_macro(std::ostringstream& o, std::string macro)
{
    o << "#define " << macro << "(O, X, F, FL) ";
}

void generate_header(std::ostringstream& o)
{
    o << "\tO = X; \\" << std::endl;
    o << "\t{  \\" << std::endl;
    o << "\t\tuint64_t __a; \\" << std::endl;
    o << "\t\tuint64_t __b; \\" << std::endl;
}

void generate_footer(std::ostringstream& o)
{
    o << "}" << std::endl;
}

void generate_bit_swap(std::ostringstream& o, int num_bits, int a, int b)
{
    o << "\t\t__a = (O & " << build_bit_mask(num_bits, a) << ") >> " << a << "ull; \\" << std::endl;
    o << "\t\t__b = (O & " << build_bit_mask(num_bits, b) << ") >> " << b << "ull; \\" << std::endl;
    o << "\t\tO &= ~" << build_bit_mask(num_bits, a) << "; \\" << std::endl;
    o << "\t\tO &= ~" << build_bit_mask(num_bits, b) << "; \\" << std::endl;
    o << "\t\tO |= __a << " << b << "ull; \\" << std::endl;
    o << "\t\tO |= __b << " << a << "ull; \\" << std::endl;
}

void generate_inverse(std::ostringstream& o, uint64_t v1, uint64_t v2, uint64_t v3, uint64_t v4)
{
    o << "\t\t*((uint16_t*)&O) *= " << v1 << "; \\" << std::endl;
    o << "\t\t*((uint16_t*)&O + 1) *= " << v2 << "; \\" << std::endl;
    o << "\t\t*((uint16_t*)&O + 2) *= " << v3 << "; \\" << std::endl;
    o << "\t\t*((uint16_t*)&O + 3) *= " << v4 << "; \\" << std::endl;
}

void generate_xor(std::ostringstream& o, uint64_t v)
{
    o << "\t\tO ^= " << v << "; \\" << std::endl;
}

void add_random(std::vector<obfuscation_pass>& passes)
{
    auto type = (obfuscation_type)(rand() % (int)obfuscation_type::max);
    switch (type)
    {
    case obfuscation_type::bswap:
    {
        auto bit_count = ((rand() % 28) + 1);
        auto off_a = (rand() % (32 - bit_count));
        auto off_b = ((rand() % (32 - bit_count)) + 32);
        passes.push_back(obfuscation_pass(type, bit_count, off_a, off_b));
        break;
    }
    case obfuscation_type::xxor:
    {
        auto v = ((uint64_t)rand() << 32) | (uint64_t)rand();
        passes.push_back(obfuscation_pass(type, v));
        break;
    }
    case obfuscation_type::m_inverse:
    {
        auto v1 = ((uint64_t)rand() % 65535);
        auto v2 = ((uint64_t)rand() % 65535);
        auto v3 = ((uint64_t)rand() % 65535);
        auto v4 = ((uint64_t)rand() % 65535);
        auto mod = 0xfff00000 + ((rand() % 10) * 0x10000);

        do
        {
            v1 = ((uint64_t)rand() % 65535);
        } while (!mul_inv(v1, mod));

        do
        {
            v2 = ((uint64_t)rand() % 65535);
        } while (!mul_inv(v2, mod));

        do
        {
            v3 = ((uint64_t)rand() % 65535);
        } while (!mul_inv(v3, mod));

        do
        {
            v4 = ((uint64_t)rand() % 65535);
        } while (!mul_inv(v4, mod));


        passes.push_back(obfuscation_pass(type, v2, mod, v1, v3, v4));
        break;
    }
    }
}

std::string generate_encrypt(std::vector<std::vector<obfuscation_pass>> passes, std::string name)
{
    std::ostringstream ss;
    generate_macro(ss, name);
    generate_header(ss);

    for (auto i = 0; i < passes.size(); i++)
    {
        if (i > 0)
        {
            ss << "\t}" << " \\" << std::endl;
        }

        ss << "\t";

        if (i > 0)
        {
            ss << "else ";
        }

        if (i != (passes.size() - 1))
        {
            ss << "if ((FL % " << (passes.size() - i - 1) << ") == 0)";
        }

        ss << " \\" << std::endl;
        ss << "\t{" << " \\" << std::endl;

        for (auto pass : passes[i])
        {
            switch (pass.type)
            {
            case obfuscation_type::bswap:
                generate_bit_swap(ss, (int)pass.args[0], (int)pass.args[1], (int)pass.args[2]);
                break;
            case obfuscation_type::xxor:
                generate_xor(ss, pass.args[0]);
                break;
            case obfuscation_type::m_inverse:
                generate_inverse(ss, pass.args[2], pass.args[0], pass.args[3], pass.args[4]);
                break;
            }
        }

        if (i == (passes.size() - 1))
        {
            ss << "\t}" << " \\" << std::endl;
        }
    }

    
    generate_footer(ss);
    return ss.str();
}

std::string generate_decrypt(std::vector<std::vector<obfuscation_pass>> passes, std::string name)
{
    std::ostringstream ss;
    
    generate_macro(ss, name);
    generate_header(ss);

    for (auto i = 0; i < passes.size(); i++)
    {
        if (i > 0)
        {
            ss << "\t}" << " \\" << std::endl;
        }

        ss << "\t";

        if (i > 0)
        {
            ss << "else ";
        }

        if (i != (passes.size() - 1))
        {
            ss << "if ((FL % " << (passes.size() - i - 1) << ") == 0)";
        }

        ss << " \\" << std::endl;
        ss << "\t{" << " \\" << std::endl;

        auto current_passes = passes[i];
        std::reverse(current_passes.begin(), current_passes.end());

        for (auto& pass : current_passes)
        {
            switch (pass.type)
            {
            case obfuscation_type::bswap:
                generate_bit_swap(ss, (int)pass.args[0], (int)pass.args[1], (int)pass.args[2]);
                break;
            case obfuscation_type::xxor:
                generate_xor(ss, pass.args[0]);
                break;
            case obfuscation_type::m_inverse:
                generate_inverse(ss, mul_inv(pass.args[2], pass.args[1]), mul_inv(pass.args[0], pass.args[1]), mul_inv(pass.args[3], pass.args[1]), mul_inv(pass.args[4], pass.args[1]));
                break;
            }
        }

        if (i == (passes.size() - 1))
        {
            ss << "\t}" << " \\" << std::endl;
        }
    }

    generate_footer(ss);
    return ss.str();
}

std::string generate_struct(const char* struct_name, std::vector<struct_field> fields)
{
    std::random_device rd;
    std::mt19937 rng(rd());
    std::shuffle(fields.begin(), fields.end(), rng);

    auto pad_index = 0;
    std::ostringstream ss;
    ss << "\tstruct " << struct_name << std::endl;
    ss << "\t{" << std::endl;
    for (auto& field : fields)
    {
        ss << "\t\tchar padding_" << pad_index++ << "[" << ((rand() % 100) + 1) << "];" << std::endl;
        ss << "\t\t" << field.type << " " << field.name << ";" << std::endl;
    }
    ss << "\t};" << std::endl << std::endl;
    return ss.str();
}

std::string generate_enum(const char* struct_name, std::vector<struct_field> fields)
{
    std::random_device rd;
    std::mt19937 rng(rd());
    std::shuffle(fields.begin(), fields.end(), rng);

    auto pad_index = 0;
    std::ostringstream ss;
    ss << "\tenum class " << struct_name << std::endl;
    ss << "\t{" << std::endl;
    for (auto& field : fields)
    {
        ss << "\t\t" << field.name << "," << std::endl;
    }
    ss << "\t};" << std::endl << std::endl;
    return ss.str();
}


int main()
{
    std::srand((unsigned int)std::time(0));
    srand((unsigned int)std::time(0));

    std::vector<std::vector<obfuscation_pass>> passes(PERMUTATIONS);
    for (int i = 0; i < PERMUTATIONS; i++)
    {
        add_random(passes[i]);
    }

    std::ofstream gen_of("bc_gen.h", std::ios::out);
    gen_of << "#pragma once" << std::endl;
    gen_of << "#include <cstdint>" << std::endl;
    gen_of << "extern uint32_t dyn_key_32;" << std::endl;
    gen_of << "extern uint64_t dyn_key_64;" << std::endl;
    gen_of << generate_encrypt(passes, "ENCRYPT") << std::endl;
    gen_of << generate_decrypt(passes, "DECRYPT") << std::endl;
    gen_of << generate_encrypt(passes, "ENCRYPTM") << std::endl;
    gen_of << generate_decrypt(passes, "DECRYPTM") << std::endl;
    gen_of.close();

    std::ofstream gens_of("bc_gen_struct.h", std::ios::out);
    gens_of << "#pragma once" << std::endl;
    gens_of << "#include \"bc_var.h\"" << std::endl << std::endl;
    gens_of << "namespace bc" << std::endl;
    gens_of << "{" << std::endl;
    gens_of << "#pragma pack(push, 1)" << std::endl;

    gens_of << generate_enum("packed_import_type", { { "name" }, { "ordinal"} });

    gens_of << generate_struct("packed_import", {
        {"obfuscated_prim64<packed_import_type, 0x1337, __LINE__>", "type"},
        {"obfuscated_string<256, 0x1337, __LINE__>", "mod"},
        {"obfuscated_string<256, 0x1337, __LINE__>", "name"},
        {"obfuscated_prim64<uint32_t, 0x1337, __LINE__>", "ordinal"},
        {"obfuscated_prim64<uint64_t, 0x1337, __LINE__>", "rva"}
        });

    gens_of << generate_struct("packed_section", {
        {"obfuscated_prim64<uint64_t, 0x1337, __LINE__>", "rva"},
        {"obfuscated_prim64<uint64_t, 0x1337, __LINE__>", "size_of_data"},
        {"obfuscated_prim64<uint64_t, 0x1337, __LINE__>", "off_to_data"},
        {"obfuscated_prim64<uint64_t, 0x1337, __LINE__>", "characteristics"}
        });

    gens_of << generate_struct("packed_resource", {
        {"obfuscated_prim64<uint16_t, 0x1337, __LINE__>", "id"},
        {"obfuscated_prim64<uint64_t, 0x1337, __LINE__>", "off_to_data"},
        {"obfuscated_prim64<uint64_t, 0x1337, __LINE__>", "size_of_data"},
        });

    gens_of << generate_struct("packed_reloc", {
        {"obfuscated_prim64<uint64_t, 0x1337, __LINE__>", "rva"}
        });

    gens_of << generate_struct("packed_tls_callback", {
        {"obfuscated_prim64<uint64_t, 0x1337, __LINE__>", "callback"}
        });

    gens_of << generate_struct("counted_element", {
        {"obfuscated_prim64<uint64_t, 0x1337, __LINE__>", "num_elements"},
        {"obfuscated_prim64<uint64_t, 0x1337, __LINE__>", "off"}
        });

    gens_of << generate_struct("packed_app", {
        {"obfuscated_prim64<uint8_t, 0x1337, __LINE__>", "options"},
        {"obfuscated_prim64<uint64_t, 0x1337, __LINE__>", "size_of_img"},
        {"obfuscated_prim64<uint64_t, 0x1337, __LINE__>", "size_of_app"},
        {"obfuscated_prim64<uint64_t, 0x1337, __LINE__>", "preferred_base"},
        {"obfuscated_prim64<uint64_t, 0x1337, __LINE__>", "ep"},
        {"counted_element", "off_to_relocs"},
        {"counted_element", "off_to_iat"},
        {"counted_element", "off_to_sections"},
        {"counted_element", "off_to_resources"},
        {"counted_element", "off_to_headers"}
        });

    gens_of << "}" << std::endl;
    gens_of << "#pragma pack(pop)" << std::endl;
    gens_of.close();

}

```

`BitConBuildTime/bc_gen.h`:

```h
#pragma once

#define ENCRYPT(O, X) O = X; \
{  \
	uint64_t __a; \
	uint64_t __b; \
	__a = (O & 67108856) >> 3ull; \
	__b = (O & 4611685468671574016) >> 39ull; \
	O &= ~67108856; \
	O &= ~4611685468671574016; \
	O |= __a << 39ull; \
	O |= __b << 3ull; \
	O ^= 78773995178593; \
	*((uint16_t*)&O) *= 8339; \
	*((uint16_t*)&O + 1) *= 12623; \
	O ^= 97972498997463; \
}

#define DECRYPT(O, X) O = X; \
{  \
	uint64_t __a; \
	uint64_t __b; \
	O ^= 97972498997463; \
	*((uint16_t*)&O) *= 4153408923; \
	*((uint16_t*)&O + 1) *= 2995209647; \
	O ^= 78773995178593; \
	__a = (O & 67108856) >> 3ull; \
	__b = (O & 4611685468671574016) >> 39ull; \
	O &= ~67108856; \
	O &= ~4611685468671574016; \
	O |= __a << 39ull; \
	O |= __b << 3ull; \
}


```

`BitConTests/BitConTests.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{D264D73C-4923-40F8-A356-289E4D1FBE6F}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>BitConTests</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectSubType>NativeUnitTestProject</ProjectSubType>
    <ProjectName>BinConTests</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>false</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>false</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>false</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>false</UseOfMfc>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir)inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(SolutionDir)inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <AdditionalIncludeDirectories>$(VCInstallDir)UnitTest\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <UseFullPaths>true</UseFullPaths>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <AdditionalLibraryDirectories>$(VCInstallDir)UnitTest\lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <AdditionalIncludeDirectories>$(VCInstallDir)UnitTest\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <UseFullPaths>true</UseFullPaths>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <AdditionalLibraryDirectories>$(VCInstallDir)UnitTest\lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <AdditionalIncludeDirectories>$(VCInstallDir)UnitTest\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <UseFullPaths>true</UseFullPaths>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalLibraryDirectories>$(VCInstallDir)UnitTest\lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <AdditionalIncludeDirectories>$(VCInstallDir)UnitTest\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <UseFullPaths>true</UseFullPaths>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalLibraryDirectories>$(VCInstallDir)UnitTest\lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="bc_tests.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\BinCon\BinCon.vcxproj">
      <Project>{f76672d3-353d-4ef3-8933-1575d4f37e0a}</Project>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`BitConTests/BitConTests.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="bc_tests.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`BitConTests/BitConTests.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`BitConTests/bc_tests.cpp`:

```cpp
#include "CppUnitTest.h"
using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace bc
{

}

```

`README.md`:

```md
# BinCon
A library to assist with memory &amp; code protection. This is not meant to be a drop in replacement for anything, but as an example for how to provide an 
increased layer of protection on top of virtualization or code mutation.

The example project provides an example of a simple console application hardened against memory scans, memory modifications, debuggers, and other things.

# Features

## Obfuscated Variables
Support for transparent obfuscation of native data types, including pointers, and integers.

## VEH Pointer Obfuscation
Support for transparent obfuscation of pointers, where the decryption is handled by a custom VEH routine that will
emulate the memory read with the real decrypted address.

## Build Time Randomization
The expression used to obfuscate variables will be randomized before a build is started. The file format of the packer is completely randomized.

```C++
struct packed_import
{
	char padding_0[2];
	obfuscated_prim64<uint64_t> rva;
	char padding_1[99];
	obfuscated_prim64<packed_import_type> type;
	char padding_2[35];
	obfuscated_prim64<uint32_t> ordinal;
	char padding_3[77];
	obfuscated_string<256> name;
	char padding_4[65];
	obfuscated_string<256> mod;
};
```

All projects share the same generated files, which can be leveraged for communication from app <-> packer. The packer has a provided communication channel with a hook on `GetProcAddress`. This will
allow you to talk to the packer stub, and request integrity checks, memory re-encryption, pointer encryption, etc.

```C++
(chal_entry*)GetProcAddress((HMODULE)0xBC, xorstr_("pack_interface"))
```

The generated expressions use a mix of XOR, byte swap, and multiplicative inverse obfuscation generated in randomized order.

```C++
#define ENCRYPT(O, X) O = X; \
{  \
	uint64_t __a; \
	uint64_t __b; \
	O ^= 136292197216505; \
	O ^= 130747394438946; \
	__a = (O & 33538048) >> 14ull; \
	__b = (O & 72022409665839104) >> 45ull; \
	O &= ~33538048; \
	O &= ~72022409665839104; \
	O |= __a << 45ull; \
	O |= __b << 14ull; \
	__a = (O & 268435454) >> 1ull; \
	__b = (O & 2305842992033824768) >> 34ull; \
	O &= ~268435454; \
	O &= ~2305842992033824768; \
	O |= __a << 34ull; \
	O |= __b << 1ull; \
}

#define DECRYPT(O, X) O = X; \
{  \
	uint64_t __a; \
	uint64_t __b; \
	__a = (O & 268435454) >> 1ull; \
	__b = (O & 2305842992033824768) >> 34ull; \
	O &= ~268435454; \
	O &= ~2305842992033824768; \
	O |= __a << 34ull; \
	O |= __b << 1ull; \
	__a = (O & 33538048) >> 14ull; \
	__b = (O & 72022409665839104) >> 45ull; \
	O &= ~33538048; \
	O &= ~72022409665839104; \
	O |= __a << 45ull; \
	O |= __b << 14ull; \
	O ^= 130747394438946; \
	O ^= 136292197216505; \
}
```

## Encrypted Sections
Keep your code sections encrypted and unavailable in memory until they're accessed, with periodic re-encryption.

## Memory Allocator
A very poorly made memory allocator that supports randomizing the allocated blocks. Will be redone soon TM.

```

`inc/bc_common.h`:

```h
#pragma once

namespace bc
{
	#define NOINLINE __declspec(noinline)
	#define INLINE __forceinline

	enum class bc_error
	{
		success,
		not_enough_memory,
		bad_hook_checksum,
		debugger_attached,
		bad_module_checksum,
		reencrypt_thread_not_running,
	};

	class bc_lock
	{
	public:
		virtual void enter() = 0;
		virtual void exit() = 0;
	};
}
```

`inc/bc_dyn_struct.h`:

```h
#pragma once
#include "bc_var.h"
#include "bc_log.h"

#include <map>

namespace bc
{
	typedef uint64_t dynamic_struct_key;

	struct dynamic_struct_pre_field
	{
		dynamic_struct_key key;
		size_t sz;
	};

	template<uint64_t ALIGNMENT>
	class dynamic_struct
	{
	private:
		void* data = NULL;
		size_t cur_sz = 0;

		obfuscated_prim64<dynamic_struct_key, 0x1337, __LINE__> alloc_key = 1;
		std::map<obfuscated_prim64<dynamic_struct_key, 0x1337, __LINE__>, obfuscated_prim64<uint64_t, 0x1337, __LINE__>> field_offsets;

	public:
		__forceinline dynamic_struct_key add_random_padding()
		{
			auto sz = rand() % 100;
			if (sz % ALIGNMENT)
			{
				sz += (ALIGNMENT - (sz % ALIGNMENT));
			}

			LOG("Sz: " << sz);
			auto key = add_field(sz);
			auto ref = ref_field<char>(key);
			for (auto i = 0; i < sz; i++)
			{
				ref[i] = (char)rand();
			}
			return key;
		}

		template<typename T>
		__forceinline dynamic_struct_key add_field_typed()
		{
			auto num_padding = (rand() % 10) + 3;
			for (auto i = 0; i < num_padding; i++)
			{
				add_random_padding();
			}

			auto sz = sizeof(T);

			data = realloc(data, cur_sz + sz);
			field_offsets[alloc_key.get()] = cur_sz;

			auto ti = (T*)((char*)data + cur_sz);
			*ti = T();

			if (sz % ALIGNMENT)
			{
				sz += (ALIGNMENT - (sz % ALIGNMENT));
			}

			cur_sz += sz;
			alloc_key += 1;
			return alloc_key - 1;
		}

		__forceinline dynamic_struct_key add_field(size_t sz)
		{
			if (!sz)
			{
				return 0;
			}

			data = realloc(data, cur_sz + sz);
			field_offsets[alloc_key.get()] = cur_sz;

			if (sz % ALIGNMENT)
			{
				sz += (ALIGNMENT - (sz % ALIGNMENT));
			}

			cur_sz += sz;
			alloc_key += 1;
			return alloc_key - 1;
		}

	public:
		template<typename T>
		__forceinline T* ref_field(dynamic_struct_key key)
		{
			if (!key)
			{
				return NULL;
			}

			return (T*)((char*)data + field_offsets[key]);
		}

		template<typename T>
		__forceinline T get_field(dynamic_struct_key key)
		{
			if (!key)
			{
				return T();
			}


			return *((T*)((char*)data + field_offsets[key]));
		}
	};
}
```

`inc/bc_gen.h`:

```h
#pragma once
#include <cstdint>
extern uint32_t dyn_key_32;
extern uint64_t dyn_key_64;
#define ENCRYPT(O, X, F, FL) 	O = X; \
	{  \
		uint64_t __a; \
		uint64_t __b; \
	if ((FL % 29) == 0) \
	{ \
		__a = (O & 252) >> 2ull; \
		__b = (O & 277076930199552) >> 42ull; \
		O &= ~252; \
		O &= ~277076930199552; \
		O |= __a << 42ull; \
		O |= __b << 2ull; \
	} \
	else if ((FL % 28) == 0) \
	{ \
		__a = (O & 67108863) >> 0ull; \
		__b = (O & 2305842974853955584) >> 35ull; \
		O &= ~67108863; \
		O &= ~2305842974853955584; \
		O |= __a << 35ull; \
		O |= __b << 0ull; \
	} \
	else if ((FL % 27) == 0) \
	{ \
		*((uint16_t*)&O) *= 17241; \
		*((uint16_t*)&O + 1) *= 11559; \
		*((uint16_t*)&O + 2) *= 10317; \
		*((uint16_t*)&O + 3) *= 5707; \
	} \
	else if ((FL % 26) == 0) \
	{ \
		O ^= 59214714119270; \
	} \
	else if ((FL % 25) == 0) \
	{ \
		O ^= 81067507740925; \
	} \
	else if ((FL % 24) == 0) \
	{ \
		*((uint16_t*)&O) *= 14907; \
		*((uint16_t*)&O + 1) *= 11599; \
		*((uint16_t*)&O + 2) *= 6603; \
		*((uint16_t*)&O + 3) *= 26399; \
	} \
	else if ((FL % 23) == 0) \
	{ \
		O ^= 29115583330276; \
	} \
	else if ((FL % 22) == 0) \
	{ \
		O ^= 14577119022777; \
	} \
	else if ((FL % 21) == 0) \
	{ \
		__a = (O & 8257536) >> 17ull; \
		__b = (O & 8658654068736) >> 37ull; \
		O &= ~8257536; \
		O &= ~8658654068736; \
		O |= __a << 37ull; \
		O |= __b << 17ull; \
	} \
	else if ((FL % 20) == 0) \
	{ \
		__a = (O & 4095) >> 0ull; \
		__b = (O & 9221120237041090560) >> 51ull; \
		O &= ~4095; \
		O &= ~9221120237041090560; \
		O |= __a << 51ull; \
		O |= __b << 0ull; \
	} \
	else if ((FL % 19) == 0) \
	{ \
		*((uint16_t*)&O) *= 17741; \
		*((uint16_t*)&O + 1) *= 27263; \
		*((uint16_t*)&O + 2) *= 3575; \
		*((uint16_t*)&O + 3) *= 17999; \
	} \
	else if ((FL % 18) == 0) \
	{ \
		__a = (O & 268435452) >> 2ull; \
		__b = (O & 1152921487426977792) >> 34ull; \
		O &= ~268435452; \
		O &= ~1152921487426977792; \
		O |= __a << 34ull; \
		O |= __b << 2ull; \
	} \
	else if ((FL % 17) == 0) \
	{ \
		__a = (O & 2046) >> 1ull; \
		__b = (O & 17996806323437568) >> 44ull; \
		O &= ~2046; \
		O &= ~17996806323437568; \
		O |= __a << 44ull; \
		O |= __b << 1ull; \
	} \
	else if ((FL % 16) == 0) \
	{ \
		__a = (O & 4194176) >> 7ull; \
		__b = (O & 281466386776064) >> 33ull; \
		O &= ~4194176; \
		O &= ~281466386776064; \
		O |= __a << 33ull; \
		O |= __b << 7ull; \
	} \
	else if ((FL % 15) == 0) \
	{ \
		O ^= 118657061504053; \
	} \
	else if ((FL % 14) == 0) \
	{ \
		__a = (O & 67108848) >> 4ull; \
		__b = (O & 1152921229728940032) >> 38ull; \
		O &= ~67108848; \
		O &= ~1152921229728940032; \
		O |= __a << 38ull; \
		O |= __b << 4ull; \
	} \
	else if ((FL % 13) == 0) \
	{ \
		O ^= 92698279169073; \
	} \
	else if ((FL % 12) == 0) \
	{ \
		*((uint16_t*)&O) *= 26991; \
		*((uint16_t*)&O + 1) *= 31623; \
		*((uint16_t*)&O + 2) *= 5619; \
		*((uint16_t*)&O + 3) *= 31429; \
	} \
	else if ((FL % 11) == 0) \
	{ \
		O ^= 63123134378578; \
	} \
	else if ((FL % 10) == 0) \
	{ \
		*((uint16_t*)&O) *= 21701; \
		*((uint16_t*)&O + 1) *= 3407; \
		*((uint16_t*)&O + 2) *= 20653; \
		*((uint16_t*)&O + 3) *= 7571; \
	} \
	else if ((FL % 9) == 0) \
	{ \
		*((uint16_t*)&O) *= 2041; \
		*((uint16_t*)&O + 1) *= 6513; \
		*((uint16_t*)&O + 2) *= 8427; \
		*((uint16_t*)&O + 3) *= 29707; \
	} \
	else if ((FL % 8) == 0) \
	{ \
		*((uint16_t*)&O) *= 109; \
		*((uint16_t*)&O + 1) *= 17281; \
		*((uint16_t*)&O + 2) *= 4199; \
		*((uint16_t*)&O + 3) *= 24487; \
	} \
	else if ((FL % 7) == 0) \
	{ \
		*((uint16_t*)&O) *= 21467; \
		*((uint16_t*)&O + 1) *= 30401; \
		*((uint16_t*)&O + 2) *= 23823; \
		*((uint16_t*)&O + 3) *= 18785; \
	} \
	else if ((FL % 6) == 0) \
	{ \
		*((uint16_t*)&O) *= 21661; \
		*((uint16_t*)&O + 1) *= 7687; \
		*((uint16_t*)&O + 2) *= 27731; \
		*((uint16_t*)&O + 3) *= 1793; \
	} \
	else if ((FL % 5) == 0) \
	{ \
		O ^= 28540057695932; \
	} \
	else if ((FL % 4) == 0) \
	{ \
		*((uint16_t*)&O) *= 11041; \
		*((uint16_t*)&O + 1) *= 7183; \
		*((uint16_t*)&O + 2) *= 10627; \
		*((uint16_t*)&O + 3) *= 26771; \
	} \
	else if ((FL % 3) == 0) \
	{ \
		O ^= 100141457498361; \
	} \
	else if ((FL % 2) == 0) \
	{ \
		O ^= 129278515640240; \
	} \
	else if ((FL % 1) == 0) \
	{ \
		O ^= 110612587743925; \
	} \
	else  \
	{ \
		*((uint16_t*)&O) *= 9871; \
		*((uint16_t*)&O + 1) *= 2339; \
		*((uint16_t*)&O + 2) *= 11117; \
		*((uint16_t*)&O + 3) *= 28079; \
	} \
}

#define DECRYPT(O, X, F, FL) 	O = X; \
	{  \
		uint64_t __a; \
		uint64_t __b; \
	if ((FL % 29) == 0) \
	{ \
		__a = (O & 252) >> 2ull; \
		__b = (O & 277076930199552) >> 42ull; \
		O &= ~252; \
		O &= ~277076930199552; \
		O |= __a << 42ull; \
		O |= __b << 2ull; \
	} \
	else if ((FL % 28) == 0) \
	{ \
		__a = (O & 67108863) >> 0ull; \
		__b = (O & 2305842974853955584) >> 35ull; \
		O &= ~67108863; \
		O &= ~2305842974853955584; \
		O |= __a << 35ull; \
		O |= __b << 0ull; \
	} \
	else if ((FL % 27) == 0) \
	{ \
		*((uint16_t*)&O) *= 1137562857; \
		*((uint16_t*)&O + 1) *= 3941495447; \
		*((uint16_t*)&O + 2) *= 3628028037; \
		*((uint16_t*)&O + 3) *= 3937764195; \
	} \
	else if ((FL % 26) == 0) \
	{ \
		O ^= 59214714119270; \
	} \
	else if ((FL % 25) == 0) \
	{ \
		O ^= 81067507740925; \
	} \
	else if ((FL % 24) == 0) \
	{ \
		*((uint16_t*)&O) *= 2888601331; \
		*((uint16_t*)&O + 1) *= 3051538863; \
		*((uint16_t*)&O + 2) *= 2367374307; \
		*((uint16_t*)&O + 3) *= 1387287775; \
	} \
	else if ((FL % 23) == 0) \
	{ \
		O ^= 29115583330276; \
	} \
	else if ((FL % 22) == 0) \
	{ \
		O ^= 14577119022777; \
	} \
	else if ((FL % 21) == 0) \
	{ \
		__a = (O & 8257536) >> 17ull; \
		__b = (O & 8658654068736) >> 37ull; \
		O &= ~8257536; \
		O &= ~8658654068736; \
		O |= __a << 37ull; \
		O |= __b << 17ull; \
	} \
	else if ((FL % 20) == 0) \
	{ \
		__a = (O & 4095) >> 0ull; \
		__b = (O & 9221120237041090560) >> 51ull; \
		O &= ~4095; \
		O &= ~9221120237041090560; \
		O |= __a << 51ull; \
		O |= __b << 0ull; \
	} \
	else if ((FL % 19) == 0) \
	{ \
		*((uint16_t*)&O) *= 4075977605; \
		*((uint16_t*)&O + 1) *= 259741055; \
		*((uint16_t*)&O + 2) *= 521323463; \
		*((uint16_t*)&O + 3) *= 2327646383; \
	} \
	else if ((FL % 18) == 0) \
	{ \
		__a = (O & 268435452) >> 2ull; \
		__b = (O & 1152921487426977792) >> 34ull; \
		O &= ~268435452; \
		O &= ~1152921487426977792; \
		O |= __a << 34ull; \
		O |= __b << 2ull; \
	} \
	else if ((FL % 17) == 0) \
	{ \
		__a = (O & 2046) >> 1ull; \
		__b = (O & 17996806323437568) >> 44ull; \
		O &= ~2046; \
		O &= ~17996806323437568; \
		O |= __a << 44ull; \
		O |= __b << 1ull; \
	} \
	else if ((FL % 16) == 0) \
	{ \
		__a = (O & 4194176) >> 7ull; \
		__b = (O & 281466386776064) >> 33ull; \
		O &= ~4194176; \
		O &= ~281466386776064; \
		O |= __a << 33ull; \
		O |= __b << 7ull; \
	} \
	else if ((FL % 15) == 0) \
	{ \
		O ^= 118657061504053; \
	} \
	else if ((FL % 14) == 0) \
	{ \
		__a = (O & 67108848) >> 4ull; \
		__b = (O & 1152921229728940032) >> 38ull; \
		O &= ~67108848; \
		O &= ~1152921229728940032; \
		O |= __a << 38ull; \
		O |= __b << 4ull; \
	} \
	else if ((FL % 13) == 0) \
	{ \
		O ^= 92698279169073; \
	} \
	else if ((FL % 12) == 0) \
	{ \
		*((uint16_t*)&O) *= 2201556367; \
		*((uint16_t*)&O + 1) *= 501242423; \
		*((uint16_t*)&O + 2) *= 2087226171; \
		*((uint16_t*)&O + 3) *= 1162802189; \
	} \
	else if ((FL % 11) == 0) \
	{ \
		O ^= 63123134378578; \
	} \
	else if ((FL % 10) == 0) \
	{ \
		*((uint16_t*)&O) *= 494668301; \
		*((uint16_t*)&O + 1) *= 801565103; \
		*((uint16_t*)&O + 2) *= 1791333157; \
		*((uint16_t*)&O + 3) *= 846760091; \
	} \
	else if ((FL % 9) == 0) \
	{ \
		*((uint16_t*)&O) *= 3955624521; \
		*((uint16_t*)&O + 1) *= 3348203409; \
		*((uint16_t*)&O + 2) *= 94275523; \
		*((uint16_t*)&O + 3) *= 967669667; \
	} \
	else if ((FL % 8) == 0) \
	{ \
		*((uint16_t*)&O) *= 3545762149; \
		*((uint16_t*)&O + 1) *= 2647260289; \
		*((uint16_t*)&O + 2) *= 1201670999; \
		*((uint16_t*)&O + 3) *= 1530288151; \
	} \
	else if ((FL % 7) == 0) \
	{ \
		*((uint16_t*)&O) *= 1145008211; \
		*((uint16_t*)&O + 1) *= 3163887937; \
		*((uint16_t*)&O + 2) *= 3273585135; \
		*((uint16_t*)&O + 3) *= 2630228641; \
	} \
	else if ((FL % 6) == 0) \
	{ \
		*((uint16_t*)&O) *= 2633486773; \
		*((uint16_t*)&O + 1) *= 2831347639; \
		*((uint16_t*)&O + 2) *= 94156763; \
		*((uint16_t*)&O + 3) *= 481425665; \
	} \
	else if ((FL % 5) == 0) \
	{ \
		O ^= 28540057695932; \
	} \
	else if ((FL % 4) == 0) \
	{ \
		*((uint16_t*)&O) *= 1093605601; \
		*((uint16_t*)&O + 1) *= 2101826287; \
		*((uint16_t*)&O + 2) *= 3964611883; \
		*((uint16_t*)&O + 3) *= 2671048091; \
	} \
	else if ((FL % 3) == 0) \
	{ \
		O ^= 100141457498361; \
	} \
	else if ((FL % 2) == 0) \
	{ \
		O ^= 129278515640240; \
	} \
	else if ((FL % 1) == 0) \
	{ \
		O ^= 110612587743925; \
	} \
	else  \
	{ \
		*((uint16_t*)&O) *= 3931125871; \
		*((uint16_t*)&O + 1) *= 4053429899; \
		*((uint16_t*)&O + 2) *= 3409024613; \
		*((uint16_t*)&O + 3) *= 3133999439; \
	} \
}

#define ENCRYPTM(O, X, F, FL) 	O = X; \
	{  \
		uint64_t __a; \
		uint64_t __b; \
	if ((FL % 29) == 0) \
	{ \
		__a = (O & 252) >> 2ull; \
		__b = (O & 277076930199552) >> 42ull; \
		O &= ~252; \
		O &= ~277076930199552; \
		O |= __a << 42ull; \
		O |= __b << 2ull; \
	} \
	else if ((FL % 28) == 0) \
	{ \
		__a = (O & 67108863) >> 0ull; \
		__b = (O & 2305842974853955584) >> 35ull; \
		O &= ~67108863; \
		O &= ~2305842974853955584; \
		O |= __a << 35ull; \
		O |= __b << 0ull; \
	} \
	else if ((FL % 27) == 0) \
	{ \
		*((uint16_t*)&O) *= 17241; \
		*((uint16_t*)&O + 1) *= 11559; \
		*((uint16_t*)&O + 2) *= 10317; \
		*((uint16_t*)&O + 3) *= 5707; \
	} \
	else if ((FL % 26) == 0) \
	{ \
		O ^= 59214714119270; \
	} \
	else if ((FL % 25) == 0) \
	{ \
		O ^= 81067507740925; \
	} \
	else if ((FL % 24) == 0) \
	{ \
		*((uint16_t*)&O) *= 14907; \
		*((uint16_t*)&O + 1) *= 11599; \
		*((uint16_t*)&O + 2) *= 6603; \
		*((uint16_t*)&O + 3) *= 26399; \
	} \
	else if ((FL % 23) == 0) \
	{ \
		O ^= 29115583330276; \
	} \
	else if ((FL % 22) == 0) \
	{ \
		O ^= 14577119022777; \
	} \
	else if ((FL % 21) == 0) \
	{ \
		__a = (O & 8257536) >> 17ull; \
		__b = (O & 8658654068736) >> 37ull; \
		O &= ~8257536; \
		O &= ~8658654068736; \
		O |= __a << 37ull; \
		O |= __b << 17ull; \
	} \
	else if ((FL % 20) == 0) \
	{ \
		__a = (O & 4095) >> 0ull; \
		__b = (O & 9221120237041090560) >> 51ull; \
		O &= ~4095; \
		O &= ~9221120237041090560; \
		O |= __a << 51ull; \
		O |= __b << 0ull; \
	} \
	else if ((FL % 19) == 0) \
	{ \
		*((uint16_t*)&O) *= 17741; \
		*((uint16_t*)&O + 1) *= 27263; \
		*((uint16_t*)&O + 2) *= 3575; \
		*((uint16_t*)&O + 3) *= 17999; \
	} \
	else if ((FL % 18) == 0) \
	{ \
		__a = (O & 268435452) >> 2ull; \
		__b = (O & 1152921487426977792) >> 34ull; \
		O &= ~268435452; \
		O &= ~1152921487426977792; \
		O |= __a << 34ull; \
		O |= __b << 2ull; \
	} \
	else if ((FL % 17) == 0) \
	{ \
		__a = (O & 2046) >> 1ull; \
		__b = (O & 17996806323437568) >> 44ull; \
		O &= ~2046; \
		O &= ~17996806323437568; \
		O |= __a << 44ull; \
		O |= __b << 1ull; \
	} \
	else if ((FL % 16) == 0) \
	{ \
		__a = (O & 4194176) >> 7ull; \
		__b = (O & 281466386776064) >> 33ull; \
		O &= ~4194176; \
		O &= ~281466386776064; \
		O |= __a << 33ull; \
		O |= __b << 7ull; \
	} \
	else if ((FL % 15) == 0) \
	{ \
		O ^= 118657061504053; \
	} \
	else if ((FL % 14) == 0) \
	{ \
		__a = (O & 67108848) >> 4ull; \
		__b = (O & 1152921229728940032) >> 38ull; \
		O &= ~67108848; \
		O &= ~1152921229728940032; \
		O |= __a << 38ull; \
		O |= __b << 4ull; \
	} \
	else if ((FL % 13) == 0) \
	{ \
		O ^= 92698279169073; \
	} \
	else if ((FL % 12) == 0) \
	{ \
		*((uint16_t*)&O) *= 26991; \
		*((uint16_t*)&O + 1) *= 31623; \
		*((uint16_t*)&O + 2) *= 5619; \
		*((uint16_t*)&O + 3) *= 31429; \
	} \
	else if ((FL % 11) == 0) \
	{ \
		O ^= 63123134378578; \
	} \
	else if ((FL % 10) == 0) \
	{ \
		*((uint16_t*)&O) *= 21701; \
		*((uint16_t*)&O + 1) *= 3407; \
		*((uint16_t*)&O + 2) *= 20653; \
		*((uint16_t*)&O + 3) *= 7571; \
	} \
	else if ((FL % 9) == 0) \
	{ \
		*((uint16_t*)&O) *= 2041; \
		*((uint16_t*)&O + 1) *= 6513; \
		*((uint16_t*)&O + 2) *= 8427; \
		*((uint16_t*)&O + 3) *= 29707; \
	} \
	else if ((FL % 8) == 0) \
	{ \
		*((uint16_t*)&O) *= 109; \
		*((uint16_t*)&O + 1) *= 17281; \
		*((uint16_t*)&O + 2) *= 4199; \
		*((uint16_t*)&O + 3) *= 24487; \
	} \
	else if ((FL % 7) == 0) \
	{ \
		*((uint16_t*)&O) *= 21467; \
		*((uint16_t*)&O + 1) *= 30401; \
		*((uint16_t*)&O + 2) *= 23823; \
		*((uint16_t*)&O + 3) *= 18785; \
	} \
	else if ((FL % 6) == 0) \
	{ \
		*((uint16_t*)&O) *= 21661; \
		*((uint16_t*)&O + 1) *= 7687; \
		*((uint16_t*)&O + 2) *= 27731; \
		*((uint16_t*)&O + 3) *= 1793; \
	} \
	else if ((FL % 5) == 0) \
	{ \
		O ^= 28540057695932; \
	} \
	else if ((FL % 4) == 0) \
	{ \
		*((uint16_t*)&O) *= 11041; \
		*((uint16_t*)&O + 1) *= 7183; \
		*((uint16_t*)&O + 2) *= 10627; \
		*((uint16_t*)&O + 3) *= 26771; \
	} \
	else if ((FL % 3) == 0) \
	{ \
		O ^= 100141457498361; \
	} \
	else if ((FL % 2) == 0) \
	{ \
		O ^= 129278515640240; \
	} \
	else if ((FL % 1) == 0) \
	{ \
		O ^= 110612587743925; \
	} \
	else  \
	{ \
		*((uint16_t*)&O) *= 9871; \
		*((uint16_t*)&O + 1) *= 2339; \
		*((uint16_t*)&O + 2) *= 11117; \
		*((uint16_t*)&O + 3) *= 28079; \
	} \
}

#define DECRYPTM(O, X, F, FL) 	O = X; \
	{  \
		uint64_t __a; \
		uint64_t __b; \
	if ((FL % 29) == 0) \
	{ \
		__a = (O & 252) >> 2ull; \
		__b = (O & 277076930199552) >> 42ull; \
		O &= ~252; \
		O &= ~277076930199552; \
		O |= __a << 42ull; \
		O |= __b << 2ull; \
	} \
	else if ((FL % 28) == 0) \
	{ \
		__a = (O & 67108863) >> 0ull; \
		__b = (O & 2305842974853955584) >> 35ull; \
		O &= ~67108863; \
		O &= ~2305842974853955584; \
		O |= __a << 35ull; \
		O |= __b << 0ull; \
	} \
	else if ((FL % 27) == 0) \
	{ \
		*((uint16_t*)&O) *= 1137562857; \
		*((uint16_t*)&O + 1) *= 3941495447; \
		*((uint16_t*)&O + 2) *= 3628028037; \
		*((uint16_t*)&O + 3) *= 3937764195; \
	} \
	else if ((FL % 26) == 0) \
	{ \
		O ^= 59214714119270; \
	} \
	else if ((FL % 25) == 0) \
	{ \
		O ^= 81067507740925; \
	} \
	else if ((FL % 24) == 0) \
	{ \
		*((uint16_t*)&O) *= 2888601331; \
		*((uint16_t*)&O + 1) *= 3051538863; \
		*((uint16_t*)&O + 2) *= 2367374307; \
		*((uint16_t*)&O + 3) *= 1387287775; \
	} \
	else if ((FL % 23) == 0) \
	{ \
		O ^= 29115583330276; \
	} \
	else if ((FL % 22) == 0) \
	{ \
		O ^= 14577119022777; \
	} \
	else if ((FL % 21) == 0) \
	{ \
		__a = (O & 8257536) >> 17ull; \
		__b = (O & 8658654068736) >> 37ull; \
		O &= ~8257536; \
		O &= ~8658654068736; \
		O |= __a << 37ull; \
		O |= __b << 17ull; \
	} \
	else if ((FL % 20) == 0) \
	{ \
		__a = (O & 4095) >> 0ull; \
		__b = (O & 9221120237041090560) >> 51ull; \
		O &= ~4095; \
		O &= ~9221120237041090560; \
		O |= __a << 51ull; \
		O |= __b << 0ull; \
	} \
	else if ((FL % 19) == 0) \
	{ \
		*((uint16_t*)&O) *= 4075977605; \
		*((uint16_t*)&O + 1) *= 259741055; \
		*((uint16_t*)&O + 2) *= 521323463; \
		*((uint16_t*)&O + 3) *= 2327646383; \
	} \
	else if ((FL % 18) == 0) \
	{ \
		__a = (O & 268435452) >> 2ull; \
		__b = (O & 1152921487426977792) >> 34ull; \
		O &= ~268435452; \
		O &= ~1152921487426977792; \
		O |= __a << 34ull; \
		O |= __b << 2ull; \
	} \
	else if ((FL % 17) == 0) \
	{ \
		__a = (O & 2046) >> 1ull; \
		__b = (O & 17996806323437568) >> 44ull; \
		O &= ~2046; \
		O &= ~17996806323437568; \
		O |= __a << 44ull; \
		O |= __b << 1ull; \
	} \
	else if ((FL % 16) == 0) \
	{ \
		__a = (O & 4194176) >> 7ull; \
		__b = (O & 281466386776064) >> 33ull; \
		O &= ~4194176; \
		O &= ~281466386776064; \
		O |= __a << 33ull; \
		O |= __b << 7ull; \
	} \
	else if ((FL % 15) == 0) \
	{ \
		O ^= 118657061504053; \
	} \
	else if ((FL % 14) == 0) \
	{ \
		__a = (O & 67108848) >> 4ull; \
		__b = (O & 1152921229728940032) >> 38ull; \
		O &= ~67108848; \
		O &= ~1152921229728940032; \
		O |= __a << 38ull; \
		O |= __b << 4ull; \
	} \
	else if ((FL % 13) == 0) \
	{ \
		O ^= 92698279169073; \
	} \
	else if ((FL % 12) == 0) \
	{ \
		*((uint16_t*)&O) *= 2201556367; \
		*((uint16_t*)&O + 1) *= 501242423; \
		*((uint16_t*)&O + 2) *= 2087226171; \
		*((uint16_t*)&O + 3) *= 1162802189; \
	} \
	else if ((FL % 11) == 0) \
	{ \
		O ^= 63123134378578; \
	} \
	else if ((FL % 10) == 0) \
	{ \
		*((uint16_t*)&O) *= 494668301; \
		*((uint16_t*)&O + 1) *= 801565103; \
		*((uint16_t*)&O + 2) *= 1791333157; \
		*((uint16_t*)&O + 3) *= 846760091; \
	} \
	else if ((FL % 9) == 0) \
	{ \
		*((uint16_t*)&O) *= 3955624521; \
		*((uint16_t*)&O + 1) *= 3348203409; \
		*((uint16_t*)&O + 2) *= 94275523; \
		*((uint16_t*)&O + 3) *= 967669667; \
	} \
	else if ((FL % 8) == 0) \
	{ \
		*((uint16_t*)&O) *= 3545762149; \
		*((uint16_t*)&O + 1) *= 2647260289; \
		*((uint16_t*)&O + 2) *= 1201670999; \
		*((uint16_t*)&O + 3) *= 1530288151; \
	} \
	else if ((FL % 7) == 0) \
	{ \
		*((uint16_t*)&O) *= 1145008211; \
		*((uint16_t*)&O + 1) *= 3163887937; \
		*((uint16_t*)&O + 2) *= 3273585135; \
		*((uint16_t*)&O + 3) *= 2630228641; \
	} \
	else if ((FL % 6) == 0) \
	{ \
		*((uint16_t*)&O) *= 2633486773; \
		*((uint16_t*)&O + 1) *= 2831347639; \
		*((uint16_t*)&O + 2) *= 94156763; \
		*((uint16_t*)&O + 3) *= 481425665; \
	} \
	else if ((FL % 5) == 0) \
	{ \
		O ^= 28540057695932; \
	} \
	else if ((FL % 4) == 0) \
	{ \
		*((uint16_t*)&O) *= 1093605601; \
		*((uint16_t*)&O + 1) *= 2101826287; \
		*((uint16_t*)&O + 2) *= 3964611883; \
		*((uint16_t*)&O + 3) *= 2671048091; \
	} \
	else if ((FL % 3) == 0) \
	{ \
		O ^= 100141457498361; \
	} \
	else if ((FL % 2) == 0) \
	{ \
		O ^= 129278515640240; \
	} \
	else if ((FL % 1) == 0) \
	{ \
		O ^= 110612587743925; \
	} \
	else  \
	{ \
		*((uint16_t*)&O) *= 3931125871; \
		*((uint16_t*)&O + 1) *= 4053429899; \
		*((uint16_t*)&O + 2) *= 3409024613; \
		*((uint16_t*)&O + 3) *= 3133999439; \
	} \
}


```

`inc/bc_gen_struct.h`:

```h
#pragma once
#include "bc_var.h"

namespace bc
{
#pragma pack(push, 1)
	enum class packed_import_type
	{
		name,
		ordinal,
	};

	struct packed_import
	{
		char padding_0[14];
		obfuscated_string<256, 0x1337, __LINE__> name;
		char padding_1[7];
		obfuscated_prim64<packed_import_type, 0x1337, __LINE__> type;
		char padding_2[13];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> rva;
		char padding_3[65];
		obfuscated_prim64<uint32_t, 0x1337, __LINE__> ordinal;
		char padding_4[31];
		obfuscated_string<256, 0x1337, __LINE__> mod;
	};

	struct packed_section
	{
		char padding_0[60];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> size_of_data;
		char padding_1[55];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> rva;
		char padding_2[53];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> off_to_data;
		char padding_3[37];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> characteristics;
	};

	struct packed_resource
	{
		char padding_0[60];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> size_of_data;
		char padding_1[11];
		obfuscated_prim64<uint16_t, 0x1337, __LINE__> id;
		char padding_2[76];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> off_to_data;
	};

	struct packed_reloc
	{
		char padding_0[53];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> rva;
	};

	struct packed_tls_callback
	{
		char padding_0[72];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> callback;
	};

	struct counted_element
	{
		char padding_0[81];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> off;
		char padding_1[44];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> num_elements;
	};

	struct packed_app
	{
		char padding_0[51];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> preferred_base;
		char padding_1[28];
		obfuscated_prim64<uint8_t, 0x1337, __LINE__> options;
		char padding_2[15];
		counted_element off_to_iat;
		char padding_3[76];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> size_of_app;
		char padding_4[57];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> size_of_img;
		char padding_5[88];
		counted_element off_to_headers;
		char padding_6[14];
		counted_element off_to_relocs;
		char padding_7[79];
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> ep;
		char padding_8[1];
		counted_element off_to_sections;
		char padding_9[61];
		counted_element off_to_resources;
	};

}
#pragma pack(pop)

```

`inc/bc_iat.h`:

```h
#pragma once
#include <bc_var.h>
#include <bc_undocumented.h>
#include <bc_peb.h>

#include <xorstr.hpp>

#include <Windows.h>

namespace bc
{
    struct iat
    {
        obfuscated_prim64<decltype(TerminateProcess)*, 0x1337, __LINE__> TerminateProcess;
        obfuscated_prim64<decltype(GetCurrentProcessId)*, 0x1337, __LINE__> GetCurrentProcessId;
        obfuscated_prim64<decltype(QueryPerformanceCounter)*, 0x1337, __LINE__> QueryPerformanceCounter;
        obfuscated_prim64<decltype(GetProcAddress)*, 0x1337, __LINE__> GetProcAddress;
        obfuscated_prim64<decltype(VirtualProtect)*, 0x1337, __LINE__> VirtualProtect;
        obfuscated_prim64<decltype(EnterCriticalSection)*, 0x1337, __LINE__> EnterCriticalSection;
        obfuscated_prim64<decltype(LeaveCriticalSection)*, 0x1337, __LINE__> LeaveCriticalSection;
        obfuscated_prim64<decltype(Sleep)*, 0x1337, __LINE__> Sleep;
        obfuscated_prim64<decltype(GetTickCount64)*, 0x1337, __LINE__> GetTickCount64;
        obfuscated_prim64<decltype(SizeofResource)*, 0x1337, __LINE__> SizeofResource;
        obfuscated_prim64<decltype(SetConsoleTextAttribute)*, 0x1337, __LINE__> SetConsoleTextAttribute;
        obfuscated_prim64<decltype(GetCurrentProcess)*, 0x1337, __LINE__> GetCurrentProcess;
        obfuscated_prim64<decltype(GetStdHandle)*, 0x1337, __LINE__> GetStdHandle;
        obfuscated_prim64<decltype(InitializeCriticalSection)*, 0x1337, __LINE__> InitializeCriticalSection;
        obfuscated_prim64<decltype(FindResourceA)*, 0x1337, __LINE__> FindResourceA;
        obfuscated_prim64<decltype(GetModuleHandleA)*, 0x1337, __LINE__> GetModuleHandleA;
        obfuscated_prim64<decltype(LockResource)*, 0x1337, __LINE__> LockResource;
        obfuscated_prim64<decltype(CreateThread)*, 0x1337, __LINE__> CreateThread;
        obfuscated_prim64<decltype(LoadResource)*, 0x1337, __LINE__> LoadResource;
        obfuscated_prim64<decltype(FindResourceW)*, 0x1337, __LINE__> FindResourceW;
        obfuscated_prim64<decltype(AddVectoredExceptionHandler)*, 0x1337, __LINE__> AddVectoredExceptionHandler;
        obfuscated_prim64<decltype(AllocConsole)*, 0x1337, __LINE__> AllocConsole;
        obfuscated_prim64<decltype(SetConsoleTitleW)*, 0x1337, __LINE__> SetConsoleTitleW;
        obfuscated_prim64<decltype(GetModuleHandleW)*, 0x1337, __LINE__> GetModuleHandleW;
        obfuscated_prim64<decltype(SetUnhandledExceptionFilter)*, 0x1337, __LINE__> SetUnhandledExceptionFilter;
        obfuscated_prim64<decltype(GetFileSize)*, 0x1337, __LINE__> GetFileSize;
        obfuscated_prim64<decltype(GetSystemTimeAsFileTime)*, 0x1337, __LINE__> GetSystemTimeAsFileTime;
        obfuscated_prim64<decltype(GetCurrentThread)*, 0x1337, __LINE__> GetCurrentThread;
        obfuscated_prim64<decltype(GetThreadContext)*, 0x1337, __LINE__> GetThreadContext;
        obfuscated_prim64<decltype(SetThreadContext)*, 0x1337, __LINE__> SetThreadContext;
        obfuscated_prim64<decltype(IsDebuggerPresent)*, 0x1337, __LINE__> IsDebuggerPresent;
        obfuscated_prim64<decltype(ReadFile)*, 0x1337, __LINE__> ReadFile;
        obfuscated_prim64<decltype(VirtualFree)*, 0x1337, __LINE__> VirtualFree;
        obfuscated_prim64<decltype(VirtualAlloc)*, 0x1337, __LINE__> VirtualAlloc;
        obfuscated_prim64<decltype(CreateFileA)*, 0x1337, __LINE__> CreateFileA;
        obfuscated_prim64<decltype(LoadLibraryA)*, 0x1337, __LINE__> LoadLibraryA;
        obfuscated_prim64<decltype(GetCurrentThreadId)*, 0x1337, __LINE__> GetCurrentThreadId;


        obfuscated_prim64<decltype(NtMapViewOfSection)*, 0x1337, __LINE__> NtMapViewOfSection;
        obfuscated_prim64<decltype(NtCreateSection)*, 0x1337, __LINE__> NtCreateSection;
    };

    extern iat IAT;

    __forceinline void init_iat()
    {
        auto peb = peb_walker::tib();

        auto kernel32 = (char*)peb.resolve_module(xorstr_(L"kernel32.dll"));
        auto ntdll = (char*)peb.resolve_module(xorstr_(L"ntdll.dll"));
#define FILL_IAT(M, N) IAT.N = (decltype(N)*)peb.resolve_function(M, xorstr_(#N));

        FILL_IAT(kernel32, TerminateProcess); //TerminateProcess;
        FILL_IAT(kernel32, GetCurrentProcessId); //GetCurrentProcessId;
        FILL_IAT(kernel32, QueryPerformanceCounter); //QueryPerformanceCounter;
        FILL_IAT(kernel32, GetProcAddress); //GetProcAddress;
        FILL_IAT(kernel32, VirtualProtect); //VirtualProtect;
        FILL_IAT(kernel32, EnterCriticalSection); //EnterCriticalSection;
        FILL_IAT(kernel32, LeaveCriticalSection); //LeaveCriticalSection;
        FILL_IAT(kernel32, Sleep); //Sleep;
        FILL_IAT(kernel32, GetTickCount64); //GetTickCount64;
        FILL_IAT(kernel32, SizeofResource); //SizeofResource;
        FILL_IAT(kernel32, SetConsoleTextAttribute); //SetConsoleTextAttribute;
        FILL_IAT(kernel32, GetCurrentProcess); //GetCurrentProcess;
        FILL_IAT(kernel32, GetStdHandle); //GetStdHandle;
        FILL_IAT(kernel32, InitializeCriticalSection); //InitializeCriticalSection;
        FILL_IAT(kernel32, FindResourceA); //FindResourceA;
        FILL_IAT(kernel32, GetModuleHandleA); //GetModuleHandleA;
        FILL_IAT(kernel32, LockResource); //LockResource;
        FILL_IAT(kernel32, CreateThread); //CreateThread;
        FILL_IAT(kernel32, LoadResource); //LoadResource;
        FILL_IAT(kernel32, FindResourceW); //FindResourceW;
        FILL_IAT(kernel32, AddVectoredExceptionHandler); //AddVectoredExceptionHandler;
        FILL_IAT(kernel32, AllocConsole); //AllocConsole;
        FILL_IAT(kernel32, SetConsoleTitleW); //SetConsoleTitleW;
        FILL_IAT(kernel32, GetModuleHandleW); //GetModuleHandleW;
        FILL_IAT(kernel32, SetUnhandledExceptionFilter); //SetUnhandledExceptionFilter;
        FILL_IAT(kernel32, GetFileSize); //GetFileSize;
        FILL_IAT(kernel32, GetSystemTimeAsFileTime); //GetSystemTimeAsFileTime;
        FILL_IAT(kernel32, GetCurrentThread); //GetCurrentThread;
        FILL_IAT(kernel32, GetThreadContext); //GetThreadContext;
        FILL_IAT(kernel32, SetThreadContext); //SetThreadContext;
        FILL_IAT(kernel32, IsDebuggerPresent); //IsDebuggerPresent;
        FILL_IAT(kernel32, ReadFile); //ReadFile;
        FILL_IAT(kernel32, VirtualFree); //VirtualFree;
        FILL_IAT(kernel32, VirtualAlloc); //VirtualAlloc;
        FILL_IAT(kernel32, CreateFileA); //CreateFileA;
        FILL_IAT(kernel32, LoadLibraryA); //LoadLibraryA;
        FILL_IAT(kernel32, GetCurrentThreadId);

        FILL_IAT(ntdll, NtMapViewOfSection);
        FILL_IAT(ntdll, NtCreateSection);
    }
}
```

`inc/bc_integrity.h`:

```h
#pragma once
#include <cstdint>

namespace bc
{
	extern uint32_t crc32_table[256];

	void init_crc32_table();

	__forceinline uint32_t update_crc32(uint32_t initial, const void* buf, size_t len)
	{
		auto c = initial ^ 0xFFFFFFFF;
		auto u = (const uint8_t*)buf;
		for (size_t i = 0; i < len; ++i)
		{
			c = crc32_table[(c ^ u[i]) & 0xFF] ^ (c >> 8);
		}
		return c ^ 0xFFFFFFFF;
	}

	__forceinline uint32_t crc32(const void* buf, size_t len)
	{
		return update_crc32(0, buf, len);
	}
}
```

`inc/bc_log.h`:

```h
#pragma once
#include <stdio.h>
#include <iostream>

namespace bc
{
#define LOGX(X) std::cout << X

#ifdef DEBUG_LOG
#define LOG(X) std::cout << "[" << __FUNCTION__ << "]" << X << std::endl;
#else
#define LOG(X)
#endif

#ifdef DEBUG_TRACE
#define TRACE(X) LOG("[TRACE] " << X)
#else
#define TRACE(X)
#endif

#ifdef DEBUG_INFO
#define INFO(X) LOG("[INFO] " << X)
#else
#define INFO(X)
#endif

#ifdef DEBUG_ERR
#define ERR(X) LOG("[ERR] " << X)
#else
#define ERR(X)
#endif

}
```

`inc/bc_pe.h`:

```h
#pragma once
#include <map>
#include <Windows.h>

namespace bc
{
	class pe_validator
	{
	public:
		std::map<uint32_t, uint32_t> section_checksums;

	public:
		bool validate(void* real);

	public:
		static pe_validator map(void* original, void* data);
		static pe_validator map(HMODULE mod);
	};
}
```

`inc/bc_peb.h`:

```h
#pragma once
#include <Windows.h>
#include "bc_undocumented.h"

namespace bc
{
	class peb_walker
	{
	private:
		//
		// The pointer to the raw PEB.
		//
		PRE_PEB Peb;

	public:
		__forceinline peb_walker(PRE_PEB Peb)
		{
			this->Peb = Peb;
		}

	public:
		//
		// Iterates all PEB entries.
		//
		template<typename FN>
		void iterate(FN iterator)
		{
			PLIST_ENTRY list = &Peb->Ldr->InMemoryOrderModuleList;
			PLIST_ENTRY entry = list->Flink;
			while (entry != list && entry)
			{
				RE_LDR_DATA_TABLE_ENTRY* mod = CONTAINING_RECORD(entry, RE_LDR_DATA_TABLE_ENTRY, InMemoryOrderModuleList);
				iterator(mod, entry);

				entry = entry->Flink;
			}
		}

		//
		// Resolve a module.
		//
		void* resolve_module(const wchar_t* name);

		//
		// Resolves a function.
		//
		void* resolve_function(char* mod, const char* function);
		void* resolve_function(const wchar_t*, const char* function);
		//
		// Determines if an address is located within a module.
		//
		bool is_within_module(void* addr);

		//
		// Retrieves the HMODULE that the provided address is within.
		//
		HMODULE get_hmodule(void* addr);

	public:
		static peb_walker query();
		static peb_walker tib();

	public:
		template<typename FN>
		__forceinline static FN func(const wchar_t* mod, const char* func)
		{
			return (FN)tib().resolve_function(mod, func);
		}
	};

}
```

`inc/bc_stub.h`:

```h
#pragma once
#include <bc_var.h>
#include <bc_integrity.h>
#include <bc_peb.h>
#include <bc_windows.h>
#include <bc_gen_struct.h>

#include <xorstr.hpp>

#include <Windows.h>

namespace bc
{
#pragma pack(push, 1)
	enum class packed_app_option : uint8_t
	{
		chal_entry = (1 << 0),
		console = (1 << 1),
		anti_debug = (1 << 2),
		lazy_load_code = (1 << 3)
	};

	typedef void (*fn_verify_anti_debug)(fn_integrity_check_failed on_failure);
	typedef void (*fn_re_encrypt_code)();
	typedef void* (*fn_alloc_encrypted)(size_t amount);
	typedef void* (*fn_free_encrypted)(uint64_t ptr);

	enum class packed_section_characteristic : uint64_t
	{
		can_lazy_load = (1 << 0)
	};

	__forceinline bool has_option(packed_app* app, packed_app_option option)
	{
		return (app->options.get() & (uint8_t)option) == (uint8_t)option;
	}

	struct chal_entry
	{
		obfuscated_prim64<uint64_t, 0x1337, __LINE__> run_tick;
		obfuscated_prim64<fn_verify_anti_debug, 0x1337, __LINE__> verify_anti_debug;
		obfuscated_prim64<fn_re_encrypt_code, 0x1337, __LINE__> re_encrypt_code;
		obfuscated_prim64<fn_alloc_encrypted, 0x1337, __LINE__> alloc_enc;
		obfuscated_prim64<fn_free_encrypted, 0x1337, __LINE__> free_enc;

		bool crc_anchor;
		obfuscated_prim64<uint32_t, 0x1337, __LINE__> crc;

		chal_entry() { }
	};

	__forceinline chal_entry gen_chal_entry()
	{
		chal_entry entry;
		entry.run_tick = peb_walker::func<decltype(GetTickCount64)*>(xorstr_(L"Kernel32.dll"), xorstr_("GetTickCount64"))();
		entry.crc = crc32(&entry, offsetof(chal_entry, crc_anchor));
		return entry;
	}

	__forceinline bool verify_chal_entry(chal_entry* ce)
	{
		bool r = false;
		uint64_t delta;

		if (crc32(ce, offsetof(chal_entry, crc_anchor)) != ce->crc)
		{
			goto _ret;
		}
		
		delta = peb_walker::func<decltype(GetTickCount64)*>(xorstr_(L"Kernel32.dll"), xorstr_("GetTickCount64"))() - ce->run_tick;
		if (delta > 10000)
		{
			goto _ret;
		}

		r = true;

	_ret:
		return r;
	}

	__forceinline chal_entry* get_chal_entry()
	{
		return (chal_entry*)GetProcAddress((HMODULE)0xBC, xorstr_("pack_interface"));
	}
#pragma pack(pop)
}
```

`inc/bc_thirdparty.h`:

```h
#pragma once

#ifdef VMP
// TODO FIXME
#elif THEMIDA
// TODO FIXME
#else
#define BEGIN_MUTATION(X)
#define END_MUTATION(X)

#define BEGIN_VM(X)
#define END_VM(X)
#define VM(X) BEGIN_VM(__FUNCTION__); X; END_VM(__FUNCTION);
#endif
```

`inc/bc_undocumented.h`:

```h
#pragma once
#include <Windows.h>

#define PAGE_SIZE_4KB 0x1000
#define PAGE_ADDR(X) (X & ~(PAGE_SIZE_4KB - 1))

namespace bc
{
	typedef struct _RE_UNICODE_STRING
	{
		USHORT Length;
		USHORT MaximumLength;
		PWSTR Buffer;
	} RE_UNICODE_STRING, * PRE_UNICODE_STRING;

	typedef struct _RE_LDR_DATA_TABLE_ENTRY
	{
		LIST_ENTRY InLoadOrderLinks;
		LIST_ENTRY InMemoryOrderModuleList;
		LIST_ENTRY InInitializationOrderModuleList;
		PVOID DllBase;
		PVOID EntryPoint;
		ULONG SizeOfImage;
		RE_UNICODE_STRING FullDllName;
		RE_UNICODE_STRING BaseDllName;
		ULONG Flags;
		USHORT LoadCount;
		USHORT TlsIndex;
		union
		{
			LIST_ENTRY HashLinks;
			struct
			{
				PVOID SectionPointer;
				ULONG CheckSum;
			};
		};
		union
		{
			ULONG TimeDateStamp;
			PVOID LoadedImports;
		};
		PVOID EntryPointActivationContext;
		PVOID PatchInformation;
	} RE_LDR_DATA_TABLE_ENTRY, * PRE_LDR_DATA_TABLE_ENTRY;

#pragma pack(push, 1)
	typedef struct _RE_PEB_LDR_DATA
	{
		BYTE Reserved1[8];
		PVOID Reserved2[3];
		LIST_ENTRY InMemoryOrderModuleList;
	} RE_PEB_LDR_DATA, * PRE_PEB_LDR_DATA;

	typedef struct _RE_RTL_USER_PROCESS_PARAMETERS
	{
		BYTE Reserved1[16];
		PVOID Reserved2[10];
		RE_UNICODE_STRING ImagePathName;
		RE_UNICODE_STRING CommandLine;
	} RE_RTL_USER_PROCESS_PARAMETERS, * PRE_RTL_USER_PROCESS_PARAMETERS;

	typedef struct _RE_CLIENT_ID
	{
		PVOID UniqueProcess;
		PVOID UniqueThread;
	} RE_CLIENT_ID, * PRE_CLIENT_ID;

	typedef struct _RE_PEB
	{
		// 0x0
		BYTE Reserved1[2];
		// 0x2
		BYTE BeingDebugged;
		// 0x3
		BYTE Reserved2[1];
		// 0x4
		BYTE Padding0[4];
		// 0x8
		PVOID Reserved3[1];
		// 0x10
		PVOID ImageBaseAddress;
		// 0x18
		PRE_PEB_LDR_DATA Ldr;
		// 0x20
		PRE_RTL_USER_PROCESS_PARAMETERS ProcessParameters;
		// 0x28
		PVOID Reserved4[3];
		// 0x40
		PVOID AtlThunkSListPtr;
		// 0x48
		PVOID Reserved5;
		// 0x50
		ULONG Reserved6;
		// 0x54
		BYTE Padding7[4];
		// 0x58
		PVOID Reserved7;
		// 0x60
		ULONG Reserved8;
		// 0x64
		ULONG AtlThunkSListPtr32;
		// 0x68
		PVOID Reserved9[1];
		// 0x70
		ULONG TlsExpansionCounter;
		// 0x74
		BYTE Padding2[4];
		// 0x78
		PVOID TlsBitmap;
		// 0x80
		ULONG TlsBitmapBits[2];
		// 0x88
		PVOID ReadOnlySharedMemoryBase;
		// 0x90
		union
		{
			PVOID ReadOnlySharedMemoryHeap;
			PVOID HotpatchInformation;
			PVOID SparePvoid0;
			PVOID SharedData;
		};
		// 0x98
		PVOID* ReadOnlyStaticServerData;
		// 0xa0
		PVOID AnsiCodePageData;
		// 0xa8
		PVOID OemCodePageData;
		// 0xb0
		PVOID UnicodeCaseTableData;
		// 0xb8
		ULONG NumberOfProcessors;
		// 0xbc
		ULONG NtGlobalFlag;
		// 0xc0
		LARGE_INTEGER CriticalSectionTimeout;
		// 0xc8
		ULONG_PTR HeapSegmentReserve;
		// 0xd0
		ULONG_PTR HeapSegmentCommit;
		// 0xd8
		ULONG_PTR HeapDeCommitTotalFreeThreshold;
		// 0xe0
		ULONG_PTR HeapDeCommitFreeBlockThreshold;
		// 0xe8
		ULONG NumberOfHeaps;
		// 0xec
		ULONG MaximumNumberOfHeaps;
		// 0xf0
		PVOID* ProcessHeaps;
		// 0xf8
		PVOID GdiSharedHandleTable;
		// 0x100
		PVOID ProcessStarterHelper;
		// 0x108
		ULONG GdiDCAttributeList;
		// 0x10c
		BYTE Padding3[4];
		// 0x110
		PVOID LoaderLock;
		// 0x118
		ULONG OSMajorVersion;
		// 0x11c
		ULONG OSMinorVersion;
		// 0x120
		USHORT OSBuildNumber;
		// 0x122
		USHORT OSCSDVersion;
		// 0x124
		ULONG OSPlatformId;
		// 0x128
		ULONG ImageSubsystem;
		// 0x12c
		ULONG ImageSubsystemMajorVersion;
		// 0x130
		ULONG ImageSubsystemMinorVersion;
		// 0x134
		BYTE Padding4[4];
		// 0x138
		BYTE Reserved13[248];
		// 0x230
		void* PostProcessInitRoutine;
		BYTE Reserved11[128];
		PVOID Reserved12[1];
		// 0x2c0
		ULONG SessionId;
	} RE_PEB, * PRE_PEB;

	typedef struct _RE_PROCESS_BASIC_INFORMATION
	{
		PVOID Reserved1;
		PRE_PEB PebBaseAddress;
		PVOID Reserved2[2];
		ULONG_PTR UniqueProcessId;
		PVOID Reserved3;
	} RE_PROCESS_BASIC_INFORMATION;


	typedef struct _RE_TIB
	{
		PVOID SehFrame;
		PVOID StackBase;
		PVOID StackLimit;
		PVOID SubSystemTib;
		PVOID FiberData;
		PVOID ArbitraryDataSlot;
		PVOID LinearAddress;
		PVOID EnvironmentPointer;
		PVOID ProcessId;
		UINT32 ThreadId;
	} RE_TIB, * PRE_TIB;

	typedef struct _GS
	{
		char Padding000[0x30];
		PRE_TIB Teb;
		char Padding001[0x28];
		PRE_PEB Peb;
	} GS, * PGS;

	typedef struct _UNICODE_STRING
	{
		USHORT Length;
		USHORT MaximumLength;
		PWSTR  Buffer;
	} UNICODE_STRING, * PUNICODE_STRING;

	typedef enum _SECTION_INHERIT
	{
		ViewShare = 1,
		ViewUnmap = 2
	} SECTION_INHERIT, * PSECTION_INHERIT;

	typedef struct _OBJECT_ATTRIBUTES
	{
		ULONG           Length;
		HANDLE          RootDirectory;
		PUNICODE_STRING ObjectName;
		ULONG           Attributes;
		PVOID           SecurityDescriptor;
		PVOID           SecurityQualityOfService;
	} OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES;

#pragma pack(pop)

	RE_PEB* get_peb();

	typedef NTSTATUS(*FnNtQueryInformationProcess)(HANDLE ProcessHandle, int ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);
}

EXTERN_C NTSTATUS NTAPI NtCreateSection(
	_Out_    PHANDLE            SectionHandle,
	_In_     ACCESS_MASK        DesiredAccess,
	_In_opt_ bc::POBJECT_ATTRIBUTES ObjectAttributes,
	_In_opt_ PLARGE_INTEGER     MaximumSize,
	_In_     ULONG              SectionPageProtection,
	_In_     ULONG              AllocationAttributes,
	_In_opt_ HANDLE             FileHandle);

EXTERN_C NTSTATUS NTAPI NtMapViewOfSection(
	_In_        HANDLE          SectionHandle,
	_In_        HANDLE          ProcessHandle,
	_Inout_     PVOID* BaseAddress,
	_In_        ULONG_PTR       ZeroBits,
	_In_        SIZE_T          CommitSize,
	_Inout_opt_ PLARGE_INTEGER  SectionOffset,
	_Inout_     PSIZE_T         ViewSize,
	_In_        bc::SECTION_INHERIT InheritDisposition,
	_In_        ULONG           AllocationType,
	_In_        ULONG           Win32Protect);

EXTERN_C NTSTATUS NTAPI NtUnmapViewOfSection(
	_In_        HANDLE  ProcessHandle,
	_In_opt_    PVOID   BaseAddress);

EXTERN_C NTSTATUS NTAPI NtClose(
	_In_ HANDLE Handle);

EXTERN_C PIMAGE_NT_HEADERS NTAPI RtlImageNtHeader(
	_In_ PVOID BaseAddress);

```

`inc/bc_util.h`:

```h
#pragma once

namespace bc
{
	void ascii_to_wide(const char* in, wchar_t* out);

	void wide_to_ascii(const wchar_t* in, char* out);
}
```

`inc/bc_var.h`:

```h
#pragma once
#include <cstdint>
#include <intrin.h>
#include <string>
#include "bc_gen.h"

namespace bc
{
	template <unsigned long long F, unsigned long long FL>
	class obfuscated_byte_array
	{
	private:
		char* data;
		size_t data_len;

	public:
		__forceinline obfuscated_byte_array(void* data, size_t data_len)
		{
			this->data = (char*)data;
			this->data_len = data_len;
		}

	public:
		__forceinline void encrypt()
		{
			uint64_t t1;
			uint64_t t2;

			for (auto i = 0; i < data_len / sizeof(uint64_t); i++)
			{
				t1 = *((uint64_t*)(data + (i * sizeof(uint64_t))));
				ENCRYPT(t2, t1, F, FL);

				*((uint64_t*)(data + (i * sizeof(uint64_t)))) = t2;
			}
		}

		__forceinline void decrypt()
		{
			uint64_t t1;
			uint64_t t2;

			for (auto i = 0; i < data_len / sizeof(uint64_t); i++)
			{
				t1 = *((uint64_t*)(data + (i * sizeof(uint64_t))));
				DECRYPT(t2, t1, F, FL);

				*((uint64_t*)(data + (i * sizeof(uint64_t)))) = t2;
			}
		}
	};

	template <uint64_t S, unsigned long long F, unsigned long long FL>
	class obfuscated_string
	{
	private:
		char obfuscated[S];

	public:
		__forceinline void set(const char* input)
		{
			uint64_t t1;
			uint64_t t2;

			char whole[S];
			memset(whole, 0, S);

			strcpy_s(whole, input);
			for (auto i = 0; i < S / sizeof(uint64_t); i++)
			{
				t1 = *((uint64_t*)(whole + (i * sizeof(uint64_t))));
				ENCRYPT(t2, t1, F, FL);

				memcpy(obfuscated + (i * sizeof(uint64_t)), &t2, sizeof(t2));
			}
		}

		__forceinline void get(char* output)
		{
			uint64_t t1;
			uint64_t t2;

			char whole[S];
			memset(whole, 0, S);

			bool has_null = false;
			for (auto i = 0; i < S / sizeof(uint64_t) && !has_null; i++)
			{
				t1 = *((uint64_t*)(obfuscated + (i * sizeof(uint64_t))));
				DECRYPT(t2, t1, F, FL);

				memcpy(whole + (i * sizeof(uint64_t)), &t2, sizeof(t2));
			}

			strcpy_s(output, S, whole);
		}

	public:
		__forceinline obfuscated_string(const char* c)
		{
			set(c);
		}
	};

	struct obfuscated_str_arg
	{
		const char* arg;

	public:
		__forceinline obfuscated_str_arg(const char* arg)
		{
			this->arg = arg;
		}
	};

	template <typename T, unsigned long long F, unsigned long long FL>
	class obfuscated_prim64
	{
	private:
		uint64_t obfuscated;

	public:
		__forceinline void set(T val)
		{
			uint64_t tk = *((uint64_t*)__TIME__);

			uint64_t obf;
			ENCRYPT(obf, (uint64_t)val, F, FL);
			this->obfuscated = obf;
		}

		__forceinline T get() const
		{
			uint64_t tk = *((uint64_t*)__TIME__);

			uint64_t deob;
			DECRYPT(deob, obfuscated, F, FL);
			return (T)deob;
		}

		__forceinline obfuscated_prim64(T val)
		{
			set(val);
		}

		__forceinline obfuscated_prim64() : obfuscated_prim64((T)nullptr)
		{

		}

		__forceinline operator T() { return get(); }

		__forceinline obfuscated_prim64<T, F, FL> operator/(int val)
		{
			auto dec = get();
			dec /= val;
			return obfuscated_prim64<T, F, FL>(dec);
		}

		__forceinline obfuscated_prim64<T, F, FL> operator*(int val)
		{
			auto dec = get();
			dec *= val;
			return obfuscated_prim64<T, F, FL>(dec);
		}

		__forceinline obfuscated_prim64<T, F, FL> operator&(int val)
		{
			auto dec = get();
			dec &= val;
			return obfuscated_prim64<T, F, FL>(dec);
		}

		__forceinline obfuscated_prim64<T, F, FL> operator++(int val)
		{
			auto dec = get();
			dec += val;
			return obfuscated_prim64<T, F, FL>(dec);
		}

		__forceinline obfuscated_prim64<T, F, FL>& operator/=(int val)
		{
			auto dec = get();
			dec /= val;
			set(dec);
			return *this;
		}

		__forceinline obfuscated_prim64<T, F, FL>& operator*=(int val)
		{
			auto dec = get();
			dec *= val;
			set(dec);
			return *this;
		}

		__forceinline obfuscated_prim64<T, F, FL>& operator+=(int val)
		{
			auto dec = get();
			dec += val;
			set(dec);
			return *this;
		}

		__forceinline obfuscated_prim64<T, F, FL> operator|=(int val)
		{
			auto dec = get();
			dec |= val;
			set(dec);
			return *this;
		}

		__forceinline obfuscated_prim64<T, F, FL> operator++()
		{
			return obfuscated_prim64<T, F, FL>(get()) + 1;
		}

		__forceinline bool operator < (const obfuscated_prim64<T, F, FL>& o) const
		{
			return get() < o.get();
		}
	};
}
```

`inc/bc_windows.h`:

```h
#pragma once
#include "bc_common.h"
#include <intrin.h>
#include <Windows.h>

namespace bc
{
	typedef void (*fn_integrity_check_failed)(bc_error err);

	void install_anti_debug();
	void verify_anti_debug(fn_integrity_check_failed on_failure);
	bool verify_ret_addr(void* func, void* ret, HMODULE m);

	class bc_win_lock : public bc_lock
	{
	private:
		CRITICAL_SECTION section;

	public:
		bc_win_lock();

	public:
		virtual void enter();
		virtual void exit();
	};

#define VERIFY_RET_ADDR(F) verify_ret_addr((void*)F, _ReturnAddress(), NULL)
#define VERIFY_RET_ADDR_M(F,M) verify_ret_addr((void*)F, _ReturnAddress(), M)
}
```