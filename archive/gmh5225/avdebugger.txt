Project Path: arc_gmh5225_avdebugger_ce1u0360

Source Tree:

```txt
arc_gmh5225_avdebugger_ce1u0360
├── Dockerfile
├── README.md
├── antivirus_debugger.py
├── config.json
├── config.py
├── find.py
├── find_bad_strings.py
├── known_bad_strings.txt
├── output.txt
├── pe_utils.py
├── pytest.ini
├── requirements.txt
├── scan.py
├── scanner.py
├── slides
│   └── 2022_03_Insomnihack_Antivirus_vmeier.pdf
├── string_encryptor.py
└── test_find_bad_strings.py

```

`Dockerfile`:

```
FROM archlinux/base
RUN echo "root:root" | chpasswd
RUN useradd -m -G wheel -s /bin/bash toto \
	&& echo "toto:toto" | chpasswd
RUN pacman -Syu --noconfirm && pacman -Sy --noconfirm git sudo vim base-devel cabextract python3 cmake lib32-glibc lib32-gcc-libs gcc-multilib python-pip radare2
RUN echo -e "%wheel ALL=(ALL) NOPASSWD:ALL" > /etc/sudoers.d/99_wheel
RUN python3 -m pip install tqdm r2pipe

#RUN cd /tmp \
#	&& git clone https://aur.archlinux.org/yay.git \
#	&& cd yay \
#	&& chown -R toto. /tmp/yay/ \
#	&& sudo -u toto makepkg -s \
#	&& pacman --noconfirm -U /tmp/yay/yay*.pkg.tar.xz
#
#RUN sudo -u toto yay -Sy --noconfirm cmake

USER toto
WORKDIR /home/toto

#RUN git clone https://github.com/taviso/loadlibrary# && cd loadlibrary && make
#COPY engine/* /home/toto/loadlibrary/engine

```

`README.md`:

```md
# Description

Most antivirus engines rely on strings or other bytes sequences, function exports and big integers to recognize malware.
This project helps to automatically recover these signatures.

# Project status

Able to automatically find and remove the strings that have the most impact on the AV's verdict.

# Setup and usage

Here are the instructions to use this tool.

## Dependencies (Python 3)

* python-tqdm
* python-hexdump
* pytest

```
python3 -m pip install -r requirements.txt
```

## Dependencies (other)

* rabin2 (from radare2)
* loadlibrary: Windows Defender scanner ported to Linux by taviso (3 minutes setup, instructions at https://github.com/taviso/loadlibrary)

## Configuration

Fix all the values in `config.json`.

## Usage

```
python3 antivirus_debugger.py -h                                                          
usage: antivirus_debugger.py [-h] [-s] [-z] [-f FILE] [-e] [-l LENGTH] [-c SECTION] [-g] [-V] [-H HIDE_SECTION] [-S SCANNER]

optional arguments:
  -h, --help            show this help message and exit
  -s, --skip-strings    Skip strings analysis
  -z, --skip-sections   Skip sections analysis
  -f FILE, --file FILE  path to file
  -e, --extensive       search strings in all sections
  -l LENGTH, --length LENGTH
                        minimum length of strings
  -c SECTION, --section SECTION
                        Analyze provided section
  -g, --globals         Analyze global variables in .data section
  -V, --virus           Virus scan
  -H HIDE_SECTION, --hide-section HIDE_SECTION
                        Hide a section
  -S SCANNER, --scanner SCANNER
                        Antivirus engine. Default = DockerWindowsDefender
```

```

`antivirus_debugger.py`:

```py
import argparse
import sys
from tempfile import NamedTemporaryFile

from find import bytes_detection
from find_bad_strings import bissect
from pe_utils import *
from scanner import DockerWindowsDefender
from scanner import g_scanner

log_format = '[%(levelname)-8s][%(asctime)s][%(filename)s:%(lineno)3d] %(funcName)s() :: %(message)s'
logging.basicConfig(filename='debug.log',
                            filemode='a',
                            format=format,
                            datefmt='%Y/%m/%d %H:%M',
                            level=logging.DEBUG
                    )


rootLogger = logging.getLogger()
logFormatter = logging.Formatter(log_format)

consoleHandler = logging.StreamHandler()
consoleHandler.setFormatter(logFormatter)
rootLogger.addHandler(consoleHandler)

BINARY = ""

g_args = None



"""
attempts to locate the part in a PE file that causes the antivirus detection
"""
def locate_signature(pe):

    nb_section_detected = 0
    detected_sections = []

    for section in pe.sections:

        # copy the binary
        new_name = NamedTemporaryFile().name
        shutil.copyfile(pe.filename, new_name)

        # hide the section
        new_pe = deepcopy(pe)
        new_pe.filename = new_name
        hide_section(new_pe, section.name)
        new_pe.md5 = md5(new_name)

        logging.debug(f"Scanning {new_name} md5 = {new_pe.md5}")
        # scan it
        status = not g_scanner.scan(new_pe.filename)

        # record the result
        section.detected = not status

        if status:
            logging.info(f"Section {section.name} triggers the antivirus")
            nb_section_detected += 1
            detected_sections += [section]

    logging.info(f"{nb_section_detected} section(s) trigger the antivirus")
    return nb_section_detected, detected_sections


def bytes_analysis(pe, start_address, end_address):

    # check that masking these bytes is sufficient to evade the antivirus
    # copy the binary
    new_name = NamedTemporaryFile().name
    shutil.copyfile(pe.filename, new_name)

    # hide the byzes
    new_pe = deepcopy(pe)
    new_pe.filename = new_name
    hide_bytes(new_pe, start_address, end_address-start_address)
    status = g_scanner.scan(new_pe.filename)

    if status:
        logging.warning("No idea. Your binary is indeed detected but hiding everything but the PE header results in detection anyways. Check PE header.")
        logging.debug(new_pe.filename)
        spwn_dbg()
        raise Exception("")


    # a signature is present in these bystes, let's binary search

    bytes_detection(pe.filename, start_address, end_address)


def strings_analysis(pe):


    # no point in continuing if the binary is not detected as malicious already.
    #assert(scan(sample_file) is True)

    str_refs = pe.strings
    logging.debug(f"Got {len(str_refs)} string objects")

    # mask all strings
    logging.debug("Patching all the strings in the binary")

    # patch the binary (mask the string)
    for str_ref in str_refs:
        # if str_ref.length > 500:
        str_ref.should_mask = True

        # copy the binary
    new_name = NamedTemporaryFile().name
    shutil.copyfile(pe.filename, new_name)
    logging.info(new_name)

    # hide the byzes
    new_pe = deepcopy(pe)
    new_pe.filename = new_name

    pipe = r2pipe.open(new_name, flags=["-w"])
    patch_binary_mass(new_name, str_refs, pipe)

    logging.debug("Binary patched")
    detection_result = not g_scanner.scan(new_name)

    # sometimes there are signatures in the .txt sections
    if detection_result:
        logging.info(f"{g_scanner.scanner_name} seems to only detect strings in this binary.")
    else:
        logging.warning(f"Patching all the strings does not evade detection.")

    return detection_result



def multi_signatures_analysis(pe):



    for section in pe.sections:
        new_pe = backup_pe(pe)

        hide_all_sections_except(new_pe, section.name)

        status = g_scanner.scan(new_pe.filename)

        if status:
            logging.info(f"Section {section.name} has a signature")

    return True # TODO


def global_vars_analysis(pe):

    logging.info("Applying patches")
    new_pe1 = backup_pe(pe)
    for patch in new_pe1.patches:
        hide_bytes(new_pe1, patch.addr, patch.size)


    logging.info(f"Simple check: maybe a single global variable is detected")
    vars = detect_data(new_pe1)
    print_global_variables(new_pe1, vars)

    status, base_threat_name = g_scanner.scan(new_pe1.filename, with_name=True)
    assert(status)


    sig_found = False

    for var in vars:

        new_pe = backup_pe(new_pe1)
        hide_bytes(new_pe, var.paddr, var.size)
        status, threat_name = g_scanner.scan(new_pe.filename, with_name=True)
        logging.debug(f"{status} - {threat_name}")
        if not status or threat_name != base_threat_name:
            logging.info(f"{g_scanner.scanner_name} detects this global variable:")
            var.display(pe)
            pe.patches += [Patch(var.paddr, var.size)]
            sig_found = True

            if not status:
                logging.info(f"Done ! You should patch these bytes:")
                for patch in pe.patches:
                    patch.display(pe)
                return
            else:
                logging.error("Patching and starting over, since we've found something that may decrease the detection score.")

            break

    if sig_found:
        global_vars_analysis(pe)

def investigate(pe):

    status = g_scanner.scan(pe.filename)

    if not status:

        logging.error(f"{pe.filename} is not detected by {g_scanner.scanner_name}")
        return

    if g_args.virus:
        logging.info(status)
        return

    if g_args.globals:

        global_vars_analysis(pe)

    if not g_args.skip_strings:
        strings_based_detection = strings_analysis(pe)
    else:
        strings_based_detection = False

    if not g_args.skip_sections and not g_args.section:
        nb_sections, detected_sections = locate_signature(pe)
    else:
        nb_sections = 0


    if not strings_based_detection and nb_sections == 0 and not g_args.section:

        if multi_signatures_analysis(pe):

            logging.info(f"Signature in .text section, but also elsewhere")
        else:

            logging.info(f"{g_scanner.scanner_name} seems to have a dumb bytes-based detection engine")
            sections_addr = [section.addr for section in pe.sections]
            start_address = min(sections_addr)
            end_address = max(sections_addr)
            assert(end_address > start_address)
            bytes_analysis(pe, start_address, end_address)

    elif nb_sections == 0 and not g_args.section:
        logging.info("Finding the high score strings will be sufficient to evade the engine")
        bissect(pe.filename)

    elif nb_sections == 1:

        if detected_sections[0].name == ".data":
            global_vars_analysis(pe)
        else:
            logging.info(f"Launching bytes analysis on section {detected_sections[0].name}")
            bytes_analysis(pe, detected_sections[0].addr, detected_sections[0].addr+detected_sections[0].size)
    elif g_args.section:
        logging.info(f"Launching bytes analysis on section {g_args.section}")

        section = next((sec for sec in pe.sections if sec.name == g_args.section), None)
        bytes_analysis(pe, section.addr, section.addr+section.size)



def parse_pe(sample_file):

    pe = PE()
    pe.filename = sample_file
    pe.sections = get_sections(pe)
    pe.strings = parse_strings(sample_file, g_args.extensive, g_args.length)
    pe.md5 = md5(sample_file)
    return pe


if __name__ == "__main__":

    parser = argparse.ArgumentParser()

    parser.add_argument("-s", '--skip-strings', help="Skip strings analysis", action="store_true")
    parser.add_argument("-z", "--skip-sections", help="Skip sections analysis", action="store_true")
    parser.add_argument("-f", "--file", help="path to file")
    parser.add_argument("-e", "--extensive", help="search strings in all sections", action="store_true")
    parser.add_argument("-l", "--length", help="minimum length of strings", type=int, default=5)
    parser.add_argument('-c', '--section', help="Analyze provided section")
    parser.add_argument('-g', '--globals', help="Analyze global variables in .data section", action="store_true")
    parser.add_argument('-V', '--virus', help="Virus scan", action="store_true")
    parser.add_argument('-H', '--hide-section', help="Hide a section", type=str)
    parser.add_argument('-S', "--scanner", help="Antivirus engine", default="DockerWindowsDefender")
    g_args = parser.parse_args()

    if g_args.scanner == "DockerWindowsDefender":
        g_scanner = DockerWindowsDefender()

    pe = parse_pe(g_args.file)

    if g_args.hide_section:
        copy_file = NamedTemporaryFile(delete=False)
        shutil.copy(pe.filename, copy_file.name)
        pe.filename = copy_file.name
        hide_section(pe, g_args.hide_section)
        logging.info(f"Dumped patched file @ {copy_file.name}")
        sys.exit(0)


    investigate(pe)

```

`config.json`:

```json
{
  "loadlibrary_path": "/home/toto/loadlibrary/mpclient",
  "loadlibrary_path_dir": "/home/toto/loadlibrary",
  "docker_loadlibrary_name": "loadlibrary-working",
  "avast_vmx": "/Users/vladimir/Virtual Machines.localized/Windows_10_Avast.vmwarevm/Windows_10_Avast.vmx",
  "kaspersky_vmx": "../../kasp.vmx",
  "deepinstinct_vmx": "../../Virtual Machines.localized/Windows_10_AV_DeepInstinct.vmwarevm/Windows_10_AV_DeepInstinct.vmx",
  "vmware_user": "toto",
  "vmware_passwd": "wow, such strong hardcoded password"
}

```

`config.py`:

```py
import json
import os

CONFIG_FILE = os.path.join(os.path.dirname(__file__), "config.json")


def get_value(value):

    try:
        with open(CONFIG_FILE) as jsonfile:

            data = json.load(jsonfile)

        if value in data:
            return data[value]
    except Exception as e:
        import traceback
        traceback.print_exc()
        import os
        print(os.getcwd())
        raise Exception(e)

    raise Exception(f"Unknown field: {value}. Available fields are: {data.keys()}")

```

`find.py`:

```py
#!/usr/bin/python

import logging
import string
import sys
from collections import deque
from concurrent import futures

import hexdump
from capstone import *
from intervaltree import Interval, IntervalTree
from tqdm import tqdm

import config
import pe_utils
from scanner import g_scanner

logging.basicConfig(filename='debug.log',
                    filemode='a',
                    format='[%(levelname)-8s][%(asctime)s][%(filename)s:%(lineno)3d] %(funcName)s() :: %(message)s',
                    datefmt='%Y/%m/%d %H:%M',
                    level=logging.DEBUG)

"""
dependecies: hexdump, intervaltree
todo:
 * pefile -> locate code section
 * sliding window algorithm in order to find a smaller section

"""

ResultQueue = deque()
interval_tree = IntervalTree()
START_LEAP = 2048
MIN_LEAP = 100
IGNORE_START = 0
IGNORE_END = 0x256 #todo use pefile to find the start of code
GOAT_FILE = '/tmp/metsrv.x64.dll'
WDEFENDER_INSTALL_PATH = config.get_value("loadlibrary_path_dir")
MAX_THREADS = 10
DEBUG_LEVEL = 1
buffer = []
goat = []
res = {}
has_lead = False
progress = 0
cs = Cs(CS_ARCH_X86, CS_MODE_64)
cs.detail = True
cs.skipdata = True



def print_disass(base, code_size, raw_code):

    code_base = base
    if code_base == 0:
        code_base = 0x1000

    for i in cs.disasm(raw_code, code_base):

        if i > 256:
            break
        logging.info("0x%x:\t%s\t%s" %(i.address, i.mnemonic, i.op_str))


"""
    remove the intervals for which we have a more precise one
    for instance, if we have [10:20] and [0:500], the last one is useless.
    Problem: if [0:5][6:10], it is not correct to delete interval [0:10]
"""
def filter_matches(good_res):
    filtered = IntervalTree() # good_res.copy()

    for match in good_res:

        # if not filtered.containsi(*match):
        #    continue

        try:
            # filtered.remove_overlap(match)
            if len(good_res.envelop(match.begin, match.end)) <= 1:
                filtered.add(match)
        except Exception as e:
            logging.warning(f"Exception encountered ({e.args}). Spawning IPython shell to debug...")
            import traceback
            traceback.format_exc()
            if not "IPython" in sys.modules:
                import IPython
                IPython.embed()


    return filtered

"""
    get strings from binary blob
"""
def strings(binary, min=4):
    result = ""
    for c in binary:
        c = chr(c)
        if c in string.printable[:-5]:
            result += c
            continue
        if len(result) >= min:
            yield result
        result = ""
    if len(result) >= min:  # catch result at EOF
        yield result

"""
    Scans a file with Windows Defender and returns True if the file
    is detected as a threat.
"""
def scan(path):

    return g_scanner.scan(path)


"""
    replace each half of a file with null bytes and check if it impacts
    the detection verdict. If it does, the half is added to a queue in order
    to improve the precision.
    Problem if each half is detected for now
"""
def sigseek(buffer, current_offset, end, counter):

    global progress
    leap = (end - current_offset) // 2
    patch = bytes(chr(0),'ascii')*int(leap)
    nb_chunk = (end - current_offset) // leap if not leap == 0 else 0
    detected_chunks = 0
    bufs = []

    logging.info(f"\t\t[+] {nb_chunk} chunks to process")

    while current_offset < end and leap >= MIN_LEAP:
        progress.set_postfix(current_offset=current_offset+leap, refresh=True)
        logging.info(f"\t\t[+] Patching buffer of size = {len(buffer)}, offset = {current_offset}, leap = {leap}")
        goat = buffer[:current_offset] + patch + buffer[current_offset+leap:]
        bufs += [goat]
        filepath = GOAT_FILE + "_"+str(counter)

        with open(filepath,'wb') as fw:
            fw.write(goat)

        if not scan(filepath):
            has_lead = True
            logging.info(f"[+] Found signature between {current_offset} and {current_offset+leap}")
            ResultQueue.append(Interval(int(current_offset), current_offset+leap))
            progress.update(1)

        else:
            logging.info(f"[-] Current offset = {current_offset}")
            detected_chunks += 1

        current_offset += leap

    if detected_chunks == nb_chunk and detected_chunks > 0:

        logging.info(f"\t[!] File appears to be detected with several patterns ({detected_chunks})")
        sigseek(bufs[0], current_offset, end, counter+1000)
        sigseek(bufs[1], current_offset-leap, end, counter+5000)
    elif detected_chunks == 1:
        branch_skipped = count_max_chunks(leap)
        progress.update(branch_skipped)


def locate_found_signatures(filename, interval_tree):

    pe = pe_utils.PE()
    pe.filename=filename
    sections = pe_utils.get_sections(pe)

    for interval in interval_tree:
        for section in sections:
            if interval.begin >= section.addr and interval.end < section.addr + section.size:
                logging.info(f"Signature in {section.name} section ({interval.begin} to {interval.end})")
        else:

            section_begin = next(section for section in sections if
                                 section.addr <= interval.begin < (section.addr + section.size))

            section_end = next(section for section in sections if
                                 section.addr <= interval.end < (section.addr + section.size))
            logging.info(f"Signature crossing two sections: {section_begin.name} and {section_end.name}  ({interval.begin} to {interval.end})")

"""
    pretty print the results with hexdumps
"""
def clean_results(filename):
    global START_LEAP
    global buffer

    logging.info(f"[*] Got {len(interval_tree)} signatures, filtering...")
    good_res = filter_matches(interval_tree)
    logging.info(f"[*] Filtered {len(interval_tree) - len(good_res)} signatures...")
    locate_found_signatures(filename, good_res)

    logging.info(f"[*] Got {len(good_res)} signatures...")

    logging.info("[+] Here are the potential findings:")

    for i in sorted(good_res):

        leap = i.end - i.begin

        if not leap < len(buffer) // 2:
            logging.info(f"\t\t[-] Skipping because leap ({leap}) is bigger than initial value")
            continue

        dump_path = "/tmp/goat_"+str(i.begin)+"-"+str(i.end)+".bin"
        sig = buffer[i.begin:i.end]

        patch = leap * bytes(chr(0),'ascii')
        goat = buffer[:i.begin] + patch + buffer[i.end:]

        with open(dump_path, "wb") as fd:
            fd.write(goat)

        logging.info(f"[*] Signature between {i.begin} and {i.end} dumped at {dump_path}:")
        logging.info(hexdump.hexdump(sig, result='return'))

        logging.info("[*] Strings:")
        for s in strings(sig):
            logging.info(f"> {s}")

        try:
            logging.info("[*] Disassembly (x64):")
            print_disass(i.begin, leap, sig)
        except:
            logging.error("Disassembly failed")

    logging.info("[*] Done")

"""
    used for the progress bar and helps
    estimate the work to be done
"""
def count_max_chunks(size):

    if size <= MIN_LEAP:
        return 0

    return 1 + 2 * count_max_chunks(size//2)


"""
    main function
"""
def process_file(sample_file, start = 0, end=-1):

    global interval_tree
    global ResultQueue
    global buffer
    global progress

    with open(sample_file, 'rb') as f:
        buffer = f.read()

    max(len(buffer), end)
    total = count_max_chunks(end)
    logging.info(f"[*] Number of chunks to process: {total}")
    progress = tqdm(total=total, leave=False)
    ResultQueue.append(Interval(start, end))
    counter = 0

    with futures.ThreadPoolExecutor(max_workers=MAX_THREADS) as exec:

        to_do = []
        last_size = 0

        while len(ResultQueue) > 0 or len(to_do) > 0:

            if len(ResultQueue) == 0:
                logging.debug("\t\t[-] Waiting on results...")
                next(futures.as_completed(to_do)).result()

            counter += 1

            logging.debug(f"\t\t[*] {len(ResultQueue)} elements in queue...")

            for i in ResultQueue:
                interval_tree.add(i)

            if len(ResultQueue) > 0:
                match = ResultQueue.pop()
            else:
                return

            last_size = match.end - match.begin
            futur = exec.submit(sigseek, buffer, match.begin, match.end, counter)
            to_do = [futur]
    progress.clear()
    progress.close()


def bytes_detection(filename, start=0, end=-1):

    # g_scanner = VMWareAvast()
    sample_file = filename

    try:
        pe = pe_utils.PE()
        pe.filename = sample_file
        new_pe = pe_utils.backup_pe(pe)
        process_file(new_pe.filename, start, end)
        clean_results(filename)
        logging.info("[*] Done ! Press any to exit...")

    except KeyboardInterrupt:
        logging.info("[*] Not done, but here is what I've found so far:")
        clean_results(filename)

if __name__ == "__main__":


    if len(sys.argv) > 1:
       sample_file = sys.argv[1]

    else:
        exit(-1)

    bytes_detection(sample_file)




```

`find_bad_strings.py`:

```py
#!/usr/bin/python3
import dataclasses
import logging
import re
import subprocess
import sys
import tempfile

from tqdm import tqdm

from scanner import g_scanner

logging.basicConfig(filename='debug.log',
                    filemode='a',
                    format='[%(levelname)-8s][%(asctime)s][%(filename)s:%(lineno)3d] %(funcName)s() :: %(message)s',
                    datefmt='%Y/%m/%d %H:%M',
                    level=logging.DEBUG)

BINARY                 = "test_cases/ext_server_kiwi.x64.dll"
ORIGINAL_BINARY        = ""
DEBUG_LEVEL            = 2  # setting supporting levels 0-3, incrementing the verbosity of log msgs
LVL_ALL_DETAILS        = 3  # everything
LVL_DETAILS            = 2  # only    important  details
LVL_RES_ONLY           = 1  # only    results
LVL_SILENT             = 0  # quiet


@dataclasses.dataclass
class StringRef:
    index      : int = 0  # index of the string
    paddr      : int = 0  # offset from the beginning of the file
    vaddr      : int = 0  # virtual address in the binary
    length     : int = 0  # number of characters of the string
    size       : int = 0  # size of the memory taken by the string
    section    : str = ""  # segment where the string is located
    encoding   : str = ""  # encoding of the string (utf-8, utf-16, utf-32, etc)
    content    : str = ""  # actual string
    is_replaced: bool = False  # has this string already been patched?
    is_bad     : bool = False  # does this string has a signifcant impact on the AV's verdict?


"""
    Wrapper to print text to stdout, either for concurrent access to
    the file descriptor, or because we need to enrich the text before.
"""
def print_dbg(msg, level=3, decorate=True):

    toprint = msg

    if decorate:
        toprint = "[*] " + toprint

    if level <= DEBUG_LEVEL:
        tqdm.write(toprint)

"""
    Loads an entire binary to memory.
    Warning: don't use on huge files.
"""
def get_binary(path):

    data = []

    with open(path, "rb") as f:
        data = f.read()

    return data


"""
    Executes rabin2 to get all the strings from a binary.
    @param filepath: the path to the file to be analyzed.
    @return: the raw output from rabin2
"""
def get_all_strings(file_path, extensive=False):

    command = ['rabin2', "-z", file_path]
    if extensive:
        command = ['rabin2', "-zz", file_path]

    p = subprocess.Popen(command, stdout=subprocess.PIPE,
                         stderr=subprocess.STDOUT)
    rout = ""
    iterations = 0
    while(True):

        retcode = p.poll()  # returns None while subprocess is running
        out = p.stdout.readline().decode('utf-8', errors="ignore")
        iterations += 1
        rout += out
        if(retcode is not None):
            break

    return rout


"""
    Executes rabin2 to enumerate the binary's sections information
    @param filepath: the path to the file to be analyzed.
    @return: the raw output from rabin2
"""
def get_sections(file_path):

    command = ['rabin2', "-S", file_path]

    p = subprocess.Popen(command, stdout=subprocess.PIPE,
                         stderr=subprocess.STDOUT)
    rout = ""
    iterations = 0
    while(True):

        retcode = p.poll()  # returns None while subprocess is running
        out = p.stdout.readline().decode('utf-8', errors="ignore")
        iterations += 1
        rout += out
        if(retcode is not None):
            break

    return rout


"""
    Hides an entire section of a binary
    rabin2 output:
        [Sections]
        Nm Paddr       Size Vaddr      Memsz Perms Name
        00 0x00000400 619008 0x180001000 622592 -r-x .text
"""
def hide_section(section, filepath, binary):

    section_size = 0
    section_addr = 0

    strings_data = get_sections(filepath)

    for string in strings_data.split('\n'):

        # to preserve some whitespaces
        data = string.split()

        if len(data) >= 4 and data[0].isnumeric():

            if data[6] == section:
                print_dbg(f"Found {section} section, hiding it...", LVL_DETAILS, True)
                section_size = int(data[2],16)
                section_addr = int(data[1],16)
                break

    assert(section_size > 0)
    assert(section_addr > 0)

    patch = bytes('\x41' * section_size, 'ascii')
    new_bin = binary[:section_addr] + patch + binary[section_addr+section_size:]

    # binary's size is not expected to change.
    assert(len(new_bin) == len(binary))

    return new_bin

"""
    converts rabin2 encoding to python3
    @param encoding the requested encoding (string)
    @return the correct encoding as string
"""
def convert_encoding(encoding):

    table = {
        "ascii": "ascii",
        "utf16le": "utf_16_le",
        "utf32le": "utf_32_le",
        "utf8": "utf8"
    }

    assert(table.get(encoding) is not None)
    return table.get(encoding)


"""
    Used to process the raw output of rabin2.
    Populates a collection of StringRefs objects from the collected data.
    TODO: parse output of -zz
    @param strings_data: the raw output of rabin2
    @return: a collection of StringRefs
"""
def parse_strings(strings_data):
    # columns: Num, Paddr, Vaddr, Len, Size, Section, Type, String
    string_refs = []

    for string in strings_data.split('\n'):
        data = re.split(r'(\s+)', string)  # to preserve some whitespaces
        if len(data) >= 7 and data[0].isnumeric():
            str_ref = StringRef()
            str_ref.index = int(data[0])
            str_ref.paddr = int(data[2], 16)
            str_ref.vaddr = int(data[4], 16)
            str_ref.length = int(data[6])
            str_ref.size = int(data[8])
            str_ref.section = data[10]
            str_ref.encoding = data[12]
            new_encoding = convert_encoding(str_ref.encoding)
            to_parse_len = str_ref.length+len("\x00".encode(new_encoding))
            # skip first whitespace
            content = "".join(data[13:])[1:to_parse_len]
            str_ref.content = content
            string_refs += [str_ref]

    return string_refs


"""
    Scans a file with Windows Defender and returns True if the file
    is detected as a threat.
"""
def scan(path):

    return g_scanner.scan(path)



"""
    @description patch a binary blob at the location pointed by "str_ref"
    @param binary binary blob of data
    @param str_ref StringRef object, must hold size, length and content.
    @param filepath if non empty, the function will write the resulting binary to the specified location on disk.
    @param mask if true, patches with junk data, or else path with str_ref.content (revert to original content)
"""
def patch_binary(binary, str_ref, filepath, mask=True):

    encoding = convert_encoding(str_ref.encoding)
    patch = bytes('\x00' * str_ref.size, 'ascii')

    # tricky part, the original string must be put back in the binary.
    # however, several encodings and null bytes make that a pain to realize.
    # In case of failures, the original binary is used instead of str_ref.content
    if not mask:
        cnt = str_ref.content + '\x00'  # why already ??
        cnt = str_ref.content.replace("\\n", '\x0a')
        cnt = cnt.replace("\\t", '\x09')
        patch = bytes(cnt+chr(0), encoding)

        if len(patch) != str_ref.size or "\\" in str_ref.content:
            print_dbg(
                "Oops, parsing error, will recover bytes from the original file...", LVL_ALL_DETAILS)
            with open(BINARY, "rb") as tmp_fd:
                tmp_fd.seek(str_ref.paddr)
                patch = tmp_fd.read(str_ref.size)

    new_bin = binary[:str_ref.paddr] + patch + \
              binary[str_ref.paddr+str_ref.size:]

    # binary's size is not expected to change.
    assert(len(new_bin) == len(binary))

    # write the patched binary to disk
    if len(filepath) > 0:
        with open(filepath, "wb") as f:
            f.write(new_bin)

    return new_bin


"""
    returns true if all string_refs are in the blacklist
    tested: true
    @param string_refs a collection of StringRef objects
    @param blacklist a collection of indexes that are known to the AV engine
"""
def is_all_blacklisted(string_refs, blacklist):
    return all(s.index in blacklist for s in string_refs)


"""
    merges two lists without duplicates
    @param list1 some collection of type 'list'
    @param list2 somme collection of type 'list'
    return list1 and list2 merged together (type: list)
"""
def merge_unique(list1, list2):
    list3 = list1 + list2
    unique_set = set(list3)
    return list(unique_set)


"""
    returns true if both lists are equal and order doesn't matter
    @param list1 some list
    @param list2 some list
"""
def is_equal_unordered(list1, list2):
    set1 = set(list1)
    set2 = set(list2)
    return set1 == set2


"""
    Takes the original binary, patches the strings whose
    indexes are in "blacklist" and re-scan with the AV.
"""
def validate_results(sample_file, tmpfile, blacklist, all_strings):


    # read the binary.
    binary = get_binary(sample_file)

    for b in blacklist:
        string = next(filter(lambda x: x.index == b, all_strings))
        print_dbg(f"Removing bad string {repr(string)}", LVL_DETAILS, True)
        binary = patch_binary(binary, string, "", True)

    with open(tmpfile, "wb") as fd:
        fd.write(binary)

    detection = scan(tmpfile)

    return detection


"""
    TODO: update the progress bar.
    TODO: use a threadpool.
    @param binary binary blob currently edited, all strings hidden
    @param string_refs list of StringRefs objects.
    @param blacklist list of strings' index to never unmask.
"""
def rec_bissect(binary, string_refs, blacklist):

    if type(string_refs) is list and len(string_refs) < 2:
        if len(string_refs) > 0:
            i = string_refs[0]
            print_dbg(f"Found it: {repr(i)}", LVL_RES_ONLY, False)
            blacklist.append(i.index)
        return blacklist

    elif type(string_refs) is StringRef:
        print_dbg(f"Found it: f{repr(string_refs)}", LVL_RES_ONLY, False)
        blacklist.append(string_refs.index)
        return blacklist


    try:
        half_nb_strings = len(string_refs) // 2
    except:
        print_dbg(f"Found it: f{repr(string_refs)}", LVL_RES_ONLY, False)
        blacklist.append(string_refs.index)
        return blacklist
    half1 = string_refs[:half_nb_strings]
    half2 = string_refs[half_nb_strings:]
    binary1 = binary
    binary2 = binary

    for string in half1:

        # hide all upper half of binary2
        binary2 = patch_binary(binary2, string, "", mask=True)

        if string.index in blacklist:
            # hide the blacklisted string
            binary1 = patch_binary(binary1, string, "", mask=True)
            binary2 = patch_binary(binary2, string, "", mask=True)

        else:
            # put the string back
            binary1 = patch_binary(binary1, string, "", mask=False)

    for string in half2:

        #hide all lower half of binary1
        binary1 = patch_binary(binary1, string, "", mask=True)

        if string.index in blacklist:
            # hide blacklisted strings in both halves
            binary1 = patch_binary(binary1, string, "", mask=True)
            binary2 = patch_binary(binary2, string, "", mask=True)
        else:
            # unhide all lower half of binary2
            binary2 = patch_binary(binary2, string, "", mask=False)
            pass

    dump_path1 = tempfile.NamedTemporaryFile()
    dump_path2 = tempfile.NamedTemporaryFile()

    with open(dump_path1.name, "wb") as f:
        f.write(binary1)

    with open(dump_path2.name, "wb") as fd:
        fd.write(binary2)

    detection_result1 = scan(dump_path1.name)
    detection_result2 = scan(dump_path2.name)

    dump_path1.close()
    dump_path2.close()

    res = detection_result1 or detection_result2

    # the upper half triggers the detection
    if detection_result1:
        print_dbg(f"Signature between half1 {half1[0].index} and {half1[-1].index}", LVL_DETAILS)
        blacklist1 = rec_bissect(binary1, half1, blacklist)
        blacklist = merge_unique(blacklist, blacklist1)

    if detection_result2:
        print_dbg(f"Signature between half2 {half2[0].index} and {half2[-1].index}", LVL_DETAILS)
        blacklist2 = rec_bissect(binary2, half2, blacklist)
        blacklist = merge_unique(blacklist, blacklist2)

    if not res:
        print_dbg("Both halves are not detected", LVL_DETAILS)

        # TODO: rather hazardous, but works for mimikatz. In case of failures, fix this.
        half1 = string_refs[:len(string_refs)//4]
        half2 = string_refs[len(string_refs)//4]
        blacklist = merge_unique(
            blacklist, rec_bissect(binary, half1, blacklist))
        blacklist = merge_unique(
            blacklist, rec_bissect(binary, half2, blacklist))

    return blacklist

"""
    Amorce function for the bissection algorithm.
    Expects a path to a binary detected by the AV engine.
    Returns a list of signatures or crashes.
"""
def bissect(sample_file, blacklist = []):

    global BINARY

    BINARY = sample_file

    # no point in continuing if the binary is not detected as malicious already.
    assert(scan(sample_file) is True)

    # use rabin2 from radare2 to extract all the strings from the binary
    #strings_data = get_all_strings(sample_file, extensive=True)

    # parse rabin2 output
    import pe_utils
    str_refs = pe_utils.parse_strings(sample_file)

    print_dbg(f"Got {len(str_refs)} string objects", LVL_DETAILS, True)

    # read the binary.
    binary = get_binary(sample_file)
    binary1 = binary
    # mask all strings
    for string in str_refs:
        # patch the binary (mask the string)
        binary = patch_binary(binary, string, "", True)

    dump_path = tempfile.NamedTemporaryFile()

    with open(dump_path.name, "wb") as f:
        f.write(binary)

    detection_result = scan(dump_path.name)
    dump_path.close()

    # sometimes there are signatures in the .txt sections
    if detection_result is True:
        print_dbg("Hiding all the strings doesn't seem to impact the AV's verdict.\
             Retrying after masking the .text section", LVL_DETAILS, True)
        binary = hide_section(".text", sample_file, binary1)
        tmp = tempfile.NamedTemporaryFile()
        with open("/tmp/toto", "wb") as f:
            f.write(binary)
        bissect("/tmp/toto")
        exit(0)


    print_dbg("Good, masking all the strings has an impact on the AV's verdict", 0)
    #progress = tqdm(total=len(str_refs), leave=False)

    blacklist = rec_bissect(binary1, str_refs, blacklist)

    if len(blacklist) > 0:
        print_dbg(f"Found {len(blacklist)} signatures", LVL_DETAILS, True)
        print(blacklist)

        for b in blacklist:
            string = next(filter(lambda x: x.index == b, str_refs))
            logging.info(f"String @ {hex(string.paddr)} should be patched: ")
            logging.info(string.content)
        tmpfile = "/tmp/newbin"
        if ORIGINAL_BINARY != "":
            if not validate_results(ORIGINAL_BINARY, tmpfile, blacklist, str_refs):
                print_dbg("Validation is ok !", LVL_DETAILS, True)
            else:
                print_dbg("Patched binary is still detected, retrying.", LVL_DETAILS, True)
                bissect("/tmp/newbin", blacklist)
    else:
        print_dbg("No signatures found...", LVL_DETAILS, True)
    return blacklist


if __name__ == "__main__":

    #g_scanner = DockerWindowsDefender()


    sample_file = BINARY

    if len(sys.argv) > 1:
        sample_file = sys.argv[1]
        BINARY = sample_file

    ORIGINAL_BINARY = BINARY

    try:
        # explore(sample_file)
        bissect(sample_file)
        print_dbg("[*] Done ! Press any to exit...", 0)

    except KeyboardInterrupt:
        print_dbg("[*] Not done, but here is what I've found so far:", 0)

```

`known_bad_strings.txt`:

```txt
Pass-the-ccache [NT6]
ERROR kuhl_m_crypto_l_certificates ; CryptAcquireCertificatePrivateKey (0x%08x)
ERROR kuhl_m_crypto_l_certificates ; CertGetCertificateContextProperty (0x%08x)
ERROR kuhl_m_crypto_l_certificates ; CertGetNameString (0x%08x)
lsasrv.dll
ERROR kuhl_m_lsadump_sam ; CreateFile (SYSTEM hive) (0x%08x)
SamIFree_SAMPR_USER_INFO_BUFFER
KiwiAndRegistryTools
wdigest.dll
multirdp
logonPasswords
credman
[%x;%x]-%1u-%u-%08x-%wZ@%wZ-%wZ.%s
n.e. (KIWI_MSV1_0_CREDENTIALS KO)
\\.\mimidrv

```

`output.txt`:

```txt
vladimir@anon ~/dev/research/find_detected_strings % python3 find_bad_strings.py

StringRef(index=449, paddr=658672, vaddr=6443112688, length=59, size=120, section='(.rdata)', encoding='utf16le', content="ERROR kuhl_m_kerberos_ask ; '%wZ' Kerberos name not found!\\n", is_replaced=False, is_bad=False)

We got 5080 string objects
Good, masking all the strings has an impact on the AV's verdict
                                                                                        
Found a bad string, re-masking it                                                                       
Pass-the-ccache [NT6]                                                                                   
                                                                                        
Found a bad string, re-masking it                                                                       
ERROR kuhl_m_crypto_l_certificates ; CryptAcquireCertificatePrivateKey (0x%08x)\n                       
                                                                                        
Found a bad string, re-masking it                                                                       
ERROR kuhl_m_crypto_l_certificates ; CertGetCertificateContextProperty (0x%08x)\n                       
                                                                                        
Found a bad string, re-masking it                                                                       
ERROR kuhl_m_crypto_l_certificates ; CertGetNameString (0x%08x)\n                                       
                                                                                        
Found a bad string, re-masking it                                                                       
lsasrv.dll                                                                                              
                                                                                        
Found a bad string, re-masking it                                                                       
ERROR kuhl_m_lsadump_sam ; CreateFile (SYSTEM hive) (0x%08x)\n                                          
                                                                                        
Found a bad string, re-masking it                                                                       
SamIFree_SAMPR_USER_INFO_BUFFER                                                                         
                                                                                        
Found a bad string, re-masking it                                                                       
KiwiAndRegistryTools                                                                                    
                                                                                        
Found a bad string, re-masking it                                                                       
wdigest.dll                                                                                             
                                                                                        
Found a bad string, re-masking it                                                                       
multirdp                                                                                                
                                                                                        
Found a bad string, re-masking it                                                                       
logonPasswords                                                                                          
                                                                                        
Found a bad string, re-masking it                                                                       
credman                                                                                                 
                                                                                        
Found a bad string, re-masking it                                                                       
[%x;%x]-%1u-%u-%08x-%wZ@%wZ-%wZ.%s                                                                                                                                                           

Found a bad string, re-masking it                                                                       
n.e. (KIWI_MSV1_0_CREDENTIALS KO)                                                                       
                                                                                        
Found a bad string, re-masking it                                                                       
\\.\mimidrv

                                                                                             
 74%|█████████████████████████████████████████████▎               | 3773/5080 [2:32:56<48:54,  2.25s/it]Traceback (most recent call last):
  File "find_bad_strings.py", line 253, in <module>
    explore(sample_file)
  File "find_bad_strings.py", line 220, in explore
    binary = patch_binary(binary, string, dump_path, False)
  File "find_bad_strings.py", line 164, in patch_binary
    f.write(new_bin)
OSError: [Errno 28] No space left on device
python3 find_bad_strings.py  8411.79s user 766.15s system 99% cpu 2:33:04.12 total                      
1 vladimir@anon ~/dev/research/find_detected_strings %

```

`pe_utils.py`:

```py
import base64
import logging
import random
import re
import string
import hashlib
import hexdump
from copy import deepcopy
import shutil
from tempfile import NamedTemporaryFile

from dataclasses import dataclass

import r2pipe

logging.basicConfig(filename='debug.log',
                    filemode='a',
                    format='[%(levelname)-8s][%(asctime)s][%(filename)s:%(lineno)3d] %(funcName)s() :: %(message)s',
                    datefmt='%Y/%m/%d %H:%M',
                    level=logging.DEBUG)


@dataclass
class Section:
    name: str
    size: int
    vsize: int
    addr: int
    vaddr: int
    detected: bool = False


@dataclass
class PE:
    filename = ""
    sections = []
    strings = []
    md5 = ""
    patches = []


@dataclass
class StringRef:
    index: int = 0  # index of the string
    paddr: int = 0  # offset from the beginning of the file
    vaddr: int = 0  # virtual address in the binary
    length: int = 0  # number of characters of the string
    size: int = 0  # size of the memory taken by the string
    section: str = ""  # segment where the string is located
    encoding: str = ""  # encoding of the string (utf-8, utf-16, utf-32, etc)
    content: str = ""  # actual string
    is_replaced: bool = False  # has this string already been patched?
    is_bad: bool = False  # does this string has a significant impact on the AV's verdict?
    should_mask: bool = True



@dataclass(unsafe_hash=True, eq=True, order=True)
class Variable:
    addr: int
    size: int
    paddr:int = 0


    def display(self, pe):

        with open(pe.filename, 'rb') as f:
            f.seek(self.paddr)
            bf = f.read(min(self.size,128))
        logging.info("\n"+hexdump.hexdump(bf, result="return"))


@dataclass
class Patch:

    addr:int
    size:int

    def display(self, pe):

        logging.info(f"{self.size} bytes @ {self.addr}:")

        with open(pe.filename, 'rb') as f:
            f.seek(self.addr)
            bf = f.read(min(self.size,128))
        logging.info("\n"+hexdump.hexdump(bf, result="return"))

def spwn_dbg():
    import sys
    if not "IPython" in sys.modules:
        logging.warning(f"Spawning IPython shell to debug...")
        import IPython
        IPython.embed()


def md5(file):
    with open(file, 'rb') as f:
        data = f.read()

        return hashlib.md5(data).hexdigest()


def backup_pe(pe):
    # copy the binary
    new_name = NamedTemporaryFile().name
    shutil.copyfile(pe.filename, new_name)

    # hide the byzes
    new_pe = deepcopy(pe)
    new_pe.filename = new_name

    return new_pe


"""
    gets sections information about a PE
"""


def get_sections(pe):
    section_size = 0
    section_addr = 0

    pipe = r2pipe.open(pe.filename)

    # get the sections
    sections = pipe.cmdj("iSj")

    for section in sections:

        if section.get("size") != 0 and section.get("addr") != 0:
            pe.sections += [
                Section(section.get("name"), section.get("size"), section.get("vsize"), section.get("paddr"),
                        section.get("vaddr"))]
            logging.debug(f"Found section: {pe.sections[-1]}")

    return pe.sections


def hide_section(pe, section_name):
    section = next((sec for sec in pe.sections if sec.name == section_name), None)
    logging.debug(f"Hiding section {section.name}")
    hide_bytes(pe, section.addr, section.size)


"""
Hide all sections but the one specified
"""


def hide_all_sections_except(pe, exception=".text"):
    for section in pe.sections:
        if section.name != exception:
            hide_section(pe, section.name)


def hide_bytes(pe, start, length):
    logging.debug(f"Hiding {length} bytes @ {start}")
    """
    pipe = r2pipe.open(pe.filename, flags=["-w"])
    replacement = ''.join(random.choice(string.ascii_letters) for i in range(length))
    replacement = base64.b64encode(bytes(replacement, "ascii")).decode()
    pipe.cmd(f"w6d {replacement} @ {start}")
    """
    # for some reasons the code above is buggy with my radare2 version
    with open(pe.filename, 'r+b') as f:
        f.seek(start)
        f.write(bytes(''.join(random.choice(string.ascii_letters) for i in range(length)), encoding='ascii'))


"""
    converts rabin2 encoding to python3
    @param encoding the requested encoding (string)
    @return the correct encoding as string
"""


def convert_encoding(encoding):
    table = {
        "ascii": "ascii",
        "utf16le": "utf_16_le",
        "utf32le": "utf_32_le",
        "utf8": "utf8"
    }

    assert (table.get(encoding) is not None)
    return table.get(encoding)


"""
    Used to process the raw output of rabin2.
    Populates a collection of StringRefs objects from the collected data.
    TODO: parse output of -zz
    @param strings_data: the raw output of rabin2
    @return: a collection of StringRefs
"""


def parse_strings_old(strings_data):
    # columns: Num, Paddr, Vaddr, Len, Size, Section, Type, String
    string_refs = []

    for string in strings_data.split('\n'):
        data = re.split(r'(\s+)', string)  # to preserve some whitespaces
        if len(data) >= 7 and data[0].isnumeric():
            str_ref = StringRef()
            str_ref.index = int(data[0])
            str_ref.paddr = int(data[2], 16)
            str_ref.vaddr = int(data[4], 16)
            str_ref.length = int(data[6])
            str_ref.size = int(data[8])
            str_ref.section = data[10]
            str_ref.encoding = data[12]
            new_encoding = convert_encoding(str_ref.encoding)
            to_parse_len = str_ref.length + len("\x00".encode(new_encoding))
            # skip first whitespace
            content = "".join(data[13:])[1:to_parse_len]
            str_ref.content = content
            string_refs += [str_ref]

    return string_refs


def parse_strings(filename, all_sections=False, min_length=12):
    pipe = r2pipe.open(filename)
    pipe.cmd("aaa")
    # pipe.cmd("aaa")
    if all_sections:
        strings = pipe.cmdj("izzj")
    else:
        strings = pipe.cmdj("izj")

    string_refs = []

    for string in strings:

        if string.get("length") < min_length:
            continue

        if not string.get("section").startswith("."):
            continue

        str_ref = StringRef()
        str_ref.index = string["ordinal"]
        str_ref.paddr = string.get("paddr")
        str_ref.vaddr = string.get("vaddr")
        str_ref.length = string.get("length")
        str_ref.size = string.get("size")
        str_ref.section = string.get("section")
        str_ref.encoding = string.get("type")
        new_encoding = convert_encoding(str_ref.encoding)
        # to_parse_len = str_ref.length + len("\x00".encode(new_encoding))
        # skip first whitespace
        content = string.get("string").replace("\\\\", "\\")
        str_ref.content = content  # .encode(convert_encoding(str_ref.encoding))
        string_refs += [str_ref]
    return string_refs


def patch_binary_mass(filename, str_refs, pipe=None, unmask_only=False):
    if pipe is None:
        pipe = r2pipe.open(filename, flags=["-w"])

    #nstr = [x for x in str_refs if x.length==29 and x.size==30]
    #for str_ref in nstr[len(nstr)//4:-len(nstr)//4]:
    for str_ref in str_refs:
        #if 28 < str_ref.length <= 29:
        patch_string(filename, str_ref, pipe, unmask_only=unmask_only)


def patch_string(filename, str_ref, pipe=None, unmask_only=False):
    if pipe is None:
        pipe = r2pipe.open(filename, flags=["-w"])

    if not str_ref.should_mask:
        replacement = str_ref.content
    elif not unmask_only:
        replacement = ''.join(random.choice(['\x00']) for _ in range(str_ref.length))
        replacement = replacement + '\0'
    else:
        return

    # replacement = base64.b64encode(bytes(replacement, convert_encoding(str_ref.encoding))).decode()
    # pipe.cmd(f"w6d {replacement} @ {str_ref.paddr}")
    logging.debug(f"Patching {str_ref.content} @ {str_ref.paddr} ({filename})")
    with open(filename, 'r+b') as f:
        f.seek(str_ref.paddr)
        f.write(bytes(replacement, encoding=convert_encoding(str_ref.encoding)))


def detect_data(pe):
    pipe = r2pipe.open(pe.filename)
    pipe.cmd("aaa")
    xrefs = pipe.cmdj("axj")
    xrefs = [x for x in xrefs if x["type"] == "DATA"]
    xrefs = sorted(xrefs, key=lambda x: x["addr"])
    vars = []

    # guess var's size
    for index, xref in enumerate(xrefs):

        if index >= len(xrefs) - 1:
            size = 256  # TODO flemme
        else:
            size = xrefs[index + 1]["addr"] - xref["addr"]

        vars += [Variable(xref["addr"], size)]

    # fix vars with size 0
    for i, var in enumerate(vars):

        for j, var2 in enumerate(vars):
            if i == j:
                continue

            if var.addr == var2.addr:
                if var.size == 0:
                    var.size = var2.size

                elif var2.size == 0:
                    var2.size = var.size

    # uniq sort
    vars_filtered = sorted(list(set(vars)), key=lambda x: x.addr)

    # only vars in .data section
    section = next((sec for sec in pe.sections if sec.name == ".data"), None)
    vars_filtered = [x for x in vars_filtered if section.vaddr <= x.addr < section.vaddr + section.vsize]

    # guess file address with virtual address
    for var in vars_filtered:
        var.paddr = var.addr - section.vaddr + section.addr

    logging.debug(vars_filtered)
    return vars_filtered

def print_global_variables(pe, vars):

    for var in vars:

        logging.debug(f"Found {var.size} bytes variable @ {hex(var.addr)}:")
        with open(pe.filename, 'rb') as f:
            f.seek(var.paddr)
            bf = f.read(min(var.size,128))
        logging.debug("\n"+hexdump.hexdump(bf, result="return"))


```

`pytest.ini`:

```ini
[pytest]
log_cli = true

```

`requirements.txt`:

```txt
tqdm
hexdump
pytest
r2pipe

```

`scan.py`:

```py
import os
import subprocess
import sys
import re
import config

WDEFENDER_INSTALL_PATH = config.get_value("loadlibrary_path")

current_dir = os.getcwd()
os.chdir(os.path.dirname(WDEFENDER_INSTALL_PATH))
command = [WDEFENDER_INSTALL_PATH, sys.argv[1]]
p = subprocess.Popen(command, stdout=subprocess.PIPE,
                     stderr=subprocess.STDOUT)

while (True):

    retcode = p.poll()  # returns None while subprocess is running
    out = p.stdout.readline().decode('utf-8', errors='ignore')
    print(out)
    m = re.search('Threat', out)

    if m:
        print("Threat found\n")
        exit(-1)

    if (retcode is not None):
        break

os.chdir(current_dir)
exit(0)

```

`scanner.py`:

```py

from dataclasses import dataclass
import subprocess
import logging
import re
import os
import shutil
import tempfile
import config

WDEFENDER_INSTALL_PATH = config.get_value("loadlibrary_path")
WDEFENDER_INSTALL_PATH_DIR = config.get_value("loadlibrary_path_dir")

logging.basicConfig(filename='debug.log',
                    filemode='a',
                    format='[%(levelname)-8s][%(asctime)s][%(filename)s:%(lineno)3d] %(funcName)s() :: %(message)s',
                    datefmt='%Y/%m/%d %H:%M',
                    level=logging.DEBUG)


@dataclass
class Scanner:

    scanner_path: str = ""
    scanner_name: str = ""

    def scan(self, path):
        return False


class WindowsDefender(Scanner):

    def __init__(self):
        self.scanner_path = WDEFENDER_INSTALL_PATH
        self.scanner_name = "Windows Defender"
    """
        Scans a file with Windows Defender and returns True if the file
        is detected as a threat.
    """

    def scan(self, file_path):

        os.chdir(os.path.dirname(self.scanner_path))
        command = [self.scanner_path, file_path]
        p = subprocess.Popen(command, stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)

        while(True):

            retcode = p.poll()  # returns None while subprocess is running
            out = p.stdout.readline().decode('utf-8', errors='ignore')
            logging.debug(out)
            m = re.search('Threat', out)

            if m:
                return True

            if(retcode is not None):
                break

        return False


class DockerWindowsDefender(Scanner):

    def __init__(self):
        self.scanner_path = WDEFENDER_INSTALL_PATH
        self.scanner_name = "Windows Defender"

    """
        Scans a file with Windows Defender and returns True if the file
        is detected as a threat.
    """

    def scan(self, file_path, with_name=False):
        tmp_file_name = tempfile.NamedTemporaryFile().name
        shutil.copyfile(file_path, tmp_file_name)
        file_path = tmp_file_name

        run_cmd = ["docker", "run", "--rm", "-v", f"{os.getcwd()}:/home/toto/av-signatures-finder", "-v",
                   "/tmp:/tmp", "-v", "/var:/var", config.get_value("docker_loadlibrary_name"), "python3", "/home/toto/av-signatures-finder/scan.py", file_path]
        p = subprocess.Popen(run_cmd, stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)
        ret_value = False
        threat_name = "Nothing"
        while(True):

            retcode = p.poll()  # returns None while subprocess is running
            out = p.stdout.readline().decode('utf-8', errors='ignore').strip()
            # print(out)
            m = re.search('identified', out)

            if m:

                threat_name = out.split("Threat")[1].split("identified")[0]
                ret_value = True

            if len(out) > 0:
                logging.debug(out)

            if(retcode is not None):
                break

        os.unlink(tmp_file_name)

        if with_name:
            return ret_value, threat_name

        return ret_value


class VMWareDeepInstinct(Scanner):

    def __init__(self):
        self.scanner_path = WDEFENDER_INSTALL_PATH
        self.scanner_name = "DeepInstinct"

    """
        Scans a file with Windows Defender and returns True if the file
        is detected as a threat.
    """

    def scan(self, file_path, with_name=False):
        tmp_file_name = tempfile.NamedTemporaryFile().name
        shutil.copyfile(file_path, tmp_file_name)
        file_path = tmp_file_name
        basename = os.path.basename(tmp_file_name)
        vmx_path = config.get_value("deepinstinct_vmx")
        passwd = config.get_value("vmware_passwd")
        username = config.get_value("vmware_user")
        copy_file_cmd = f"vmrun  -T  ws  -gu  {username}  -gp  {passwd}  CopyFileFromHostToGuest  {vmx_path}  {tmp_file_name}  C:\\Users\\toto\\Desktop\\{basename}.exe"
        file_exists_cmd = f"vmrun  -T  ws  -gu  {username}  -gp  {passwd}  fileExistsInGuest  {vmx_path}  C:\\Users\\toto\\Desktop\\{basename}.exe"
        exec_cmd = f"vmrun  -T  ws  -gu  {username}  -gp  {passwd}  runProgramInGuest  {vmx_path}  C:\\Users\\toto\\Desktop\\{basename}.exe"
        print(copy_file_cmd)
        p = subprocess.Popen(copy_file_cmd.split("  "), stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)
        print(
            f"Copy file result: {p.stdout.readline().decode('utf-8', errors='ignore').strip()}")

        p = subprocess.Popen(file_exists_cmd.split("  "), stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)

        print(
            f"File exists 1 result: {p.stdout.readline().decode('utf-8', errors='ignore').strip()}")

        p = subprocess.Popen(exec_cmd.split("  "), stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)

        p = subprocess.Popen(file_exists_cmd.split("  "), stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)

        ret_value = False
        threat_name = "Nothing"
        while(True):

            retcode = p.poll()  # returns None while subprocess is running
            out = p.stdout.readline().decode('utf-8', errors='ignore').strip()
            # print(out)
            m = re.search('does not exist', out)

            if m:

                threat_name = out
                ret_value = True

            if len(out) > 0:
                logging.debug(out)

            if(retcode is not None):
                break

        os.unlink(tmp_file_name)

        if with_name:
            return ret_value, threat_name

        return ret_value


class VMWareKaspersky(Scanner):

    def __init__(self):
        self.scanner_path = WDEFENDER_INSTALL_PATH
        self.scanner_name = "Kaspersky"

    """
        Scans a file with Kaspersky and returns True if the file
        is detected as a threat.
    """

    def scan(self, file_path, with_name=False):
        tmp_file_name = tempfile.NamedTemporaryFile().name
        shutil.copyfile(file_path, tmp_file_name)
        file_path = tmp_file_name
        basename = os.path.basename(tmp_file_name)
        vmx_path = config.get_value("kaspersky_vmx")
        passwd = config.get_value("vmware_passwd")
        username = config.get_value("vmware_user")
        copy_file_cmd = f"vmrun  -T  ws  -gu {username}  -gp  {passwd}  CopyFileFromHostToGuest  {vmx_path}  {tmp_file_name}  C:\\Users\\toto\\Desktop\\{basename}.exe"
        file_exists_cmd = f"vmrun  -T  ws  -gu  {username}  -gp  {passwd}  fileExistsInGuest  {vmx_path}  C:\\Users\\toto\\Desktop\\{basename}.exe"
        exec_cmd = f"vmrun  -T  ws  -gu  {username}  -gp  {passwd}  runProgramInGuest  {vmx_path}  C:\\Users\\toto\\Desktop\\{basename}.exe"
        scan_cmd = ["vmrun",  "-T",  "ws",  "-gu",  username,  "-gp",  passwd,  "runProgramInGuest",
                    f"{vmx_path}", "C:\\Program Files (x86)\\Kaspersky Lab\\Kaspersky Anti-Virus 21.3\\avp.exe", "SCAN", f"C:\\Users\\{username}\\Desktop\\{basename}.exe", "/i0"]
        # print(f"Copy file result: {subprocess.Popen(scan_cmd.split('  '), stdout=subprocess.PIPE,stderr=subprocess.STDOUT).stdout.readline().decode('utf-8', errors='ignore').strip()}")
        p = subprocess.Popen(copy_file_cmd.split("  "), stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)
        #print(f"Copy file result: {p.stdout.readline().decode('utf-8', errors='ignore').strip()}")

        p = subprocess.Popen(file_exists_cmd.split("  "), stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)

        #print(f"File exists 1 result: {p.stdout.readline().decode('utf-8', errors='ignore').strip()}")

        # execp = subprocess.Popen(exec_cmd.split("  "), stdout=subprocess.PIPE,
        #                     stderr=subprocess.STDOUT)
        #out2 = execp.stdout.readline().decode('utf-8', errors='ignore').strip()
        #print(f"File exec result: {out2}")

        # time.sleep(1)
        # print(scan_cmd)
        p = subprocess.Popen(scan_cmd, stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)

        ret_value = False
        threat_name = "Nothing"

        while(True):

            retcode = p.poll()  # returns None while subprocess is running
            out = p.stdout.readline().decode('utf-8', errors='ignore').strip()
            # out2 += execp.stdout.readline().decode('utf-8', errors='ignore').strip()
            # print(out)
            m = re.search('suspicion', out)
            # n = re.search("A program could not run", out2)
            if m:

                threat_name = out
                logging.debug("Detected")
                ret_value = True

            if retcode == 3:
                logging.debug("Detected")

                ret_value = True
                break

            """
            elif False:
                ret_value = True
                threat_name = execp
                logging.debug("Detected")
                break
            else:
                logging.debug(out2)
            """

            # logging.debug(f"Retcode:{retcode}")

            if retcode is not None:
                break

        os.unlink(tmp_file_name)

        if with_name:
            return ret_value, threat_name

        return ret_value


class VMWareAvast(Scanner):

    def __init__(self):
        self.scanner_path = WDEFENDER_INSTALL_PATH
        self.scanner_name = "Avast"

    """
        Scans a file with Kaspersky and returns True if the file
        is detected as a threat.
    """

    def scan(self, file_path, with_name=False):
        tmp_file_name = tempfile.NamedTemporaryFile().name
        shutil.copyfile(file_path, tmp_file_name)
        file_path = tmp_file_name
        basename = os.path.basename(tmp_file_name)
        vmx_path = config.get_value("avast_vmx")
        passwd = config.get_value("vmware_passwd")
        username = config.get_value("vmware_user")
        copy_file_cmd = f"vmrun  -T  ws  -gu  {username}  -gp  {passwd}  CopyFileFromHostToGuest  {vmx_path}  {tmp_file_name}  C:\\Users\\toto\\Desktop\\{basename}.exe"
        file_exists_cmd = f"vmrun  -T  ws  -gu  {username}  -gp  {passwd}  fileExistsInGuest  {vmx_path}  C:\\Users\\toto\\Desktop\\{basename}.exe"
        exec_cmd = f"vmrun  -T  ws  -gu  {username}  -gp  {passwd}  runProgramInGuest  {vmx_path}  C:\\Users\\toto\\Desktop\\{basename}.exe"
        p = subprocess.Popen(copy_file_cmd.split("  "), stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)

        out = p.stdout.readline().decode('utf-8', errors='ignore').strip()
        logging.debug(out)

        p = subprocess.Popen(exec_cmd.split(
            "  "), stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        out = p.stdout.readline().decode('utf-8', errors='ignore').strip()
        logging.debug(out)
        if re.search("could not run", out):
            return True, "toto"
        logging.debug(file_exists_cmd)
        p = subprocess.Popen(file_exists_cmd.split("  "), stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)

        ret_value = False
        threat_name = "Nothing"
        while True:

            retcode = p.poll()  # returns None while subprocess is running
            out = p.stdout.readline().decode('utf-8', errors='ignore').strip()
            # print(out)
            m = re.search('does not exist', out)

            if m:

                threat_name = out
                ret_value = True

            if len(out) > 0:
                logging.debug(out)

            if retcode is not None:
                break

        os.unlink(tmp_file_name)

        if with_name:
            return ret_value, threat_name

        return ret_value


g_scanner = DockerWindowsDefender()

```

`string_encryptor.py`:

```py
#!/usr/bin/python3

import r2pipe # add dependency to list
import base64
import lief
import keystone
import logging
import sys
import stackprinter
from itertools import cycle


"""
Steps:

1. List XREFS to all strings (done)
2. Insert 3 instructions, with the decrypt_string function already present in the binary.
3. Insert the decrypt_string function in a new section. (done)


OR

2. Replace instruction with a JMP
3. To a new code section with the 3 aforementioned instructions.
4. JMP to return address.

Needs to add a new section statically, at the end of the binary. Either LIEF or radare2.
Needs to compute the JMP destination (+ check 2 MB restrictions :O).
Needs to a PIE code able to decrypt a function O.o
    1. Find strings, replace with Vigenere :D
    2. Write other PIE elf bin that de-Vignere strings (done)
    3. Steal the code section and patch it in the binary in a new code section (done).

Add new section (".toto"): (done)

1. JMP instruction lands here
2. Need to remember the EIP address 
3. Copy original instruction in that section. (done)
4. Replace original instruction by JMP NEAR + offset to new section + offset to instruction
5. JMP to section ".test" O.o absolute jmp is best. (done)
6. Add JMP to ".toto", after function call. (done)
7. JMP to original EIP + 1 (address of step 2). (done)


TODO:

1. Encrypt string in .data section (with vigenere for the PoC). (done)
2. Implement add_jump_table_section (done)

1. Chiffrer automatiquement les strings dans le binaire (easy) (P1) (done)
4. Améliorer le hook pour se rappeler automatiquement l'adresse de retour. (P2) (done)
2. Appliquer l'algo à toutes les strings (done)
3. Check pour pas déchiffrer deux fois la même string dans le cas où elle est employée plusieurs fois. (LP)


TODO:
1. Do not encrypt strings if patch_xref won't handle it.l (done)
"""

# config init
stackprinter.set_excepthook(style='darkbg2') # stacktraces with variables' values
logging.basicConfig(level=logging.INFO)

# constants
BINARY = "bin/simple_test.bin"
STUB = "bin/simple_vigenere.bin"
TRAMPOLINE_SECTION = ".switch"
DECRYPT_SECTION = ".test"
KEY = "MUSIQUE"
SZ_BLK_PER_STRING = 29 # space required to handle 1 string in the switch section

# global variables
g_is_pe = False
ks = keystone.Ks(keystone.KS_ARCH_X86, keystone.KS_MODE_64)

"""
    takes a position-independant function in a given binary
    and copy it.
    @name: function name
    @binary: a binary already parsed with LIEF.
"""
def strip_function(name: str, binary: lief.ELF.Binary):

    address = 0 # offset of the function within the binary
    size = 0 # size of the function

    if binary.format == lief.EXE_FORMATS.ELF:
        symbol = binary.get_static_symbol(name)

        address = symbol.value
        size = symbol.size

    # lief does not appear to be able to locate function by name in PE files.
    elif binary.format == lief.EXE_FORMATS.PE:

        r2 = r2pipe.open(STUB)
        r2.cmd("aaa")
        all_functions = r2.cmdj("aflj")
        matching_functions = []

        for fn in all_functions:

            if name in fn['name']:
                logging.info(f"Found function matching '{name}': {fn}")
                matching_functions += [fn]

        if len(matching_functions) > 1:
            logging.warning(f"More than 1 function found with name {name}. Bug incoming.")

        address = matching_functions[0]['offset']
        size = matching_functions[0]['size']

    else:
        raise Exception("Unsupported file format")

    function_bytes = binary.get_content_from_virtual_address(address, size)
    return function_bytes, address, size

"""
    TODO: bad function name
    TODO: document
    TODO: cleanup
"""
def add_section(original_binary):

    r2 = r2pipe.open(BINARY)
    strings = get_strings(r2)
    nb_strings = len(strings)

    # :(
    if g_is_pe:

        section = original_binary.get_section(".rdata")
        section.characteristics = lief.PE.SECTION_CHARACTERISTICS.MEM_WRITE | lief.PE.SECTION_CHARACTERISTICS.MEM_READ# make the section writable :O


        section = lief.PE.Section(DECRYPT_SECTION)
        section.characteristics = lief.PE.SECTION_CHARACTERISTICS.CNT_CODE | lief.PE.SECTION_CHARACTERISTICS.MEM_READ | lief.PE.SECTION_CHARACTERISTICS.MEM_EXECUTE
        content,_,_   = strip_function("decrypt", lief.parse(STUB))

        section.content = content
        section = original_binary.add_section(section)

        section = lief.PE.Section(TRAMPOLINE_SECTION)
        section.characteristics = lief.PE.SECTION_CHARACTERISTICS.CNT_CODE | lief.PE.SECTION_CHARACTERISTICS.MEM_READ | lief.PE.SECTION_CHARACTERISTICS.MEM_EXECUTE

        section.content = [0x90 for i in range(SZ_BLK_PER_STRING * nb_strings)] # placeholder
        section = original_binary.add_section(section)
        return original_binary, section
    else:

        section = original_binary.get_section(".rodata")
        section += lief.ELF.SECTION_FLAGS.WRITE # make the section writable :O

        section = lief.ELF.Section(DECRYPT_SECTION, lief.ELF.SECTION_TYPES.PROGBITS)
        section += lief.ELF.SECTION_FLAGS.EXECINSTR
        section += lief.ELF.SECTION_FLAGS.WRITE
        content,_,_   = strip_function("decrypt", lief.parse(STUB))

        section.content = content
        section = original_binary.add(section, loaded=True)

        section = lief.ELF.Section(TRAMPOLINE_SECTION, lief.ELF.SECTION_TYPES.PROGBITS)
        section += lief.ELF.SECTION_FLAGS.EXECINSTR
        section += lief.ELF.SECTION_FLAGS.WRITE

        section.content = [0x90 for i in range(SZ_BLK_PER_STRING * nb_strings)] # placeholder # TODO compute in advanced the required size
        section = original_binary.add(section, loaded=True)
        return original_binary, section

def get_instructions_size(current_instructions: str, placeholder_value: list) -> int:

    ins, _ = ks.asm(current_instructions.format(*placeholder_value))
    return len(ins)

def adjust_signedness(offset):

    if type(offset) == int:
        offset = hex(offset)

    sign = '-'
    if offset[0] == '-':

        sign = '+'
        offset = offset[1:]

    return sign + offset


"""
    lea rdi, str.offset1 ; load the string
    mov r12, label1 ; or EIP+len(next_instruction)
    jmp decrypt_section ; absolute jmp # end of decrypt section will jmp on r12
    label1:
    pop rax ; original instruction pointer
    jmp rax

"""
def add_jump_table_section(binary, radare_pipe, string, previous_block_sz, original_instruction):

    proper_assembly = ["push rdi\npush rsi\npush rax\nlea rdi, [rip{}]\n", #offset_to_str, sign to be included
        "mov rsi, {}\n", #str_size
        "lea rax, [rip{}\n", #offset_to_decrypt_section
        "call rax\n",
        "pop rax\npop rsi\npop rdi\n",
        "lea rdi, [rip{}]\n",# offset_to_str2 # assert unused
        "ret"]

    if g_is_pe:
        proper_assembly = ["push rcx\npush rdx\npush rax\nlea rcx, [rip{}]\n", #offset_to_str, sign to be included
        "mov rdx, {}\n", #str_size
        "lea rax, [rip{}\n", #offset_to_decrypt_section
        "call rax\n",
        "pop rax\npop rdx\npop rcx\n",
        "lea rdi, [rip{}]\n",# offset_to_str2 # assert unused TODO cleanup
        "ret"]

    string_offset = string["vaddr"]
    section = binary.get_section(TRAMPOLINE_SECTION)
    binary_base_address = 0

    if g_is_pe:
        binary_base_address = radare_pipe.cmdj("ij")['bin']['baddr']

    new_data_address = binary.get_section(".data").virtual_address
    new_decrypt_address = binary.get_section(DECRYPT_SECTION).virtual_address
    new_text_address = binary.get_section(".text").virtual_address

    # load string in rdi
    offset_to_str = hex(binary_base_address+section.virtual_address-string_offset)
    offset_to_str = adjust_signedness(offset_to_str)
    crt_ins_size = get_instructions_size(proper_assembly[0], [offset_to_str])
    offset_to_str = hex(binary_base_address+section.virtual_address-string_offset+crt_ins_size+previous_block_sz)
    offset_to_str = adjust_signedness(offset_to_str)
    assembly  = proper_assembly[0].format(offset_to_str)

    # load string size
    str_size = string["length"]
    assembly += proper_assembly[1].format(str_size)

    # call decrypt_function
    sections_offset = section.virtual_address - new_decrypt_address
    crt_ins_size = get_instructions_size(assembly + proper_assembly[2], [adjust_signedness(sections_offset)])
    offset_to_decrypt_section = hex(sections_offset + crt_ins_size + previous_block_sz)
    offset_to_decrypt_section = adjust_signedness(offset_to_decrypt_section)
    assembly += proper_assembly[2].format(offset_to_decrypt_section)
    assembly += proper_assembly[3]

    # restore registers
    assembly += proper_assembly[4]

    # load original instruction
    offset_to_str2 = binary_base_address+section.virtual_address-string_offset
    offset_to_str2 += get_instructions_size(assembly+proper_assembly[5], [offset_to_str])
    offset_to_str2 += previous_block_sz
    #assembly += proper_assembly[5].format(hex(offset_to_str2)) # original instruction here
    assert(original_instruction["mnemonic"] == "lea") # TODO: handle more cases
    first_operand = original_instruction["opex"]['operands'][0]

    assert(first_operand["type"] == "reg")
    dest_reg = first_operand["value"]
    assembly += f"lea {dest_reg}, [rip{adjust_signedness(offset_to_str2)}]\n"

    # return to original instructi"]on
    assembly += proper_assembly[-1]
    encoding, _ = ks.asm(assembly)

    current_content = section.content[:previous_block_sz]
    section.content = current_content + encoding

    # write the new binary to disk
    binary.write(BINARY+".patch")
    return len(encoding)

"""
    @key: encryption key :str:
    @string: the string to encrypt

    As a PoC, Vigenere is used :D
"""
def encrypt_string(key, plaintext):

    universe = [c for c in (chr(i) for i in range(32,127) if not i == 92) ]
    uni_len = len(universe)
    ret_txt = ''
    k_len = len(key)

    for i, l in enumerate(plaintext):

        if l not in universe:
            ret_txt += l
        else:
            txt_idx = universe.index(l)

            k = key[i % k_len]
            key_idx = universe.index(k)
            code = universe[(txt_idx + key_idx) % uni_len]
            ret_txt += code

    return ret_txt

def xor(key, message):
    return ''.join(chr(ord(c)^ord(k)) for c,k in zip(message, cycle(key)))

"""
    relies on radare2 to retrieve all the strings
    in a binary.

    \return strings as JSON objects
"""
def get_strings(radare_pipe):

    # list strings in .data section as JSON objects
    radare_pipe.cmd("aaa")
    all_strings = radare_pipe.cmdj("izj")
    return all_strings

"""
    Todo: handle several strings.
"""
def patch_xref(binary, string, radare_pipe, previous_block_sz) -> bool:

    # patch the instruction that originally references the string
    # this allows to decrypt beforehand, so as no to alter the
    # program's behavior.
    xrefs = radare_pipe.cmdj(f"axtj @ {string['vaddr']}")
    original_instruction = None

    # For now, several XREFS to the same strings is an unhandled
    # case, for simplicity.
    if len(xrefs) > 1:

        logging.warning(f"Skipping string \'{string['string']}\' because more than 1 XREF was found")
        return False, original_instruction

    # no xref found
    elif len(xrefs) < 1:
        logging.warning(f"Skipping string \'{string['string']}\' because less than 1 XREF could be found")
        return False, original_instruction

    xref = xrefs[0]

    # corner cases that can't be handled right for now
    if not xref["opcode"].startswith("lea"):

        logging.warning(f"Skipping string \'{string['string']}\'. Unhandle opcode {xref['opcode']}\'")
        return False, original_instruction
    """
    if string["section"] in [".rodata", ".rdata"]:
        logging.warning(f"Skipping string \'{string['string']}\' because it's located in a read-only section.")
        return False, original_instruction
    """

    logging.info(f"Encrypting string \'{base64.b64decode(string['string'])}\'...")
    location = xref["from"]

    # store original instruction infomration
    original_instruction = radare_pipe.cmdj(f"aoj @ {location}")
    switch_address= binary.get_section(TRAMPOLINE_SECTION).virtual_address
    binary_base_address = 0

    # LIEF creates new sections for PE with virtual_address relative to image base.
    if g_is_pe:
        binary_base_address = radare_pipe.cmdj("ij")['bin']['baddr']

    jmp_destination = binary_base_address+switch_address - location + previous_block_sz # displacement between the original instruction and the switch section
    assembly = f"call {hex(jmp_destination)}"
    tmp_encoding, _ = ks.asm(assembly)

    # TODO: clean up below
    res = ""
    for i in tmp_encoding:
        if i < 10:
            res += "0" + str(hex(i))[2:]
        else:
            res += str(hex(i))[2:]

    res += "9090"
    radare_pipe.cmd(f"wx {res} @ {hex(location)}")
    return True, original_instruction

def encrypt_strings(binary):

    r2 = r2pipe.open(BINARY+".patch", flags=["-w"])
    all_strings = get_strings(r2)
    previous_block_sz = 0
    nb_encrypted_strings = 0

    for index, string in enumerate(all_strings):

        decoded_string = base64.b64decode(string["string"])
        binary = lief.parse(BINARY+".patch") # is this needed?

        # hook the binary where the string is referenced. Skip if the string
        # is used several times.
        can_proceed, original_instruction = patch_xref(binary, string, r2, previous_block_sz)

        if not can_proceed:
            continue

        # encrypt the string in .data (or whatever else) section.
        encrypted = encrypt_string(KEY, base64.b64decode(string["string"]).decode()) # convert_encoding(string["type"])
        encoded = base64.b64encode(encrypted.encode()).decode()
        r2.cmd(f"w6d {encoded} @ {string['vaddr']}")

        # prepare the trampoline for the hook.
        # takes care of decrypting the string and resuming the original control flow.
        binary = lief.parse(BINARY+".patch") # is this needed?
        previous_block_sz += add_jump_table_section(binary, r2, string, previous_block_sz, original_instruction[0]) # TODO handle > 1 opcodes
        nb_encrypted_strings += 1

    logging.info(f"Successfully encrypted {nb_encrypted_strings}/{len(all_strings)} strings!")

if __name__ == "__main__":

    if len(sys.argv) > 1:
        BINARY =  sys.argv[1]

    if len(sys.argv) > 2:
        STUB = sys.argv[2]

    logging.info(f"Encrypting strings of {BINARY}")
    logging.info(f"Decryption routine will be copied from {STUB}")

    original_binary = lief.parse(BINARY)

    if original_binary.format == lief.EXE_FORMATS.ELF:
        logging.info("ELF executable detected")

    elif original_binary.format == lief.EXE_FORMATS.PE:
        logging.info("PE Executable detected.")
        g_is_pe = True

    else:
        logging.error("Unrecognized binary")
        exit(1)

    new_binary, section = add_section(original_binary)

    # make a copy of the original binary
    new_binary.write(BINARY+".patch")

    # parse strings references and encrypt
    encrypt_strings(new_binary)

```

`test_find_bad_strings.py`:

```py
#!/usr/bin/python3

import pytest
import unittest.mock
import tempfile
import find_bad_strings as fbs
import hashlib
import os
import shutil
import random

def test_is_all_blacklisted():
    strings_refs = []

    for i in range(100):
        tmp = fbs.StringRef()
        tmp.index = i
        strings_refs += [tmp]

    available_idx = [str_ref.index for str_ref in strings_refs]

    rnd_blacklist = random.choices(available_idx, k=random.randint(0,len(available_idx)//2))

    assert not (fbs.is_all_blacklisted(strings_refs, rnd_blacklist))

    assert fbs.is_all_blacklisted(strings_refs, available_idx)

def test_parse_strings():
    data_blob = """[Strings]
Num Paddr      Vaddr      Len Size Section  Type  String
000 0x00099640 0x18009a240  13  14 (.rdata) ascii kiwi_exec_cmd
001 0x00099650 0x18009a250   4   5 (.rdata) ascii kiwi
002 0x00099658 0x18009a258  27  56 (.rdata) utf16le \nmimikatz(powershell) # %s\n
003 0x00099690 0x18009a290   5  12 (.rdata) utf16le hello
004 0x000996a0 0x18009a2a0  50 102 (.rdata) utf16le ERROR mimikatz_initOrClean ; CoInitializeEx: %08x\n
005 0x00099708 0x18009a308   4  10 (.rdata) utf16le INIT
006 0x00099718 0x18009a318   5  12 (.rdata) utf16le CLEAN
007 0x00099730 0x18009a330  36  74 (.rdata) utf16le >>> %s of '%s' module failed : %08x\n"""
    strings_refs = fbs.parse_strings(data_blob)

    assert len(strings_refs) == 8
    assert strings_refs[-1].index == 7
    assert strings_refs[0].index == 0
    assert strings_refs[7].length == 36

def md5(fname):
    hash_md5 = hashlib.md5()
    with open(fname, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_md5.update(chunk)
    return hash_md5.hexdigest()

def test_patch_binary():
    string = "3122 0x000cef20 0x1800cfb20 23  48   .rdata  utf16le \\pipe\\protected_storage"
    string_ref = fbs.StringRef(3122, 0x000cef20, 0x1800cfb20, 23, 48, ".rdata", "utf16le", "\pipe\protected_storage")
    string_ref.should_mask = True
    index = int(string.split()[0])
    assert string_ref.index == index
    assert string_ref.content == "\pipe\protected_storage"
    md5_before = md5("test_cases/ext_server_kiwi.x64.dll")
    tmp_bin = tempfile.NamedTemporaryFile()
    shutil.copyfile("test_cases/ext_server_kiwi.x64.dll", tmp_bin.name)
    print("tmp file name = " + tmp_bin.name)
    filename = tmp_bin.name
    all_strings_ref = fbs.parse_strings(filename)
    len_strings_before = len(all_strings_ref)

    # replace the string with something else
    fbs.patch_string(filename, string_ref, unmask_only=False)
    all_strings_ref2 = fbs.parse_strings(filename)

    assert(len(all_strings_ref2) == len_strings_before)
    # check that the replacement worked
    assert all_strings_ref2[index].content != string_ref.content
    print(f"Replaced by : {all_strings_ref2[index].content}")

    # check that no other string contains this value (in case offsets are wrong)
    assert not(any(string_ref.content in string.content for string in all_strings_ref2))

    # re-set the string
    string_ref.should_mask = False
    all_strings_ref[index].should_mask = False
    #fbs.patch_string(filename, string_ref, unmask_only=False)
    fbs.patch_string(filename, all_strings_ref[index], unmask_only=False)
    all_strings_ref = fbs.parse_strings(filename)

    # check that the original string was put back
    string = all_strings_ref[index].content
    assert all_strings_ref[index].content == string_ref.content
    new_md5 = md5(filename)

    # check files are the same
    assert md5_before == new_md5
    tmp_bin.close()
    pass


"""
    replace the actual scan with Windows Defender by a
    fake one, so as to check if the bissection algorithm works
    as expected.
"""
def mock_scan(filepath):
    #return True
    all_strings_ref = fbs.parse_strings(filepath)
    known_strings = ['Ask a privilege by its id', 'RUUU', 'CERT_NCRYPT_KEY_HANDLE_TRANSFER_PROP_ID', 'text', 'LocalAlloc', 'viewstack', '0000//...-', 'CERT_SUBJECT_NAME_MD5_HASH_PROP_ID', 'HeapReAlloc', 'Preshutdown service']


    ##return any(s.content in known_strings for s in all_strings_ref)
    for i in all_strings_ref:
        if i.content in known_strings:
            print(f"---> Found bad string {i.content} at index {i.index}, address = {i.paddr}")
            return True
    return False

@unittest.mock.patch("find_bad_strings.scan", side_effect=mock_scan)
@unittest.mock.patch("find_bad_strings.os.chdir")
#@unittest.mock.patch("find_bad_strings.validate_results")
def test_bissection(mock_scan, mock_chdir):
    """known_strings = ["Pass-the-ccache [NT6]",
            "ERROR kuhl_m_crypto_l_certificates ; CryptAcquireCertificatePrivateKey (0x%08x)\\n",
            "ERROR kuhl_m_crypto_l_certificates ; CertGetCertificateContextProperty (0x%08x)\\n",
            "ERROR kuhl_m_crypto_l_certificates ; CertGetNameString (0x%08x)\\n",
            "lsasrv.dll",
            "ERROR kuhl_m_lsadump_sam ; CreateFile (SYSTEM hive) (0x%08x)\\n",
            "SamIFree_SAMPR_USER_INFO_BUFFER",
            "KiwiAndRegistryTools",
            "wdigest.dll",
            "multirdp",
            "logonPasswords",
            "credman",
            "[%x;%x]-%1u-%u-%08x-%wZ@%wZ-%wZ.%s",
            "n.e. (KIWI_MSV1_0_CREDENTIALS KO)"]
    """

    known_strings = ['Ask a privilege by its id', 'RUUU', 'CERT_NCRYPT_KEY_HANDLE_TRANSFER_PROP_ID', 'text', 'LocalAlloc', 'viewstack', '0000//...-', 'CERT_SUBJECT_NAME_MD5_HASH_PROP_ID', 'HeapReAlloc', 'Preshutdown service']

    tmp = tempfile.NamedTemporaryFile()
    shutil.copyfile("test_cases/ext_server_kiwi.x64.dll", tmp.name)

    fbs.ORIGINAL_BINARY = "test_cases/ext_server_kiwi.x64.dll"
    blacklist = fbs.bissect(tmp.name)
    assert len(blacklist) > 0
    all_strings_ref = fbs.parse_strings("test_cases/ext_server_kiwi.x64.dll")

    try:
        for i in blacklist:
            assert all_strings_ref[i].index == i
            assert all_strings_ref[i].content in known_strings

        for str in known_strings:
            assert any(str in x.content for x in all_strings_ref)
        #assert len(blacklist) == len(known_strings)

    except AssertionError:
        print(blacklist)
        for i in blacklist:
            print(list(filter(lambda x: x.index == i, all_strings_ref)))
        raise AssertionError


@pytest.mark.parametrize('list1,list2,output', [
    ([], [1], [1]),
    ([1], [1], [1]),
    ([2,3], [4], [2,3,4]),
    ([2,3,34,3], [1,0,3,1,1,1], [0,1,2,3,34])])
def test_merge_unique(list1, list2, output):
    assert fbs.merge_unique(list1, list2) == output

def test_merge_unique_param_return():
    toto = [1,2,3,4,5,6]
    res = []
    for i in toto:
        res = fbs.merge_unique(res, [i])
    assert res == toto


@pytest.mark.parametrize('list1,list2,output', [
    ([], [1], False),
    ([1], [1], True),
    ([2, 3], [4], False),
    ([2, 3, 34, 3], [1, 0, 3, 1, 1, 1], False),
    ([4,3,2], [2,3,4], True)])
def test_is_equal_unordered(list1, list2, output):
    assert fbs.is_equal_unordered(list1, list2) == output

def test_validate_results():
    all_strings = fbs.get_all_strings("test_cases/ext_server_kiwi.x64.dll")
    all_strings_ref = fbs.parse_strings(all_strings)

    blacklist = [x.index for x in all_strings_ref]

    fbs.validate_results(fbs.BINARY, blacklist, all_strings_ref)

def test_hide_section():
    filepath = os.path.abspath("test_cases/ext_server_kiwi.x64.dll")

    binary = fbs.get_binary(filepath)
    fbs.hide_section(".text", filepath, binary)

```