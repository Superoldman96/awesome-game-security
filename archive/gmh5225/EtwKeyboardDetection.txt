Project Path: arc_gmh5225_EtwKeyboardDetection__a9uadmi

Source Tree:

```txt
arc_gmh5225_EtwKeyboardDetection__a9uadmi
├── EtwKeyboardEmulationDetect
│   ├── EtwKeyboardEmulationDetect.vcxproj
│   ├── EtwKeyboardEmulationDetect.vcxproj.filters
│   ├── EtwKeyboardEmulationDetect.vcxproj.user
│   ├── entry.c
│   ├── etw.c
│   └── etw.h
├── EtwKeyboardEmulationDetect.sln
└── README.md

```

`EtwKeyboardEmulationDetect.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.4.33213.308
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "EtwKeyboardEmulationDetect", "EtwKeyboardEmulationDetect\EtwKeyboardEmulationDetect.vcxproj", "{69E89766-8C82-4E77-83B0-79FDD7871E8A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{69E89766-8C82-4E77-83B0-79FDD7871E8A}.Debug|x64.ActiveCfg = Debug|x64
		{69E89766-8C82-4E77-83B0-79FDD7871E8A}.Debug|x64.Build.0 = Debug|x64
		{69E89766-8C82-4E77-83B0-79FDD7871E8A}.Debug|x86.ActiveCfg = Debug|Win32
		{69E89766-8C82-4E77-83B0-79FDD7871E8A}.Debug|x86.Build.0 = Debug|Win32
		{69E89766-8C82-4E77-83B0-79FDD7871E8A}.Release|x64.ActiveCfg = Release|x64
		{69E89766-8C82-4E77-83B0-79FDD7871E8A}.Release|x64.Build.0 = Release|x64
		{69E89766-8C82-4E77-83B0-79FDD7871E8A}.Release|x86.ActiveCfg = Release|Win32
		{69E89766-8C82-4E77-83B0-79FDD7871E8A}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {45766C72-7B7D-4E28-9CEA-0D9EE0C591F0}
	EndGlobalSection
EndGlobal

```

`EtwKeyboardEmulationDetect/EtwKeyboardEmulationDetect.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{69e89766-8c82-4e77-83b0-79fdd7871e8a}</ProjectGuid>
    <RootNamespace>EtwKeyboardEmulationDetect</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="entry.c" />
    <ClCompile Include="etw.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="etw.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`EtwKeyboardEmulationDetect/EtwKeyboardEmulationDetect.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="entry.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="etw.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="etw.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`EtwKeyboardEmulationDetect/EtwKeyboardEmulationDetect.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`EtwKeyboardEmulationDetect/entry.c`:

```c
#include "etw.h"

ETW_TOKEN token;

UINT32 etwCount;
UINT32 win32Count;
HHOOK keyboardHook;
BOOL active = FALSE;

VOID
EtwCallback(
	__in PEVENT_RECORD Event
)
{
	DWORD size;
	PTRACE_EVENT_INFO trace;
	PWCHAR provider;
	EVENT_PROPERTY_INFO property;
	EVENT_PROPERTY_INFO iProperty;

	trace = GetEventData(Event, &size);

	provider = (PCHAR)trace + trace->ProviderNameOffset;

	for (UINT countIndex = 0;
		countIndex < trace->TopLevelPropertyCount;
		countIndex = countIndex + 1)
	{
		EVENT_PROPERTY_INFO  property = trace->EventPropertyInfoArray[countIndex];

		if (!wcscmp(L"fid_UCX_URB_BULK_OR_INTERRUPT_TRANSFER", (PCHAR)trace + property.NameOffset))
		{

			for (INT propertyIndex = property.structType.StructStartIndex;
				propertyIndex < property.structType.StructStartIndex + property.structType.NumOfStructMembers;
				propertyIndex = propertyIndex + 1)
			{
				iProperty = trace->EventPropertyInfoArray[propertyIndex];

				if (!wcscmp(L"fid_URB_TransferBufferLength", (PCHAR)trace + iProperty.NameOffset))
				{

					//
					//Get value of fid_URB_TransferBufferLength
					//

					LPCWSTR string = GetPropertyData(
						trace,
						Event,
						iProperty,
						20); // index for fid_URB_TransferBufferLength

					if (string == NULL)
					{
						continue;
					}

					//
					// Filter out for only keyboard packets by size
					//

					if (!wcscmp(string, L"0xC"))
					{
						etwCount = etwCount + 1;
					}

					free(string);
				}
			}
		}
	}

	free(trace);
}

LRESULT
Win32Callback(
	__in INT    Code,
	__in WPARAM WParam,
	__in LPARAM LParam
)
{
	KBDLLHOOKSTRUCT* key = (KBDLLHOOKSTRUCT*)LParam;

	//if (key->flags & LLKHF_LOWER_IL_INJECTED || key->flags & LLKHF_INJECTED) {
	//	printf("Simulated keyboard!\n");
	//}

	if (Code >= 0 && WParam == WM_KEYUP)
	{
		if (key->vkCode == VK_F1)
		{
			if (active)
			{
				
				//
				// Each keyboard press has 2 packets. 4 Because up and down
				//

				if (win32Count == (etwCount / 4))
				{
					printf("Not simulated!\n");
				}
				else
				{
					printf("Simulated!\n");
				}
			}
			else
			{
				active = TRUE;
			}

			win32Count = 0;
			etwCount = -4; // Since the packets for F1 will arrive late

			return ERROR_SUCCESS;
		}

		win32Count = win32Count + 1;

	}

	return CallNextHookEx(keyboardHook,
		Code,
		WParam,
		LParam);
}

VOID
main(
)
{
	struct tagMSG msg;
	BOOL status;

	SetupEtwSession(
		L"Zeptaaaaa",
		EtwCallback,
		NULL,
		&token);

	status = StartEtwSessionAsync(&token);

	if (status == FALSE)
	{
		printf("Failed to start etw async seesion!\n");
		return;
	}

	keyboardHook = SetWindowsHookExA(
		WH_KEYBOARD_LL,
		Win32Callback,
		NULL,
		0);

	while (GetMessageA(&msg, 0, 0, 0))
	{
		TranslateMessage(&msg);
		DispatchMessageA(&msg);
	}

}



```

`EtwKeyboardEmulationDetect/etw.c`:

```c
#include "etw.h"

CONST GUID ucx = { 0x36DA592D, 0xE43A, 0x4E28, {0xAF,0x6F, 0x4B, 0xC5, 0x7C, 0x5A, 0x11, 0xE8} };
CONST GUID zepta = { 0x11111011, 0x1345, 0x01bcd, { 0xAA, 0x22, 0x71, 0x00, 0x00, 0x00, 0x00, 0xF3 } };

BOOL
SetupEtwSession(
	__in CONST LPCWSTR Name,
	__in CONST PVOID CallbackRecord,
	__in CONST PVOID CallbackBuffer,
	__inout PETW_TOKEN Token
)
{
	ULONG size;
	ULONG status = 0;
	PVOID buffer;
	PEVENT_TRACE_PROPERTIES properties;

	if (Name == NULL || Token == NULL)
	{
		return FALSE;
	}

	Token->Name = Name;
	Token->Handle = (TRACEHANDLE)INVALID_HANDLE_VALUE;
	Token->SetupHandle = (TRACEHANDLE)INVALID_HANDLE_VALUE;

	Token->CallbackRecord = CallbackRecord;
	Token->CallbackBuffer = CallbackBuffer;
	Token->Thread = NULL;
	Token->Active = false;

	size = sizeof(EVENT_TRACE_PROPERTIES) + (wcslen(Token->Name) + 1) * sizeof(Token->Name[0]);
	buffer = malloc(size);

	if (buffer == NULL)
	{
		return FALSE;
	}

	RtlZeroMemory(buffer, size);

	properties = (PEVENT_TRACE_PROPERTIES)buffer;

	properties->Wnode.BufferSize = size;
	properties->Wnode.Guid = zepta;
	properties->Wnode.ClientContext = 1;
	properties->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
	properties->LogFileMode = EVENT_TRACE_REAL_TIME_MODE;
	properties->FlushTimer = 1;
	properties->LogFileNameOffset = 0;
	properties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
	properties->EnableFlags = 0;

	status = StartTraceW(
		&Token->SetupHandle,
		Token->Name,
		properties);

	if (status != ERROR_SUCCESS &&
		status != ERROR_ALREADY_EXISTS)
	{
		printf("Error on StartTraceW. Code: %x\n", status);
		return FALSE;
	}
	
	status = EnableTraceEx2(
		Token->SetupHandle,
		&ucx,
		EVENT_CONTROL_CODE_ENABLE_PROVIDER,
		TRACE_LEVEL_VERBOSE,
		0,
		0,
		0,
		NULL);

	if (status != ERROR_SUCCESS && status != ERROR_INVALID_PARAMETER)
	{
		printf("Error on EnableTraceEx2. Code: %x\n", status);
		return FALSE;
	}

	return TRUE;
}

BOOL
StartEtwSession(
	__inout PETW_TOKEN Token
)
{
	ULONG status;
	EVENT_TRACE_LOGFILE trace;

	if (Token == NULL ||
		Token->SetupHandle == (TRACEHANDLE)INVALID_HANDLE_VALUE ||
		Token->Active == TRUE)
	{
		return FALSE;
	}

	ZeroMemory(&trace, sizeof(EVENT_TRACE_LOGFILE));

	trace.LoggerName = (LPWSTR)Token->Name;
	trace.LogFileName = NULL;
	trace.EventRecordCallback = (PEVENT_RECORD_CALLBACK)Token->CallbackRecord;
	trace.BufferCallback = (PEVENT_TRACE_BUFFER_CALLBACKW)Token->CallbackBuffer;
	trace.ProcessTraceMode = PROCESS_TRACE_MODE_EVENT_RECORD | PROCESS_TRACE_MODE_REAL_TIME;

	Token->Handle = OpenTraceW(&trace);

	if (INVALID_PROCESSTRACE_HANDLE == Token->Handle)
	{
		printf("Error on OpenTraceW. Code: %x\n", GetLastError());
		CloseTrace(Token->Handle);
		return FALSE;
	}

	Token->Active = TRUE;

	status = ProcessTrace(
		&Token->Handle,
		1,
		NULL,
		NULL);

	if (status != ERROR_SUCCESS && status != ERROR_CANCELLED)
	{
		printf("Error on ProcessTrace. Code: %x\n", status);
		CloseTrace(Token->Handle);
		return FALSE;
	}

	return TRUE;
}

BOOL
StartEtwSessionAsync(
	__inout PETW_TOKEN Token
)
{
	Token->Thread = CreateThread(
		NULL,
		0,
		(LPTHREAD_START_ROUTINE)StartEtwSession,
		Token,
		0,
		NULL);

	return Token->Thread ? TRUE : FALSE;
}

BOOL
StopEtwSession(
	__inout PETW_TOKEN Token
)
{
	if (Token == NULL ||
		Token->Active == FALSE ||
		Token->Handle == INVALID_PROCESSTRACE_HANDLE)
	{
		return FALSE;
	}

	CloseTrace(Token->Handle);

	if (Token->Thread)
	{
		WaitForSingleObject(Token->Thread, INFINITE);
	}

	return TRUE;
}

PTRACE_EVENT_INFO
GetEventData(
	__in PEVENT_RECORD Event,
	__inout PDWORD Osize
)
{
	ULONG status;
	ULONG size = 0;
	PCHAR buffer = NULL;

	if (Event == NULL)
	{
		return NULL;
	}

	status = TdhGetEventInformation(
		Event,
		0,
		NULL,
		NULL,
		&size);

	if (status == ERROR_INSUFFICIENT_BUFFER)
	{
		buffer = (PCHAR)calloc(size, sizeof(PCHAR));

		status = TdhGetEventInformation(
			Event,
			0,
			NULL,
			(PTRACE_EVENT_INFO)buffer,
			&size);

		if (status != ERROR_SUCCESS)
		{
			return NULL;
		}
	}

	*Osize = size;
	return (PTRACE_EVENT_INFO)buffer;
}

//
// Not my proudest moment.
//
LPCWSTR
GetPropertyData(
	__in PTRACE_EVENT_INFO Trace,
	__in PEVENT_RECORD Event,
	__in EVENT_PROPERTY_INFO Prop,
	__in UINT Index
)
{
	ULONG size = 5;
	PVOID buffer = 0;
	ULONG used = 0;
	USHORT sizeFormat;
	ULONG status;

	INT i = 0;
	while (TRUE)
	{
		if (buffer)
		{
			free(buffer);
			buffer = malloc(size);
		}
		else
		{
			buffer = malloc(size);
		}

		status = TdhFormatProperty(
			Trace,
			NULL,
			8,
			Prop.nonStructType.InType,
			Prop.nonStructType.OutType,
			4,
			(USHORT)((PCHAR)Event->UserData + used + Event->UserDataLength) - Event->UserDataLength,
			(PBYTE)((PBYTE)Event->UserData + used),
			&size,
			(PWCHAR)buffer,
			&sizeFormat);

		if (status == ERROR_INSUFFICIENT_BUFFER)
		{
			size = size * 2;
			continue;
		}

		if (status == ERROR_SUCCESS)
		{
			i = i + 1;
			if (i == Index)
			{
				return (LPCWSTR)buffer;
			}
			used += sizeFormat;

		}

		if (used > Event->UserDataLength)
		{
			free(buffer);
			break;
		}

		if (status != ERROR_SUCCESS)
		{
			free(buffer);
			break;
		}
	}
	return NULL;
}

```

`EtwKeyboardEmulationDetect/etw.h`:

```h
#pragma once
#include <Windows.h>
#include <evntrace.h>
#include <evntcons.h>
#include <stdbool.h>
#include <stdio.h>
#include <tdh.h>
#include <wchar.h>
#include <stdlib.h> 
#pragma comment(lib, "tdh.lib")

typedef struct _ETW_TOKEN
{
	LPCWSTR Name;
	TRACEHANDLE SetupHandle;
	TRACEHANDLE Handle;
	PVOID CallbackRecord;
	PVOID CallbackBuffer;
	HANDLE Thread;
	BOOL Active;
} ETW_TOKEN, * PETW_TOKEN;

//
// Etw session
//

BOOL
SetupEtwSession(
	__in CONST LPCWSTR Name,
	__in CONST PVOID CallbackRecord,
	__in CONST PVOID CallbackBuffer,
	__inout PETW_TOKEN Token
);

BOOL
StartEtwSession(
	__inout PETW_TOKEN Token
);

BOOL
StartEtwSessionAsync(
	__inout PETW_TOKEN Token
);

BOOL
StopEtwSession(
	__inout PETW_TOKEN Token
);

//
// Etw event parse
//

PTRACE_EVENT_INFO
GetEventData(
	__in PEVENT_RECORD Event,
	__inout PDWORD Osize
);

LPCWSTR
GetPropertyData(
	__in PTRACE_EVENT_INFO Trace,
	__in PEVENT_RECORD Event,
	__in EVENT_PROPERTY_INFO Prop,
	__in UINT Index
);


```

`README.md`:

```md
Detects emulated keyboard presses like keyboard service callback and keybd_event from usermode.
If you have reversed any Windows USB driver you will notice a lot of Etw logging. This is essentially abusing this fact.

This does not work for all keyboards since this only checks ETW logs from UCX. More logs have to be gathers for it to
work on all keyboards.

```