Project Path: arc_gmh5225_EAC_dbp_yue43ky4

Source Tree:

```txt
arc_gmh5225_EAC_dbp_yue43ky4
├── EAC_Bypass
│   ├── EAC_Bypass.inf
│   ├── EAC_Bypass.vcxproj
│   ├── EAC_Bypass.vcxproj.filters
│   ├── EAC_Bypass.vcxproj.user
│   ├── Main.c
│   ├── Main.hpp
│   ├── Options.hpp
│   ├── common.h
│   ├── ntos.h
│   ├── ntos.hpp
│   └── ntstructs.hpp
├── EAC_Bypass.sln
├── EAC_Usermode
│   ├── EAC.cpp
│   ├── EAC.hpp
│   ├── EAC_Usermode.vcxproj
│   ├── EAC_Usermode.vcxproj.filters
│   ├── EAC_Usermode.vcxproj.user
│   ├── Options.hpp
│   ├── detours.h
│   └── main.cpp
├── LICENSE
└── README.md

```

`EAC_Bypass.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29009.5
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "EAC_Bypass", "EAC_Bypass\EAC_Bypass.vcxproj", "{2BA794F5-5FFA-454A-A1FC-D739771C6F72}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "EAC_Usermode", "EAC_Usermode\EAC_Usermode.vcxproj", "{56F38C3E-FC80-4028-B6E9-4688A33E4AEB}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {4A0C5232-FCF5-4CA3-A672-9A0BAF764A19}
	EndGlobalSection
EndGlobal

```

`EAC_Bypass/EAC_Bypass.inf`:

```inf
;
; EAC_Bypass.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=EAC_Bypass.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
EAC_Bypass_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
EAC_Bypass.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%EAC_Bypass.DeviceDesc%=EAC_Bypass_Device, Root\EAC_Bypass ; TODO: edit hw-id

[EAC_Bypass_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
EAC_Bypass.sys

;-------------- Service installation
[EAC_Bypass_Device.NT.Services]
AddService = EAC_Bypass,%SPSVCINST_ASSOCSERVICE%, EAC_Bypass_Service_Inst

; -------------- EAC_Bypass driver install sections
[EAC_Bypass_Service_Inst]
DisplayName    = %EAC_Bypass.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\EAC_Bypass.sys

;
;--- EAC_Bypass_Device Coinstaller installation ------
;

[EAC_Bypass_Device.NT.CoInstallers]
AddReg=EAC_Bypass_Device_CoInstaller_AddReg
CopyFiles=EAC_Bypass_Device_CoInstaller_CopyFiles

[EAC_Bypass_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[EAC_Bypass_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[EAC_Bypass_Device.NT.Wdf]
KmdfService =  EAC_Bypass, EAC_Bypass_wdfsect
[EAC_Bypass_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "EAC_Bypass Installation Disk"
EAC_Bypass.DeviceDesc = "EAC_Bypass Device"
EAC_Bypass.SVCDESC = "EAC_Bypass Service"

```

`EAC_Bypass/EAC_Bypass.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{2BA794F5-5FFA-454A-A1FC-D739771C6F72}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>EAC_Bypass</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>
    </TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
    <TimeStampServer>http://timestamp.globalsign.com/scripts/timstamp.dll</TimeStampServer>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <GenerateMapFile>true</GenerateMapFile>
      <AdditionalDependencies>VirtualizerDDK64.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ProgramDatabaseFile />
      <Profile>false</Profile>
    </Link>
    <ClCompile>
      <DebugInformationFormat>None</DebugInformationFormat>
      <TreatWarningAsError>false</TreatWarningAsError>
      <BufferSecurityCheck>true</BufferSecurityCheck>
      <AdditionalOptions>/pdbpath:none %(AdditionalOptions)</AdditionalOptions>
      <FunctionLevelLinking>false</FunctionLevelLinking>
      <StringPooling>false</StringPooling>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="EAC_Bypass.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Main.hpp" />
    <ClInclude Include="ntos.hpp" />
    <ClInclude Include="ntstructs.hpp" />
    <ClInclude Include="Options.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`EAC_Bypass/EAC_Bypass.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
    <Filter Include="Header Files\OS">
      <UniqueIdentifier>{daa8f17e-d414-4954-a19d-8800baded80d}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="EAC_Bypass.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Main.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ntstructs.hpp">
      <Filter>Header Files\OS</Filter>
    </ClInclude>
    <ClInclude Include="ntos.hpp">
      <Filter>Header Files\OS</Filter>
    </ClInclude>
    <ClInclude Include="Options.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`EAC_Bypass/EAC_Bypass.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>ProductionSign</SignMode>
    <ProductionCertificate>CN=上海渤窿投资管理有限公司, O=上海渤窿投资管理有限公司, L=shanghai, S=shanghai, C=CN | A29E53F93B6BB31BC26997449DBDE4E218217CB4</ProductionCertificate>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`EAC_Bypass/Main.c`:

```c
#include "main.hpp"
#include "Options.hpp"

#pragma region CallBacks
OB_PREOP_CALLBACK_STATUS ProcessObjectPreCallback(PVOID RegistrationContext, POB_PRE_OPERATION_INFORMATION OperationInformation)
{
	UNREFERENCED_PARAMETER(RegistrationContext);
	VirtualizerStart();
	VirtualizerStrEncryptStart();
#if (PROTECT_PROCESS == 1)
	if (OperationInformation && MmIsAddressValid(OperationInformation))
	{
		HANDLE pid = PsGetProcessId((PEPROCESS)OperationInformation->Object);
		if (pid && pid == (HANDLE)ProcessIdToProtect)
		{
			if (OperationInformation->Operation == OB_OPERATION_HANDLE_CREATE ||
				OperationInformation->Operation == OB_OPERATION_HANDLE_DUPLICATE)
			{
				if ((OperationInformation->Parameters->CreateHandleInformation.OriginalDesiredAccess & PROCESS_TERMINATE) == PROCESS_TERMINATE)
				{
					OperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= ~PROCESS_TERMINATE;
				}
				if ((OperationInformation->Parameters->CreateHandleInformation.OriginalDesiredAccess & PROCESS_VM_OPERATION) == PROCESS_VM_OPERATION)
				{
					OperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= ~PROCESS_VM_OPERATION;
				}
				if ((OperationInformation->Parameters->CreateHandleInformation.OriginalDesiredAccess & PROCESS_VM_READ) == PROCESS_VM_READ)
				{
					OperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= ~PROCESS_VM_READ;
				}
				if ((OperationInformation->Parameters->CreateHandleInformation.OriginalDesiredAccess & PROCESS_VM_WRITE) == PROCESS_VM_WRITE)
				{
					OperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= ~PROCESS_VM_WRITE;
				}
			}
		}
	}
#endif
	VirtualizerStrEncryptEnd();
	VirtualizerEnd();
	if (PsGetCurrentProcessId() == 4)
	{
		POB_PRE_OPERATION_CALLBACK EACCallBack = (POB_PRE_OPERATION_CALLBACK)ProcessPreOperation;
		EACCallBack(RegistrationContext, OperationInformation);
	}
	if (PsGetCurrentProcessId() == pGameId)
	{
		POB_PRE_OPERATION_CALLBACK EACCallBack = (POB_PRE_OPERATION_CALLBACK)ProcessPreOperation;
		EACCallBack(RegistrationContext, OperationInformation);
	}
	return(OB_PREOP_SUCCESS);
}

VOID ProcessObjectPostCallback(PVOID RegistrationContext, POB_POST_OPERATION_INFORMATION OperationInformation)
{
	if (PsGetCurrentProcessId() == 4)
	{
		POB_POST_OPERATION_CALLBACK EACCallBack = (POB_POST_OPERATION_CALLBACK)ProcessPostOperation;
		EACCallBack(RegistrationContext, OperationInformation);
	}
	if (PsGetCurrentProcessId() == pGameId)
	{
		POB_POST_OPERATION_CALLBACK EACCallBack = (POB_POST_OPERATION_CALLBACK)ProcessPostOperation;
		EACCallBack(RegistrationContext, OperationInformation);
	}
	return;
}

OB_PREOP_CALLBACK_STATUS ThreadObjectPreCallback(PVOID RegistrationContext, POB_PRE_OPERATION_INFORMATION OperationInformation)
{
	if (PsGetCurrentProcessId() == 4)
	{
		POB_PRE_OPERATION_CALLBACK EACCallBack = (POB_PRE_OPERATION_CALLBACK)ThreadPreOperation;
		EACCallBack(RegistrationContext, OperationInformation);
	}
	
	return(OB_PREOP_SUCCESS);
}

VOID ThreadObjectPostCallback(PVOID RegistrationContext, POB_POST_OPERATION_INFORMATION OperationInformation)
{
	if (PsGetCurrentProcessId() == 4)
	{
		POB_POST_OPERATION_CALLBACK EACCallBack = (POB_POST_OPERATION_CALLBACK)ThreadPostOperation;
		EACCallBack(RegistrationContext, OperationInformation);
	}
	return;
}

// credits for this function and the offsets goes to https://www.write-bug.com/article/2503.html
BOOLEAN RemoveMiniFilter()
{
#if (REMOVE_FILTER == 1)
	VirtualizerStart();
	VirtualizerStrEncryptStart();
	NTSTATUS status = STATUS_SUCCESS;
	ULONG ulFilterListSize = 0;
	PFLT_FILTER* ppFilterList = NULL;
	ULONG i = 0;
	PFLT_OPERATION_REGISTRATION pFltOperationRegistration = NULL;
	FltEnumerateFilters(NULL, 0, &ulFilterListSize);
	ppFilterList = (PFLT_FILTER*)ExAllocatePool(NonPagedPool, ulFilterListSize * sizeof(PFLT_FILTER));
	if (NULL == ppFilterList)
	{
		DbgPrint("[EAC_Bypass] ExAllocatePool Error!\n");
		return FALSE;
	}
	status = FltEnumerateFilters(ppFilterList, ulFilterListSize, &ulFilterListSize);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("[EAC_Bypass] FltEnumerateFilters Error![0x%X]\n", status);
		return FALSE;
	}
	DbgPrint("[EAC_Bypass] ulFilterListSize=%d\n", ulFilterListSize);
	if (lOperationsOffset == 0)
	{
		DbgPrint("[EAC_Bypass] GetOperationsOffset Error\n");
		return FALSE;
	}
	try
	{
		for (i = 0; i < ulFilterListSize; i++)
		{
			pFltOperationRegistration = (PFLT_OPERATION_REGISTRATION)(*(PVOID*)((PUCHAR)ppFilterList[i] + lOperationsOffset));
			try
			{
				while (IRP_MJ_OPERATION_END != pFltOperationRegistration->MajorFunction)
				{
					if (MmIsAddressValid(pFltOperationRegistration->PreOperation) &&
						IsFromEACRange(pFltOperationRegistration->PreOperation))
					{
						FilterAddr = pFltOperationRegistration->PreOperation;
						pFltOperationRegistration->PreOperation = DummyObjectPreCallback;
						DbgPrint("[EAC_Bypass] BE Filter found 0x%llX", FilterAddr);
						break;
					}
					pFltOperationRegistration = (PFLT_OPERATION_REGISTRATION)((PUCHAR)pFltOperationRegistration + sizeof(FLT_OPERATION_REGISTRATION));
				}
			}
			__except (EXCEPTION_EXECUTE_HANDLER)
			{
				DbgPrint("[EAC_Bypass] Exception [0x%X] in RemoveMiniFilter", GetExceptionCode());
			}
			FltObjectDereference(ppFilterList[i]);
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		DbgPrint("[EAC_Bypass] Exception [0x%X] in RemoveMiniFilter", GetExceptionCode());
	}
	VirtualizerStrEncryptEnd();
	VirtualizerEnd();
	ExFreePool(ppFilterList);
	ppFilterList = NULL;
#endif
	return TRUE;
}

BOOLEAN RestoreMiniFilter()
{
#if (REMOVE_FILTER == 1)
	NTSTATUS status = STATUS_SUCCESS;
	ULONG ulFilterListSize = 0;
	PFLT_FILTER* ppFilterList = NULL;
	ULONG i = 0;
	PFLT_OPERATION_REGISTRATION pFltOperationRegistration = NULL;
	try
	{
		VirtualizerStart();
		VirtualizerStrEncryptStart();
		FltEnumerateFilters(NULL, 0, &ulFilterListSize);
		ppFilterList = (PFLT_FILTER*)ExAllocatePool(NonPagedPool, ulFilterListSize * sizeof(PFLT_FILTER));
		if (NULL == ppFilterList)
		{
			DbgPrint("[EAC_Bypass] ExAllocatePool Error!\n");
			return FALSE;
		}
		status = FltEnumerateFilters(ppFilterList, ulFilterListSize, &ulFilterListSize);
		if (!NT_SUCCESS(status))
		{
			DbgPrint("[EAC_Bypass] FltEnumerateFilters Error![0x%X]\n", status);
			return FALSE;
		}
		DbgPrint("[EAC_Bypass] ulFilterListSize=%d\n", ulFilterListSize);
		if (lOperationsOffset == 0)
		{
			DbgPrint("[EAC_Bypass] GetOperationsOffset Error\n");
			return FALSE;
		}
		for (i = 0; i < ulFilterListSize; i++)
		{
			pFltOperationRegistration = (PFLT_OPERATION_REGISTRATION)(*(PVOID*)((PUCHAR)ppFilterList[i] + lOperationsOffset));
			try
			{
				while (IRP_MJ_OPERATION_END != pFltOperationRegistration->MajorFunction)
				{
					if (pFltOperationRegistration->PreOperation == DummyObjectPreCallback)
					{
						pFltOperationRegistration->PreOperation = pFltOperationRegistration->PreOperation;
						DbgPrint("[EAC_Bypass] EAC Filter restored");
					}
					pFltOperationRegistration = (PFLT_OPERATION_REGISTRATION)((PUCHAR)pFltOperationRegistration + sizeof(FLT_OPERATION_REGISTRATION));
				}
			}
			__except (EXCEPTION_EXECUTE_HANDLER)
			{
				DbgPrint("[EAC_Bypass] Exception [0x%X] in RemoveMiniFilter", GetExceptionCode());
			}
			FltObjectDereference(ppFilterList[i]);
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		DbgPrint("[EAC_Bypass] Exception [0x%X] in RemoveMiniFilter", GetExceptionCode());
	}
	VirtualizerStrEncryptEnd();
	VirtualizerEnd();

	ExFreePool(ppFilterList);
	ppFilterList = NULL;
#endif
	return TRUE;
}

BOOLEAN Do_Bypass()
{
	PLIST_ENTRY FirstEntry = 0;
	PLIST_ENTRY pEntry = 0;;
	__try
	{
		VirtualizerStart();
		VirtualizerStrEncryptStart();
#if (REMOVE_PROCESSCALLBACKS == 1)
		if (ProcessPostOperation || ProcessPreOperation)
			return TRUE;
#if (SUSPEND_EAC == 1)
		if (!NT_SUCCESS(SuspendOrResumeAllThreads(1)))
		{
			DbgPrint("[EAC_Bypass] SuspendOrResumeAllThreads failed.");
			return FALSE;
		}
#endif
		FirstEntry = (PLIST_ENTRY)((uintptr_t)* PsProcessType + 0xC8);
		pEntry = FirstEntry;
		while (pEntry != NULL || pEntry != FirstEntry)
		{
			CALLBACK_ENTRY_ITEM* curCallback = (CALLBACK_ENTRY_ITEM*)pEntry;
			if (!MmIsAddressValid(pEntry))
				break;
			if (IsFromEACRange((PVOID)curCallback->PostOperation) ||
				IsFromEACRange((PVOID)curCallback->PreOperation))
			{
				ProcessPostOperation = (PVOID)curCallback->PostOperation;
				ProcessPreOperation = (PVOID)curCallback->PreOperation;
				curCallback->PostOperation = (POB_POST_OPERATION_CALLBACK)ProcessObjectPostCallback;
				curCallback->PreOperation = (POB_PRE_OPERATION_CALLBACK)ProcessObjectPreCallback;
				break;
			}
			pEntry = pEntry->Flink;
			if (pEntry == FirstEntry || pEntry == 0 || !MmIsAddressValid(pEntry) || !MmIsAddressValid(pEntry)) break;
		}
#endif
#if (REMOVE_THREADCALLBACKS == 1)
		FirstEntry = (PLIST_ENTRY)((uintptr_t)* PsThreadType + 0xC8);
		pEntry = FirstEntry;
		while (pEntry != NULL || pEntry != FirstEntry)
		{
			CALLBACK_ENTRY_ITEM* curCallback = (CALLBACK_ENTRY_ITEM*)pEntry;
			if (!MmIsAddressValid(pEntry))
				break;
			if (IsFromEACRange((PVOID)curCallback->PostOperation) ||
				IsFromEACRange((PVOID)curCallback->PreOperation))
			{
				ThreadPostOperation = (PVOID)curCallback->PostOperation;
				ThreadPreOperation = (PVOID)curCallback->PreOperation;
				curCallback->PostOperation = (POB_POST_OPERATION_CALLBACK)ThreadObjectPostCallback;
				curCallback->PreOperation = (POB_PRE_OPERATION_CALLBACK)ThreadObjectPreCallback;
				break;
			}
			pEntry = pEntry->Flink;
			if (pEntry == FirstEntry || pEntry == 0 || !MmIsAddressValid(pEntry) || !MmIsAddressValid(pEntry)) break;
		}
#endif
		VirtualizerStrEncryptEnd();
		VirtualizerEnd();
	}
	except(EXCEPTION_EXECUTE_HANDLER)
	{
		VirtualizerStrEncryptStart();
		DbgPrint("[EAC_Bypass] Exception [0x%X] in Do_Bypass", GetExceptionCode());
		VirtualizerStrEncryptEnd();
		return FALSE;
	}
	return TRUE;
}

BOOLEAN Remove_Bypass()
{
	PLIST_ENTRY FirstEntry = 0;
	PLIST_ENTRY pEntry = 0;
	__try
	{
		VirtualizerStart();
		VirtualizerStrEncryptStart();
#if (REMOVE_PROCESSCALLBACKS == 1)
		FirstEntry = (PLIST_ENTRY)((uintptr_t)* PsProcessType + 0xC8);
		pEntry = FirstEntry;
		while (pEntry != NULL || pEntry != FirstEntry)
		{
			CALLBACK_ENTRY_ITEM* curCallback = (CALLBACK_ENTRY_ITEM*)pEntry;
			if (!MmIsAddressValid(pEntry))
				break;
			if (curCallback->PostOperation == ProcessObjectPostCallback ||
				curCallback->PreOperation == ProcessObjectPreCallback)
			{
				curCallback->PostOperation = (POB_POST_OPERATION_CALLBACK)ProcessPostOperation;
				curCallback->PreOperation = (POB_PRE_OPERATION_CALLBACK)ProcessPreOperation;
				ProcessPostOperation = 0;
				ProcessPreOperation = 0;
				break;
			}
			pEntry = pEntry->Flink;
			if (pEntry == FirstEntry || pEntry == 0 || !MmIsAddressValid(pEntry)) break;
		}
#endif
#if (REMOVE_THREADCALLBACKS == 1)
		FirstEntry = (PLIST_ENTRY)((uintptr_t)* PsThreadType + 0xC8);
		pEntry = FirstEntry;
		while (pEntry != NULL || pEntry != FirstEntry)
		{
			CALLBACK_ENTRY_ITEM* curCallback = (CALLBACK_ENTRY_ITEM*)pEntry;
			if (!MmIsAddressValid(pEntry))
				break;
			if (curCallback->PostOperation == ThreadObjectPostCallback ||
				curCallback->PreOperation == ThreadObjectPreCallback)
			{
				curCallback->PostOperation = (POB_POST_OPERATION_CALLBACK)ThreadPostOperation;
				curCallback->PreOperation = (POB_PRE_OPERATION_CALLBACK)ThreadPreOperation;
				ThreadPostOperation = 0;
				ThreadPreOperation = 0;
				break;
			}
			pEntry = pEntry->Flink;
			if (pEntry == FirstEntry || pEntry == 0 || !MmIsAddressValid(pEntry)) break;
		}
#endif
#if (SUSPEND_EAC == 1)
		if (!NT_SUCCESS(SuspendOrResumeAllThreads(0)))
		{
			DbgPrint("[EAC_Bypass] SuspendOrResumeAllThreads failed.");
			return FALSE;
		}
#endif
		VirtualizerStrEncryptEnd();
		VirtualizerEnd();
	}
	except(EXCEPTION_EXECUTE_HANDLER)
	{
		VirtualizerStrEncryptStart();
		DbgPrint("[EAC_Bypass] Exception [0x%X] in Remove_Bypass", GetExceptionCode());
		VirtualizerStrEncryptEnd();
		return FALSE;
	}
	return TRUE;
}

BOOLEAN FuckImageCallBack()
{
#if (REMOVE_IMAGEROUTINE == 1)
	__try
	{
		VirtualizerStart();
		VirtualizerStrEncryptStart();
		ULONG64	NotifyAddr = 0, MagicPtr = 0;
		ULONG64	PspLoadImageNotifyRoutine = (ULONG64)ImageCallBacks;
		for (int i = 0; i < 64; i++)
		{
			MagicPtr = PspLoadImageNotifyRoutine + i * 8;
			NotifyAddr = *(PULONG64)(MagicPtr);
			if (MmIsAddressValid((PVOID)NotifyAddr) && NotifyAddr != 0)
			{
				NotifyAddr = *(PULONG64)(NotifyAddr & 0xfffffffffffffff8);
				if (IsFromEACRange((PVOID)NotifyAddr))
				{
					DbgPrint("[EAC_Bypass] EAC found in ImageCallBacks");
					EAC_ImageRoutine = (PVOID)NotifyAddr;
					if (!NT_SUCCESS(PsRemoveLoadImageNotifyRoutine((PLOAD_IMAGE_NOTIFY_ROUTINE)NotifyAddr)))
						DbgPrint("[EAC_Bypass] PsRemoveLoadImageNotifyRoutine failed");
					else
					{
						DbgPrint("[EAC_Bypass] ImageCallBack has been removed");
						return TRUE;
					}
				}
			}
		}
		VirtualizerStrEncryptEnd();
		VirtualizerEnd();
	}
	except(EXCEPTION_EXECUTE_HANDLER)
	{
		VirtualizerStrEncryptStart();
		DbgPrint("[EAC_Bypass] Exception [0x%X] in FuckImageCallBack", GetExceptionCode());
		VirtualizerStrEncryptEnd();
		return FALSE;
	}
#endif
	return FALSE;
}

BOOLEAN FuckThreadCallBack()
{
#if (REMOVE_THREADROUTINE == 1)
	__try
	{
		VirtualizerStart();
		VirtualizerStrEncryptStart();
		ULONG64	NotifyAddr = 0, MagicPtr = 0;
		ULONG64	PspCreateThreadNotifyRoutine = (ULONG64)ThreadCallBacks;
		for (int i = 0; i < 64; i++)
		{
			MagicPtr = PspCreateThreadNotifyRoutine + i * 8;
			NotifyAddr = *(PULONG64)(MagicPtr);
			if (MmIsAddressValid((PVOID)NotifyAddr) && NotifyAddr != 0)
			{
				NotifyAddr = *(PULONG64)(NotifyAddr & 0xfffffffffffffff8);
				if (IsFromEACRange((PVOID)NotifyAddr))
				{
					DbgPrint("[EAC_Bypass] EAC found in ThreadCallBacks");
					EAC_ThreadRoutine = (PVOID)NotifyAddr;
					if (!NT_SUCCESS(PsRemoveCreateThreadNotifyRoutine((PCREATE_THREAD_NOTIFY_ROUTINE)NotifyAddr)))
						DbgPrint("[EAC_Bypass] PsRemoveCreateThreadNotifyRoutine failed");
					else
					{
						DbgPrint("[EAC_Bypass] ThreadCallBack has been removed");
						return TRUE;
					}
				}
			}
		}
		VirtualizerStrEncryptEnd();
		VirtualizerEnd();
	}
	except(EXCEPTION_EXECUTE_HANDLER)
	{
		VirtualizerStrEncryptStart();
		DbgPrint("[EAC_Bypass] Exception [0x%X] in FuckThreadCallBack", GetExceptionCode());
		VirtualizerStrEncryptEnd();
		return FALSE;
	}
#endif

	return FALSE;
}

BOOLEAN RestoreImageCallBack()
{
	VirtualizerStart();
	VirtualizerStrEncryptStart();
#if (REMOVE_IMAGEROUTINE == 1)
	if (!MmIsAddressValid((PVOID)EAC_ImageRoutine) ||
		!NT_SUCCESS(PsSetLoadImageNotifyRoutine((PLOAD_IMAGE_NOTIFY_ROUTINE)EAC_ImageRoutine)))
		DbgPrint("[EAC_Bypass] WARNING : PsSetLoadImageNotifyRoutine failed");
	else
	{
		DbgPrint("[EAC_Bypass] ImageCallBack has been restored");
		return TRUE;
	}
#endif
	VirtualizerStrEncryptEnd();
	VirtualizerEnd();
	return FALSE;
}

BOOLEAN RestoreThreadCallBack()
{
	VirtualizerStart();
	VirtualizerStrEncryptStart();
#if (REMOVE_THREADROUTINE == 1)
	if (!MmIsAddressValid((PVOID)EAC_ThreadRoutine) ||
		!NT_SUCCESS(PsSetCreateThreadNotifyRoutine((PCREATE_THREAD_NOTIFY_ROUTINE)EAC_ThreadRoutine)))
		DbgPrint("[EAC_Bypass] WARNING : PsSetCreateThreadNotifyRoutine failed");
	else
	{
		DbgPrint("[EAC_Bypass] ThreadCallBack has been restored");
		return TRUE;
	}
#endif
	VirtualizerStrEncryptEnd();
	VirtualizerEnd();
	return FALSE;
}

#pragma endregion CallBacks

#pragma region Routines
VOID ImageRoutine(PUNICODE_STRING FullImageName, HANDLE ProcessId, PIMAGE_INFO Info)
{
	UNREFERENCED_PARAMETER(ProcessId);
	//VirtualizerStart();
	if (wcsstr(FullImageName->Buffer, L"EasyAntiCheat.sys"))
	{
		EAC_Base = Info->ImageBase;
		EAC_Base_Size = Info->ImageSize;
		VirtualizerStrEncryptStart();
		DbgPrint("[EAC_Bypass] EAC found in ImageRoutine 0x%llX %d", EAC_Base, EAC_Base_Size);
		VirtualizerStrEncryptEnd();
	}
	//VirtualizerEnd();
}

VOID ProcessRoutine(HANDLE ParentId, HANDLE ProcessId, BOOLEAN Create)
{
	VirtualizerStart();
	VirtualizerStrEncryptStart();
	LPSTR lpFileName = 0;
	PEPROCESS Process = 0;
	if (ProcessId == pGameId && pGameId)
	{
		if (Create == 0)
		{
			DbgPrint("[EAC_Bypass] Protected process %d close %I64x %I64x", ProcessId, EAC_Base, EAC_Base_Size);
			if (ProcessPreOperation || ProcessPostOperation || ThreadPreOperation || ThreadPostOperation)
			{

				if (Remove_Bypass() == FALSE)
					DbgPrint("[EAC_Bypass] WARNING : Remove_Bypass failed");
			}
			IsBypassEnabled = FALSE;
			if (FilterAddr)
			{
				if (!RestoreMiniFilter())
					DbgPrint("[EAC_Bypass] WARNING : RestoreMiniFilter failed");
			}
#if (RESTORE_ROUTINES == 1)
			/*if (RestoreThreadCallBack() == FALSE)
				DbgPrint("[EAC_Bypass] WARNING : RestoreImageCallBack failed.");
			if (RestoreImageCallBack() == FALSE)
				DbgPrint("[EAC_Bypass] WARNING : RestoreImageCallBack failed.");*/
#endif
		}
	}
	// This is required to make sure we don't disturb the game launch
	if (ProcessId == pParentId && pParentId)
	{
		if (Create == 0)
		{
			DbgPrint("[EAC_Bypass] Protected launcher %d close %I64x %I64x", ProcessId);
			if (FuckImageCallBack() == FALSE)
				DbgPrint("[EAC_Bypass] WARNING : FuckImageCallBack failed");
			if (FuckThreadCallBack() == FALSE)
				DbgPrint("[EAC_Bypass] WARNING : FuckThreadCallBack failed");
			if (!RemoveMiniFilter())
				DbgPrint("[EAC_Bypass] WARNING : RemoveMiniFilter failed");
		}
	}
	if (!NT_SUCCESS(PsLookupProcessByProcessId(ProcessId, &Process)))
	{
		DbgPrint("[EAC_Bypass] WARNING : PsLookupProcessByProcessId failed");
		return;
	}
	if (MmIsAddressValid(Process))
	{
		lpFileName = (LPSTR)PsGetProcessImageFileName(Process);
		if (MmIsAddressValid(lpFileName))
		{
			// 
			if (!_stricmp(lpFileName, "YourEACGame.exe") ||
				strstr(lpFileName, "YourEACGame.exe"))
			{
				if (Create)
				{
					pParentId = ParentId;
					pGameId = ProcessId;
					DbgPrint("[EAC_Bypass] Protected process %d found %I64x %I64x", ProcessId, EAC_Base, EAC_Base_Size);
					FilterAddr = 0;
					IsBypassEnabled = FALSE;
					if (Do_Bypass() == FALSE)
						DbgPrint("[EAC_Bypass] WARNING : Do_Bypass failed");
					IsBypassEnabled = TRUE;
#if (RESTORE_ROUTINES == 1)
					if (RestoreThreadCallBack() == FALSE)
						DbgPrint("[EAC_Bypass] WARNING : RestoreImageCallBack failed.");
					if (RestoreImageCallBack() == FALSE)
						DbgPrint("[EAC_Bypass] WARNING : RestoreImageCallBack failed.");

#endif
				}
			}
		}
	}

	VirtualizerStrEncryptEnd();
	VirtualizerEnd();
}


#pragma endregion Routines

BOOLEAN InitBypass()
{
	VirtualizerStart();
	VirtualizerStrEncryptStart();
	BOOLEAN Result = FALSE;
	RTL_OSVERSIONINFOW	osInfo;
	PVOID Base = 0;
	PIMAGE_NT_HEADERS64 Header = 0;
	PIMAGE_SECTION_HEADER pFirstSec = 0;
	ANSI_STRING s1, s2;
	PVOID pFound = 0;
	NTSTATUS status = -1;
	RtlFillMemory(&osInfo, sizeof(RTL_OSVERSIONINFOW), 0);
	RtlFillMemory(&s1, sizeof(ANSI_STRING), 0);
	RtlFillMemory(&s2, sizeof(ANSI_STRING), 0);
	osInfo.dwOSVersionInfoSize = sizeof(RTL_OSVERSIONINFOW);
	RtlGetVersion(&osInfo);

	DbgPrint("[EAC_Bypass] OsInfo: BuildNumber[%ld] dwMajorVersion[%d] dwMinorVersion[%d]", osInfo.dwBuildNumber, osInfo.dwMajorVersion, osInfo.dwMinorVersion);
	if (6 == osInfo.dwMajorVersion)
	{
		if (osInfo.dwMinorVersion == 1)
		{
			DbgPrint("[EAC_Bypass] Windows 7 detected");
			//Windows 7
			Base = GetKernelBase();
			if (Base == 0)
			{
				DbgPrint("[EAC_Bypass] GetKernelBase failed.");
				return Result;
			}
			Header = RtlImageNtHeader(Base);
			pFirstSec = (PIMAGE_SECTION_HEADER)(Header + 1);
			for (PIMAGE_SECTION_HEADER pSec = pFirstSec; pSec < pFirstSec + (Header->FileHeader.NumberOfSections); pSec++)
			{
				RtlInitAnsiString(&s1, "PAGE");
				RtlInitAnsiString(&s2, (PCCHAR)pSec->Name);
				if (RtlCompareString(&s1, &s2, TRUE) == 0)
				{
					//BE ?? ?? ?? ?? 6A 00 8B CB 8B C6 E8 ?? ?? ?? ??  84 C0 75 20 83 C7 04 83 C6 04 81 ?? ?? ?? ?? ?? 72 E3 53 E8 ?? ?? ?? ??  B8 ?? ?? ?? ??  5F
					UCHAR ImageCallBacks_pattern[] = "\x48\x8D\x0D\xCC\xCC\xCC\xCC\x45\x33\xC0\x48\x8B\xD7\x48\x8D\x0C\xD9\xE8\xCC\xCC\xCC\xCC\x84\xC0\x75\xCC\xFF\xC3\x83\xFB\x08\xCC\xCC\x48\x8B\xCF";
					UCHAR ImageCallBacks_pattern2[] = "\xBE\xCC\xCC\xCC\xCC\x6A\x00\x8B\xCB\x8B\xC6\xE8\xCC\xCC\xCC\xCC\x84\xC0\x75\x20\x83\xC7\x04\x83\xC6\x04\x81\xCC\xCC\xCC\xCC\xCC\x72\xE3\x53\xE8\xCC\xCC\xCC\xCC\xB8\xCC\xCC\xCC\xCC";

					//BE ?? ?? ?? ?? 6A 00 8B CB 8B C6 E8 ?? ?? ?? ??  84 C0 75 20 83 C7 04 83 C6 04 81 ?? ?? ?? ?? ?? 72 E3 53 E8 ?? ?? ?? ??  B8 ?? ?? ?? ??  5E
					UCHAR ThreadCallBacks_pattern[] = "\x48\x8D\x1D\xCC\xCC\xCC\xCC\x41\xBF\x40\x00\x00\x00\x48\x8B\xCB";
					UCHAR ThreadCallBacks_pattern2[] = "\xBE\xCC\xCC\xCC\xCC\x6A\x00\x8B\xCB\x8B\xC\xE8\xCC\xCC\xCC\xCC\x84\xC0\x75\x20\x83\xC7\x04\x83\xC6\x04\x81\xCC\xCC\xCC\xCC\xCC\x72\xE3\x53\xE8\xCC\xCC\xCC\xCC\xB8\xCC\xCC\xCC\xCC\x5E";
					UCHAR PsSuspendThread_pattern[] = "\xE8\xCC\xCC\xCC\xCC\x8B\xF8\x48\x8B\x4C\x24\x68\xE8\xCC\xCC\xCC\xCC\xCC\x48";
					//E8 ?? ?? ?? ?? 53 8B 45 08 E8 ?? ?? ?? ?? 8B D8 85 DB 75 E9
					UCHAR PsSuspendThread_pattern2[] = "\xE8\xCC\xCC\xCC\xCC\x53\x8B\x45\x08\xE8\xCC\xCC\xCC\xCC\x8B\xD8\x85\xDB\x75\xE9";
					// E8 ?? ?? ?? ?? 8B D8 85 DB 75 EA 8B 0F 83 E1 FE
					UCHAR PsResumeThread_pattern[] = "\xE8\xCC\xCC\xCC\xCC\x8B\xF8\x48\x8B\x4C\x24\x60\xE8";
					UCHAR PsResumeThread_pattern2[] = "\xE8\xCC\xCC\xCC\xCC\x8B\xD8\x85\xDB\x75\xEA\x8B\x0F\x83\xE1\xFE";
					status = SearchPattern(ImageCallBacks_pattern, 0xCC, sizeof(ImageCallBacks_pattern) - 1, (void*)((PUCHAR)(Base)+pSec->VirtualAddress), pSec->Misc.VirtualSize, &pFound);
					if (NT_SUCCESS(status))
						ImageCallBacks = (PVOID*)dereference((uintptr_t)pFound, 3);
					if (!ImageCallBacks)
					{
						status = SearchPattern(ImageCallBacks_pattern2, 0xCC, sizeof(ImageCallBacks_pattern2) - 1, (void*)((PUCHAR)(Base)+pSec->VirtualAddress), pSec->Misc.VirtualSize, &pFound);
						if (NT_SUCCESS(status))
						{
							DbgPrint("[EAC_Bypass] ImageCallBacks found!!");
							ImageCallBacks = *(uintptr_t*)((uintptr_t)(pFound)+1);
						}
						if (!ImageCallBacks)
						{
							DbgPrint("[EAC_Bypass] ImageCallBacks not found.");
							return Result;
						}
					}
					
					pFound = 0;
					status = SearchPattern(ThreadCallBacks_pattern, 0xCC, sizeof(ThreadCallBacks_pattern) - 1, (void*)((PUCHAR)(Base)+pSec->VirtualAddress), pSec->Misc.VirtualSize, &pFound);
					if (NT_SUCCESS(status))
						ThreadCallBacks = (PVOID*)dereference((uintptr_t)pFound, 3);
					if (!ThreadCallBacks)
					{
						status = SearchPattern(ThreadCallBacks_pattern2, 0xCC, sizeof(ThreadCallBacks_pattern2) - 1, (void*)((PUCHAR)(Base)+pSec->VirtualAddress), pSec->Misc.VirtualSize, &pFound);
						if (NT_SUCCESS(status))
							ThreadCallBacks = *(uintptr_t*)((uintptr_t)(pFound)+1);
						if (!ThreadCallBacks)
						{
							DbgPrint("[EAC_Bypass] ThreadCallBacks not found.");
							return Result;
						}
					}
					
					pFound = 0;
					status = SearchPattern(PsSuspendThread_pattern, 0xCC, sizeof(PsSuspendThread_pattern) - 1, (void*)((PUCHAR)(Base)+pSec->VirtualAddress), pSec->Misc.VirtualSize, &pFound);
					if (NT_SUCCESS(status))
						o_PsSuspendThread = (p_PsSuspendThread)dereference((uintptr_t)pFound, 1);
					if (!o_PsSuspendThread)
					{
						status = SearchPattern(PsSuspendThread_pattern2, 0xCC, sizeof(PsSuspendThread_pattern2) - 1, (void*)((PUCHAR)(Base)+pSec->VirtualAddress), pSec->Misc.VirtualSize, &pFound);
						if (NT_SUCCESS(status))
							o_PsSuspendThread = (p_PsSuspendThread)dereference((uintptr_t)pFound, 1);
						if (!o_PsSuspendThread)
						{
							DbgPrint("[EAC_Bypass] o_PsSuspendThread not found.");
							return Result;
						}
					}
					pFound = 0;
					status = SearchPattern(PsResumeThread_pattern, 0xCC, sizeof(PsResumeThread_pattern) - 1, (void*)((PUCHAR)(Base)+pSec->VirtualAddress), pSec->Misc.VirtualSize, &pFound);
					if (NT_SUCCESS(status))
						o_PsResumeThread = (p_PsResumeThread)dereference((uintptr_t)pFound, 1);
					if (!o_PsResumeThread)
					{
						status = SearchPattern(PsResumeThread_pattern2, 0xCC, sizeof(PsResumeThread_pattern2) - 1, (void*)((PUCHAR)(Base)+pSec->VirtualAddress), pSec->Misc.VirtualSize, &pFound);
						if (NT_SUCCESS(status))
							o_PsResumeThread = (p_PsResumeThread)dereference((uintptr_t)pFound, 1);
						if (!o_PsResumeThread)
						{
							DbgPrint("[EAC_Bypass] o_PsResumeThread not found.");
							return Result;
						}
					}
				}
			}
			if (ImageCallBacks && ThreadCallBacks && o_PsSuspendThread && o_PsResumeThread)
			{
				DbgPrint("[EAC_Bypass] PsSuspendThread found at 0x%llX", o_PsSuspendThread);
				DbgPrint("[EAC_Bypass] PsResumeThread found at 0x%llX", o_PsResumeThread);
				DbgPrint("[EAC_Bypass] ImageCallBacks found at 0x%llX", ImageCallBacks);
				DbgPrint("[EAC_Bypass] ThreadCallBacks found at 0x%llX", ThreadCallBacks);
				DbgPrint("[EAC_Bypass] All Addresses found. Bypass is ready!");
				Result = 1;
			}
		}
		else if (osInfo.dwMinorVersion == 3)
		{
			// Win8.1
			DbgPrint("[EAC_Bypass] Windows 8.1 detected");
			Base = GetKernelBase();
			if (Base == 0)
			{
				DbgPrint("[EAC_Bypass] GetKernelBase failed.");
				return Result;
			}
			Header = RtlImageNtHeader(Base);
			pFirstSec = (PIMAGE_SECTION_HEADER)(Header + 1);
			for (PIMAGE_SECTION_HEADER pSec = pFirstSec; pSec < pFirstSec + (Header->FileHeader.NumberOfSections); pSec++)
			{
				RtlInitAnsiString(&s1, "PAGE");
				RtlInitAnsiString(&s2, (PCCHAR)pSec->Name);
				if (RtlCompareString(&s1, &s2, TRUE) == 0)
				{
					UCHAR ImageCallBacks_pattern[] = "\x48\x8D\x3D\xCC\xCC\xCC\xCC\xBD\x40\x00\x00\x00\x89\x06";
					UCHAR ThreadCallBacks_pattern[] = "\x48\x8D\x1D\xCC\xCC\xCC\xCC\x41\xBF\x40\x00\x00\x00\x48\x8B\xCB";
					UCHAR PsSuspendThread_pattern[] = "\xE8\xCC\xCC\xCC\xCC\x8B\xF8\xBA\xCC\xCC\xCC\xCC\x48\x8B\x4C\x24\x68";
					UCHAR PsResumeThread_pattern[] = "\xE8\xCC\xCC\xCC\xCC\x8B\xF8\x83\xF8\x01\x75\xCC\x48\x8B\x8E\xCC\xCC\xCC\xCC";
					status = SearchPattern(ImageCallBacks_pattern, 0xCC, sizeof(ImageCallBacks_pattern) - 1, (void*)((PUCHAR)(Base)+pSec->VirtualAddress), pSec->Misc.VirtualSize, &pFound);
					if (NT_SUCCESS(status))
						ImageCallBacks = (PVOID*)dereference((uintptr_t)pFound, 3);
					if (!ImageCallBacks)
					{
						DbgPrint("[EAC_Bypass] ImageCallBacks not found.");
						return Result;
					}
					pFound = 0;
					status = SearchPattern(ThreadCallBacks_pattern, 0xCC, sizeof(ThreadCallBacks_pattern) - 1, (void*)((PUCHAR)(Base)+pSec->VirtualAddress), pSec->Misc.VirtualSize, &pFound);
					if (NT_SUCCESS(status))
						ThreadCallBacks = (PVOID*)dereference((uintptr_t)pFound, 3);
					if (!ThreadCallBacks)
					{
						DbgPrint("[EAC_Bypass] ThreadCallBacks not found.");
						return Result;
					}
					pFound = 0;
					status = SearchPattern(PsSuspendThread_pattern, 0xCC, sizeof(PsSuspendThread_pattern) - 1, (void*)((PUCHAR)(Base)+pSec->VirtualAddress), pSec->Misc.VirtualSize, &pFound);
					if (NT_SUCCESS(status))
						o_PsSuspendThread = (p_PsSuspendThread)dereference((uintptr_t)pFound, 1);
					if (!o_PsSuspendThread)
					{
						DbgPrint("[EAC_Bypass] o_PsSuspendThread not found.");
						return Result;
					}
					pFound = 0;
					status = SearchPattern(PsResumeThread_pattern, 0xCC, sizeof(PsResumeThread_pattern) - 1, (void*)((PUCHAR)(Base)+pSec->VirtualAddress), pSec->Misc.VirtualSize, &pFound);
					if (NT_SUCCESS(status))
						o_PsResumeThread = (p_PsResumeThread)dereference((uintptr_t)pFound, 1);
					if (!o_PsResumeThread)
					{
						DbgPrint("[EAC_Bypass] o_PsResumeThread not found.");
						return Result;
					}
				}
			}
			if (ImageCallBacks && ThreadCallBacks && o_PsSuspendThread && o_PsResumeThread)
			{
				DbgPrint("[EAC_Bypass] PsSuspendThread found at 0x%llX", o_PsSuspendThread);
				DbgPrint("[EAC_Bypass] PsResumeThread found at 0x%llX", o_PsResumeThread);
				DbgPrint("[EAC_Bypass] ImageCallBacks found at 0x%llX", ImageCallBacks);
				DbgPrint("[EAC_Bypass] ThreadCallBacks found at 0x%llX", ThreadCallBacks);
				DbgPrint("[EAC_Bypass] All Addresses found. Bypass is ready!");
				Result = 1;
			}
		}
	}
	else if (osInfo.dwMajorVersion == 10)
	{
		// Win10
		DbgPrint("[EAC_Bypass] Windows 10 detected");
		Base = GetKernelBase();
		if (Base == 0)
		{
			DbgPrint("[EAC_Bypass] GetKernelBase failed.");
			return Result;
		}
		Header = RtlImageNtHeader(Base);
		pFirstSec = (PIMAGE_SECTION_HEADER)(Header + 1);
		for (PIMAGE_SECTION_HEADER pSec = pFirstSec; pSec < pFirstSec + (Header->FileHeader.NumberOfSections); pSec++)
		{
			RtlInitAnsiString(&s1, "PAGE");
			RtlInitAnsiString(&s2, (PCCHAR)pSec->Name);
			if (RtlCompareString(&s1, &s2, TRUE) == 0)
			{
				UCHAR ImageCallBacks_pattern[] = "\x48\x8D\x0D\xCC\xCC\xCC\xCC\x45\x33\xC0\x48\x8D\x0C\xD9\x48\x8B\xD7\xE8\xCC\xCC\xCC\xCC\x84\xC0\x0F\x84\xCC\xCC\xCC\xCC";
				UCHAR ThreadCallBacks_pattern[] = "\x48\x8D\x0D\xCC\xCC\xCC\xCC\x45\x33\xC0\x48\x8D\x0C\xD9\x48\x8B\xD7\xE8\xCC\xCC\xCC\xCC\x84\xC0\x74";
				// for older win10 versions 
				UCHAR ThreadCallBacks2_pattern[] = "\x48\x8D\x0D\xCC\xCC\xCC\xCC\x45\x33\xC0\x48\x8D\x0C\xD9\x48\x8B\xD7\xE8\xCC\xCC\xCC\xCC\x84\xC0\x75";
				UCHAR PsSuspendThread_pattern[] = "\xE8\xCC\xCC\xCC\xCC\x48\x8B\xD6\x48\x8B\xCD\xE8\xCC\xCC\xCC\xCC\x48\x8B\xF0";
				UCHAR PsResumeThread_pattern[] = "\xE8\xCC\xCC\xCC\xCC\x48\x8B\xD7\x48\x8B\xCD\xE8\xCC\xCC\xCC\xCC\xEB\xCC\xBB";
				// old win10 builds
				UCHAR PsSuspendThread3_pattern[] = "\xE8\xCC\xCC\xCC\xCC\x8B\xF8\xBA\xCC\xCC\xCC\xCC\x48\x8B\x4C\x24\x78";
				UCHAR PsResumeThread3_pattern[] = "\xE8\xCC\xCC\xCC\xCC\xBA\xCC\xCC\xCC\xCC\x48\x8B\x4C\x24\x78\xE8\xCC\xCC\xCC\xCC\x90";

				// for win10 ver 1903 and higher
				UCHAR PsSuspendThread2_pattern[] = "\xE8\xCC\xCC\xCC\xCC\x48\x8B\xD7\x48\x8B\xCE\xE8\xCC\xCC\xCC\xCC\x48\x8B\xF8";
				UCHAR PsResumeThread2_pattern[] = "\xE8\xCC\xCC\xCC\xCC\x48\x8B\xD7\x48\x8B\xCE\xE8\xCC\xCC\xCC\xCC\xCC\xCC\x49\x8B\xCE";

				status = SearchPattern(ImageCallBacks_pattern, 0xCC, sizeof(ImageCallBacks_pattern) - 1, (void*)((PUCHAR)(Base)+pSec->VirtualAddress), pSec->Misc.VirtualSize, &pFound);
				if (NT_SUCCESS(status))
					ImageCallBacks = (PVOID*)dereference((uintptr_t)pFound, 3);
				if (!ImageCallBacks)
				{
					DbgPrint("[EAC_Bypass] ImageCallBacks not found.");
					return Result;
				}
				pFound = 0;
				status = SearchPattern(ThreadCallBacks_pattern, 0xCC, sizeof(ThreadCallBacks_pattern) - 1, (void*)((PUCHAR)(Base)+pSec->VirtualAddress), pSec->Misc.VirtualSize, &pFound);
				if (NT_SUCCESS(status))
					ThreadCallBacks = (PVOID*)dereference((uintptr_t)pFound, 3);
				if (!ThreadCallBacks)
				{
					DbgPrint("[EAC_Bypass] ThreadCallBacks not found.Retrying...");
					status = SearchPattern(ThreadCallBacks2_pattern, 0xCC, sizeof(ThreadCallBacks2_pattern) - 1, (void*)((PUCHAR)(Base)+pSec->VirtualAddress), pSec->Misc.VirtualSize, &pFound);
					if (NT_SUCCESS(status))
						ThreadCallBacks = (PVOID*)dereference((uintptr_t)pFound, 3);
					if (!ThreadCallBacks)
					{
						DbgPrint("[EAC_Bypass] ThreadCallBacks not found.");
						return Result;
					}

				}
				pFound = 0;
				status = SearchPattern(PsSuspendThread_pattern, 0xCC, sizeof(PsSuspendThread_pattern) - 1, (void*)((PUCHAR)(Base)+pSec->VirtualAddress), pSec->Misc.VirtualSize, &pFound);
				if (NT_SUCCESS(status))
					o_PsSuspendThread = (p_PsSuspendThread)dereference((uintptr_t)pFound, 1);
				if (!o_PsSuspendThread)
				{
					DbgPrint("[EAC_Bypass] o_PsSuspendThread not found.Retrying...");
					status = SearchPattern(PsSuspendThread2_pattern, 0xCC, sizeof(PsSuspendThread2_pattern) - 1, (void*)((PUCHAR)(Base)+pSec->VirtualAddress), pSec->Misc.VirtualSize, &pFound);
					if (NT_SUCCESS(status))
						o_PsSuspendThread = (p_PsSuspendThread)dereference((uintptr_t)pFound, 1);
					if (!o_PsSuspendThread)
					{
						DbgPrint("[EAC_Bypass] o_PsSuspendThread not found.Retrying...");
						status = SearchPattern(PsSuspendThread3_pattern, 0xCC, sizeof(PsSuspendThread3_pattern) - 1, (void*)((PUCHAR)(Base)+pSec->VirtualAddress), pSec->Misc.VirtualSize, &pFound);
						if (NT_SUCCESS(status))
							o_PsSuspendThread = (p_PsSuspendThread)dereference((uintptr_t)pFound, 1);
						if (!o_PsSuspendThread)
						{
							DbgPrint("[EAC_Bypass] o_PsSuspendThread not found.");
							return Result;
						}
					}
				}
				pFound = 0;
				status = SearchPattern(PsResumeThread_pattern, 0xCC, sizeof(PsResumeThread_pattern) - 1, (void*)((PUCHAR)(Base)+pSec->VirtualAddress), pSec->Misc.VirtualSize, &pFound);
				if (NT_SUCCESS(status))
					o_PsResumeThread = (p_PsResumeThread)dereference((uintptr_t)pFound, 1);
				if (!o_PsResumeThread)
				{
					DbgPrint("[EAC_Bypass] o_PsResumeThread not found.Retrying...");
					status = SearchPattern(PsResumeThread2_pattern, 0xCC, sizeof(PsResumeThread2_pattern) - 1, (void*)((PUCHAR)(Base)+pSec->VirtualAddress), pSec->Misc.VirtualSize, &pFound);
					if (NT_SUCCESS(status))
						o_PsResumeThread = (p_PsResumeThread)dereference((uintptr_t)pFound, 1);
					if (!o_PsResumeThread)
					{
						DbgPrint("[EAC_Bypass] o_PsResumeThread not found.Retrying...");
						status = SearchPattern(PsResumeThread3_pattern, 0xCC, sizeof(PsResumeThread3_pattern) - 1, (void*)((PUCHAR)(Base)+pSec->VirtualAddress), pSec->Misc.VirtualSize, &pFound);
						if (NT_SUCCESS(status))
							o_PsResumeThread = (p_PsResumeThread)dereference((uintptr_t)pFound, 1);
						if (!o_PsResumeThread)
						{
							DbgPrint("[EAC_Bypass] o_PsResumeThread not found.");
							return Result;
						}
					}
				}
			}
		}
		if (ImageCallBacks && ThreadCallBacks && o_PsSuspendThread && o_PsResumeThread)
		{
			DbgPrint("[EAC_Bypass] PsSuspendThread found at 0x%llX", o_PsSuspendThread);
			DbgPrint("[EAC_Bypass] PsResumeThread found at 0x%llX", o_PsResumeThread);
			DbgPrint("[EAC_Bypass] ImageCallBacks found at 0x%llX", ImageCallBacks);
			DbgPrint("[EAC_Bypass] ThreadCallBacks found at 0x%llX", ThreadCallBacks);
			DbgPrint("[EAC_Bypass] All Addresses found. Bypass is ready!");
			Result = 1;
		}
	}

	if (Result == 0)
		return Result;

	if (!NT_SUCCESS(PsSetLoadImageNotifyRoutine(ImageRoutine)) ||
		!NT_SUCCESS(PsSetCreateProcessNotifyRoutine(ProcessRoutine, 0)))
	{
		VirtualizerStrEncryptStart();
		DbgPrint("[EAC_Bypass] CallBack installation failed.");
		VirtualizerStrEncryptEnd();
		Result = 0;
		return Result;
	}
	ProcessPreOperation = 0;
	ProcessPostOperation = 0;
	ThreadPreOperation = 0;
	ThreadPostOperation = 0;
	VirtualizerStrEncryptEnd();
	VirtualizerEnd();
	return Result;
}

BOOLEAN UninitBypass()
{
	VirtualizerStart();
	VirtualizerStrEncryptStart();
	BOOLEAN Result = 1;
	if (ProcessPreOperation || ProcessPostOperation || ThreadPreOperation || ThreadPostOperation)
	{
		if (!Remove_Bypass())
		{
			DbgPrint("[EAC_Bypass] WARNING : Failed to reset the callbacks");
			Result = 0;
		}
	}
	IsBypassEnabled = FALSE;
#if (RESTORE_ROUTINES == 1)
	if (RestoreThreadCallBack() == FALSE)
		DbgPrint("[EAC_Bypass] WARNING : RestoreImageCallBack failed.");
	if (RestoreImageCallBack() == FALSE)
		DbgPrint("[EAC_Bypass] WARNING : RestoreImageCallBack failed.");
#endif
	if (FilterAddr)
	{
		if (!RestoreMiniFilter())
		{
			DbgPrint("[EAC_Bypass] Failed to restore the minifilter");
			Result = 0;
		}
	}
	if (!NT_SUCCESS(PsRemoveLoadImageNotifyRoutine(ImageRoutine)) ||
		!NT_SUCCESS(PsSetCreateProcessNotifyRoutine(ProcessRoutine, 1)))
	{
		DbgPrint("[EAC_Bypass] Failed to remove the callbacks");
		Result = 0;
	}
	VirtualizerStrEncryptEnd();
	VirtualizerEnd();
	return Result;
}

VOID OnUnload(IN PDRIVER_OBJECT DriverObject)
{
	UNREFERENCED_PARAMETER(DriverObject);
	VirtualizerStart();
	VirtualizerStrEncryptStart();

	UNICODE_STRING symLink;
	RtlInitUnicodeString(&symLink, dSymLinkBuffer);

	if (!NT_SUCCESS(IoDeleteSymbolicLink(&symLink)))
	{
		DbgPrint("[EAC_Bypass] WARNING : IoDeleteSymbolicLink failed.");
	}
	if (pDeviceObject)
		IoDeleteDevice(pDeviceObject);
	if (!UninitBypass())
		DbgPrint("[EAC_Bypass] WARNING : Failed to uninitialize the bypass.");
	VirtualizerStrEncryptEnd();
	VirtualizerEnd();

}


NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
	UNREFERENCED_PARAMETER(RegistryPath);
	VirtualizerStart();
	VirtualizerStrEncryptStart();
	NTSTATUS ntStatus = -1;
	UNICODE_STRING deviceNameUnicodeString, deviceSymLinkUnicodeString;

	RtlInitUnicodeString(&deviceNameUnicodeString, dNameBuffer);
	RtlInitUnicodeString(&deviceSymLinkUnicodeString, dSymLinkBuffer);

	DriverObject->DriverUnload = OnUnload;
	DriverObject->MajorFunction[IRP_MJ_CREATE] = DeviceCreate;
	DriverObject->MajorFunction[IRP_MJ_CLOSE] = DeviceClose;
	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DeviceIoHandler;

	if (InitBypass() == 0)
	{
		DbgPrint("[EAC_Bypass] InitBypass failed.");
		return ntStatus;
	}

	ntStatus = IoCreateDevice(DriverObject, 0, &deviceNameUnicodeString, FILE_DEVICE_UNKNOWN, FILE_DEVICE_UNKNOWN, FALSE, &pDeviceObject);
	if (!NT_SUCCESS(ntStatus))
	{
		DbgPrint("[EAC_Bypass] IoCreateDevice failed.");
		return ntStatus;
	}
	ntStatus = IoCreateSymbolicLink(&deviceSymLinkUnicodeString, &deviceNameUnicodeString);
	if (!NT_SUCCESS(ntStatus))
	{
		DbgPrint("[EAC_Bypass] IoCreateSymbolicLink failed.");
		return ntStatus;
	}
	//HideDriver(DriverObject);
	VirtualizerStrEncryptEnd();
	VirtualizerEnd();
	return ntStatus;
}

NTSTATUS DeviceCreate(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
	UNREFERENCED_PARAMETER(DeviceObject);
	UNREFERENCED_PARAMETER(Irp);
	return STATUS_SUCCESS;
}

NTSTATUS DeviceClose(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
	UNREFERENCED_PARAMETER(DeviceObject);
	UNREFERENCED_PARAMETER(Irp);
	return STATUS_SUCCESS;
}

NTSTATUS DeviceIoHandler(PDEVICE_OBJECT DeviceObject, PIRP IRP)
{
	UNREFERENCED_PARAMETER(DeviceObject);
	VirtualizerStart();
	VirtualizerStrEncryptStart();
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(IRP);
	IRP->IoStatus.Status = STATUS_SUCCESS;
	if (stack)
	{
		if (stack->Parameters.DeviceIoControl.IoControlCode == ctl_protectprocess)
		{
			PHIDEPROC_STRUCT buffer = (PHIDEPROC_STRUCT)IRP->AssociatedIrp.SystemBuffer;
			if (MmIsAddressValid(buffer))
				ProcessIdToProtect = buffer->pId;
			IRP->IoStatus.Information = sizeof(PHIDEPROC_STRUCT);
		}

		if (stack->Parameters.DeviceIoControl.IoControlCode == ctl_isenabled)
		{
			PIS_ENABLED_STRUCT buffer = (PIS_ENABLED_STRUCT)IRP->AssociatedIrp.SystemBuffer;
			if (MmIsAddressValid(buffer))
				buffer->IsEnabled = IsBypassEnabled;
			IRP->IoStatus.Information = sizeof(PIS_ENABLED_STRUCT);
		}
		if (stack->Parameters.DeviceIoControl.IoControlCode == ctl_getprocid)
		{
			PGETPROC_STRUCT buffer = (PGETPROC_STRUCT)IRP->AssociatedIrp.SystemBuffer;
			if (MmIsAddressValid(buffer))
				buffer->pId = pGameId;
			IRP->IoStatus.Information = sizeof(PGETPROC_STRUCT);
		}
	}

	IoCompleteRequest(IRP, IO_NO_INCREMENT);
	VirtualizerStrEncryptEnd();
	VirtualizerEnd();
	return IRP->IoStatus.Status;
}

#pragma region Utils

// Credits to DarthTon (BlackBone, Github)
NTSTATUS SearchPattern(IN PCUCHAR pattern, IN UCHAR wildcard, IN ULONG_PTR len, IN const VOID* base, IN ULONG_PTR size, OUT PVOID* ppFound)
{
	ASSERT(ppFound != NULL && pattern != NULL && base != NULL);
	if (ppFound == NULL || pattern == NULL || base == NULL)
		return STATUS_INVALID_PARAMETER;

	for (ULONG_PTR i = 0; i < size - len; i++)
	{
		BOOLEAN found = TRUE;
		for (ULONG_PTR j = 0; j < len; j++)
		{
			if (pattern[j] != wildcard && pattern[j] != ((PCUCHAR)base)[i + j])
			{
				found = FALSE;
				break;
			}
		}
		if (found != FALSE)
		{
			*ppFound = (PUCHAR)base + i;
			return STATUS_SUCCESS;
		}
	}
	return STATUS_NOT_FOUND;
}



PVOID GetKernelBase()
{
	VirtualizerStart();
	VirtualizerStrEncryptStart();
	NTSTATUS status = STATUS_INSUFFICIENT_RESOURCES;
	PVOID Base = 0;
	ULONG cb = 0x10000;
	do
	{
		status = STATUS_INSUFFICIENT_RESOURCES;
		PRTL_PROCESS_MODULES prpm = (PRTL_PROCESS_MODULES)ExAllocatePool(PagedPool, cb);
		if (prpm)
		{
			if (0 <= (status == ZwQuerySystemInformation(0x0B, prpm, cb, &cb)))
			{
				ULONG NumberOfModules = prpm->NumberOfModules;
				if (NumberOfModules)
				{
					PRTL_PROCESS_MODULE_INFORMATION Modules = prpm->Modules;
					do
					{
						if ((ULONG64)Modules->ImageBase > (ULONG64)(0x8000000000000000))
						{
							Base = Modules->ImageBase;
							break;
						}
					} while (Modules++, --NumberOfModules);
				}
			}
			ExFreePool(prpm);
		}

	} while (status == STATUS_INFO_LENGTH_MISMATCH);
	VirtualizerStrEncryptEnd();
	VirtualizerEnd();
	return Base;
}

BOOLEAN IsFromEACRange(PVOID Address)
{
	if ((ULONG64)Address > (ULONG64)EAC_Base &&
		(ULONG64)((ULONG64)EAC_Base + (ULONG64)EAC_Base_Size) > (ULONG64)Address)
	{
		return 1;
	}
	return 0;
}

BOOLEAN SuspendOrResumeAllThreads(BOOLEAN Suspend)
{
	VirtualizerStart();
	VirtualizerStrEncryptStart();
	ULONG cb = 0x20000;
	PSYSTEM_PROCESS_INFORMATION psi = 0;
	PVOID buf = 0;
	NTSTATUS status = 0, rc = 0;
	PETHREAD peThread = 0;
	do
	{
		status = STATUS_INSUFFICIENT_RESOURCES;

		if (buf = ExAllocatePool(PagedPool, cb))
		{
			if (0 <= (status = ZwQuerySystemInformation(5, buf, cb, &cb)))
			{
				psi = (PSYSTEM_PROCESS_INFORMATION)buf;
				while (psi->NextEntryOffset)
				{
					if (psi->UniqueProcessId == (HANDLE)4)
					{
						for (ULONG i = 0; i < psi->NumberOfThreads; i++)
						{
							if (MmIsAddressValid(psi->Threads[i].StartAddress) && IsFromEACRange(psi->Threads[i].StartAddress))
							{
								rc = PsLookupThreadByThreadId(psi->Threads[i].ClientId.UniqueThread, &peThread);
								if (!NT_SUCCESS(rc))
								{
									DbgPrint("[EAC_Bypass] PsLookupThreadByThreadId failed in SuspendOrResumeAllThreads");
									if (buf)
										ExFreePool(buf);
									return 0;
								}
								if (NT_SUCCESS(rc))
								{
									DbgPrint("[EAC_Bypass] Found EAC Thread %d !", psi->Threads[i].ClientId.UniqueThread);
									if (peThread)
									{
										if (Suspend == TRUE)
										{
											if (!NT_SUCCESS(o_PsSuspendThread(peThread, 0)))
												DbgPrint("[EAC_Bypass] o_PsSuspendThread failed.");
										}
										else
											if (!NT_SUCCESS(o_PsResumeThread(peThread)))
												DbgPrint("[EAC_Bypass] o_PsSuspendThread failed.");
									}
								}
							}
						}

					}
					psi = (PSYSTEM_PROCESS_INFORMATION)((ULONG64)(psi)+psi->NextEntryOffset);
				}

			}
			if (buf)
				ExFreePool(buf);
		}

	} while (status == STATUS_INFO_LENGTH_MISMATCH);
	VirtualizerStrEncryptEnd();
	VirtualizerEnd();
	return (status == 0) ? 1 : 0;
}

// Credits to GayPig (Github), yes I am lazy
uintptr_t dereference(uintptr_t address, unsigned int offset)
{
	if (address == 0)
		return 0;

	return address + (int)((*(int*)(address + offset) + offset) + sizeof(int));
}

#pragma endregion Utils

```

`EAC_Bypass/Main.hpp`:

```hpp
#pragma once 

#include "ntos.hpp"
#include "ntstructs.hpp"

// Driver stuff

typedef struct HIDEPROC_STRUCT
{
	ULONG pId;
}HIDEPROC_STRUCT, * PHIDEPROC_STRUCT;

typedef struct IS_ENABLED_STRUCT
{
	BOOLEAN IsEnabled;
}IS_ENABLED_STRUCT, * PIS_ENABLED_STRUCT;

typedef struct GETPROC_STRUCT
{
	ULONG pId;
}GETPROC_STRUCT, * PGETPROC_STRUCT;

#define ctl_protectprocess    CTL_CODE(FILE_DEVICE_UNKNOWN, 0xad138, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define ctl_isenabled    CTL_CODE(FILE_DEVICE_UNKNOWN, 0xad136, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define ctl_getprocid    CTL_CODE(FILE_DEVICE_UNKNOWN, 0xad139, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

const WCHAR dNameBuffer[] = L"\\Device\\EAC_Bypass";
const WCHAR dSymLinkBuffer[] = L"\\DosDevices\\EAC_Bypass";
ULONG ProcessIdToProtect = 0;
BOOLEAN IsBypassEnabled = 0;
PDEVICE_OBJECT pDeviceObject = 0;
NTSTATUS DeviceIoHandler(PDEVICE_OBJECT devicDriverObjecte_obj, PIRP IRP);
NTSTATUS DeviceCreate(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS DeviceClose(PDEVICE_OBJECT DeviceObject, PIRP Irp);

// Callbacks
PVOID* ThreadCallBacks = 0, *ImageCallBacks = 0;

// Backups
PVOID ProcessPostOperation = 0, ProcessPreOperation = 0, ThreadPostOperation = 0, ThreadPreOperation = 0, FilterAddr = 0;
PVOID EAC_ThreadRoutine = 0, EAC_ImageRoutine = 0;

// EAC information
PVOID EAC_Base = 0;
ULONG64 EAC_Base_Size = 0;

// Filter information
HANDLE pParentId = 0, pGameId = 0;
LONG lOperationsOffset = 0;

typedef NTSTATUS(NTAPI* p_PsSuspendThread)(IN PETHREAD Thread, OUT PULONG PreviousCount OPTIONAL);
p_PsSuspendThread o_PsSuspendThread = 0;

typedef NTSTATUS(NTAPI* p_PsResumeThread)(IN PETHREAD Thread);
p_PsResumeThread o_PsResumeThread = 0;

// Bypass functions
BOOLEAN RestoreImageCallBack();
BOOLEAN RestoreThreadCallBack();

// Routines
VOID ImageRoutine(PUNICODE_STRING FullImageName, HANDLE ProcessId, PIMAGE_INFO Info);
VOID ProcessRoutine(HANDLE ParentId, HANDLE ProcessId, BOOLEAN Create);


// Utils
NTSTATUS SearchPattern(IN PCUCHAR pattern, IN UCHAR wildcard, IN ULONG_PTR len, IN const VOID* base, IN ULONG_PTR size, OUT PVOID* ppFound);
PVOID GetKernelBase();
BOOLEAN IsFromEACRange(PVOID Address);
BOOLEAN SuspendOrResumeAllThreads(BOOLEAN Suspend);
uintptr_t dereference(uintptr_t address, unsigned int offset);
VOID HideDriver(PDRIVER_OBJECT pDriverObject);


```

`EAC_Bypass/Options.hpp`:

```hpp
#pragma once


#define REMOVE_IMAGEROUTINE 1
#define REMOVE_THREADROUTINE 1
#define REMOVE_PROCESSCALLBACKS 1
#define REMOVE_THREADCALLBACKS 1
#define REMOVE_FILTER 0
#define SUSPEND_EAC 1
#define PROTECT_PROCESS 1
#define RESTORE_ROUTINES 1
#define USE_VM 0

#if(USE_VM == 1)
#include "VL\VirtualizerSDK.h"
#else
#define VM_TIGER_WHITE_START
#define VM_TIGER_WHITE_END
#define VM_TIGER_WHITE_START
#define VM_TIGER_WHITE_END
#define VM_EAGLE_BLACK_START
#define VM_EAGLE_BLACK_END
#define VIRTUALIZER_TIGER_WHITE_START 
#define VIRTUALIZER_TIGER_WHITE_END 
static void VirtualizerStart() {}
static void VirtualizerEnd() {}
static void VirtualizerStrEncryptStart() {}
static void VirtualizerStrEncryptEnd() {}
#endif
```

`EAC_Bypass/common.h`:

```h
#pragma once 

#include "ntos.h"

typedef struct _OPERATION_INFO_ENTRY
{
	LIST_ENTRY    ListEntry;
	OB_OPERATION  Operation;
	ULONG         Flags;
	PVOID         Object;
	POBJECT_TYPE  ObjectType;
	ACCESS_MASK   AccessMask;
} OPERATION_INFO_ENTRY, * POPERATION_INFO_ENTRY;


typedef struct _THREAD_BASIC_INFORMATION
{
	NTSTATUS                ExitStatus;
	PVOID                   TebBaseAddress;
	CLIENT_ID               ClientId;
	KAFFINITY               AffinityMask;
	KPRIORITY               Priority;
	KPRIORITY               BasePriority;
} THREAD_BASIC_INFORMATION, * PTHREAD_BASIC_INFORMATION;


typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _SYSTEM_THREAD {
	LARGE_INTEGER           KernelTime;
	LARGE_INTEGER           UserTime;
	LARGE_INTEGER           CreateTime;
	ULONG                   WaitTime;
	PVOID                   StartAddress;
	CLIENT_ID               ClientId;
	KPRIORITY               Priority;
	LONG                    BasePriority;
	ULONG                   ContextSwitchCount;
	ULONG                   State;
	KWAIT_REASON            WaitReason;
} SYSTEM_THREAD, * PSYSTEM_THREAD;

typedef struct _SYSTEM_THREAD_INFORMATION
{
	LARGE_INTEGER KernelTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER CreateTime;
	ULONG WaitTime;
	PVOID StartAddress;
	CLIENT_ID ClientId;
	KPRIORITY Priority;
	LONG BasePriority;
	ULONG ContextSwitches;
	ULONG ThreadState;
	KWAIT_REASON WaitReason;
} SYSTEM_THREAD_INFORMATION, * PSYSTEM_THREAD_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFORMATION
{
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	LARGE_INTEGER WorkingSetPrivateSize; // since VISTA
	ULONG HardFaultCount; // since WIN7
	ULONG NumberOfThreadsHighWatermark; // since WIN7
	ULONGLONG CycleTime; // since WIN7
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	UNICODE_STRING ImageName;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	HANDLE InheritedFromUniqueProcessId;
	ULONG HandleCount;
	ULONG SessionId;
	ULONG_PTR UniqueProcessKey; // since VISTA (requires SystemExtendedProcessInformation)
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG PageFaultCount;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	SIZE_T QuotaPeakPagedPoolUsage;
	SIZE_T QuotaPagedPoolUsage;
	SIZE_T QuotaPeakNonPagedPoolUsage;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
	LARGE_INTEGER ReadOperationCount;
	LARGE_INTEGER WriteOperationCount;
	LARGE_INTEGER OtherOperationCount;
	LARGE_INTEGER ReadTransferCount;
	LARGE_INTEGER WriteTransferCount;
	LARGE_INTEGER OtherTransferCount;
	SYSTEM_THREAD_INFORMATION Threads[1];
} SYSTEM_PROCESS_INFORMATION, * PSYSTEM_PROCESS_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[ANYSIZE_ARRAY];
}RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

typedef struct _IMAGE_SECTION_HEADER {
	char  Name[8];
	union {
		ULONG PhysicalAddress;
		ULONG VirtualSize;
	} Misc;
	ULONG VirtualAddress;
	ULONG SizeOfRawData;
	ULONG PointerToRawData;
	ULONG PointerToRelocations;
	ULONG PointerToLinenumbers;
	WORD  NumberOfRelocations;
	WORD  NumberOfLinenumbers;
	ULONG Characteristics;
} IMAGE_SECTION_HEADER, * PIMAGE_SECTION_HEADER;

typedef struct _IMAGE_FILE_HEADER {
	WORD  Machine;
	WORD  NumberOfSections;
	ULONG TimeDateStamp;
	ULONG PointerToSymbolTable;
	ULONG NumberOfSymbols;
	WORD  SizeOfOptionalHeader;
	WORD  Characteristics;
} IMAGE_FILE_HEADER, * PIMAGE_FILE_HEADER;

typedef struct _IMAGE_DATA_DIRECTORY {
	ULONG VirtualAddress;
	ULONG Size;
} IMAGE_DATA_DIRECTORY, * PIMAGE_DATA_DIRECTORY;

typedef struct _IMAGE_OPTIONAL_HEADER64 {
	WORD        Magic;
	char        MajorLinkerVersion;
	char        MinorLinkerVersion;
	ULONG       SizeOfCode;
	ULONG       SizeOfInitializedData;
	ULONG       SizeOfUninitializedData;
	ULONG       AddressOfEntryPoint;
	ULONG       BaseOfCode;
	ULONGLONG   ImageBase;
	ULONG       SectionAlignment;
	ULONG       FileAlignment;
	WORD        MajorOperatingSystemVersion;
	WORD        MinorOperatingSystemVersion;
	WORD        MajorImageVersion;
	WORD        MinorImageVersion;
	WORD        MajorSubsystemVersion;
	WORD        MinorSubsystemVersion;
	ULONG       Win32VersionValue;
	ULONG       SizeOfImage;
	ULONG       SizeOfHeaders;
	ULONG       CheckSum;
	WORD        Subsystem;
	WORD        DllCharacteristics;
	ULONGLONG   SizeOfStackReserve;
	ULONGLONG   SizeOfStackCommit;
	ULONGLONG   SizeOfHeapReserve;
	ULONGLONG   SizeOfHeapCommit;
	ULONG       LoaderFlags;
	ULONG       NumberOfRvaAndSizes;
	IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER64, * PIMAGE_OPTIONAL_HEADER64;

typedef struct _IMAGE_NT_HEADERS64 {
	ULONG                   Signature;
	IMAGE_FILE_HEADER       FileHeader;
	IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, * PIMAGE_NT_HEADERS64;


typedef struct _OBJECT_TYPE_INITIALIZER
{
	SHORT Length;
	UCHAR ObjectTypeFlags;
	ULONG CaseInsensitive : 1;
	ULONG UnnamedObjectsOnly : 1;
	ULONG UseDefaultObject : 1;
	ULONG SecurityRequired : 1;
	ULONG MaintainHandleCount : 1;
	ULONG MaintainTypeList : 1;
	ULONG ObjectTypeCode;
	ULONG InvalidAttributes;
	GENERIC_MAPPING GenericMapping;
	ULONG ValidAccessMask;
	POOL_TYPE PoolType;
	ULONG DefaultPagedPoolCharge;
	ULONG DefaultNonPagedPoolCharge;
	PVOID DumpProcedure;
	LONG* OpenProcedure;
	PVOID CloseProcedure;
	PVOID DeleteProcedure;
	LONG* ParseProcedure;
	LONG* SecurityProcedure;
	LONG* QueryNameProcedure;
	UCHAR* OkayToCloseProcedure;
} OBJECT_TYPE_INITIALIZER, * POBJECT_TYPE_INITIALIZER;

typedef struct _CALLBACK_ENTRY {
	UINT16 Version; 
	UINT16 OperationRegistrationCount; 
	UINT32 unk1; 
	PVOID RegistrationContext; 
	UNICODE_STRING Altitude; 
} CALLBACK_ENTRY, * PCALLBACK_ENTRY;

typedef struct _CALLBACK_ENTRY_ITEM {
	LIST_ENTRY EntryItemList;
	OB_OPERATION Operations;
	CALLBACK_ENTRY* CallbackEntry; 
	POBJECT_TYPE ObjectType;
	POB_PRE_OPERATION_CALLBACK PreOperation;
	POB_POST_OPERATION_CALLBACK PostOperation;
	__int64 unk;
}CALLBACK_ENTRY_ITEM, * PCALLBACK_ENTRY_ITEM;

typedef struct _OBJECT_TYPE {
	LIST_ENTRY TypeList;
	UNICODE_STRING Name;
	VOID* DefaultObject;
	UCHAR Index;
	unsigned __int32 TotalNumberOfObjects;
	unsigned __int32 TotalNumberOfHandles;
	unsigned __int32 HighWaterNumberOfObjects;
	unsigned __int32 HighWaterNumberOfHandles;
	OBJECT_TYPE_INITIALIZER TypeInfo;
	EX_PUSH_LOCK TypeLock;
	unsigned __int32 Key;
	LIST_ENTRY CallbackList; 
}OBJECT_TYPE, * POBJECT_TYPE;


// Callbacks
PVOID *ThreadCallBacks = 0, *ImageCallBacks = 0;
// Backups
PVOID ProcessPostOperation = 0, ProcessPreOperation = 0, ThreadPostOperation = 0, ThreadPreOperation = 0;
PVOID EAC_ThreadRoutine = 0, EAC_ImageRoutine = 0;

// EAC Information
PVOID EAC_Base = 0;
ULONG64 EAC_Base_Size = 0;
// Filter information
HANDLE pParentId = 0, pGameId = 0;

typedef NTSTATUS(NTAPI* p_PsSuspendThread)(IN PETHREAD Thread, OUT PULONG PreviousCount OPTIONAL);
p_PsSuspendThread o_PsSuspendThread = 0;

typedef NTSTATUS(NTAPI* p_PsResumeThread)(IN PETHREAD Thread);
p_PsResumeThread o_PsResumeThread = 0;

VOID FuckThreadCallBack();
VOID FuckImageCallBack();
VOID Do_Bypass();
VOID Remove_Bypass();
VOID ImageRoutine(PUNICODE_STRING FullImageName, HANDLE ProcessId, PIMAGE_INFO Info);
VOID ProcessRoutine(HANDLE ParentId, HANDLE ProcessId, BOOLEAN Create);


NTSTATUS SearchPattern(IN PCUCHAR pattern, IN UCHAR wildcard, IN ULONG_PTR len, IN const VOID* base, IN ULONG_PTR size, OUT PVOID* ppFound);
PVOID GetKernelBase();
BOOLEAN IsFromEACRange(PVOID Address);
BOOLEAN SuspendOrResumeAllThreads(BOOLEAN Suspend);
uintptr_t dereference(uintptr_t address, unsigned int offset);

```

`EAC_Bypass/ntstructs.hpp`:

```hpp
#pragma once

typedef struct _OPERATION_INFO_ENTRY
{
	LIST_ENTRY    ListEntry;
	OB_OPERATION  Operation;
	ULONG         Flags;
	PVOID         Object;
	POBJECT_TYPE  ObjectType;
	ACCESS_MASK   AccessMask;
} OPERATION_INFO_ENTRY, * POPERATION_INFO_ENTRY;


typedef struct _THREAD_BASIC_INFORMATION
{
	NTSTATUS                ExitStatus;
	PVOID                   TebBaseAddress;
	CLIENT_ID               ClientId;
	KAFFINITY               AffinityMask;
	KPRIORITY               Priority;
	KPRIORITY               BasePriority;
} THREAD_BASIC_INFORMATION, * PTHREAD_BASIC_INFORMATION;


typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _SYSTEM_THREAD {
	LARGE_INTEGER           KernelTime;
	LARGE_INTEGER           UserTime;
	LARGE_INTEGER           CreateTime;
	ULONG                   WaitTime;
	PVOID                   StartAddress;
	CLIENT_ID               ClientId;
	KPRIORITY               Priority;
	LONG                    BasePriority;
	ULONG                   ContextSwitchCount;
	ULONG                   State;
	KWAIT_REASON            WaitReason;
} SYSTEM_THREAD, * PSYSTEM_THREAD;

typedef struct _SYSTEM_THREAD_INFORMATION
{
	LARGE_INTEGER KernelTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER CreateTime;
	ULONG WaitTime;
	PVOID StartAddress;
	CLIENT_ID ClientId;
	KPRIORITY Priority;
	LONG BasePriority;
	ULONG ContextSwitches;
	ULONG ThreadState;
	KWAIT_REASON WaitReason;
} SYSTEM_THREAD_INFORMATION, * PSYSTEM_THREAD_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFORMATION
{
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	LARGE_INTEGER WorkingSetPrivateSize; // since VISTA
	ULONG HardFaultCount; // since WIN7
	ULONG NumberOfThreadsHighWatermark; // since WIN7
	ULONGLONG CycleTime; // since WIN7
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	UNICODE_STRING ImageName;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	HANDLE InheritedFromUniqueProcessId;
	ULONG HandleCount;
	ULONG SessionId;
	ULONG_PTR UniqueProcessKey; // since VISTA (requires SystemExtendedProcessInformation)
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG PageFaultCount;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	SIZE_T QuotaPeakPagedPoolUsage;
	SIZE_T QuotaPagedPoolUsage;
	SIZE_T QuotaPeakNonPagedPoolUsage;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
	LARGE_INTEGER ReadOperationCount;
	LARGE_INTEGER WriteOperationCount;
	LARGE_INTEGER OtherOperationCount;
	LARGE_INTEGER ReadTransferCount;
	LARGE_INTEGER WriteTransferCount;
	LARGE_INTEGER OtherTransferCount;
	SYSTEM_THREAD_INFORMATION Threads[1];
} SYSTEM_PROCESS_INFORMATION, * PSYSTEM_PROCESS_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[ANYSIZE_ARRAY];
}RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

typedef struct _IMAGE_SECTION_HEADER {
	char  Name[8];
	union {
		ULONG PhysicalAddress;
		ULONG VirtualSize;
	} Misc;
	ULONG VirtualAddress;
	ULONG SizeOfRawData;
	ULONG PointerToRawData;
	ULONG PointerToRelocations;
	ULONG PointerToLinenumbers;
	WORD  NumberOfRelocations;
	WORD  NumberOfLinenumbers;
	ULONG Characteristics;
} IMAGE_SECTION_HEADER, * PIMAGE_SECTION_HEADER;

typedef struct _IMAGE_FILE_HEADER {
	WORD  Machine;
	WORD  NumberOfSections;
	ULONG TimeDateStamp;
	ULONG PointerToSymbolTable;
	ULONG NumberOfSymbols;
	WORD  SizeOfOptionalHeader;
	WORD  Characteristics;
} IMAGE_FILE_HEADER, * PIMAGE_FILE_HEADER;

typedef struct _IMAGE_DATA_DIRECTORY {
	ULONG VirtualAddress;
	ULONG Size;
} IMAGE_DATA_DIRECTORY, * PIMAGE_DATA_DIRECTORY;

typedef struct _IMAGE_OPTIONAL_HEADER64 {
	WORD        Magic;
	char        MajorLinkerVersion;
	char        MinorLinkerVersion;
	ULONG       SizeOfCode;
	ULONG       SizeOfInitializedData;
	ULONG       SizeOfUninitializedData;
	ULONG       AddressOfEntryPoint;
	ULONG       BaseOfCode;
	ULONGLONG   ImageBase;
	ULONG       SectionAlignment;
	ULONG       FileAlignment;
	WORD        MajorOperatingSystemVersion;
	WORD        MinorOperatingSystemVersion;
	WORD        MajorImageVersion;
	WORD        MinorImageVersion;
	WORD        MajorSubsystemVersion;
	WORD        MinorSubsystemVersion;
	ULONG       Win32VersionValue;
	ULONG       SizeOfImage;
	ULONG       SizeOfHeaders;
	ULONG       CheckSum;
	WORD        Subsystem;
	WORD        DllCharacteristics;
	ULONGLONG   SizeOfStackReserve;
	ULONGLONG   SizeOfStackCommit;
	ULONGLONG   SizeOfHeapReserve;
	ULONGLONG   SizeOfHeapCommit;
	ULONG       LoaderFlags;
	ULONG       NumberOfRvaAndSizes;
	IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER64, * PIMAGE_OPTIONAL_HEADER64;

typedef struct _IMAGE_NT_HEADERS64 {
	ULONG                   Signature;
	IMAGE_FILE_HEADER       FileHeader;
	IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, * PIMAGE_NT_HEADERS64;


typedef struct _OBJECT_TYPE_INITIALIZER
{
	SHORT Length;
	UCHAR ObjectTypeFlags;
	ULONG CaseInsensitive : 1;
	ULONG UnnamedObjectsOnly : 1;
	ULONG UseDefaultObject : 1;
	ULONG SecurityRequired : 1;
	ULONG MaintainHandleCount : 1;
	ULONG MaintainTypeList : 1;
	ULONG ObjectTypeCode;
	ULONG InvalidAttributes;
	GENERIC_MAPPING GenericMapping;
	ULONG ValidAccessMask;
	POOL_TYPE PoolType;
	ULONG DefaultPagedPoolCharge;
	ULONG DefaultNonPagedPoolCharge;
	PVOID DumpProcedure;
	LONG* OpenProcedure;
	PVOID CloseProcedure;
	PVOID DeleteProcedure;
	LONG* ParseProcedure;
	LONG* SecurityProcedure;
	LONG* QueryNameProcedure;
	UCHAR* OkayToCloseProcedure;
} OBJECT_TYPE_INITIALIZER, * POBJECT_TYPE_INITIALIZER;

typedef struct _CALLBACK_ENTRY {
	UINT16 Version;
	UINT16 OperationRegistrationCount;
	UINT32 unk1;
	PVOID RegistrationContext;
	UNICODE_STRING Altitude;
} CALLBACK_ENTRY, * PCALLBACK_ENTRY;

typedef struct _CALLBACK_ENTRY_ITEM {
	LIST_ENTRY EntryItemList;
	OB_OPERATION Operations;
	CALLBACK_ENTRY* CallbackEntry;
	POBJECT_TYPE ObjectType;
	POB_PRE_OPERATION_CALLBACK PreOperation;
	POB_POST_OPERATION_CALLBACK PostOperation;
	__int64 unk;
}CALLBACK_ENTRY_ITEM, * PCALLBACK_ENTRY_ITEM;

typedef struct _OBJECT_TYPE {
	LIST_ENTRY TypeList;
	UNICODE_STRING Name;
	VOID* DefaultObject;
	UCHAR Index;
	unsigned __int32 TotalNumberOfObjects;
	unsigned __int32 TotalNumberOfHandles;
	unsigned __int32 HighWaterNumberOfObjects;
	unsigned __int32 HighWaterNumberOfHandles;
	OBJECT_TYPE_INITIALIZER TypeInfo;
	EX_PUSH_LOCK TypeLock;
	unsigned __int32 Key;
	LIST_ENTRY CallbackList;
}OBJECT_TYPE, * POBJECT_TYPE;

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	union
	{
		LIST_ENTRY HashLinks;
		struct
		{
			PVOID SectionPointer;
			ULONG CheckSum;
		};
	};
	union
	{
		ULONG TimeDateStamp;
		PVOID LoadedImports;
	};
	struct _ACTIVATION_CONTEXT* EntryPointActivationContext;
	PVOID PatchInformation;
	LIST_ENTRY ForwarderLinks;
	LIST_ENTRY ServiceTagLinks;
	LIST_ENTRY StaticLinks;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;
```

`EAC_Usermode/EAC.cpp`:

```cpp
#include "EAC.hpp"
#include <TlHelp32.h>

HANDLE EAC::hEvent;
typedef BOOL(NTAPI* p_DeviceIoControl)(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
static p_DeviceIoControl o_DeviceIoControl = nullptr;

bool EAC::Init()
{
	return Bypass_DeviceIoControl(true);
}
bool EAC::Uninit()
{
	return Bypass_DeviceIoControl(false);
}


bool WINAPI DeviceIoControl_Hook (HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped)
{
	VM_START
	DWORD_PTR dwStartAddress = 0;
	HMODULE hModule = 0;
	static HANDLE hThread = nullptr;
	if (NT_SUCCESS(NtQueryInformationThread(GetCurrentThread(), static_cast<THREADINFOCLASS>(9), &dwStartAddress, sizeof(DWORD_PTR), NULL)) &&
		!GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, reinterpret_cast<char*>(dwStartAddress), &hModule))
	{
		if (!EnumWindows([](HWND hWnd, LPARAM lParam) -> BOOL
			{
				DWORD procId = 0;
				if (GetWindowThreadProcessId(hWnd, &procId) && procId == GetCurrentProcessId())
					SuspendThread(GetCurrentThread());
				return TRUE;
			}, NULL))
		{
			MessageBoxExA(0, "Failed to use EnumWindows!", "ERRROR!", 0, 0);
			return false;
		}
	}
	VM_END
	return o_DeviceIoControl(hDevice, dwIoControlCode, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesReturned, lpOverlapped);
};

bool EAC::Bypass_DeviceIoControl(bool detourStatus)
{
	VM_START
	if(!o_DeviceIoControl)
		o_DeviceIoControl = reinterpret_cast<p_DeviceIoControl>(GetProcAddress(GetModuleHandleA("KERNELBASE"), "DeviceIoControl"));
	if (DetourTransactionBegin() != NO_ERROR ||
		DetourUpdateThread(GetCurrentThread()) != NO_ERROR ||
		DetourAttach(&(PVOID&)o_DeviceIoControl, DeviceIoControl_Hook) != NO_ERROR ||
		DetourTransactionCommit() != NO_ERROR)
	{
#if _DEBUG == 1
		std::cout << "Could not hook functions" << std::endl;
#endif
		MessageBoxExA(0, "Failed to hook functions!", "ERRROR!", 0, 0);
		return false;
	}
	VM_END
	return true;
	}
```

`EAC_Usermode/EAC.hpp`:

```hpp
#pragma once
#include <windows.h>
#include <iostream>
#include "detours.h"
#include <cstdint>
#include <intrin.h>
#include <winternl.h>
#include "Options.hpp"

#pragma comment(lib,"ntdll")
#ifdef _WIN64
#pragma comment(lib,"detours64")
#else
#pragma comment(lib,"detours")
#endif

class EAC
{
public:
	static EAC& GetInstance() {
		static EAC Instance;
		return Instance;
	}
	bool Init();
	bool Uninit();

private:
	EAC(EAC const&) = delete;
	EAC(EAC&&) = delete;
	EAC& operator=(EAC const&) = delete;
	EAC& operator=(EAC&&) = delete;

	static bool Bypass_DeviceIoControl(bool detourStatus);
protected:
	EAC()
	{
		hEvent = CreateEvent(0, 0, 0, 0);
	}
	~EAC()
	{
		CloseHandle(hEvent);
	}
	static HANDLE hEvent;
};
```

`EAC_Usermode/EAC_Usermode.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{56F38C3E-FC80-4028-B6E9-4688A33E4AEB}</ProjectGuid>
    <RootNamespace>EACUsermode</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <DebugInformationFormat>None</DebugInformationFormat>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <DebugInformationFormat>None</DebugInformationFormat>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="EAC.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="EAC.hpp" />
    <ClInclude Include="Options.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`EAC_Usermode/EAC_Usermode.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="EAC.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="EAC.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Options.hpp">
      <Filter>Resource Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`EAC_Usermode/EAC_Usermode.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`EAC_Usermode/Options.hpp`:

```hpp
#define USE_VM 0

#if(USE_VM == 1)
#include "WL\WinlicenseSDK.h"
#if _WIN64
#pragma comment(lib,"WinLicenseSDK64.lib")
#else
#pragma comment(lib,"WinLicenseSDK32.lib")
#endif
#else
#define VM_START
#define VM_END
#endif

```

`EAC_Usermode/detours.h`:

```h
//////////////////////////////////////////////////////////////////////////////
//
//  Core Detours Functionality (detours.h of detours.lib)
//
//  Microsoft Research Detours Package, Version 3.0 Build_316.
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#pragma once
#ifndef _DETOURS_H_
#define _DETOURS_H_

#define DETOURS_VERSION     30000   // 3.00.00

//////////////////////////////////////////////////////////////////////////////
//

#if (_MSC_VER < 1299)
typedef LONG LONG_PTR;
typedef ULONG ULONG_PTR;
#endif

#ifndef __in_z
#define __in_z
#endif

//////////////////////////////////////////////////////////////////////////////
//
#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct  _GUID
{
    DWORD Data1;
    WORD Data2;
    WORD Data3;
    BYTE Data4[ 8 ];
} GUID;

#ifdef INITGUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#else
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    const GUID name
#endif // INITGUID
#endif // !GUID_DEFINED

#if defined(__cplusplus)
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID &
#endif // !_REFGUID_DEFINED
#else // !__cplusplus
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID * const
#endif // !_REFGUID_DEFINED
#endif // !__cplusplus

//
//////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/////////////////////////////////////////////////// Instruction Target Macros.
//
#define DETOUR_INSTRUCTION_TARGET_NONE          ((PVOID)0)
#define DETOUR_INSTRUCTION_TARGET_DYNAMIC       ((PVOID)(LONG_PTR)-1)
#define DETOUR_SECTION_HEADER_SIGNATURE         0x00727444   // "Dtr\0"

extern const GUID DETOUR_EXE_RESTORE_GUID;
extern const GUID DETOUR_EXE_HELPER_GUID;

#define DETOUR_TRAMPOLINE_SIGNATURE             0x21727444  // Dtr!
typedef struct _DETOUR_TRAMPOLINE DETOUR_TRAMPOLINE, *PDETOUR_TRAMPOLINE;

/////////////////////////////////////////////////////////// Binary Structures.
//
#pragma pack(push, 8)
typedef struct _DETOUR_SECTION_HEADER
{
    DWORD       cbHeaderSize;
    DWORD       nSignature;
    DWORD       nDataOffset;
    DWORD       cbDataSize;

    DWORD       nOriginalImportVirtualAddress;
    DWORD       nOriginalImportSize;
    DWORD       nOriginalBoundImportVirtualAddress;
    DWORD       nOriginalBoundImportSize;

    DWORD       nOriginalIatVirtualAddress;
    DWORD       nOriginalIatSize;
    DWORD       nOriginalSizeOfImage;
    DWORD       cbPrePE;

    DWORD       nOriginalClrFlags;
    DWORD       reserved1;
    DWORD       reserved2;
    DWORD       reserved3;

    // Followed by cbPrePE bytes of data.
} DETOUR_SECTION_HEADER, *PDETOUR_SECTION_HEADER;

typedef struct _DETOUR_SECTION_RECORD
{
    DWORD       cbBytes;
    DWORD       nReserved;
    GUID        guid;
} DETOUR_SECTION_RECORD, *PDETOUR_SECTION_RECORD;

typedef struct _DETOUR_CLR_HEADER
{
    // Header versioning
    ULONG                   cb;
    USHORT                  MajorRuntimeVersion;
    USHORT                  MinorRuntimeVersion;

    // Symbol table and startup information
    IMAGE_DATA_DIRECTORY    MetaData;
    ULONG                   Flags;

    // Followed by the rest of the IMAGE_COR20_HEADER
} DETOUR_CLR_HEADER, *PDETOUR_CLR_HEADER;

typedef struct _DETOUR_EXE_RESTORE
{
    DWORD               cb;
    DWORD               cbidh;
    DWORD               cbinh;
    DWORD               cbclr;

    PBYTE               pidh;
    PBYTE               pinh;
    PBYTE               pclr;

    IMAGE_DOS_HEADER    idh;
    union {
        IMAGE_NT_HEADERS    inh;
        IMAGE_NT_HEADERS32  inh32;
        IMAGE_NT_HEADERS64  inh64;
        BYTE                raw[sizeof(IMAGE_NT_HEADERS64) +
                                sizeof(IMAGE_SECTION_HEADER) * 32];
    };
    DETOUR_CLR_HEADER   clr;

} DETOUR_EXE_RESTORE, *PDETOUR_EXE_RESTORE;

typedef struct _DETOUR_EXE_HELPER
{
    DWORD               cb;
    DWORD               pid;
    CHAR                DllName[MAX_PATH];

} DETOUR_EXE_HELPER, *PDETOUR_EXE_HELPER;

#pragma pack(pop)

#define DETOUR_SECTION_HEADER_DECLARE(cbSectionSize) \
{ \
      sizeof(DETOUR_SECTION_HEADER),\
      DETOUR_SECTION_HEADER_SIGNATURE,\
      sizeof(DETOUR_SECTION_HEADER),\
      (cbSectionSize),\
      \
      0,\
      0,\
      0,\
      0,\
      \
      0,\
      0,\
      0,\
      0,\
}

/////////////////////////////////////////////////////////////// Helper Macros.
//
#define DETOURS_STRINGIFY(x)    DETOURS_STRINGIFY_(x)
#define DETOURS_STRINGIFY_(x)    #x

///////////////////////////////////////////////////////////// Binary Typedefs.
//
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_BYWAY_CALLBACK)(PVOID pContext,
                                                         PCHAR pszFile,
                                                         PCHAR *ppszOutFile);

typedef BOOL (CALLBACK *PF_DETOUR_BINARY_FILE_CALLBACK)(PVOID pContext,
                                                        PCHAR pszOrigFile,
                                                        PCHAR pszFile,
                                                        PCHAR *ppszOutFile);

typedef BOOL (CALLBACK *PF_DETOUR_BINARY_SYMBOL_CALLBACK)(PVOID pContext,
                                                          ULONG nOrigOrdinal,
                                                          ULONG nOrdinal,
                                                          ULONG *pnOutOrdinal,
                                                          PCHAR pszOrigSymbol,
                                                          PCHAR pszSymbol,
                                                          PCHAR *ppszOutSymbol);

typedef BOOL (CALLBACK *PF_DETOUR_BINARY_COMMIT_CALLBACK)(PVOID pContext);

typedef BOOL (CALLBACK *PF_DETOUR_ENUMERATE_EXPORT_CALLBACK)(PVOID pContext,
                                                             ULONG nOrdinal,
                                                             PCHAR pszName,
                                                             PVOID pCode);

typedef BOOL (CALLBACK *PF_DETOUR_IMPORT_FILE_CALLBACK)(PVOID pContext,
                                                        HMODULE hModule,
                                                        PCSTR pszFile);

typedef BOOL (CALLBACK *PF_DETOUR_IMPORT_FUNC_CALLBACK)(PVOID pContext,
                                                        DWORD nOrdinal,
                                                        PCSTR pszFunc,
                                                        PVOID pvFunc);

typedef VOID * PDETOUR_BINARY;
typedef VOID * PDETOUR_LOADED_BINARY;

//////////////////////////////////////////////////////////// Transaction APIs.
//
LONG WINAPI DetourTransactionBegin(VOID);
LONG WINAPI DetourTransactionAbort(VOID);
LONG WINAPI DetourTransactionCommit(VOID);
LONG WINAPI DetourTransactionCommitEx(PVOID **pppFailedPointer);

LONG WINAPI DetourUpdateThread(HANDLE hThread);

LONG WINAPI DetourAttach(PVOID *ppPointer,
                         PVOID pDetour);

LONG WINAPI DetourAttachEx(PVOID *ppPointer,
                           PVOID pDetour,
                           PDETOUR_TRAMPOLINE *ppRealTrampoline,
                           PVOID *ppRealTarget,
                           PVOID *ppRealDetour);

LONG WINAPI DetourDetach(PVOID *ppPointer,
                         PVOID pDetour);

BOOL WINAPI DetourSetIgnoreTooSmall(BOOL fIgnore);
BOOL WINAPI DetourSetRetainRegions(BOOL fRetain);

////////////////////////////////////////////////////////////// Code Functions.
//
PVOID WINAPI DetourFindFunction(PCSTR pszModule, PCSTR pszFunction);
PVOID WINAPI DetourCodeFromPointer(PVOID pPointer, PVOID *ppGlobals);
PVOID WINAPI DetourCopyInstruction(PVOID pDst,
                                   PVOID *pDstPool,
                                   PVOID pSrc,
                                   PVOID *ppTarget,
                                   LONG *plExtra);

///////////////////////////////////////////////////// Loaded Binary Functions.
//
HMODULE WINAPI DetourGetContainingModule(PVOID pvAddr);
HMODULE WINAPI DetourEnumerateModules(HMODULE hModuleLast);
PVOID WINAPI DetourGetEntryPoint(HMODULE hModule);
ULONG WINAPI DetourGetModuleSize(HMODULE hModule);
BOOL WINAPI DetourEnumerateExports(HMODULE hModule,
                                   PVOID pContext,
                                   PF_DETOUR_ENUMERATE_EXPORT_CALLBACK pfExport);
BOOL WINAPI DetourEnumerateImports(HMODULE hModule,
                                   PVOID pContext,
                                   PF_DETOUR_IMPORT_FILE_CALLBACK pfImportFile,
                                   PF_DETOUR_IMPORT_FUNC_CALLBACK pfImportFunc);

PVOID WINAPI DetourFindPayload(HMODULE hModule, REFGUID rguid, DWORD *pcbData);
PVOID WINAPI DetourFindPayloadEx(REFGUID rguid, DWORD * pcbData);
DWORD WINAPI DetourGetSizeOfPayloads(HMODULE hModule);

///////////////////////////////////////////////// Persistent Binary Functions.
//

PDETOUR_BINARY WINAPI DetourBinaryOpen(HANDLE hFile);
PVOID WINAPI DetourBinaryEnumeratePayloads(PDETOUR_BINARY pBinary,
                                           GUID *pGuid,
                                           DWORD *pcbData,
                                           DWORD *pnIterator);
PVOID WINAPI DetourBinaryFindPayload(PDETOUR_BINARY pBinary,
                                     REFGUID rguid,
                                     DWORD *pcbData);
PVOID WINAPI DetourBinarySetPayload(PDETOUR_BINARY pBinary,
                                    REFGUID rguid,
                                    PVOID pData,
                                    DWORD cbData);
BOOL WINAPI DetourBinaryDeletePayload(PDETOUR_BINARY pBinary, REFGUID rguid);
BOOL WINAPI DetourBinaryPurgePayloads(PDETOUR_BINARY pBinary);
BOOL WINAPI DetourBinaryResetImports(PDETOUR_BINARY pBinary);
BOOL WINAPI DetourBinaryEditImports(PDETOUR_BINARY pBinary,
                                    PVOID pContext,
                                    PF_DETOUR_BINARY_BYWAY_CALLBACK pfByway,
                                    PF_DETOUR_BINARY_FILE_CALLBACK pfFile,
                                    PF_DETOUR_BINARY_SYMBOL_CALLBACK pfSymbol,
                                    PF_DETOUR_BINARY_COMMIT_CALLBACK pfCommit);
BOOL WINAPI DetourBinaryWrite(PDETOUR_BINARY pBinary, HANDLE hFile);
BOOL WINAPI DetourBinaryClose(PDETOUR_BINARY pBinary);

/////////////////////////////////////////////////// Create Process & Load Dll.
//
typedef BOOL (WINAPI *PDETOUR_CREATE_PROCESS_ROUTINEA)
    (LPCSTR lpApplicationName,
     LPSTR lpCommandLine,
     LPSECURITY_ATTRIBUTES lpProcessAttributes,
     LPSECURITY_ATTRIBUTES lpThreadAttributes,
     BOOL bInheritHandles,
     DWORD dwCreationFlags,
     LPVOID lpEnvironment,
     LPCSTR lpCurrentDirectory,
     LPSTARTUPINFOA lpStartupInfo,
     LPPROCESS_INFORMATION lpProcessInformation);

typedef BOOL (WINAPI *PDETOUR_CREATE_PROCESS_ROUTINEW)
    (LPCWSTR lpApplicationName,
     LPWSTR lpCommandLine,
     LPSECURITY_ATTRIBUTES lpProcessAttributes,
     LPSECURITY_ATTRIBUTES lpThreadAttributes,
     BOOL bInheritHandles,
     DWORD dwCreationFlags,
     LPVOID lpEnvironment,
     LPCWSTR lpCurrentDirectory,
     LPSTARTUPINFOW lpStartupInfo,
     LPPROCESS_INFORMATION lpProcessInformation);

BOOL WINAPI DetourCreateProcessWithDllA(LPCSTR lpApplicationName,
                                        __in_z LPSTR lpCommandLine,
                                        LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                        LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        BOOL bInheritHandles,
                                        DWORD dwCreationFlags,
                                        LPVOID lpEnvironment,
                                        LPCSTR lpCurrentDirectory,
                                        LPSTARTUPINFOA lpStartupInfo,
                                        LPPROCESS_INFORMATION lpProcessInformation,
                                        LPCSTR lpDllName,
                                        PDETOUR_CREATE_PROCESS_ROUTINEA
                                        pfCreateProcessA);

BOOL WINAPI DetourCreateProcessWithDllW(LPCWSTR lpApplicationName,
                                        __in_z LPWSTR lpCommandLine,
                                        LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                        LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        BOOL bInheritHandles,
                                        DWORD dwCreationFlags,
                                        LPVOID lpEnvironment,
                                        LPCWSTR lpCurrentDirectory,
                                        LPSTARTUPINFOW lpStartupInfo,
                                        LPPROCESS_INFORMATION lpProcessInformation,
                                        LPCSTR lpDllName,
                                        PDETOUR_CREATE_PROCESS_ROUTINEW
                                        pfCreateProcessW);

#ifdef UNICODE
#define DetourCreateProcessWithDll      DetourCreateProcessWithDllW
#define PDETOUR_CREATE_PROCESS_ROUTINE  PDETOUR_CREATE_PROCESS_ROUTINEW
#else
#define DetourCreateProcessWithDll      DetourCreateProcessWithDllA
#define PDETOUR_CREATE_PROCESS_ROUTINE  PDETOUR_CREATE_PROCESS_ROUTINEA
#endif // !UNICODE

BOOL WINAPI DetourCreateProcessWithDllExA(LPCSTR lpApplicationName,
                                          __in_z LPSTR lpCommandLine,
                                          LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                          LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                          BOOL bInheritHandles,
                                          DWORD dwCreationFlags,
                                          LPVOID lpEnvironment,
                                          LPCSTR lpCurrentDirectory,
                                          LPSTARTUPINFOA lpStartupInfo,
                                          LPPROCESS_INFORMATION lpProcessInformation,
                                          LPCSTR lpDllName,
                                          PDETOUR_CREATE_PROCESS_ROUTINEA
                                          pfCreateProcessA);

BOOL WINAPI DetourCreateProcessWithDllExW(LPCWSTR lpApplicationName,
                                          __in_z LPWSTR lpCommandLine,
                                          LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                          LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                          BOOL bInheritHandles,
                                          DWORD dwCreationFlags,
                                          LPVOID lpEnvironment,
                                          LPCWSTR lpCurrentDirectory,
                                          LPSTARTUPINFOW lpStartupInfo,
                                          LPPROCESS_INFORMATION lpProcessInformation,
                                          LPCSTR lpDllName,
                                          PDETOUR_CREATE_PROCESS_ROUTINEW
                                          pfCreateProcessW);

#ifdef UNICODE
#define DetourCreateProcessWithDllEx    DetourCreateProcessWithDllExW
#define PDETOUR_CREATE_PROCESS_ROUTINE  PDETOUR_CREATE_PROCESS_ROUTINEW
#else
#define DetourCreateProcessWithDllEx    DetourCreateProcessWithDllExA
#define PDETOUR_CREATE_PROCESS_ROUTINE  PDETOUR_CREATE_PROCESS_ROUTINEA
#endif // !UNICODE

BOOL WINAPI DetourProcessViaHelperA(DWORD dwTargetPid,
                                    LPCSTR lpDllName,
                                    PDETOUR_CREATE_PROCESS_ROUTINEA pfCreateProcessA);

BOOL WINAPI DetourProcessViaHelperW(DWORD dwTargetPid,
                                    LPCSTR lpDllName,
                                    PDETOUR_CREATE_PROCESS_ROUTINEW pfCreateProcessW);

#ifdef UNICODE
#define DetourProcessViaHelper          DetourProcessViaHelperW
#else
#define DetourProcessViaHelper          DetourProcessViaHelperA
#endif // !UNICODE

BOOL WINAPI DetourUpdateProcessWithDll(HANDLE hProcess,
                                       LPCSTR *plpDlls,
                                       DWORD nDlls);

BOOL WINAPI DetourCopyPayloadToProcess(HANDLE hProcess,
                                       REFGUID rguid,
                                       PVOID pvData,
                                       DWORD cbData);
BOOL WINAPI DetourRestoreAfterWith(VOID);
BOOL WINAPI DetourRestoreAfterWithEx(PVOID pvData, DWORD cbData);
BOOL WINAPI DetourIsHelperProcess(VOID);
VOID CALLBACK DetourFinishHelperProcess(HWND, HINSTANCE, LPSTR, INT);

//
//////////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
}
#endif // __cplusplus

//////////////////////////////////////////////// Detours Internal Definitions.
//
#ifdef __cplusplus
#ifdef DETOURS_INTERNAL

#ifndef __deref_out
#define __deref_out
#endif

#ifndef __deref
#define __deref
#endif

//////////////////////////////////////////////////////////////////////////////
//
#if (_MSC_VER < 1299)
#include <imagehlp.h>
typedef IMAGEHLP_MODULE IMAGEHLP_MODULE64;
typedef PIMAGEHLP_MODULE PIMAGEHLP_MODULE64;
typedef IMAGEHLP_SYMBOL SYMBOL_INFO;
typedef PIMAGEHLP_SYMBOL PSYMBOL_INFO;

static inline
LONG InterlockedCompareExchange(LONG *ptr, LONG nval, LONG oval)
{
    return (LONG)::InterlockedCompareExchange((PVOID*)ptr, (PVOID)nval, (PVOID)oval);
}
#else
#include <dbghelp.h>
#endif

#ifdef IMAGEAPI // defined by DBGHELP.H
typedef LPAPI_VERSION (NTAPI *PF_ImagehlpApiVersionEx)(LPAPI_VERSION AppVersion);

typedef BOOL (NTAPI *PF_SymInitialize)(IN HANDLE hProcess,
                                       IN LPCSTR UserSearchPath,
                                       IN BOOL fInvadeProcess);
typedef DWORD (NTAPI *PF_SymSetOptions)(IN DWORD SymOptions);
typedef DWORD (NTAPI *PF_SymGetOptions)(VOID);
typedef DWORD64 (NTAPI *PF_SymLoadModule64)(IN HANDLE hProcess,
                                            IN HANDLE hFile,
                                            IN PSTR ImageName,
                                            IN PSTR ModuleName,
                                            IN DWORD64 BaseOfDll,
                                            IN DWORD SizeOfDll);
typedef BOOL (NTAPI *PF_SymGetModuleInfo64)(IN HANDLE hProcess,
                                            IN DWORD64 qwAddr,
                                            OUT PIMAGEHLP_MODULE64 ModuleInfo);
typedef BOOL (NTAPI *PF_SymFromName)(IN HANDLE hProcess,
                                     IN LPSTR Name,
                                     OUT PSYMBOL_INFO Symbol);

typedef struct _DETOUR_SYM_INFO
{
    HANDLE                  hProcess;
    HMODULE                 hDbgHelp;
    PF_ImagehlpApiVersionEx pfImagehlpApiVersionEx;
    PF_SymInitialize        pfSymInitialize;
    PF_SymSetOptions        pfSymSetOptions;
    PF_SymGetOptions        pfSymGetOptions;
    PF_SymLoadModule64      pfSymLoadModule64;
    PF_SymGetModuleInfo64   pfSymGetModuleInfo64;
    PF_SymFromName          pfSymFromName;
} DETOUR_SYM_INFO, *PDETOUR_SYM_INFO;

PDETOUR_SYM_INFO DetourLoadDbgHelp(VOID);

#endif // IMAGEAPI

#ifndef DETOUR_TRACE
#if DETOUR_DEBUG
#define DETOUR_TRACE(x) printf x
#define DETOUR_BREAK()  __debugbreak()
#include <stdio.h>
#include <limits.h>
#else
#define DETOUR_TRACE(x)
#define DETOUR_BREAK()
#endif
#endif

#ifdef DETOURS_IA64
__declspec(align(16)) struct DETOUR_IA64_BUNDLE
{
  public:
    union
    {
        BYTE    data[16];
        UINT64  wide[2];
    };

  public:
    struct DETOUR_IA64_METADATA;

    typedef BOOL (DETOUR_IA64_BUNDLE::* DETOUR_IA64_METACOPY)
        (const DETOUR_IA64_METADATA *pMeta, DETOUR_IA64_BUNDLE *pDst) const;

    enum {
        A_UNIT  = 1u,
        I_UNIT  = 2u,
        M_UNIT  = 3u,
        B_UNIT  = 4u,
        F_UNIT  = 5u,
        L_UNIT  = 6u,
        X_UNIT  = 7u,
        UNIT_MASK = 7u,
        STOP    = 8u
    };
    struct DETOUR_IA64_METADATA
    {
        ULONG       nTemplate       : 8;    // Instruction template.
        ULONG       nUnit0          : 4;    // Unit for slot 0
        ULONG       nUnit1          : 4;    // Unit for slot 1
        ULONG       nUnit2          : 4;    // Unit for slot 2
        DETOUR_IA64_METACOPY    pfCopy;     // Function pointer.
    };

  protected:
    BOOL CopyBytes(const DETOUR_IA64_METADATA *pMeta, DETOUR_IA64_BUNDLE *pDst) const;
    BOOL CopyBytesMMB(const DETOUR_IA64_METADATA *pMeta, DETOUR_IA64_BUNDLE *pDst) const;
    BOOL CopyBytesMBB(const DETOUR_IA64_METADATA *pMeta, DETOUR_IA64_BUNDLE *pDst) const;
    BOOL CopyBytesBBB(const DETOUR_IA64_METADATA *pMeta, DETOUR_IA64_BUNDLE *pDst) const;
    BOOL CopyBytesMLX(const DETOUR_IA64_METADATA *pMeta, DETOUR_IA64_BUNDLE *pDst) const;

    static const DETOUR_IA64_METADATA s_rceCopyTable[33];

  public:
    // 120 112 104 96 88 80 72 64 56 48 40 32 24 16  8  0
    //  f.  e.  d. c. b. a. 9. 8. 7. 6. 5. 4. 3. 2. 1. 0.

    //                                      00
    // f.e. d.c. b.a. 9.8. 7.6. 5.4. 3.2. 1.0.
    // 0000 0000 0000 0000 0000 0000 0000 001f : Template [4..0]
    // 0000 0000 0000 0000 0000 03ff ffff ffe0 : Zero [ 41..  5]
    // 0000 0000 0000 0000 0000 3c00 0000 0000 : Zero [ 45.. 42]
    // 0000 0000 0007 ffff ffff c000 0000 0000 : One  [ 82.. 46]
    // 0000 0000 0078 0000 0000 0000 0000 0000 : One  [ 86.. 83]
    // 0fff ffff ff80 0000 0000 0000 0000 0000 : Two  [123.. 87]
    // f000 0000 0000 0000 0000 0000 0000 0000 : Two  [127..124]
    BYTE    GetTemplate() const;
    BYTE    GetInst0() const;
    BYTE    GetInst1() const;
    BYTE    GetInst2() const;
    BYTE    GetUnit0() const;
    BYTE    GetUnit1() const;
    BYTE    GetUnit2() const;
    UINT64  GetData0() const;
    UINT64  GetData1() const;
    UINT64  GetData2() const;

  public:
    BOOL    IsBrl() const;
    VOID    SetBrl();
    VOID    SetBrl(UINT64 target);
    UINT64  GetBrlTarget() const;
    VOID    SetBrlTarget(UINT64 target);
    VOID    SetBrlImm(UINT64 imm);
    UINT64  GetBrlImm() const;

    BOOL    IsMovlGp() const;
    UINT64  GetMovlGp() const;
    VOID    SetMovlGp(UINT64 gp);

    VOID    SetInst0(BYTE nInst);
    VOID    SetInst1(BYTE nInst);
    VOID    SetInst2(BYTE nInst);
    VOID    SetData0(UINT64 nData);
    VOID    SetData1(UINT64 nData);
    VOID    SetData2(UINT64 nData);
    BOOL    SetNop0();
    BOOL    SetNop1();
    BOOL    SetNop2();
    BOOL    SetStop();

    BOOL    Copy(DETOUR_IA64_BUNDLE *pDst) const;
};
#endif // DETOURS_IA64

//#ifdef DETOURS_ARM
//#error Feature not supported in this release.



//#endif // DETOURS_ARM

//////////////////////////////////////////////////////////////////////////////

#endif // DETOURS_INTERNAL
#endif // __cplusplus

#endif // _DETOURS_H_
//
////////////////////////////////////////////////////////////////  End of File.

```

`EAC_Usermode/main.cpp`:

```cpp
#include "EAC.hpp"

__declspec(dllexport) BOOL UNKNOWN(HMODULE hDll, DWORD dwReason, LPVOID lpReserved)
{
	VM_START
	if (dwReason == DLL_PROCESS_ATTACH)
		EAC::GetInstance().Init();
	if (dwReason == DLL_PROCESS_DETACH)
		EAC::GetInstance().Uninit();
	VM_END
	return true;
}
```

`LICENSE`:

```
MIT License

Copyright (c) 2020 Schnocker

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# EAC Bypass
A simple EAC bypass used for debugging games.

```