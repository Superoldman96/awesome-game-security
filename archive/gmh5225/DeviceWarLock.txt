Project Path: arc_gmh5225_DeviceWarLock_iq_ga9i_

Source Tree:

```txt
arc_gmh5225_DeviceWarLock_iq_ga9i_
├── README.md
├── app
│   ├── build.gradle
│   ├── proguard-rules.pro
│   └── src
│       ├── androidTest
│       │   └── java
│       │       └── com
│       │           └── xiaoc
│       │               └── warlock
│       │                   └── ExampleInstrumentedTest.java
│       ├── main
│       │   ├── AndroidManifest.xml
│       │   ├── aidl
│       │   │   └── com
│       │   │       └── xiaoc
│       │   │           └── warlock
│       │   │               └── IServerCallback.aidl
│       │   ├── cpp
│       │   │   ├── CMakeLists.txt
│       │   │   ├── inc
│       │   │   │   ├── collector
│       │   │   │   │   ├── BasicInfoCollector.h
│       │   │   │   │   ├── ICollector.h
│       │   │   │   │   ├── MiscInfoCollector.h
│       │   │   │   │   ├── NativeCollector.h
│       │   │   │   │   └── SystemInfoCollector.h
│       │   │   │   ├── constants
│       │   │   │   │   └── Constants.h
│       │   │   │   ├── crypto
│       │   │   │   │   ├── EncryptManager.h
│       │   │   │   │   └── crypto.h
│       │   │   │   ├── detector
│       │   │   │   │   ├── FridaDetector.h
│       │   │   │   │   ├── MiscDetector.h
│       │   │   │   │   ├── NativeDetector.h
│       │   │   │   │   ├── SandboxDetector.h
│       │   │   │   │   ├── SystemDetector.h
│       │   │   │   │   └── VirtualDetector.h
│       │   │   │   ├── network
│       │   │   │   │   └── NetworkManager.h
│       │   │   │   ├── utils
│       │   │   │   │   ├── Base64Utils.h
│       │   │   │   │   ├── CommandUtils.h
│       │   │   │   │   ├── DetectorUtils.h
│       │   │   │   │   ├── FileUtils.h
│       │   │   │   │   ├── IDetector.h
│       │   │   │   │   ├── LogUtils.h
│       │   │   │   │   ├── MiscUtil.h
│       │   │   │   │   ├── StringUtils.h
│       │   │   │   │   ├── SyscallUtils.h
│       │   │   │   │   ├── XsonCollector.h
│       │   │   │   │   └── allheader.h
│       │   │   │   └── warlockCore.h
│       │   │   └── src
│       │   │       ├── collector
│       │   │       │   ├── BasicInfoCollector.cpp
│       │   │       │   ├── MiscInfoCollector.cpp
│       │   │       │   ├── NativeCollector.cpp
│       │   │       │   └── SystemInfoCollector.cpp
│       │   │       ├── crypto
│       │   │       │   ├── AES.cpp
│       │   │       │   ├── Base64.cpp
│       │   │       │   ├── EncryptManager.cpp
│       │   │       │   └── MD5.cpp
│       │   │       ├── detector
│       │   │       │   ├── FridaDetector.cpp
│       │   │       │   ├── MiscDetector.cpp
│       │   │       │   ├── NativeDetector.cpp
│       │   │       │   ├── SandboxDetector.cpp
│       │   │       │   ├── SystemDetector.cpp
│       │   │       │   └── VirtualDetector.cpp
│       │   │       ├── netlink
│       │   │       │   ├── NetlinkConnection.cpp
│       │   │       │   ├── NetlinkConnection.h
│       │   │       │   ├── bionic_netlink.cpp
│       │   │       │   ├── bionic_netlink.h
│       │   │       │   ├── ifaddrs.cpp
│       │   │       │   ├── ifaddrs.h
│       │   │       │   ├── syscall32.s
│       │   │       │   ├── syscall64.s
│       │   │       │   ├── syscall_x86.s
│       │   │       │   └── syscall_x86_64.s
│       │   │       ├── network
│       │   │       │   └── NetworkManager.cpp
│       │   │       ├── utils
│       │   │       │   ├── Base64Utils.cpp
│       │   │       │   ├── CommandUtils.cpp
│       │   │       │   ├── DetectorUtils.cpp
│       │   │       │   ├── FileUtils.cpp
│       │   │       │   ├── MiscUtil.cpp
│       │   │       │   ├── StringUtils.cpp
│       │   │       │   ├── SyscallUtils.cpp
│       │   │       │   └── XsonCollector.cpp
│       │   │       ├── warlockCore.cpp
│       │   │       └── warlockServer.cpp
│       │   ├── ic_launcher-playstore.png
│       │   ├── java
│       │   │   └── com
│       │   │       └── xiaoc
│       │   │           └── warlock
│       │   │               ├── App.java
│       │   │               ├── BuildConfig.java
│       │   │               ├── Core
│       │   │               │   ├── BaseCollector.java
│       │   │               │   ├── BaseDetector.java
│       │   │               │   ├── CollectCallback.java
│       │   │               │   ├── DetectCallback.java
│       │   │               │   ├── EnvironmentDetector.java
│       │   │               │   ├── FingerprintCollector.java
│       │   │               │   ├── Warlock.java
│       │   │               │   ├── collector
│       │   │               │   │   ├── BasicInfoCollector.java
│       │   │               │   │   ├── MiscInfoCollector.java
│       │   │               │   │   ├── PhoneInfoCollector.java
│       │   │               │   │   ├── SignatureCollector.java
│       │   │               │   │   ├── StatInfoCollector.java
│       │   │               │   │   ├── SystemInfoCollector.java
│       │   │               │   │   └── WebViewInfoCollector.java
│       │   │               │   └── detector
│       │   │               │       ├── BootloaderStateChecker.java
│       │   │               │       ├── CloudPhoneDetector.java
│       │   │               │       ├── HookDetector.java
│       │   │               │       ├── MiscDetector.java
│       │   │               │       ├── RootDetector.java
│       │   │               │       ├── SandboxDetector.java
│       │   │               │       ├── SignatureDetector.java
│       │   │               │       ├── VirtualDetector.java
│       │   │               │       └── XposedDetector.java
│       │   │               ├── MainActivity.java
│       │   │               ├── Provider
│       │   │               │   └── AppProvider.java
│       │   │               ├── Util
│       │   │               │   ├── API.java
│       │   │               │   ├── AppChecker.java
│       │   │               │   ├── ClipboardUtil.java
│       │   │               │   ├── InfoValue.java
│       │   │               │   ├── MiscUtil.java
│       │   │               │   ├── NativeEngine.java
│       │   │               │   ├── WarningBuilder.java
│       │   │               │   ├── XCommandUtil.java
│       │   │               │   ├── XFile.java
│       │   │               │   ├── XLog.java
│       │   │               │   ├── XNetwork.java
│       │   │               │   ├── XString.java
│       │   │               │   ├── XTime.java
│       │   │               │   └── Xson.java
│       │   │               ├── crypto
│       │   │               │   ├── AESUtil.java
│       │   │               │   ├── Base64Util.java
│       │   │               │   ├── CompressUtil.java
│       │   │               │   ├── EncryptUtil.java
│       │   │               │   └── MD5Util.java
│       │   │               ├── manager
│       │   │               │   └── ServerManager.java
│       │   │               ├── network
│       │   │               │   └── NetworkClient.java
│       │   │               ├── service
│       │   │               │   └── WarLockServer.java
│       │   │               └── ui
│       │   │                   ├── MainUI.java
│       │   │                   ├── adapter
│       │   │                   │   ├── InfoAdapter.java
│       │   │                   │   ├── InfoItem.java
│       │   │                   │   └── ViewPagerAdapter.java
│       │   │                   ├── dialog
│       │   │                   │   └── DialogManager.java
│       │   │                   └── fragment
│       │   │                       ├── EnvironmentFragment.java
│       │   │                       └── FingerprintFragment.java
│       │   └── res
│       │       ├── drawable
│       │       │   ├── button_bg.xml
│       │       │   ├── ic_check_circle.xml
│       │       │   ├── ic_expand_more.xml
│       │       │   ├── ic_launcher_background.xml
│       │       │   ├── ic_launcher_foreground.xml
│       │       │   ├── ic_more_vert.xml
│       │       │   ├── ic_security.xml
│       │       │   └── rounded_card_bg.xml
│       │       ├── layout
│       │       │   ├── activity_main.xml
│       │       │   ├── dialog_settings.xml
│       │       │   ├── fragment_environment.xml
│       │       │   ├── fragment_fingerprint.xml
│       │       │   ├── item_detail.xml
│       │       │   ├── item_empty_state.xml
│       │       │   ├── item_info_card.xml
│       │       │   └── layout_menu_sheet.xml
│       │       ├── menu
│       │       │   ├── menu_main.xml
│       │       │   └── menu_popup.xml
│       │       ├── mipmap-anydpi-v26
│       │       │   ├── ic_launcher.xml
│       │       │   └── ic_launcher_round.xml
│       │       ├── mipmap-hdpi
│       │       │   ├── ic_launcher.webp
│       │       │   ├── ic_launcher_foreground.webp
│       │       │   └── ic_launcher_round.webp
│       │       ├── mipmap-mdpi
│       │       │   ├── ic_launcher.webp
│       │       │   ├── ic_launcher_foreground.webp
│       │       │   └── ic_launcher_round.webp
│       │       ├── mipmap-xhdpi
│       │       │   ├── ic_launcher.webp
│       │       │   ├── ic_launcher_foreground.webp
│       │       │   └── ic_launcher_round.webp
│       │       ├── mipmap-xxhdpi
│       │       │   ├── ic_launcher.webp
│       │       │   ├── ic_launcher_foreground.webp
│       │       │   └── ic_launcher_round.webp
│       │       ├── mipmap-xxxhdpi
│       │       │   ├── ic_launcher.webp
│       │       │   ├── ic_launcher_foreground.webp
│       │       │   └── ic_launcher_round.webp
│       │       ├── values
│       │       │   ├── colors.xml
│       │       │   ├── strings.xml
│       │       │   ├── styles.xml
│       │       │   └── themes.xml
│       │       ├── values-night
│       │       │   └── themes.xml
│       │       └── xml
│       │           ├── backup_rules.xml
│       │           └── data_extraction_rules.xml
│       └── test
│           └── java
│               └── com
│                   └── xiaoc
│                       └── warlock
│                           └── ExampleUnitTest.java
├── build.gradle
├── gradle
│   ├── libs.versions.toml
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── gradlew.bat
├── resource
│   ├── image-20250615152000063.png
│   ├── image-20250615152022446.png
│   └── warlock采集字段定义.txt
└── settings.gradle

```

`README.md`:

```md
## 一、项目背景

​	本项目始于2024年年底创建的GitHub仓库，经过5个月的开发已初步实现核心功能。当前版本的服务端代码完成于2025年5月初，此后项目进入维护阶段。出于代码质量考虑，服务端部分暂未开源，待后续迭代优化后将考虑开放源代码。

​	项目初衷源于实际业务中对抗黑灰产的需求。在日常工作中，频繁需要开发新的检测模块来应对各类安全威胁。然而，采用每次新建独立项目或集中堆砌代码的方式都存在明显弊端。为此，我决定开发一个统一的安全检测SDK，以系统化地解决这一问题。

​	需要说明的是，当前版本仍存在诸多不足，主要提供了一些基础检测功能。在实际业务场景中，由于合规要求等限制因素，某些定制化检测方案往往难以直接落地。因此，理想的解决方案是针对特定类型的黑灰产工具，开发通用检测机制并结合用户行为分析(UBA)进行精准防御。这也是项目未来的重点发展方向。

## 二、Warlock介绍

​	Warlock项目地址：https://github.com/imxiaoc996/DeviceWarLock （release版本在本文章附件以及GitHub仓库中）

Warlock设备指纹分为java层和native层指纹，java层共计80+采集信息，native层共计20+采集信息，采集完毕后他们会形成一个json保存在log里，设备环境检测主要有Root、Unlock、云手机、沙箱、注入等检测手段，以下是能力汇总：

### 2.1 设备指纹采集能力

1. **基础硬件与系统信息采集**

- 设备品牌、型号、序列号

- Android系统版本、系统指纹、CPU架构

- 时区、数据目录、内存、存储空间等

2. **设备唯一标识采集**

- Android ID、Google Advertising ID（AAID）

- IMEI、UUID、蓝牙地址、MAC地址等

- DRM ID、Boot ID、ReaperAssignedDeviceId等

3. **WebView与系统环境指纹**

- WebView的UserAgent、分辨率、像素密度、GPU信息、字体列表

- WebView版本、系统语言

4. **系统服务与应用信息**

- 已安装应用列表、系统服务列表

- 系统字体哈希、屏幕亮度、分辨率、超时时间

------

### 2.2 设备环境检测能力

1. **虚拟环境与仿真检测**

- 检测模拟器（如传感器数量、摄像头数量、模拟器特征属性等）

- 检查云手机、沙箱环境

2. **安全风险检测**

- Root检测、Xposed检测、Hook检测、Unlock检测

- 签名校验、系统完整性检测

3. **系统环境异常检测**

- 检查开发者选项、USB调试、VPN连接等

- 检查自定义ROM（如LineageOS）特征

4. **电池与硬件状态检测**

- 电池状态、传感器、摄像头等硬件环境检测

![](resource/image-20250615152000063.png)

![](resource/image-20250615152022446.png)

## 三、写在最后

​	本文内容较为精简，主要介绍开源项目 **Warlock**。我们后续计划推进改机相关项目，但当前的重点仍是完善 Warlock 的核心功能。

​	尽管 Warlock 在现有安全检测工具中可能功能尚不完善，但作为开源项目，它希望能为对安全检测技术感兴趣的同学提供一些参考和帮助。

​	我们承诺至少会维护并迭代该项目一年。如果你有更好的检测方法，项目出现bug，或发现项目中尚未涵盖的技术方案，欢迎一起探讨，共同进步！
```

`app/build.gradle`:

```gradle
plugins {
    alias(libs.plugins.android.application)

}

android {
    namespace 'com.xiaoc.warlock'
    compileSdk 34

    defaultConfig {
        applicationId "com.xiaoc.warlock"
        minSdk 24
        targetSdk 34
        versionCode 1
        versionName "1.0"
        ndk {
            abiFilters 'x86', 'armeabi-v7a', 'x86_64', 'arm64-v8a'
           // abiFilters 'armeabi' //, 'x86', 'armeabi-v7a', 'x86_64', 'arm64-v8a'
        }
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        externalNativeBuild {
            cmake {
                cppFlags ''
                targets "warlockCore", "warlockServer"  // 指定要构建的目标
                arguments "-DANDROID_STL=c++_shared"      // 使用共享 STL
            }
        }
    }
    buildFeatures {
        aidl true
        buildConfig false
    }
    
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
    externalNativeBuild {
        cmake {
            path file('src/main/cpp/CMakeLists.txt')
            version '3.22.1'
        }
    }
    ndkVersion '25.1.8937393'


}

dependencies {

    implementation 'com.google.android.material:material:1.5.0'
    implementation 'com.github.tiann:FreeReflection:3.1.0'
    implementation 'com.google.android.material:material:1.9.0'
    implementation 'com.tencent.bugly:crashreport:latest.release'
    implementation 'androidx.viewpager2:viewpager2:1.0.0'
    implementation 'com.google.android.gms:play-services-ads-identifier:18.0.1'
    implementation 'org.lsposed.hiddenapibypass:hiddenapibypass:4.3'
    implementation 'com.google.code.gson:gson:2.10.1'
    implementation 'com.squareup.okhttp3:okhttp:4.9.3'
    implementation 'org.bouncycastle:bcprov-jdk15to18:1.70'

    implementation libs.appcompat
    implementation libs.material
    implementation libs.activity
    implementation libs.constraintlayout
    testImplementation libs.junit
    androidTestImplementation libs.ext.junit
    androidTestImplementation libs.espresso.core

    // 添加StringFog运行时依赖
    implementation 'com.github.megatronking.stringfog:xor:5.0.0'
}
```

`app/proguard-rules.pro`:

```pro
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile
```

`app/src/androidTest/java/com/xiaoc/warlock/ExampleInstrumentedTest.java`:

```java
package com.xiaoc.warlock;

import android.content.Context;

import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.ext.junit.runners.AndroidJUnit4;

import org.junit.Test;
import org.junit.runner.RunWith;

import static org.junit.Assert.*;

/**
 * Instrumented test, which will execute on an Android device.
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
@RunWith(AndroidJUnit4.class)
public class ExampleInstrumentedTest {
    @Test
    public void useAppContext() {
        // Context of the app under test.
        Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
        assertEquals("com.xiaoc.warlock", appContext.getPackageName());
    }
}
```

`app/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">
    <uses-permission android:name="android.permission.READ_PHONE_STATE" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.READ_PRIVILEGED_PHONE_STATE" />
    <uses-permission android:name="android.permission.BLUETOOTH_CONNECT"/>
    <uses-permission android:name="android.permission.ACCESS_WIDEVINE_ID" />
    <uses-permission android:name="com.google.android.providers.gsf.permission.READ_GSERVICES" />
    <uses-permission android:name="android.permission.READ_PHONE_NUMBERS" />
    <uses-permission android:name="android.permission.READ_SMS" />
    <uses-permission android:name="com.google.android.gms.permission.AD_ID"/>
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.BATTERY_STATS" />
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.WRITE_SETTINGS"/>
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <uses-permission android:name = "android.permission.ACCESS_WIFI_STATE" />
    <uses-permission android:name="android.permission.GET_ACCOUNTS" />
    <uses-permission android:name="android.permission.LOCATION_HARDWARE" />
    <uses-permission android:name="android.permission.QUERY_ALL_PACKAGES" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>

    <!-- 用于获取音频设置的权限 -->
    <uses-permission android:name="android.permission.MODIFY_AUDIO_SETTINGS" />
    <application
        android:name=".App"
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme"
        tools:targetApi="31"
        android:usesCleartextTraffic="true">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:screenOrientation="portrait">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <provider
            android:name=".Provider.AppProvider"
            android:authorities="${applicationId}.initprovider"
            android:exported="false" />


<!--        <service-->
<!--            android:name=".service.WarLockServer"-->
<!--            android:isolatedProcess="true"-->
<!--            android:useAppZygote="true"-->
<!--            android:process=":isolated_warlock"/>-->
    </application>

</manifest>
```

`app/src/main/aidl/com/xiaoc/warlock/IServerCallback.aidl`:

```aidl
// IServerCallback.aidl
package com.xiaoc.warlock;

interface IServerCallback {
    void onSandboxDetected(String details);
      void ping();

}
```

`app/src/main/cpp/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.22.1)
project("warlockCore")
#添加内联支持
enable_language(C ASM)

# RapidJSON 相关配置
set(RAPIDJSON_BUILD_TESTS OFF CACHE BOOL "Build rapidjson tests" FORCE)
set(RAPIDJSON_BUILD_EXAMPLES OFF CACHE BOOL "Build rapidjson examples" FORCE)
set(RAPIDJSON_BUILD_DOC OFF CACHE BOOL "Build rapidjson documentation" FORCE)

include(FetchContent)
FetchContent_Declare(
        rapidjson
        GIT_REPOSITORY https://github.com/Tencent/rapidjson.git
        GIT_TAG master
)
FetchContent_MakeAvailable(rapidjson)

# 只支持ARM架构
if (${CMAKE_ANDROID_ARCH_ABI} STREQUAL "arm64-v8a")
    set(syscall src/netlink/syscall64.s)
elseif (${CMAKE_ANDROID_ARCH_ABI} STREQUAL "armeabi-v7a")
    set(syscall src/netlink/syscall32.s)
    elseif (${CMAKE_ANDROID_ARCH_ABI} STREQUAL "x86")
    set(syscall src/netlink/syscall_x86.s)
    elseif (${CMAKE_ANDROID_ARCH_ABI} STREQUAL "x86_64")
    set(syscall src/netlink/syscall_x86_64.s)
else()
    message(FATAL_ERROR "Unsupported architecture: ${CMAKE_ANDROID_ARCH_ABI}")
endif()

# 头文件目录
include_directories(
        inc/
        inc/collector/
        inc/utils/
        inc/netlink/
        inc/detector/
        inc/network/
        ${ANDROID_NDK}/sysroot/usr/include
        ${ANDROID_NDK}/sysroot/usr/include/${ANDROID_TOOLCHAIN_NAME}
)
file(GLOB CRYPTO_SOURCES "${CMAKE_CURRENT_SOURCE_DIR}/src/crypto/*.cpp")
file(GLOB UTILS_SOURCES "${CMAKE_CURRENT_SOURCE_DIR}/src/utils/*.cpp")
file(GLOB DETECTOR_SOURCES "${CMAKE_CURRENT_SOURCE_DIR}/src/detector/*.cpp")
file(GLOB COLLECTOR_SOURCES "${CMAKE_CURRENT_SOURCE_DIR}/src/collector/*.cpp")
file(GLOB NETWORK_SOURCES "${CMAKE_CURRENT_SOURCE_DIR}/src/network/*.cpp")

# 主库源文件
set(SOURCE_FILES
        src/warlockCore.cpp
        src/netlink/ifaddrs.cpp
        src/netlink/NetlinkConnection.cpp
        src/detector/SystemDetector.cpp
        ${DETECTOR_SOURCES}
        ${syscall}
        ${CRYPTO_SOURCES}
        ${UTILS_SOURCES}
        ${COLLECTOR_SOURCES}
        ${NETWORK_SOURCES}
)

# 隔离进程库源文件
set(ISOLATED_SOURCE_FILES
        src/detector/SandboxDetector.cpp
        src/warlockServer.cpp
)

# 添加两个库
add_library(warlockCore SHARED ${SOURCE_FILES})
add_library(warlockServer SHARED ${ISOLATED_SOURCE_FILES})

# 查找系统库
find_library(log-lib log)
find_library(mediandk-lib mediandk)

# 配置主库
target_include_directories(warlockCore PRIVATE ${rapidjson_SOURCE_DIR}/include)
target_link_libraries(warlockCore
        ${log-lib}
        ${mediandk-lib}
)

# 配置隔离进程库
target_link_libraries(warlockServer
        ${log-lib}
)
```

`app/src/main/cpp/inc/collector/BasicInfoCollector.h`:

```h
#ifndef WARLOCK_BASICINFOCOLLECTOR_H
#define WARLOCK_BASICINFOCOLLECTOR_H

#include "ICollector.h"
#include <media/NdkMediaDrm.h>

#include "../inc/utils/Base64Utils.h"
#include "../inc/utils/LogUtils.h"
#include "../inc/constants/Constants.h"
#include "utils/XsonCollector.h"
#include <media/NdkMediaDrm.h>
#include "../../src/netlink/bionic_netlink.h"
#include "../../src/netlink/ifaddrs.h"
#include "../utils/allheader.h"
#include <net/if.h>
class BasicInfoCollector : public ICollector {
public:
    ~BasicInfoCollector() override = default;
    void collect(std::map<std::string, std::string>& info) override;

private:
    void getDrmId(std::map<std::string, std::string>& info);
    void getNetworkInfo();
    bool getNetworkInfoLegacy();  // Android 10以下
    bool getNetworkInfoModern();  // Android 10及以上
    bool tryIoctlMethod();
    bool tryNetlinkMethod();
    void collectNetworkInterfaces();
};

#endif
```

`app/src/main/cpp/inc/collector/ICollector.h`:

```h
// inc/collector/ICollector.h
#ifndef WARLOCK_ICOLLECTOR_H
#define WARLOCK_ICOLLECTOR_H

#include "../utils/allheader.h"

class ICollector {
public:
    virtual ~ICollector() = default;
    virtual void collect(std::map<std::string, std::string>& info) = 0;
};

#endif
```

`app/src/main/cpp/inc/collector/MiscInfoCollector.h`:

```h
#ifndef WARLOCK_MISCINFOCOLLECTOR_H
#define WARLOCK_MISCINFOCOLLECTOR_H

#include "ICollector.h"
#include "../constants/Constants.h"
#include "../utils/XsonCollector.h"
#include "../inc/utils/SyscallUtils.h"
#include <sys/statfs.h>
#include <linux/magic.h>
#include <rapidjson/document.h>
#include <rapidjson/writer.h>
#include <rapidjson/stringbuffer.h>
#include <dlfcn.h>
#include <media/NdkMediaDrm.h>
#include <EGL/egl.h>
#include <fstream>

using namespace constants::fingerprint;
using namespace constants::path;

class MiscInfoCollector : public ICollector {
public:
    void collect(std::map<std::string, std::string>& info) override;
private:
    void collectServiceList();
    void collectStorageStats();
    void collectDrmId();
    void collectDirStats();
    void collectCpuInfo();
    void collectHardwareFeatures();
    void collectMemoryInfo();
};

#endif
```

`app/src/main/cpp/inc/collector/NativeCollector.h`:

```h
// inc/collector/NativeCollector.h
#ifndef WARLOCK_NATIVECOLLECTOR_H
#define WARLOCK_NATIVECOLLECTOR_H

#include "../utils/allheader.h"
#include "ICollector.h"
#include "utils/XsonCollector.h"
#include "crypto/EncryptManager.h"

class NativeCollector {
public:
    static NativeCollector* getInstance();
    void startCollect(JNIEnv* env, jobject callback);
    bool isCollectComplete() const;
    std::string getCollectedInfo() ;
    void cleanup();

private:
    NativeCollector();
    ~NativeCollector();
    
    static void* collectThread(void* arg);
    void collect();
    void notifyComplete();
    void initCollectors();
    void encryptCollectedInfo();

    static NativeCollector* instance;
    pthread_t threadId;
    bool isComplete;
    std::string rawInfo;
    std::map<std::string, std::string> collectedInfo;
    std::vector<std::unique_ptr<ICollector>> collectors;
    std::string encryptedInfo;  // 存储加密后的信息
    
    // 线程同步
    pthread_mutex_t mutex;
    
    // JNI回调相关
    JavaVM* javaVM;
    jobject globalCallback;
};

#endif
```

`app/src/main/cpp/inc/collector/SystemInfoCollector.h`:

```h
#ifndef WARLOCK_SYSTEMINFOCOLLECTOR_H
#define WARLOCK_SYSTEMINFOCOLLECTOR_H

#include "ICollector.h"
#include "../constants/Constants.h"
#include "../utils/XsonCollector.h"
#include "../utils/allheader.h"
#include "../constants/Constants.h"
using namespace constants::fingerprint;
using namespace constants::path;
extern "C" {
__attribute__((always_inline)) long raw_syscall(long number, ...);
}
class SystemInfoCollector : public ICollector {
public:
    void collect(std::map<std::string, std::string>& info) override;
    void collectProps();
private:
    std::string readBuildProp(const char* path);
    bool readFileContent(int fd, std::string& content);
    void collectBuildPropFile();
    void readSystemFile(const char* path, const char* fingerprintId);
    void collectDeviceID();
    void collectSystemVersion();
    std::string extractVersion(const std::string& input);
    void collectGetProp();
};

#endif
```

`app/src/main/cpp/inc/constants/Constants.h`:

```h
#ifndef WARLOCK_CONSTANTS_H
#define WARLOCK_CONSTANTS_H

#include <cstdint>
#include <sys/system_properties.h>
namespace constants {
    // DRM相关常量
    namespace drm {
        // Widevine UUID
        const uint8_t WIDEVINE_UUID[] = {
            0xed, 0xef, 0x8b, 0xa9, 0x79, 0xd6, 0x4a, 0xce,
            0xa3, 0xc8, 0x27, 0xdc, 0xd5, 0x1d, 0x21, 0xed
        };
        
        // DRM属性名

    }

    // 指纹Key常量
    namespace fingerprint {
        // 基础信息
        const char* const KEY_DRM_ID = "n1";
        const char* const SYSTEM_PROP_ID = "n2";
        const char* const NETWORK_INFO_ID = "n3";
        const char* const SYSTEM_BUILD_ID = "n4";
        const char* const ODM_ETC_BUILD_ID = "n5";
        const char* const PRODUCT_BUILD_ID = "n6";
        const char* const VENDOR_BUILD_ID = "n7";
        const char* const UUID_ID = "n8";
        const char* const CID_ID = "n9";
        const char* const SERIAL_NUMBER_ID = "n10";
        const char* const MISC_ID = "n11";
        const char* const BOOT_ID = "n12";
        const char* const SYSTEM_VERSION_ID = "n13";
        const char* const GET_PROPS_ID = "n14";
        const char* const NETWORK_INTERFACES_ID = "n15";
        const char* const SERVICE_LIST_ID = "n16";
        const char* const STORAGE_STATS_ID = "n17";
        const char* const DRM_ID_ID = "n18";
        // 新增指纹ID
        const char* const CPU_INFO_ID = "n19";
        const char* const HARDWARE_FEATURES_ID = "n20";
        const char* const MEMORY_INFO_ID = "n21";
    }

    // 文件路径常量
    namespace path {
        const char* const BUILD_PROP = "/system/build.prop";
        const char* const CPU_INFO = "/proc/cpuinfo";
        const char* const MEM_INFO = "/proc/meminfo";
        const char* const SYSTEM_BUILD_FILE = "/system/build.prop";
        const char* const ODM_ETC_BUILD_FILE = "/odm/etc/build.prop";
        const char* const PRODUCT_BUILD_FILE = "/product/build.prop";
        const char* const VENDOR_BUILD_FILE = "/vendor/build.prop";
        const char* const UUID_PATH = "/proc/sys/kernel/random/uuid";
        const char* const CID_PATH = "/sys/block/mmcblk0/device/cid";
        const char* const SERIAL_NUMBER_PATH = "/sys/devices/soc0/serial_number";
        const char* const MISC_PATH = "/proc/misc";
        const char* const BOOT_ID_PATH = "/proc/sys/kernel/random/boot_id";

    }

    // 命令常量
    namespace cmd {
        const char* const GET_PROP = "getprop";
        // ... 其他命令
    }
    namespace system_props {
        // 常见系统属性数组
        static const char* const COMMON_PROPS[] = {
                "ro.build.version.sdk",
                "ro.build.version.release",
                "ro.product.model",
                "ro.product.brand",
                "ro.boot.bootloader",
                "ro.build.version.securitypatch",
                "ro.build.version.incremental",
                "gsm.version.baseband",
                "gsm.version.ril-impl",
                "ro.build.fingerprint",
                "ro.build.description",
                "ro.build.product",
                "ro.boot.vbmeta.digest",
                "ro.hardware",
                "ro.product.name",
                "ro.product.board",
                "ro.recovery_id",
                "ro.expect.recovery_id",
                "ro.board.platform",
                "ro.product.manufacturer",
                "ro.product.device",
                "ro.odm.build.id",
                "sys.usb.state",
                "ro.setupwizard.mode",
                "ro.build.id",
                "ro.build.tags",
                "ro.build.type",
                "ro.debuggable",
                "persist.sys.meid"
        };

        // 不常见系统属性数组
        static const char* const RARE_PROPS[] = {
                "vendor.serialno",
                "sys.serialno",
                "persist.sys.wififactorymac",
                "ro.boot.deviceid",
                "ro.rpmb.board",
                "ro.vold.serialno",
                "persist.oppo.wlan.macaddress",
                "persist.sys.oppo.serialno",
                "ril.serialnumber",
                "ro.boot.ap_serial",
                "ro.boot.uniqueno",
                "persist.sys.oppo.opmuuid",
                "persist.sys.oppo.nlp.id",
                "persist.sys.oplus.nlp.id",
                "persist.sys.dcs.hash",
                "ro.ril.oem.sno",
                "ro.ril.oem.psno",
                "persist.vendor.sys.fp.uid",
                "ro.ril.miui.imei0",
                "ro.ril.miui.imei1",
                "ro.ril.oem.imei",
                "ro.ril.oem.meid",
                "persist.radio.imei",
                "persist.radio.imei1",
                "persist.radio.imei2",
                "persist.sys.lite.uid",
                "persist.radio.serialno",
                "vendor.boot.serialno",
                "persist.sys.oneplus.serialno",
                "ro.meizu.hardware.imei1",
                "ro.meizu.hardware.imei2",
                "ro.meizu.hardware.meid",
                "ro.meizu.hardware.psn",
                "ro.meizu.hardware.sn",
                "persist.radio.factory_phone_sn",
                "persist.radio.factory_sn",
                "ro.meizu.serialno",
                "ro.boot.psn",
                "ro.boot.meid",
                "ro.boot.imei1",
                "ro.boot.imei2",
                "ro.wifimac",
                "ro.wifimac_2",
                "ro.vendor.deviceid",
                "ro.isn",
                "ro.vendor.isn",
                "persist.radio.device.imei",
                "persist.radio.device.imei2",
                "persist.radio.device.meid",
                "persist.radio.device.meid2",
                "persist.asus.serialno",
                "sys.wifimac",
                "sys.bt.address",
                "persist.btpw.bredr",
                "persist.radio.imei",
                "persist.radio.imei2",
                "persist.radio.meid",
                "persist.radio.meid2",
                "ro.boot.fpd.uid",
                "ro.vendor.boot.serialno",
                "ro.boot.wifimacaddr",
                "persist.sys.wifi.mac",
                "persist.sys.wifi_mac",
                "sys.prop.writeimei",
                "ril.gm.imei",
                "ril.cdma.meid",
                "ro.boot.em.did",
                "ro.qchip.serialno",
                "ro.ril.oem.btmac",
                "ro.ril.oem.ifimac"
        };

        // 获取数组大小的辅助函数
        constexpr size_t COMMON_PROPS_SIZE = sizeof(COMMON_PROPS) / sizeof(COMMON_PROPS[0]);
        constexpr size_t RARE_PROPS_SIZE = sizeof(RARE_PROPS) / sizeof(RARE_PROPS[0]);
    }
}

#endif
```

`app/src/main/cpp/inc/crypto/EncryptManager.h`:

```h
#ifndef DEVICEWARLOCK_ENCRYPTMANAGER_H
#define DEVICEWARLOCK_ENCRYPTMANAGER_H

#include <string>
#include <vector>
#include <android/log.h>
#include "crypto.h"

class EncryptManager {
public:
    static EncryptManager* getInstance();
    std::string encryptData(const std::string& data);

private:
    EncryptManager();
    ~EncryptManager();
    static EncryptManager* instance;
    
    // 加密相关
    std::string generateUUID();
    std::string generateTimestamp();
    std::string generateSalt(const std::string& uuid, const std::string& timestamp);
    std::string generateKey(const std::string& uuid, const std::string& timestamp, const std::string& salt);
    std::string generateAESKey(const std::string& salt);
    unsigned char generateSum(const std::string& salt);
    std::string insertKey(const std::string& base64Result, const std::string& key, unsigned char sum);
    
    // 加密上下文
    MD5_CTX md5_ctx;
    AES_CTX aes_ctx;
};

#endif //DEVICEWARLOCK_ENCRYPTMANAGER_H 
```

`app/src/main/cpp/inc/crypto/crypto.h`:

```h
#ifndef CRYPTO_NATIVE_H
#define CRYPTO_NATIVE_H

#include <jni.h>
#include <stdint.h>
#include <string.h>

// MD5相关结构体
typedef struct {
    uint32_t state[4];
    uint32_t count[2];
    uint8_t buffer[64];
} MD5_CTX;

// MD5函数声明
void MD5Init(MD5_CTX *context);
void MD5Update(MD5_CTX *context, const uint8_t *input, size_t inputLen);
void MD5Final(uint8_t digest[16], MD5_CTX *context);
// AES 相关定义
#define AES_BLOCK_SIZE 16
#define AES_ROUNDS 10

typedef struct {
    uint32_t round_key[4 * (AES_ROUNDS + 1)];
} AES_CTX;

void AES_init(AES_CTX *ctx, const uint8_t *key);
void AES_encrypt_block(const AES_CTX *ctx, const uint8_t *input, uint8_t *output);
void AES_decrypt_block(const AES_CTX *ctx, const uint8_t *input, uint8_t *output);
void AES_encrypt_with_padding(const AES_CTX *ctx, const uint8_t *input, size_t length, uint8_t *output, size_t *output_length);
void AES_decrypt_with_padding(const AES_CTX *ctx, const uint8_t *input, size_t length, uint8_t *output, size_t *output_length);
void generate_inverse_sbox();

// Base64相关函数声明
size_t BASE64_encode_len(size_t input_length);
void BASE64_encode(const uint8_t *input, size_t input_length, char *output);
size_t BASE64_decode_len(const char *input);
int BASE64_decode(const char *input, size_t input_length, uint8_t *output, size_t *output_length);
char* BASE64_encode_alloc(const uint8_t *input, size_t input_length, size_t *output_length);
uint8_t* BASE64_decode_alloc(const char *input, size_t input_length, size_t *output_length);
#endif
```

`app/src/main/cpp/inc/detector/FridaDetector.h`:

```h
#ifndef WARLOCK_FRIDADETECTOR_H
#define WARLOCK_FRIDADETECTOR_H

#include <jni.h>
#include <string>
#include <unistd.h>
#include <sys/syscall.h>
#include "IDetector.h"
#include "../../inc/utils/DetectorUtils.h"
#include "../../inc/utils/LogUtils.h"
#include <sys/prctl.h>
#include <linux/sched.h>
#include <errno.h>
#include <string.h>
#include <sys/socket.h>
#include <linux/in.h>
#include <sys/endian.h>
#include <set>
#include <sys/wait.h>
#include "../../inc/utils/SyscallUtils.h"
#include <vector>
#include "../utils/allheader.h"
#include <bits/glibc-syscalls.h>
class FridaDetector: public IDetector {
private:
    static const std::string CHECK_FRIDA;

    volatile bool isRunning;
    pthread_t threadId;
    JavaVM* javaVM;
    jobject globalCallback;

    // 添加检测状态
    std::set<int> detectedPorts;
    bool isAbnormalStateReported;
    void cleanup();
    static void* threadFunction(void* arg);
    void detectFridaPorts(JNIEnv* env);
    void resetDetectionState();
    void detectFridaFile(JNIEnv* env);
    void detectFridaInMaps(JNIEnv* env);
    bool isMapsAbnormalReported;
public:
    FridaDetector();
    ~FridaDetector() override;

    void detect(JNIEnv* env, jobject callback) override;
    void stop();
};

#endif
```

`app/src/main/cpp/inc/detector/MiscDetector.h`:

```h
#ifndef WARLOCK_MISCDETECTOR_H
#define WARLOCK_MISCDETECTOR_H

#include <jni.h>
#include <string>
#include "IDetector.h"
#include "../../inc/utils/DetectorUtils.h"
#include "../../inc/utils/LogUtils.h"
#include "../../inc/utils/SyscallUtils.h"
#include "../utils/StringUtils.h"
#include "../utils/allheader.h"
#include <linux/prctl.h>
#include <sys/prctl.h>
class MiscDetector : public IDetector {
private:
    static const std::string CHECK_MISC;

    JavaVM* javaVM;
    jobject globalCallback;
    volatile bool isRunning;
    pthread_t threadId;

    // 检测状态标志
    bool isPathCheckReported;
    bool isMapsCheckReported;

    // 线程相关
    static void* threadFunction(void* arg);
    void cleanup();
    void resetDetectionState();

    // 具体检测方法
    void detectSomething(JNIEnv* env);  // 示例方法，可以根据需要添加更多
    void detectPathExistence(JNIEnv* env);  // 添加路径检测方法
    void detectTmpInMaps(JNIEnv* env);

public:
    MiscDetector();
    ~MiscDetector() override;

    void detect(JNIEnv* env, jobject callback) override;
    void stop();
};

#endif
```

`app/src/main/cpp/inc/detector/NativeDetector.h`:

```h
#ifndef WARLOCK_NATIVEDETECTOR_H
#define WARLOCK_NATIVEDETECTOR_H

#include <jni.h>
#include <vector>
#include <memory>
#include "IDetector.h"
#include "FridaDetector.h"
#include "VirtualDetector.h"
#include "MiscDetector.h"
#include "SystemDetector.h"
class NativeDetector {
public:
    static NativeDetector* getInstance();
    void startDetect(JNIEnv* env, jobject callback);
    void cleanup();

private:
    NativeDetector();
    ~NativeDetector();

    void detect();
    void initDetectors();
    JNIEnv* getEnv();

    static NativeDetector* instance;
    std::vector<std::unique_ptr<IDetector>> detectors;

    JavaVM* javaVM;
    jobject globalCallback;
};

#endif
```

`app/src/main/cpp/inc/detector/SandboxDetector.h`:

```h
//
// Created by 17267 on 2024-12-17.
//

#ifndef WARLOCK_SANDBOXDETECTOR_H
#define WARLOCK_SANDBOXDETECTOR_H
#include <jni.h>
#include <string>
#include <dirent.h>
#include <unistd.h>
#include <sys/types.h>
#include <dlfcn.h>
#include "../utils/LogUtils.h"
class SandboxDetector {
private:
    typedef DIR* (*OpenDir)(const char*);
    typedef struct dirent* (*ReadDir)(DIR*);

    static std::string getLibcPath();
    static void getNameByPid(pid_t pid, char* buff);
    static void* replaceSecInsns(const char* libPath, const char* symbol);
    static void notifyDetection(JNIEnv* env, jobject thiz, const std::string& details);
    static void checkProcessByProc(JNIEnv* env, jobject thiz);
public:
    static void checkSandbox(JNIEnv* env, jobject thiz);
    static void checkProcessByPs(JNIEnv* env, jobject thiz);

};

#endif //WARLOCK_SANDBOXDETECTOR_H

```

`app/src/main/cpp/inc/detector/SystemDetector.h`:

```h
#ifndef WARLOCK_SYSTEMDETECTOR_H
#define WARLOCK_SYSTEMDETECTOR_H

#include "IDetector.h"
#include "../utils/allheader.h"
#include "../utils/LogUtils.h"
#include "../utils/DetectorUtils.h"
#include "../crypto/crypto.h"
#include <sys/system_properties.h>
#include <fstream>

class SystemDetector : public IDetector {
public:
    virtual ~SystemDetector() = default;
    void detect(JNIEnv* env, jobject callback) override;

private:
    static const std::string CHECK_SYSTEM;

    bool checkDmVerity();
    bool checkSystemPartition();
    std::string calculateSystemHash();
    bool checkAVB();
    std::string getSystemDetails();
};

#endif
```

`app/src/main/cpp/inc/detector/VirtualDetector.h`:

```h
#ifndef WARLOCK_VIRTUALDETECTOR_H
#define WARLOCK_VIRTUALDETECTOR_H

#include "IDetector.h"
#include "../utils/LogUtils.h"
#include "../utils/MiscUtil.h"
#include <linux/seccomp.h>
#include <linux/filter.h>
#include <linux/audit.h>
#include <sys/prctl.h>
#include <errno.h>
#include "allheader.h"
#include "../utils/StringUtils.h"
#include "../utils/DetectorUtils.h"
#include <sys/system_properties.h>

class VirtualDetector : public IDetector {
public:
    void detect(JNIEnv* env, jobject callback) override;

private:
    static const std::string CHECK_BRAND_SERVICES;

    static const std::string CHECK_VIRTUAL;
    static const std::string CHECK_THERMAL;
    static const std::string CHECK_PROCESS;
    static const int DetectX86Flag = 0x12345678;
    static const int MIN_THERMAL_ZONES = 2;
    static const int MAX_NORMAL_PROCESS = 2;

    void install_check_arch_seccomp();
    std::string check_arch_by_seccomp();
    void detectArch(JNIEnv* env, jobject callback);
    void detectThermal(JNIEnv* env, jobject callback);  // 新增温度检测方法
    int check_thermal_zones();  // 新增温度区检测方法
    void detectProcess(JNIEnv* env, jobject callback);  // 新增进程检测方法
    void detectBrandServices(JNIEnv* env, jobject callback);
    void checkServices(const char* services[], size_t count,
                       std::string& missingServices, bool& isAbnormal);
    bool checkServiceExists(const char* serviceName);
    std::string getServiceList();

};

#endif
```

`app/src/main/cpp/inc/network/NetworkManager.h`:

```h
#ifndef DEVICEWARLOCK_NETWORKMANAGER_H
#define DEVICEWARLOCK_NETWORKMANAGER_H

#include <string>

class NetworkManager {
public:
    static NetworkManager* getInstance();
    bool sendData(const std::string& encryptedData);

private:
    NetworkManager() = default;
    ~NetworkManager() = default;
    static NetworkManager* instance;
};

#endif //DEVICEWARLOCK_NETWORKMANAGER_H 
```

`app/src/main/cpp/inc/utils/Base64Utils.h`:

```h
#ifndef WARLOCK_BASE64UTILS_H
#define WARLOCK_BASE64UTILS_H

#include <string>

class Base64Utils {
public:
    static std::string Encode(const uint8_t* input, size_t length);
    static std::string Decode(const std::string& input);
};

#endif
```

`app/src/main/cpp/inc/utils/CommandUtils.h`:

```h

#ifndef WARLOCK_COMMANDUTILS_H
#define WARLOCK_COMMANDUTILS_H

#include <string>

namespace utils {
    class CommandUtils {
    public:
        static std::string execCommand(const char* cmd);
    private:
        static long syscall(long number, ...);
    };
}

#endif
```

`app/src/main/cpp/inc/utils/DetectorUtils.h`:

```h
#ifndef WARLOCK_DETECTORUTILS_H
#define WARLOCK_DETECTORUTILS_H

#include <string>
#include <jni.h>

class DetectorUtils {
public:
    static constexpr const char* LEVEL_HIGH = "high";
    static constexpr const char* LEVEL_MEDIUM = "medium";
    static constexpr const char* LEVEL_LOW = "low";

    static void reportWarning(JNIEnv* env, jobject callback,
                              const std::string& type,
                              const std::string& level,
                              const std::string& detail);
};

#endif
```

`app/src/main/cpp/inc/utils/FileUtils.h`:

```h

#ifndef WARLOCK_FILEUTILS_H
#define WARLOCK_FILEUTILS_H

#include <string>
#include <unistd.h>
#include <fcntl.h>
#include <sys/syscall.h>

namespace utils {
    class FileUtils {
    public:
        static int openFile(const char* path, int flags);
        static ssize_t readFile(int fd, void* buf, size_t count);
        static int closeFile(int fd);
        static std::string readFileAsString(const char* path);
    private:
        static long syscall(long number, ...);
    };
}

#endif
```

`app/src/main/cpp/inc/utils/IDetector.h`:

```h
#ifndef WARLOCK_IDETECTOR_H
#define WARLOCK_IDETECTOR_H

#include <jni.h>

class IDetector {
public:
    virtual ~IDetector() = default;
    virtual void detect(JNIEnv* env, jobject callback) = 0;
};

#endif // WARLOCK_IDETECTOR_H//
// Created by 17267 on 2024-12-24.
//

#ifndef WARLOCK_IDETECTOR_H
#define WARLOCK_IDETECTOR_H

#endif //WARLOCK_IDETECTOR_H

```

`app/src/main/cpp/inc/utils/LogUtils.h`:

```h

#ifndef WARLOCK_LOGUTILS_H
#define WARLOCK_LOGUTILS_H

#include <android/log.h>

#define TAG "WarlockNative"

#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__)
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, TAG, __VA_ARGS__)
#define LOGW(...) __android_log_print(ANDROID_LOG_WARN, TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__)

#endif
```

`app/src/main/cpp/inc/utils/MiscUtil.h`:

```h
#ifndef WARLOCK_SYSTEMUTILS_H
#define WARLOCK_SYSTEMUTILS_H

#include <string>
#include <jni.h>

namespace MiscUtil {
    class SystemUtils {
    public:
        static int getSDKLevel();
        static void init(JNIEnv* env);

    private:
        static int sdkLevel;
        static bool isInitialized;
    };
}

#endif // WARLOCK_SYSTEMUTILS_H
```

`app/src/main/cpp/inc/utils/StringUtils.h`:

```h

#ifndef WARLOCK_STRINGUTILS_H
#define WARLOCK_STRINGUTILS_H

#include <string>
#include <vector>

namespace utils {
    class StringUtils {
    public:
        static bool isEmpty(const std::string& str);
        static std::string trim(const std::string& str);
        static std::vector<std::string> split(const std::string& str, const std::string& delim);
        static std::string join(const std::vector<std::string>& vec, const std::string& delim);
        static bool contains(const std::string& str, const std::string& substr);
        static bool containsManual(const char* str, const char* pattern);
        static bool containsBM(const char* text, const char* pattern);
        static bool containsBytes(const char* str, const char* pattern);
        static bool containsSafe(const std::string& text, const std::string& pattern);

    };
}

#endif
```

`app/src/main/cpp/inc/utils/SyscallUtils.h`:

```h

#ifndef WARLOCK_SYSCALLUTILS_H
#define WARLOCK_SYSCALLUTILS_H

#include <sys/syscall.h>
#include "allheader.h"
namespace utils {
    class SyscallUtils {
    public:
        static long syscall(long number, ...);
    private:
        #if defined(__aarch64__)
        static long syscall_aarch64(long number, long arg1, long arg2, long arg3);
        #elif defined(__arm__)
        static long syscall_arm(long number, long arg1, long arg2, long arg3);
        #elif defined(__x86_64__)
        static long syscall_x86_64(long number, long arg1, long arg2, long arg3);
        #elif defined(__i386__)
        static long syscall_x86(long number, long arg1, long arg2, long arg3);
        #endif
    };
}

#endif
```

`app/src/main/cpp/inc/utils/XsonCollector.h`:

```h
// inc/utils/XsonCollector.h
#ifndef WARLOCK_XSONCOLLECTOR_H
#define WARLOCK_XSONCOLLECTOR_H

#include <string>
#include <map>
#include "rapidjson/document.h"
#include "rapidjson/writer.h"
#include "rapidjson/stringbuffer.h"
#include "rapidjson/document.h"
#include "rapidjson/prettywriter.h"
class XsonCollector {
public:
    static XsonCollector* getInstance();


    void put(const std::string& key, const std::string& value);
    void putFailed(const std::string& key);
    void putNotCollected(const std::string& key);
    std::string toString();
    void clear();

private:
    XsonCollector();
    ~XsonCollector();

    static XsonCollector* instance;
    rapidjson::Document doc;  // 使用 RapidJSON 的 Document
};

#endif
```

`app/src/main/cpp/inc/utils/allheader.h`:

```h
//
// Created by 17267 on 2024-12-15.
//

#ifndef WARLOCK_ALLHEADER_H
#define WARLOCK_ALLHEADER_H
//导入常见的头文件
#include <string.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <string>
#include <map>
#include <list>
#include <jni.h>
#include <dlfcn.h>
#include <stddef.h>
#include <fcntl.h>
#include <dirent.h>
#include <cstring>
#include <cstdio>
#include <unistd.h>
#include <stdlib.h>
#include <syscall.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <jni.h>
#include <dlfcn.h>
#include <android/log.h>
#include <malloc.h>
#include <regex>
#include <bits/getopt.h>
#include <asm/unistd.h>
#include <unistd.h>
#include <asm/fcntl.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <jni.h>
#include <dlfcn.h>
#include <android/log.h>
#include <malloc.h>
#include <regex>
#include <bits/getopt.h>
#include <asm/unistd.h>
#include <unistd.h>
#include <asm/fcntl.h>
#include "limits.h"
#include <string.h>
#include <cerrno>
#include <cstring>
#include <climits>
#include "syscall.h"
#include <cstring>
#include <cstdio>
#include <unistd.h>
#include <stdlib.h>
#include <syscall.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <jni.h>
#include <dlfcn.h>
#include <android/log.h>
#include <malloc.h>
#include <regex>
#include <bits/getopt.h>
#include <asm/unistd.h>
#include <unistd.h>
#include <asm/fcntl.h>
#include <fcntl.h>
#include <jni.h>
#include <dlfcn.h>
#include <android/log.h>
#include <malloc.h>
#include <stdbool.h>
#include <stdlib.h>
#include <stdio.h>
#include <regex>
#include <bits/getopt.h>
#include <asm/unistd.h>
#include <unistd.h>
#include <asm/fcntl.h>
#include<fcntl.h>
#include<sys/types.h>
#include<sys/stat.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sstream>
#include <sys/utsname.h>
#include <linux/fcntl.h>
#include <dirent.h>
#include <sys/syscall.h>
#include <bits/glibc-syscalls.h>
#endif //WARLOCK_ALLHEADER_H

```

`app/src/main/cpp/inc/warlockCore.h`:

```h
// warlockCore.h

#ifndef WARLOCK_WARLOCKCORE_H
#define WARLOCK_WARLOCKCORE_H

#include <jni.h>
#include <string>
#include <cstring>
#include <stdio.h>
#include <fcntl.h>
#include "../inc/collector/NativeCollector.h"
#include "../inc/detector/NativeDetector.h"
#ifdef __cplusplus
extern "C" {
#endif

JNIEXPORT jstring JNICALL
Java_com_xiaoc_warlock_Util_NativeEngine_popen(JNIEnv *env, jobject /* obj */, jstring command);
JNIEXPORT jint JNICALL
Java_com_xiaoc_warlock_Util_NativeEngine_open(JNIEnv *env, jobject /* obj */, jstring path, jint flags);
JNIEXPORT void JNICALL
Java_com_xiaoc_warlock_Util_NativeEngine_startCollect(JNIEnv *env, jclass clazz, jobject callback);

JNIEXPORT jstring JNICALL
Java_com_xiaoc_warlock_Util_NativeEngine_getCollectedInfo(JNIEnv *env, jclass clazz);
JNIEXPORT void JNICALL
Java_com_xiaoc_warlock_Util_NativeEngine_startDetect(JNIEnv *env, jclass /* clazz */, jobject callback);
JNIEXPORT void JNICALL
Java_com_xiaoc_warlock_Util_NativeEngine_stopDetect(JNIEnv *env, jclass /* clazz */);
#ifdef __cplusplus
}
#endif

#endif // WARLOCK_WARLOCKCORE_H
```

`app/src/main/cpp/src/collector/BasicInfoCollector.cpp`:

```cpp
// src/collector/BasicInfoCollector.cpp
#include "../inc/collector/BasicInfoCollector.h"


using namespace constants;

void BasicInfoCollector::getDrmId(std::map<std::string, std::string>& info) {
    try {
        AMediaDrm* mediaDrm = AMediaDrm_createByUUID(drm::WIDEVINE_UUID);
        if (!mediaDrm) {
            LOGE("Failed to create MediaDrm instance");
            XsonCollector::getInstance()->putFailed(fingerprint::KEY_DRM_ID);
            return;
        }

        AMediaDrmByteArray deviceId;
        media_status_t status = AMediaDrm_getPropertyByteArray(
            mediaDrm,
            PROPERTY_DEVICE_UNIQUE_ID,
            &deviceId
        );

        if (status == AMEDIA_OK) {
            std::string result = Base64Utils::Encode(
                reinterpret_cast<const uint8_t*>(deviceId.ptr),
                deviceId.length
            );
            XsonCollector::getInstance()->put(fingerprint::KEY_DRM_ID, result);
        } else {
            LOGE("Failed to get DRM device ID, status: %d", status);
            XsonCollector::getInstance()->putFailed(fingerprint::KEY_DRM_ID);
        }

        AMediaDrm_release(mediaDrm);
    } catch (const std::exception& e) {
        LOGE("Error collecting DRM ID: %s", e.what());
        XsonCollector::getInstance()->putFailed(fingerprint::KEY_DRM_ID);
    }
}
// BasicInfoCollector.cpp
void BasicInfoCollector::getNetworkInfo() {
    bool success = false;
    rapidjson::Document doc;
    doc.SetObject();
    auto& allocator = doc.GetAllocator();
    rapidjson::Value networkInfo(rapidjson::kObjectType);

    if (android_get_device_api_level() >= 29) {  // Android 10及以上
        success = getNetworkInfoModern();
    } else {
        success = getNetworkInfoLegacy();
    }

    if (!success) {
        XsonCollector::getInstance()->putFailed(constants::fingerprint::NETWORK_INFO_ID);
        return;
    }
}

bool BasicInfoCollector::getNetworkInfoLegacy() {
    struct ifaddrs *ifap, *ifaptr;
    rapidjson::Document doc;
    doc.SetObject();
    auto& allocator = doc.GetAllocator();
    rapidjson::Value networkInfo(rapidjson::kObjectType);

    if (myGetifaddrs(&ifap) != 0) {
        return false;
    }

    bool hasValidInterface = false;
    for (ifaptr = ifap; ifaptr != nullptr; ifaptr = ifaptr->ifa_next) {
        if (ifaptr->ifa_addr != nullptr) {
            sa_family_t family = ifaptr->ifa_addr->sa_family;
            if (family == AF_PACKET) {
                auto *sockadd = (struct sockaddr_ll *) (ifaptr->ifa_addr);
                char mac[18] = {0};
                int len = 0;
                for (int i = 0; i < 6; i++) {
                    len += sprintf(mac + len, "%02X%s",
                                   sockadd->sll_addr[i], (i < 5 ? ":" : ""));
                }

                rapidjson::Value interfaceName(ifaptr->ifa_name, allocator);
                rapidjson::Value macAddr(mac, allocator);
                networkInfo.AddMember(interfaceName, macAddr, allocator);
                hasValidInterface = true;
            }
        }
    }
    freeifaddrs(ifap);

    if (!hasValidInterface) {
        return false;
    }

    rapidjson::StringBuffer buffer;
    rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
    doc.SetObject();
    doc.AddMember("s", 0, allocator);
    doc.AddMember("v", networkInfo, allocator);
    doc.Accept(writer);

    XsonCollector::getInstance()->put(
            constants::fingerprint::NETWORK_INFO_ID,
            buffer.GetString()
    );
    return true;
}

bool BasicInfoCollector::getNetworkInfoModern() {
    // 先尝试 netlink 方式
    if (tryNetlinkMethod()) {
        return true;
    }

    // netlink 失败则尝试 ioctl
    return tryIoctlMethod();
}

bool BasicInfoCollector::tryNetlinkMethod() {
    int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
    if (sock < 0) {
        return false;
    }

    struct {
        struct nlmsghdr nh;
        struct ifinfomsg ifi;
        char attrbuf[512];
    } req;

    memset(&req, 0, sizeof(req));
    req.nh.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));
    req.nh.nlmsg_type = RTM_GETLINK;
    req.nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP;
    req.ifi.ifi_family = AF_UNSPEC;

    if (send(sock, &req, req.nh.nlmsg_len, 0) < 0) {
        close(sock);
        return false;
    }

    rapidjson::Document doc;
    doc.SetObject();
    auto& allocator = doc.GetAllocator();
    rapidjson::Value networkInfo(rapidjson::kObjectType);
    bool hasValidInterface = false;

    char buf[8192];
    while (true) {
        int len = recv(sock, buf, sizeof(buf), 0);
        if (len < 0) {
            break;
        }

        struct nlmsghdr* h = (struct nlmsghdr*)buf;
        for (; NLMSG_OK(h, len); h = NLMSG_NEXT(h, len)) {
            if (h->nlmsg_type == NLMSG_DONE) {
                goto done;
            }

            if (h->nlmsg_type == RTM_NEWLINK) {
                struct ifinfomsg* ifi = (struct ifinfomsg*)NLMSG_DATA(h);
                struct rtattr* rta = IFLA_RTA(ifi);
                int rtl = IFLA_PAYLOAD(h);

                char ifname[IF_NAMESIZE] = {0};
                char mac[18] = {0};
                bool got_mac = false;

                for (; RTA_OK(rta, rtl); rta = RTA_NEXT(rta, rtl)) {
                    if (rta->rta_type == IFLA_ADDRESS) {
                        unsigned char* data = (unsigned char*)RTA_DATA(rta);
                        sprintf(mac, "%02X:%02X:%02X:%02X:%02X:%02X",
                                data[0], data[1], data[2],
                                data[3], data[4], data[5]);
                        got_mac = true;
                    } else if (rta->rta_type == IFLA_IFNAME) {
                        strncpy(ifname, (char*)RTA_DATA(rta), IF_NAMESIZE - 1);
                    }
                }

                if (got_mac && strlen(ifname) > 0) {
                    rapidjson::Value interfaceName(ifname, allocator);
                    rapidjson::Value macAddr(mac, allocator);
                    networkInfo.AddMember(interfaceName, macAddr, allocator);
                    hasValidInterface = true;
                }
            }
        }
    }

    done:
    close(sock);

    if (!hasValidInterface) {
        return false;
    }

    rapidjson::StringBuffer buffer;
    rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
    doc.AddMember("s", 0, allocator);
    doc.AddMember("v", networkInfo, allocator);
    doc.Accept(writer);

    XsonCollector::getInstance()->put(
            constants::fingerprint::NETWORK_INFO_ID,
            buffer.GetString()
    );
    return true;
}

bool BasicInfoCollector::tryIoctlMethod() {
    int sock = socket(AF_INET, SOCK_DGRAM, 0);
    if (sock < 0) {
        return false;
    }

    rapidjson::Document doc;
    doc.SetObject();
    auto& allocator = doc.GetAllocator();
    rapidjson::Value networkInfo(rapidjson::kObjectType);
    bool hasValidInterface = false;

    // 尝试常见的网卡接口
    const char* interfaces[] = {"wlan0", "eth0", "rmnet0"};
    for (const char* ifname : interfaces) {
        struct ifreq ifr;
        memset(&ifr, 0, sizeof(ifr));
        strcpy(ifr.ifr_name, ifname);

        if (ioctl(sock, SIOCGIFHWADDR, &ifr) >= 0) {
            char mac[18];
            sprintf(mac, "%02X:%02X:%02X:%02X:%02X:%02X",
                    (unsigned char)ifr.ifr_hwaddr.sa_data[0],
                    (unsigned char)ifr.ifr_hwaddr.sa_data[1],
                    (unsigned char)ifr.ifr_hwaddr.sa_data[2],
                    (unsigned char)ifr.ifr_hwaddr.sa_data[3],
                    (unsigned char)ifr.ifr_hwaddr.sa_data[4],
                    (unsigned char)ifr.ifr_hwaddr.sa_data[5]);

            rapidjson::Value interfaceName(ifname, allocator);
            rapidjson::Value macAddr(mac, allocator);
            networkInfo.AddMember(interfaceName, macAddr, allocator);
            hasValidInterface = true;
        }
    }

    close(sock);

    if (!hasValidInterface) {
        return false;
    }

    rapidjson::StringBuffer buffer;
    rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
    doc.AddMember("s", 0, allocator);
    doc.AddMember("v", networkInfo, allocator);
    doc.Accept(writer);

    XsonCollector::getInstance()->put(
            constants::fingerprint::NETWORK_INFO_ID,
            buffer.GetString()
    );
    return true;
}
void BasicInfoCollector::collectNetworkInterfaces() {
    FILE* fp = popen("ip a", "r");
    if (!fp) {
        XsonCollector::getInstance()->putFailed(
                constants::fingerprint::NETWORK_INTERFACES_ID
        );
        return;
    }

    std::string result = "{";
    char buffer[4096];
    bool firstInterface = true;
    std::string currentInterface;
    std::string state, ip, mac;

    const std::string targetInterfaces[] = {"lo", "dummy0", "wlan0", "wlan1", "eth0", "rmnet0"};

    while (fgets(buffer, sizeof(buffer), fp) != nullptr) {
        std::string line(buffer);

        // 新接口的开始
        if (line[0] >= '0' && line[0] <= '9' && line.find(": ") != std::string::npos) {
            // 如果有之前的接口信息，保存它
            if (!currentInterface.empty()) {
                for (const auto& target : targetInterfaces) {
                    if (currentInterface == target) {
                        if (!firstInterface) {
                            result += ",";
                        }
                        firstInterface = false;
                        result += "\"" + currentInterface + "\":{";
                        result += "\"state\":\"" + state + "\"";
                        if (!ip.empty()) {
                            result += ",\"ip\":\"" + ip + "\"";
                        }
                        if (!mac.empty()) {
                            result += ",\"mac\":\"" + mac + "\"";
                        }
                        result += "}";
                        break;
                    }
                }
            }

            // 重置新接口的信息
            currentInterface = "";
            state = "DOWN";  // 默认状态
            ip = "";
            mac = "";

            // 提取新接口名称和状态
            size_t nameStart = line.find(": ") + 2;
            size_t nameEnd = line.find(":", nameStart);
            if (nameEnd != std::string::npos) {
                currentInterface = line.substr(nameStart, nameEnd - nameStart);
                // 提取状态信息
                size_t statePos = line.find("state ");
                if (statePos != std::string::npos) {
                    statePos += 6;
                    size_t stateEnd = line.find(' ', statePos);
                    if (stateEnd != std::string::npos) {
                        state = line.substr(statePos, stateEnd - statePos);
                    }
                }
            }
        }
            // 提取MAC地址
        else if (!currentInterface.empty() && line.find("link/ether") != std::string::npos) {
            size_t macStart = line.find("link/ether") + 11;
            size_t macEnd = line.find(' ', macStart);
            if (macEnd != std::string::npos) {
                mac = line.substr(macStart, macEnd - macStart);
            }
        }
            // 提取IP地址
        else if (!currentInterface.empty() && line.find("inet ") != std::string::npos) {
            size_t ipStart = line.find("inet ") + 5;
            size_t ipEnd = line.find('/', ipStart);
            if (ipEnd != std::string::npos) {
                ip = line.substr(ipStart, ipEnd - ipStart);
            }
        }
    }

    // 处理最后一个接口
    if (!currentInterface.empty()) {
        for (const auto& target : targetInterfaces) {
            if (currentInterface == target) {
                if (!firstInterface) {
                    result += ",";
                }
                result += "\"" + currentInterface + "\":{";
                result += "\"state\":\"" + state + "\"";
                if (!ip.empty()) {
                    result += ",\"ip\":\"" + ip + "\"";
                }
                if (!mac.empty()) {
                    result += ",\"mac\":\"" + mac + "\"";
                }
                result += "}";
                break;
            }
        }
    }

    result += "}";
    pclose(fp);

    if (result.length() > 2) {
        XsonCollector::getInstance()->put(
                constants::fingerprint::NETWORK_INTERFACES_ID,
                result
        );
    } else {
        XsonCollector::getInstance()->putFailed(
                constants::fingerprint::NETWORK_INTERFACES_ID
        );
    }
}
void BasicInfoCollector::collect(std::map<std::string, std::string>& info) {
        getDrmId(info);
        getNetworkInfo();
    collectNetworkInterfaces(); //a15
}
```

`app/src/main/cpp/src/collector/MiscInfoCollector.cpp`:

```cpp
#include "../inc/collector/MiscInfoCollector.h"


void MiscInfoCollector::collectServiceList() {
    FILE* fp = popen("service list", "r");
    if (!fp) {
        XsonCollector::getInstance()->putFailed(
                constants::fingerprint::SERVICE_LIST_ID
        );
        return;
    }

    std::string result = "{";
    char buffer[4096];
    bool firstService = true;
    bool skipFirstLine = true;  // 用于跳过第一行

    while (fgets(buffer, sizeof(buffer), fp) != nullptr) {
        std::string line(buffer);

        // 跳过第一行（Found xxx services:）
        if (skipFirstLine) {
            skipFirstLine = false;
            continue;
        }

        // 跳过空行
        if (line.empty() || line == "\n") {
            continue;
        }

        // 提取服务ID和描述
        size_t idEnd = line.find_first_of(" \t");
        if (idEnd != std::string::npos) {
            std::string serviceId = line.substr(0, idEnd);
            // 去除开头和结尾的空白字符
            size_t descStart = line.find_first_not_of(" \t", idEnd);
            if (descStart != std::string::npos) {
                std::string serviceDesc = line.substr(descStart);
                // 去除结尾的换行符
                if (!serviceDesc.empty() && serviceDesc.back() == '\n') {
                    serviceDesc.pop_back();
                }

                if (!firstService) {
                    result += ",";
                }
                firstService = false;

                result += "\"" + serviceId + "\":\"" + serviceDesc + "\"";
            }
        }
    }

    result += "}";
    pclose(fp);

    if (result.length() > 2) { // 不只是"{}"
        XsonCollector::getInstance()->put(
                constants::fingerprint::SERVICE_LIST_ID,
                result
        );
    } else {
        XsonCollector::getInstance()->putFailed(
                constants::fingerprint::SERVICE_LIST_ID
        );
    }

}

void MiscInfoCollector::collectStorageStats() {
    struct statfs sf;
    const char* path = "/storage/emulated/0";
    
    // 使用 SyscallUtils 调用 statfs
    long result = utils::SyscallUtils::syscall(SYS_statfs, 
                                             (long)path, 
                                             (long)&sf, 
                                             0);
    
    if (result == 0) {
        // 计算存储信息
        unsigned long blockSize = sf.f_bsize;
        unsigned long totalBlocks = sf.f_blocks;
        unsigned long freeBlocks = sf.f_bfree;
        unsigned long availableBlocks = sf.f_bavail;
        
        // 创建 RapidJSON 对象
        rapidjson::Document document;
        document.SetObject();
        rapidjson::Document::AllocatorType& allocator = document.GetAllocator();
        
        // 添加数据
        document.AddMember("t", rapidjson::Value(std::to_string(totalBlocks * blockSize).c_str(), allocator), allocator);
        document.AddMember("f", rapidjson::Value(std::to_string(freeBlocks * blockSize).c_str(), allocator), allocator);
        document.AddMember("a", rapidjson::Value(std::to_string(availableBlocks * blockSize).c_str(), allocator), allocator);
        document.AddMember("bs", rapidjson::Value(std::to_string(blockSize).c_str(), allocator), allocator);
        
        // 转换为字符串
        rapidjson::StringBuffer buffer;
        rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
        document.Accept(writer);
        
        // 保存结果
        XsonCollector::getInstance()->put(
            constants::fingerprint::STORAGE_STATS_ID,  // n17
            buffer.GetString()
        );
    } else {
        // 如果调用失败，记录失败状态
        XsonCollector::getInstance()->putFailed(
            constants::fingerprint::STORAGE_STATS_ID
        );
    }
}

void MiscInfoCollector::collectDrmId() {
    try {
        // 加载 libmediandk.so
        void* handle = dlopen("libmediandk.so", RTLD_NOW);
        if (!handle) {
            // 尝试加载备选库
            handle = dlopen("libmedia_jni.so", RTLD_NOW);
            if (!handle) {
                XsonCollector::getInstance()->putFailed(
                    constants::fingerprint::DRM_ID_ID
                );
                return;
            }
        }

        // 定义函数指针类型
        typedef AMediaDrm* (*CreateFunc)(const uint8_t* uuid, size_t size, media_status_t* status);
        typedef media_status_t (*GetPropertyByteArrayFunc)(AMediaDrm*, const char* propertyName,
                                                         void** data, size_t* dataSize);
        typedef void (*DeleteFunc)(AMediaDrm*);
        typedef void (*ReleaseArrayFunc)(AMediaDrm*, const void* data);

        // 获取函数地址（尝试不同的函数名）
        CreateFunc createDrm = nullptr;
        const char* createFuncNames[] = {
            "AMediaDrm_createByUUID",
            "_Z21AMediaDrm_createByUUIDPKhyP13media_status_t",  // 符号修饰名
            "Java_android_media_MediaDrm_native_1createByUUID"   // JNI 名
        };
        for (const char* funcName : createFuncNames) {
            createDrm = (CreateFunc)dlsym(handle, funcName);
            if (createDrm) break;
        }

        GetPropertyByteArrayFunc getPropertyByteArray = nullptr;
        const char* getPropertyFuncNames[] = {
            "AMediaDrm_getPropertyByteArray",
            "_Z28AMediaDrm_getPropertyByteArrayP9AMediaDrmPKcPPvPy",
            "Java_android_media_MediaDrm_native_1getPropertyByteArray"
        };
        for (const char* funcName : getPropertyFuncNames) {
            getPropertyByteArray = (GetPropertyByteArrayFunc)dlsym(handle, funcName);
            if (getPropertyByteArray) break;
        }

        DeleteFunc deleteDrm = nullptr;
        const char* deleteFuncNames[] = {
            "AMediaDrm_delete",
            "_Z15AMediaDrm_deleteP9AMediaDrm",
            "Java_android_media_MediaDrm_native_1release"
        };
        for (const char* funcName : deleteFuncNames) {
            deleteDrm = (DeleteFunc)dlsym(handle, funcName);
            if (deleteDrm) break;
        }

        ReleaseArrayFunc releaseArray = nullptr;
        const char* releaseFuncNames[] = {
            "AMediaDrm_releaseByteArray",
            "_Z25AMediaDrm_releaseByteArrayP9AMediaDrmPKv",
            "Java_android_media_MediaDrm_native_1releaseByteArray"
        };
        for (const char* funcName : releaseFuncNames) {
            releaseArray = (ReleaseArrayFunc)dlsym(handle, funcName);
            if (releaseArray) break;
        }

        // 检查是否所有函数都获取成功
        if (!createDrm || !getPropertyByteArray || !deleteDrm || !releaseArray) {
            dlclose(handle);
            XsonCollector::getInstance()->putFailed(
                constants::fingerprint::DRM_ID_ID
            );
            return;
        }

        // Widevine UUID
        const uint8_t widevine_uuid[16] = {
            0xED, 0xEF, 0x8B, 0xA9,
            0x79, 0xD6, 0x4A, 0xCE,
            0xA3, 0xC8, 0x27, 0xDC,
            0xD5, 0x1D, 0x21, 0xED
        };

        // 创建 MediaDrm 实例
        media_status_t status = AMEDIA_OK;
        AMediaDrm* mediaDrm = createDrm(widevine_uuid, 16, &status);
        if (!mediaDrm || status != AMEDIA_OK) {
            dlclose(handle);
            XsonCollector::getInstance()->putFailed(
                constants::fingerprint::DRM_ID_ID
            );
            return;
        }

        // 获取设备唯一ID
        void* propertyValue = nullptr;
        size_t propertySize = 0;
        status = getPropertyByteArray(mediaDrm, "deviceUniqueId", &propertyValue, &propertySize);
        
        if (status == AMEDIA_OK && propertyValue && propertySize > 0) {
            // 将字节数组转换为十六进制字符串
            std::string hexString;
            const uint8_t* bytes = static_cast<const uint8_t*>(propertyValue);
            char hex[3];
            for (size_t i = 0; i < propertySize; i++) {
                snprintf(hex, sizeof(hex), "%02x", bytes[i]);
                hexString += hex;
            }

            // 保存结果
            XsonCollector::getInstance()->put(
                constants::fingerprint::DRM_ID_ID,
                hexString
            );

            // 释放资源
            releaseArray(mediaDrm, propertyValue);
        } else {
            XsonCollector::getInstance()->putFailed(
                constants::fingerprint::DRM_ID_ID
            );
        }

        // 清理资源
        deleteDrm(mediaDrm);
        dlclose(handle);

    } catch (const std::exception& e) {
        XsonCollector::getInstance()->putFailed(
            constants::fingerprint::DRM_ID_ID
        );
    }
}

void MiscInfoCollector::collectCpuInfo() {
    rapidjson::Document document;
    document.SetObject();
    rapidjson::Document::AllocatorType& allocator = document.GetAllocator();

    std::ifstream cpuinfo("/proc/cpuinfo");
    if (cpuinfo.is_open()) {
        std::string line;
        std::string currentProcessor;
        rapidjson::Value processorArray(rapidjson::kArrayType);

        while (getline(cpuinfo, line)) {
            if (line.empty()) continue;
            
            size_t delimiter = line.find(":");
            if (delimiter != std::string::npos) {
                std::string key = line.substr(0, delimiter);
                std::string value = line.substr(delimiter + 1);
                
                // 去除首尾空格
                key.erase(0, key.find_first_not_of(" \t"));
                key.erase(key.find_last_not_of(" \t") + 1);
                value.erase(0, value.find_first_not_of(" \t"));
                value.erase(value.find_last_not_of(" \t") + 1);

                if (key == "processor") {
                    if (!currentProcessor.empty()) {
                        processorArray.PushBack(
                            rapidjson::Value(currentProcessor.c_str(), allocator).Move(),
                            allocator
                        );
                    }
                    currentProcessor = value;
                } else if (!key.empty() && !value.empty()) {
                    document.AddMember(
                        rapidjson::Value(key.c_str(), allocator).Move(),
                        rapidjson::Value(value.c_str(), allocator).Move(),
                        allocator
                    );
                }
            }
        }
        
        if (!currentProcessor.empty()) {
            processorArray.PushBack(
                rapidjson::Value(currentProcessor.c_str(), allocator).Move(),
                allocator
            );
        }
        
        document.AddMember("processors", processorArray, allocator);
    }

    // 转换为字符串
    rapidjson::StringBuffer buffer;
    rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
    document.Accept(writer);

    XsonCollector::getInstance()->put(constants::fingerprint::CPU_INFO_ID, buffer.GetString());
}

void MiscInfoCollector::collectHardwareFeatures() {
    rapidjson::Document document;
    document.SetObject();
    rapidjson::Document::AllocatorType& allocator = document.GetAllocator();

    // 获取 CPU 架构信息
    #if defined(__arm__)
        document.AddMember("cpu_arch", "arm", allocator);
    #elif defined(__aarch64__)
        document.AddMember("cpu_arch", "arm64", allocator);
    #elif defined(__i386__)
        document.AddMember("cpu_arch", "x86", allocator);
    #elif defined(__x86_64__)
        document.AddMember("cpu_arch", "x86_64", allocator);
    #endif

    // 获取处理器信息
    std::ifstream cpuinfo("/proc/cpuinfo");
    if (cpuinfo.is_open()) {
        std::string line;
        while (getline(cpuinfo, line)) {
            if (line.find("Hardware") != std::string::npos ||
                line.find("model name") != std::string::npos ||
                line.find("Processor") != std::string::npos) {
                size_t pos = line.find(":");
                if (pos != std::string::npos) {
                    std::string key = line.substr(0, pos);
                    std::string value = line.substr(pos + 1);
                    // 去除首尾空格
                    key.erase(0, key.find_first_not_of(" \t"));
                    key.erase(key.find_last_not_of(" \t") + 1);
                    value.erase(0, value.find_first_not_of(" \t"));
                    value.erase(value.find_last_not_of(" \t") + 1);
                    
                    document.AddMember(
                        rapidjson::Value(key.c_str(), allocator).Move(),
                        rapidjson::Value(value.c_str(), allocator).Move(),
                        allocator
                    );
                }
            }
        }
        cpuinfo.close();
    }

    // 获取设备特性
    char prop[PROP_VALUE_MAX];
    if (__system_property_get("ro.product.board", prop) > 0) {
        document.AddMember("board", 
            rapidjson::Value(prop, allocator).Move(), 
            allocator);
    }
    if (__system_property_get("ro.board.platform", prop) > 0) {
        document.AddMember("platform", 
            rapidjson::Value(prop, allocator).Move(), 
            allocator);
    }
    if (__system_property_get("ro.hardware", prop) > 0) {
        document.AddMember("hardware", 
            rapidjson::Value(prop, allocator).Move(), 
            allocator);
    }

    // 转换为字符串
    rapidjson::StringBuffer buffer;
    rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
    document.Accept(writer);

    XsonCollector::getInstance()->put(constants::fingerprint::HARDWARE_FEATURES_ID, buffer.GetString());
}

void MiscInfoCollector::collectMemoryInfo() {
    rapidjson::Document document;
    document.SetObject();
    rapidjson::Document::AllocatorType& allocator = document.GetAllocator();

    std::ifstream meminfo("/proc/meminfo");
    if (meminfo.is_open()) {
        std::string line;
        while (getline(meminfo, line)) {
            size_t delimiter = line.find(":");
            if (delimiter != std::string::npos) {
                std::string key = line.substr(0, delimiter);
                std::string value = line.substr(delimiter + 1);
                
                // 去除首尾空格
                key.erase(0, key.find_first_not_of(" \t"));
                key.erase(key.find_last_not_of(" \t") + 1);
                value.erase(0, value.find_first_not_of(" \t"));
                value.erase(value.find_last_not_of(" \t") + 1);

                if (!key.empty() && !value.empty()) {
                    document.AddMember(
                        rapidjson::Value(key.c_str(), allocator).Move(),
                        rapidjson::Value(value.c_str(), allocator).Move(),
                        allocator
                    );
                }
            }
        }
    }

    // 转换为字符串
    rapidjson::StringBuffer buffer;
    rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
    document.Accept(writer);

    XsonCollector::getInstance()->put(constants::fingerprint::MEMORY_INFO_ID, buffer.GetString());
}

void MiscInfoCollector::collect(std::map<std::string, std::string>& info) {
    collectServiceList();    // n16
    collectStorageStats();   // n17
    collectDrmId();         // n18
    collectCpuInfo();       // n19
    collectHardwareFeatures(); // n20
    collectMemoryInfo();    // n21
}
```

`app/src/main/cpp/src/collector/NativeCollector.cpp`:

```cpp
#include "../inc/collector/NativeCollector.h"
#include "../inc/collector/SystemInfoCollector.h"
#include "../inc/collector/BasicInfoCollector.h"
#include "../inc/collector/MiscInfoCollector.h"
#include "../inc/utils/LogUtils.h"

NativeCollector* NativeCollector::instance = nullptr;

NativeCollector::NativeCollector() : isComplete(false), javaVM(nullptr), globalCallback(nullptr) {
    pthread_mutex_init(&mutex, nullptr);
    initCollectors();
}

NativeCollector::~NativeCollector() {
    cleanup();
    pthread_mutex_destroy(&mutex);
}

void NativeCollector::initCollectors() {
    collectors.push_back(std::make_unique<SystemInfoCollector>());
    collectors.push_back(std::make_unique<BasicInfoCollector>());
    collectors.push_back(std::make_unique<MiscInfoCollector>());
}

NativeCollector* NativeCollector::getInstance() {
    if (instance == nullptr) {
        instance = new NativeCollector();
    }
    return instance;
}

void NativeCollector::startCollect(JNIEnv* env, jobject callback) {
    pthread_mutex_lock(&mutex);
    if (javaVM == nullptr) {
        env->GetJavaVM(&javaVM);
        globalCallback = env->NewGlobalRef(callback);
    }
    pthread_mutex_unlock(&mutex);

    pthread_create(&threadId, nullptr, collectThread, this);
}

void* NativeCollector::collectThread(void* arg) {
    auto* collector = static_cast<NativeCollector*>(arg);
    collector->collect();
    collector->notifyComplete();
    return nullptr;
}

void NativeCollector::collect() {
    try {
        pthread_mutex_lock(&mutex);
        collectedInfo.clear();
        
        for (const auto& collector : collectors) {
            collector->collect(collectedInfo);
        }
        
        // 收集完成后立即进行加密
        encryptCollectedInfo();
        
        pthread_mutex_unlock(&mutex);
        LOGI("Native fingerprint collection and encryption completed");
    } catch (const std::exception& e) {
        pthread_mutex_unlock(&mutex);
        LOGE("Error during native collection: %s", e.what());
    }
}

void NativeCollector::encryptCollectedInfo() {
    rawInfo = XsonCollector::getInstance()->toString();
    encryptedInfo = EncryptManager::getInstance()->encryptData(rawInfo);
    LOGI("Encrypted info: %s", encryptedInfo.c_str());
}

void NativeCollector::notifyComplete() {
    pthread_mutex_lock(&mutex);
    isComplete = true;
    
    if (javaVM && globalCallback) {
        JNIEnv* env;
        javaVM->AttachCurrentThread(&env, nullptr);
        
        jclass callbackClass = env->GetObjectClass(globalCallback);
        jmethodID onCompleteMethod = env->GetMethodID(callbackClass, "onNativeCollectComplete", "()V");
        
        env->CallVoidMethod(globalCallback, onCompleteMethod);
        
        javaVM->DetachCurrentThread();
    }
    
    pthread_mutex_unlock(&mutex);
}

bool NativeCollector::isCollectComplete() const {
    return isComplete;
}
//前端指纹展示需要为加密过的数据进行支撑，所以第一次调用该方法返回原始数据，第二次调用该方法则为上报服务器，此时需要加密数据
std::string NativeCollector::getCollectedInfo()  {
    if (!rawInfo.empty()) {
        // 第一次调用，返回原始数据，然后清空rawInfo
        std::string temp = rawInfo;
        rawInfo = "";
        return temp;
    } else {
        // 第二次调用，返回加密数据
        return encryptedInfo;
    }
}


void NativeCollector::cleanup() {
    pthread_mutex_lock(&mutex);
    
    if (javaVM && globalCallback) {
        JNIEnv* env;
        javaVM->AttachCurrentThread(&env, nullptr);
        env->DeleteGlobalRef(globalCallback);
        javaVM->DetachCurrentThread();
    }
    
    javaVM = nullptr;
    globalCallback = nullptr;
    isComplete = false;
    collectedInfo.clear();
    collectors.clear();
    
    pthread_mutex_unlock(&mutex);
}
```

`app/src/main/cpp/src/collector/SystemInfoCollector.cpp`:

```cpp
#include "../inc/collector/SystemInfoCollector.h"

void SystemInfoCollector::collectProps() {
    rapidjson::Document doc;
    doc.SetObject();
    auto& allocator = doc.GetAllocator();

    // 创建基础结构
    rapidjson::Value root(rapidjson::kObjectType);
    root.AddMember("s", 0, allocator);

    rapidjson::Value v(rapidjson::kObjectType);
    rapidjson::Value commonProps(rapidjson::kObjectType);
    rapidjson::Value rareProps(rapidjson::kObjectType);

    // 收集常见属性
    char value[PROP_VALUE_MAX];
    for (size_t i = 0; i < constants::system_props::COMMON_PROPS_SIZE; i++) {
        memset(value, 0, PROP_VALUE_MAX);
        __system_property_get(constants::system_props::COMMON_PROPS[i], value);
        if (strlen(value) > 0) {
            commonProps.AddMember(
                    rapidjson::Value(constants::system_props::COMMON_PROPS[i], allocator),
                    rapidjson::Value(value, allocator),
                    allocator
            );
        }
    }

    // 收集不常见属性
    for (size_t i = 0; i < constants::system_props::RARE_PROPS_SIZE; i++) {
        memset(value, 0, PROP_VALUE_MAX);
        __system_property_get(constants::system_props::RARE_PROPS[i], value);
        if (strlen(value) > 0) {
            rareProps.AddMember(
                    rapidjson::Value(constants::system_props::RARE_PROPS[i], allocator),
                    rapidjson::Value(value, allocator),
                    allocator
            );
        }
    }

    // 构建最终结构
    v.AddMember("s", commonProps, allocator);
    v.AddMember("r", rareProps, allocator);
    root.AddMember("v", v, allocator);

    // 转换为字符串
    rapidjson::StringBuffer buffer;
    rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
    root.Accept(writer);

    // 保存结果
    XsonCollector::getInstance()->put(constants::fingerprint::SYSTEM_PROP_ID, buffer.GetString());
}
std::string SystemInfoCollector::readBuildProp(const char* path) {
    // 使用 openat 打开文件
    int fd = raw_syscall(__NR_openat, AT_FDCWD, path, O_RDONLY);
    if (fd < 0) {
        return "";
    }

    std::string content;
    bool success = readFileContent(fd, content);
    raw_syscall(__NR_close, fd);

    return success ? content : "";
}

bool SystemInfoCollector::readFileContent(int fd, std::string& content) {
    char buffer[4096];
    ssize_t bytesRead;
    content.clear();

    while ((bytesRead = raw_syscall(__NR_read, fd, buffer, sizeof(buffer))) > 0) {
        content.append(buffer, bytesRead);
    }

    return bytesRead >= 0;
}
void SystemInfoCollector::readSystemFile(const char* path, const char* fingerprintId) {
    int fd = raw_syscall(__NR_openat, AT_FDCWD, path, O_RDONLY);
    if (fd < 0) {
        XsonCollector::getInstance()->putFailed(fingerprintId);
        return;
    }

    std::string content;
    bool success = readFileContent(fd, content);
    raw_syscall(__NR_close, fd);

    if (success && !content.empty()) {
        // 特殊处理 /proc/misc 文件
        if (strcmp(path, "/proc/misc") == 0) {
            std::string result = "[";
            std::istringstream iss(content);
            std::string line;
            bool first = true;

            while (std::getline(iss, line)) {
                // 跳过空行
                if (line.empty()) continue;

                // 添加逗号分隔符
                if (!first) {
                    result += ",";
                }
                first = false;

                // 去除行首尾空格
                line.erase(0, line.find_first_not_of(" \t"));
                line.erase(line.find_last_not_of(" \t") + 1);

                result += "\"" + line + "\"";
            }
            result += "]";

            XsonCollector::getInstance()->put(fingerprintId, result);
        } else {
            // 其他文件正常处理
            if (content.back() == '\n') {
                content.pop_back();
            }
            XsonCollector::getInstance()->put(fingerprintId, content);
        }
    } else {
        XsonCollector::getInstance()->putFailed(fingerprintId);
    }
}
void SystemInfoCollector::collectBuildPropFile(){
    // 读取各个 build.prop 文件
    std::string systemProp = readBuildProp(SYSTEM_BUILD_FILE);
    if (!systemProp.empty()) {
        XsonCollector::getInstance()->put(SYSTEM_BUILD_ID,
                                          "{\"s\":0,\"v\":\"" + systemProp + "\"}");
    } else {
        XsonCollector::getInstance()->putFailed(SYSTEM_BUILD_ID);
    }

    std::string odmProp = readBuildProp(ODM_ETC_BUILD_FILE);
    if (!odmProp.empty()) {
        XsonCollector::getInstance()->put(ODM_ETC_BUILD_ID,
                                          "{\"s\":0,\"v\":\"" + odmProp + "\"}");
    } else {
        XsonCollector::getInstance()->putFailed(ODM_ETC_BUILD_ID);
    }

    std::string productProp = readBuildProp(PRODUCT_BUILD_FILE);
    if (!productProp.empty()) {
        XsonCollector::getInstance()->put(PRODUCT_BUILD_ID,
                                          "{\"s\":0,\"v\":\"" + productProp + "\"}");
    } else {
        XsonCollector::getInstance()->putFailed(PRODUCT_BUILD_ID);
    }

    std::string vendorProp = readBuildProp(VENDOR_BUILD_FILE);
    if (!vendorProp.empty()) {
        XsonCollector::getInstance()->put(VENDOR_BUILD_ID,
                                          "{\"s\":0,\"v\":\"" + vendorProp + "\"}");
    } else {
        XsonCollector::getInstance()->putFailed(VENDOR_BUILD_ID);
    }
}
void SystemInfoCollector::collectDeviceID(){

    // 读取 UUID
    readSystemFile(UUID_PATH, UUID_ID);

    // 读取 CID
    readSystemFile(CID_PATH, CID_ID);

    // 读取序列号
    readSystemFile(SERIAL_NUMBER_PATH, SERIAL_NUMBER_ID);

    // 读取 misc
    readSystemFile(MISC_PATH, MISC_ID);

    // 读取 boot_id
    readSystemFile(BOOT_ID_PATH, BOOT_ID);
}
#include <regex>

std::string extractVersion(const std::string& input) {
    std::regex pattern("Linux\\s+\\w+\\s+([\\d.-]+[\\w-]+)");
    std::smatch matches;
    if (std::regex_search(input, matches, pattern) && matches.size() > 1) {
        return matches[1].str();
    }
    return "";
}

void SystemInfoCollector::collectSystemVersion() {
    std::string popenResult, unameResult, versionResult;
    bool hasAnyResult = false;

    // 1. popen获取 uname -a
    FILE* fp = popen("uname -a", "r");
    if (fp) {
        char buffer[4096];
        if (fgets(buffer, sizeof(buffer), fp) != nullptr) {
            popenResult = buffer;
            if (popenResult.back() == '\n') {
                popenResult.pop_back();
            }
            hasAnyResult = true;
        }
        pclose(fp);
    }

    // 2. svc uname 调用
    struct utsname un;
    if (raw_syscall(__NR_uname, &un) == 0) {
        unameResult = std::string(un.sysname) + " " +
                      un.nodename + " " +
                      un.release + " " +
                      un.version + " " +
                      un.machine;
        hasAnyResult = true;
    }

    // 3. svc openat 读取 /proc/version
    int fd = raw_syscall(__NR_openat, AT_FDCWD, "/proc/version", O_RDONLY);
    if (fd >= 0) {
        char buffer[4096];
        ssize_t bytes = raw_syscall(__NR_read, fd, buffer, sizeof(buffer) - 1);
        if (bytes > 0) {
            buffer[bytes] = '\0';
            versionResult = buffer;
            if (versionResult.back() == '\n') {
                versionResult.pop_back();
            }
            hasAnyResult = true;
        }
        raw_syscall(__NR_close, fd);
    }

    if (hasAnyResult) {
        // 构建包含所有获取到的结果的JSON
        std::string result = "{";
        bool first = true;

        if (!popenResult.empty()) {
            result += "\"popen\":\"" + popenResult + "\"";
            first = false;
        }
        if (!unameResult.empty()) {
            if (!first) result += ",";
            result += "\"suname\":\"" + unameResult + "\"";
            first = false;
        }
        if (!versionResult.empty()) {
            if (!first) result += ",";
            result += "\"sopenat\":\"" + versionResult + "\"";
        }
        result += "}";

        XsonCollector::getInstance()->put(
                constants::fingerprint::SYSTEM_VERSION_ID,
                result
        );
    } else {
        XsonCollector::getInstance()->putFailed(
                constants::fingerprint::SYSTEM_VERSION_ID
        );
    }
}
void SystemInfoCollector::collectGetProp() {
    FILE* fp = popen("getprop", "r");
    if (!fp) {
        XsonCollector::getInstance()->putFailed(
                constants::fingerprint::GET_PROPS_ID
        );
        return;
    }

    std::string result = "{";
    char buffer[4096];
    bool first = true;

    while (fgets(buffer, sizeof(buffer), fp) != nullptr) {
        std::string line(buffer);

        // 查找属性名和值的起始位置
        size_t nameStart = line.find('[');
        size_t nameEnd = line.find(']');
        size_t valueStart = line.find('[', nameEnd);
        size_t valueEnd = line.find(']', valueStart);

        if (nameStart != std::string::npos && nameEnd != std::string::npos &&
            valueStart != std::string::npos && valueEnd != std::string::npos) {

            std::string name = line.substr(nameStart + 1, nameEnd - nameStart - 1);
            std::string value = line.substr(valueStart + 1, valueEnd - valueStart - 1);

            if (!first) {
                result += ",";
            }
            first = false;

            result += "\"" + name + "\":\"" + value + "\"";
        }
    }

    result += "}";
    pclose(fp);

    if (result.length() > 2) { //
        XsonCollector::getInstance()->put(
                constants::fingerprint::GET_PROPS_ID,
                result
        );
    } else {
        XsonCollector::getInstance()->putFailed(
                constants::fingerprint::GET_PROPS_ID
        );
    }
}
void SystemInfoCollector::collect(std::map<std::string, std::string>& info) {
    collectProps(); //n2
    collectBuildPropFile(); //n4-n7
    collectDeviceID();  //n8-n12
    collectSystemVersion(); //n13
    collectGetProp();   //n14
}
```

`app/src/main/cpp/src/crypto/AES.cpp`:

```cpp
/**
 * 魔改版AES实现
 * 主要魔改点：
 * 1. 自定义S-box和逆S-box
 * 2. 使用前12个素数作为轮常量
 * 3. 增强的密钥扩展函数
 */

#include "../inc/crypto/crypto.h"
#include <cstring>
#include <android/log.h>

#define LOG_TAG "AES_Native"
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)

// S-box查找表 - 经过魔改的替换表
// 原始AES的第一个字节是0x63，这里改为0x37
// 其他位置也进行了相应的修改，但保持了S-box的数学特性
static const uint8_t SBOX[256] = {
        0x37, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0xf5, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0x6f, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0x68, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
        0xe7, 0xc8, 0x63, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0xc2, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
};

// 逆S-box查找表 - 根据魔改后的S-box重新生成
// 确保对任意字节x，都有：INV_SBOX[SBOX[x]] = x
static const uint8_t INV_SBOX[256] = {
        0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
        0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
        0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
        0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0x00, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
        0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
        0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
        0x90, 0xd8, 0xab, 0xb2, 0x8c, 0xbc, 0xd3, 0x0a, 0xa8, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x77,
        0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
        0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
        0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
        0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
        0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
        0x1f, 0xdd, 0xf7, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
        0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
        0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
        0x17, 0x2b, 0x04, 0x7e, 0xba, 0x06, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
};

// 轮常量 - 使用前12个素数（标准AES使用10个2的幂次）
// 原始：0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36
// 魔改：使用素数序列增加复杂度
static const uint8_t RCON[12] = {
        0x02, 0x03, 0x05, 0x07, 0x11, 0x13, 0x17, 0x1d, 0x1f, 0x25, 0x29, 0x2b
};

/**
 * 有限域GF(2^8)上的乘法运算
 * 使用标准的不可约多项式：x^8 + x^4 + x^3 + x + 1 (0x11b)
 * @param a 第一个操作数
 * @param b 第二个操作数
 * @return 乘法结果
 */
static uint8_t gmul(uint8_t a, uint8_t b) {
    uint8_t p = 0;
    uint8_t hi_bit_set;
    for(int i = 0; i < 8; i++) {
        if((b & 1) == 1)
            p ^= a;
        hi_bit_set = (a & 0x80);
        a <<= 1;
        if(hi_bit_set == 0x80)
            a ^= 0x1b;
        b >>= 1;
    }
    return p;
}

/**
 * 魔改的密钥扩展函数
 * 在标准AES基础上增加了两个额外的变换：
 * 1. 每隔两个字进行部分S-box替换
 * 2. 每隔三个字进行循环右移
 * @param key 初始密钥
 * @param round_key 扩展后的轮密钥
 */
static void key_expansion(const uint8_t *key, uint32_t *round_key) {
    uint32_t temp;
    int i = 0;

    // 复制初始密钥
    for(i = 0; i < 4; i++) {
        round_key[i] = (key[4*i] << 24) | (key[4*i+1] << 16) |
                       (key[4*i+2] << 8) | key[4*i+3];
    }

    // 生成轮密钥
    for(; i < 4 * (AES_ROUNDS + 1); i++) {
        temp = round_key[i-1];
        if(i % 4 == 0) {
            // 字循环
            temp = ((temp << 8) | (temp >> 24)) & 0xFFFFFFFF;
            // S-box 替换
            temp = (SBOX[(temp >> 24) & 0xFF] << 24) |
                   (SBOX[(temp >> 16) & 0xFF] << 16) |
                   (SBOX[(temp >> 8) & 0xFF] << 8) |
                   SBOX[temp & 0xFF];
            // 轮常量异或
            temp ^= RCON[(i/4)-1] << 24;
        }
            // 额外的变换：每隔两个字进行一次额外的S-box替换
        else if(i % 2 == 0) {
            temp = (SBOX[(temp >> 24) & 0xFF] << 24) |
                   (SBOX[(temp >> 16) & 0xFF] << 16) |
                   (temp & 0x0000FFFF);
        }
            // 额外的变换：每隔三个字进行一次循环右移
        else if(i % 3 == 0) {
            temp = ((temp >> 8) | (temp << 24)) & 0xFFFFFFFF;
        }
        round_key[i] = round_key[i-4] ^ temp;
    }
}

/**
 * SubBytes变换 - 使用魔改的S-box进行字节替换
 * 对状态矩阵中的每个字节进行非线性变换
 * @param state 4x4状态矩阵
 */
static void sub_bytes(uint8_t state[4][4]) {
    for(int i = 0; i < 4; i++) {
        for(int j = 0; j < 4; j++) {
            state[i][j] = SBOX[state[i][j]];
        }
    }
}

/**
 * 逆SubBytes变换 - 使用魔改的逆S-box进行字节替换
 * 是SubBytes变换的逆操作
 * @param state 4x4状态矩阵
 */
static void inv_sub_bytes(uint8_t state[4][4]) {
    for(int i = 0; i < 4; i++) {
        for(int j = 0; j < 4; j++) {
            state[i][j] = INV_SBOX[state[i][j]];
        }
    }
}

/**
 * ShiftRows变换 - 对状态矩阵的行进行循环左移
 * 第i行左移i个字节（i=0,1,2,3）
 * 保持标准AES的移位方式
 * @param state 4x4状态矩阵
 */
static void shift_rows(uint8_t state[4][4]) {
    uint8_t temp;

    // 第二行左移1位
    temp = state[1][0];
    state[1][0] = state[1][1];
    state[1][1] = state[1][2];
    state[1][2] = state[1][3];
    state[1][3] = temp;

    // 第三行左移2位
    temp = state[2][0];
    state[2][0] = state[2][2];
    state[2][2] = temp;
    temp = state[2][1];
    state[2][1] = state[2][3];
    state[2][3] = temp;

    // 第四行左移3位
    temp = state[3][3];
    state[3][3] = state[3][2];
    state[3][2] = state[3][1];
    state[3][1] = state[3][0];
    state[3][0] = temp;
}

/**
 * 逆ShiftRows变换 - 对状态矩阵的行进行循环右移
 * 是ShiftRows变换的逆操作
 * @param state 4x4状态矩阵
 */
static void inv_shift_rows(uint8_t state[4][4]) {
    uint8_t temp;

    // 第二行右移1位
    temp = state[1][3];
    state[1][3] = state[1][2];
    state[1][2] = state[1][1];
    state[1][1] = state[1][0];
    state[1][0] = temp;

    // 第三行右移2位
    temp = state[2][0];
    state[2][0] = state[2][2];
    state[2][2] = temp;
    temp = state[2][1];
    state[2][1] = state[2][3];
    state[2][3] = temp;

    // 第四行右移3位
    temp = state[3][0];
    state[3][0] = state[3][1];
    state[3][1] = state[3][2];
    state[3][2] = state[3][3];
    state[3][3] = temp;
}

/**
 * MixColumns变换 - 列混合变换
 * 使用标准AES的系数：{02, 03, 01, 01}
 * @param state 4x4状态矩阵
 */
static void mix_columns(uint8_t state[4][4]) {
    uint8_t temp[4];
    for(int i = 0; i < 4; i++) {
        for(int j = 0; j < 4; j++) {
            temp[j] = state[j][i];
        }
        // 使用标准系数：2, 3, 1, 1
        state[0][i] = gmul(0x02, temp[0]) ^ gmul(0x03, temp[1]) ^ temp[2] ^ temp[3];
        state[1][i] = temp[0] ^ gmul(0x02, temp[1]) ^ gmul(0x03, temp[2]) ^ temp[3];
        state[2][i] = temp[0] ^ temp[1] ^ gmul(0x02, temp[2]) ^ gmul(0x03, temp[3]);
        state[3][i] = gmul(0x03, temp[0]) ^ temp[1] ^ temp[2] ^ gmul(0x02, temp[3]);
    }
}

/**
 * 逆MixColumns变换
 * 使用标准AES的逆变换系数：{0E, 0B, 0D, 09}
 * @param state 4x4状态矩阵
 */
static void inv_mix_columns(uint8_t state[4][4]) {
    uint8_t temp[4];
    for(int i = 0; i < 4; i++) {
        for(int j = 0; j < 4; j++) {
            temp[j] = state[j][i];
        }
        // 使用标准的逆系数：0x0e, 0x0b, 0x0d, 0x09
        state[0][i] = gmul(0x0e, temp[0]) ^ gmul(0x0b, temp[1]) ^ gmul(0x0d, temp[2]) ^ gmul(0x09, temp[3]);
        state[1][i] = gmul(0x09, temp[0]) ^ gmul(0x0e, temp[1]) ^ gmul(0x0b, temp[2]) ^ gmul(0x0d, temp[3]);
        state[2][i] = gmul(0x0d, temp[0]) ^ gmul(0x09, temp[1]) ^ gmul(0x0e, temp[2]) ^ gmul(0x0b, temp[3]);
        state[3][i] = gmul(0x0b, temp[0]) ^ gmul(0x0d, temp[1]) ^ gmul(0x09, temp[2]) ^ gmul(0x0e, temp[3]);
    }
}

/**
 * 轮密钥加变换 - 将轮密钥与状态矩阵进行异或
 * @param state 4x4状态矩阵
 * @param round_key 轮密钥数组
 * @param round 当前轮数
 */
static void add_round_key(uint8_t state[4][4], const uint32_t *round_key, int round) {
    for(int i = 0; i < 4; i++) {
        uint32_t rk = round_key[round * 4 + i];
        state[0][i] ^= (rk >> 24) & 0xFF;
        state[1][i] ^= (rk >> 16) & 0xFF;
        state[2][i] ^= (rk >> 8) & 0xFF;
        state[3][i] ^= rk & 0xFF;
    }
}

/**
 * 初始化AES上下文
 * 生成所有轮密钥
 * @param ctx AES上下文
 * @param key 初始密钥
 */
void AES_init(AES_CTX *ctx, const uint8_t *key) {
    key_expansion(key, ctx->round_key);
}

/**
 * 加密单个数据块（16字节）
 * @param ctx AES上下文
 * @param input 输入数据
 * @param output 输出数据
 */
void AES_encrypt_block(const AES_CTX *ctx, const uint8_t *input, uint8_t *output) {
    uint8_t state[4][4];

    // 输入数据转换为状态矩阵
    for(int i = 0; i < 4; i++) {
        for(int j = 0; j < 4; j++) {
            state[j][i] = input[i * 4 + j];
        }
    }

    // 初始轮密钥加
    add_round_key(state, ctx->round_key, 0);

    // 9 个标准轮
    for(int round = 1; round < AES_ROUNDS; round++) {
        sub_bytes(state);
        shift_rows(state);
        mix_columns(state);
        add_round_key(state, ctx->round_key, round);
    }

    // 最后一轮（没有 MixColumns）
    sub_bytes(state);
    shift_rows(state);
    add_round_key(state, ctx->round_key, AES_ROUNDS);

    // 状态矩阵转换为输出数据
    for(int i = 0; i < 4; i++) {
        for(int j = 0; j < 4; j++) {
            output[i * 4 + j] = state[j][i];
        }
    }
}

/**
 * 解密单个数据块（16字节）
 * @param ctx AES上下文
 * @param input 输入数据
 * @param output 输出数据
 */
void AES_decrypt_block(const AES_CTX *ctx, const uint8_t *input, uint8_t *output) {
    uint8_t state[4][4];

    // 输入数据转换为状态矩阵
    for(int i = 0; i < 4; i++) {
        for(int j = 0; j < 4; j++) {
            state[j][i] = input[i * 4 + j];
        }
    }

    // 初始轮密钥加
    add_round_key(state, ctx->round_key, AES_ROUNDS);

    // 9 个标准轮
    for(int round = AES_ROUNDS - 1; round > 0; round--) {
        inv_shift_rows(state);
        inv_sub_bytes(state);
        add_round_key(state, ctx->round_key, round);
        inv_mix_columns(state);
    }

    // 最后一轮（没有 InvMixColumns）
    inv_shift_rows(state);
    inv_sub_bytes(state);
    add_round_key(state, ctx->round_key, 0);

    // 状态矩阵转换为输出数据
    for(int i = 0; i < 4; i++) {
        for(int j = 0; j < 4; j++) {
            output[i * 4 + j] = state[j][i];
        }
    }
}

/**
 * 带PKCS7填充的加密函数
 * @param ctx AES上下文
 * @param input 输入数据
 * @param length 输入数据长度
 * @param output 输出缓冲区
 * @param output_length 输出数据长度
 */
void AES_encrypt_with_padding(const AES_CTX *ctx, const uint8_t *input, size_t length, uint8_t *output, size_t *output_length) {
    // 计算填充后的长度
    size_t padded_len = ((length + AES_BLOCK_SIZE - 1) / AES_BLOCK_SIZE) * AES_BLOCK_SIZE;
    *output_length = padded_len;

    // 创建临时缓冲区
    uint8_t* padded_input = new uint8_t[padded_len];

    // 复制原始数据
    memcpy(padded_input, input, length);

    // PKCS7 填充
    uint8_t pad_value = padded_len - length;
    for (size_t i = length; i < padded_len; i++) {
        padded_input[i] = pad_value;
    }

    // 逐块加密
    for (size_t i = 0; i < padded_len; i += AES_BLOCK_SIZE) {
        AES_encrypt_block(ctx, padded_input + i, output + i);
    }

    delete[] padded_input;
}

/**
 * 带PKCS7填充的解密函数
 * 包含填充验证和错误处理
 * @param ctx AES上下文
 * @param input 输入数据
 * @param length 输入数据长度
 * @param output 输出缓冲区
 * @param output_length 输出数据长度
 */
void AES_decrypt_with_padding(const AES_CTX *ctx, const uint8_t *input, size_t length, uint8_t *output, size_t *output_length) {
    if (length == 0 || length % AES_BLOCK_SIZE != 0) {
        *output_length = 0;
        return;
    }

    // 创建临时缓冲区
    uint8_t* decrypted = new uint8_t[length];

    // 逐块解密
    for (size_t i = 0; i < length; i += AES_BLOCK_SIZE) {
        AES_decrypt_block(ctx, input + i, decrypted + i);
    }

    // 获取填充长度
    uint8_t padding_len = decrypted[length - 1];

    // 验证填充长度
    if (padding_len == 0 || padding_len > AES_BLOCK_SIZE || padding_len > length) {
        // 如果填充无效，返回原始解密数据
        memcpy(output, decrypted, length);
        *output_length = length;
        delete[] decrypted;
        return;
    }

    // 验证所有填充字节
    bool padding_valid = true;
    for (size_t i = length - padding_len; i < length; i++) {
        if (decrypted[i] != padding_len) {
            padding_valid = false;
            break;
        }
    }

    if (!padding_valid) {
        // 如果填充验证失败，返回原始解密数据
        memcpy(output, decrypted, length);
        *output_length = length;
    } else {
        // 填充验证成功，移除填充
        *output_length = length - padding_len;
        memcpy(output, decrypted, *output_length);
    }

    delete[] decrypted;
}

/**
 * 生成逆S-box的辅助函数
 * 用于验证S-box和逆S-box的对应关系
 */
void generate_inverse_sbox() {
    uint8_t inv_sbox[256];
    for (int i = 0; i < 256; i++) {
        uint8_t value = SBOX[i];
        inv_sbox[value] = i;
    }

    // 使用Android日志输出
    LOGI("static const uint8_t INV_SBOX[256] = {");
    for (int i = 0; i < 256; i++) {
        if (i % 16 == 0) {
            LOGI("    ");
        }
        LOGI("0x%02x%s", inv_sbox[i], (i == 255 ? "" : ", "));
        if ((i + 1) % 16 == 0 && i != 255) {
            LOGI("\n");
        }
    }
    LOGI("\n};");
}
//
//// 示例函数也改用Android日志
//void example() {
//    // 1. 准备密钥
//    uint8_t key[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
//
//    // 2. 初始化上下文
//    AES_CTX ctx;
//    AES_init(&ctx, key);
//
//    // 3. 准备要加密的数据
//    const char* message = "Hello, World!"; // 13字节
//    size_t message_len = strlen(message);
//
//    // 4. 计算输出缓冲区大小
//    size_t output_len;
//    size_t padded_len = ((message_len + AES_BLOCK_SIZE - 1) / AES_BLOCK_SIZE) * AES_BLOCK_SIZE;
//    uint8_t* encrypted = new uint8_t[padded_len];
//
//    // 5. 加密
//    AES_encrypt_with_padding(&ctx, (const uint8_t*)message, message_len,
//                             encrypted, &output_len);
//
//    // 6. 使用加密后的数据
//    char hex_output[output_len * 3 + 1];
//    char* p = hex_output;
//    for (size_t i = 0; i < output_len; i++) {
//        p += sprintf(p, "%02x ", encrypted[i]);
//    }
//    LOGI("Encrypted data: %s", hex_output);
//
//    delete[] encrypted;
//}

```

`app/src/main/cpp/src/crypto/Base64.cpp`:

```cpp
#include "../inc/crypto/crypto.h"

// 魔改的 Base64 编码表
static const char base64_table[64] = {
        'A', 'B', 'P', 'D', 'E', 'F', 'T', 'H', 'I', 'J', 'K', 'L', 'M',
        'N', 'O', 'C', 'Q', 'R', 'S', 'G', 'U', 'V', 'W', 'X', 'Y', 'Z',
        'a', 'b', 'c', 'd', 'e', 's', 'g', 'h', 'i', 'j', 'k', 'y', 'm',
        'n', 'o', 'p', 'q', 'r', 'f', 't', 'u', 'v', 'w', 'x', 'l', 'z',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '/', '='
};

// 生成解码表
static unsigned char base64_reverse_table[256];
static bool base64_reverse_table_initialized = false;

// 初始化解码表
static void init_base64_reverse_table() {
    if (base64_reverse_table_initialized) return;

    // 初始化所有值为无效值
    memset(base64_reverse_table, 0xFF, 256);

    // 填充有效值
    for (int i = 0; i < 64; i++) {
        base64_reverse_table[(unsigned char)base64_table[i]] = i;
    }

    base64_reverse_table_initialized = true;
}

// 计算Base64编码后的长度
size_t BASE64_encode_len(size_t input_length) {
    return ((input_length + 2) / 3) * 4;
}

// Base64编码
void BASE64_encode(const uint8_t *input, size_t input_length, char *output) {
    size_t i = 0;
    size_t j = 0;

    // 每次处理3个字节
    while (i + 2 < input_length) {
        uint32_t b = (input[i] << 16) | (input[i + 1] << 8) | input[i + 2];
        output[j] = base64_table[(b >> 18) & 0x3F];
        output[j + 1] = base64_table[(b >> 12) & 0x3F];
        output[j + 2] = base64_table[(b >> 6) & 0x3F];
        output[j + 3] = base64_table[b & 0x3F];
        i += 3;
        j += 4;
    }

    // 处理剩余字节
    if (i < input_length) {
        uint32_t b = input[i] << 16;
        if (i + 1 < input_length) {
            b |= input[i + 1] << 8;
        }

        output[j] = base64_table[(b >> 18) & 0x3F];
        output[j + 1] = base64_table[(b >> 12) & 0x3F];

        if (i + 1 < input_length) {
            output[j + 2] = base64_table[(b >> 6) & 0x3F];
            output[j + 3] = '*';  // 一个填充字符
        } else {
            output[j + 2] = '*';  // 两个填充字符
            output[j + 3] = '*';
        }
        j += 4;
    }

    output[j] = '\0';
}

// 计算Base64解码后的长度
size_t BASE64_decode_len(const char *input) {
    size_t len = strlen(input);
    size_t padding = 0;

    if (len >= 2) {
        if (input[len - 1] == '*') padding++;
        if (input[len - 2] == '*') padding++;
    }

    return (len / 4) * 3 - padding;
}

// Base64解码
int BASE64_decode(const char *input, size_t input_length, uint8_t *output, size_t *output_length) {
    if (!base64_reverse_table_initialized) {
        init_base64_reverse_table();
    }

    size_t i = 0;
    size_t j = 0;
    uint32_t b = 0;

    while (i + 3 < input_length) {
        unsigned char b1 = base64_reverse_table[(unsigned char)input[i]];
        unsigned char b2 = base64_reverse_table[(unsigned char)input[i + 1]];
        unsigned char b3 = base64_reverse_table[(unsigned char)input[i + 2]];
        unsigned char b4 = base64_reverse_table[(unsigned char)input[i + 3]];

        // 检查无效字符
        if (b1 == 0xFF || b2 == 0xFF ||
            (input[i + 2] != '*' && b3 == 0xFF) ||
            (input[i + 3] != '*' && b4 == 0xFF)) {
            return -1;
        }

        b = (b1 << 18) | (b2 << 12);
        if (input[i + 2] != '*') {
            b |= b3 << 6;
        }
        if (input[i + 3] != '*') {
            b |= b4;
        }

        output[j] = (b >> 16) & 0xFF;
        if (input[i + 2] != '*') {
            output[j + 1] = (b >> 8) & 0xFF;
        }
        if (input[i + 3] != '*') {
            output[j + 2] = b & 0xFF;
        }

        i += 4;
        j += 3;
        if (input[i - 1] == '*') j--;
        if (input[i - 2] == '*') j--;
    }

    *output_length = j;
    return 0;
}

// 带缓冲区分配的编码函数
char* BASE64_encode_alloc(const uint8_t *input, size_t input_length, size_t *output_length) {
    *output_length = BASE64_encode_len(input_length);
    char *output = new char[*output_length + 1];  // +1 for null terminator
    if (output) {
        BASE64_encode(input, input_length, output);
    }
    return output;
}

// 带缓冲区分配的解码函数
uint8_t* BASE64_decode_alloc(const char *input, size_t input_length, size_t *output_length) {
    *output_length = BASE64_decode_len(input);
    uint8_t *output = new uint8_t[*output_length];
    if (output) {
        if (BASE64_decode(input, input_length, output, output_length) != 0) {
            delete[] output;
            return nullptr;
        }
    }
    return output;
}
//void example() {
//    // 编码示例
//    const char* message = "Hello, World!";
//    size_t input_len = strlen(message);
//    size_t output_len;
//
//    // 使用自动分配内存的版本
//    char* encoded = BASE64_encode_alloc((const uint8_t*)message, input_len, &output_len);
//    if (encoded) {
//        printf("Encoded: %s\n", encoded);
//
//        // 解码
//        size_t decoded_len;
//        uint8_t* decoded = BASE64_decode_alloc(encoded, output_len, &decoded_len);
//        if (decoded) {
//            printf("Decoded: %.*s\n", (int)decoded_len, decoded);
//            delete[] decoded;
//        }
//
//        delete[] encoded;
//    }
//
//    // 或者使用预分配缓冲区的版本
//    size_t encode_buf_size = BASE64_encode_len(input_len);
//    char* encode_buf = new char[encode_buf_size + 1];  // +1 for null terminator
//
//    BASE64_encode((const uint8_t*)message, input_len, encode_buf);
//    printf("Encoded: %s\n", encode_buf);
//
//    size_t decode_buf_size = BASE64_decode_len(encode_buf);
//    uint8_t* decode_buf = new uint8_t[decode_buf_size];
//
//    BASE64_decode(encode_buf, strlen(encode_buf), decode_buf, &decode_buf_size);
//    printf("Decoded: %.*s\n", (int)decode_buf_size, decode_buf);
//
//    delete[] encode_buf;
//    delete[] decode_buf;
//}
```

`app/src/main/cpp/src/crypto/EncryptManager.cpp`:

```cpp
#include <android/log.h>
#include "../../inc/crypto/EncryptManager.h"
#include <sstream>
#include <iomanip>
#include <chrono>
#include <random>
#include <vector>
#include <cstring>
#include <cstdlib>
#include <ctime>
#define TAG "EncryptManager"
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, TAG, __VA_ARGS__)

EncryptManager* EncryptManager::instance = nullptr;

EncryptManager::EncryptManager() {
    // 初始化MD5上下文
    MD5Init(&md5_ctx);
}

EncryptManager::~EncryptManager() {
    // 清理工作（如果需要）
}

EncryptManager* EncryptManager::getInstance() {
    if (instance == nullptr) {
        instance = new EncryptManager();
    }
    return instance;
}

std::string EncryptManager::generateUUID() {
    static std::random_device rd;
    static std::mt19937 gen(rd());
    static std::uniform_int_distribution<> dis(0, 15);
    static const char* digits = "0123456789abcdef";

    std::string uuid;
    uuid.reserve(36);

    for (int i = 0; i < 36; i++) {
        if (i == 8 || i == 13 || i == 18 || i == 23) {
            uuid += '-';
        } else {
            uuid += digits[dis(gen)];
        }
    }

    return uuid;
}

std::string EncryptManager::generateTimestamp() {
    auto now = std::chrono::system_clock::now();
    auto duration = now.time_since_epoch();
    auto seconds = std::chrono::duration_cast<std::chrono::seconds>(duration).count();
    return std::to_string(seconds);
}

std::string EncryptManager::generateSalt(const std::string& uuid, const std::string& timestamp) {
    std::string combined = uuid + timestamp;
    
    // 使用魔改的MD5
    MD5Init(&md5_ctx);
    MD5Update(&md5_ctx, (const uint8_t*)combined.c_str(), combined.length());
    
    uint8_t digest[16];
    MD5Final(digest, &md5_ctx);
    
    // 将MD5结果转换为十六进制字符串
    std::stringstream ss;
    ss << std::hex << std::setfill('0');
    for (int i = 0; i < 16; i++) {
        ss << std::setw(2) << static_cast<int>(digest[i]);
    }
    
    return ss.str();
}

std::string EncryptManager::generateKey(const std::string& uuid, const std::string& timestamp, const std::string& salt) {
    return timestamp + uuid + salt;
}

std::string EncryptManager::generateAESKey(const std::string& salt) {
    // 1. 生成 key1：每间隔一位取16位
    std::string key1;
    for (size_t i = 0; i < salt.length() && key1.length() < 16; i += 2) {
        key1 += salt[i];
    }
    // 补齐 key1 到16位
    while (key1.length() < 16) {
        key1 += '0';
    }
    
    // 2. 生成 key2：剩余位倒序
    std::string key2;
    for (size_t i = 1; i < salt.length() && key2.length() < 16; i += 2) {
        key2 = salt[i] + key2; // 倒序添加
    }
    // 补齐 key2 到16位
    while (key2.length() < 16) {
        key2 = '0' + key2;
    }
    
    // 3. key1 和 key2 每一位异或生成最终的 AES key
    std::string aesKey;
    for (size_t i = 0; i < 16; i++) {
        aesKey += static_cast<char>(key1[i] ^ key2[i]);
    }
    
    LOGI("Key1: %s", key1.c_str());
    LOGI("Key2: %s", key2.c_str());
    
    return aesKey;
}

unsigned char EncryptManager::generateSum(const std::string& salt) {
    // 获取 timestamp 的最后一位
    std::string timestamp = generateTimestamp();
    char timestampLastChar = timestamp[timestamp.length() - 1];

    // 获取 salt 的最后一位
    char saltLastChar = salt[salt.length() - 1];

    // 进行异或运算
    char result = timestampLastChar ^ saltLastChar;

    // 如果结果为负数，生成1-50的随机数
    if (result < 0) {
        // 使用当前时间作为种子
        std::srand(std::time(nullptr));
        // 生成1-50的随机数
        result = (std::rand() % 50) + 1;
    }

    return static_cast<unsigned char>(result);
}

std::string EncryptManager::insertKey(const std::string& base64Result, const std::string& key, unsigned char sum) {
    std::string result = base64Result;
    size_t step = sum + 1; // 间隔值
    size_t currentPos = sum % result.length(); // 初始位置
    
    // 按照间隔值插入 key 的每个字符
    for (char c : key) {
        result.insert(currentPos, 1, c);
        currentPos = (currentPos + step) % (result.length() + 1); // 移动到下一个插入位置
    }
    
    return result + "+" + std::to_string(static_cast<int>(sum));
}

std::string EncryptManager::encryptData(const std::string& data) {
    // 1. 生成基础值
    std::string timestamp = generateTimestamp();
    std::string uuid = generateUUID();
    std::string salt = generateSalt(uuid, timestamp);
    std::string key = generateKey(uuid, timestamp, salt);
    
    LOGI("Timestamp: %s", timestamp.c_str());
    LOGI("UUID: %s", uuid.c_str());
    LOGI("Salt: %s", salt.c_str());
    LOGI("Key: %s", key.c_str());
    
    // 2. 生成AES密钥
    std::string aesKey = generateAESKey(salt);
    LOGI("AES Key: %s", aesKey.c_str());
    
    // 3. 初始化AES上下文并加密
    AES_init(&aes_ctx, (const uint8_t*)aesKey.c_str());
    
    // 计算填充后的长度
    size_t padded_len = ((data.length() + AES_BLOCK_SIZE - 1) / AES_BLOCK_SIZE) * AES_BLOCK_SIZE;
    std::vector<uint8_t> input_data(padded_len, 0);
    std::vector<uint8_t> encrypted(padded_len, 0);
    
    // 复制数据并填充
    memcpy(input_data.data(), data.c_str(), data.length());
    uint8_t pad_value = padded_len - data.length();
    for (size_t i = data.length(); i < padded_len; i++) {
        input_data[i] = pad_value;
    }
    
    // 逐块加密
    for (size_t i = 0; i < padded_len; i += AES_BLOCK_SIZE) {
        AES_encrypt_block(&aes_ctx, &input_data[i], &encrypted[i]);
    }
    
    // 4. Base64编码
    size_t base64_len;
    char* base64_result = BASE64_encode_alloc(encrypted.data(), padded_len, &base64_len);
    
    std::string base64String(base64_result);
    delete[] base64_result;
    
    LOGI("Base64 Result: %s", base64String.c_str());
    
    // 5. 生成sum并插入key
    unsigned char sum = generateSum(salt);
    LOGI("Sum: %d", sum);
    
    // 6. 最终加密结果
    std::string finalResult = insertKey(base64String, key, sum);
    LOGI("Final Result: %s", finalResult.c_str());
    
    return finalResult;
} 
```

`app/src/main/cpp/src/crypto/MD5.cpp`:

```cpp
#include "../../inc/crypto/crypto.h"

// 每轮操作的左移位数
static const uint8_t S[] = {
    9, 14, 19, 24,  9, 14, 19, 24,  9, 14, 19, 24,  9, 14, 19, 24,
    7, 11, 16, 22,  7, 11, 16, 22,  7, 11, 16, 22,  7, 11, 16, 22,
    6, 13, 18, 25,  6, 13, 18, 25,  6, 13, 18, 25,  6, 13, 18, 25,
    8, 12, 17, 23,  8, 12, 17, 23,  8, 12, 17, 23,  8, 12, 17, 23
};

// 常量表
static const uint32_t K[] = {
    0xc76aa478, 0xf8c7b756, 0x242070db, 0xc1bdceee,
    0xe57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
    0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
    0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
    0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
    0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
    0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
    0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
    0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
    0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
    0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
    0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
    0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
    0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
    0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
    0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391
};

// 基本MD5函数
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)) ^ (y))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)) ^ (x))
#define H(x, y, z) ((x) ^ (y) ^ (z) ^ (x & y))
#define I(x, y, z) ((y) ^ ((x) | (~z)) ^ (z))

// 循环左移
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))

// 四轮操作
#define FF(a, b, c, d, x, s, ac) { \
    (a) += F((b), (c), (d)) + (x) + (uint32_t)(ac); \
    (a) = ROTATE_LEFT((a), (s)); \
    (a) += (b); \
}
#define GG(a, b, c, d, x, s, ac) { \
    (a) += G((b), (c), (d)) + (x) + (uint32_t)(ac); \
    (a) = ROTATE_LEFT((a), (s)); \
    (a) += (b); \
}
#define HH(a, b, c, d, x, s, ac) { \
    (a) += H((b), (c), (d)) + (x) + (uint32_t)(ac); \
    (a) = ROTATE_LEFT((a), (s)); \
    (a) += (b); \
}
#define II(a, b, c, d, x, s, ac) { \
    (a) += I((b), (c), (d)) + (x) + (uint32_t)(ac); \
    (a) = ROTATE_LEFT((a), (s)); \
    (a) += (b); \
}

// 初始化MD5上下文
void MD5Init(MD5_CTX *context) {
    context->count[0] = context->count[1] = 0;
    // 原始值
    // context->state[0] = 0x67452301;
    // context->state[1] = 0xefcdab89;
    // context->state[2] = 0x98badcfe;
    // context->state[3] = 0x10325476;
    
    // 修改为自定义值
    context->state[0] = 0x71452301;
    context->state[1] = 0xefcdab79;
    context->state[2] = 0x98badcae;
    context->state[3] = 0x10325496;
}

// MD5核心转换
static void MD5Transform(uint32_t state[4], const uint8_t block[64]) {
    uint32_t a = state[0], b = state[1], c = state[2], d = state[3];
    uint32_t x[16];

    // 将64字节块转换为16个32位字
    for (int i = 0, j = 0; i < 16; ++i, j += 4)
        x[i] = ((uint32_t)block[j]) | (((uint32_t)block[j+1]) << 8) |
               (((uint32_t)block[j+2]) << 16) | (((uint32_t)block[j+3]) << 24);

    // 第1轮
    FF(a, b, c, d, x[ 0], S[ 0], K[ 0]);
    FF(d, a, b, c, x[ 1], S[ 1], K[ 1]);
    FF(c, d, a, b, x[ 2], S[ 2], K[ 2]);
    FF(b, c, d, a, x[ 3], S[ 3], K[ 3]);
    FF(a, b, c, d, x[ 4], S[ 4], K[ 4]);
    FF(d, a, b, c, x[ 5], S[ 5], K[ 5]);
    FF(c, d, a, b, x[ 6], S[ 6], K[ 6]);
    FF(b, c, d, a, x[ 7], S[ 7], K[ 7]);
    FF(a, b, c, d, x[ 8], S[ 8], K[ 8]);
    FF(d, a, b, c, x[ 9], S[ 9], K[ 9]);
    FF(c, d, a, b, x[10], S[10], K[10]);
    FF(b, c, d, a, x[11], S[11], K[11]);
    FF(a, b, c, d, x[12], S[12], K[12]);
    FF(d, a, b, c, x[13], S[13], K[13]);
    FF(c, d, a, b, x[14], S[14], K[14]);
    FF(b, c, d, a, x[15], S[15], K[15]);

    // 第2轮
    GG(a, b, c, d, x[ 1], S[16], K[16]);
    GG(d, a, b, c, x[ 6], S[17], K[17]);
    GG(c, d, a, b, x[11], S[18], K[18]);
    GG(b, c, d, a, x[ 0], S[19], K[19]);
    GG(a, b, c, d, x[ 5], S[20], K[20]);
    GG(d, a, b, c, x[10], S[21], K[21]);
    GG(c, d, a, b, x[15], S[22], K[22]);
    GG(b, c, d, a, x[ 4], S[23], K[23]);
    GG(a, b, c, d, x[ 9], S[24], K[24]);
    GG(d, a, b, c, x[14], S[25], K[25]);
    GG(c, d, a, b, x[ 3], S[26], K[26]);
    GG(b, c, d, a, x[ 8], S[27], K[27]);
    GG(a, b, c, d, x[13], S[28], K[28]);
    GG(d, a, b, c, x[ 2], S[29], K[29]);
    GG(c, d, a, b, x[ 7], S[30], K[30]);
    GG(b, c, d, a, x[12], S[31], K[31]);

    // 第3轮
    HH(a, b, c, d, x[ 5], S[32], K[32]);
    HH(d, a, b, c, x[ 8], S[33], K[33]);
    HH(c, d, a, b, x[11], S[34], K[34]);
    HH(b, c, d, a, x[14], S[35], K[35]);
    HH(a, b, c, d, x[ 1], S[36], K[36]);
    HH(d, a, b, c, x[ 4], S[37], K[37]);
    HH(c, d, a, b, x[ 7], S[38], K[38]);
    HH(b, c, d, a, x[10], S[39], K[39]);
    HH(a, b, c, d, x[13], S[40], K[40]);
    HH(d, a, b, c, x[ 0], S[41], K[41]);
    HH(c, d, a, b, x[ 3], S[42], K[42]);
    HH(b, c, d, a, x[ 6], S[43], K[43]);
    HH(a, b, c, d, x[ 9], S[44], K[44]);
    HH(d, a, b, c, x[12], S[45], K[45]);
    HH(c, d, a, b, x[15], S[46], K[46]);
    HH(b, c, d, a, x[ 2], S[47], K[47]);

    // 第4轮
    II(a, b, c, d, x[ 0], S[48], K[48]);
    II(d, a, b, c, x[ 7], S[49], K[49]);
    II(c, d, a, b, x[14], S[50], K[50]);
    II(b, c, d, a, x[ 5], S[51], K[51]);
    II(a, b, c, d, x[12], S[52], K[52]);
    II(d, a, b, c, x[ 3], S[53], K[53]);
    II(c, d, a, b, x[10], S[54], K[54]);
    II(b, c, d, a, x[ 1], S[55], K[55]);
    II(a, b, c, d, x[ 8], S[56], K[56]);
    II(d, a, b, c, x[15], S[57], K[57]);
    II(c, d, a, b, x[ 6], S[58], K[58]);
    II(b, c, d, a, x[13], S[59], K[59]);
    II(a, b, c, d, x[ 4], S[60], K[60]);
    II(d, a, b, c, x[11], S[61], K[61]);
    II(c, d, a, b, x[ 2], S[62], K[62]);
    II(b, c, d, a, x[ 9], S[63], K[63]);

    state[0] += a;
    state[1] += b;
    state[2] += c;
    state[3] += d;
}

// 更新MD5上下文
void MD5Update(MD5_CTX *context, const uint8_t *input, size_t inputLen) {
    size_t i, index, partLen;

    // 计算已有数据的位数
    index = (context->count[0] >> 3) & 0x3F;

    // 更新位数计数器
    if ((context->count[0] += ((uint32_t)inputLen << 3)) < ((uint32_t)inputLen << 3))
        context->count[1]++;
    context->count[1] += ((uint32_t)inputLen >> 29);

    partLen = 64 - index;

    // 分块转换
    if (inputLen >= partLen) {
        memcpy(&context->buffer[index], input, partLen);
        MD5Transform(context->state, context->buffer);

        for (i = partLen; i + 63 < inputLen; i += 64)
            MD5Transform(context->state, &input[i]);

        index = 0;
    } else {
        i = 0;
    }

    // 缓存剩余数据
    memcpy(&context->buffer[index], &input[i], inputLen - i);
}

// 完成MD5计算
void MD5Final(uint8_t digest[16], MD5_CTX *context) {
    uint8_t bits[8];
    size_t index, padLen;

    // 保存位数
    for (int i = 0; i < 8; i++)
        bits[i] = (uint8_t)(context->count[i >> 2] >> ((i & 0x03) << 3));

    // 填充数据
    index = (context->count[0] >> 3) & 0x3f;
    padLen = (index < 56) ? (56 - index) : (120 - index);

    uint8_t padding[64];
    memset(padding, 0, sizeof(padding));
    padding[0] = 0x91;

    MD5Update(context, padding, padLen);
    MD5Update(context, bits, 8);

    // 输出摘要
    for (int i = 0; i < 16; i++)
        digest[i] = (uint8_t)(context->state[i >> 2] >> ((i & 0x03) << 3));
}


//魔改：
// 1. 修改常量表
// 2. 修改轮常量    
// 3. 修改轮函数
// 4. 修改轮操作
// 5. 修改初始化常量值

//使用示例
// Java_CryptoNative_md5Native(JNIEnv *env, jclass clazz, jbyteArray input) {
//    MD5_CTX context;
//    uint8_t digest[16];
//
//    jbyte *buffer = env->GetByteArrayElements(input, NULL);
//    jsize length = env->GetArrayLength(input);
//
//    MD5Init(&context);
//    MD5Update(&context, (uint8_t*)buffer, length);
//    MD5Final(digest, &context);
//
//    env->ReleaseByteArrayElements(input, buffer, JNI_ABORT);
//
//    jbyteArray result = env->NewByteArray(16);
//    env->SetByteArrayRegion(result, 0, 16, (jbyte*)digest);
//
//    return result;
//}
```

`app/src/main/cpp/src/detector/FridaDetector.cpp`:

```cpp
#include "../../inc/detector/FridaDetector.h"


const std::string FridaDetector::CHECK_FRIDA = "frida_check";

FridaDetector::FridaDetector()
        : isRunning(false), javaVM(nullptr), globalCallback(nullptr),
          isAbnormalStateReported(false) , isMapsAbnormalReported(false){
}

FridaDetector::~FridaDetector() {
    stop();
}

void FridaDetector::detect(JNIEnv* env, jobject callback) {
    try {
        if (isRunning) {
            LOGD("Detection already running");
            return;
        }

        if (!env || !callback) {
            LOGE("Invalid parameters: env or callback is null");
            return;
        }

        // 获取JavaVM
        if (env->GetJavaVM(&javaVM) != JNI_OK) {
            LOGE("Failed to get JavaVM");
            return;
        }

        // 创建全局引用
        globalCallback = env->NewGlobalRef(callback);
        if (!globalCallback) {
            LOGE("Failed to create global reference");
            return;
        }

        try {
            detectFridaFile(env);
        }  catch (...) {

        }

        isRunning = true;
        int result = pthread_create(&threadId, nullptr, threadFunction, this);
        if (result != 0) {
            LOGE("Failed to create thread: %s", strerror(result));
            cleanup();
            return;
        }
    } catch (const std::exception& e) {
        LOGE("Exception in detect: %s", e.what());
        cleanup();
    } catch (...) {
        LOGE("Unknown exception in detect");
        cleanup();
    }
}

void* FridaDetector::threadFunction(void* arg) {
    FridaDetector* detector = static_cast<FridaDetector*>(arg);

    // 设置线程名
    prctl(PR_SET_NAME, "warlockcf");

    // 获取JNI环境
    JNIEnv* env = nullptr;
    JavaVMAttachArgs args;
    args.version = JNI_VERSION_1_6;
    args.name = "FridaDetector";
    args.group = nullptr;

    if (detector->javaVM->AttachCurrentThread(&env, &args) != JNI_OK || !env) {
        LOGE("Failed to attach thread to JVM");
        return nullptr;
    }

    // 主检测循环
    while (detector->isRunning) {
        try {
            detector->detectFridaPorts(env);
            detector->detectFridaInMaps(env);

        } catch (const std::exception& e) {
            LOGE("Exception in detection loop: %s", e.what());
        } catch (...) {
            LOGE("Unknown exception in detection loop");
        }
        usleep(3000 * 1000);
    }

    detector->javaVM->DetachCurrentThread();
    return nullptr;
}
void FridaDetector::cleanup() {
    isRunning = false;

    if (javaVM && globalCallback) {
        JNIEnv* env = nullptr;
        if (javaVM->AttachCurrentThread(&env, nullptr) == JNI_OK && env) {
            env->DeleteGlobalRef(globalCallback);
            javaVM->DetachCurrentThread();
        }
    }

    globalCallback = nullptr;
    javaVM = nullptr;
    resetDetectionState();
}
void FridaDetector::detectFridaPorts(JNIEnv* env) {
    if (!env || !globalCallback) {
        LOGE("Invalid JNI environment or callback");
        return;
    }

    const int FRIDA_DEFAULT_PORT = 27042;
    const int knownPorts[] = {27042, 6666, 9999, 6699};
    const int knownPortsCount = sizeof(knownPorts) / sizeof(knownPorts[0]);

    try {
        struct sockaddr_in sa;
        memset(&sa, 0, sizeof(sa));
        sa.sin_family = AF_INET;
        sa.sin_addr.s_addr = htonl(INADDR_LOOPBACK);

        bool foundNewPort = false;
        std::string newDetectedPorts;

        for (int i = 0; i < knownPortsCount; i++) {
            if (detectedPorts.find(knownPorts[i]) != detectedPorts.end()) {
                continue;
            }

            int sock = socket(AF_INET, SOCK_STREAM, 0);
            if (sock == -1) {
                LOGD("Failed to create socket: %s", strerror(errno));
                continue;
            }

            // 设置socket超时
            struct timeval timeout;
            timeout.tv_sec = 1;
            timeout.tv_usec = 0;
            setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));
            setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(timeout));

            sa.sin_port = htons(knownPorts[i]);
            if (connect(sock, (struct sockaddr*)&sa, sizeof(sa)) != -1) {
                LOGD("Found new suspicious port: %d", knownPorts[i]);
                detectedPorts.insert(knownPorts[i]);
                foundNewPort = true;
                if (!newDetectedPorts.empty()) {
                    newDetectedPorts += ", ";
                }
                newDetectedPorts += std::to_string(knownPorts[i]);
            }
            close(sock);
        }

        if (foundNewPort && env->ExceptionCheck()) {
            env->ExceptionClear();
        }

        // 只在发现新端口时报告
        if (foundNewPort) {
            std::string detail;
            std::string checkType;

            if (detectedPorts.find(FRIDA_DEFAULT_PORT) != detectedPorts.end()) {
                detail = "port: " + newDetectedPorts;
                checkType = "checkFridaPort_native";
            } else {
                detail = "ports: " + newDetectedPorts;
                checkType = "checkAbnormalPorts_native";
            }

            if (!isAbnormalStateReported) {
                isAbnormalStateReported = true;
            }

            DetectorUtils::reportWarning(env, globalCallback,
                                         checkType,
                                         DetectorUtils::LEVEL_HIGH,
                                         detail);
        }
    } catch (const std::exception& e) {
        LOGE("Exception in detectFridaPorts: %s", e.what());
    } catch (...) {
        LOGE("Unknown exception in detectFridaPorts");
    }
}
void FridaDetector::detectFridaFile(JNIEnv* env) {
    try {
        const char* targetPath = "/data/local/tmp";
        int fd;
                // Android 系统调用号
        #if defined(__aarch64__)
                const long SYSCALL_OPEN = 56;        // openat for arm64
                const long SYSCALL_GETDENTS64 = 61;  // getdents64 for arm64
                const long SYSCALL_CLOSE = 57;       // close for arm64
        #elif defined(__arm__)
                const long SYSCALL_OPEN = 5;         // open for arm
                const long SYSCALL_GETDENTS64 = 217; // getdents64 for arm
                const long SYSCALL_CLOSE = 6;        // close for arm
                #elif defined(__x86_64__)
                const long SYSCALL_OPEN = 2;         // open for x86_64
                const long SYSCALL_GETDENTS64 = 217; // getdents64 for x86_64
                const long SYSCALL_CLOSE = 3;        // close for x86_64
                #elif defined(__i386__)
                const long SYSCALL_OPEN = 5;         // open for x86
                const long SYSCALL_GETDENTS64 = 220; // getdents64 for x86
                const long SYSCALL_CLOSE = 6;        // close for x86
                #else
                #error "Unsupported architecture"
        #endif
        // 使用系统调用打开目录
        fd = utils::SyscallUtils::syscall(SYSCALL_OPEN, (long)targetPath, O_RDONLY | O_DIRECTORY);
        if (fd < 0) {
            LOGE("Failed to open directory: %s", strerror(errno));
            return;
        }

        char buf[1024];
        int nread;
        struct linux_dirent64 {
            uint64_t        d_ino;
            int64_t         d_off;
            unsigned short  d_reclen;
            unsigned char   d_type;
            char           d_name[];
        };

        bool foundFrida = false;
        std::string foundFile;

        // 读取目录内容
        while ((nread = utils::SyscallUtils::syscall(SYS_getdents64, fd, (long)buf, sizeof(buf))) > 0) {
            for (int bpos = 0; bpos < nread;) {
                struct linux_dirent64* d = (struct linux_dirent64*)(buf + bpos);
                std::string filename(d->d_name);

                // 检查文件名是否包含 frida-server
                if (filename.find("frida-server") != std::string::npos) {
                    foundFrida = true;
                    foundFile = filename;
                    break;
                }

                bpos += d->d_reclen;
            }

            if (foundFrida) break;
        }

        // 关闭目录
        utils::SyscallUtils::syscall(SYS_close, fd);

        // 如果找到frida-server，报告警告
        if (foundFrida) {
            std::string detail =  targetPath + foundFile;

            DetectorUtils::reportWarning(env, globalCallback,
                                         "checkFridaFile_native",
                                         DetectorUtils::LEVEL_HIGH,
                                         detail);
        }

    } catch (const std::exception& e) {
        LOGE("Exception in detectFridaServer: %s", e.what());
    } catch (...) {
        LOGE("Unknown exception in detectFridaServer");
    }
}
void FridaDetector::detectFridaInMaps(JNIEnv* env) {
    // 如果已经报告过，直接返回
    if (isMapsAbnormalReported) {
        return;
    }
    try {
        // Android 系统调用号
#if defined(__aarch64__)
        const long SYSCALL_OPENAT = 56;
        const long SYSCALL_READ = 63;
        const long SYSCALL_CLOSE = 57;
#elif defined(__arm__)
        const long SYSCALL_OPENAT = 322;
        const long SYSCALL_READ = 3;
        const long SYSCALL_CLOSE = 6;
        #elif defined(__x86_64__)
        const long SYSCALL_OPENAT = 257;
        const long SYSCALL_READ = 0;
        const long SYSCALL_CLOSE = 3;

        #elif defined(__i386__)
        const long SYSCALL_OPENAT = 295;    // openat for x86
        const long SYSCALL_READ = 3;        // read for x86
        const long SYSCALL_CLOSE = 6;       // close for x86
        #else
        #error "Unsupported architecture"
#endif

        // 打开 /proc/self/maps
        int fd = utils::SyscallUtils::syscall(SYSCALL_OPENAT, AT_FDCWD, (long)"/proc/self/maps", O_RDONLY);
        if (fd < 0) {
            LOGE("Failed to open maps: %s", strerror(errno));
            return;
        }

        char buffer[4096];
        std::string content;
        bool foundSuspicious = false;
        std::vector<std::string> suspiciousEntries;

        // 读取文件内容
        while (true) {
            long bytes = utils::SyscallUtils::syscall(SYSCALL_READ, fd, (long)buffer, sizeof(buffer));
            if (bytes <= 0) break;

            content.append(buffer, bytes);

            // 查找可疑字符串
            size_t pos = 0;
            while ((pos = content.find('\n')) != std::string::npos) {
                std::string line = content.substr(0, pos);
                content.erase(0, pos + 1);

                // 检查是否包含可疑字符串
                if (line.find("frida") != std::string::npos ||
                    line.find("agent") != std::string::npos ||
                    line.find("gadget") != std::string::npos ||
                    line.find("gum-js-loop") != std::string::npos){

                    foundSuspicious = true;
                    suspiciousEntries.push_back(line);
                }
            }
        }

        // 关闭文件
        utils::SyscallUtils::syscall(SYSCALL_CLOSE, fd);

        // 如果找到可疑内容，报告警告
        if (foundSuspicious) {
            std::string detail;
            for (const auto& entry : suspiciousEntries) {
                detail += entry + "\n";
            }

            DetectorUtils::reportWarning(env, globalCallback,
                                         "checkFridaInMaps_native",
                                         DetectorUtils::LEVEL_HIGH,
                                         detail);
            isMapsAbnormalReported = true;
        }

    } catch (const std::exception& e) {
        LOGE("Exception in detectFridaInMaps: %s", e.what());
    } catch (...) {
        LOGE("Unknown exception in detectFridaInMaps");
    }
}
void FridaDetector::stop() {
    if (!isRunning) {
        return;
    }

    try {
        isRunning = false;
        if (pthread_join(threadId, nullptr) != 0) {
            LOGE("Failed to join thread: %s", strerror(errno));
        }
        cleanup();
    } catch (const std::exception& e) {
        LOGE("Exception in stop: %s", e.what());
    } catch (...) {
        LOGE("Unknown exception in stop");
    }
}

void FridaDetector::resetDetectionState() {
    detectedPorts.clear();
    isAbnormalStateReported = false;
    isMapsAbnormalReported = false;
}

```

`app/src/main/cpp/src/detector/MiscDetector.cpp`:

```cpp
#include "../../inc/detector/MiscDetector.h"
#include <errno.h>
#include <string.h>

const std::string MiscDetector::CHECK_MISC = "misc_check";

MiscDetector::MiscDetector()
        : isRunning(false), javaVM(nullptr), globalCallback(nullptr),
          isPathCheckReported(false), isMapsCheckReported(false) {
}

MiscDetector::~MiscDetector() {
    stop();
}

void MiscDetector::detect(JNIEnv* env, jobject callback) {
    try {
        if (isRunning) {
            LOGD("Detection already running");
            return;
        }

        if (!env || !callback) {
            LOGE("Invalid parameters: env or callback is null");
            return;
        }

        // 获取JavaVM
        if (env->GetJavaVM(&javaVM) != JNI_OK) {
            LOGE("Failed to get JavaVM");
            return;
        }

        // 创建全局引用
        globalCallback = env->NewGlobalRef(callback);
        if (!globalCallback) {
            LOGE("Failed to create global reference");
            return;
        }

        // 创建检测线程
        isRunning = true;
        int result = pthread_create(&threadId, nullptr, threadFunction, this);
        if (result != 0) {
            LOGE("Failed to create thread: %s", strerror(result));
            cleanup();
            return;
        }
    } catch (const std::exception& e) {
        LOGE("Exception in detect: %s", e.what());
        cleanup();
    } catch (...) {
        LOGE("Unknown exception in detect");
        cleanup();
    }
}

void* MiscDetector::threadFunction(void* arg) {
    MiscDetector* detector = static_cast<MiscDetector*>(arg);

    prctl(PR_SET_NAME, "warlockmsc");

    JNIEnv* env = nullptr;
    JavaVMAttachArgs args;
    args.version = JNI_VERSION_1_6;
    args.name = "MiscDetector";
    args.group = nullptr;

    if (detector->javaVM->AttachCurrentThread(&env, &args) != JNI_OK || !env) {
        LOGE("Failed to attach thread to JVM");
        return nullptr;
    }

    // 主检测循环
    while (detector->isRunning) {
        try {
            // 只在未报告时执行检测
            if (!detector->isPathCheckReported) {
                detector->detectPathExistence(env);
            }
            if (!detector->isMapsCheckReported) {
                detector->detectTmpInMaps(env);
            }

            // 如果两个检测都已报告，可以考虑停止线程
            if (detector->isPathCheckReported && detector->isMapsCheckReported) {
                LOGD("All checks completed, stopping thread");
                break;
            }
        } catch (const std::exception& e) {
            LOGE("Exception in detection loop: %s", e.what());
        } catch (...) {
            LOGE("Unknown exception in detection loop");
        }
        usleep(3000 * 1000);  // 3秒延迟
    }

    detector->javaVM->DetachCurrentThread();
    return nullptr;
}

void MiscDetector::detectPathExistence(JNIEnv* env) {
    jobject contextObj = nullptr;
    jobject fileObj = nullptr;
    jstring pathStr = nullptr;
    const char* path = nullptr;

    try {
        // 获取Context
        jclass callbackClass = env->GetObjectClass(globalCallback);
        jmethodID getContextMethod = env->GetMethodID(callbackClass, "getContext", "()Landroid/content/Context;");
        contextObj = env->CallObjectMethod(globalCallback, getContextMethod);

        // 获取文件路径
        jclass contextClass = env->FindClass("android/content/Context");
        jmethodID getFilesDir = env->GetMethodID(contextClass, "getFilesDir", "()Ljava/io/File;");
        fileObj = env->CallObjectMethod(contextObj, getFilesDir);

        jclass fileClass = env->FindClass("java/io/File");
        jmethodID getAbsolutePath = env->GetMethodID(fileClass, "getAbsolutePath", "()Ljava/lang/String;");
        pathStr = (jstring)env->CallObjectMethod(fileObj, getAbsolutePath);

        path = env->GetStringUTFChars(pathStr, nullptr);

        // 使用SyscallUtils进行检测
#if defined(__aarch64__)
        const long SYSCALL_FACCESSAT = 48;  // ARM64
#elif defined(__arm__)
        const long SYSCALL_FACCESSAT = 334; // ARM
        #elif defined(__x86_64__)
        const long SYSCALL_FACCESSAT = 269; // x86_64
        #elif defined(__i386__)
        const long SYSCALL_FACCESSAT = 297; // x86
        #else
        #error "Unsupported architecture"
#endif

        int result = utils::SyscallUtils::syscall(SYSCALL_FACCESSAT, AT_FDCWD, (long)path, F_OK, 0);

        env->ReleaseStringUTFChars(pathStr, path);

        if (result < 0) {
            // 可能运行在虚拟机中
            std::string detail = "Application might be running in a virtual machine";
            DetectorUtils::reportWarning(env, globalCallback,
                                         "checkVirtual/sandbox_native",
                                         DetectorUtils::LEVEL_HIGH,
                                         detail);
        }

    } catch (const std::exception& e) {
        LOGE("Exception in detectPathExistence: %s", e.what());
    } catch (...) {
        LOGE("Unknown exception in detectPathExistence");
    }
}
void MiscDetector::detectTmpInMaps(JNIEnv* env) {
    try {
#if defined(__aarch64__)
        const long SYSCALL_OPENAT = 56;
        const long SYSCALL_READ = 63;
        const long SYSCALL_CLOSE = 57;
#elif defined(__arm__)
        const long SYSCALL_OPENAT = 322;
        const long SYSCALL_READ = 3;
        const long SYSCALL_CLOSE = 6;
        #elif defined(__x86_64__)
        const long SYSCALL_OPENAT = 257;
        const long SYSCALL_READ = 0;
        const long SYSCALL_CLOSE = 3;
        #elif defined(__i386__)
        const long SYSCALL_OPENAT = 295;
        const long SYSCALL_READ = 3;
        const long SYSCALL_CLOSE = 6;
#endif

        int fd = utils::SyscallUtils::syscall(SYSCALL_OPENAT, AT_FDCWD, (long)"/proc/self/maps", O_RDONLY);
        if (fd < 0) {
            LOGE("Failed to open maps: %s", strerror(errno));
            return;
        }

        char buffer[4096];
        std::string content;
        std::map<std::string, std::vector<std::string>> hookFeatures;

        // Hook框架特征
        const std::vector<std::pair<std::string, std::string>> signatures = {
                {"Frida", "frida"},
                {"Frida", "gadget"},
                {"Frida", "gum-js-loop"},
                {"Xposed", "XposedBridge"},
                {"Xposed", "xposed"},
                {"Substrate", "substrate"},
                {"Substrate", "cynject"},
                {"Other", "/data/local/tmp"},
                {"Other", "libriru"},      // Riru框架
                {"Other", "libsandhook"},  // SandHook框架
                {"Other", "epic"},         // Epic框架
                {"Other", "edxposed"},     // EdXposed框架
                {"Other", "taichi"},       // 太极框架
                {"LSPosed", "lspd"},       // LSPosed框架
                {"Dexposed", "dexposed"},  // DexPosed框架
                {"YAHFA", "libyahfa"},     // YAHFA框架
                {"Pine", "libpine"},       // Pine框架
                {"Dobby", "libdobby"},     // Dobby框架
                {"Shadow","libhookProxy"},
                {"Shadow","libshadow"}
        };

        // 读取文件内容
        while (true) {
            long bytes = utils::SyscallUtils::syscall(SYSCALL_READ, fd, (long)buffer, sizeof(buffer));
            if (bytes <= 0) break;

            content.append(buffer, bytes);

            size_t pos = 0;
            std::string remaining = content;
            while ((pos = remaining.find('\n')) != std::string::npos) {
                std::string line = remaining.substr(0, pos);
                remaining = remaining.substr(pos + 1);

                for (const auto& sig : signatures) {
                    // 使用多种方法检测特征
                    if (utils::StringUtils::containsSafe(line, sig.second)) {
                        hookFeatures[sig.first].push_back(line);
                    }
                }
            }
            content = remaining;
        }

        utils::SyscallUtils::syscall(SYSCALL_CLOSE, fd);

        // 报告发现的hook特征
        if (!hookFeatures.empty()) {
            std::string detail;

            for (const auto& feature : hookFeatures) {
                detail += "=== " + feature.first + " Framework ===\n";
                for (const auto& line : feature.second) {
                    detail += line + "\n";
                }
                detail += "\n";
            }

            DetectorUtils::reportWarning(env, globalCallback,
                                         "checkMaps_native",
                                         DetectorUtils::LEVEL_HIGH,
                                         detail);
            isMapsCheckReported = true;
        }

    } catch (const std::exception& e) {
        LOGE("Exception in detectTmpInMaps: %s", e.what());
    } catch (...) {
        LOGE("Unknown exception in detectTmpInMaps");
    }
}

void MiscDetector::cleanup() {
    isRunning = false;

    if (javaVM && globalCallback) {
        JNIEnv* env = nullptr;
        if (javaVM->AttachCurrentThread(&env, nullptr) == JNI_OK && env) {
            env->DeleteGlobalRef(globalCallback);
            javaVM->DetachCurrentThread();
        }
    }

    globalCallback = nullptr;
    javaVM = nullptr;
    resetDetectionState();
}

void MiscDetector::resetDetectionState() {
    isPathCheckReported = false;
    isMapsCheckReported = false;
}

void MiscDetector::stop() {
    if (!isRunning) {
        return;
    }

    try {
        isRunning = false;
        if (pthread_join(threadId, nullptr) != 0) {
            LOGE("Failed to join thread: %s", strerror(errno));
        }
        cleanup();
    } catch (const std::exception& e) {
        LOGE("Exception in stop: %s", e.what());
    } catch (...) {
        LOGE("Unknown exception in stop");
    }
}
```

`app/src/main/cpp/src/detector/NativeDetector.cpp`:

```cpp
#include "../../inc/detector/NativeDetector.h"

#include "../../inc/utils/LogUtils.h"

NativeDetector* NativeDetector::instance = nullptr;

NativeDetector::NativeDetector() : javaVM(nullptr), globalCallback(nullptr) {
    initDetectors();
}

NativeDetector::~NativeDetector() {
    cleanup();
}

void NativeDetector::initDetectors() {
    detectors.push_back(std::make_unique<VirtualDetector>());
    detectors.push_back(std::make_unique<FridaDetector>());
    detectors.push_back(std::make_unique<MiscDetector>());
    //detectors.push_back(std::make_unique<SystemDetector>());

    // 可以添加其他检测器
}

NativeDetector* NativeDetector::getInstance() {
    if (instance == nullptr) {
        instance = new NativeDetector();
    }
    return instance;
}

void NativeDetector::startDetect(JNIEnv* env, jobject callback) {
    if (javaVM != nullptr) {
        return;
    }

    env->GetJavaVM(&javaVM);
    globalCallback = env->NewGlobalRef(callback);

    detect();
}

JNIEnv* NativeDetector::getEnv() {
    if (!javaVM) {
        return nullptr;
    }

    JNIEnv* env = nullptr;
    int status = javaVM->GetEnv((void**)&env, JNI_VERSION_1_6);

    if (status == JNI_EDETACHED) {
        status = javaVM->AttachCurrentThread(&env, nullptr);
        if (status < 0) {
            return nullptr;
        }
    }

    return env;
}

void NativeDetector::detect() {
    JNIEnv* env = getEnv();
    if (!env) {
        LOGE("Failed to get JNIEnv");
        return;
    }

    try {
        for (const auto& detector : detectors) {
            detector->detect(env, globalCallback);
        }
    } catch (const std::exception& e) {
        LOGE("Error during detection: %s", e.what());
    }
}

void NativeDetector::cleanup() {
    if (javaVM && globalCallback) {
        JNIEnv* env = getEnv();
        if (env) {
            env->DeleteGlobalRef(globalCallback);
        }
    }

    javaVM = nullptr;
    globalCallback = nullptr;
    detectors.clear();
}
```

`app/src/main/cpp/src/detector/SandboxDetector.cpp`:

```cpp
#include "detector/SandboxDetector.h"

std::string SandboxDetector::getLibcPath() {
#if defined(__aarch64__)
    return "/system/lib64/libc.so";
#else
    return "/system/lib/libc.so";
#endif
}

void SandboxDetector::getNameByPid(pid_t pid, char* buff) {
    char path[64] = {0};
    snprintf(path, sizeof(path), "/proc/%d/cmdline", pid);
    FILE* fp = fopen(path, "r");
    if (fp) {
        fgets(buff, 200, fp);
        fclose(fp);
    }
}

void* SandboxDetector::replaceSecInsns(const char* libPath, const char* symbol) {
    void* handle = dlopen(libPath, RTLD_NOW);
    if (handle) {
        return dlsym(handle, symbol);
    }
    return nullptr;
}

void SandboxDetector::notifyDetection(JNIEnv* env, jobject thiz, const std::string& details) {
    // 获取类和方法
    jclass cls = env->GetObjectClass(thiz);
    jmethodID method = env->GetMethodID(cls, "onSandboxDetected", "(Ljava/lang/String;)V");

    if (method) {
        // 调用Java层回调
        jstring jDetails = env->NewStringUTF(details.c_str());
        env->CallVoidMethod(thiz, method, jDetails);
        env->DeleteLocalRef(jDetails);
    }
}

void SandboxDetector::checkSandbox(JNIEnv* env, jobject thiz) {
    LOGD("Enter checkSandbox");
    auto orig_opendir = reinterpret_cast<OpenDir>(
            replaceSecInsns(getLibcPath().c_str(), "opendir"));

    DIR *pdr = orig_opendir("/proc");
    if (pdr == nullptr) {
        LOGE("Failed to open /proc directory");
        return;
    }

    auto orig_readdir = reinterpret_cast<ReadDir>(
            replaceSecInsns(getLibcPath().c_str(), "readdir"));

    pid_t main_pid = getpid();
    dirent *read_ptr;
    std::string detailsStr;

    while ((read_ptr = orig_readdir(pdr)) != nullptr) {
        long proc_pid = strtol(read_ptr->d_name, nullptr, 10);

        if (proc_pid && proc_pid == main_pid) {
            char proc_name[200] = {0};
            getNameByPid(proc_pid, proc_name);

            if (strstr(proc_name, "com.xiaoc.warlock") != nullptr) {
                if (!detailsStr.empty()) {
                    detailsStr += "\n";
                }

                detailsStr += "Pid: " + std::to_string(proc_pid) +
                              "(pid name: " + proc_name + ")";

                LOGE("Found sandbox process: PID=%ld, Name=%s", proc_pid, proc_name);
            }
        }
    }

    closedir(pdr);

    if (!detailsStr.empty()) {
        notifyDetection(env, thiz, detailsStr);
    }
}
void SandboxDetector::checkProcessByPs(JNIEnv* env, jobject thiz) {
    const char* cmd;
    int api_level = android_get_device_api_level();

    // Android 10 (API 29) 及以上使用 ps -ef
    // Android 10 以下使用 ps
    if (api_level >= 29) {
        cmd = "ps -ef";
    } else {
        cmd = "ps";
    }

    auto orig_popen = reinterpret_cast<FILE *(*)(const char *, const char *)>(
            replaceSecInsns(getLibcPath().c_str(), "popen"));

    FILE *file = orig_popen(cmd, "r");
    if (file == nullptr) {
        LOGE("Failed to execute ps command");
        return;
    }

    char buf[0x1000];
    std::string detailsStr;
    int processCount = 0;
    bool isFirstLine = true;

    while (fgets(buf, sizeof(buf), file)) {
        // 跳过第一行（标题行）
        if (isFirstLine) {
            isFirstLine = false;
            continue;
        }
        // 检查是否包含我们的包名
        if (strstr(buf, "com.xiaoc.warlock") != nullptr) {
            processCount++;
            // 如果已经有内容，添加换行
            if (!detailsStr.empty()) {
                detailsStr += "\n";
            }
            // 移除行尾的换行符
            std::string line(buf);
            if (!line.empty() && line[line.length()-1] == '\n') {
                line.erase(line.length()-1);
            }
            detailsStr += line;
        }
    }

    pclose(file);

    // 如果找到多于一个进程（不包括ps命令本身）
    if (processCount > 0 && !detailsStr.empty()) {
        LOGE("Found multiple processes: \n%s", detailsStr.c_str());
        notifyDetection(env, thiz, detailsStr);
    }
}
```

`app/src/main/cpp/src/detector/SystemDetector.cpp`:

```cpp
#include "../../inc/detector/SystemDetector.h"

const std::string SystemDetector::CHECK_SYSTEM = "checkSystem_native";

void SystemDetector::detect(JNIEnv* env, jobject callback) {
    if (!env || !callback) {
        LOGE("Invalid JNI parameters");
        return;
    }

    try {
        std::vector<std::string> abnormalDetails;

        // 1. 检查 dm-verity 状态
        if (!checkDmVerity()) {
            abnormalDetails.push_back("Dm-Verity is diasble");
        }

        // 2. 检查系统分区状态
        if (!checkSystemPartition()) {
            abnormalDetails.push_back("SystemPart is write");
        }

        // 3. 检查 AVB 状态
        if (!checkAVB()) {
            abnormalDetails.push_back("AVB diasble");
        }

        // 如果发现任何异常
        if (!abnormalDetails.empty()) {
            std::string detail = "System Abnormal:\n";
            for (const auto& item : abnormalDetails) {
                detail += "- " + item + "\n";
            }
            DetectorUtils::reportWarning(
                    env,
                    callback,
                    CHECK_SYSTEM,
                    DetectorUtils::LEVEL_MEDIUM,
                    detail
            );
        }
    } catch (const std::exception& e) {
        LOGE("Error in system detection: %s", e.what());
    }
}

bool SystemDetector::checkDmVerity() {
    std::ifstream verityStatus("/sys/module/dm_verity/parameters/status");
    if (!verityStatus.is_open()) {
        return false;
    }
    std::string status;
    std::getline(verityStatus, status);
    return status.find("enabled") != std::string::npos;
}

bool SystemDetector::checkSystemPartition() {
    FILE* mounts = fopen("/proc/mounts", "r");
    if (!mounts) {
        return false;
    }

    bool isReadOnly = true;
    char line[512];
    while (fgets(line, sizeof(line), mounts)) {
        if (strstr(line, "/system") && !strstr(line, " ro,")) {
            isReadOnly = false;
            break;
        }
    }
    fclose(mounts);
    return isReadOnly;
}

bool SystemDetector::checkAVB() {
    return access("/sys/fs/avb/", F_OK) == 0;
}


```

`app/src/main/cpp/src/detector/VirtualDetector.cpp`:

```cpp
#include "../../inc/detector/VirtualDetector.h"
#include "../../inc/utils/SyscallUtils.h"
#include "../../inc/utils/MiscUtil.h"

const std::string VirtualDetector::CHECK_VIRTUAL = "checkVirtual_native";
const std::string VirtualDetector::CHECK_THERMAL = "checkThermal_native";
const std::string VirtualDetector::CHECK_PROCESS = "checkProcess_native";
const std::string VirtualDetector::CHECK_BRAND_SERVICES = "checkBrandServices_native";
void VirtualDetector::detect(JNIEnv* env, jobject callback) {
    detectArch(env, callback);
    detectThermal(env, callback);

    if (MiscUtil::SystemUtils::getSDKLevel() > __ANDROID_API_Q__) {
        detectProcess(env, callback);
    }
    detectBrandServices(env, callback);  // 添加新的检测

}

void VirtualDetector::install_check_arch_seccomp() {
    struct sock_filter filter[15] = {
            BPF_STMT(BPF_LD + BPF_W + BPF_ABS, (uint32_t) offsetof(struct seccomp_data, nr)),
            BPF_JUMP(BPF_JMP + BPF_JEQ, __NR_getpid, 0, 12),
            BPF_STMT(BPF_LD + BPF_W + BPF_ABS, (uint32_t) offsetof(struct seccomp_data, args[0])),
            BPF_JUMP(BPF_JMP + BPF_JEQ, DetectX86Flag, 0, 10),
            BPF_STMT(BPF_LD + BPF_W + BPF_ABS, (uint32_t) offsetof(struct seccomp_data, arch)),
            BPF_JUMP(BPF_JMP + BPF_JEQ, AUDIT_ARCH_X86_64, 0, 1),
            BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ERRNO | (864 & SECCOMP_RET_DATA)),
            BPF_JUMP(BPF_JMP + BPF_JEQ, AUDIT_ARCH_I386, 0, 1),
            BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ERRNO | (386 & SECCOMP_RET_DATA)),
            BPF_JUMP(BPF_JMP + BPF_JEQ, AUDIT_ARCH_ARM, 0, 1),
            BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ERRNO | (0xA32 & SECCOMP_RET_DATA)),
            BPF_JUMP(BPF_JMP + BPF_JEQ, AUDIT_ARCH_AARCH64, 0, 1),
            BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ERRNO | (0xA64 & SECCOMP_RET_DATA)),
            BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ERRNO | (6 & SECCOMP_RET_DATA)),
            BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW)
    };

    struct sock_fprog program = {
            .len = (unsigned short) (sizeof(filter) / sizeof(filter[0])),
            .filter = filter
    };

    errno = 0;
    if (utils::SyscallUtils::syscall(__NR_prctl, PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {
        LOGE("prctl(PR_SET_NO_NEW_PRIVS) failed: %s", strerror(errno));
        return;
    }

    errno = 0;
    if (utils::SyscallUtils::syscall(__NR_prctl, PR_SET_SECCOMP, SECCOMP_MODE_FILTER, (long)&program)) {
        LOGE("prctl(PR_SET_SECCOMP) failed: %s", strerror(errno));
        return;
    }
}

std::string VirtualDetector::check_arch_by_seccomp() {
    if (MiscUtil::SystemUtils::getSDKLevel() < __ANDROID_API_N_MR1__) {
        return "";
    }

    errno = 0;
    utils::SyscallUtils::syscall(__NR_getpid, DetectX86Flag);

    if (errno == 386) {
        return "I386设备";
    } else if (errno == 864) {
        return "X86_64设备";
    } else if (errno == 0xA32 || errno == 0xA64) {
        return "";  // ARM设备，正常
    } else if (errno == 0) {
        return "";  // 可能是没有开启seccomp
    }
    return std::to_string(errno);
}
void VirtualDetector::detectArch(JNIEnv* env, jobject callback) {
    if (!env || !callback) {
        LOGE("Invalid JNI parameters");
        return;
    }

    install_check_arch_seccomp();
    std::string result = check_arch_by_seccomp();

    if (!result.empty()) {
        DetectorUtils::reportWarning(env, callback,
                                     CHECK_VIRTUAL,
                                     DetectorUtils::LEVEL_HIGH,
                                    result);
    }
}
void VirtualDetector::detectProcess(JNIEnv* env, jobject callback) {
    if (!env || !callback) {
        LOGE("Invalid JNI parameters");
        return;
    }

    FILE* file = nullptr;
    try {
        file = popen("ps -ef", "r");
        if (!file) {
            throw std::runtime_error(std::string(strerror(errno)));
        }

        char buf[0x1000];
        std::string buffStr;
        uint32_t process_count = 0;

        while (fgets(buf, sizeof(buf), file)) {
            try {
                std::string line(buf);
                buffStr += line;

                if (!utils::StringUtils::contains(line, "xiaoc")) {
                    process_count++;
                    LOGI("ps -ef match: %s", line.c_str());
                }
            } catch (const std::exception& e) {
                LOGE("Error processing line: %s", e.what());
                continue;
            }
        }

        if (file) {
            pclose(file);
            file = nullptr;
        }

        if (process_count > MAX_NORMAL_PROCESS) {
            DetectorUtils::reportWarning(env, callback,
                                         CHECK_PROCESS,
                                         DetectorUtils::LEVEL_HIGH,
                                         buffStr);
        } else {
            LOGE("No sandbox detected in process check");
        }
    } catch (const std::exception& e) {
        if (file) {
            pclose(file);
        }
        throw; // 重新抛出异常，让上层处理
    }
}

void VirtualDetector::detectThermal(JNIEnv* env, jobject callback) {
    if (!env || !callback) {
        LOGE("Invalid JNI parameters");
        return;
    }

    try {
        int thermal_count = check_thermal_zones();

        if (thermal_count == -1) {
            LOGE("Cannot access thermal zones: %s", strerror(errno));
            return;
        }

        if (thermal_count < MIN_THERMAL_ZONES) {
            std::string detail = "thermal sensor size" + std::to_string(thermal_count);

            DetectorUtils::reportWarning(env, callback,
                                         CHECK_THERMAL,
                                         DetectorUtils::LEVEL_HIGH,
                                         detail);
        } else {
            LOGI("Thermal zones check passed: found %d sensors", thermal_count);
        }
    } catch (const std::exception& e) {
        LOGE("Error in thermal detection: %s", e.what());
        // 异常情况下不抛出，只记录日志
        return;
    }
}

int VirtualDetector::check_thermal_zones() {
    DIR* dir_ptr = nullptr;
    int count = 0;

    try {
        dir_ptr = opendir("/sys/class/thermal/");
        if (!dir_ptr) {
            return -1;
        }

        struct dirent* entry;
        while ((entry = readdir(dir_ptr))) {
            if (!entry->d_name ||
                !strcmp(entry->d_name, ".") ||
                !strcmp(entry->d_name, "..")) {
                continue;
            }
            if (strstr(entry->d_name, "thermal_zone") != nullptr) {
                count++;
            }
        }

        closedir(dir_ptr);
        return count;
    } catch (const std::exception& e) {
        if (dir_ptr) {
            closedir(dir_ptr);
        }
        throw;
    }
}
void VirtualDetector::detectBrandServices(JNIEnv* env, jobject callback) {
    if (!env || !callback) {
        LOGE("Invalid JNI parameters");
        return;
    }

    // 获取手机品牌
    char brand[PROP_VALUE_MAX];
    char model[PROP_VALUE_MAX];
    __system_property_get("ro.product.brand", brand);
    __system_property_get("ro.product.model", model);
    std::string brandStr(brand);
    std::string modelStr(model);
    std::transform(brandStr.begin(), brandStr.end(), brandStr.begin(), ::tolower);
    std::transform(modelStr.begin(), modelStr.end(), modelStr.begin(), ::tolower);
    std::string serviceList = getServiceList();

    // 检查是否为iPhone
    if (brandStr.find("apple") != std::string::npos ||
        brandStr.find("iphone") != std::string::npos ||
        modelStr.find("iphone") != std::string::npos) {

        std::string detail = "You iPhone ?\n"
                             "brand: " + std::string(brand) + "\n"
                                                             "model: " + std::string(model);

        DetectorUtils::reportWarning(env, callback,
                                     CHECK_BRAND_SERVICES,
                                     DetectorUtils::LEVEL_HIGH,
                                     detail);
        return;
    }
    // 检查服务
    std::string missingServices;
    bool isAbnormal = false;

    // 检查谷歌服务
    const char* googleServices[] = {
            "com.google.android.gms",
            "com.google.android.gsf",
            "com.google.android.apps.wellbeing",
            "com.google.android.googlequicksearchbox",
            "com.google.android.apps.nexuslauncher",
            "com.google.android.apps.pixelmigrate",
            "com.google.android.apps.restore",
            "com.google.android.apps.turbo",
            "com.google.android.apps.safetyhub",
            "com.google.android.dialer"
    };
    int googleServiceCount = 0;
    for (const auto& service : googleServices) {
        if (checkServiceExists(service)) {
            googleServiceCount++;
        }
    }

    if (googleServiceCount >= 5) {
        std::string detail = "Google Service (" + std::to_string(googleServiceCount)+"/10)";
        DetectorUtils::reportWarning(env, callback,
                                     CHECK_BRAND_SERVICES,
                                     DetectorUtils::LEVEL_HIGH,
                                     detail);
        return;
    }

    if (brandStr.find("redmi") != std::string::npos ||
        modelStr.find("redmi") != std::string::npos) {
        const char* services[] = {
                "miui.redmi",
                "redmi.fingerprint",
                "redmi.face.FaceService",
                "miui.security",
                "redmi.securitycenter",
                "MiuiSystemUI",
                "redmi.camera.service",
                "miui.powerkeeper",
                "miui.memory.service",
                "security",
                "MiuiBackup",
                "MiuiBluetooth",
                "MiuiInit",
                "miuibooster",
                "miuiboosterservice",
                "MiuiSystemUI",
                "miui.securitycenter",
                "miui.face.FaceService"
        };
        checkServices(services, sizeof(services)/sizeof(services[0]), missingServices, isAbnormal);
    }// 各品牌特有服务检测
    else if (brandStr.find("xiaomi") != std::string::npos) {
        const char* services[] = {
                "miui",
                "miui.memory.service",
                "security",
                "MiuiBackup",
                "MiuiBluetooth",
                "MiuiInit",
                "miuibooster",
                "miuiboosterservice",
                "MiuiSystemUI",
                "miui.securitycenter",
                "miui.face.FaceService"
        };
        checkServices(services, sizeof(services)/sizeof(services[0]), missingServices, isAbnormal);
    }
//    else if (brandStr.find("huawei") != std::string::npos) {
//        // 华为特有服务
//        const char* services[] = {
//                "hwsys",
//                "huawei.android.launcher",
//                "HwCamCfgSvr",
//                "hwfacemanager",
//                "hwfingerprint",
//                "HwSystemManager",
//                "hwNotification"
//        };
//        checkServices(services, sizeof(services)/sizeof(services[0]), missingServices, isAbnormal);
//    }
//    else if (brandStr.find("oppo") != std::string::npos) {
//        // OPPO特有服务
//        const char* services[] = {
//                "oppo.face.FaceService",
//                "OppoAlgoService",
//                "oppo.fingerprints.fingerprintservice",
//                "OppoSystemUI",
//                "oppo.biometrics.fingerprint.remote",
//                "OppoBiometricsService",
//                "OppoExService"
//        };
//        checkServices(services, sizeof(services)/sizeof(services[0]), missingServices, isAbnormal);
//    }
//    else if (brandStr.find("vivo") != std::string::npos) {
//        // vivo特有服务
//        const char* services[] = {
//                "VivoFrameworkService",
//                "VivoSystemUIService",
//                "vivo.fingerprint.FingerprintService",
//                "VivoPhoneService",
//                "VivoSecurityService",
//                "VivoPermissionService",
//                "VivoBackupService"
//        };
//        checkServices(services, sizeof(services)/sizeof(services[0]), missingServices, isAbnormal);
//    }
//    else if (brandStr.find("samsung") != std::string::npos) {
//        // 三星特有服务
//        const char* services[] = {
//                "samsung.seandroid",
//                "spengestureservice",
//                "securitymanager",
//                "samsung.knox",
//                "SamsungKeyguardService",
//                "samsung.fingerprint.service",
//                "SemBnRService"
//        };
//        checkServices(services, sizeof(services)/sizeof(services[0]), missingServices, isAbnormal);
//    }
//    else if (brandStr.find("oneplus") != std::string::npos) {
//        // 一加特有服务
//        const char* services[] = {
//                "oneplus.face.FaceService",
//                "oneplus.fingerprint.FingerprintService",
//                "OnePlusSystemUI",
//                "oneplus.biometrics",
//                "OnePlusGestureService",
//                "oneplus.camera",
//                "OnePlusCustomizeService"
//        };
//        checkServices(services, sizeof(services)/sizeof(services[0]), missingServices, isAbnormal);
//    }
//    else if (brandStr.find("meizu") != std::string::npos) {
//        // 魅族特有服务
//        const char* services[] = {
//                "flyme.face",
//                "meizu.security",
//                "FlymeSystemUI",
//                "meizu.customizecenter",
//                "meizu.fingerprint",
//                "MeizuBackupService",
//                "FlymePermissionService"
//        };
//        checkServices(services, sizeof(services)/sizeof(services[0]), missingServices, isAbnormal);
//    }

    if (isAbnormal) {
        std::string detail = "brand: " + std::string(brand) + "\n" +
                             "model: " + std::string(model) + "\n" +
                             "service list:\n" + serviceList;

        DetectorUtils::reportWarning(env, callback,
                                     CHECK_BRAND_SERVICES,
                                     DetectorUtils::LEVEL_HIGH,
                                     detail);
    }
}
void VirtualDetector::checkServices(const char* services[], size_t count,
                                    std::string& missingServices, bool& isAbnormal) {
    int foundCount = 0;
    static const int MIN_REQUIRED_SERVICES = 4;

    LOGD("Starting service check, need %d of %zu services", MIN_REQUIRED_SERVICES, count);

    for (size_t i = 0; i < count; i++) {
        if (checkServiceExists(services[i])) {
            foundCount++;
            LOGD("Found service[%d/%zu]: %s", foundCount, count, services[i]);
            if (foundCount >= MIN_REQUIRED_SERVICES) {
                LOGD("Found enough services (%d), marking as normal", foundCount);
                isAbnormal = false;
                return;
            }
        } else {
            LOGD("Missing service: %s", services[i]);
            missingServices += services[i];
            missingServices += "\n";
        }
    }

    LOGD("Found only %d/%zu services, marking as abnormal", foundCount, count);
    isAbnormal = true;
    missingServices = "找到特征服务: " + std::to_string(foundCount) +
                      "/" + std::to_string(count) + "\n" +
                      "缺失的服务:\n" + missingServices;
}
std::string VirtualDetector::getServiceList() {
    FILE* pipe = popen("service list", "r");
    if (!pipe) {
        LOGE("Failed to execute service list command: %s", strerror(errno));
        return "无法获取服务列表";
    }

    char buffer[128];
    std::string result;

    while (!feof(pipe)) {
        if (fgets(buffer, sizeof(buffer), pipe) != nullptr) {
            result += buffer;
        }
    }

    int status = pclose(pipe);
    if (status != 0) {
        LOGE("service list command failed with status: %d", status);
    }

    if (result.empty()) {
        LOGE("Got empty service list");
    } else {
        LOGD("Got service list with length: %zu", result.length());
    }

    return result;
}
bool VirtualDetector::checkServiceExists(const char* serviceName) {
    // 缓存原始服务列表和小写版本
    static std::string serviceList = getServiceList();
    static std::string lowerServiceList = serviceList;  // 缓存小写版本
    static bool initialized = false;

    // 第一次调用时转换为小写
    if (!initialized) {
        std::transform(lowerServiceList.begin(), lowerServiceList.end(),
                       lowerServiceList.begin(), ::tolower);
        initialized = true;
    }

    // 只需转换查询的服务名为小写
    std::string name(serviceName);
    std::transform(name.begin(), name.end(), name.begin(), ::tolower);

    return lowerServiceList.find(name) != std::string::npos;
}
```

`app/src/main/cpp/src/netlink/NetlinkConnection.cpp`:

```cpp
#include "NetlinkConnection.h"
#include "../inc/utils/LogUtils.h"

NetlinkConnection::NetlinkConnection() {
    fd_ = -1;
    // 内核保持数据包在8KiB以下(NLMSG_GOODSIZE)
    size_ = 8192;
    data_ = new char[size_];
}

NetlinkConnection::~NetlinkConnection() {
    if (fd_ != -1) close(fd_);
    delete[] data_;
}

bool NetlinkConnection::SendRequest(int type) {
    if (data_ == nullptr) return false;

    // 如果还没有打开netlink socket，则创建一个
    if (fd_ == -1) {
        fd_ = socket(PF_NETLINK, SOCK_RAW | SOCK_CLOEXEC, NETLINK_ROUTE);
        if (fd_ == -1) return false;
    }

    // 构造并发送消息
    struct NetlinkMessage {
        nlmsghdr hdr;
        rtgenmsg msg;
    } request;

    memset(&request, 0, sizeof(request));
    request.hdr.nlmsg_flags = NLM_F_DUMP | NLM_F_REQUEST;
    request.hdr.nlmsg_type = type;
    request.hdr.nlmsg_len = sizeof(request);
    request.msg.rtgen_family = AF_UNSPEC;  // 所有协议族

    return (TEMP_FAILURE_RETRY(send(fd_, &request, sizeof(request), 0)) == sizeof(request));
}

bool NetlinkConnection::ReadResponses(void callback(void*, nlmsghdr*), void* out) {
    // 读取所有响应，将感兴趣的传给回调函数
    ssize_t bytes_read;
    struct iovec iov{};
    iov.iov_base = data_;
    iov.iov_len = size_;

    struct sockaddr_nl nladdr{};
    struct msghdr msg = {
            .msg_name = &nladdr,
            .msg_namelen = sizeof(nladdr),
            .msg_iov = &iov,
            .msg_iovlen = 1,
    };

    while ((bytes_read = TEMP_FAILURE_RETRY(raw_syscall(__NR_recvmsg, fd_, &msg, 0))) > 0) {
        auto* hdr = reinterpret_cast<nlmsghdr*>(msg.msg_iov->iov_base);

        for (; NLMSG_OK(hdr, static_cast<size_t>(bytes_read));
               hdr = NLMSG_NEXT(hdr, bytes_read)) {

            if (hdr->nlmsg_type == NLMSG_DONE) return true;

            if (hdr->nlmsg_type == NLMSG_ERROR) {
                auto* err = reinterpret_cast<nlmsgerr*>(NLMSG_DATA(hdr));
                errno = (hdr->nlmsg_len >= NLMSG_LENGTH(sizeof(nlmsgerr)))
                        ? -err->error : EIO;
                return false;
            }

            callback(out, hdr);  // 处理每条消息
        }
    }
    return false;
}
```

`app/src/main/cpp/src/netlink/NetlinkConnection.h`:

```h
#ifndef WARLOCK_NETLINK_CONNECTION_H
#define WARLOCK_NETLINK_CONNECTION_H

#include <sys/types.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <cstring>
#include <linux/if.h>
#include <linux/if_packet.h>
#include <errno.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <unistd.h>
#include "syscall.h"

struct nlmsghdr;
extern "C" {
__attribute__((always_inline)) long raw_syscall(long number, ...);
}
class NetlinkConnection {
public:
    // 构造和析构函数
    NetlinkConnection();
    ~NetlinkConnection();

    // 发送netlink请求
    bool SendRequest(int type);

    // 读取响应并通过回调处理
    bool ReadResponses(void callback(void*, nlmsghdr*), void* context);

private:
    int fd_;      // netlink socket文件描述符
    char* data_;  // 数据缓冲区
    size_t size_; // 缓冲区大小
};

#endif // WARLOCK_NETLINK_CONNECTION_H
```

`app/src/main/cpp/src/netlink/bionic_netlink.cpp`:

```cpp
/*
 * Copyright (C) 2015 The Android Open Source Project
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "bionic_netlink.h"

#include <jni.h>
#include <dlfcn.h>
#include <android/log.h>
#include <malloc.h>
#include <stdbool.h>
#include <stdlib.h>
#include <stdio.h>
#include <regex>
#include <bits/getopt.h>
#include <asm/unistd.h>
#include <unistd.h>
#include <asm/fcntl.h>
#include<fcntl.h>
#include<sys/types.h>
#include<sys/stat.h>

#include <unistd.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>



extern "C" {
    __inline__ __attribute__((always_inline))  long raw_syscall(long __number, ...);
}

/**
 * form
 *
 * http://aospxref.com/android-10.0.0_r47/xref/bionic/libc/bionic/bionic_netlink.cpp
 *
 * @author zhenxi by 2022年1月18日14:07:54
 */
NetlinkConnection::NetlinkConnection() {
  fd_ = -1;

  // The kernel keeps packets under 8KiB (NLMSG_GOODSIZE),
  // but that's a bit too large to go on the stack.
  size_ = 8192;
  data_ = new char[size_];
}

NetlinkConnection::~NetlinkConnection() {
//  ErrnoRestorer errno_restorer;
  if (fd_ != -1) close(fd_);
  delete[] data_;
}

bool NetlinkConnection::SendRequest(int type) {
  // Rather than force all callers to check for the unlikely event of being
  // unable to allocate 8KiB, check here.
  // NetlinkConnection构造方法 的时候生成的8kb的data内存
  if (data_ == nullptr) return false;

  // Did we open a netlink socket yet?
  if (fd_ == -1) {
    //尝试建立socket netlink 链接
    fd_ = socket(PF_NETLINK, SOCK_RAW | SOCK_CLOEXEC, NETLINK_ROUTE);
    if (fd_ == -1) return false;
  }

  // Construct and send the message.
  struct NetlinkMessage {
    nlmsghdr hdr;
    rtgenmsg msg;
  } request;

  memset(&request, 0, sizeof(request));
  request.hdr.nlmsg_flags = NLM_F_DUMP | NLM_F_REQUEST;
  request.hdr.nlmsg_type = type;
  request.hdr.nlmsg_len = sizeof(request);
  // All families
  request.msg.rtgen_family = AF_UNSPEC;
  //使用socket数据发送
  return (TEMP_FAILURE_RETRY(send(fd_, &request, sizeof(request), 0)) == sizeof(request));
}
/*
 * 获取socket的返回结果
 */
bool NetlinkConnection::ReadResponses(void callback(void*, nlmsghdr*), void* out) {
  // Read through all the responses, handing interesting ones to the callback.
  ssize_t bytes_read;

  struct iovec iov{};
  iov.iov_base = data_;
  iov.iov_len = size_;

  struct sockaddr_nl nladdr{};
  struct msghdr msg = {
          .msg_name = &nladdr,
          .msg_namelen = sizeof(nladdr),
          .msg_iov = &iov,
          .msg_iovlen = 1,
  };



//while ((bytes_read = TEMP_FAILURE_RETRY(raw_syscall(__NR_recvfrom,fd_, data_, size_, 0, NULL,0))) > 0) {
//    auto* hdr = reinterpret_cast<nlmsghdr*>(data_);

while ((bytes_read = TEMP_FAILURE_RETRY(raw_syscall(__NR_recvmsg,fd_,&msg, 0))) > 0){
    auto* hdr = reinterpret_cast<nlmsghdr*>(msg.msg_iov->iov_base);

    for (; NLMSG_OK(hdr, static_cast<size_t>(bytes_read)); hdr = NLMSG_NEXT(hdr, bytes_read)) {
      //判断是否读取结束,否则读取callback
      if (hdr->nlmsg_type == NLMSG_DONE) return true;
      if (hdr->nlmsg_type == NLMSG_ERROR) {
        auto* err = reinterpret_cast<nlmsgerr*>(NLMSG_DATA(hdr));
        errno = (hdr->nlmsg_len >= NLMSG_LENGTH(sizeof(nlmsgerr))) ? -err->error : EIO;
        return false;
      }
      //处理具体逻辑
      callback(out, hdr);
    }
  }

  // We only get here if recv fails before we see a NLMSG_DONE.
  return false;
}
```

`app/src/main/cpp/src/netlink/bionic_netlink.h`:

```h
/*
 * Copyright (C) 2016 The Android Open Source Project
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#pragma once

#include <sys/types.h>

#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <cstring>
#include <linux/if.h>
#include <linux/if_packet.h>
#include "ifaddrs.h"
#include <errno.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <string.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <unistd.h>


struct nlmsghdr;


struct ifaddrs_storage {
    // Must come first, so that `ifaddrs_storage` is-a `ifaddrs`.
    ifaddrs ifa;

    // The interface index, so we can match RTM_NEWADDR messages with earlier RTM_NEWLINK messages (to copy the interface flags).
    int interface_index;

    // Storage for the pointers in `ifa`.
    sockaddr_storage addr;

    sockaddr_storage netmask;
    sockaddr_storage ifa_ifu;
    char name[IFNAMSIZ + 1];

    explicit ifaddrs_storage(ifaddrs **list) {
        memset(this, 0, sizeof(*this));

        // push_front onto `list`.
        ifa.ifa_next = *list;

        *list = reinterpret_cast<ifaddrs *>(this);
    }

    void SetAddress(int family, const void *data, size_t byteCount) {
        // The kernel currently uses the order IFA_ADDRESS, IFA_LOCAL, IFA_BROADCAST
        // in inet_fill_ifaddr, but let's not assume that will always be true...
        if (ifa.ifa_addr == nullptr) {
            //family 类型,v4还是v6这种
            //具体要赋值的数据

            //data = "000000000000";
            sockaddr *pSockaddr = CopyAddress(family, data, byteCount, &addr);

            ifa.ifa_addr = pSockaddr;

//            LOGE("赋值 ->  %x 原始-> %x  ",ifa.ifa_addr,pSockaddr);

        } else {
            // We already saw an IFA_LOCAL, which implies this is a destination address.
            ifa.ifa_dstaddr = CopyAddress(family, data, byteCount, &ifa_ifu);
            //ifa.ifa_ifu.ifu_dstaddr
        }
    }

    void SetBroadcastAddress(int family, const void *data, size_t byteCount) {
        // ifa_broadaddr and ifa_dstaddr overlap in a union. Unfortunately, it's possible
        // to have an interface with both. Keeping the last thing the kernel gives us seems
        // to be glibc 2.19's behavior too, so our choice is being source compatible with
        // badly-written code that assumes ifa_broadaddr and ifa_dstaddr are interchangeable
        // or supporting interfaces with both addresses configured. My assumption is that
        // bad code is more common than weird network interfaces...
        ifa.ifa_broadaddr = CopyAddress(family, data, byteCount, &ifa_ifu);
    }

    void SetLocalAddress(int family, const void *data, size_t byteCount) {
        // The kernel source says "for point-to-point IFA_ADDRESS is DESTINATION address,
        // local address is supplied in IFA_LOCAL attribute".
        //   -- http://lxr.free-electrons.com/source/include/uapi/linux/if_addr.h#L17

        // So copy any existing IFA_ADDRESS into ifa_dstaddr...
        if (ifa.ifa_addr != nullptr) {
            ifa.ifa_dstaddr = reinterpret_cast<sockaddr *>(memcpy(&ifa_ifu, &addr, sizeof(addr)));
        }
        // ...and then put this IFA_LOCAL into ifa_addr.
        ifa.ifa_addr = CopyAddress(family, data, byteCount, &addr);
    }

    // Netlink gives us the prefix length as a bit count. We need to turn
    // that into a BSD-compatible netmask represented by a sockaddr*.
    void SetNetmask(int family, size_t prefix_length) {
        // ...and work out the netmask from the prefix length.
        netmask.ss_family = family;
        uint8_t *dst = SockaddrBytes(family, &netmask);
        memset(dst, 0xff, prefix_length / 8);
        if ((prefix_length % 8) != 0) {
            dst[prefix_length / 8] = (0xff << (8 - (prefix_length % 8)));
        }
        ifa.ifa_netmask = reinterpret_cast<sockaddr *>(&netmask);
    }

    void SetPacketAttributes(int ifindex, unsigned short hatype, unsigned char halen) {
        sockaddr_ll *sll = reinterpret_cast<sockaddr_ll *>(&addr);
        sll->sll_ifindex = ifindex;
        sll->sll_hatype = hatype;
        sll->sll_halen = halen;
    }

private:
    sockaddr *CopyAddress(int family, const void *data, size_t byteCount, sockaddr_storage *ss) {
        // Netlink gives us the address family in the header, and the
        // sockaddr_in or sockaddr_in6 bytes as the payload. We need to
        // stitch the two bits together into the sockaddr that's part of
        // our portable interface.
        ss->ss_family = family;

        uint8_t *address = SockaddrBytes(family, ss);


//        LOGE ("赋值之前 data 16进制打印    %02X  %02X  %02X  %02X  %02X  %02X  %02X ",
//              data,(data+1),sockadd->sll_addr[2],
//                sockadd->sll_addr[3],sockadd->sll_addr[4],sockadd->sll_addr[5]);



        memcpy(address, data, byteCount);


//        char macp[INET6_ADDRSTRLEN];
//        appUtils::getpData(macp, data, 6);
//        LOGE("拷贝之后data的内容     %s   ", macp);





        //LOGE("拷贝地址内容    %x  %x  数据大小  %d ",address,data,byteCount);

//        LOGE ("0000000000000 最终数据内容16进制   %02X  %02X  %02X  %02X  %02X  %02X  %02X ",
//              sockadd->sll_addr[0],sockadd->sll_addr[1],sockadd->sll_addr[2],
//              sockadd->sll_addr[3],sockadd->sll_addr[4],sockadd->sll_addr[5]);

        // For IPv6 we might also have to set the scope id.
        if (family == AF_INET6 && (IN6_IS_ADDR_LINKLOCAL(data) || IN6_IS_ADDR_MC_LINKLOCAL(data))) {
            reinterpret_cast<sockaddr_in6 *>(ss)->sin6_scope_id = interface_index;
        }

        return reinterpret_cast<sockaddr *>(ss);
    }

    // Returns a pointer to the first byte in the address data (which is stored in network byte order).
    //
    uint8_t *SockaddrBytes(int family, sockaddr_storage *ss) {
        if (family == AF_INET) {
            sockaddr_in *ss4 = reinterpret_cast<sockaddr_in *>(ss);
            return reinterpret_cast<uint8_t *>(&ss4->sin_addr);
        } else if (family == AF_INET6) {
            sockaddr_in6 *ss6 = reinterpret_cast<sockaddr_in6 *>(ss);
            return reinterpret_cast<uint8_t *>(&ss6->sin6_addr);
        } else if (family == AF_PACKET) {
            sockaddr_ll *sll = reinterpret_cast<sockaddr_ll *>(ss);
            return reinterpret_cast<uint8_t *>(&sll->sll_addr);
        }
        return nullptr;
    }
};

class NetlinkConnection {
public:
    NetlinkConnection();

    ~NetlinkConnection();

    bool SendRequest(int type);

    bool ReadResponses(void callback(void *, nlmsghdr *), void *context);

    bool MyReadResponses(void *context);

private:
    int fd_;
    char *data_;
    size_t size_;
};

```

`app/src/main/cpp/src/netlink/ifaddrs.cpp`:

```cpp
/*
 * Copyright (C) 2015 The Android Open Source Project
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "ifaddrs.h"

#include <errno.h>
#include <linux/if_packet.h>
#include <net/if.h>
#include <netinet/in.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

//#include "private/ErrnoRestorer.h"

#include "bionic_netlink.h"

// The public ifaddrs struct is full of pointers. Rather than track several
// different allocations, we use a maximally-sized structure with the public
// part at offset 0, and pointers into its hidden tail.

static void __getifaddrs_callback(void* context, nlmsghdr* hdr) {
  ifaddrs** out = reinterpret_cast<ifaddrs**>(context);

  //首先先判断消息类型是不是RTM_NEWLINK类型
  if (hdr->nlmsg_type == RTM_NEWLINK) {
      //LOGE ("开始执行正常 发现消息是 11111111");

    ifinfomsg* ifi = reinterpret_cast<ifinfomsg*>(NLMSG_DATA(hdr));

    // Create a new ifaddr entry, and set the interface index and flags.
    // 创建一份新的进行拷贝和赋值
    // 将两个**的封装成 ifaddrs_storage
    ifaddrs_storage* new_addr = new ifaddrs_storage(out);

    new_addr->interface_index = ifi->ifi_index;
    new_addr->ifa.ifa_flags = ifi->ifi_flags;

    // Go through the various bits of information and find the name.
    rtattr* rta = IFLA_RTA(ifi);
    //获取这个消息的长度
    size_t rta_len = IFLA_PAYLOAD(hdr);
    //这块是判断这个消息是否是合格的消息
    while (RTA_OK(rta, rta_len)) {
      if (rta->rta_type == IFLA_ADDRESS) {
          if (RTA_PAYLOAD(rta) < sizeof(new_addr->addr)) {
            new_addr->SetAddress(AF_PACKET, RTA_DATA(rta), RTA_PAYLOAD(rta));
            new_addr->SetPacketAttributes(ifi->ifi_index, ifi->ifi_type, RTA_PAYLOAD(rta));
          }
      } else if (rta->rta_type == IFLA_BROADCAST) {

          if (RTA_PAYLOAD(rta) < sizeof(new_addr->ifa_ifu)) {
            new_addr->SetBroadcastAddress(AF_PACKET, RTA_DATA(rta), RTA_PAYLOAD(rta));
            new_addr->SetPacketAttributes(ifi->ifi_index, ifi->ifi_type, RTA_PAYLOAD(rta));
          }
      } else if (rta->rta_type == IFLA_IFNAME) {

          if (RTA_PAYLOAD(rta) < sizeof(new_addr->name)) {
            memcpy(new_addr->name, RTA_DATA(rta), RTA_PAYLOAD(rta));
            new_addr->ifa.ifa_name = new_addr->name;
          }
      }
      rta = RTA_NEXT(rta, rta_len);
    }


  } else if (hdr->nlmsg_type == RTM_NEWADDR) {

      //消息封装
    ifaddrmsg* msg = reinterpret_cast<ifaddrmsg*>(NLMSG_DATA(hdr));

    // We should already know about this from an RTM_NEWLINK message.
    const ifaddrs_storage* addr = reinterpret_cast<const ifaddrs_storage*>(*out);

    while (addr != nullptr && addr->interface_index != static_cast<int>(msg->ifa_index)) {
      addr = reinterpret_cast<const ifaddrs_storage*>(addr->ifa.ifa_next);
    }
    // If this is an unknown interface, ignore whatever we're being told about it.
    if (addr == nullptr) return;

    // Create a new ifaddr entry and copy what we already know.
    ifaddrs_storage* new_addr = new ifaddrs_storage(out);

    // We can just copy the name rather than look for IFA_LABEL.
    strcpy(new_addr->name, addr->name);

    new_addr->ifa.ifa_name = new_addr->name;

    new_addr->ifa.ifa_flags = addr->ifa.ifa_flags;
    new_addr->interface_index = addr->interface_index;

    // Go through the various bits of information and find the address
    // and any broadcast/destination address.
    rtattr* rta = IFA_RTA(msg);
    size_t rta_len = IFA_PAYLOAD(hdr);


    while (RTA_OK(rta, rta_len)) {

      if (rta->rta_type == IFA_ADDRESS) {
        if (msg->ifa_family == AF_INET || msg->ifa_family == AF_INET6) {
          new_addr->SetAddress(msg->ifa_family,RTA_DATA(rta) , RTA_PAYLOAD(rta));
          new_addr->SetNetmask(msg->ifa_family, msg->ifa_prefixlen);
        }
      } else if (rta->rta_type == IFA_BROADCAST) {
          if (msg->ifa_family == AF_INET) {
          new_addr->SetBroadcastAddress(msg->ifa_family, RTA_DATA(rta), RTA_PAYLOAD(rta));
        }
      } else if (rta->rta_type == IFA_LOCAL) {
          if (msg->ifa_family == AF_INET || msg->ifa_family == AF_INET6) {
          new_addr->SetLocalAddress(msg->ifa_family, RTA_DATA(rta), RTA_PAYLOAD(rta));
        }
      }
      rta = RTA_NEXT(rta, rta_len);
    }
  }
}
void freeifaddrs(ifaddrs* list) {
  while (list != nullptr) {
    ifaddrs* current = list;
    list = list->ifa_next;
    free(current);
  }
}
int myGetifaddrs(ifaddrs** out) {
  // We construct the result directly into `out`, so terminate the list.
  *out = nullptr;

  // Open the netlink socket and ask for all the links and addresses.
  NetlinkConnection nc;
  bool okay = nc.SendRequest(RTM_GETLINK) && nc.ReadResponses(__getifaddrs_callback, out) &&
          nc.SendRequest(RTM_GETADDR) && nc.ReadResponses(__getifaddrs_callback, out);

  if (!okay) {
    //out = nullptr;
    ifaddrs *pIfaddrs = *out;
    if(pIfaddrs!= nullptr){
      freeifaddrs(pIfaddrs);
    }
    // Ensure that callers crash if they forget to check for success.
    *out = nullptr;
    return -1;
  }

  return 0;
}



```

`app/src/main/cpp/src/netlink/ifaddrs.h`:

```h
/*
 * Copyright (C) 2015 The Android Open Source Project
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#pragma once

/**
 * @file ifaddrs.h
 * @brief Access to network interface addresses.
 */

#include <sys/cdefs.h>
#include <netinet/in.h>
#include <sys/socket.h>

__BEGIN_DECLS

/**
 * Returned by getifaddrs() and freed by freeifaddrs().
 */
struct ifaddrs {
  /** Pointer to the next element in the linked list. */
  struct ifaddrs* ifa_next;

  /** Interface name. */
  char* ifa_name;
  /** Interface flags (like `SIOCGIFFLAGS`). */
  unsigned int ifa_flags;

  /** Interface address. */
  struct sockaddr* ifa_addr;



  /** Interface netmask. */
  struct sockaddr* ifa_netmask;

  union {
    /** Interface broadcast address (if IFF_BROADCAST is set). */
    struct sockaddr* ifu_broadaddr;
    /** Interface destination address (if IFF_POINTOPOINT is set). */
    struct sockaddr* ifu_dstaddr;
  } ifa_ifu;

  /** Unused. */
  void* ifa_data;
};

/** Synonym for `ifa_ifu.ifu_broadaddr` in `struct ifaddrs`. */
#define ifa_broadaddr ifa_ifu.ifu_broadaddr
/** Synonym for `ifa_ifu.ifu_dstaddr` in `struct ifaddrs`. */
#define ifa_dstaddr ifa_ifu.ifu_dstaddr

/**
 * [getifaddrs(3)](http://man7.org/linux/man-pages/man3/getifaddrs.3.html) creates a linked list
 * of `struct ifaddrs`. The list must be freed by freeifaddrs().
 *
 * Returns 0 and stores the list in `*__list_ptr` on success,
 * and returns -1 and sets `errno` on failure.
 *
 * Available since API level 24.
 */
int myGetifaddrs(struct ifaddrs** __list_ptr) __INTRODUCED_IN(24);

/**
 * [freeifaddrs(3)](http://man7.org/linux/man-pages/man3/freeifaddrs.3.html) frees a linked list
 * of `struct ifaddrs` returned by getifaddrs().
 *
 * Available since API level 24.
 */
void freeifaddrs(struct ifaddrs* __ptr) __INTRODUCED_IN(24);

__END_DECLS

```

`app/src/main/cpp/src/netlink/syscall32.s`:

```s
    .text
    .global raw_syscall
    .type raw_syscall,%function

raw_syscall:
        MOV             R12, SP
        STMFD           SP!, {R4-R7}
        MOV             R7, R0
        MOV             R0, R1
        MOV             R1, R2
        MOV             R2, R3
        LDMIA           R12, {R3-R6}
        SVC             0
        LDMFD           SP!, {R4-R7}
        mov             pc, lr

```

`app/src/main/cpp/src/netlink/syscall64.s`:

```s
    .text
    .global raw_syscall
    .type raw_syscall,@function

raw_syscall:
        MOV             X8, X0
        MOV             X0, X1
        MOV             X1, X2
        MOV             X2, X3
        MOV             X3, X4
        MOV             X4, X5
        MOV             X5, X6
        SVC             0
        RET

```

`app/src/main/cpp/src/netlink/syscall_x86.s`:

```s
.text
.global raw_syscall
.type raw_syscall,@function

raw_syscall:
    push    %ebp
    mov     %esp, %ebp
    push    %ebx          # 保存ebx
    push    %esi
    push    %edi

    mov     8(%ebp), %eax  # 系统调用号
    mov     12(%ebp), %ebx # 第一个参数
    mov     16(%ebp), %ecx # 第二个参数
    mov     20(%ebp), %edx # 第三个参数
    mov     24(%ebp), %esi # 第四个参数
    mov     28(%ebp), %edi # 第五个参数

    int     $0x80         # 执行系统调用

    pop     %edi
    pop     %esi
    pop     %ebx
    mov     %ebp, %esp
    pop     %ebp
    ret
```

`app/src/main/cpp/src/netlink/syscall_x86_64.s`:

```s
.text
.global raw_syscall
.type raw_syscall,@function

raw_syscall:
    mov     %rdi, %rax    # 系统调用号移到rax
    mov     %rsi, %rdi    # 第一个参数
    mov     %rdx, %rsi    # 第二个参数
    mov     %rcx, %rdx    # 第三个参数
    mov     %r8,  %r10    # 第四个参数
    mov     %r9,  %r8     # 第五个参数
    mov     8(%rsp), %r9  # 第六个参数
    syscall              # 执行系统调用
    ret
```

`app/src/main/cpp/src/network/NetworkManager.cpp`:

```cpp
#include "network/NetworkManager.h"
#include <android/log.h>

#define TAG "NetworkManager"
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, TAG, __VA_ARGS__)

NetworkManager* NetworkManager::instance = nullptr;

NetworkManager* NetworkManager::getInstance() {
    if (instance == nullptr) {
        instance = new NetworkManager();
    }
    return instance;
}

bool NetworkManager::sendData(const std::string& encryptedData) {
    // TODO: 实现实际的网络请求逻辑
    LOGI("Ready to send encrypted data: %s", encryptedData.c_str());
    return true;
} 
```

`app/src/main/cpp/src/utils/Base64Utils.cpp`:

```cpp
#include "../inc/utils/Base64Utils.h"

static const std::string base64_chars = 
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    "abcdefghijklmnopqrstuvwxyz"
    "0123456789+/";

std::string Base64Utils::Encode(const uint8_t* input, size_t length) {
    std::string ret;
    int i = 0;
    int j = 0;
    uint8_t char_array_3[3];
    uint8_t char_array_4[4];

    while (length--) {
        char_array_3[i++] = *(input++);
        if (i == 3) {
            char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
            char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
            char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
            char_array_4[3] = char_array_3[2] & 0x3f;

            for(i = 0; i < 4; i++)
                ret += base64_chars[char_array_4[i]];
            i = 0;
        }
    }

    if (i) {
        for(j = i; j < 3; j++)
            char_array_3[j] = '\0';

        char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
        char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
        char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);

        for (j = 0; j < i + 1; j++)
            ret += base64_chars[char_array_4[j]];

        while(i++ < 3)
            ret += '=';
    }

    return ret;
}
```

`app/src/main/cpp/src/utils/CommandUtils.cpp`:

```cpp
#include "../inc/utils/CommandUtils.h"
#include "../inc/utils/LogUtils.h"
#include <stdarg.h>
#include <sys/wait.h>
#include "../inc/utils/SyscallUtils.h"

namespace utils {

    long CommandUtils::syscall(long number, ...) {
        va_list args;
        va_start(args, number);
        long arg1 = va_arg(args, long);
        long arg2 = va_arg(args, long);
        long arg3 = va_arg(args, long);
        va_end(args);
        
        long result = SyscallUtils::syscall(number, arg1, arg2, arg3);
        return result;
    }

    std::string CommandUtils::execCommand(const char* cmd) {
        std::string result;
        FILE* pipe = popen(cmd, "r");
        if (!pipe) {
            LOGE("Failed to execute command: %s", cmd);
            return result;
        }

        char buffer[128];
        while (fgets(buffer, sizeof(buffer), pipe) != nullptr) {
            result += buffer;
        }

        pclose(pipe);
        return result;
    }
}
```

`app/src/main/cpp/src/utils/DetectorUtils.cpp`:

```cpp
#include "../inc/utils/DetectorUtils.h"
#include "../inc/utils/LogUtils.h"

void DetectorUtils::reportWarning(JNIEnv* env, jobject callback,
                                  const std::string& type,
                                  const std::string& level,
                                  const std::string& detail) {
    if (!callback) {
        LOGE("Callback is null");
        return;
    }

    jclass callbackClass = env->GetObjectClass(callback);
    jmethodID reportMethod = env->GetMethodID(callbackClass, "onDetectWarning",
                                              "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V");

    if (reportMethod) {
        jstring jType = env->NewStringUTF(type.c_str());
        jstring jLevel = env->NewStringUTF(level.c_str());
        jstring jDetail = env->NewStringUTF(detail.c_str());

        env->CallVoidMethod(callback, reportMethod, jType, jLevel, jDetail);

        env->DeleteLocalRef(jType);
        env->DeleteLocalRef(jLevel);
        env->DeleteLocalRef(jDetail);
        env->DeleteLocalRef(callbackClass);
    }
}
```

`app/src/main/cpp/src/utils/FileUtils.cpp`:

```cpp

#include "../inc/utils/FileUtils.h"
#include "../inc/utils/LogUtils.h"
#include <stdarg.h>
#include <errno.h>
#include "../inc/utils/SyscallUtils.h"
namespace utils {

    long FileUtils::syscall(long number, ...) {
        va_list args;
        va_start(args, number);
        long arg1 = va_arg(args, long);
        long arg2 = va_arg(args, long);
        long arg3 = va_arg(args, long);
        va_end(args);
        
        long result = SyscallUtils::syscall(number, arg1, arg2, arg3);
        return result;
    }

    int FileUtils::openFile(const char* path, int flags) {
        return (int)syscall(__NR_openat, AT_FDCWD, (long)path, flags);
    }

    ssize_t FileUtils::readFile(int fd, void* buf, size_t count) {
        return syscall(__NR_read, fd, (long)buf, count);
    }

    int FileUtils::closeFile(int fd) {
        return (int)syscall(__NR_close, fd, 0, 0);
    }

    std::string FileUtils::readFileAsString(const char* path) {
        std::string content;
        int fd = openFile(path, O_RDONLY);
        if (fd < 0) {
            LOGE("Failed to open file: %s, errno: %d", path, errno);
            return content;
        }

        char buffer[4096];
        ssize_t bytesRead;
        while ((bytesRead = readFile(fd, buffer, sizeof(buffer))) > 0) {
            content.append(buffer, bytesRead);
        }

        closeFile(fd);
        return content;
    }
}
```

`app/src/main/cpp/src/utils/MiscUtil.cpp`:

```cpp
#include "../../inc/utils/MiscUtil.h"
#include "../../inc/utils/LogUtils.h"

namespace MiscUtil {

    int SystemUtils::sdkLevel = 0;
    bool SystemUtils::isInitialized = false;

    void SystemUtils::init(JNIEnv* env) {
        if (isInitialized) {
            return;
        }

        jclass versionClass = env->FindClass("android/os/Build$VERSION");
        if (versionClass != nullptr) {
            jfieldID sdkIntFieldID = env->GetStaticFieldID(versionClass, "SDK_INT", "I");
            if (sdkIntFieldID != nullptr) {
                sdkLevel = env->GetStaticIntField(versionClass, sdkIntFieldID);
                isInitialized = true;
            }
        }

        if (!isInitialized) {
            LOGE("Failed to get SDK level");
            sdkLevel = 0;
        }
    }

    int SystemUtils::getSDKLevel() {
        return sdkLevel;
    }
}
```

`app/src/main/cpp/src/utils/StringUtils.cpp`:

```cpp
// utils/StringUtils.cpp
#include "../inc/utils/StringUtils.h"
#include <algorithm>

namespace utils {

    bool StringUtils::isEmpty(const std::string& str) {
        return str.empty() || str.find_first_not_of(" \t\n\r") == std::string::npos;
    }

    std::string StringUtils::trim(const std::string& str) {
        if (str.empty()) {
            return str;
        }

        size_t first = str.find_first_not_of(" \t\n\r");
        if (first == std::string::npos) {
            return "";
        }

        size_t last = str.find_last_not_of(" \t\n\r");
        return str.substr(first, (last - first + 1));
    }

    std::vector<std::string> StringUtils::split(const std::string& str, const std::string& delim) {
        std::vector<std::string> tokens;
        size_t prev = 0, pos = 0;
        do {
            pos = str.find(delim, prev);
            if (pos == std::string::npos) pos = str.length();
            std::string token = str.substr(prev, pos - prev);
            if (!token.empty()) tokens.push_back(token);
            prev = pos + delim.length();
        } while (pos < str.length() && prev < str.length());
        return tokens;
    }

    std::string StringUtils::join(const std::vector<std::string>& vec, const std::string& delim) {
        std::string result;
        for (size_t i = 0; i < vec.size(); ++i) {
            if (i > 0) result += delim;
            result += vec[i];
        }
        return result;
    }
    bool StringUtils::contains(const std::string& str, const std::string& substr) {
        return str.find(substr) != std::string::npos;
    }
    bool StringUtils::containsManual(const char* str, const char* pattern) {
        if (!str || !pattern) return false;

        const char* s = str;
        while (*s) {
            const char* p = pattern;
            const char* current = s;

            while (*p && *current && *p == *current) {
                p++;
                current++;
            }

            if (!*p) return true;
            s++;
        }
        return false;
    }

    bool StringUtils::containsBM(const char* text, const char* pattern) {
        if (!text || !pattern) return false;

        int textLen = strlen(text);
        int patternLen = strlen(pattern);

        if (patternLen == 0) return false;

        int skip[256] = {0};
        for (int i = 0; i < 256; i++) {
            skip[i] = patternLen;
        }
        for (int i = 0; i < patternLen - 1; i++) {
            skip[static_cast<unsigned char>(pattern[i])] = patternLen - 1 - i;
        }

        int i = patternLen - 1;
        while (i < textLen) {
            int j = patternLen - 1;
            int k = i;

            while (j >= 0 && text[k] == pattern[j]) {
                j--;
                k--;
            }

            if (j < 0) return true;

            i += skip[static_cast<unsigned char>(text[i])];
        }
        return false;
    }

    bool StringUtils::containsBytes(const char* str, const char* pattern) {
        if (!str || !pattern) return false;

        size_t patternLen = strlen(pattern);
        size_t strLen = strlen(str);

        if (patternLen > strLen) return false;

        for (size_t i = 0; i <= strLen - patternLen; i++) {
            bool found = true;
            for (size_t j = 0; j < patternLen; j++) {
                if (str[i + j] != pattern[j]) {
                    found = false;
                    break;
                }
            }
            if (found) return true;
        }
        return false;
    }

    bool StringUtils::containsSafe(const std::string& text, const std::string& pattern) {
        if (pattern.empty() || text.empty()) return false;

        const char* textCStr = text.c_str();
        const char* patternCStr = pattern.c_str();

        // 使用多种方法检测
        bool result1 = contains(text, pattern);           // 标准方法
        bool result2 = containsManual(textCStr, patternCStr);    // 手动查找
        bool result3 = containsBM(textCStr, patternCStr);        // Boyer-Moore
        bool result4 = containsBytes(textCStr, patternCStr);     // 字节比较

        // 至少两种方法检测到才认为是真实存在
        int count = result1 + result2 + result3 + result4;
        return count >= 2;
    }
}
```

`app/src/main/cpp/src/utils/SyscallUtils.cpp`:

```cpp

#include "../inc/utils/SyscallUtils.h"
#include "../inc/utils/LogUtils.h"
#include <stdarg.h>

namespace utils {

    #if defined(__aarch64__)
    long SyscallUtils::syscall_aarch64(long number, long arg1, long arg2, long arg3) {
        long result;
        __asm__ volatile(
            "mov x8, %1\n"    // 系统调用号
            "mov x0, %2\n"    // 第一个参数
            "mov x1, %3\n"    // 第二个参数
            "mov x2, %4\n"    // 第三个参数
            "svc #0\n"        // 触发系统调用
            "mov %0, x0"      // 获取返回值
            : "=r"(result)
            : "r"(number), "r"(arg1), "r"(arg2), "r"(arg3)
            : "x0", "x1", "x2", "x8"
        );
        return result;
    }
    #elif defined(__arm__)
    long SyscallUtils::syscall_arm(long number, long arg1, long arg2, long arg3) {
        long result;
        __asm__ volatile(
            "mov r7, %1\n"    // 系统调用号
            "mov r0, %2\n"    // 第一个参数
            "mov r1, %3\n"    // 第二个参数
            "mov r2, %4\n"    // 第三个参数
            "swi #0\n"        // 触发系统调用
            "mov %0, r0"      // 获取返回值
            : "=r"(result)
            : "r"(number), "r"(arg1), "r"(arg2), "r"(arg3)
            : "r0", "r1", "r2", "r7"
        );
        return result;
    }
    #elif defined(__x86_64__)
    long SyscallUtils::syscall_x86_64(long number, long arg1, long arg2, long arg3) {
        long result;
        __asm__ volatile(
            "mov %1, %%rax\n"    // 系统调用号
            "mov %2, %%rdi\n"    // 第一个参数
            "mov %3, %%rsi\n"    // 第二个参数
            "mov %4, %%rdx\n"    // 第三个参数
            "syscall\n"          // 触发系统调用
            "mov %%rax, %0"      // 获取返回值
            : "=r"(result)
            : "r"(number), "r"(arg1), "r"(arg2), "r"(arg3)
            : "rax", "rdi", "rsi", "rdx"
        );
        return result;
    }
    #elif defined(__i386__)
    long SyscallUtils::syscall_x86(long number, long arg1, long arg2, long arg3) {
        long result;
        __asm__ volatile(
                "pushl %%ebx\n"      // 保存ebx的值，因为它是PIC寄存器
                "movl %2, %%ebx\n"   // 加载第一个参数到ebx
                "movl %1, %%eax\n"   // 系统调用号到eax
                "movl %3, %%ecx\n"   // 第二个参数到ecx
                "movl %4, %%edx\n"   // 第三个参数到edx
                "int $0x80\n"        // 触发系统调用
                "popl %%ebx\n"       // 恢复ebx的值
                : "=a"(result)       // 输出：eax到result
                : "g"(number),       // 输入：系统调用号
        "r"(arg1),         // 输入：第一个参数
        "r"(arg2),         // 输入：第二个参数
        "r"(arg3)          // 输入：第三个参数
                : "ecx", "edx"       // 告诉编译器这些寄存器会被修改
                );
        return result;
    }
    #endif

    long SyscallUtils::syscall(long number, ...) {
        va_list args;
        va_start(args, number);
        long arg1 = va_arg(args, long);
        long arg2 = va_arg(args, long);
        long arg3 = va_arg(args, long);
        va_end(args);

        #if defined(__aarch64__)
        return syscall_aarch64(number, arg1, arg2, arg3);
        #elif defined(__arm__)
        return syscall_arm(number, arg1, arg2, arg3);
        #elif defined(__x86_64__)
        return syscall_x86_64(number, arg1, arg2, arg3);
        #elif defined(__i386__)
        return syscall_x86(number, arg1, arg2, arg3);
        #else
        LOGE("Unsupported architecture");
        return -1;
        #endif
    }
}
```

`app/src/main/cpp/src/utils/XsonCollector.cpp`:

```cpp
// src/utils/XsonCollector.cpp
#include "../inc/utils/XsonCollector.h"
#include "../inc/utils/LogUtils.h"


XsonCollector* XsonCollector::instance = nullptr;

XsonCollector::XsonCollector() {
    doc.SetObject();
}

XsonCollector::~XsonCollector() = default;

XsonCollector* XsonCollector::getInstance() {
    if (instance == nullptr) {
        instance = new XsonCollector();
    }
    return instance;
}

void XsonCollector::put(const std::string& key, const std::string& value) {
    try {
        rapidjson::Document::AllocatorType& allocator = doc.GetAllocator();
        rapidjson::Value item(rapidjson::kObjectType);

        item.AddMember("s", 0, allocator);  // 成功状态
        item.AddMember(
                "v",
                rapidjson::Value(value.c_str(), allocator).Move(),
                allocator
        );

        doc.AddMember(
                rapidjson::Value(key.c_str(), allocator).Move(),
                item,
                allocator
        );
    } catch (const std::exception& e) {
        putFailed(key);
    }
}

void XsonCollector::putFailed(const std::string& key) {
    rapidjson::Document::AllocatorType& allocator = doc.GetAllocator();
    rapidjson::Value item(rapidjson::kObjectType);

    item.AddMember("s", -1, allocator);  // 失败状态

    doc.AddMember(
            rapidjson::Value(key.c_str(), allocator).Move(),
            item,
            allocator
    );
}

void XsonCollector::putNotCollected(const std::string& key) {
    rapidjson::Document::AllocatorType& allocator = doc.GetAllocator();
    rapidjson::Value item(rapidjson::kObjectType);

    item.AddMember("s", -2, allocator);  // 未收集状态
    item.AddMember("v", rapidjson::Value(rapidjson::kNullType), allocator);

    doc.AddMember(
            rapidjson::Value(key.c_str(), allocator).Move(),
            item,
            allocator
    );
}

std::string XsonCollector::toString() {
    try {
        rapidjson::StringBuffer buffer;
        rapidjson::PrettyWriter<rapidjson::StringBuffer> writer(buffer);
        doc.Accept(writer);
        return buffer.GetString();
    } catch (const std::exception& e) {
        return "{}";
    }
}

void XsonCollector::clear() {
    doc.SetObject();
}
```

`app/src/main/cpp/src/warlockCore.cpp`:

```cpp
#include "../inc/warlockCore.h"


extern "C" {

// 实现 popen 方法
JNIEXPORT jstring JNICALL
Java_com_xiaoc_warlock_Util_NativeEngine_popen(JNIEnv *env, jobject /* obj */, jstring command) {
    const char *cmd = env->GetStringUTFChars(command, nullptr);
    char buffer[128];
    FILE *pipe = popen(cmd, "r");
    if (!pipe) {
        env->ReleaseStringUTFChars(command, cmd);
        return env->NewStringUTF("Error opening pipe");
    }

    // 读取命令输出
    std::string result;
    while (fgets(buffer, sizeof(buffer), pipe) != NULL) {
        result += buffer;
    }

    pclose(pipe);
    env->ReleaseStringUTFChars(command, cmd);
    return env->NewStringUTF(result.c_str());
}

// 实现 open 方法
JNIEXPORT jint JNICALL
Java_com_xiaoc_warlock_Util_NativeEngine_open(JNIEnv *env, jobject /* obj */, jstring path, jint flags) {
    const char *filePath = env->GetStringUTFChars(path, nullptr);
    int fd = open(filePath, flags);
    env->ReleaseStringUTFChars(path, filePath);
    return fd;
}
JNIEXPORT void JNICALL
Java_com_xiaoc_warlock_Util_NativeEngine_startCollect(JNIEnv *env, jclass /* clazz */, jobject callback) {
    NativeCollector::getInstance()->startCollect(env, callback);
}

JNIEXPORT jstring JNICALL
Java_com_xiaoc_warlock_Util_NativeEngine_getCollectedInfo(JNIEnv *env, jclass /* clazz */) {
    std::string jsonStr = NativeCollector::getInstance()->getCollectedInfo();
    return env->NewStringUTF(jsonStr.c_str());
}
JNIEXPORT void JNICALL
Java_com_xiaoc_warlock_Util_NativeEngine_startDetect(JNIEnv *env, jclass /* clazz */, jobject callback) {
    NativeDetector::getInstance()->startDetect(env, callback);
}

JNIEXPORT void JNICALL
Java_com_xiaoc_warlock_Util_NativeEngine_stopDetect(JNIEnv *env, jclass /* clazz */) {
    NativeDetector::getInstance()->cleanup();
}

}
```

`app/src/main/cpp/src/warlockServer.cpp`:

```cpp
//
// Created by 17267 on 2024-12-17.
//
#include <jni.h>
#include "detector/SandboxDetector.h"

extern "C" {
JNIEXPORT void JNICALL
Java_com_xiaoc_warlock_service_WarLockServer_nativeCheckSandbox(JNIEnv *env, jobject thiz) {
    SandboxDetector::checkSandbox(env, thiz);
    SandboxDetector::checkProcessByPs(env, thiz);

}
}
```

`app/src/main/java/com/xiaoc/warlock/App.java`:

```java
package com.xiaoc.warlock;

import android.app.Application;
import android.os.Build;

import com.xiaoc.warlock.Util.AppChecker;
import me.weishu.reflection.Reflection;

public class App extends Application {
    @Override
    public void onCreate() {
        super.onCreate();
        AppChecker.checkStackTrace(new Exception());
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                Reflection.unseal(this);

            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}

```

`app/src/main/java/com/xiaoc/warlock/BuildConfig.java`:

```java
package com.xiaoc.warlock;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class BuildConfig {
 public static String APP_PACKAGE = "com.xiaoc.warlock";
 public static final String ZYGISK_PATH = "/data/adb/zy";
 public static String APK_PATH = "/data/data/com.xiaoc.warlock";
 public static String AP_PACKAGE_PATH = "/data/data/me.bmax.apatch";
 public static String SDCARD_DOWNLOAD_PATH = "/sdcard/Download";
 public static String SDCARD_ANDROID_PATH = "/sdcard/Android/";
 public static String DATA_LOCAL_TMP_PATH = "/data/local/tmp";
 public static final String[] FINGERPRINT_REGIONS = {
         "build", "bootimage", "odm", "product", "system_ext", "system", "vendor"
 };
 public static final String KEYCHAIN_DIR = "/data/misc/keychain";
 public static final String PUBKEY_BLACKLIST_FILE = "/data/misc/keychain/pubkey_blacklist.txt";
 public static final String SERIAL_BLACKLIST_FILE = "/data/misc/keychain/serial_blacklist.txt";
 public static final Map<String, String> PATH_MAPPINGS = new HashMap<String, String>() {{
  put("/sdcard/Android/data/.nomedia", "SDADN");
  put("/sdcard/Android/data/com.google.android.gms", "SDADC");
  put("/sdcard/", "SD");
  put("/storage/emulated/0", "SD0");
 }};
 public static final int CAMERA_MINIMUM_QUANTITY_LIMIT = 2;
 public static final String STORAGE_SERIAL_PATH = "/sys/block/mmcblk0/device/serial";
 public static final String SERIAL_PATH = "/sys/devices/soc0/serial_number";
 public static final String DEVICES_PATH = "/proc/bus/input/devices";
 public static final String CID_PATH = "/sys/block/mmcblk0/device/cid";
 public static final int SENSOR_MINIMUM_QUANTITY_LIMIT = 15;
 public static  String[] targetPackages = {
         "com.sankuai.meituan",         // 美团
         "com.tencent.mm",              // 微信
         "bin.mt.plus",                 // MT管理器
         "com.smile.gifmaker",          // 快手
         "com.ss.android.ugc.aweme",    // 抖音
         "com.eg.android.AlipayGphone"  // 支付宝
 };
 public static final String APATCH_STRING = "Apatch";
 public static final String KSU_STRING = "KSU";
 public static final String[] SHIZUKU_FILES = {
         "/data/local/tmp/shizuku",
         "/data/local/tmp/shizuku_starter"
 };
 // 挂载点特征
 public static final List<String> MOUNT_KEYWORDS = Arrays.asList(
         "apatch",
         "ksu",
         "magisk",
         "supersu",
         "xposed",
         "edxposed",
         "lsposed"
 );

 // 内存映射特征
 public static final List<String> MAPS_KEYWORDS = Arrays.asList(
         "lspatch",
         "xposed",
         "edxposed",
         "lsposed",
         "riru",
         "zygisk",
         "magisk",
         "epic",
         "taichi",
         "virtualapp",
         "substratego",
         "dexposed"
 );
 /**
  * 模拟器共享文件夹路径列表
  */
 public static final String[] EMULATOR_MOUNT_PATHS = {
         "/mnt/shared/Sharefolder",    // 通用共享文件夹
         "/tiantian.conf",             // 天天模拟器
         "/data/share1",               // 通用共享目录
         "/hardware_device.conf",      // 硬件配置文件
         "/mnt/shared/products",       // 共享产品目录
         "/mumu_hardware.conf",        // MUMU模拟器
         "/Andy.conf",                 // Andy模拟器
         "/mnt/windows/BstSharedFolder", // BlueStacks
         "/bst.conf",                  // BlueStacks配置
         "/mnt/shared/Applications",   // 共享应用目录
         "/ld.conf",                    // LD模拟器
         "vboxsf",                      //virtualbox
         "docker"
 };
 /**
  * 检测这些属性的值是否异常。这是用于检测是否设备unlock
  */
 public static final String[] BOOTLOADER_PROPS = {
         "ro.boot.verifiedbootstate",
         "ro.secureboot.lockstate",
         "vendor.boot.vbmeta.device_state",
         "vendor.boot.verifiedbootstate",
         "ro.boot.vbmeta.device_state",
         "ro.boot.flash.locked"
 };
 /**
  * 模拟器的prop特征
  */
 public static final String[] QEMU_PROPS = {
         "ro.kernel.qemu.avd_name",
         "ro.kernel.qemu.gltransport",
         "ro.kernel.qemu.opengles.version",
         "ro.kernel.qemu.uirenderer",
         "ro.kernel.qemu.vsync",
         "ro.qemu.initrc",
         "init.svc.qemu-props",
         "qemu.adb.secure",
         "qemu.cmdline",
         "qemu.hw.mainkeys",
         "qemu.logcat",
         "ro.adb.qemud",
         "qemu.sf.fake_camera",
         "qemu.sf.lcd_density",
         "qemu.timezone",
         "init.svc.goldfish-logcat",
         "ro.boottime.goldfish-logcat",
         "ro.hardware.audio.primary",
         "init.svc.ranchu-net",
         "init.svc.ranchu-setup",
         "ro.boottime.ranchu-net",
         "ro.boottime.ranchu-setup",
         "init.svc.droid4x",
         "init.svc.noxd",
         "init.svc.qemud",
         "init.svc.goldfish-setup",
         "init.svc.goldfish-logcat",
         "init.svc.ttVM_x86-setup",
         "vmos.browser.home",
         "vmos.camera.enable",
         "ro.trd_yehuo_searchbox",
         "init.svc.microvirtd",
         "init.svc.vbox86-setup",
         "ro.ndk_translation.version",
         "redroid.width",
         "redroid.height",
         "redroid.fps",
         "ro.rf.vmname"
 };

 /**
  * 检测是否存在Xposed文件的特征
  */
 public static List<String> XPOSED_PATHS = Arrays.asList(
         "/sbin/.magisk/modules/riru_lsposed",
         "/data/adb/lspd",
         "/sbin/.magisk/modules/zygisk_lsposed",
         "/sbin/.magisk/modules/riru_edxposed",
         "/data/misc/riru/modules/edxp",
         "/data/adb/riru/modules/edxp.prop",
         "/sbin/.magisk/modules/taichi",
         "/data/misc/taichi",
         "/sbin/.magisk/modules/dreamland",
         "/data/misc/riru/modules/dreamland",
         "/data/adb/riru/modules/dreamland",
         "/system/bin/app_process.orig",
         "/system/xposed.prop",
         "/system/framework/XposedBridge.jar",
         "/system/lib/libxposed_art.so",
         "/system/lib/libxposed_art.so.no_orig",
         "/system/lib64/libxposed_art.so",
         "/system/lib64/libxposed_art.so.no_orig",
         "/system/bin/app_process_zposed",
         "/system/framework/ZposedBridge.jar",
         "/system/lib/libzposed_art.so"
 );
 /**
  * Root设备上常见的Apk
  */
 public static final String[] ROOT_PACKAGES = {
         "com.topjohnwu.magisk",
         "eu.chainfire.supersu",
         "com.noshufou.android.su",
         "com.noshufou.android.su.elite",
         "com.koushikdutta.superuser",
         "com.thirdparty.superuser",
         "com.yellowes.su",
         "com.fox2code.mmm",
         "io.github.vvb2060.magisk",
         "com.kingroot.kinguser",
         "com.kingo.root",
         "com.smedialink.oneclickroot",
         "com.zhiqupk.root.global",
         "com.alephzain.framaroot",
         "io.github.huskydg.magisk",
         "me.weishu.kernelsu",
         "me.bmax.apatch"
 };
 /**
  * Root相关文件路径列表
  */
 public static final String[] ROOT_FILES = {
         "/su/bin/su",
         "/sbin/su",
         "/data/local/xbin/su",
         "/data/local/bin/su",
         "/data/local/su",
         "/system/xbin/su",
         "/system/bin/su",
         "/system/sd/xbin/su",
         "/system/bin/failsafe/su",
         "/system/bin/.ext/.su",
         "/system/etc/.installed_su_daemon",
         "/system/etc/.has_su_daemon",
         "/system/xbin/sugote",
         "/system/xbin/sugote-mksh",
         "/system/xbin/supolicy",
         "/system/etc/init.d/99SuperSUDaemon",
         "/system/.supersu",
         "/product/bin/su",
         "/apex/com.android.runtime/bin/su",
         "/apex/com.android.art/bin/su",
         "/system_ext/bin/su",
         "/system/xbin/bstk/su",
         "/system/app/SuperUser/SuperUser.apk",
         "/system/app/Superuser.apk",
         "/system/xbin/mu_bak",
         "/odm/bin/su",
         "/vendor/bin/su",
         "/vendor/xbin/su",
         "/system/bin/.ext/su",
         "/system/usr/we-need-root/su",
         "/cache/su",
         "/data/su",
         "/dev/su",
         "/system/bin/cph_su",
         "/dev/com.koushikdutta.superuser.daemon",
         "/system/xbin/daemonsu",
         "/sbin/.mianju",
         "/sbin/nvsu",
         "/system/bin/.hid/su",
         "/system/addon.d/99-magisk.sh",
         "/cache/.disable_magisk",
         "/dev/magisk/img",
         "/sbin/.magisk",
         "/cache/magisk.log",
         "/data/adb/magisk",
         "/system/etc/init/magisk",
         "/system/etc/init/magisk.rc",
         "/data/magisk.apk"
 };
 public static final String[] EMULATOR_FILES = {
         // LD模拟器
         "/system/bin/ldinit",
         "/system/bin/ldmountsf",
         "/system/lib/libldutils.so",

         // MicroVirt (逍遥模拟器)
         "/system/bin/microvirt-prop",
         "/system/lib/libdroid4x.so",
         "/system/bin/windroyed",
         "/system/lib/libnemuVMprop.so",
         "/system/bin/microvirtd",

         // NOX (夜神模拟器)
         "/system/bin/nox-prop",
         "/system/lib/libnoxspeedup.so",
         "/data/property/persist.nox.simulator_version",
         "/data/misc/profiles/ref/com.bignox.google.installer",
         "/data/misc/profiles/ref/com.bignox.app.store.hd",

         // 其他模拟器特征
         "/system/bin/ttVM-prop",
         "/system/bin/droid4x-prop",
         "/system/bin/duosconfig",
         "/system/etc/xxzs_prop.sh",

         // MUMU模拟器
         "/system/etc/mumu-configs/device-prop-configs/mumu.config",

         // BlueStacks
         "/boot/bstsetup.env",
         "/boot/bstmods",
         "/system/xbin/bstk",
         "/data/bluestacks.prop",
         "/data/data/com.anrovmconfig",
         "/data/data/com.bluestacks.appmart",
         "/data/data/com.bluestacks.home",

         // MicroVirt相关
         "/data/data/com.microvirt.market",
         "/dev/nemuguest",
         "/data/data/com.microvirt.toolst",

         // MUMU相关
         "/data/data/com.mumu.launcher",
         "/data/data/com.mumu.store",
         "/data/data/com.netease.mumu.cloner",

         // BlueStacks其他特征
         "/system/bin/bstshutdown",
         "/sys/module/bstinput",
         "/sys/class/misc/bstXqpb",

         // PhoenixOS
         "/system/phoenixos",
         "/xbin/phoenix_compat",

         // 遁地模拟器
         "/init.dundi.rc",
         "/system/etc/init.dundi.sh",
         "/data/data/com.ddmnq.dundidevhelper",

         // Andy Cloud
         "/init.andy.cloud.rc",

         // 其他模拟器
         "/system/bin/xiaopiVM-prop",
         "/system/bin/XCPlayer-prop",
         "/system/lib/liblybox_prop.so",

         // 腾讯模拟器
         "/system/bin/tencent_virtual_input",
         "/vendor/bin/init.tencent.sh",

         // YouWave
         "/data/youwave_id",

         // VirtualBox相关
         "/dev/vboxguest",
         "/dev/vboxuser",
         "/sys/bus/pci/drivers/vboxguest",
         "/sys/class/bdi/vboxsf-c",
         "/sys/class/misc/vboxguest",
         "/sys/class/misc/vboxuser",
         "/sys/devices/virtual/bdi/vboxsf-c",
         "/sys/devices/virtual/misc/vboxguest",
         "/sys/devices/virtual/misc/vboxuser",
         "/sys/module/vboxguest",
         "/sys/module/vboxsf",
         "/sys/module/vboxvideo",
         "/system/bin/androVM-vbox-sf",
         "/system/bin/androVM_setprop",
         "/system/bin/get_androVM_host",
         "/system/bin/mount.vboxsf",
         "/system/etc/init.androVM.sh",
         "/system/etc/init.buildroid.sh",
         "/system/lib/vboxguest.ko",
         "/system/lib/vboxsf.ko",
         "/system/lib/vboxvideo.ko",
         "/system/xbin/mount.vboxsf",

         // Goldfish (Android模拟器)
         "/dev/goldfish_pipe",
         "/sys/devices/virtual/misc/goldfish_pipe",
         "/sys/module/goldfish_audio",
         "/sys/module/goldfish_battery",

         // KVM相关
         "/sys/module/kvm_intel/",
         "/sys/module/kvm_amd/",

         // x86相关配置文件
         "/init.android_x86_64.rc",
         "/init.android_x86.rc",
         "/init.androidVM_x86.rc",
         "/init.intel.rc",
         "/init.vbox2345_x86.rc",
         // 新增的模拟器相关路径
         "/system/bin/androVM-prop",
         "/system/bin/microvirt-prop",
         "/system/lib/libdroid4x.so",
         "/system/bin/windroyed",
         "/system/bin/nox-prop",
         "/system/lib/libnoxspeedup.so",
         "/system/bin/ttVM-prop",
         "/data/.bluestacks.prop",
         "/system/bin/duosconfig",
         "/system/etc/xxzs_prop.sh",
         "/system/etc/mumu-configs/device-prop-configs/mumu.config",
         "/system/priv-app/ldAppStore",
         "/system/bin/ldinit",
         "/system/bin/ldmountsf",
         "/system/app/AntStore",
         "/system/app/AntLauncher",
         "/vmos.prop",
         "/fstab.titan",
         "/init.titan.rc",
         "/x8.prop",
         "/system/lib/libc_malloc_debug_qemu.so",

         "/boot/bstmods/vboxsf.ko",
         "/dev/mtp_usb",
         "/dev/qemu_pipe",
         "/dev/socket/baseband_genyd",
         "/dev/socket/genyd",
         "/dev/socket/qemud",
         "/dev/socket/windroyed-audio",
         "/dev/socket/windroyed-camera",
         "/dev/socket/windroyed-gps",
         "/dev/socket/windroyed-sensors",
         "/dev/vboxguest",
         "/dev/vboxpci",
         "/dev/vboxuser",
         "/fstab.goldfish",
         "/fstab.nox",
         "/fstab.ranchu-encrypt",
         "/fstab.ranchu-noencrypt",
         "/fstab.ttVM_x86",
         "/fstab.vbox86",
         "/init.goldfish.rc",
         "/init.magisk.rc",
         "/init.nox.rc",
         "/init.ranchu-encrypt.rc",
         "/init.ranchu-noencrypt.rc",
         "/init.ranchu.rc",
         "/init.ttVM_x86.rc",
         "/init.vbox86.rc",
         "/init.vbox86p.rc",
         "/init.windroye.rc",
         "/init.windroye.sh",
         "/init.x86.rc",
         "/proc/irq/20/vboxguest",
         "/sdcard/Android/data/com.redfinger.gamemanage",
         "/stab.andy",
         "/sys/bus/pci/drivers/vboxguest",
         "/sys/bus/pci/drivers/vboxpci",
         "/sys/bus/platform/drivers/qemu_pipe",
         "/sys/bus/platform/drivers/qemu_pipe/qemu_pipe",
         "/sys/bus/platform/drivers/qemu_trace",
         "/sys/bus/virtio/drivers/itolsvmlgtp",
         "/sys/bus/virtio/drivers/itoolsvmhft",
         "/sys/class/bdi/vboxsf-1",
         "/sys/class/bdi/vboxsf-2",
         "/sys/class/bdi/vboxsf-3",
         "/sys/class/misc/qemu_pipe",
         "/sys/class/misc/vboxguest",
         "/sys/class/misc/vboxuser",
         "/sys/devices/platform/qemu_pipe",
         "/sys/devices/virtual/bdi/vboxsf-1",
         "/sys/devices/virtual/bdi/vboxsf-2",
         "/sys/devices/virtual/bdi/vboxsf-3",
         "/sys/devices/virtual/misc/qemu_pipe",
         "/sys/devices/virtual/misc/vboxguest",
         "/sys/devices/virtual/misc/vboxpci",
         "/sys/devices/virtual/misc/vboxuser",
         "/sys/fs/selinux/booleans/in_qemu",
         "/sys/kernel/debug/bdi/vboxsf-1",
         "/sys/kernel/debug/bdi/vboxsf-2",
         "/sys/kernel/debug/x86",
         "/sys/module/qemu_trace_sysfs",
         "/sys/module/vboxguest",
         "/sys/module/vboxguest/drivers/pci:vboxguest",
         "/sys/module/vboxpcism",
         "/sys/module/vboxsf",
         "/sys/module/vboxvideo",
         "/sys/module/virtio_pt/drivers/virtio:itoolsvmhft",
         "/sys/module/virtio_pt_ie/drivers/virtio:itoolsvmlgtp",
         "/sys/qemu_trace",
         "/system/app/GenymotionLayout",
         "/system/bin/OpenglService",
         "/system/bin/androVM-vbox-sf",
         "/system/bin/droid4x",
         "/system/bin/droid4x-prop",
         "/system/bin/droid4x-vbox-sf",
         "/system/bin/droid4x_setprop",
         "/system/bin/enable_nox",
         "/system/bin/genymotion-vbox-sf",
         "/system/bin/microvirt-prop",
         "/system/bin/microvirt-vbox-sf",
         "/system/bin/microvirt_setprop",
         "/system/bin/microvirtd",
         "/system/bin/mount.vboxsf",
         "/system/bin/nox",
         "/system/bin/nox-prop",
         "/system/bin/nox-vbox-sf",
         "/system/bin/nox_setprop",
         "/system/bin/noxd",
         "/system/bin/noxscreen",
         "/system/bin/noxspeedup",
         "/system/bin/qemu-props",
         "/system/bin/qemud",
         "/system/bin/shellnox",
         "/system/droid4x",
         "/system/etc/init.droid4x.sh",
         "/system/etc/init.tiantian.sh",
         "/system/lib/egl/libEGL_emulation.so",
         "/system/lib/egl/libEGL_tiantianVM.so",
         "/system/lib/egl/libEGL_windroye.so",
         "/system/lib/egl/libGLESv1_CM_emulation.so",
         "/system/lib/egl/libGLESv1_CM_tiantianVM.so",
         "/system/lib/egl/libGLESv1_CM_windroye.so",
         "/system/lib/egl/libGLESv2_emulation.so",
         "/system/lib/egl/libGLESv2_tiantianVM.so",
         "/system/lib/egl/libGLESv2_windroye.so",
         "/system/lib/hw/audio.primary.vbox86.so",
         "/system/lib/hw/audio.primary.windroye.so",
         "/system/lib/hw/audio.primary.x86.so",
         "/system/lib/hw/autio.primary.nox.so",
         "/system/lib/hw/camera.vbox86.so",
         "/system/lib/hw/camera.windroye.jpeg.so",
         "/system/lib/hw/camera.windroye.so",
         "/system/lib/hw/camera.x86.so",
         "/system/lib/hw/gps.nox.so",
         "/system/lib/hw/gps.vbox86.so",
         "/system/lib/hw/gps.windroye.so",
         "/system/lib/hw/gralloc.nox.so",
         "/system/lib/hw/gralloc.vbox86.so",
         "/system/lib/hw/gralloc.windroye.so",
         "/system/lib/hw/sensors.nox.so",
         "/system/lib/hw/sensors.vbox86.so",
         "/system/lib/hw/sensors.windroye.so",
         "/system/lib/init.nox.sh",
         "/system/lib/libGM_OpenglSystemCommon.so",
         "/system/lib/libnoxd.so",
         "/system/lib/libnoxspeedup.so",
         "/system/lib/modules/3.10.30-android-x86.hd+",
         "/system/lib/vboxguest.ko",
         "/system/lib/vboxpcism.ko",
         "/system/lib/vboxsf.ko",
         "/system/lib/vboxvideo.ko",
         "/system/lib64/egl/libEGL_emulation.so",
         "/system/lib64/egl/libGLESv1_CM_emulation.so",
         "/system/lib64/egl/libGLESv2_emulation.so",
         "/system/lib64/libc_malloc_debug_qemu.so",
         "/system/usr/Keylayout/droid4x_Virtual_Input.kl",
         "/system/usr/idc/Genymotion_Virtual_Input.idc",
         "/system/usr/idc/droid4x_Virtual_Input.idc",
         "/system/usr/idc/nox_Virtual_Input.idc",
         "/system/usr/idc/windroye.idc",
         "/system/usr/keychars/nox_gpio.kcm",
         "/system/usr/keychars/windroye.kcm",
         "/system/usr/keylayout/Genymotion_Virtual_Input.kl",
         "/system/usr/keylayout/nox_Virtual_Input.kl",
         "/system/usr/keylayout/nox_gpio.kl",
         "/system/usr/keylayout/windroye.kl",
         "/system/xbin/noxsu",
         "/ueventd.android_x86.rc",
         "/ueventd.andy.rc",
         "/ueventd.goldfish.rc",
         "/ueventd.nox.rc",
         "/ueventd.ranchu.rc",
         "/vendor/lib64/libgoldfish-ril.so",
         "/vendor/lib64/libgoldfish_codecs_common.so",
         "/vendor/lib64/libstagefright_goldfish_avcdec.so",
         "/vendor/lib64/libstagefright_goldfish_vpxdec.so",
         "/x86.prop"

 };

}

```

`app/src/main/java/com/xiaoc/warlock/Core/BaseCollector.java`:

```java
package com.xiaoc.warlock.Core;

import android.content.Context;

import com.xiaoc.warlock.Util.InfoValue;
import com.xiaoc.warlock.Util.XLog;
import com.xiaoc.warlock.Util.Xson;

import java.util.List;
import java.util.Map;

public abstract class BaseCollector  implements CollectCallback {
    protected Context context;

    public BaseCollector(Context context) {
        this.context = context;
    }

    public abstract void collect();

    /**
     * 存储字符串信息
     */
    protected void putInfo(String key, String value) {
        try {
            Xson.put(key, new InfoValue(0, value));
        } catch (Exception e) {
            Xson.put(key, InfoValue.fail());
            XLog.e("BaseCollector", "Failed to collect " + key + ": " + e.getMessage());
        }
    }
    /**
     * 存储布尔值信息
     */
    protected void putInfo(String key, Boolean value) {
        try {
            Xson.put(key, new InfoValue(0, value));
        } catch (Exception e) {
            Xson.put(key, InfoValue.fail());
            XLog.e("BaseCollector", "Failed to collect " + key + ": " + e.getMessage());
        }
    }
    /**
     * 存储长整型的信息
     */
    protected void putInfo(String key, long value) {
        try {
            Xson.put(key, new InfoValue(0, String.valueOf(value)));
        } catch (Exception e) {
            Xson.put(key, InfoValue.fail());
            XLog.e("BaseCollector", "Failed to collect " + key + ": " + e.getMessage());
        }
    }
    /**
     * 存储列表信息
     */
    protected void putInfo(String key, List<?> value) {
        try {
            Xson.put(key, new InfoValue(0, value));
        } catch (Exception e) {
            Xson.put(key, InfoValue.fail());
            XLog.e("BaseCollector", "Failed to collect " + key + ": " + e.getMessage());
        }
    }

    /**
     * 存储Map信息
     */
    protected void putInfo(String key, Map<?, ?> value) {
        try {
            Xson.put(key, new InfoValue(0, value));
        } catch (Exception e) {
            Xson.put(key, InfoValue.fail());
            XLog.e("BaseCollector", "Failed to collect " + key + ": " + e.getMessage());
        }
    }
    protected void putFailedInfo(String key) {
        Xson.put(key, InfoValue.fail());
    }

    protected void putNotCollectedInfo(String key) {
        Xson.put(key, InfoValue.notCollected());
    }
    @Override
    public void onNativeCollectComplete() {
        // 处理 Native 层收集完成的逻辑
    }
}
```

`app/src/main/java/com/xiaoc/warlock/Core/BaseDetector.java`:

```java
package com.xiaoc.warlock.Core;

import android.content.Context;

import com.xiaoc.warlock.Util.XLog;
import com.xiaoc.warlock.ui.adapter.InfoItem;

public abstract class BaseDetector {
    protected Context context;
    protected EnvironmentCallback callback;

    public interface EnvironmentCallback {
        void onAbnormalDetected(InfoItem item);
    }

    public BaseDetector(Context context, EnvironmentCallback callback) {
        this.context = context;
        this.callback = callback;
    }

    public abstract void detect();

    protected void reportAbnormal(InfoItem item) {
        if (callback != null) {
            callback.onAbnormalDetected(item);
        }
    }
    // 添加 release 方法
    public void release() {
        // 基类的清理工作
        context = null;
        callback = null;
    }
}
```

`app/src/main/java/com/xiaoc/warlock/Core/CollectCallback.java`:

```java
package com.xiaoc.warlock.Core;


/**
 * Native层指纹收集完成的回调接口
 */
public interface CollectCallback {
    /**
     * Native层收集完成时调用
     */
    void onNativeCollectComplete();
}
```

`app/src/main/java/com/xiaoc/warlock/Core/DetectCallback.java`:

```java
package com.xiaoc.warlock.Core;

import android.content.Context;

public interface DetectCallback {
    Context getContext();  // 添加获取Context的方法
    void onDetectWarning(String type, String level, String detail);
}
```

`app/src/main/java/com/xiaoc/warlock/Core/EnvironmentDetector.java`:

```java
package com.xiaoc.warlock.Core;

import android.content.Context;
import android.os.Handler;
import android.os.Looper;

import com.xiaoc.warlock.Core.detector.CloudPhoneDetector;
import com.xiaoc.warlock.Core.detector.HookDetector;
import com.xiaoc.warlock.Core.detector.MiscDetector;
import com.xiaoc.warlock.Core.detector.RootDetector;
import com.xiaoc.warlock.Core.detector.SandboxDetector;
import com.xiaoc.warlock.Core.detector.SignatureDetector;
import com.xiaoc.warlock.Core.detector.VirtualDetector;
import com.xiaoc.warlock.Core.detector.XposedDetector;
import com.xiaoc.warlock.Util.XLog;
import com.xiaoc.warlock.ui.adapter.InfoItem;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class EnvironmentDetector  implements BaseDetector.EnvironmentCallback{
    private String TAG = "EnvironmentDetector";
    private static EnvironmentDetector instance;
    private final Context context;
    private final Handler handler;
    private final List<EnvironmentCallback> callbacks = new ArrayList<>();
    private boolean isDetecting = false;
    private final List<BaseDetector> detectors;
    private final List<InfoItem> pendingItems = new ArrayList<>(); // 添加待处理项列表

    @Override
    public void onAbnormalDetected(InfoItem item) {
        XLog.d(TAG, "Received abnormal detection: " + item.getTitle());
        if (callbacks.isEmpty()) {
            XLog.d(TAG, "No callbacks registered, queuing item");
            pendingItems.add(item);
        } else {
            notifyEnvironmentChange(item);
        }
    }

    public interface EnvironmentCallback {
        void onEnvironmentChanged(InfoItem newItem);
    }

    private EnvironmentDetector(Context context) {
        this.context = context.getApplicationContext();
        this.handler = new Handler(Looper.getMainLooper());
        this.detectors = initDetectors();
    }

    private List<BaseDetector> initDetectors() {
        return Arrays.asList(
                new RootDetector(context, this),
                new VirtualDetector(context,this),
                new MiscDetector(context,this),
                new XposedDetector(context,this),
                new SandboxDetector(context,this),
                new CloudPhoneDetector(context,this),
                new SignatureDetector(context,this),
                new HookDetector(context,this)
                // 添加更多检测器...
        );
    }

    public static synchronized EnvironmentDetector getInstance(Context context) {
        if (instance == null) {
            instance = new EnvironmentDetector(context);
        }
        return instance;
    }

    public void registerCallback(EnvironmentCallback callback) {
        if (!callbacks.contains(callback)) {
            callbacks.add(callback);
            XLog.d(TAG, "Registered callback: " + callback.getClass().getSimpleName());

            // 发送所有待处理的警告
            if (!pendingItems.isEmpty()) {
                XLog.d(TAG, "Processing " + pendingItems.size() + " pending items");
                for (InfoItem item : pendingItems) {
                    notifyEnvironmentChange(item);
                }
                pendingItems.clear();
            }
        }
    }

    public void unregisterCallback(EnvironmentCallback callback) {
        callbacks.remove(callback);
    }

    public void startDetection() {
        if (isDetecting) return;
        isDetecting = true;
        for (BaseDetector detector : detectors) {
            detector.detect();
        }
    }

    public void stopDetection() {
        handler.removeCallbacksAndMessages(null);
    }


    private void notifyEnvironmentChange(InfoItem item) {
        handler.post(() -> {
            XLog.d(TAG, "Notifying " + callbacks.size() + " callbacks about environment change");  // 添加日志
            for (EnvironmentCallback callback : callbacks) {
                if (callback != null) {  // 添加空检查
                    callback.onEnvironmentChanged(item);
                    XLog.d(TAG, "Notified callback: " + callback.getClass().getSimpleName());  // 添加日志
                }
            }
        });
    }
}
```

`app/src/main/java/com/xiaoc/warlock/Core/FingerprintCollector.java`:

```java
package com.xiaoc.warlock.Core;

import android.content.Context;
import android.hardware.SensorManager;
import android.os.Build;
import android.os.Environment;
import android.os.StatFs;
import android.telephony.TelephonyManager;
import android.util.DisplayMetrics;
import android.view.WindowManager;

import com.xiaoc.warlock.Util.NativeEngine;
import com.xiaoc.warlock.Util.XLog;
import com.xiaoc.warlock.Util.Xson;
import com.xiaoc.warlock.crypto.MD5Util;
import com.xiaoc.warlock.ui.adapter.InfoItem;

import org.json.JSONException;
import org.json.JSONObject;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Set;

public class FingerprintCollector {
    private final Context context;
    private final List<FingerprintCallback> callbacks = new ArrayList<>();
    private static FingerprintCollector instance;
    private static final String TAG = "FingerprintCollector";
    private String eventId = null;
    
    // 需要进行MD5加密的键列表
    private static final Set<String> MD5_KEYS = new HashSet<>(Arrays.asList(
            "a3","a5","a7","a14", "a21", "a52","a53","a58","a64","a69","a70","a6" ,"n1","n3","n8","n9","n10","n11","n12","n15","n17","n20","n21"
    ));

    public interface FingerprintCallback {
        void onFingerprintCollected(InfoItem item);
    }

    private FingerprintCollector(Context context) {
        this.context = context.getApplicationContext();
    }

    public static synchronized FingerprintCollector getInstance(Context context) {
        if (instance == null) {
            instance = new FingerprintCollector(context);
        }
        return instance;
    }

    public void registerCallback(FingerprintCallback callback) {
        if (!callbacks.contains(callback)) {
            callbacks.add(callback);
        }
    }

    public void unregisterCallback(FingerprintCallback callback) {
        callbacks.remove(callback);
    }
    
    /**
     * 设置事件ID并显示
     * @param eventId 要显示的事件ID
     * @param isSuccess 是否获取/上报成功
     * @param errorMsg 错误信息，如果isSuccess为false则使用此信息
     */
    public void setAndDisplayEventId(String eventId, boolean isSuccess, String errorMsg) {
        this.eventId = eventId;
        
        // 创建事件ID展示项
        InfoItem eventIdItem = new InfoItem("Event ID", "事件ID信息");
        if (isSuccess) {
            eventIdItem.addDetail("state", "success");
            eventIdItem.addDetail("event_id", eventId);
        } else {
            eventIdItem.addDetail("state", "error");
            eventIdItem.addDetail("state", "failed");
        }
        
        // 通知回调
        notifyCallbacks(eventIdItem);
    }

    public void collectFingerprint() {
        // 在后台线程中从已收集的数据中获取信息并展示
        new Thread(() -> {
            try {
                // 获取Java层数据
                String javaJson = Xson.getMapString(true);
                if (javaJson != null && !javaJson.isEmpty()) {
                    parseAndDisplayJavaFingerprint(javaJson);
                }

                // 获取Native层数据
                String nativeJson = NativeEngine.getCollectedInfo();
                if (nativeJson != null && !nativeJson.isEmpty()) {
                    parseAndDisplayNativeFingerprint(nativeJson);
                }
            } catch (Exception e) {
                XLog.e(TAG, "Error collecting fingerprints: " + e.getMessage());
            }
        }).start();
    }

    private void notifyCallbacks(InfoItem item) {
        for (FingerprintCallback callback : callbacks) {
            if (callback != null) {
                callback.onFingerprintCollected(item);
            }
        }
    }
    
    /**
     * 解析并展示Java层收集的指纹信息
     */
    private void parseAndDisplayJavaFingerprint(String javaFingerprint) {
        try {
            JSONObject jsonObject = new JSONObject(javaFingerprint);

            // 基本设备信息
            InfoItem basicInfo = new InfoItem("Base Info", "基本设备信息");
            addJsonDataToInfoItem(jsonObject, basicInfo, new String[]{"a8",Build.MODEL,Build.CPU_ABI,Build.VERSION.RELEASE,"a11","a67"},
                    new String[]{"Vendor","Model","CPU_ABI","AndroidVersion","FingerPrint","KernelInfo"});
            notifyCallbacks(basicInfo);
            //Java层设备信息
            InfoItem javaInfo = new InfoItem("Java Fingerprint", "java指纹信息");
            addJsonDataToInfoItem(jsonObject, javaInfo, new String[]{"a3","a4","a5","a6", "a7","a14", "a21","a52","a53","a58","a69" ,"a70","a80","a81"},
                    new String[]{"a3","a4","a5","a6", "a7","a14", "a21","a52","a53","a58","a69" ,"a70","a80","a81"});
            notifyCallbacks(javaInfo);

        } catch (JSONException e) {
            XLog.e(TAG, "Error parsing Java fingerprint: " + e.getMessage());
        }
    }

    /**
     * 解析并展示Native层收集的指纹信息
     */
    private void parseAndDisplayNativeFingerprint(String nativeFingerprint) {
        try {
            JSONObject jsonObject = new JSONObject(nativeFingerprint);

            //Native层设备信息
            InfoItem nativeInfo = new InfoItem("Native Fingerprint", "native指纹信息");
            addJsonDataToInfoItem(jsonObject, nativeInfo, new String[]{"n1","n3","n9","n10","n11","n12","n15"},
                    new String[]{"n1","n3","n9","n10","n11","n12","n15"});
            notifyCallbacks(nativeInfo);
            
        } catch (JSONException e) {
            XLog.e(TAG, "Error parsing Native fingerprint: " + e.getMessage());
        }
    }
    
    /**
     * 辅助方法：从JSON对象中提取数据并添加到InfoItem中
     * 支持处理普通字符串键和以a或n开头后跟1-2位数字的键
     * 对于指定的键，会对值进行MD5加密后再展示
     */
    private void addJsonDataToInfoItem(JSONObject jsonObject, InfoItem infoItem, 
                                     String[] keys, String[] displayNames) {

        for (int i = 0; i < keys.length; i++) {
            try {
                String key = keys[i];
                // 检查是否是以a或n开头后跟1-2位数字的键
                if ((key.startsWith("a") || key.startsWith("n")) && 
                    key.length() >= 2 && key.length() <= 3 && 
                    Character.isDigit(key.charAt(1)) && 
                    (key.length() == 2 || Character.isDigit(key.charAt(2)))) {
                    
                    // 处理a或n开头后跟1-2位数字的键
                    if (jsonObject.has(key)) {
                        JSONObject data = jsonObject.getJSONObject(key);
                        if (data.has("v")) {
                            Object value = data.get("v");
                            String valueStr = value.toString();
                            
                            // 检查是否需要进行MD5加密
                            if (MD5_KEYS.contains(key)) {
                                // 对数据进行MD5加密
                                valueStr = MD5Util.md5(valueStr);
                                XLog.d(TAG, "Applied MD5 encryption to key: " + key);
                            }
                            
                            infoItem.addDetail(displayNames[i], valueStr);
                        }
                    }
                } else {
                    // 对于常规键，直接添加
                    infoItem.addDetail(displayNames[i], key);
                }
            } catch (JSONException e) {
                XLog.e(TAG, "Error getting " + keys[i] + ": " + e.getMessage());
            }
        }
    }
} 
```

`app/src/main/java/com/xiaoc/warlock/Core/Warlock.java`:

```java
package com.xiaoc.warlock.Core;

import android.content.Context;

import com.xiaoc.warlock.Core.collector.BasicInfoCollector;
import com.xiaoc.warlock.Core.collector.MiscInfoCollector;
import com.xiaoc.warlock.Core.collector.PhoneInfoCollector;
import com.xiaoc.warlock.Core.collector.SignatureCollector;
import com.xiaoc.warlock.Core.collector.StatInfoCollector;
import com.xiaoc.warlock.Core.collector.SystemInfoCollector;
import com.xiaoc.warlock.Core.collector.WebViewInfoCollector;
import com.xiaoc.warlock.Util.Xson;

import java.util.Arrays;
import java.util.List;

public class Warlock {
    private static volatile Warlock instance;
    private final Context context;
    private final List<BaseCollector> collectors;


    
    private Warlock(Context context) {
        if (context == null) {
            throw new IllegalArgumentException("Context cannot be null");
        }
        this.context = context.getApplicationContext();
        this.collectors = initCollectors();
    }

    public static Warlock getInstance(Context context) {
        if (context == null) {
            throw new IllegalArgumentException("Context cannot be null");
        }
        if (instance == null) {
            synchronized (Warlock.class) {
                if (instance == null) {
                    instance = new Warlock(context);
                }
            }
        }
        return instance;
    }

    private List<BaseCollector> initCollectors() {
        return Arrays.asList(
                new SignatureCollector(context),
                new BasicInfoCollector(context),
                new StatInfoCollector(context),
                new PhoneInfoCollector(context),
                new MiscInfoCollector(context),
                new SystemInfoCollector(context),
                new WebViewInfoCollector(context)
                // 添加更多收集器...
        );
    }

    /**
     * 收集所有信息
     */
    public void collectFingerprint() {
        // 清除旧数据
        Xson.clear();

        // 收集新数据
        for (BaseCollector collector : collectors) {
            collector.collect();
        }
    }
}

```

`app/src/main/java/com/xiaoc/warlock/Core/collector/BasicInfoCollector.java`:

```java
package com.xiaoc.warlock.Core.collector;

import android.accounts.Account;
import android.accounts.AccountManager;
import android.annotation.SuppressLint;
import android.bluetooth.BluetoothAdapter;
import android.content.ContentResolver;
import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.database.Cursor;
import android.media.MediaDrm;
import android.net.Uri;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.os.IBinder;
import android.os.Parcel;
import android.provider.Settings;
import android.util.ArrayMap;
import android.util.Base64;

import com.google.android.gms.ads.identifier.AdvertisingIdClient;
import com.xiaoc.warlock.BuildConfig;
import com.xiaoc.warlock.Core.BaseCollector;
import com.xiaoc.warlock.Util.MiscUtil;
import com.xiaoc.warlock.Util.XCommandUtil;
import com.xiaoc.warlock.Util.XFile;
import com.xiaoc.warlock.Util.XLog;
import com.xiaoc.warlock.Util.XString;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.TimeZone;
import java.util.UUID;
import java.util.regex.Pattern;

public class BasicInfoCollector extends BaseCollector {
    private static final String TAG = "BasicInfoCollector";
    private static final Pattern PROP_PATTERN = Pattern.compile("\\[(.*?)\\]:\\s*\\[(.*?)\\]");
    private static final String WIDEVINE_UUID = "edef8ba9-79d6-4ace-a3c8-27dcd51d21ed";
    private static final Uri GSF_URI = Uri.parse("content://com.google.android.gsf.gservices");
    private static final String GSF_PACKAGE = "com.google.android.gsf";

    public BasicInfoCollector(Context context) {
        super(context);
    }

    @Override
    public void collect() {
        // 设备标识信息
        getMacAddress();            // MAC地址
        getAndroidID();            // a5: Android ID
        getAaid();                 // a3: Google Advertising ID
        getDrmIdSha256();          // a6: DRM ID
        getBootID();               // a4: Boot ID
        
        // 系统属性信息
        getProp();                 // a1: System Properties
        archInfo();                // a2: CPU架构信息
        
        // 设备基本信息
        collectDeviceBrands();     // a8, a9: 品牌和型号
        collectDeviceSerial();     // a20: 序列号
        collectFingerprint();      // a11: 设备指纹
        collectDataDir();          // a10: 数据目录
        collectTimeZone();         // a12: 时区信息
        
        // 应用相关信息
        getAppPackage();           // a16: 包名信息
        getAppPath();              // a14: 应用路径
        
        // 其他信息
        collectAccounts();         // a60: 账户信息
        getBluetoothAddress();     // a15: 蓝牙地址
    }

    /**
     * 收集设备品牌和型号信息
     */
    private void collectDeviceBrands() {
        try {
            putInfo("a8", Build.BRAND);
        } catch (Exception e) {
            putFailedInfo("a8");
        }

        try {
            putInfo("a9", Build.MODEL);
        } catch (Exception e) {
            putFailedInfo("a9");
        }
    }

    /**
     * 收集设备序列号
     */
    private void collectDeviceSerial() {
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                putInfo("a20", Build.getSerial());
            } else {
                putFailedInfo("a20");
            }
        } catch (Exception e) {
            putFailedInfo("a20");
        }
    }

    /**
     * 收集设备指纹
     */
    private void collectFingerprint() {
        try {
            putInfo("a11", Build.FINGERPRINT);
        } catch (Exception e) {
            putFailedInfo("a11");
        }
    }

    /**
     * 收集数据目录
     */
    private void collectDataDir() {
        try {
            putInfo("a10", context.getApplicationInfo().dataDir);
        } catch (Exception e) {
            putFailedInfo("a10");
        }
    }

    /**
     * 收集时区信息
     */
    private void collectTimeZone() {
        try {
            TimeZone timeZone = TimeZone.getDefault();
            putInfo("a12", timeZone.getID());
        } catch (Exception e) {
            putFailedInfo("a12");
        }
    }

    public void getAppPath() {
        Map<String, String> pathInfo = new LinkedHashMap<>();

        String pm_Path = "";
        String src_Path= "";
        String shell_Path= "";
        try {
            // 方法1：通过ApplicationInfo获取
             src_Path = context.getApplicationInfo().sourceDir;

            // 方法2：通过PackageManager获取
            PackageManager pm = context.getPackageManager();
            ApplicationInfo ai = pm.getApplicationInfo(context.getPackageName(), 0);
            pm_Path = ai.sourceDir;

            // 方法3：通过命令行获取
            String packageName = context.getPackageName();
            String command = "pm path " + packageName;
            XCommandUtil.CommandResult result = XCommandUtil.execute(command);
            if (result.isSuccess()) {
                shell_Path = result.getSuccessMsg().replace("package:", "");
            }
            if (XString.compareIgnoreSpaces(src_Path,pm_Path,shell_Path)){
                putInfo("a14",src_Path);
            }else {
                pathInfo.put("src_Path",pm_Path);
                pathInfo.put("pm_Path",pm_Path);
                pathInfo.put("shell_Path",shell_Path);
                putInfo("a14",pathInfo);
            }

        } catch (Exception e) {
            putFailedInfo("a14");
        }
    }
    //通过两种方式获取并判断是否一致，如果获取出来的结果一致就写入bootFile获取的结果，如果不一致则写入两种不同的结果
    private  void getBootID(){
        try {
            Map<String, String> bootInfo = new LinkedHashMap<>();
            String bootFile = XFile.readFile("/proc/sys/kernel/random/boot_id");
            String bootShell;
            XCommandUtil.CommandResult result = XCommandUtil.execute("cat /proc/sys/kernel/random/boot_id");
            if (result.isSuccess()) {
                bootShell = result.getSuccessMsg();
            }else {
                bootShell = "null";
            }
            boolean bootB = XString.compareIgnoreSpaces(bootFile,bootShell);
            if (bootB){
                putInfo("a4",bootShell);
            }else {
                bootInfo.put("bootFile" ,bootFile);
                bootInfo.put("bootShell" ,bootShell);
                putInfo("a4",bootInfo);
            }
        }catch (Exception e){
            putFailedInfo("a4");

        }

    }
    private void archInfo (){
        try {
            Map<String, String> archInfo = new LinkedHashMap<>();

            // 方法1：通过Build类获取
            String cpuAbi = Build.CPU_ABI;
            if (!XString.isEmpty(cpuAbi)) {
                archInfo.put("ARCH_BUILD" , cpuAbi);
            }

            String arch;
            // 方法2：通过系统属性获取
            arch = System.getProperty("os.arch");
            if (!XString.isEmpty(arch)) {
                archInfo.put("ARCH_SYSTEM" , cpuAbi);
            }

            // 方法3：通过执行命令获取
            try {
                Process process = Runtime.getRuntime().exec("getprop ro.product.cpu.abi");
                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                arch = reader.readLine();
                reader.close();
                if (!XString.isEmpty(arch)) {
                    archInfo.put("ARCH_PROP" , arch);
                }
            } catch (Exception ignored) {
            }
            XLog.d(archInfo.toString());
            // 如果收集到信息，则存储
            if (!archInfo.isEmpty()) {
                // 直接存储List，Gson会自动转换为数组
                putInfo("a2", archInfo);
            } else {
                putFailedInfo("a2");
            }
        }catch (Exception e){
            putFailedInfo("a2");

        }

    }
    private void getProp() {
        try {
            XCommandUtil.CommandResult result = XCommandUtil.execute("getprop");
            if (result.isSuccess()) {
                Map<String, String> propMap = new LinkedHashMap<>();
                String content = result.getSuccessMsg();
                // XLog.d(content);

                // 按行分割输出
                String[] lines = content.split("\n");
                for (String line : lines) {
                    // 去掉首尾空白字符
                    line = line.trim();
                    if (line.isEmpty()) continue;

                    // 查找键和值
                    int keyStart = line.indexOf('[');
                    int keyEnd = line.indexOf(']', keyStart);
                    int valueStart = line.indexOf('[', keyEnd);
                    int valueEnd = line.indexOf(']', valueStart);

                    if (keyStart != -1 && keyEnd != -1 && valueStart != -1 && valueEnd != -1) {
                        String key = line.substring(keyStart + 1, keyEnd).trim();
                        String value = line.substring(valueStart + 1, valueEnd).trim();
                        if (!key.isEmpty()) {
                            propMap.put(key, value);
                        }
                    }
                }

                // 输出剩余的属性
                if (!propMap.isEmpty()) {
                    putInfo("a1", propMap);
                }
            } else {
                putFailedInfo("a1");
            }
        }catch (Exception e) {
            putFailedInfo("a1");
            XLog.e(TAG, "Failed to collect props: " + e.getMessage());
        }

    }
    /**
     * 通过Binder方式获取Android ID
     */
    private String getAndroidIdViaBinder() {
        Parcel data = null;
        Parcel reply = null;

        try {
            // 获取ActivityThread实例
            Class<?> activityThreadClass = Class.forName("android.app.ActivityThread");
            Object currentActivityThread = activityThreadClass
                    .getMethod("currentActivityThread")
                    .invoke(null);

            // 获取ContentProvider
            Object provider = activityThreadClass
                    .getMethod("acquireProvider", Context.class, String.class, int.class, boolean.class)
                    .invoke(currentActivityThread, context, "settings", 0, true);

            if (provider == null) return "";

            // 获取IContentProvider的Binder对象
            Field mRemoteField = provider.getClass().getDeclaredField("mRemote");
            mRemoteField.setAccessible(true);
            IBinder binder = (IBinder) mRemoteField.get(provider);

            if (binder == null) return "";

            // 准备Parcel数据
            data = Parcel.obtain();
            reply = Parcel.obtain();

            // 写入接口标识
            data.writeInterfaceToken("android.content.IContentProvider");

            // 根据Android版本写入不同参数
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                // Android 12及以上
                context.getAttributionSource().writeToParcel(data, 0);
                writeCommonParcelData(data);
            } else if (Build.VERSION.SDK_INT == Build.VERSION_CODES.R) {
                // Android 11
                data.writeString(context.getPackageName());
                data.writeString(null); // featureId
                writeCommonParcelData(data);
            } else if (Build.VERSION.SDK_INT == Build.VERSION_CODES.Q) {
                // Android 10
                data.writeString(context.getPackageName());
                writeCommonParcelData(data);
            } else {
                // Android 9及以下
                data.writeString(context.getPackageName());
                data.writeString("GET_secure");
                data.writeString("android_id");
                data.writeBundle(Bundle.EMPTY);
            }

            // 执行Binder调用
            int callTransaction = Class.forName("android.content.IContentProvider")
                    .getDeclaredField("CALL_TRANSACTION")
                    .getInt(null);

            if (binder.transact(callTransaction, data, reply, 0)) {
                reply.readException();
                Bundle resultBundle = reply.readBundle();
                return resultBundle != null ? resultBundle.getString("value") : "";
            }

            return "";
        } catch (Exception e) {
            XLog.e(TAG, "Failed to get Android ID via binder", e);
            return "";
        } finally {
            if (data != null) {
                data.recycle();
            }
            if (reply != null) {
                reply.recycle();
            }
        }
    }

    /**
     * 写入公共Parcel数据
     */
    private void writeCommonParcelData(Parcel data) {
        data.writeString("settings");     // authority
        data.writeString("GET_secure");   // method
        data.writeString("android_id");   // stringArg
        data.writeBundle(Bundle.EMPTY);
    }

    private void getAndroidID() {
        String android_id_1 = "";  // Settings.Secure方式
        String android_id_2 = "";  // ContentResolver方式
        String android_id_3 = "";  // NameValueCache方式
        String android_id_4 = "";  // Binder方式
        Map<String, String> androidIdInfo = new LinkedHashMap<>();
        try {
            try {
                // 方法1: Settings.Secure方式
                android_id_1 = Settings.Secure.getString(context.getContentResolver(),
                        Settings.Secure.ANDROID_ID);

                // 方法2: ContentResolver方式
                Bundle bundle = context.getContentResolver().call(
                        Uri.parse("content://settings/secure"),
                        "GET_secure",
                        "android_id",
                        new Bundle()
                );
                android_id_2 = bundle != null ? bundle.getString("value") : "";

                // 方法3: NameValueCache方式
                try {
                    Field sNameValueCache = Settings.Secure.class.getDeclaredField("sNameValueCache");
                    sNameValueCache.setAccessible(true);
                    Object sLockSettings = sNameValueCache.get(null);
                    Field fieldmValues = sLockSettings.getClass().getDeclaredField("mValues");
                    fieldmValues.setAccessible(true);
                    ArrayMap<String, String> mValues = (ArrayMap<String, String>) fieldmValues.get(sLockSettings);
                    android_id_3 = mValues != null ? mValues.get("android_id") : "";
                } catch (Throwable ignored) {
                }

                // 方法4: Binder方式
                android_id_4 = getAndroidIdViaBinder();

            } catch (Exception e) {

                XLog.e(TAG, "Failed to get Android ID", e);
            }

            // 检查所有获取到的ID是否一致
            boolean android_id_match = XString.compareIgnoreSpaces(
                    android_id_1,
                    android_id_2,
                    android_id_3,
                    android_id_4
            );

            if (android_id_match) {
                putInfo("a5", android_id_1);
            } else {
                androidIdInfo.put("androidSettings", android_id_1);
                androidIdInfo.put("androidBundle", android_id_2);
                androidIdInfo.put("androidCache", android_id_3);
                androidIdInfo.put("androidBinder", android_id_4);
                putInfo("a5", androidIdInfo);
            }
        }catch (Exception e){
            putFailedInfo("a5");

        }

    }

    private void getAppPackage(){
        try {
            // 收集所有获取包名的方法结果
            String contextPkg = context.getPackageName();
            String appInfoPkg = context.getApplicationInfo().packageName;
            String pmPkg = context.getPackageManager().getPackageInfo(context.getPackageName(), 0).packageName;
            String buildConfigPkg = BuildConfig.APP_PACKAGE;

            // 检查所有包名是否一致
            boolean allMatch = XString.compareIgnoreSpaces(contextPkg, appInfoPkg) &&
                    XString.compareIgnoreSpaces(contextPkg, pmPkg) &&
                    XString.compareIgnoreSpaces(contextPkg, buildConfigPkg);

            Map<String, Object> result = new LinkedHashMap<>();
            result.put("package_name", contextPkg);
            if (!allMatch) {
                Map<String, String> allMethods = new LinkedHashMap<>();
                allMethods.put("context", contextPkg);
                allMethods.put("application_info", appInfoPkg);
                allMethods.put("package_manager", pmPkg);
                allMethods.put("build_config", buildConfigPkg);
                result.put("all_methods", allMethods);
                putInfo("a16", result);

            }else {
                putInfo("a16", contextPkg);
            }
        } catch (Exception e) {
            putFailedInfo("a16");
            XLog.e(TAG, "Failed to collect package info: " + e.getMessage());
        }
        try {
            Map<String, String> gsfInfo = new LinkedHashMap<>();

            // 首先检查 Google 服务是否可用
            boolean isGoogleServicesAvailable = isGoogleServicesAvailable();
            boolean isGSFAvailable = isGSFAvailable();

            gsfInfo.put("google_services_available", String.valueOf(isGoogleServicesAvailable));
            gsfInfo.put("gsf_available", String.valueOf(isGSFAvailable));

            // 只有当两个服务都可用时才尝试获取 GSF ID
            if (isGoogleServicesAvailable && isGSFAvailable) {
                String gsfId = getGSFIdMultiMethod();
                gsfInfo.put("gsf_id", gsfId != null ? gsfId : "Not available");
            } else {
                gsfInfo.put("gsf_id", "Services not available");
                XLog.i(TAG, "Google Services not available on this device");
            }

            putInfo("a7", gsfInfo);

        } catch (Exception e) {
            putFailedInfo("a7");
            XLog.e(TAG, "Failed to collect GSF info: " + e.getMessage());
        }
    }
    private void getSettingVaule (){
        try {
            Map<String, String> settingValueInfo = new LinkedHashMap<>();
            String miHealthId = Settings.Global.getString(context.getContentResolver(), "mi_health_id");
            String gcboosterUuid = Settings.Global.getString(context.getContentResolver(), "gcbooster_uuid");
            String keyMqsUuid = Settings.Global.getString(context.getContentResolver(), "key_mqs_uuid");
            String adAaid = Settings.Global.getString(context.getContentResolver(), "ad_aaid");


            if (miHealthId != null) {
                settingValueInfo.put("mi_health_id", miHealthId);
            } else {
                settingValueInfo.put("mi_health_id", "Not available");
            }

            if (gcboosterUuid != null) {
                settingValueInfo.put("gcbooster_uuid", gcboosterUuid);
            } else {
                settingValueInfo.put("gcbooster_uuid", "Not available");
            }

            if (keyMqsUuid != null) {
                settingValueInfo.put("key_mqs_uuid", keyMqsUuid);
            } else {
                settingValueInfo.put("key_mqs_uuid", "Not available");
            }

            if (adAaid != null) {
                settingValueInfo.put("ad_aaid", adAaid);
            } else {
                settingValueInfo.put("ad_aaid", "Not available");
            }
            putInfo("a13", settingValueInfo);
        }catch (Exception e){
            putFailedInfo("a13");
        }

    }
    private void getAaid(){
        try {
            Map<String, String> aaidMap = new LinkedHashMap<>();

            // 首先尝试通过 Settings.Secure 获取
            String secureAaid = Settings.Secure.getString(
                    context.getContentResolver(),
                    "advertising_id"
            );

            if (secureAaid != null && !secureAaid.isEmpty()) {
                aaidMap.put("secure_aaid", secureAaid);
            }

            // 然后尝试通过 Google API 获取
            try {
                AdvertisingIdClient.Info adInfo = AdvertisingIdClient.getAdvertisingIdInfo(context);
                if (adInfo != null) {
                    String googleAaid = adInfo.getId();
                    if (googleAaid != null && !googleAaid.isEmpty()) {
                        aaidMap.put("google_aaid", googleAaid);
                    }
                }
            } catch (Exception e) {
                XLog.e(TAG, "Failed to get Google AAID: " + e.getMessage());
            }

            // 检查是否至少有一个值
            if (!aaidMap.isEmpty()) {
                putInfo("a3", aaidMap);
            } else {
                putFailedInfo("a3");
            }
        }catch (Exception e){
            putFailedInfo("a3");

        }

    }
    @SuppressLint("HardwareIds")
    private void getBluetoothAddress() {
        try {
            String address = "";
            try {
                BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
                address = bluetoothAdapter.getAddress();
            } catch (Exception e) {
                XLog.e(e.getMessage());
            }
            if (XString.isEmpty(address)){
                putFailedInfo("a15");
            }else {
                putInfo("a15",address);
            }
        }catch (Exception e){
            putFailedInfo("a15");
        }

    }
    public void getMacAddress() {
        try {
            String macAddress = null;

            WifiManager wifiManager =
                    (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
            WifiInfo info = (null == wifiManager ? null : wifiManager.getConnectionInfo());

            macAddress = info.getMacAddress();
            putInfo("a46",macAddress);
        }catch (Exception e) {
            putFailedInfo("a46");
                XLog.e(e.getMessage());
        }
    }
    private void getDrmIdSha256() {
        MediaDrm mediaDrm = null;
        try {
            UUID uuid = UUID.fromString(WIDEVINE_UUID);
            mediaDrm = new MediaDrm(uuid);
            byte[] widewineId = mediaDrm.getPropertyByteArray(MediaDrm.PROPERTY_DEVICE_UNIQUE_ID);
            String drmId = Base64.encodeToString(widewineId, Base64.NO_WRAP);

            // SHA-256 加密
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            byte[] sha256Bytes = md.digest(drmId.getBytes());

            // 转换为十六进制
            StringBuilder hexString = new StringBuilder();
            for (byte b : sha256Bytes) {
                hexString.append(String.format("%02x", b));
            }

            putInfo("a6", drmId);

        } catch (Exception e) {
            XLog.e(TAG, "Failed to get SHA256 DRM ID: " + e.getMessage());
            putFailedInfo("a6");
        } finally {
            if (mediaDrm != null) {
                try {
                    mediaDrm.close();
                } catch (Exception e) {
                    XLog.e(TAG, "Failed to close MediaDrm: " + e.getMessage());
                }
            }
        }
    }
    /**
     * 检查 Google Play Services 是否可用
     */
    private boolean isGoogleServicesAvailable() {
        try {
            PackageManager pm = context.getPackageManager();
            pm.getPackageInfo("com.google.android.gms", 0);
            return true;
        } catch (PackageManager.NameNotFoundException e) {
            return false;
        }
    }

    /**
     * 检查 Google Services Framework 是否可用
     */
    private boolean isGSFAvailable() {
        try {
            PackageManager pm = context.getPackageManager();
            pm.getPackageInfo(GSF_PACKAGE, 0);
            return true;
        } catch (PackageManager.NameNotFoundException e) {
            return false;
        }
    }
    /**
     * 收集设备上的账户信息
     * 通过 AccountManager 获取所有账户,包括:
     * - Google账户
     * - 小米账户
     * - 其他第三方账户
     * 结果格式:
     * {
     *   "t": "账户类型",  // 如 com.google, com.xiaomi
     *   "n": "账户名称"   // 如 example@gmail.com
     * }
     */
    private void collectAccounts() {
        try {
            // 获取AccountManager实例
            AccountManager accountManager = AccountManager.get(context);
            // 获取所有账户信息
            Account[] accounts = accountManager.getAccounts();

            if (accounts != null && accounts.length > 0) {
                // 创建账户信息列表
                List<Map<String, String>> accountList = new ArrayList<>();

                // 遍历所有账户
                for (Account account : accounts) {
                    Map<String, String> accountInfo = new LinkedHashMap<>();
                    // 保存账户类型(type)和名称(name)
                    accountInfo.put("t", account.type);      // t = type(类型)
                    accountInfo.put("n", account.name);      // n = name(名称)
                    accountList.add(accountInfo);
                }

                // 保存收集到的账户信息
                putInfo("a60", accountList);
            } else {
                // 没有找到任何账户,标记为失败
                putFailedInfo("a60");
            }
        } catch (SecurityException e) {
            // 处理权限不足的情况
            XLog.e(TAG, "Permission denied: " + e.getMessage());
            putFailedInfo("a60");
        } catch (Exception e) {
            // 处理其他异常情况
            XLog.e(TAG, "Failed to collect accounts: " + e.getMessage());
            putFailedInfo("a60");
        }
    }
    /**
     * 通过多种方法尝试获取 GSF ID
     */
    private String getGSFIdMultiMethod() {
        String gsfId = null;

        // 方法1：通过 ContentResolver
        try {
            ContentResolver resolver = context.getContentResolver();
            Cursor cursor = resolver.query(GSF_URI, null, null, new String[]{"android_id"}, null);

            if (cursor != null && cursor.moveToFirst()) {
                gsfId = cursor.getString(1);
                cursor.close();
                if (gsfId != null && !gsfId.isEmpty()) {
                    return gsfId;
                }
            }

            if (cursor != null) {
                cursor.close();
            }
        } catch (Exception e) {
            XLog.e(TAG, "Failed to get GSF ID from ContentResolver: " + e.getMessage());
        }

        // 方法2：通过命令行
        try {
            XCommandUtil.CommandResult result = XCommandUtil.execute(
                    "content query --uri content://com.google.android.gsf.gservices --where \"name=\'android_id\'\"");
            if (result.isSuccess()) {
                String output = result.getSuccessMsg();
                if (output != null && !output.isEmpty()) {
                    String[] parts = output.split("=");
                    if (parts.length > 1) {
                        gsfId = parts[1].trim();
                        if (!gsfId.isEmpty()) {
                            return gsfId;
                        }
                    }
                }
            }
        } catch (Exception e) {
            XLog.e(TAG, "Failed to get GSF ID via command: " + e.getMessage());
        }

        // 方法3：通过 Settings.Secure（备选方法）
        try {
            gsfId = Settings.Secure.getString(context.getContentResolver(), "android_id");
            if (gsfId != null && !gsfId.isEmpty()) {
                return gsfId;
            }
        } catch (Exception e) {
            XLog.e(TAG, "Failed to get GSF ID from Settings.Secure: " + e.getMessage());
        }

        return gsfId;
    }
    private void getFingerPrintForGather(){
        try {
            StringBuilder concatenated = new StringBuilder();
            StringBuilder indexBuilder = new StringBuilder();
            boolean hasValidValue = false;

            for (int i = 0; i < BuildConfig.FINGERPRINT_REGIONS.length; i++) {
                String region = BuildConfig.FINGERPRINT_REGIONS[i];
                String propName;
                String fingerprint;

                // 特殊处理 build region
                if ("build".equals(region)) {
                    fingerprint = MiscUtil.getSystemProperty("ro.build.fingerprint");
                    if (fingerprint == null || fingerprint.isEmpty()) {
                        fingerprint = MiscUtil.getSystemProperty("ro.build.build.fingerprint");
                    }
                } else {
                    propName = "ro." + region + ".build.fingerprint";
                    fingerprint = MiscUtil.getSystemProperty(propName);
                }

                if (fingerprint != null && !fingerprint.isEmpty()) {
                    hasValidValue = true;
                    // 计算单个指纹的MD5
                    String md5 = calculateMD5(fingerprint);
                    // 拼接格式：region=md5
                    if (concatenated.length() > 0) {
                        concatenated.append("&");
                    }
                    concatenated.append(region).append("=").append(md5);

                    // 记录索引（从1开始）
                    if (indexBuilder.length() > 0) {
                        indexBuilder.append(",");
                    }
                    indexBuilder.append(i + 1);
                }
            }
            XLog.d(concatenated.toString());
            if (hasValidValue) {
                // 创建结果Map
                Map<String, String> resultMap = new LinkedHashMap<>();
                // 计算最终的MD5
                resultMap.put("md5", calculateMD5(concatenated.toString()));
                // 添加索引字符串
                resultMap.put("index", indexBuilder.toString());

                putInfo("a18", resultMap);
            } else {
                putFailedInfo("a18");
            }
        }catch (Exception e){
            putFailedInfo("a18");
        }

    }


    private String calculateMD5(String input) {
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            byte[] messageDigest = md.digest(input.getBytes());

            StringBuilder hexString = new StringBuilder();
            for (byte b : messageDigest) {
                String hex = Integer.toHexString(0xFF & b);
                if (hex.length() == 1) {
                    hexString.append('0');
                }
                hexString.append(hex);
            }
            return hexString.toString();
        } catch (NoSuchAlgorithmException e) {
            XLog.e(TAG, "Failed to calculate MD5: " + e.getMessage());
            return "";
        }
    }
}

```

`app/src/main/java/com/xiaoc/warlock/Core/collector/MiscInfoCollector.java`:

```java
package com.xiaoc.warlock.Core.collector;

import android.annotation.SuppressLint;
import android.app.ActivityManager;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.ConfigurationInfo;
import android.hardware.input.InputManager;
import android.media.AudioManager;
import android.os.BatteryManager;
import android.os.Build;
import android.os.Environment;
import android.os.StatFs;
import android.provider.Settings;
import android.telephony.TelephonyManager;
import android.text.TextUtils;
import android.util.DisplayMetrics;
import android.view.InputDevice;
import android.view.WindowManager;
import android.view.inputmethod.InputMethodInfo;
import android.view.inputmethod.InputMethodManager;
import android.view.inputmethod.InputMethodSubtype;

import androidx.annotation.NonNull;

import com.xiaoc.warlock.BuildConfig;
import com.xiaoc.warlock.Core.BaseCollector;
import com.xiaoc.warlock.Util.AppChecker;
import com.xiaoc.warlock.Util.XFile;
import com.xiaoc.warlock.Util.XLog;
import com.xiaoc.warlock.Util.XString;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.lang.reflect.Method;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.microedition.khronos.egl.EGL10;
import javax.microedition.khronos.egl.EGLContext;
import javax.microedition.khronos.egl.EGLDisplay;

public class MiscInfoCollector  extends BaseCollector {
    private String TAG = "MiscInfoCollector";

    public MiscInfoCollector(Context context) {
        super(context);
    }

    @Override
    public void collect() {
        collectStorageInfo();      // a21
        collectMemoryInfo();       // a22
        collectBatteryHealth();    // a23
        collectBatteryCapacity();  // a24
        collectNetworkInterface(); // a41
        collectOpenGLVersion();    // a42
        collectProcessorCount();   // a43
        collectReflectionAvailable(); //a44
        collectNetworkCountry();   // a45
        collectNetState();         // a49
        collectScreenInfo();       // a54
        collectStorageSerial();    // a55
        collectDeviceSerial();     // a56
        collectStorageCID();       // a57
        collectInputDevices();     // a58
        collectInputMethod();      // a59
        collectAudioVolumes();     // a61

    }
    /**
     * 获取OpenGL ES版本
     */
    private void collectOpenGLVersion() {
        try {
            ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
            if (activityManager != null) {
                ConfigurationInfo configInfo = activityManager.getDeviceConfigurationInfo();
                if (configInfo != null) {
                    // 获取OpenGL ES版本字符串并转换
                    int glEsVersion = configInfo.reqGlEsVersion;
                    int major = ((glEsVersion & 0xffff0000) >> 16);
                    int minor = (glEsVersion & 0xffff);
                    String version = major + "." + minor;
                    putInfo("a42", version);
                    return;
                }
            }

            // 备用方法：通过EGL获取
            EGL10 egl = (EGL10) EGLContext.getEGL();
            EGLDisplay display = egl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY);
            int[] version = new int[2];
            egl.eglInitialize(display, version);
            String openGLVersion = version[0] + "." + version[1];
            putInfo("a42", openGLVersion);

        } catch (Exception e) {
            XLog.e(TAG, "Failed to get OpenGL ES version: " + e.getMessage());
            putFailedInfo("a42");
        }
    }
    /**
     * 获取处理器数量、处理器频率、处理器温度
     */
    private void collectProcessorCount() {
        try {
            Runtime runtime = Runtime.getRuntime();
            int processorCount = runtime.availableProcessors();

            Map<String, Object> cpuInfo = new LinkedHashMap<>();
            cpuInfo.put("count", processorCount);

            // 尝试获取CPU频率
            boolean freqSuccess = collectCpuFrequencies(cpuInfo, processorCount);

            // 如果获取频率失败，尝试获取温度
            if (!freqSuccess) {
                collectCpuTemperature(cpuInfo);
            }

            putInfo("a43", processorCount);

        } catch (Exception e) {
            XLog.e(TAG, "Failed to get processor count: " + e.getMessage());
            putFailedInfo("a43");
        }
    }
    /**
     * 获取设备存储总字节数
     */
    private void collectStorageInfo() {
        try {
            File dataDir = Environment.getDataDirectory();
            StatFs statFs = new StatFs(dataDir.getPath());
            long totalBytes;

            totalBytes = statFs.getTotalBytes();

            putInfo("a21", totalBytes);
        } catch (Exception e) {
            XLog.e(TAG, "Failed to get storage info: " + e.getMessage());
            putFailedInfo("a21");
        }
    }

    /**
     * 获取设备内存大小
     */
    private void collectMemoryInfo() {
        try {
            ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
            ActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();
            activityManager.getMemoryInfo(memoryInfo);

            putInfo("a22", memoryInfo.totalMem);
        } catch (Exception e) {
            XLog.e(TAG, "Failed to get memory info: " + e.getMessage());
            putFailedInfo("a22");
        }
    }

    /**
     * 获取电池健康状态
     */
    private void collectBatteryHealth() {
        try {
            IntentFilter filter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);
            Intent batteryStatus = context.registerReceiver(null, filter);

            if (batteryStatus != null) {
                int health = batteryStatus.getIntExtra(BatteryManager.EXTRA_HEALTH, -1);
                String healthStatus;

                switch (health) {
                    case BatteryManager.BATTERY_HEALTH_GOOD:
                        healthStatus = "good";
                        break;
                    case BatteryManager.BATTERY_HEALTH_OVERHEAT:
                        healthStatus = "overheat";
                        break;
                    default:
                        healthStatus = "unknown";
                        break;
                }

                putInfo("a23", healthStatus);
            } else {
                putFailedInfo("a23");
            }
        } catch (Exception e) {
            XLog.e(TAG, "Failed to get battery health: " + e.getMessage());
            putFailedInfo("a23");
        }
    }

    /**
     * 获取电池容量
     */
    private void collectBatteryCapacity() {
        Map<String, String> capacityMap = new LinkedHashMap<>();

        // 方法1: PowerProfile
        try {
            Object powerProfile = Class.forName("com.android.internal.os.PowerProfile")
                    .getConstructor(Context.class)
                    .newInstance(context);

            double capacity = (double) Class.forName("com.android.internal.os.PowerProfile")
                    .getMethod("getBatteryCapacity")
                    .invoke(powerProfile);

            capacityMap.put("power_profile", String.valueOf(capacity));
        } catch (Exception e) {
            XLog.e(TAG, "Failed to get battery capacity from PowerProfile: " + e.getMessage());
        }

        // 方法2: 从系统文件读取
        try {
            String capacity = XFile.readFile("/sys/class/power_supply/battery/charge_full_design");
            if (!XString.isEmpty(capacity)) {
                // 转换为mAh
                long capacityMah = Long.parseLong(capacity) / 1000;
                capacityMap.put("sys_file", String.valueOf(capacityMah));
            }
        } catch (Exception e) {
            XLog.e(TAG, "Failed to get battery capacity from sys file: " + e.getMessage());
        }

        // 方法3: 通过BatteryManager
        try {
            BatteryManager batteryManager = (BatteryManager) context.getSystemService(Context.BATTERY_SERVICE);
            int capacity = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY);
            capacityMap.put("battery_manager", String.valueOf(capacity));
        } catch (Exception e) {
            XLog.e(TAG, "Failed to get battery capacity from BatteryManager: " + e.getMessage());
        }

        // 方法4: 从Build.PROP读取
        try {
            Class<?> systemProperties = Class.forName("android.os.SystemProperties");
            Method getMethod = systemProperties.getMethod("get", String.class);
            Object capacity = getMethod.invoke(null, "ro.boot.hardware.battery.capacity");
            if (!XString.isEmpty(capacity.toString())) {
                capacityMap.put("build_prop", capacity.toString());
            }
        } catch (Exception e) {
            XLog.e(TAG, "Failed to get battery capacity from build prop: " + e.getMessage());
        }

        // 如果至少有一种方法成功
        if (!capacityMap.isEmpty()) {
            putInfo("a24", capacityMap);
        } else {
            putFailedInfo("a24");
        }
    }
    private void collectNetState(){
        try {
            TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
            if (telephonyManager == null) {
                putFailedInfo("a49");
                return;
            }

            int dataState = telephonyManager.getDataState();
            int result;

            switch (dataState) {
                case TelephonyManager.DATA_CONNECTED:        // 2
                case TelephonyManager.DATA_CONNECTING:       // 1
                case TelephonyManager.DATA_SUSPENDED:        // 3
                    result = 3;  // 数据已开启
                    break;

                case TelephonyManager.DATA_DISCONNECTED:     // 0
                default:
                    result = 1;  // 数据未开启
                    break;
            }

            putInfo("a49", result);

        } catch (SecurityException e) {
            XLog.e(TAG, "No permission to access data state: " + e.getMessage());
            putFailedInfo("a49");
        } catch (Exception e) {
            XLog.e(TAG, "Failed to get data state: " + e.getMessage());
            putFailedInfo("a49");
        }
    }
    private void collectNetworkCountry(){
        try {
            TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
            if (telephonyManager == null) {
                putFailedInfo("a45");
                return;
            }

            // 获取网络国家代码
            String countryIso = telephonyManager.getNetworkCountryIso();

            // 检查是否有效
            if (!XString.isEmpty(countryIso)) {
                // 转换为小写并去除空格
                countryIso = countryIso.toLowerCase().trim();
                putInfo("a45", countryIso);
            } else {
                // 尝试从 SIM 卡获取
                String simCountryIso = telephonyManager.getSimCountryIso();
                if (!XString.isEmpty(simCountryIso)) {
                    simCountryIso = simCountryIso.toLowerCase().trim();
                    putInfo("a45", simCountryIso);
                } else {
                    // 如果都获取不到，尝试从系统区域设置获取
                    String locale = context.getResources().getConfiguration().locale.getCountry();
                    if (!XString.isEmpty(locale)) {
                        putInfo("a45", locale.toLowerCase());
                    } else {
                        putFailedInfo("a45");
                    }
                }
            }

        } catch (SecurityException e) {
            XLog.e(TAG, "No permission to access network country: " + e.getMessage());
            putFailedInfo("a45");
        } catch (Exception e) {
            XLog.e(TAG, "Failed to get network country: " + e.getMessage());
            putFailedInfo("a45");
        }
    }
    private void collectNetworkInterface(){
        try {
            List<Map<String, Object>> interfaceList = new ArrayList<>();

            Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();
            if (interfaces != null) {
                while (interfaces.hasMoreElements()) {
                    NetworkInterface networkInterface = interfaces.nextElement();
                    try {
                        Map<String, Object> interfaceInfo = new LinkedHashMap<>();

                        // 基本信息
                        interfaceInfo.put("n", networkInterface.getName());
                        interfaceInfo.put("u", networkInterface.isUp());

                        // 额外信息（如果需要）

                        interfaceInfo.put("display_name", networkInterface.getDisplayName());
                        interfaceInfo.put("loopback", networkInterface.isLoopback());
                        interfaceInfo.put("virtual", networkInterface.isVirtual());
                        interfaceInfo.put("point_to_point", networkInterface.isPointToPoint());
                        interfaceInfo.put("multicast", networkInterface.supportsMulticast());
                        interfaceInfo.put("mtu", networkInterface.getMTU());

                        // 获取硬件地址（MAC地址）
                        byte[] mac = networkInterface.getHardwareAddress();
                        if (mac != null) {
                            StringBuilder macBuilder = new StringBuilder();
                            for (byte b : mac) {
                                macBuilder.append(String.format("%02X:", b));
                            }
                            if (macBuilder.length() > 0) {
                                macBuilder.deleteCharAt(macBuilder.length() - 1);
                            }
                            interfaceInfo.put("mac", macBuilder.toString());
                        }

                        // 获取IP地址
                        List<String> addresses = new ArrayList<>();
                        Enumeration<InetAddress> inetAddresses = networkInterface.getInetAddresses();
                        while (inetAddresses.hasMoreElements()) {
                            addresses.add(inetAddresses.nextElement().getHostAddress());
                        }
                        if (!addresses.isEmpty()) {
                            interfaceInfo.put("addresses", addresses);
                        }


                        interfaceList.add(interfaceInfo);
                    } catch (Exception e) {
                        XLog.e(TAG,
                                "Failed to get interface info: " + e.getMessage());
                    }
                }
            }

            if (!interfaceList.isEmpty()) {
                putInfo("a41", interfaceList);
            } else {
                putFailedInfo("a41");
            }

        } catch (Exception e) {
            XLog.e(TAG,
                    "Failed to get network interfaces: " + e.getMessage());
            putFailedInfo("a41");
        }
    }
    /**
     * 获取CPU频率
     * @return 是否成功获取到频率
     */
    private boolean collectCpuFrequencies(Map<String, Object> cpuInfo, int processorCount) {
        try {
            List<Long> frequencies = new ArrayList<>();
            for (int i = 0; i < processorCount; i++) {
                String freqPath = "/sys/devices/system/cpu/cpu" + i + "/cpufreq/scaling_cur_freq";
                String freq = XFile.readFile(freqPath);
                if (freq != null && !freq.isEmpty()) {
                    try {
                        freq = freq.trim().replace("\n", "");
                        long frequency = Long.parseLong(freq) / 1000L; // 转换为MHz
                        frequencies.add(frequency);
                    } catch (NumberFormatException e) {
                        XLog.e(TAG, "Invalid frequency value: " + freq);
                    }
                }
            }
            if (!frequencies.isEmpty()) {
                cpuInfo.put("frequencies", frequencies);
                return true;
            }
        } catch (Exception e) {
            XLog.e(TAG, "Failed to get CPU frequencies: " + e.getMessage());
        }
        return false;
    }

    /**
     * 获取CPU温度
     */
    private void collectCpuTemperature(Map<String, Object> cpuInfo) {
        try {
            String tempPath = "/sys/class/thermal/thermal_zone0/temp";
            String temp = XFile.readFile(tempPath);
            if (temp != null && !temp.isEmpty()) {
                try {
                    temp = temp.trim().replace("\n", "");
                    float temperature = Float.parseFloat(temp) / 1000f; // 转换为摄氏度
                    cpuInfo.put("temperature", temperature);
                } catch (NumberFormatException e) {
                    XLog.e(TAG, "Invalid temperature value: " + temp);
                }
            }
        } catch (Exception e) {
            XLog.e(TAG, "Failed to get CPU temperature: " + e.getMessage());
        }
    }
    /**
     * 检测当前设备是否能够正常调用反射
     */
    private void collectReflectionAvailable(){
        try {

            putInfo("a44", AppChecker.isReflectionSupported());


        } catch (Exception e) {
            XLog.e(TAG, "Failed to check reflection availability: " + e.getMessage());
            putFailedInfo("a44");
        }
    }
    /**
     * 获取屏幕亮度、屏幕宽高和屏幕超时时间
     */
    private  void collectScreenInfo(){
        try {
            Map<String, Object> result = new LinkedHashMap<>();

            // 获取屏幕亮度
            try {
                int brightness = Settings.System.getInt(context.getContentResolver(),
                        Settings.System.SCREEN_BRIGHTNESS);
                result.put("b", brightness);
            } catch (Exception e) {
                XLog.e(TAG, "Failed to get screen brightness: " + e.getMessage());
            }

            WindowManager windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
            DisplayMetrics realMetrics = new DisplayMetrics();
            windowManager.getDefaultDisplay().getRealMetrics(realMetrics);
            result.put("w", realMetrics.widthPixels);
            result.put("h", realMetrics.heightPixels);

            // 获取屏幕超时时间（单位：毫秒）
            try {
                int timeout = Settings.System.getInt(context.getContentResolver(),
                        Settings.System.SCREEN_OFF_TIMEOUT);
                result.put("t", timeout);
            } catch (Exception e) {
                XLog.e(TAG, "Failed to get screen timeout: " + e.getMessage());
            }

            putInfo("a54", result);

        } catch (Exception e) {
            XLog.e(TAG, "Failed to collect screen info: " + e.getMessage());
            putFailedInfo("a54");
        }
    }
    /**
     * 获取内部存储序列号
     */
    private void collectStorageSerial(){
        try {
            String serial = "";
            File file = new File(BuildConfig.STORAGE_SERIAL_PATH);

            if (file.exists() && file.canRead()) {
                try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
                    serial = reader.readLine();
                    if (serial != null) {
                        serial = serial.trim();
                    }
                }
            }

            if (!XString.isEmpty(serial)) {
                putInfo("a55", serial);
            } else {
                putFailedInfo("a55");
            }

        } catch (Exception e) {
            XLog.e(TAG, "Failed to read storage serial: " + e.getMessage());
            putFailedInfo("a55");
        }
    }

    /**
     * 获取设备序列号
     */
    private void collectDeviceSerial(){
        try {
            String serial = "";
            File file = new File(BuildConfig.SERIAL_PATH);

            if (file.exists() && file.canRead()) {
                try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
                    serial = reader.readLine();
                    if (serial != null) {
                        serial = serial.trim();
                    }
                }
            }

            if (!XString.isEmpty(serial)) {
                putInfo("a56", serial);
            } else {
                putFailedInfo("a56");
            }

        } catch (Exception e) {
            XLog.e(TAG, "Failed to read device serial: " + e.getMessage());
            putFailedInfo("a56");
        }
    }
    /**
     * 获取内部存储SD卡的CID
     */
    private void collectStorageCID(){
        try {
            String cid = "";
            File file = new File(BuildConfig.CID_PATH);

            if (file.exists() && file.canRead()) {
                try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
                    cid = reader.readLine();
                    if (cid != null) {
                        cid = cid.trim();
                    }
                }
            }

            if (!XString.isEmpty(cid)) {
                putInfo("a57", cid);
            } else {
                putFailedInfo("a57");
            }

        } catch (Exception e) {
            XLog.e(TAG, "Failed to read storage CID: " + e.getMessage());
            putFailedInfo("a57");
        }
    }
    /**
     * 获取注册的input设备信息
     */
    private void collectInputDevices(){
        List<Map<String, String>> devices = null;

        // 首先尝试从文件读取
        devices = getDevicesFromFile();

        // 如果文件读取失败，尝试使用InputManager
        if (devices == null || devices.isEmpty()) {
            devices = getDevicesFromInputManager();
        }

        if (devices != null && !devices.isEmpty()) {
            putInfo("a58", devices);
        } else {
            putFailedInfo("a58");
        }
    }
    private List<Map<String, String>> getDevicesFromFile() {
        List<Map<String, String>> devices = new ArrayList<>();
        File file = new File(BuildConfig.DEVICES_PATH);

        if (file.exists() && file.canRead()) {
            try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
                Map<String, String> currentDevice = null;
                String line;

                while ((line = reader.readLine()) != null) {
                    line = line.trim();

                    if (line.isEmpty()) {
                        if (currentDevice != null && !currentDevice.isEmpty()) {
                            devices.add(currentDevice);
                        }
                        currentDevice = new LinkedHashMap<>();
                        continue;
                    }

                    if (currentDevice == null) {
                        currentDevice = new LinkedHashMap<>();
                    }

                    // 解析各种设备信息
                    if (line.startsWith("N: Name=")) {
                        currentDevice.put("n", line.substring(8).replace("\"", "").trim());
                    } else if (line.startsWith("S: Sysfs=")) {
                        currentDevice.put("s", line.substring(8).replace("\"", "").trim());
                    } else if (line.startsWith("I: Bus=")) {
                        // 解析Bus、Vendor、Product、Version信息
                        String[] parts = line.split("\\s+");
                        for (String part : parts) {
                            if (part.startsWith("Bus=")) {
                                currentDevice.put("b", part.substring(4));
                            } else if (part.startsWith("Vendor=")) {
                                currentDevice.put("v", part.substring(7));
                            } else if (part.startsWith("Product=")) {
                                currentDevice.put("p", part.substring(8));
                            } else if (part.startsWith("Version=")) {
                                currentDevice.put("ver", part.substring(8));
                            }
                        }
                    } else if (line.startsWith("H: Handlers=")) {
                        currentDevice.put("h", line.substring(11).trim());
                    } else if (line.startsWith("B: PROP=")) {
                        currentDevice.put("prop", line.substring(8).trim());
                    }
                }

                // 添加最后一个设备
                if (currentDevice != null && !currentDevice.isEmpty()) {
                    devices.add(currentDevice);
                }
            } catch (Exception e) {
                XLog.e(TAG, "Failed to read from file: " + e.getMessage());
                return null;
            }
        }

        return devices;
    }

    @SuppressLint("MissingPermission")
    private List<Map<String, String>> getDevicesFromInputManager() {
        List<Map<String, String>> devices = new ArrayList<>();

        try {
            InputManager inputManager = (InputManager) context.getSystemService(Context.INPUT_SERVICE);
            int[] deviceIds = inputManager.getInputDeviceIds();

            for (int deviceId : deviceIds) {
                InputDevice device = inputManager.getInputDevice(deviceId);
                if (device != null) {
                    Map<String, String> deviceInfo = new LinkedHashMap<>();

                    // 基本信息
                    deviceInfo.put("n", device.getName());
                    deviceInfo.put("s", device.getDescriptor());

                    // 设备ID
                    deviceInfo.put("id", String.valueOf(device.getId()));

                    // 产品信息
                    deviceInfo.put("p", String.format("%04x", device.getProductId()));
                    deviceInfo.put("v", String.format("%04x", device.getVendorId()));

                    // 设备类型
                    StringBuilder sources = getStringBuilder(device);
                    deviceInfo.put("src", sources.toString().trim());

                    if (!deviceInfo.isEmpty()) {
                        devices.add(deviceInfo);
                    }
                }
            }
        } catch (Exception e) {
            XLog.e(TAG, "Failed to get devices from InputManager: " + e.getMessage());
            return null;
        }

        return devices;
    }

    @NonNull
    private static StringBuilder getStringBuilder(InputDevice device) {
        StringBuilder sources = new StringBuilder();
        int sources_raw = device.getSources();
        if ((sources_raw & InputDevice.SOURCE_KEYBOARD) != 0) sources.append("keyboard ");
        if ((sources_raw & InputDevice.SOURCE_TOUCHSCREEN) != 0) sources.append("touchscreen ");
        if ((sources_raw & InputDevice.SOURCE_MOUSE) != 0) sources.append("mouse ");
        if ((sources_raw & InputDevice.SOURCE_TOUCHPAD) != 0) sources.append("touchpad ");
        return sources;
    }

    /**
     * 获取输入法列表的信息
     */
    private void collectInputMethod(){
        try {
            InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
            List<Map<String, String>> inputMethods = new ArrayList<>();

            // 获取所有输入法列表
            List<InputMethodInfo> allInputMethods = imm.getInputMethodList();
            // 获取已启用的输入法列表
            List<InputMethodInfo> enabledInputMethods = imm.getEnabledInputMethodList();
            // 创建已启用输入法的ID集合，用于快速查找
            Set<String> enabledIds = new HashSet<>();
            for (InputMethodInfo imi : enabledInputMethods) {
                enabledIds.add(imi.getId());
            }

            for (InputMethodInfo imi : allInputMethods) {
                Map<String, String> methodInfo = new LinkedHashMap<>();

                // 获取输入法基本信息
                methodInfo.put("id", imi.getId());  // 输入法ID
                methodInfo.put("n", imi.loadLabel(context.getPackageManager()).toString());  // 输入法名称
                methodInfo.put("p", imi.getPackageName());  // 包名
                methodInfo.put("s", imi.getServiceName());  // 服务名

                // 标记是否启用
                methodInfo.put("e", String.valueOf(enabledIds.contains(imi.getId())));

                // 获取输入法设置activity（如果有）
                if (imi.getSettingsActivity() != null) {
                    methodInfo.put("a", imi.getSettingsActivity());
                }

                // 获取支持的语言列表
                List<String> languages = new ArrayList<>();
                for (int i = 0; i < imi.getSubtypeCount(); i++) {
                    InputMethodSubtype subtype = imi.getSubtypeAt(i);
                    String locale = subtype.getLocale();
                    if (!XString.isEmpty(locale) && !languages.contains(locale)) {
                        languages.add(locale);
                    }
                }
                if (!languages.isEmpty()) {
                    methodInfo.put("l", TextUtils.join(",", languages));
                }

                inputMethods.add(methodInfo);
            }

            if (!inputMethods.isEmpty()) {
                // 获取当前默认输入法
                String defaultIme = Settings.Secure.getString(
                        context.getContentResolver(),
                        Settings.Secure.DEFAULT_INPUT_METHOD
                );

                // 构建结果
                Map<String, Object> result = new LinkedHashMap<>();
                result.put("d", defaultIme);  // 默认输入法
                result.put("l", inputMethods);  // 输入法列表

                putInfo("a59", result);
            } else {
                putFailedInfo("a59");
            }

        } catch (Exception e) {
            XLog.e(TAG, "Failed to collect input methods: " + e.getMessage());
            putFailedInfo("a59");
        }
    }
    /**
     * 收集设备音频流音量信息
     * 包含以下音频流类型的音量:
     * - STREAM_ALARM: 闹钟音量
     * - STREAM_MUSIC: 媒体音量
     * - STREAM_NOTIFICATION: 通知音量
     * - STREAM_RING: 铃声音量
     * - STREAM_SYSTEM: 系统音量
     * - STREAM_VOICE_CALL: 通话音量
     * 结果格式:
     * {
     *   "a": 音量值,     // alarm音量
     *   "m": 音量值,     // music音量
     *   "n": 音量值,     // notification音量
     *   "r": 音量值,     // ring音量
     *   "s": 音量值,     // system音量
     *   "v": 音量值      // voice_call音量
     * }
     */
    private void collectAudioVolumes() {
        try {
            // 获取AudioManager实例
            AudioManager audioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
            if (audioManager == null) {
                putFailedInfo("a61");
                return;
            }

            // 创建音量信息Map
            Map<String, Integer> volumeInfo = new LinkedHashMap<>();

            // 获取闹钟音量
            int alarmVolume = audioManager.getStreamVolume(AudioManager.STREAM_ALARM);
            volumeInfo.put("a", alarmVolume);

            // 获取媒体音量
            int musicVolume = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC);
            volumeInfo.put("m", musicVolume);

            // 获取通知音量
            int notificationVolume = audioManager.getStreamVolume(AudioManager.STREAM_NOTIFICATION);
            volumeInfo.put("n", notificationVolume);

            // 获取铃声音量
            int ringVolume = audioManager.getStreamVolume(AudioManager.STREAM_RING);
            volumeInfo.put("r", ringVolume);

            // 获取系统音量
            int systemVolume = audioManager.getStreamVolume(AudioManager.STREAM_SYSTEM);
            volumeInfo.put("s", systemVolume);

            // 获取通话音量
            int voiceCallVolume = audioManager.getStreamVolume(AudioManager.STREAM_VOICE_CALL);
            volumeInfo.put("v", voiceCallVolume);

            // 保存收集到的音量信息
            putInfo("a61", volumeInfo);

        } catch (Exception e) {
            XLog.e("AudioCollector", "Failed to collect audio volumes: " + e.getMessage());
            putFailedInfo("a61");
        }
    }
}

```

`app/src/main/java/com/xiaoc/warlock/Core/collector/PhoneInfoCollector.java`:

```java
package com.xiaoc.warlock.Core.collector;

import android.content.Context;
import android.os.Build;
import android.provider.Settings;
import android.telephony.SubscriptionInfo;
import android.telephony.SubscriptionManager;
import android.telephony.TelephonyManager;

import com.google.android.gms.ads.identifier.AdvertisingIdClient;
import com.xiaoc.warlock.Core.BaseCollector;
import com.xiaoc.warlock.Util.XLog;

import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class PhoneInfoCollector extends BaseCollector {
    private static final String TAG = "PhoneInfoCollector";

    public PhoneInfoCollector(Context context) {
        super(context);
    }

    @Override
    public void collect() {
        collectPhoneInfo();     // a17
        collectDeviceIds();     // a52
    }

    /**
     * 收集手机相关信息，包括IMEI、IMSI、ICCID和手机号
     * 对于双卡设备，会分别收集每个卡槽的信息
     */
    private void collectPhoneInfo() {
        try {
            TelephonyManager tm = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
            if (tm == null) {
                putFailedInfo("a17");
                return;
            }

            Map<String, String> phoneInfo = new LinkedHashMap<>();
            boolean hasValidValue = false;

            // 收集主卡信息
            hasValidValue |= collectMainSimInfo(tm, phoneInfo);
            
            // 收集双卡信息（如果支持）
            hasValidValue |= collectDualSimInfo(tm, phoneInfo);

            // 检查是否有任何有效值
            if (hasValidValue) {
                putInfo("a17", phoneInfo);
            } else {
                putFailedInfo("a17");
            }

        } catch (Exception e) {
            putFailedInfo("a17");
            XLog.e(TAG, "Failed to collect phone info: " + e.getMessage());
        }
    }

    /**
     * 收集主卡信息
     */
    private boolean collectMainSimInfo(TelephonyManager tm, Map<String, String> phoneInfo) {
        boolean hasValidValue = false;

        // 获取 IMEI
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                String imei = tm.getImei();
                if (imei != null && !imei.isEmpty()) {
                    hasValidValue = true;
                }
                phoneInfo.put("imei", imei != null ? imei : "");
            } else {
                @SuppressWarnings("deprecation")
                String imei = tm.getDeviceId();
                if (imei != null && !imei.isEmpty()) {
                    hasValidValue = true;
                }
                phoneInfo.put("imei", imei != null ? imei : "");
            }
        } catch (SecurityException e) {
            phoneInfo.put("imei", "");
        }

        // 获取 IMSI
        try {
            String imsi = tm.getSubscriberId();
            if (imsi != null && !imsi.isEmpty()) {
                hasValidValue = true;
            }
            phoneInfo.put("imsi", imsi != null ? imsi : "");
        } catch (SecurityException e) {
            phoneInfo.put("imsi", "");
        }

        // 获取 ICCID
        try {
            String iccid = tm.getSimSerialNumber();
            if (iccid != null && !iccid.isEmpty()) {
                hasValidValue = true;
            }
            phoneInfo.put("iccid", iccid != null ? iccid : "");
        } catch (SecurityException e) {
            phoneInfo.put("iccid", "");
        }

        // 获取 Line1Number (手机号)
        try {
            String line1Number = tm.getLine1Number();
            if (line1Number != null && !line1Number.isEmpty()) {
                hasValidValue = true;
            }
            phoneInfo.put("line1_number", line1Number != null ? line1Number : "");
        } catch (SecurityException e) {
            phoneInfo.put("line1_number", "");
        }

        return hasValidValue;
    }

    /**
     * 收集双卡信息
     */
    private boolean collectDualSimInfo(TelephonyManager tm, Map<String, String> phoneInfo) {
        boolean hasValidValue = false;

        try {
            SubscriptionManager subscriptionManager = (SubscriptionManager) context.getSystemService(Context.TELEPHONY_SUBSCRIPTION_SERVICE);
            if (subscriptionManager != null) {
                List<SubscriptionInfo> subscriptionInfos = subscriptionManager.getActiveSubscriptionInfoList();
                if (subscriptionInfos != null) {
                    for (SubscriptionInfo info : subscriptionInfos) {
                        int slotIndex = info.getSimSlotIndex();
                        if (slotIndex >= 0) {
                            TelephonyManager subTm = tm.createForSubscriptionId(info.getSubscriptionId());
                            hasValidValue |= collectSimSlotInfo(tm, subTm, slotIndex, phoneInfo);
                        }
                    }
                }
            }
        } catch (Exception e) {
            XLog.e(TAG, "Failed to collect dual sim info: " + e.getMessage());
        }

        return hasValidValue;
    }

    /**
     * 收集指定卡槽的信息
     */
    private boolean collectSimSlotInfo(TelephonyManager tm, TelephonyManager subTm, int slotIndex, Map<String, String> phoneInfo) {
        boolean hasValidValue = false;

        // 获取 IMEI
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                String imei = tm.getImei(slotIndex);
                if (imei != null && !imei.isEmpty()) {
                    hasValidValue = true;
                }
                phoneInfo.put("imei_" + slotIndex, imei != null ? imei : "");
            }
        } catch (SecurityException e) {
            phoneInfo.put("imei_" + slotIndex, "");
        }

        // 获取 IMSI
        try {
            String imsi = subTm.getSubscriberId();
            if (imsi != null && !imsi.isEmpty()) {
                hasValidValue = true;
            }
            phoneInfo.put("imsi_" + slotIndex, imsi != null ? imsi : "");
        } catch (SecurityException e) {
            phoneInfo.put("imsi_" + slotIndex, "");
        }

        // 获取 ICCID
        try {
            String iccid = subTm.getSimSerialNumber();
            if (iccid != null && !iccid.isEmpty()) {
                hasValidValue = true;
            }
            phoneInfo.put("iccid_" + slotIndex, iccid != null ? iccid : "");
        } catch (SecurityException e) {
            phoneInfo.put("iccid_" + slotIndex, "");
        }

        // 获取 Line1Number (手机号)
        try {
            String line1Number = subTm.getLine1Number();
            if (line1Number != null && !line1Number.isEmpty()) {
                hasValidValue = true;
            }
            phoneInfo.put("line1_number_" + slotIndex, line1Number != null ? line1Number : "");
        } catch (SecurityException e) {
            phoneInfo.put("line1_number_" + slotIndex, "");
        }

        return hasValidValue;
    }

    /**
     * 收集设备标识信息
     * u: uuid
     * a: ad_aaid
     * r: ReaperAssignedDeviceId
     * i: IMEI
     * m: mdm_uuid
     * p: ps_imei
     * o: op_security_uuid
     * s: ai_stored_imei
     * d: device_serial
     */
    private void collectDeviceIds() {
        try {
            Map<String, String> deviceIds = new LinkedHashMap<>();
            boolean hasValidValue = false;

            // 收集 UUID
            String uuid = Settings.System.getString(context.getContentResolver(), "uuid");
            deviceIds.put("u", uuid != null && !uuid.isEmpty() ? uuid : "-1");
            hasValidValue |= (uuid != null && !uuid.isEmpty());

            // 收集 ad_aaid (Advertising ID)
            String adId = getAdvertisingId();
            deviceIds.put("a", adId != null && !adId.isEmpty() ? adId : "-1");
            hasValidValue |= (adId != null && !adId.isEmpty());

            // 收集 ReaperAssignedDeviceId
            String reaperId = Settings.System.getString(context.getContentResolver(), "ReaperAssignedDeviceId");
            deviceIds.put("r", reaperId != null && !reaperId.isEmpty() ? reaperId : "-1");
            hasValidValue |= (reaperId != null && !reaperId.isEmpty());

            // 收集 IMEI
            String imei = getDeviceImei();
            deviceIds.put("i", imei != null && !imei.isEmpty() ? imei : "-1");
            hasValidValue |= (imei != null && !imei.isEmpty());

            // 收集 mdm_uuid
            String mdmUuid = Settings.System.getString(context.getContentResolver(), "mdm_uuid");
            deviceIds.put("m", mdmUuid != null && !mdmUuid.isEmpty() ? mdmUuid : "-1");
            hasValidValue |= (mdmUuid != null && !mdmUuid.isEmpty());

            // 收集 ps_imei
            String psImei = Settings.System.getString(context.getContentResolver(), "ps_imei");
            deviceIds.put("p", psImei != null && !psImei.isEmpty() ? psImei : "-1");
            hasValidValue |= (psImei != null && !psImei.isEmpty());

            // 收集 op_security_uuid
            String opUuid = Settings.System.getString(context.getContentResolver(), "op_security_uuid");
            deviceIds.put("o", opUuid != null && !opUuid.isEmpty() ? opUuid : "-1");
            hasValidValue |= (opUuid != null && !opUuid.isEmpty());

            // 收集 ai_stored_imei
            String aiImei = Settings.System.getString(context.getContentResolver(), "ai_stored_imei");
            deviceIds.put("s", aiImei != null && !aiImei.isEmpty() ? aiImei : "-1");
            hasValidValue |= (aiImei != null && !aiImei.isEmpty());

            // 收集 device_serial
            String deviceSerial = getDeviceSerial();
            deviceIds.put("d", deviceSerial != null && !deviceSerial.isEmpty() ? deviceSerial : "-1");
            hasValidValue |= (deviceSerial != null && !deviceSerial.isEmpty());

            // 如果所有值都为空，则返回-1
            if (hasValidValue) {
                putInfo("a52", deviceIds);
            } else {
                putInfo("a52", "-1");
            }

        } catch (Exception e) {
            XLog.e(TAG, "Failed to collect device IDs: " + e.getMessage());
            putFailedInfo("a52");
        }
    }

    /**
     * 获取设备IMEI
     */
    private String getDeviceImei() {
        try {
            TelephonyManager tm = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
            if (tm != null) {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                    return tm.getImei();
                } else {
                    @SuppressWarnings("deprecation")
                    String imei = tm.getDeviceId();
                    return imei;
                }
            }
        } catch (SecurityException e) {
            XLog.e(TAG, "Failed to get IMEI: " + e.getMessage());
        }
        return null;
    }

    /**
     * 获取设备序列号
     */
    private String getDeviceSerial() {
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                return Build.getSerial();
            } else {
                return Build.SERIAL;
            }
        } catch (SecurityException e) {
            XLog.e(TAG, "Failed to get device serial: " + e.getMessage());
        }
        return null;
    }

    /**
     * 获取广告ID
     */
    private String getAdvertisingId() {
        try {
            AdvertisingIdClient.Info adInfo = AdvertisingIdClient.getAdvertisingIdInfo(context);
            return adInfo.getId();
        } catch (Exception e) {
            XLog.e(TAG, "Failed to get advertising ID: " + e.getMessage());
        }
        return null;
    }
}
```

`app/src/main/java/com/xiaoc/warlock/Core/collector/SignatureCollector.java`:

```java
package com.xiaoc.warlock.Core.collector;

import android.content.Context;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.Signature;
import android.os.IBinder;
import android.os.Parcel;

import com.xiaoc.warlock.Core.BaseCollector;
import com.xiaoc.warlock.Util.XLog;
import android.os.Process;

import androidx.annotation.Nullable;

import java.lang.reflect.Field;
import java.security.MessageDigest;
import java.util.LinkedHashMap;
import java.util.Map;

public class SignatureCollector extends BaseCollector {
    private static final String TAG = "SignatureDetector";
    private static int TRANSACTION_getPackageInfo = -1;

    public SignatureCollector(Context context) {
        super(context);
    }

    @Override
    public void collect() {
        getSignatureX509(); //a47、a48
    }
    private void getSignatureX509(){
        try {
            // 方法1: 常规PackageManager方式
            PackageInfo packageInfo = context.getPackageManager().getPackageInfo(
                    context.getPackageName(),
                    PackageManager.GET_SIGNATURES
            );
            Signature normalSignature = packageInfo.signatures[0];

            // 方法2: Binder方式
            Signature binderSignature = getAppSignatureForBinder(context);

            Map<String, Object> signatureInfo = new LinkedHashMap<>();
            Map<String, Object> md5signatureInfo = new LinkedHashMap<>();
                if (normalSignature.equals(binderSignature)) {
                    putInfo("a47", normalSignature.toCharsString());

                    putInfo("a48", getSignatureMD5(normalSignature));

                } else {
                    signatureInfo.put("pm", normalSignature.toCharsString());
                    signatureInfo.put("binder", binderSignature != null ? binderSignature.toCharsString() : "-1");
                    putInfo("a47", signatureInfo);
                    md5signatureInfo.put("pm", getSignatureMD5(normalSignature));
                    md5signatureInfo.put("binder", binderSignature != null ? getSignatureMD5(binderSignature) : "-1");
                
                    putInfo("a48", md5signatureInfo);
                }
            
        } catch (Exception e) {
            putFailedInfo("a47");
            putFailedInfo("a48");

            XLog.e(TAG, "Failed to collect signature info", e);
        }
    }
    /**
     * 获取签名的MD5指纹
     */
    private String getSignatureMD5(Signature signature) {
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            byte[] signatureBytes = signature.toByteArray();
            md.update(signatureBytes);
            byte[] digest = md.digest();

            // 转换为16进制字符串
            StringBuilder sb = new StringBuilder();
            for (byte b : digest) {
                sb.append(String.format("%02X", b));
            }
            return sb.toString();
        } catch (Exception e) {
            XLog.e(TAG, "Failed to get signature MD5", e);
            return null;
        }
    }


    /**
     * 通过Binder获取签名信息
     */
    public static Signature getAppSignatureForBinder(Context context) {
        Signature signature = null;
        try {
            IBinder binder = getBinder(context);

            // 准备Parcel数据
            Parcel data = Parcel.obtain();
            Parcel reply = Parcel.obtain();

            try {
                // 写入接口标识
                data.writeInterfaceToken("android.content.pm.IPackageManager");
                // 写入包名
                data.writeString(context.getPackageName());
                // 写入获取签名的flag
                data.writeLong(PackageManager.GET_SIGNATURES);
                // 写入当前进程uid
                data.writeInt(Process.myUid());

                // 执行transact调用
                binder.transact(getTransactionId(), data, reply, 0);
                // 读取异常信息(如果有)
                reply.readException();
                // 读取返回的PackageInfo对象
                PackageInfo packageInfo = reply.readTypedObject(PackageInfo.CREATOR);

                if (packageInfo != null && packageInfo.signatures != null && packageInfo.signatures.length > 0) {
                    signature = packageInfo.signatures[0];
                }
            } finally {
                // 回收Parcel
                data.recycle();
                reply.recycle();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return signature;
    }

    @Nullable
    private static IBinder getBinder(Context context) throws NoSuchFieldException, IllegalAccessException {
        PackageManager packageManager = context.getPackageManager();
        // 通过反射获取 mPM 字段
        Field mPmField = packageManager.getClass().getDeclaredField("mPM");
        mPmField.setAccessible(true);
        Object iPackageManager = mPmField.get(packageManager);

        // 获取 mRemote
        Field mRemoteField = iPackageManager.getClass().getDeclaredField("mRemote");
        mRemoteField.setAccessible(true);
        return (IBinder) mRemoteField.get(iPackageManager);
    }

    // 获取TRANSACTION_getPackageInfo的值
    private static int getTransactionId() {
        try {
            Class<?> stubClass = Class.forName("android.content.pm.IPackageManager$Stub");
            Field field = stubClass.getDeclaredField("TRANSACTION_getPackageInfo");
            field.setAccessible(true);
            return field.getInt(null);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return -1;
    }



}

```

`app/src/main/java/com/xiaoc/warlock/Core/collector/StatInfoCollector.java`:

```java
package com.xiaoc.warlock.Core.collector;

import android.content.Context;
import android.system.Os;

import com.xiaoc.warlock.BuildConfig;
import com.xiaoc.warlock.Core.BaseCollector;
import com.xiaoc.warlock.Util.XCommandUtil;
import com.xiaoc.warlock.Util.XLog;

import java.io.File;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Objects;
import java.util.TimeZone;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class StatInfoCollector extends BaseCollector {
    private static final String TAG = "StatInfoCollector";

    public StatInfoCollector(Context context) {
        super(context);
    }

    @Override
    public void collect() {
        collectStorageStats();      // a50
        collectStatFile();          // a53
        collectSerialBlacklist();   // a29, a30, a31
        collectPubkeyBlacklist();   // a32, a33, a34
        collectKeychainStats();     // a35, a36
        collectApkPathStats();      // a40
        collectDownloadPathStats(); // a37
        collectAndroidPathStats();  // a38
        collectTmpPathStats();      // a39
    }

    /**
     * 收集存储统计信息
     */
    private void collectStorageStats() {
        try {
            XCommandUtil.CommandResult result = XCommandUtil.execute("stat -f /storage/emulated/0");
            if (result.isSuccess()) {
                String output = result.getSuccessMsg();

                // 更新正则表达式以匹配实际输出格式
                Pattern blockSizePattern = Pattern.compile("Block Size: (\\d+)");
                Pattern totalBlocksPattern = Pattern.compile("Blocks: Total: (\\d+)");
                Pattern freeBlocksPattern = Pattern.compile("Free: (\\d+)");
                Pattern availableBlocksPattern = Pattern.compile("Available: (\\d+)");
                
                Matcher blockSizeMatcher = blockSizePattern.matcher(output);
                Matcher totalBlocksMatcher = totalBlocksPattern.matcher(output);
                Matcher freeBlocksMatcher = freeBlocksPattern.matcher(output);
                Matcher availableBlocksMatcher = availableBlocksPattern.matcher(output);
                
                if (blockSizeMatcher.find() && totalBlocksMatcher.find() && 
                    freeBlocksMatcher.find() && availableBlocksMatcher.find()) {
                    
                    long blockSize = Long.parseLong(Objects.requireNonNull(blockSizeMatcher.group(1)));
                    long totalBlocks = Long.parseLong(Objects.requireNonNull(totalBlocksMatcher.group(1)));
                    long freeBlocks = Long.parseLong(Objects.requireNonNull(freeBlocksMatcher.group(1)));
                    long availableBlocks = Long.parseLong(Objects.requireNonNull(availableBlocksMatcher.group(1)));
                    
                    // 构建结果对象

                    Map<String, String> results = new LinkedHashMap<>();
                    results.put("t", String.valueOf(totalBlocks * blockSize));      // total space
                    results.put("f", String.valueOf(freeBlocks * blockSize));       // free space
                    results.put("a", String.valueOf(availableBlocks * blockSize));  // available space
                    results.put("bs", String.valueOf(blockSize));                   // block size
                    results.put("s", output);                                       // original output string
                    
                    putInfo("a50", results);
                    
                    // 调试日志
                    XLog.d(TAG, "Storage stats collected successfully: " + result);
                } else {
                    XLog.e(TAG, "Failed to match storage stats patterns. Output: " + output);
                    putFailedInfo("a50");
                }
            } else {
                XLog.e(TAG, "Command execution failed: " + result.getErrorMsg());
                putFailedInfo("a50");
            }
        } catch (Exception e) {
            XLog.e(TAG, "Failed to collect storage stats: " + e.getMessage());
            putFailedInfo("a50");
        }
    }

    /**
     * 收集serial黑名单文件统计信息
     */
    private void collectSerialBlacklist() {
        try {
            XCommandUtil.CommandResult result = XCommandUtil.execute("stat " + BuildConfig.SERIAL_BLACKLIST_FILE);
            if (result.isSuccess()) {
                String output = result.getSuccessMsg();
                String[] lines = output.split("\n");

                for (String line : lines) {
                    line = line.trim();
                    if (line.startsWith("Access:") && line.contains("-")) {
                        putInfo("a29", extractTimestamp(line));
                    } else if (line.startsWith("Modify:") && line.contains("-")) {
                        putInfo("a30", extractTimestamp(line));
                    } else if (line.startsWith("Change:") && line.contains("-")) {
                        putInfo("a31", extractTimestamp(line));
                    }
                }
            } else {
                putFailedInfo("a29");
                putFailedInfo("a30");
                putFailedInfo("a31");
            }
        } catch (Exception e) {
            XLog.e(TAG, "Failed to collect serial blacklist stats: " + e.getMessage());
            putFailedInfo("a29");
            putFailedInfo("a30");
            putFailedInfo("a31");
        }
    }

    /**
     * 将秒级时间戳转换为纳秒级时间戳
     */
    private String extractTimestamp(String line) {
        try {
            // 提取时间部分，格式如：2024-10-25 15:21:34.828000001
            Pattern pattern = Pattern.compile("\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d+");
            Matcher matcher = pattern.matcher(line);

            if (matcher.find()) {
                String timeStr = matcher.group();
                // 解析时间字符串
                String[] parts = timeStr.split("\\.");
                String datePart = parts[0]; // 2024-10-25 15:21:34
                String nanoPart = parts[1]; // 828000001

                // 转换为时间戳
                SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
                sdf.setTimeZone(TimeZone.getTimeZone("GMT+8")); // 设置时区为+8
                long milliseconds = sdf.parse(datePart).getTime();

                // 转换为纳秒级时间戳
                long nanoSeconds = milliseconds * 1_000_000L + Long.parseLong(nanoPart);
                return String.valueOf(nanoSeconds);
            }
        } catch (Exception e) {
            XLog.e(TAG, "Failed to extract timestamp: " + e.getMessage());
        }
        return "-1";
    }

    private void collectStatFile() {
        try {
            Map<String, Map<String, Object>> result = new LinkedHashMap<>();

            for (Map.Entry<String, String> entry : BuildConfig.PATH_MAPPINGS.entrySet()) {
                String path = entry.getKey();
                String mapping = entry.getValue();

                try {
                    Map<String, Object> stats = getFileStatsByCommand(path);

                    if (!stats.isEmpty()) {
                        result.put(mapping, stats);
                    }
                } catch (Exception e) {
                    XLog.e(TAG, "Failed to get stats for " + path + ": " + e.getMessage());
                }
            }

            if (!result.isEmpty()) {
                putInfo("a53", result);
            } else {
                putFailedInfo("a53");
            }
        } catch (Exception e) {
            XLog.e(TAG, "Failed to collect file stats: " + e.getMessage());
            putFailedInfo("a53");
        }
    }

    private Map<String, Object> getFileStatsByReflection(File file) {
        Map<String, Object> stats = new LinkedHashMap<>();
        try {
            Class<?> statClass = Class.forName("android.system.StructStat");
            Object stat = Os.stat(file.getAbsolutePath());

            // 获取秒级时间戳
            long atimeSecs = ((Long) statClass.getField("st_atime").get(stat));
            long mtimeSecs = ((Long) statClass.getField("st_mtime").get(stat));
            long ctimeSecs = ((Long) statClass.getField("st_ctime").get(stat));

            // 获取纳秒部分
            long atimeNanos = 0;
            long mtimeNanos = 0;
            long ctimeNanos = 0;

            try {
                // Android 7.0 (API 24) 及以上版本支持纳秒字段
                atimeNanos = ((Long) statClass.getField("st_atime_nsec").get(stat));
                mtimeNanos = ((Long) statClass.getField("st_mtime_nsec").get(stat));
                ctimeNanos = ((Long) statClass.getField("st_ctime_nsec").get(stat));
            } catch (NoSuchFieldException e) {
                // 旧版本 Android 不支持纳秒字段
                XLog.d(TAG, "Nanosecond fields not available");
            }

            // 转换每个时间戳
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            sdf.setTimeZone(TimeZone.getTimeZone("Asia/Shanghai"));

            // Access time
            Date atimeDate = new Date(atimeSecs * 1000);
            String atimeDateStr = sdf.format(atimeDate);
            String atimeNanoStr = String.format("%-9s", atimeNanos).replace(' ', '0');
            long atimeTimestamp = (atimeSecs) * 1_000_000_000L + atimeNanos;

            // Modify time
            Date mtimeDate = new Date(mtimeSecs * 1000);
            String mtimeDateStr = sdf.format(mtimeDate);
            String mtimeNanoStr = String.format("%-9s", mtimeNanos).replace(' ', '0');
            long mtimeTimestamp = (mtimeSecs) * 1_000_000_000L + mtimeNanos;

            // Change time
            Date ctimeDate = new Date(ctimeSecs * 1000);
            String ctimeDateStr = sdf.format(ctimeDate);
            String ctimeNanoStr = String.format("%-9s", ctimeNanos).replace(' ', '0');
            long ctimeTimestamp = (ctimeSecs) * 1_000_000_000L + ctimeNanos;

            // 获取inode
            long inode = (Long) statClass.getField("st_ino").get(stat);

            // 存储结果
            stats.put("A", atimeTimestamp);
            stats.put("M", mtimeTimestamp);
            stats.put("C", ctimeTimestamp);
            stats.put("I", inode);

            // 调试输出
            XLog.d(TAG, String.format("Access: dateStr=%s, nanoStr=%s, timestamp=%d",
                    atimeDateStr, atimeNanoStr, atimeTimestamp));
            XLog.d(TAG, String.format("Modify: dateStr=%s, nanoStr=%s, timestamp=%d",
                    mtimeDateStr, mtimeNanoStr, mtimeTimestamp));
            XLog.d(TAG, String.format("Change: dateStr=%s, nanoStr=%s, timestamp=%d",
                    ctimeDateStr, ctimeNanoStr, ctimeTimestamp));

        } catch (Exception e) {
            XLog.e(TAG, "Reflection failed: " + e.getMessage());
        }
        return stats;
    }

    private Map<String, Object> getFileStatsByCommand(String path) {
        Map<String, Object> stats = new LinkedHashMap<>();

        String command = String.format("stat '%s'", path);
        XCommandUtil.CommandResult result = XCommandUtil.execute(command);

        if (result.isSuccess() && !result.getSuccessMsg().isEmpty()) {
            try {
                // 匹配时间行和Inode行
                Pattern timePattern = Pattern.compile("(Access|Modify|Change): (\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2})\\.(\\d+)");
                Pattern inodePattern = Pattern.compile("Inode: (\\d+)");

                Matcher timeMatcher = timePattern.matcher(result.getSuccessMsg());
                while (timeMatcher.find()) {
                    String type = timeMatcher.group(1);
                    String dateStr = timeMatcher.group(2);
                    String nanoStr = timeMatcher.group(3);

                    // 解析日期时间部分到毫秒
                    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
                    sdf.setTimeZone(TimeZone.getTimeZone("Asia/Shanghai"));
                    long millis = sdf.parse(dateStr).getTime();

                    // 处理纳秒部分（保持原始精度）
                    nanoStr = String.format("%-9s", nanoStr).replace(' ', '0');
                    long nanos = Long.parseLong(nanoStr);

                    // 组合为纳秒时间戳
                    long timestamp = (millis / 1000) * 1_000_000_000L + nanos;

                    // 调试输出
                    XLog.d(TAG, String.format("%s: dateStr=%s, nanoStr=%s, timestamp=%d",
                            type, dateStr, nanoStr, timestamp));

                    // 根据类型存储
                    switch (type) {
                        case "Access":
                            stats.put("A", timestamp);
                            break;
                        case "Modify":
                            stats.put("M", timestamp);
                            break;
                        case "Change":
                            stats.put("C", timestamp);
                            break;
                    }
                }

                // 获取Inode
                Matcher inodeMatcher = inodePattern.matcher(result.getSuccessMsg());
                if (inodeMatcher.find()) {
                    stats.put("I", Long.parseLong(Objects.requireNonNull(inodeMatcher.group(1))));
                }

            } catch (Exception e) {
                XLog.e(TAG, "Failed to parse stat output: " + e.getMessage());
            }
        }

        return stats;
    }

    private void collectPubkeyBlacklist() {
        try {
            XCommandUtil.CommandResult result = XCommandUtil.execute("stat " + BuildConfig.PUBKEY_BLACKLIST_FILE);
            XLog.d("xiaoc666", result.getSuccessMsg());

            if (result.isSuccess()) {
                String output = result.getSuccessMsg();
                String[] lines = output.split("\n");
                XLog.d("xiaoc666", result.getSuccessMsg());
                for (String line : lines) {
                    line = line.trim();
                    if (line.startsWith("Access:") && line.contains("-")) {  // Access time
                        putInfo("a33", extractTimestamp(line));
                    } else if (line.startsWith("Modify:") && line.contains("-")) {  // Modify time
                        putInfo("a32", extractTimestamp(line));
                    } else if (line.startsWith("Change:") && line.contains("-")) {  // Change time
                        putInfo("a34", extractTimestamp(line));
                    }
                }
            } else {
                putFailedInfo("a32");
                putFailedInfo("a33");
                putFailedInfo("a34");
            }
        } catch (Exception e) {
            putFailedInfo("a32");
            putFailedInfo("a33");
            putFailedInfo("a34");
            XLog.e(TAG, "Failed to collect pubkey blacklist stats: " + e.getMessage());
        }
    }

    private void collectKeychainStats() {
        try {
            XCommandUtil.CommandResult result = XCommandUtil.execute("stat " + BuildConfig.KEYCHAIN_DIR);

            if (result.isSuccess()) {
                String output = result.getSuccessMsg();
                String[] lines = output.split("\n");

                for (String line : lines) {
                    line = line.trim();
                    if (line.startsWith("Access:") && line.contains("-")) {  // Access time
                        putInfo("a35", extractTimestamp(line));
                    }  else if (line.startsWith("Change:") && line.contains("-")) {  // Change time
                        putInfo("a36", extractTimestamp(line));
                    }
                }
            } else {
                putFailedInfo("a35");
                putFailedInfo("a36");
            }
        } catch (Exception e) {
            putFailedInfo("a35");
            putFailedInfo("a36");
            XLog.e(TAG, "Failed to collect keychain stats: " + e.getMessage());
        }
    }

    private void collectApkPathStats() {
        try {
            XCommandUtil.CommandResult result = XCommandUtil.execute("stat " + BuildConfig.APK_PATH);
            XLog.d("xiaoc666", result.getSuccessMsg() + " | " + result.getErrorMsg());

            // 检查错误输出是否包含 "No such file or directory"
            if (result.getErrorMsg() != null &&
                    result.getErrorMsg().contains("No such file or directory")) {
                putInfo("a40", "false");
            } else {
                putInfo("a40", "true");
            }
        } catch (Exception e) {
            XLog.e(TAG, "Failed to check Apppackage: " + e.getMessage());
            putFailedInfo("a40");
        }
    }

    private void collectDownloadPathStats() {
        try {
            XCommandUtil.CommandResult result = XCommandUtil.execute("stat " + BuildConfig.SDCARD_DOWNLOAD_PATH);
            XLog.d("xiaoc666", result.getSuccessMsg());

            if (result.isSuccess()) {
                Map<String, String> timeMap = new LinkedHashMap<>();
                String output = result.getSuccessMsg();
                String[] lines = output.split("\n");

                for (String line : lines) {
                    line = line.trim();
                    if (line.startsWith("Access:") && line.contains("-")) {
                        timeMap.put("access", extractTimestamp(line));
                    } else if (line.startsWith("Change:") && line.contains("-")) {
                        timeMap.put("change", extractTimestamp(line));
                    }
                }

                // 检查是否都获取到了时间戳
                if (timeMap.containsKey("access") && timeMap.containsKey("change")) {
                    putInfo("a37", timeMap);
                } else {
                    putFailedInfo("a37");
                }
            } else {
                putFailedInfo("a37");
            }
        } catch (Exception e) {
            XLog.e(TAG, "Failed to collect download path stats: " + e.getMessage());
            putFailedInfo("a37");
        }
    }

    private void collectAndroidPathStats() {
        try {
            XCommandUtil.CommandResult result = XCommandUtil.execute("stat " + BuildConfig.SDCARD_ANDROID_PATH);
            XLog.d("xiaoc666", result.getSuccessMsg());

            if (result.isSuccess()) {
                Map<String, String> timeMap = new LinkedHashMap<>();
                String output = result.getSuccessMsg();
                String[] lines = output.split("\n");

                for (String line : lines) {
                    line = line.trim();
                    if (line.startsWith("Access:") && line.contains("-")) {
                        timeMap.put("access", extractTimestamp(line));
                    } else if (line.startsWith("Change:") && line.contains("-")) {
                        timeMap.put("change", extractTimestamp(line));
                    }
                }

                // 检查是否都获取到了时间戳
                if (timeMap.containsKey("access") && timeMap.containsKey("change")) {
                    putInfo("a38", timeMap);
                } else {
                    putFailedInfo("a38");
                }
            } else {
                putFailedInfo("a38");
            }
        } catch (Exception e) {
            XLog.e(TAG, "Failed to collect sdcard android path stats: " + e.getMessage());
            putFailedInfo("a38");
        }
    }

    private void collectTmpPathStats() {
        try {
            XCommandUtil.CommandResult result = XCommandUtil.execute("stat " + BuildConfig.DATA_LOCAL_TMP_PATH);
            XLog.d("xiaoc666", result.getSuccessMsg());

            if (result.isSuccess()) {
                Map<String, String> timeMap = new LinkedHashMap<>();
                String output = result.getSuccessMsg();
                String[] lines = output.split("\n");

                for (String line : lines) {
                    line = line.trim();
                    if (line.startsWith("Access:") && line.contains("-")) {
                        timeMap.put("access", extractTimestamp(line));
                    } else if (line.startsWith("Change:") && line.contains("-")) {
                        timeMap.put("change", extractTimestamp(line));
                    }
                }

                // 检查是否都获取到了时间戳
                if (timeMap.containsKey("access") && timeMap.containsKey("change")) {
                    putInfo("a39", timeMap);
                } else {
                    putFailedInfo("a39");
                }
            } else {
                putFailedInfo("a39");
            }
        } catch (Exception e) {
            XLog.e(TAG, "Failed to collect /data/local/tmp path stats: " + e.getMessage());
            putFailedInfo("a39");
        }
    }
}

```

`app/src/main/java/com/xiaoc/warlock/Core/collector/SystemInfoCollector.java`:

```java
package com.xiaoc.warlock.Core.collector;

import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.hardware.Camera;
import android.hardware.Sensor;
import android.hardware.SensorManager;
import android.hardware.input.InputManager;
import android.media.MediaDrm;
import android.os.StatFs;
import android.view.InputDevice;

import com.xiaoc.warlock.BuildConfig;
import com.xiaoc.warlock.Core.BaseCollector;
import com.xiaoc.warlock.Util.XCommandUtil;
import com.xiaoc.warlock.Util.XFile;
import com.xiaoc.warlock.Util.XLog;
import com.xiaoc.warlock.Util.XString;
import com.xiaoc.warlock.crypto.MD5Util;

import android.os.Process;

import java.io.File;
import java.lang.reflect.Method;
import java.net.Inet6Address;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Enumeration;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class SystemInfoCollector extends BaseCollector {
    private static final String TAG = "SystemInfoCollector";

    public SystemInfoCollector(Context context) {
        super(context);
    }

    @Override
    public void collect() {
        collectCpuInfo();     //a19
        collectSensors();     // a25
        collectMountStats();  // a26
        collectCameraInfo();    // a27
        collectInputDevices();  // a28
        collectMediaDrmProperties();    // a62
        collectWlan0Address();  // a63
        collectDiskInfo();      // a64
        collectArpInfo();       // a65
        collectIPv6Info();     // a66
        collectUnameInfo();     // a67
        collectAppUid();     // a68
        collectDataDirUid();     // a69
        collectTargetApkPaths();    // a70
        collectSystemFontHash();    // a80
        collectSystemServices();    // a75
    }
    /**
     * 收集传感器信息
     * 使用 getSensorList 获取设备上所有可用的传感器信息
     * 结果格式:
     * {
     *   "s": "传感器名称",
     *   "v": "传感器厂商",
     *   "t": "传感器类型",
     *   "m": "最大量程",
     *   "r": "分辨率",
     *   "p": "功耗(mA)"
     * }
     */
    private void collectSensors() {
        try {
            SensorManager sensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
            if (sensorManager == null) {
                putFailedInfo("a25");
                return;
            }

            List<Sensor> sensorList = sensorManager.getSensorList(Sensor.TYPE_ALL);
            List<Map<String, String>> sensorInfo = new ArrayList<>();

            for (Sensor sensor : sensorList) {
                Map<String, String> info = new LinkedHashMap<>();
                info.put("s", sensor.getName());
                info.put("v", sensor.getVendor());
                info.put("t", String.valueOf(sensor.getType()));
                info.put("m", String.valueOf(sensor.getMaximumRange()));
                info.put("r", String.valueOf(sensor.getResolution()));
                info.put("p", String.valueOf(sensor.getPower()));
                sensorInfo.add(info);
            }

            if (!sensorInfo.isEmpty()) {
                putInfo("a25", sensorInfo);
            } else {
                putFailedInfo("a25");
            }

        } catch (Exception e) {
            XLog.e(TAG, "Failed to collect sensors: " + e.getMessage());
            putFailedInfo("a25");
        }
    }

    /**
     * 收集挂载信息
     */
    private void collectMountStats() {
        try {
            String mountStats = XFile.readFile("/proc/self/mountstats");
            if (mountStats == null || mountStats.isEmpty()) {
                // 尝试从 /proc/mounts 读取
                mountStats = XFile.readFile("/proc/mounts");
            }

            if (mountStats != null && !mountStats.isEmpty()) {
                List<Map<String, String>> mountInfo = new ArrayList<>();
                String[] lines = mountStats.split("\n");

                for (String line : lines) {
                    try {
                        String[] parts = line.trim().split("\\s+");
                        if (parts.length >= 3) {
                            Map<String, String> info = new LinkedHashMap<>();
                            info.put("d", parts[0]);  // device
                            info.put("p", parts[1]);  // path
                            info.put("t", parts[2]);  // type
                            mountInfo.add(info);
                        }
                    } catch (Exception e) {
                        XLog.e(TAG, "Failed to parse mount line: " + line);
                    }
                }

                if (!mountInfo.isEmpty()) {
                    putInfo("a26", mountInfo);
                } else {
                    putFailedInfo("a26");
                }
            } else {
                putFailedInfo("a26");
            }

        } catch (Exception e) {
            XLog.e(TAG, "Failed to collect mount stats: " + e.getMessage());
            putFailedInfo("a26");
        }
    }
    /**
     * 收集相机信息
     */
    private void collectCameraInfo() {
        try {
            List<Map<String, String>> cameraInfoList = new ArrayList<>();

            // 获取相机数量
            int numberOfCameras = Camera.getNumberOfCameras();

            for (int i = 0; i < numberOfCameras; i++) {
                Camera.CameraInfo cameraInfo = new Camera.CameraInfo();
                Camera.getCameraInfo(i, cameraInfo);

                Map<String, String> info = new LinkedHashMap<>();
                info.put("n", String.valueOf(i));
                info.put("t", cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_FRONT ? "front" : "back");
                info.put("o", String.valueOf(cameraInfo.orientation));

                cameraInfoList.add(info);
            }

            if (!cameraInfoList.isEmpty()) {
                putInfo("a27", cameraInfoList);
            } else {
                putFailedInfo("a27");
            }

        } catch (Exception e) {
            XLog.e(TAG, "Failed to collect camera info: " + e.getMessage());
            putFailedInfo("a27");
        }
    }

    /**
     * 收集输入设备信息
     */
    private void collectInputDevices() {
        try {
            InputManager inputManager = (InputManager) context.getSystemService(Context.INPUT_SERVICE);
            if (inputManager == null) {
                putFailedInfo("a28");
                return;
            }

            int[] deviceIds = inputManager.getInputDeviceIds();
            List<Map<String, String>> inputDeviceList = new ArrayList<>();

            for (int deviceId : deviceIds) {
                InputDevice device = inputManager.getInputDevice(deviceId);
                if (device != null) {
                    Map<String, String> info = new LinkedHashMap<>();

                    // 获取设备名称
                    String name = device.getName();
                    if (name == null) continue;

                    // 获取vendor ID
                    // 注意：这里vendor用0和1来表示，你可能需要根据实际情况调整逻辑
                    String vendor = "0";
                    if (device.getVendorId() > 0) {
                        vendor = "1";
                    }

                    info.put("v", vendor);
                    info.put("n", name);

                    inputDeviceList.add(info);
                }
            }

            if (!inputDeviceList.isEmpty()) {
                putInfo("a28", inputDeviceList);
            } else {
                putFailedInfo("a28");
            }

        } catch (Exception e) {
            XLog.e(TAG, "Failed to collect input devices: " + e.getMessage());
            putFailedInfo("a28");
        }
    }
    private void collectCpuInfo(){
        try {
            String cpuInfo = XFile.readFile("/proc/cpuinfo");
            if (cpuInfo == null || cpuInfo.isEmpty()) {
                putFailedInfo("a19");
                return;
            }

            Map<String, Object> result = new LinkedHashMap<>();
            Map<String, String> commonInfo = new LinkedHashMap<>();
            Map<String, String> regularInfo = new LinkedHashMap<>();
            List<Map<String, String>> uniqueInfo = new ArrayList<>();

            // 按处理器分割内容
            String[] processors = cpuInfo.split("\n\n");
            Map<String, String> currentProcessor = null;

            // 先处理第一个处理器的信息来获取通用信息
            if (processors.length > 0) {
                String[] lines = processors[0].split("\n");
                for (String line : lines) {
                    if (line.trim().isEmpty()) continue;

                    String[] parts = line.split(":", 2);
                    if (parts.length != 2) continue;

                    String key = parts[0].trim();
                    String value = parts[1].trim();

                    // 收集通用信息
                    switch (key) {
                        case "Hardware":
                        case "Processor":
                        case "Model name":
                        case "CPU implementer":
                        case "CPU architecture":
                        case "CPU revision":
                        case "BogoMIPS":    // 性能指标
                        case "Serial":      // 序列号
                        case "Model":       // 型号
                            commonInfo.put(key, value);
                            break;
                    }
                }
            }

            // 处理所有处理器的信息
            for (String processor : processors) {
                String[] lines = processor.split("\n");
                boolean isNewProcessor = true;

                for (String line : lines) {
                    if (line.trim().isEmpty()) continue;

                    String[] parts = line.split(":", 2);
                    if (parts.length != 2) continue;

                    String key = parts[0].trim();
                    String value = parts[1].trim();

                    switch (key) {
                        case "processor":
                            if (isNewProcessor) {
                                currentProcessor = new LinkedHashMap<>();
                                isNewProcessor = false;
                            }
                            break;
                        case "Features":
                            // Features 放在 regular 信息中
                            regularInfo.put(key, value);
                            break;
                        case "CPU variant":
                        case "CPU part":
                            // 处理器特定信息
                            if (currentProcessor != null) {
                                currentProcessor.put(key, value);
                            }
                            break;
                    }
                }

                if (currentProcessor != null && !currentProcessor.isEmpty()) {
                    uniqueInfo.add(new LinkedHashMap<>(currentProcessor));
                }
            }

            result.put("c", commonInfo);    // common info
            result.put("r", regularInfo);   // regular info
            result.put("u", uniqueInfo);    // unique info

            putInfo("a19", result);

        } catch (Exception e) {
            XLog.e(TAG, "Failed to collect CPU info: " + e.getMessage());
            putFailedInfo("a19");
        }

    }
    /**
     * 收集 MediaDrm 字符串属性信息
     * 获取以下属性:
     * - vendor: 供应商名称
     * - version: DRM版本
     * - description: 描述信息
     * - algorithms: 支持的算法
     * - systemId: 系统ID
     * 结果格式:
     * {
     *   "v": "供应商",
     *   "ver": "版本",
     *   "d": "描述",
     *   "a": "算法",
     *   "s": "系统ID"
     * }
     */
    private void collectMediaDrmProperties() {
        MediaDrm mediaDrm = null;
        try {
            // 使用 Widevine UUID 创建 MediaDrm 实例
            UUID WIDEVINE_UUID = new UUID(0xEDEF8BA979D64ACEL, 0xA3C827DCD51D21EDL);
            mediaDrm = new MediaDrm(WIDEVINE_UUID);

            Map<String, String> drmInfo = new LinkedHashMap<>();

            // 获取供应商信息
            String vendor = mediaDrm.getPropertyString(MediaDrm.PROPERTY_VENDOR);
            if (!XString.isEmpty(vendor)) {
                drmInfo.put("v", vendor);
            }

            // 获取版本信息
            String version = mediaDrm.getPropertyString(MediaDrm.PROPERTY_VERSION);
            if (!XString.isEmpty(version)) {
                drmInfo.put("ver", version);
            }

            // 获取描述信息
            String description = mediaDrm.getPropertyString(MediaDrm.PROPERTY_DESCRIPTION);
            if (!XString.isEmpty(description)) {
                drmInfo.put("d", description);
            }

            // 获取算法信息
            String algorithms = mediaDrm.getPropertyString(MediaDrm.PROPERTY_ALGORITHMS);
            if (!XString.isEmpty(algorithms)) {
                drmInfo.put("a", algorithms);
            }

            // 获取系统ID
            String systemId = mediaDrm.getPropertyString("systemId");
            if (!XString.isEmpty(systemId)) {
                drmInfo.put("s", systemId);
            }

            if (!drmInfo.isEmpty()) {
                putInfo("a62", drmInfo);
            } else {
                putFailedInfo("a62");
            }

        } catch (Exception e) {
            XLog.e(TAG, "Failed to collect MediaDrm properties: " + e.getMessage());
            putFailedInfo("a62");
        } finally {
            if (mediaDrm != null) {
                try {
                    mediaDrm.close();
                } catch (Exception e) {
                    XLog.e(TAG, "Failed to close MediaDrm: " + e.getMessage());
                }
            }
        }
    }
    /**
     * 收集 wlan0 MAC 地址信息
     * 从两个路径获取:
     * - /sys/class/net/wlan0/address
     * - /sys/devices/virtual/net/wlan0/address
     * 结果格式:
     * 如果两个地址相同:
     * {
     *   "v": "MAC地址"
     * }
     * 如果两个地址不同:
     * {
     *   "c": "class路径下的MAC地址",
     *   "d": "devices路径下的MAC地址"
     * }
     */
    private void collectWlan0Address() {
        try {
            String classPath = "/sys/class/net/wlan0/address";
            String devicesPath = "/sys/devices/virtual/net/wlan0/address";

            // 读取两个路径的地址
            String classAddress = XFile.readFile(classPath);
            String devicesAddress = XFile.readFile(devicesPath);

            // 去除可能的空白字符
            if (classAddress != null) {
                classAddress = classAddress.trim();
            }
            if (devicesAddress != null) {
                devicesAddress = devicesAddress.trim();
            }

            // 如果两个地址都为空,标记失败
            if (XString.isEmpty(classAddress) && XString.isEmpty(devicesAddress)) {
                putFailedInfo("a63");
                return;
            }

            // 比较两个地址是否相同
            if (XString.compareExact(classAddress, devicesAddress)) {
                // 如果相同,只保存一个值
                putInfo("a63", classAddress);
            } else {
                // 如果不同,分别保存
                Map<String, String> addressMap = new LinkedHashMap<>();
                if (!XString.isEmpty(classAddress)) {
                    addressMap.put("c", classAddress);
                }
                if (!XString.isEmpty(devicesAddress)) {
                    addressMap.put("d", devicesAddress);
                }
                putInfo("a63", addressMap);
            }

        } catch (Exception e) {
            XLog.e(TAG, "Failed to collect wlan0 address: " + e.getMessage());
            putFailedInfo("a63");
        }
    }
    /**
     * 收集硬盘信息
     * 通过多种方式获取存储信息:
     * - StatFs API获取基本存储信息
     * - XCommandUtil执行stat命令获取文件系统信息
     * 结果格式:
     * {
     *   "t": "总字节数",
     *   "f": "空闲字节数",
     *   "a": "可用字节数",
     *   "bs": "块大小",
     *   "s": "stat命令输出"
     * }
     */
    private void collectDiskInfo() {
        try {
            Map<String, String> diskInfo = new LinkedHashMap<>();

            // 使用StatFs获取存储信息
            StatFs statFs = new StatFs("/storage/emulated/0");

            // 获取总字节数
            long totalBytes = statFs.getTotalBytes();
            diskInfo.put("t", String.valueOf(totalBytes));

            // 获取空闲字节数
            long freeBytes = statFs.getFreeBytes();
            diskInfo.put("f", String.valueOf(freeBytes));

            // 获取可用字节数
            long availableBytes = statFs.getAvailableBytes();
            diskInfo.put("a", String.valueOf(availableBytes));

            // 获取块大小
            long blockSize = statFs.getBlockSizeLong();
            diskInfo.put("bs", String.valueOf(blockSize));

            // 使用XCommandUtil执行stat命令获取文件系统信息
            XCommandUtil.CommandResult result = XCommandUtil.execute("stat -f /storage/emulated/0");
            if (result.isSuccess() && !XString.isEmpty(result.getSuccessMsg())) {
                diskInfo.put("s", result.getSuccessMsg().trim());
            }

            if (!diskInfo.isEmpty()) {
                putInfo("a64", diskInfo);
            } else {
                putFailedInfo("a64");
            }

        } catch (Exception e) {
            XLog.e(TAG, "Failed to collect disk info: " + e.getMessage());
            putFailedInfo("a64");
        }
    }
    /**
     * 收集ARP表信息
     * 优先从/proc/net/arp读取,失败则使用ip neigh show命令
     * 结果格式:
     * [{
     *   "ip": "IP地址",
     *   "hw": "硬件地址(MAC)",
     *   "d": "设备名称"
     * }]
     */
    private void collectArpInfo() {
        try {
            List<Map<String, String>> arpList = new ArrayList<>();
            boolean success = false;

            // 首先尝试读取/proc/net/arp文件
            try {
                String arpContent = XFile.readFile("/proc/net/arp");
                if (!XString.isEmpty(arpContent)) {
                    String[] lines = arpContent.split("\n");
                    // 跳过标题行
                    for (int i = 1; i < lines.length; i++) {
                        String line = lines[i].trim();
                        if (!line.isEmpty()) {
                            String[] parts = line.split("\\s+");
                            if (parts.length >= 6) {
                                Map<String, String> entry = new LinkedHashMap<>();
                                entry.put("ip", parts[0]);  // IP address
                                entry.put("hw", parts[3]);  // HW address
                                entry.put("d", parts[5]);   // Device
                                arpList.add(entry);
                            }
                        }
                    }
                    success = true;
                }
            } catch (Exception e) {
                XLog.d(TAG, "Failed to read /proc/net/arp: " + e.getMessage());
            }

            // 如果读取文件失败,尝试使用ip neigh show命令
            if (!success) {
                XCommandUtil.CommandResult result = XCommandUtil.execute("ip neigh show");
                if (result.isSuccess()) {
                    String[] lines = result.getSuccessMsg().split("\n");
                    for (String line : lines) {
                        if (!line.trim().isEmpty()) {
                            // 解析命令输出,格式类似:
                            // 192.168.1.1 dev wlan0 lladdr 00:11:22:33:44:55 REACHABLE
                            String[] parts = line.trim().split("\\s+");
                            if (parts.length >= 6) {
                                Map<String, String> entry = new LinkedHashMap<>();
                                entry.put("ip", parts[0]);          // IP address
                                entry.put("hw", parts[4]);          // HW address (lladdr后面的值)
                                entry.put("d", parts[2]);           // Device (dev后面的值)
                                arpList.add(entry);
                            }
                        }
                    }
                    success = true;
                }
            }

            if (success && !arpList.isEmpty()) {
                putInfo("a65", arpList);
            } else {
                putFailedInfo("a65");
            }

        } catch (Exception e) {
            XLog.e(TAG, "Failed to collect ARP info: " + e.getMessage());
            putFailedInfo("a65");
        }
    }
    /**
     * 收集设备IPv6地址信息
     * 优先使用NetworkInterface API获取,失败则使用ip命令
     * 结果格式:
     * [{
     *   "a": "IPv6地址",
     *   "i": "网络接口名称"
     * }]
     */
    private void collectIPv6Info() {
        try {
            List<Map<String, String>> ipv6List = new ArrayList<>();
            boolean success = false;

            // 首先尝试使用NetworkInterface API获取
            try {
                Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();
                while (interfaces.hasMoreElements()) {
                    NetworkInterface networkInterface = interfaces.nextElement();
                    Enumeration<InetAddress> addresses = networkInterface.getInetAddresses();

                    while (addresses.hasMoreElements()) {
                        InetAddress address = addresses.nextElement();
                        if (address instanceof Inet6Address) {
                            Map<String, String> ipInfo = new LinkedHashMap<>();
                            ipInfo.put("a", address.getHostAddress());    // IPv6地址
                            ipInfo.put("i", networkInterface.getName());  // 接口名称
                            ipv6List.add(ipInfo);
                            success = true;
                        }
                    }
                }
            } catch (Exception e) {
                XLog.d(TAG, "Failed to get IPv6 from NetworkInterface: " + e.getMessage());
            }

            // 如果API方法失败,使用ip命令获取
            if (!success) {
                XCommandUtil.CommandResult result = XCommandUtil.execute("ip -6 addr show");
                if (result.isSuccess()) {
                    String[] lines = result.getSuccessMsg().split("\n");
                    String currentInterface = "";

                    for (String line : lines) {
                        line = line.trim();
                        if (line.isEmpty()) continue;

                        // 解析接口名
                        if (line.contains(": ")) {
                            String[] parts = line.split(":", 2);
                            if (parts.length > 1) {
                                currentInterface = parts[1].trim().split("\\s+")[0];
                            }
                            continue;
                        }

                        // 解析IPv6地址
                        if (line.contains("inet6")) {
                            String[] parts = line.trim().split("\\s+");
                            for (String part : parts) {
                                if (part.contains(":")) {  // IPv6地址包含冒号
                                    Map<String, String> ipInfo = new LinkedHashMap<>();
                                    ipInfo.put("a", part.split("/")[0]);  // 去掉前缀长度
                                    ipInfo.put("i", currentInterface);
                                    ipv6List.add(ipInfo);
                                    success = true;
                                    break;
                                }
                            }
                        }
                    }
                }
            }

            if (success && !ipv6List.isEmpty()) {
                putInfo("a66", ipv6List);
            } else {
                putFailedInfo("a66");
            }

        } catch (Exception e) {
            XLog.e(TAG, "Failed to collect IPv6 info: " + e.getMessage());
            putFailedInfo("a66");
        }
    }
    /**
     * 收集系统uname信息
     * 使用 uname -a 命令获取系统信息,包括:
     * - 内核名称
     * - 主机名
     * - 内核版本
     * - 系统架构等
     * 结果格式:
     * {
     *   "v": "完整的uname输出信息"
     * }
     */
    private void collectUnameInfo() {
        try {
            XCommandUtil.CommandResult result = XCommandUtil.execute("uname -a");
            if (result.isSuccess() && !XString.isEmpty(result.getSuccessMsg())) {
                // 去除首尾空白字符
                String unameInfo = result.getSuccessMsg().trim();
                putInfo("a67", unameInfo);
            } else {
                putFailedInfo("a67");
            }
        } catch (Exception e) {
            XLog.e(TAG, "Failed to collect uname info: " + e.getMessage());
            putFailedInfo("a67");
        }
    }
    /**
     * 收集应用UID信息
     * 获取当前应用的User ID,可通过以下方式:
     * - Process.myUid()
     * - context.getApplicationInfo().uid
     * 结果格式:
     * {
     *   "v": "应用UID"
     * }
     */
    private void collectAppUid() {
        try {
            // 方法一: 通过Process获取
            int uid = Process.myUid();

            // 方法二: 通过ApplicationInfo获取(作为备选验证)
            int appUid = context.getApplicationInfo().uid;

            // 两种方法获取的结果应该一致
            if (uid == appUid) {
                putInfo("a68", String.valueOf(uid));
            } else {
                // 如果不一致,保存两个值
                Map<String, String> uidInfo = new LinkedHashMap<>();
                uidInfo.put("p", String.valueOf(uid));      // Process获取的UID
                uidInfo.put("a", String.valueOf(appUid));   // ApplicationInfo获取的UID
                putInfo("a68", uidInfo);
            }
        } catch (Exception e) {
            XLog.e(TAG, "Failed to collect app UID: " + e.getMessage());
            putFailedInfo("a68");
        }
    }
    /**
     * 收集应用数据目录权限信息
     * 通过ls -l命令获取/data/data/包名目录的权限信息
     * 从输出中提取uid信息(u0_axxx格式)
     * 结果格式:
     * {
     *   "v": "用户ID" // 例如: u0_a325
     * }
     */
    private void collectDataDirUid() {
        try {
            String packagePath = "/data/data/" + context.getPackageName();
            XCommandUtil.CommandResult result = XCommandUtil.execute("ls -l " + packagePath);

            if (result.isSuccess() && !XString.isEmpty(result.getSuccessMsg())) {
                String output = result.getSuccessMsg();
                String[] lines = output.split("\n");

                // 查找包含u0_a的行
                for (String line : lines) {
                    if (line.contains("u0_a")) {
                        // 使用正则表达式提取u0_axxx格式的uid
                        Pattern pattern = Pattern.compile("u0_a\\d+");
                        Matcher matcher = pattern.matcher(line);
                        if (matcher.find()) {
                            String uid = matcher.group();
                            putInfo("a69", uid);
                            return;
                        }
                    }
                }
                putFailedInfo("a69");
            } else {
                putFailedInfo("a69");
            }

        } catch (Exception e) {
            XLog.e(TAG, "Failed to collect data dir uid: " + e.getMessage());
            putFailedInfo("a69");
        }
    }
    /**
     * 收集指定应用的APK路径信息
     * 包括:
     * - 美团
     * - 微信
     * - MT管理器
     * - 快手
     * - 抖音
     * - 支付宝
     * 结果格式:
     * [{
     *   "p": "包名",
     *   "s": "源文件路径"  // /data/app/xxx/base.apk
     * }]
     */
    private void collectTargetApkPaths() {
        try {

            List<Map<String, String>> apkList = new ArrayList<>();
            PackageManager pm = context.getPackageManager();

            for (String packageName : BuildConfig.targetPackages) {
                try {
                    ApplicationInfo appInfo = pm.getApplicationInfo(packageName, 0);
                    String sourceDir = appInfo.sourceDir;
                    if (!XString.isEmpty(sourceDir)) {
                        Map<String, String> info = new LinkedHashMap<>();
                        info.put("p", packageName);
                        info.put("s", sourceDir);
                        apkList.add(info);
                    }
                } catch (Exception ignored) {
                }
            }

            if (!apkList.isEmpty()) {
                putInfo("a70", apkList);
            } else {
                putFailedInfo("a70");
            }

        } catch (Exception e) {
            putFailedInfo("a70");
        }
    }

    /**
     * 遍历/system/fonts目录下的tf字体文件
     */
    private void collectSystemFontHash() {
        File fontDir = new File("/system/fonts");
        StringBuilder allHashes = new StringBuilder();

        if (fontDir.exists()) {
            Collection<File> fontFiles = XFile.listFiles(fontDir, new String[]{"ttf"}, true);

            for (File font : fontFiles) {
                String md5;
                try {
                    md5 = MD5Util.md5(XFile.readFileToByteArray(font));
                    // 将每个MD5拼接到字符串中
                    allHashes.append(md5);
                } catch (Exception e) {
                    putFailedInfo("a80");
                }
            }

            // 生成最终的MD5
            if (allHashes.length() > 0) {
                String finalMd5 = MD5Util.md5(allHashes.toString().getBytes());
                putInfo("a80", finalMd5);
            }else {
                putFailedInfo("a80");
            }
        } else {
            putFailedInfo("a80");
        }

    }
    /**
     * 采集系统服务列表信息（指纹字段a75）
     */
    private void collectSystemServices() {
        try {
            List<Map<String, Object>> servicesList = new ArrayList<>();

            // 方法1：优先尝试通过ServiceManager反射获取
            List<String> services = getSystemServicesViaReflection();

            // 方法2：如果反射失败，尝试通过service list命令获取
            if (services.isEmpty()) {
                services = getSystemServicesViaCommand();
            }

            // 方法3：如果前两种方法都失败，尝试通过dumpsys获取
            if (services.isEmpty()) {
                services = getSystemServicesViaDumpsys();
            }

            // 转换为结构化数据
            for (String serviceName : services) {
                Map<String, Object> serviceInfo = new LinkedHashMap<>();
                serviceInfo.put("n", serviceName);  // 服务名称

                // 尝试获取服务实例并检查是否可用
                try {
                    Object service = context.getSystemService(serviceName);
                    serviceInfo.put("a", service != null);  // 是否可访问
                } catch (Exception e) {
                    serviceInfo.put("a", false);
                }

                servicesList.add(serviceInfo);
            }

            if (!servicesList.isEmpty()) {
                Map<String, Object> result = new LinkedHashMap<>();
                result.put("c", services.size());  // 服务总数
                result.put("l", servicesList);     // 服务列表详情

                // 添加额外信息：关键服务是否存在
                Map<String, Boolean> criticalServices = new LinkedHashMap<>();
                criticalServices.put("window", services.contains("window"));
                criticalServices.put("power", services.contains("power"));
                criticalServices.put("activity", services.contains("activity"));
                criticalServices.put("package", services.contains("package"));
                result.put("k", criticalServices);

                putInfo("a75", result);
            } else {
                putFailedInfo("a75");
            }
        } catch (Exception e) {
            XLog.e(TAG, "Failed to collect system services: " + e.getMessage());
            putFailedInfo("a75");
        }
    }

    /**
     * 通过反射ServiceManager获取系统服务列表
     */
    private List<String> getSystemServicesViaReflection() {
        List<String> services = new ArrayList<>();
        try {
            Class<?> serviceManagerClass = Class.forName("android.os.ServiceManager");
            Method listServicesMethod = serviceManagerClass.getMethod("listServices");
            String[] serviceNames = (String[]) listServicesMethod.invoke(null);
            if (serviceNames != null) {
                services.addAll(Arrays.asList(serviceNames));
            }
        } catch (Exception e) {
            XLog.d(TAG, "Reflection method failed, fallback to next method");
        }
        return services;
    }

    /**
     * 执行service list命令获取系统服务列表
     */
    private List<String> getSystemServicesViaCommand() {
        List<String> services = new ArrayList<>();
        try {
            XCommandUtil.CommandResult result = XCommandUtil.execute("service list");
            if (result.isSuccess()) {
                String[] lines = result.getSuccessMsg().split("\n");
                for (String line : lines) {
                    if (line.contains(": [")) {
                        String serviceName = line.split(": \\[")[0].trim();
                        services.add(serviceName);
                    }
                }
            }
        } catch (Exception e) {
            XLog.d(TAG, "Service command failed, fallback to next method");
        }
        return services;
    }

    /**
     * dumpsys命令获取系统服务列表
     */
    private List<String> getSystemServicesViaDumpsys() {
        List<String> services = new ArrayList<>();
        try {
            XCommandUtil.CommandResult result = XCommandUtil.execute("dumpsys -l");
            if (result.isSuccess()) {
                String[] lines = result.getSuccessMsg().split("\n");
                for (String line : lines) {
                    if (!line.startsWith(" ") && !line.isEmpty()) {
                        services.add(line.trim());
                    }
                }
            }
        } catch (Exception e) {
            XLog.d(TAG, "Dumpsys method failed");
        }
        return services;
    }
}

```

`app/src/main/java/com/xiaoc/warlock/Core/collector/WebViewInfoCollector.java`:

```java
package com.xiaoc.warlock.Core.collector;

import android.content.Context;
import android.content.pm.PackageInfo;
import android.os.Build;
import android.os.Handler;
import android.os.Looper;
import android.webkit.WebSettings;
import android.webkit.WebView;
import android.webkit.WebViewClient;

import com.xiaoc.warlock.Core.BaseCollector;
import com.xiaoc.warlock.Util.XLog;
import com.xiaoc.warlock.crypto.MD5Util;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.util.Locale;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

/**
 * WebView信息收集器
 * 用于收集WebView相关的指纹信息，包括：
 * - 用户代理(User Agent)
 * - 屏幕分辨率
 * - 像素比例
 * - 时区
 * - GPU信息
 * - 字体列表
 * - WebView版本
 * - 系统语言
 */
public class WebViewInfoCollector extends BaseCollector {
    private static final String TAG = "WebViewInfoCollector";
    private WebView webView;
    private final Handler mainHandler = new Handler(Looper.getMainLooper());

    // 键名定义 - 使用a81-a89的键名
    private static final String WEB_FINGERPRINT = "a81";  // 复合指纹（MD5值）
    private static final String WEB_USER_AGENT = "a82";   // 仅存储User Agent，不参与复合指纹
    private static final String WEB_WEBVIEW_VERSION = "a88";
    private static final String WEB_SYSTEM_LANGUAGE = "a89";

    public WebViewInfoCollector(Context context) {
        super(context);
    }

    @Override
    public void collect() {
        // 先采集不需要WebView的数据
        collectSystemLanguage();
        collectWebViewVersion();
        
        // 使用WebView收集其他数据
        collectWebViewInfo();
    }

    /**
     * 收集系统语言信息
     */
    private void collectSystemLanguage() {
        try {
            Locale locale = Locale.getDefault();
            String language = locale.toString(); // 例如：zh_CN
            putInfo(WEB_SYSTEM_LANGUAGE, language);
            XLog.d(TAG, "Collected system language: " + language);
        } catch (Exception e) {
            XLog.e(TAG, "Failed to collect system language: " + e.getMessage());
            putFailedInfo(WEB_SYSTEM_LANGUAGE);
        }
    }

    /**
     * 收集WebView版本信息
     */
    private void collectWebViewVersion() {
        try {
            // 获取WebView版本（可以通过User-Agent提取或直接获取）
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                PackageInfo webViewPackage = WebView.getCurrentWebViewPackage();
                if (webViewPackage != null) {
                    String version = webViewPackage.versionName;
                    putInfo(WEB_WEBVIEW_VERSION, version);
                    XLog.d(TAG, "Collected WebView version: " + version);
                    return;
                }
            }
            
            // 如果无法直接获取，通过创建临时WebView获取
            final AtomicReference<String> userAgent = new AtomicReference<>();
            final CountDownLatch latch = new CountDownLatch(1);
            
            mainHandler.post(() -> {
                try {
                    WebView tempWebView = new WebView(context);
                    userAgent.set(tempWebView.getSettings().getUserAgentString());
                    tempWebView.destroy();
                } catch (Exception e) {
                    XLog.e(TAG, "Error getting WebView UA: " + e.getMessage());
                } finally {
                    latch.countDown();
                }
            });
            
            if (latch.await(2, TimeUnit.SECONDS)) {
                String ua = userAgent.get();
                if (ua != null) {
                    // 从UA中提取Chrome版本号作为WebView版本
                    String[] parts = ua.split(" ");
                    for (String part : parts) {
                        if (part.startsWith("Chrome/")) {
                            String version = part.substring(7);
                            putInfo(WEB_WEBVIEW_VERSION, version);
                            XLog.d(TAG, "Extracted WebView version from UA: " + version);
                            return;
                        }
                    }
                }
            }
            
            putFailedInfo(WEB_WEBVIEW_VERSION);
        } catch (Exception e) {
            XLog.e(TAG, "Failed to collect WebView version: " + e.getMessage());
            putFailedInfo(WEB_WEBVIEW_VERSION);
        }
    }

    /**
     * 通过WebView收集各种Web相关信息
     * 使用简化的JavaScript指纹收集方法
     */
    private void collectWebViewInfo() {
        final CountDownLatch latch = new CountDownLatch(1);
        final AtomicReference<JSONObject> resultDataRef = new AtomicReference<>();
        
        mainHandler.post(() -> {
            try {
                // 创建WebView实例
                webView = new WebView(context);
                
                // 配置WebView
                WebSettings settings = webView.getSettings();
                settings.setJavaScriptEnabled(true);
                settings.setDomStorageEnabled(true);
                
                // 设置WebViewClient处理页面加载完成事件
                webView.setWebViewClient(new WebViewClient() {
                    @Override
                    public void onPageFinished(WebView view, String url) {
                        XLog.d(TAG, "WebView page loaded, injecting fingerprint JS");
                        injectFingerprintJS(latch, resultDataRef);
                    }
                });
                
                // 设置WebChromeClient以记录JavaScript控制台消息
                webView.setWebChromeClient(new android.webkit.WebChromeClient() {
                    @Override
                    public boolean onConsoleMessage(android.webkit.ConsoleMessage consoleMessage) {
                        XLog.d(TAG, "WebView console: " + consoleMessage.message());
                        return true;
                    }
                });
                
                // 加载空白页面以触发WebView初始化
                webView.loadData("<html><body></body></html>", "text/html", "UTF-8");
                
                // 设置超时处理
                mainHandler.postDelayed(() -> {
                    if (latch.getCount() > 0) {
                        XLog.w(TAG, "WebView fingerprint collection timed out");
                        try {
                            // 尝试再次执行JavaScript
                            injectFingerprintJS(latch, resultDataRef);
                            // 额外等待3秒
                            mainHandler.postDelayed(() -> {
                                if (latch.getCount() > 0) {
                                    XLog.e(TAG, "Final timeout, cleaning up WebView");
                                    cleanupWebView();
                                    latch.countDown();
                                }
                            }, 3000);
                        } catch (Exception e) {
                            XLog.e(TAG, "Error in timeout handler: " + e.getMessage());
                            cleanupWebView();
                            latch.countDown();
                        }
                    }
                }, 5000); // 5秒后超时
                
            } catch (Exception e) {
                XLog.e(TAG, "Error setting up WebView: " + e.getMessage());
                cleanupWebView();
                latch.countDown();
            }
        });
        
        try {
            // 等待收集完成
            if (latch.await(10, TimeUnit.SECONDS)) {
                // 处理收集的数据
                JSONObject data = resultDataRef.get();
                if (data != null) {
                    processCollectedData(data);
                } else {
                    XLog.e(TAG, "No WebView data was collected");
                    markWebViewFieldsAsFailed();
                }
            } else {
                XLog.e(TAG, "Timeout waiting for WebView data collection");
                markWebViewFieldsAsFailed();
            }
        } catch (Exception e) {
            XLog.e(TAG, "Error in WebView collection: " + e.getMessage());
            markWebViewFieldsAsFailed();
        }
    }
    
    /**
     * 注入JavaScript代码采集指纹
     */
    private void injectFingerprintJS(CountDownLatch latch, AtomicReference<JSONObject> resultDataRef) {
        if (webView == null) {
            XLog.e(TAG, "WebView is null, cannot inject JS");
            return;
        }
        
        String jsCode = "(function() {\n" +
            "    // 1. 基础信息\n" +
            "    const data = {\n" +
            "        userAgent: navigator.userAgent,\n" +
            "        screen: window.screen.width + 'x' + window.screen.height,\n" +
            "        pixelRatio: window.devicePixelRatio,\n" +
            "        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n" +
            "        hardwareConcurrency: navigator.hardwareConcurrency || 'unknown',\n" +
            "        touchSupport: 'ontouchstart' in window,\n" +
            "        language: navigator.language,\n" +
            "        platform: navigator.platform\n" +
            "    };\n" +
            "\n" +
            "    // 2. WebGL指纹\n" +
            "    try {\n" +
            "        const canvas = document.createElement('canvas');\n" +
            "        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n" +
            "        if (gl) {\n" +
            "            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');\n" +
            "            if (debugInfo) {\n" +
            "                data.gpuVendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);\n" +
            "                data.gpuRenderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);\n" +
            "            }\n" +
            "            // 收集更多WebGL参数\n" +
            "            data.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n" +
            "            data.maxViewportDims = gl.getParameter(gl.MAX_VIEWPORT_DIMS);\n" +
            "            data.shadings = gl.getParameter(gl.SHADING_LANGUAGE_VERSION);\n" +
            "            data.extensions = gl.getSupportedExtensions().join(',').substring(0, 500);\n" +
            "        }\n" +
            "    } catch (e) {\n" +
            "        data.webglError = e.message;\n" +
            "    }\n" +
            "\n" +
            "    // 3. 字体列表（简化版）\n" +
            "    data.fonts = [];\n" +
            "    const testFonts = ['Arial', 'Courier New', 'Times New Roman', 'Roboto', 'Noto Sans', 'Helvetica', 'Verdana', 'Tahoma', 'Georgia'];\n" +
            "    for (const font of testFonts) {\n" +
            "        data.fonts.push(font);\n" +
            "    }\n" +
            "\n" +
            "    // 4. Canvas指纹\n" +
            "    try {\n" +
            "        const canvas = document.createElement('canvas');\n" +
            "        canvas.width = 200;\n" +
            "        canvas.height = 20;\n" +
            "        const ctx = canvas.getContext('2d');\n" +
            "        ctx.textBaseline = 'top';\n" +
            "        ctx.font = '14px Arial';\n" +
            "        ctx.fillStyle = '#f60';\n" +
            "        ctx.fillRect(125, 1, 62, 20);\n" +
            "        ctx.fillStyle = '#069';\n" +
            "        ctx.fillText('WebViewFP,za2', 2, 15);\n" +
            "        const base64 = canvas.toDataURL().substring(0, 100);\n" +
            "        data.canvasHash = base64;\n" +
            "    } catch (e) {\n" +
            "        data.canvasError = e.message;\n" +
            "    }\n" +
            "\n" +
            "    return JSON.stringify(data);\n" +
            "})();";
        
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
                webView.evaluateJavascript(jsCode, value -> {
                    try {
                        // 处理JS返回的JSON数据
                        XLog.d(TAG, "Received WebView data: " + value);
                        
                        // 移除多余的引号和转义字符
                        String jsonStr = value;
                        if (jsonStr.startsWith("\"") && jsonStr.endsWith("\"")) {
                            jsonStr = jsonStr.substring(1, jsonStr.length() - 1)
                                    .replace("\\\"", "\"")
                                    .replace("\\\\", "\\");
                        }
                        
                        JSONObject data = new JSONObject(jsonStr);
                        XLog.d(TAG, "Parsed JSON data successfully");
                        
                        // 存储结果并解除锁定
                        resultDataRef.set(data);
                        cleanupWebView();
                        latch.countDown();
                        
                    } catch (JSONException e) {
                        XLog.e(TAG, "Error parsing WebView data: " + e.getMessage());
                        cleanupWebView();
                        latch.countDown();
                    }
                });
            } else {
                // 为KitKat以下设备提供后备方案
                XLog.e(TAG, "Device API level too low for evaluateJavascript");
                cleanupWebView();
                latch.countDown();
            }
        } catch (Exception e) {
            XLog.e(TAG, "Error injecting fingerprint JS: " + e.getMessage());
            cleanupWebView();
            latch.countDown();
        }
    }
    
    /**
     * 处理收集到的数据并存储，生成指纹
     */
    private void processCollectedData(JSONObject data) {
        try {
            // 仅保存User Agent
            if (data.has("userAgent")) {
                String userAgent = data.getString("userAgent");
                putInfo(WEB_USER_AGENT, userAgent);
                XLog.d(TAG, "Saved user agent: " + userAgent);
            }

            // 构建复合指纹
            StringBuilder fingerprintBuilder = new StringBuilder();
            
            // 添加各项属性到复合指纹，按照固定顺序添加
            addToFingerprint(fingerprintBuilder, data, "screen");
            addToFingerprint(fingerprintBuilder, data, "pixelRatio");
            addToFingerprint(fingerprintBuilder, data, "timezone");
            addToFingerprint(fingerprintBuilder, data, "gpuVendor");
            addToFingerprint(fingerprintBuilder, data, "gpuRenderer");
            addToFingerprint(fingerprintBuilder, data, "platform");
            addToFingerprint(fingerprintBuilder, data, "language");
            addToFingerprint(fingerprintBuilder, data, "hardwareConcurrency");
            addToFingerprint(fingerprintBuilder, data, "touchSupport");
            addToFingerprint(fingerprintBuilder, data, "maxTextureSize");
            addToFingerprint(fingerprintBuilder, data, "maxViewportDims");
            addToFingerprint(fingerprintBuilder, data, "shadings");
            addToFingerprint(fingerprintBuilder, data, "canvasHash");

            // 添加字体信息
            if (data.has("fonts")) {
                JSONArray fontsArray = data.getJSONArray("fonts");
                StringBuilder fontsList = new StringBuilder();
                for (int i = 0; i < fontsArray.length(); i++) {
                    if (i > 0) fontsList.append(",");
                    fontsList.append(fontsArray.getString(i));
                }
                fingerprintBuilder.append(fontsList);
            }
            
            // 添加系统语言和WebView版本，这些是在Java端收集的
            String systemLanguage = Locale.getDefault().toString();
            fingerprintBuilder.append(systemLanguage);

            String webViewVersion = "";
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                try {
                    PackageInfo webViewPackage = WebView.getCurrentWebViewPackage();
                    if (webViewPackage != null) {
                        webViewVersion = webViewPackage.versionName;
                    }
                } catch (Exception e) {
                    // Ignore
                }
            }
            fingerprintBuilder.append(webViewVersion);
            
            // 计算复合指纹的MD5哈希值
            String combinedData = fingerprintBuilder.toString();
            String fingerprint = MD5Util.md5(combinedData);
            
            // 存储生成的指纹
            putInfo(WEB_FINGERPRINT, fingerprint);
            XLog.d(TAG, "Generated WebView fingerprint (MD5): " + fingerprint);
            XLog.d(TAG, "Fingerprint source data length: " + combinedData.length());
            
        } catch (Exception e) {
            XLog.e(TAG, "Error processing collected data: " + e.getMessage(), e);
            markWebViewFieldsAsFailed();
        }
    }
    
    /**
     * 将指定键的值添加到指纹字符串构建器
     */
    private void addToFingerprint(StringBuilder builder, JSONObject data, String key) {
        try {
            if (data.has(key)) {
                Object value = data.get(key);
                builder.append(value.toString());
            } else {
                builder.append("NA_").append(key);
            }
        } catch (JSONException e) {
            builder.append("ERR_").append(key);
        }
    }
    
    /**
     * 标记所有WebView相关字段为失败
     */
    private void markWebViewFieldsAsFailed() {
        putFailedInfo(WEB_FINGERPRINT);
        putFailedInfo(WEB_USER_AGENT);
    }
    
    /**
     * 清理WebView资源
     */
    private void cleanupWebView() {
        mainHandler.post(() -> {
            if (webView != null) {
                webView.destroy();
                webView = null;
                XLog.d(TAG, "WebView destroyed");
            }
        });
    }
} 
```

`app/src/main/java/com/xiaoc/warlock/Core/detector/BootloaderStateChecker.java`:

```java
package com.xiaoc.warlock.Core.detector;

import android.content.Context;
import android.os.Build;
import android.security.keystore.KeyGenParameterSpec;
import android.security.keystore.KeyProperties;
import android.util.Log;

import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1InputStream;
import org.bouncycastle.asn1.ASN1Integer;
import org.bouncycastle.asn1.ASN1OctetString;
import org.bouncycastle.asn1.ASN1Primitive;
import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.asn1.ASN1Boolean;
import org.bouncycastle.jce.provider.BouncyCastleProvider;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.security.KeyPairGenerator;
import java.security.KeyStore;
import java.security.Security;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.security.spec.ECGenParameterSpec;
import java.util.Date;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

/**
 * Android Bootloader状态检测工具类
 * 使用密钥认证(Key Attestation)检测设备bootloader解锁状态
 */
public class BootloaderStateChecker {
    private static final String TAG = "BootloaderDetector";
    private static final String KEY_ALIAS = "bootloader_check_key";
    private static final String ATTESTATION_OID = "1.3.6.1.4.1.11129.2.1.17";

    // 超时设置（秒）
    private static final int DEFAULT_TIMEOUT_SECONDS = 10;

    // 启动验证状态
    public static final int VERIFIED_BOOT_VERIFIED = 0;     // 设备处于完全锁定和验证状态
    public static final int VERIFIED_BOOT_SELF_SIGNED = 1;  // 设备使用自签名的引导镜像启动
    public static final int VERIFIED_BOOT_UNVERIFIED = 2;   // 设备以未验证的状态启动
    public static final int VERIFIED_BOOT_FAILED = 3;       // 设备启动验证失败

    /**
     * Bootloader状态结果
     */
    public enum BootloaderStatus {
        LOCKED("LOCKED", true),
        UNLOCKED("UNLOCKED", false),
        LOCKED_INSECURE("LOCKED_INSECURE", false),
        UNKNOWN("UNKNOWN", false);

        private final String displayName;
        private final boolean secure;

        BootloaderStatus(String displayName, boolean secure) {
            this.displayName = displayName;
            this.secure = secure;
        }

        public String getDisplayName() {
            return displayName;
        }

        public boolean isSecure() {
            return secure;
        }
    }

    static {
        // 初始化BouncyCastle
        try {
            Security.addProvider(new BouncyCastleProvider());
        } catch (Exception e) {
            Log.e(TAG, "无法初始化BouncyCastle", e);
        }
    }

    /**
     * 检测设备bootloader状态
     *
     * @param context 应用上下文
     * @return bootloader状态
     */
    public static BootloaderStatus detectStatus(Context context) {
        return detectStatus(context, DEFAULT_TIMEOUT_SECONDS);
    }

    /**
     * 检测设备bootloader状态（带超时）
     *
     * @param context 应用上下文
     * @param timeoutSeconds 超时时间（秒）
     * @return bootloader状态
     */
    public static BootloaderStatus detectStatus(Context context, int timeoutSeconds) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.N) {
            Log.w(TAG, "设备API级别过低，不支持密钥认证");
            return BootloaderStatus.UNKNOWN;
        }

        ExecutorService executor = Executors.newSingleThreadExecutor();
        Future<BootloaderStatus> future = executor.submit(new BootloaderStatusTask(context));

        try {
            return future.get(timeoutSeconds, TimeUnit.SECONDS);
        } catch (Exception e) {
            Log.e(TAG, "检测bootloader状态时出错", e);
            return BootloaderStatus.UNKNOWN;
        } finally {
            executor.shutdownNow();
        }
    }

    /**
     * 后台执行bootloader状态检测的任务
     */
    private static class BootloaderStatusTask implements Callable<BootloaderStatus> {
        private final Context context;

        BootloaderStatusTask(Context context) {
            this.context = context;
        }

        @Override
        public BootloaderStatus call() {
            try {
                // 第一步：通过Key Attestation检测，尝试使用StrongBox
                BootloaderStatus strongBoxResult = checkWithStrongBox();
                if (strongBoxResult != BootloaderStatus.UNKNOWN) {
                    Log.d(TAG, "使用StrongBox成功检测到bootloader状态: " + strongBoxResult);
                    return strongBoxResult;
                }

                // 如果StrongBox失败，尝试使用标准KeyStore
                BootloaderStatus standardResult = checkWithoutStrongBox();
                if (standardResult != BootloaderStatus.UNKNOWN) {
                    Log.d(TAG, "使用标准KeyStore成功检测到bootloader状态: " + standardResult);
                    return standardResult;
                }

                // 如果两种方法都失败，尝试证书内容分析作为补充方法
                BootloaderStatus certificateResult = checkViaCertificateContent();
                if (certificateResult != BootloaderStatus.UNKNOWN) {
                    Log.d(TAG, "通过证书内容分析成功检测到bootloader状态: " + certificateResult);
                    return certificateResult;
                }

                Log.w(TAG, "所有检测方法均失败，无法确定bootloader状态");
                return BootloaderStatus.UNKNOWN;
            } catch (Exception e) {
                Log.e(TAG, "检测过程中出错", e);
                return BootloaderStatus.UNKNOWN;
            }
        }

        /**
         * 使用StrongBox进行检测
         */
        private BootloaderStatus checkWithStrongBox() {
            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.P) {
                Log.d(TAG, "设备API级别过低，不支持StrongBox");
                return BootloaderStatus.UNKNOWN;
            }

            try {
                Log.d(TAG, "使用StrongBox开始检测");
                // 生成密钥并获取证书链
                generateKeyWithStrongBox();
                X509Certificate[] certChain = getAttestationCertificateChain();

                if (certChain == null || certChain.length == 0) {
                    Log.w(TAG, "无法获取StrongBox证书链");
                    return BootloaderStatus.UNKNOWN;
                }

                // 从证书中解析Root of Trust信息
                return analyzeRootOfTrust(certChain);
            } catch (Exception e) {
                Log.e(TAG, "使用StrongBox检测时出错: " + e.getMessage());
                return BootloaderStatus.UNKNOWN;
            }
        }

        /**
         * 使用标准KeyStore检测
         */
        private BootloaderStatus checkWithoutStrongBox() {
            try {
                Log.d(TAG, "使用标准KeyStore开始检测");
                // 生成密钥并获取证书链
                generateKeyWithoutStrongBox();
                X509Certificate[] certChain = getAttestationCertificateChain();

                if (certChain == null || certChain.length == 0) {
                    Log.w(TAG, "无法获取标准KeyStore证书链");
                    return BootloaderStatus.UNKNOWN;
                }

                // 从证书中解析Root of Trust信息
                return analyzeRootOfTrust(certChain);
            } catch (Exception e) {
                Log.e(TAG, "使用标准KeyStore检测时出错: " + e.getMessage());
                return BootloaderStatus.UNKNOWN;
            }
        }

        /**
         * 分析证书中的Root of Trust信息
         */
        private BootloaderStatus analyzeRootOfTrust(X509Certificate[] certChain) {
            for (X509Certificate cert : certChain) {
                RootOfTrust rootOfTrust = extractRootOfTrust(cert);
                if (rootOfTrust != null) {
                    // 基于Root of Trust信息判断bootloader状态
                    if (!rootOfTrust.isDeviceLocked()) {
                        return BootloaderStatus.UNLOCKED;
                    } else if (rootOfTrust.getVerifiedBootState() != VERIFIED_BOOT_VERIFIED) {
                        return BootloaderStatus.LOCKED_INSECURE;
                    } else {
                        return BootloaderStatus.LOCKED;
                    }
                }
            }

            Log.w(TAG, "在证书链中未找到Root of Trust信息");
            return BootloaderStatus.UNKNOWN;
        }

        /**
         * 通过证书内容分析间接判断
         * 针对不在证书中包含Root of Trust的设备
         */
        private BootloaderStatus checkViaCertificateContent() {
            try {
                X509Certificate[] certChain = getAttestationCertificateChain();
                if (certChain == null || certChain.length == 0) {
                    return BootloaderStatus.UNKNOWN;
                }

                // 检查证书内容中的特征
                for (X509Certificate cert : certChain) {
                    String certSubject = cert.getSubjectX500Principal().getName();
                    String certIssuer = cert.getIssuerX500Principal().getName();

                    // 检查证书内容中是否包含特定字符串
                    if (containsUnlockedIndicator(cert)) {
                        return BootloaderStatus.UNLOCKED;
                    }

                    // 检查是否有自签名证书（通常表示设备被修改）
                    if (certSubject.equals(certIssuer) && !isTrustedIssuer(certSubject)) {
                        // 自签名且非信任发行者通常表示设备已解锁
                        return BootloaderStatus.UNLOCKED;
                    }

                    // 检查是否有可信证书链（通常表示设备未解锁）
                    if (hasValidManufacturerChain(certChain)) {
                        return BootloaderStatus.LOCKED;
                    }
                }

                return BootloaderStatus.UNKNOWN;
            } catch (Exception e) {
                Log.e(TAG, "通过证书内容检测时出错", e);
                return BootloaderStatus.UNKNOWN;
            }
        }

        /**
         * 检查证书中是否包含解锁指示器
         */
        private boolean containsUnlockedIndicator(X509Certificate cert) {
            try {
                // 检查常见的解锁相关字符串
                String[] unlockIndicators = {
                        "unlocked", "debuggable", "test-keys", "dev-keys", "insecure"
                };

                String certString = cert.toString().toLowerCase();
                for (String indicator : unlockIndicators) {
                    if (certString.contains(indicator)) {
                        return true;
                    }
                }

                return false;
            } catch (Exception e) {
                return false;
            }
        }

        /**
         * 检查是否为信任的证书发行者
         */
        private boolean isTrustedIssuer(String issuer) {
            // 检查是否为知名的证书发行者
            String[] trustedIssuers = {
                    "google", "android", "qualcomm", "mediatek", "samsung", "xiaomi", "huawei", "oppo", "vivo"
            };

            String lowerIssuer = issuer.toLowerCase();
            for (String trusted : trustedIssuers) {
                if (lowerIssuer.contains(trusted)) {
                    return true;
                }
            }

            return false;
        }

        /**
         * 检查是否有有效的制造商证书链
         */
        private boolean hasValidManufacturerChain(X509Certificate[] certChain) {
            if (certChain == null || certChain.length < 2) {
                return false;
            }

            // 检查证书链中是否包含制造商证书
            for (X509Certificate cert : certChain) {
                String issuer = cert.getIssuerX500Principal().getName().toLowerCase();
                if (issuer.contains("google") || issuer.contains("android") ||
                        issuer.contains("qualcomm") || issuer.contains("mediatek") ||
                        issuer.contains(Build.MANUFACTURER.toLowerCase())) {
                    return true;
                }
            }

            return false;
        }
    }

    /**
     * 使用StrongBox生成带有认证信息的密钥对
     */
    private static void generateKeyWithStrongBox() throws Exception {
        // 清除可能存在的旧密钥
        KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
        keyStore.load(null);
        if (keyStore.containsAlias(KEY_ALIAS)) {
            keyStore.deleteEntry(KEY_ALIAS);
        }

        // 创建认证挑战（确保每次不同）
        byte[] challenge = new Date().toString().getBytes();

        // 配置密钥生成参数
        KeyGenParameterSpec.Builder builder = new KeyGenParameterSpec.Builder(
                KEY_ALIAS,
                KeyProperties.PURPOSE_SIGN)
                .setAlgorithmParameterSpec(new ECGenParameterSpec("secp256r1"))
                .setDigests(KeyProperties.DIGEST_SHA256)
                .setAttestationChallenge(challenge);

        // 明确使用StrongBox
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
            builder.setIsStrongBoxBacked(true);
        } else {
            throw new IllegalStateException("设备不支持StrongBox");
        }

        // 生成密钥对
        KeyPairGenerator generator = KeyPairGenerator.getInstance(
                KeyProperties.KEY_ALGORITHM_EC, "AndroidKeyStore");
        generator.initialize(builder.build());
        generator.generateKeyPair();
        Log.d(TAG, "使用StrongBox成功生成密钥");
    }

    /**
     * 使用标准KeyStore生成带有认证信息的密钥对
     */
    private static void generateKeyWithoutStrongBox() throws Exception {
        // 清除可能存在的旧密钥
        KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
        keyStore.load(null);
        if (keyStore.containsAlias(KEY_ALIAS)) {
            keyStore.deleteEntry(KEY_ALIAS);
        }

        // 创建认证挑战（确保每次不同）
        byte[] challenge = new Date().toString().getBytes();

        // 配置密钥生成参数
        KeyGenParameterSpec.Builder builder = new KeyGenParameterSpec.Builder(
                KEY_ALIAS,
                KeyProperties.PURPOSE_SIGN)
                .setAlgorithmParameterSpec(new ECGenParameterSpec("secp256r1"))
                .setDigests(KeyProperties.DIGEST_SHA256)
                .setAttestationChallenge(challenge);

        // 明确不使用StrongBox
        // 生成密钥对
        KeyPairGenerator generator = KeyPairGenerator.getInstance(
                KeyProperties.KEY_ALGORITHM_EC, "AndroidKeyStore");
        generator.initialize(builder.build());
        generator.generateKeyPair();
        Log.d(TAG, "使用标准KeyStore成功生成密钥");
    }

    /**
     * 获取密钥的证书链
     */
    private static X509Certificate[] getAttestationCertificateChain() throws Exception {
        KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
        keyStore.load(null);

        Certificate[] certificates = keyStore.getCertificateChain(KEY_ALIAS);
        if (certificates == null || certificates.length == 0) {
            return null;
        }

        X509Certificate[] x509Certificates = new X509Certificate[certificates.length];
        for (int i = 0; i < certificates.length; i++) {
            x509Certificates[i] = (X509Certificate) certificates[i];
        }

        return x509Certificates;
    }

    /**
     * 从证书中提取Root of Trust信息
     */
    private static RootOfTrust extractRootOfTrust(X509Certificate cert) {
        try {
            byte[] extensionValue = cert.getExtensionValue(ATTESTATION_OID);
            if (extensionValue == null) {
                return null;
            }

            // 使用ASN.1解析
            ASN1Primitive asn1Primitive = getAsn1Primitive(extensionValue);
            if (!(asn1Primitive instanceof ASN1OctetString)) {
                return null;
            }

            byte[] extensionData = ((ASN1OctetString) asn1Primitive).getOctets();
            ASN1Primitive extensionObject = getAsn1Primitive(extensionData);
            if (!(extensionObject instanceof ASN1Sequence)) {
                return null;
            }

            return parseKeyAttestationSequence((ASN1Sequence) extensionObject);
        } catch (Exception e) {
            Log.e(TAG, "解析证书中的Root of Trust时出错", e);
            return null;
        }
    }

    private static ASN1Primitive getAsn1Primitive(byte[] data) throws IOException {
        try (ASN1InputStream asn1InputStream = new ASN1InputStream(new ByteArrayInputStream(data))) {
            return asn1InputStream.readObject();
        }
    }

    private static RootOfTrust parseKeyAttestationSequence(ASN1Sequence attestationSequence) {
        try {
            // 处理不同格式的证书
            // 在不同设备上，证书格式可能有所不同

            // 尝试从TEE强制授权列表中查找
            if (attestationSequence.size() >= 8) {
                ASN1Encodable teeEnforced = attestationSequence.getObjectAt(7);
                if (teeEnforced instanceof ASN1Sequence) {
                    RootOfTrust rootOfTrust = findRootOfTrustInAuthList((ASN1Sequence) teeEnforced);
                    if (rootOfTrust != null) {
                        return rootOfTrust;
                    }
                }
            }

            // 尝试从软件强制授权列表查找
            if (attestationSequence.size() >= 7) {
                ASN1Encodable softwareEnforced = attestationSequence.getObjectAt(6);
                if (softwareEnforced instanceof ASN1Sequence) {
                    RootOfTrust rootOfTrust = findRootOfTrustInAuthList((ASN1Sequence) softwareEnforced);
                    if (rootOfTrust != null) {
                        return rootOfTrust;
                    }
                }
            }

            // 尝试直接在序列中查找
            for (int i = 0; i < attestationSequence.size(); i++) {
                if (attestationSequence.getObjectAt(i) instanceof ASN1Sequence) {
                    RootOfTrust rootOfTrust =
                            findRootOfTrustInAuthList((ASN1Sequence) attestationSequence.getObjectAt(i));
                    if (rootOfTrust != null) {
                        return rootOfTrust;
                    }
                }
            }

            return null;
        } catch (Exception e) {
            Log.e(TAG, "解析密钥认证序列时出错", e);
            return null;
        }
    }

    private static RootOfTrust findRootOfTrustInAuthList(ASN1Sequence authList) {
        try {
            // 遍历查找Root of Trust标签
            for (int i = 0; i < authList.size(); i++) {
                ASN1Encodable item = authList.getObjectAt(i);
                if (!(item instanceof ASN1Sequence)) continue;

                ASN1Sequence taggedItem = (ASN1Sequence) item;
                if (taggedItem.size() < 2) continue;

                // 检查标签值
                ASN1Encodable tagValue = taggedItem.getObjectAt(0);
                if (tagValue instanceof ASN1Integer) {
                    long tag = ((ASN1Integer) tagValue).getValue().longValue();

                    // 通常是702，但为了兼容不同设备，也尝试检查其他结构
                    if (tag == 702) {
                        RootOfTrust rootOfTrust = parseRootOfTrustValue(taggedItem.getObjectAt(1));
                        if (rootOfTrust != null) {
                            return rootOfTrust;
                        }
                    }
                }

                // 可能不使用标签而是直接内嵌
                if (taggedItem.size() >= 3) {
                    // 尝试解析看是否符合Root of Trust结构
                    RootOfTrust potentialRot = parseDirectSequence(taggedItem);
                    if (potentialRot != null) {
                        return potentialRot;
                    }
                }
            }

            return null;
        } catch (Exception e) {
            Log.e(TAG, "在授权列表中查找Root of Trust时出错", e);
            return null;
        }
    }

    /**
     * 尝试直接从序列中解析RootOfTrust
     * 适用于一些非标准结构
     */
    private static RootOfTrust parseDirectSequence(ASN1Sequence sequence) {
        try {
            if (sequence.size() < 3) return null;

            // 尝试解析第二个元素为布尔值
            boolean deviceLocked = false;
            if (sequence.getObjectAt(1) instanceof ASN1Boolean) {
                deviceLocked = ((ASN1Boolean) sequence.getObjectAt(1)).isTrue();
            } else {
                return null; // 不符合格式
            }

            // 尝试解析第三个元素为整数
            int verifiedBootState = 0;
            if (sequence.getObjectAt(2) instanceof ASN1Integer) {
                verifiedBootState = ((ASN1Integer) sequence.getObjectAt(2)).getValue().intValue();
                return new RootOfTrust(deviceLocked, verifiedBootState);
            }

            return null;
        } catch (Exception e) {
            return null;
        }
    }

    private static RootOfTrust parseRootOfTrustValue(ASN1Encodable value) {
        try {
            if (!(value instanceof ASN1Sequence)) {
                return null;
            }

            ASN1Sequence rootOfTrustSeq = (ASN1Sequence) value;
            if (rootOfTrustSeq.size() < 3) {
                return null;
            }

            // 解析设备锁定状态
            boolean deviceLocked = false;
            if (rootOfTrustSeq.getObjectAt(1) instanceof ASN1Boolean) {
                deviceLocked = ((ASN1Boolean) rootOfTrustSeq.getObjectAt(1)).isTrue();
            }

            // 解析验证引导状态
            int verifiedBootState = 0;
            if (rootOfTrustSeq.getObjectAt(2) instanceof ASN1Integer) {
                verifiedBootState = ((ASN1Integer) rootOfTrustSeq.getObjectAt(2)).getValue().intValue();
            }

            return new RootOfTrust(deviceLocked, verifiedBootState);
        } catch (Exception e) {
            Log.e(TAG, "解析Root of Trust值时出错", e);
            return null;
        }
    }

    /**
     * Root of Trust信息类
     */
    private static class RootOfTrust {
        private final boolean deviceLocked;
        private final int verifiedBootState;

        RootOfTrust(boolean deviceLocked, int verifiedBootState) {
            this.deviceLocked = deviceLocked;
            this.verifiedBootState = verifiedBootState;
        }

        boolean isDeviceLocked() {
            return deviceLocked;
        }

        int getVerifiedBootState() {
            return verifiedBootState;
        }
    }
}
```

`app/src/main/java/com/xiaoc/warlock/Core/detector/CloudPhoneDetector.java`:

```java
package com.xiaoc.warlock.Core.detector;

import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.hardware.Sensor;
import android.hardware.SensorManager;
import android.media.MediaCodecInfo;
import android.media.MediaCodecList;
import android.os.BatteryManager;
import android.os.Build;

import com.xiaoc.warlock.Core.BaseDetector;
import com.xiaoc.warlock.Util.WarningBuilder;
import com.xiaoc.warlock.Util.XLog;
import com.xiaoc.warlock.ui.adapter.InfoItem;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

public class CloudPhoneDetector extends BaseDetector {
    private static final String TAG = "BatteryDetector";
    private final BatteryManager batteryManager;
    private boolean isDetecting = false;

    private String DEV_PATH = "/dev";
    public CloudPhoneDetector(Context context, EnvironmentCallback callback) {
        super(context, callback);
        batteryManager = (BatteryManager) context.getSystemService(Context.BATTERY_SERVICE);
    }

    @Override
    public void detect() {
        if (isDetecting) return;
        isDetecting = true;
        checkBatteryStatus();
        checkAOSPSensors();
        checkDevDirectory();
        checkOMXNames();
    }

    private void checkBatteryStatus() {
        try {
            List<String> abnormalDetails = new ArrayList<>();

            // 方法1: 检查基本电池信息
            Intent batteryStatus = context.registerReceiver(null,
                    new IntentFilter(Intent.ACTION_BATTERY_CHANGED));

            if (batteryStatus == null) return;

            int plugged = batteryStatus.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);
            int voltage = batteryStatus.getIntExtra(BatteryManager.EXTRA_VOLTAGE, -1);
            int temperature = batteryStatus.getIntExtra(BatteryManager.EXTRA_TEMPERATURE, -1);

            // 方法2: 检查充电功率
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                int currentNow = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CURRENT_NOW);

                if (isCharging(plugged) && voltage != -1 && currentNow != -1) {
                    float voltageInVolts = voltage / 1000f;
                    float currentInAmperes = Math.abs(currentNow / 1000000f);
                    float chargingPower = voltageInVolts * currentInAmperes;

                    // 检查是否存在异常的充电功率（可能是云手机特征）
                    if (chargingPower > 300) {
                        abnormalDetails.add(String.format("Power: %.2fW", chargingPower));
                    }
                }
            }

            // 方法3: 检查温度异常
            if (temperature != -1) {
                float temp = temperature / 10f;
                // 检查温度是否在正常范围内
                if (temp < 10 || temp > 50) {
                    abnormalDetails.add(String.format("Temperature: %.1f°C", temp));
                }
            }

            // 方法4: 检查电池健康状态
            int health = batteryStatus.getIntExtra(BatteryManager.EXTRA_HEALTH,
                    BatteryManager.BATTERY_HEALTH_UNKNOWN);
            if (health == BatteryManager.BATTERY_HEALTH_UNKNOWN ||
                    health == BatteryManager.BATTERY_HEALTH_DEAD) {
                abnormalDetails.add("Health: " + getBatteryHealthString(health));
            }

            // 如果发现异常情况，生成报告
            if (!abnormalDetails.isEmpty()) {
                StringBuilder details = new StringBuilder();
                for (String detail : abnormalDetails) {
                    details.append(detail).append("\n");
                }

                InfoItem warning = new WarningBuilder("checkBattery", null)
                        .addDetail("check", details.toString().trim())
                        .addDetail("level", "high")
                        .build();

                reportAbnormal(warning);
            }

        } catch (Exception e) {
            XLog.e(TAG, "Battery detection failed", e);
        }
    }

    /**
     * 检查设备是否正在充电
     */
    private boolean isCharging(int plugged) {
        return plugged == BatteryManager.BATTERY_PLUGGED_AC ||
                plugged == BatteryManager.BATTERY_PLUGGED_USB ||
                plugged == BatteryManager.BATTERY_PLUGGED_WIRELESS;
    }

    /**
     * 获取电池健康状态的描述
     */
    private String getBatteryHealthString(int health) {
        switch (health) {
            case BatteryManager.BATTERY_HEALTH_GOOD: return "Good";
            case BatteryManager.BATTERY_HEALTH_OVERHEAT: return "Overheat";
            case BatteryManager.BATTERY_HEALTH_DEAD: return "Dead";
            case BatteryManager.BATTERY_HEALTH_OVER_VOLTAGE: return "Over voltage";
            case BatteryManager.BATTERY_HEALTH_UNSPECIFIED_FAILURE: return "Unspecified failure";
            case BatteryManager.BATTERY_HEALTH_COLD: return "Cold";
            default: return "Unknown";
        }
    }
    private void checkAOSPSensors() {
        try {
            // 需要Android N及以上版本
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                SensorManager sensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
                List<Sensor> sensorList = sensorManager.getSensorList(Sensor.TYPE_ALL);

                // 收集所有AOSP传感器
                List<String> aospSensors = new ArrayList<>();
                for (Sensor sensor : sensorList) {
                    if (sensor.getVendor().contains("AOSP")) {
                        aospSensors.add(String.format("%s (%s)",
                                sensor.getName(),
                                sensor.getVendor()));
                    }
                }

                // 如果AOSP传感器数量过多，可能是模拟器或云手机
                if (aospSensors.size() > 3) {
                    StringBuilder details = new StringBuilder();
                    details.append(String.format("AOSP Sensors: %d/%d\n",
                            aospSensors.size(),
                            sensorList.size()));

                    // 最多显示前3个传感器
                    for (int i = 0; i < Math.min(3, aospSensors.size()); i++) {
                        details.append("Sensor: ").append(aospSensors.get(i)).append("\n");
                    }

                    if (aospSensors.size() > 3) {
                        details.append("... and ").append(aospSensors.size() - 3).append(" more");
                    }

                    InfoItem warning = new WarningBuilder("checkAOSPSensors", null)
                            .addDetail("check", details.toString().trim())
                            .addDetail("level", "high")
                            .build();

                    reportAbnormal(warning);
                }
            }
        } catch (Exception e) {
            XLog.e(TAG, "AOSP sensors detection failed", e);
        }
    }

    /**
     * 扫描 /dev 目录，查找可能的 RK3588 控制器节点
     * @return
     */
    private void  checkDevDirectory() {
        List<String> nodes = new ArrayList<>();
        File devDir = new File(DEV_PATH);
        if (devDir.exists() && devDir.isDirectory()) {
            File[] files = devDir.listFiles();
            if (files != null) {
                for (File file : files) {
                    String name = file.getName();
                    // 查找常见的 RK3588 相关节点，例如 video、rk 等
                    if (name.startsWith("video") && name.startsWith("rk")) {
                        nodes.add(name);
                    }
                }
            }
            if (!nodes.isEmpty()){
                InfoItem warning = new WarningBuilder("checkDev", null)
                        .addDetail("check", nodes.toString().trim())
                        .addDetail("level", "high")
                        .build();

                reportAbnormal(warning);
            }
        } else {
            XLog.e(TAG, "Cannot access /dev directory. Permission denied or not available.");
        }
    }

    /**
     * 通过检测MediaCodec API 的名称是否包含OMX以及rk。
     */
    private  void checkOMXNames() {
        List<String> omxNames = new ArrayList<>();
        try {
            MediaCodecList codecList = new MediaCodecList(MediaCodecList.ALL_CODECS);
            for (MediaCodecInfo codecInfo : codecList.getCodecInfos()) {
                String codecName = codecInfo.getName();
                // OMX 名称通常以 "OMX." 开头
                if (codecName.startsWith("OMX.") && codecName.contains("rk")) {
                    omxNames.add(codecName);
                }
            }
            if (!omxNames.isEmpty()){
                InfoItem warning = new WarningBuilder("checkMediaCodec", null)
                        .addDetail("check", omxNames.toString().trim())
                        .addDetail("level", "high")
                        .build();

                reportAbnormal(warning);
            }

        } catch (Exception e) {
            XLog.e(TAG, "Error retrieving OMX names: " + e.getMessage());
        }
    }
}
```

`app/src/main/java/com/xiaoc/warlock/Core/detector/HookDetector.java`:

```java
package com.xiaoc.warlock.Core.detector;

import android.content.Context;
import android.os.Debug;

import com.xiaoc.warlock.Core.BaseDetector;
import com.xiaoc.warlock.Util.WarningBuilder;
import com.xiaoc.warlock.ui.adapter.InfoItem;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class HookDetector extends BaseDetector {
    private static final String MAPS_FILE = "/proc/self/maps";
    private static final String RWX_PERMISSION = "rwx";  // 可读可写可执行权限标记
    @Override
    public void detect() {
        isPtraceAttached();
        hasTracerPid();
        isDebuggerConnected();
        hasRWXSegments();
    }
    public static class SuspiciousSegment {
        public String address;    // 内存地址范围
        public String permission; // 权限
        public String path;       // 映射文件路径

        public SuspiciousSegment(String address, String permission, String path) {
            this.address = address;
            this.permission = permission;
            this.path = path;
        }

        @Override
        public String toString() {
            return String.format("Address: %s, Permission: %s, Path: %s",
                    address, permission, path);
        }
    }

    public HookDetector(Context context, EnvironmentCallback callback) {
        super(context, callback);
    }


    public void isPtraceAttached() {
        try {
            // 尝试自我附加ptrace
            Process process = Runtime.getRuntime().exec("ptrace -p " + android.os.Process.myPid());
            int exitValue = process.waitFor();
            if (exitValue != 0){
                InfoItem warning = new WarningBuilder("checkPtrace", null)
                        .addDetail("check", String.valueOf(true))
                        .addDetail("level", "high")
                        .build();
                reportAbnormal(warning);
            }

        } catch (Exception e) {

        }
    }
    public void hasTracerPid() {
        try {
            BufferedReader reader = new BufferedReader(new FileReader("/proc/self/status"));
            String line;
            while ((line = reader.readLine()) != null) {
                if (line.startsWith("TracerPid:")) {
                    int tracerPid = Integer.parseInt(line.substring(10).trim());
                    if (tracerPid != 0){
                        InfoItem warning = new WarningBuilder("checkHasTracerPid", null)
                                .addDetail("check", String.valueOf(true))
                                .addDetail("level", "high")
                                .build();
                        reportAbnormal(warning);
                    }

                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public void isDebuggerConnected() {
        boolean result =Debug.isDebuggerConnected();
        if (result){
            InfoItem warning = new WarningBuilder("checkDebuggerConnected", null)
                    .addDetail("check", String.valueOf(true))
                    .addDetail("level", "high")
                    .build();
            reportAbnormal(warning);
        }

    }
    /**
     * 检查是否存在可读可写可执行的内存段
     * @return 如果发现RWX段返回true
     */
    public  void hasRWXSegments() {
        try {
            List<SuspiciousSegment> segments = findRWXSegments();
            if (!segments.isEmpty()){
                InfoItem warning = new WarningBuilder("checkRWXSegments", null)
                        .addDetail("check", String.valueOf(true))
                        .addDetail("level", "high")
                        .build();
                reportAbnormal(warning);
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 查找所有可读可写可执行的内存段
     * @return 可疑段列表
     */
    public static List<SuspiciousSegment> findRWXSegments() {
        List<SuspiciousSegment> suspiciousSegments = new ArrayList<>();

        try (BufferedReader reader = new BufferedReader(new FileReader(MAPS_FILE))) {
            String line;
            while ((line = reader.readLine()) != null) {
                // maps文件的每一行格式：
                // address           perms offset  dev   inode      pathname
                // 00400000-00452000 r-xp 00000000 08:02 173521      /usr/bin/dbus-daemon

                String[] parts = line.split("\\s+");
                if (parts.length < 2) continue;

                String address = parts[0];
                String permission = parts[1];

                // 获取映射文件路径（如果存在）
                String path = parts.length > 5 ? parts[parts.length - 1] : "anonymous";

                // 检查是否具有rwx权限
                if (permission.equals(RWX_PERMISSION)) {
                    suspiciousSegments.add(new SuspiciousSegment(address, permission, path));
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        return suspiciousSegments;
    }

}

```

`app/src/main/java/com/xiaoc/warlock/Core/detector/MiscDetector.java`:

```java
package com.xiaoc.warlock.Core.detector;

import android.Manifest;
import android.app.KeyguardManager;
import android.app.admin.DevicePolicyManager;
import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.location.Location;
import android.location.LocationManager;
import android.net.ConnectivityManager;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.os.Build;
import android.provider.Settings;
import com.xiaoc.warlock.Core.detector.BootloaderStateChecker;
import android.telephony.TelephonyManager;

import com.xiaoc.warlock.App;
import com.xiaoc.warlock.BuildConfig;
import com.xiaoc.warlock.Core.BaseDetector;
import com.xiaoc.warlock.Util.AppChecker;
import com.xiaoc.warlock.Util.MiscUtil;
import com.xiaoc.warlock.Util.WarningBuilder;

import com.xiaoc.warlock.Util.XFile;
import com.xiaoc.warlock.Util.XLog;
import com.xiaoc.warlock.ui.adapter.InfoItem;

import java.net.NetworkInterface;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class MiscDetector extends BaseDetector {
    private final TelephonyManager telephonyManager;
    private String TAG = "MiscDetector";

    public MiscDetector(Context context, EnvironmentCallback callback) {
        super(context, callback);
        telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);

    }

    /**
     * 检测当前设备是否能够正常调用反射
     */
    private void checkReflectionAvailable(){
        try {
            boolean supported =AppChecker.isReflectionSupported();
                if (supported && Build.VERSION.SDK_INT >= Build.VERSION_CODES.P){{
                    InfoItem warning = new WarningBuilder("checkHideApi", null)
                            .addDetail("check", String.valueOf(supported))
                            .addDetail("level", "medium")
                            .build();

                    reportAbnormal(warning);
                }}

        } catch (Exception e) {
        }
    }
    /**
     * 检测App启动时是否会有异常堆栈
     */
    private void checkException(){
        try {
            boolean StackTraceBbnormal =AppChecker.isStackTraceBbnormal();
            if (StackTraceBbnormal){{
                StringBuilder details = new StringBuilder();
                for (String line : AppChecker.getStackTraceBbnormal()) {
                    details.append(line).append("\n");
                }
                InfoItem warning = new WarningBuilder("checkStackTrace", null)
                        .addDetail("check", details.toString().trim())
                        .addDetail("level", "high")
                        .build();

                reportAbnormal(warning);
            }}

        } catch (Exception e) {
        }
    }

    /**
     * 检测当前手机是否有手机卡
     */
    private void checkSimCard() {
        try {
            if (telephonyManager == null) {
                XLog.e(TAG, "TelephonyManager is null");
                return;
            }

            boolean hasActiveSim = false;

            // 对于Android Q及以上版本，检查所有SIM卡槽
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                int phoneCount = telephonyManager.getPhoneCount();
                for (int i = 0; i < phoneCount; i++) {
                    if (telephonyManager.getSimState(i) == TelephonyManager.SIM_STATE_READY) {
                        hasActiveSim = true;
                        break;
                    }
                }
            } else {
                // 对于低版本Android，只检查主卡槽
                hasActiveSim = telephonyManager.getSimState() == TelephonyManager.SIM_STATE_READY;
            }

            // 如果没有可用的SIM卡，报告警告
            if (!hasActiveSim) {
                InfoItem warning = new WarningBuilder("checkSimCard", null)
                        .addDetail("check", "Not Found Sim")
                        .addDetail("level", "medium")
                        .build();

                reportAbnormal(warning);
                XLog.d(TAG, "未检测到可用的SIM卡");
            }

        } catch (SecurityException e) {
            XLog.e(TAG, "缺少必要权限", e);
        } catch (Exception e) {
            XLog.e(TAG, "检查SIM卡状态失败", e);
        }
    }

    /**
     * 检测当前设备是否存在shizuku
     */
    private void checkShizukuFiles() {
        try {
            List<String> foundFiles = new ArrayList<>();

            for (String path : BuildConfig.SHIZUKU_FILES) {
                if (XFile.exists(path)) {
                    foundFiles.add(path);
                    XLog.d(TAG, "发现Shizuku文件: " + path);
                }
            }

            if (!foundFiles.isEmpty()) {
                StringBuilder details = new StringBuilder();
                for (String file : foundFiles) {
                    details.append(file).append("\n");
                }

                InfoItem warning = new WarningBuilder("checkShizuku", null)
                        .addDetail("check", details.toString().trim())
                        .addDetail("level", "low")
                        .build();

                reportAbnormal(warning);
            }
        } catch (Exception e) {
            XLog.e(TAG, "检查Shizuku文件失败", e);
        }
    }
    /**
     * 检测系统代理设置
     * 检查是否设置了HTTP代理，这可能表明设备正在被用于抓包分析
     */
    private void checkProxy() {
        try {
            String host = System.getProperty("http.proxyHost");
            String port = System.getProperty("http.proxyPort");

            if (host != null && !host.isEmpty()) {
                String proxyInfo = host + (port != null ? ":" + port : "");

                InfoItem warning = new WarningBuilder("checkProxy", null)
                        .addDetail("check", proxyInfo)
                        .addDetail("level", "medium")
                        .build();

                reportAbnormal(warning);
                XLog.d(TAG, "检测到代理设置: " + proxyInfo);
            }
        } catch (Exception e) {
            XLog.e(TAG, "检查代理设置失败", e);
        }
    }
    /**
     * 检测USB调试状态
     * 检查ADB调试是否启用，这是一个潜在的安全风险
     */
    private void checkAdbDebug() {
        try {
            int adbEnabled = Settings.Global.getInt(
                    context.getContentResolver(),
                    Settings.Global.ADB_ENABLED,
                    0);

            if (adbEnabled == 1) {
                InfoItem warning = new WarningBuilder("checkAdbDebug", null)
                        .addDetail("check", String.valueOf(true))
                        .addDetail("level", "low")
                        .build();

                reportAbnormal(warning);
                XLog.d(TAG, "USB调试已启用");
            }
        } catch (Exception e) {
            XLog.e(TAG, "检查USB调试状态失败", e);
        }
    }

    /**
     * 检测开发者选项状态
     * 检查开发者选项是否启用，这可能表明设备处于开发测试状态
     */
    private void checkDevelopmentSettings() {
        try {
            int developmentSettingsEnabled = Settings.Global.getInt(
                    context.getContentResolver(),
                    Settings.Global.DEVELOPMENT_SETTINGS_ENABLED,
                    0);

            if (developmentSettingsEnabled == 1) {
                InfoItem warning = new WarningBuilder("checkDevelopmentSettings", null)
                        .addDetail("check", String.valueOf(true))
                        .addDetail("level", "low")
                        .build();

                reportAbnormal(warning);
                XLog.d(TAG, "开发者选项已启用");
            }
        } catch (Exception e) {
            XLog.e(TAG, "检查开发者选项状态失败", e);
        }
    }
    /**
     * 检测VPN连接状态
     * 检查设备是否正在使用VPN连接，这可能表明流量正在被重定向或监控
     */
    private void checkVpnConnection() {
        try {
            ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
            if (cm == null) {
                XLog.e(TAG, "ConnectivityManager is null");
                return;
            }

            // 方法1：通过网络接口检测
            boolean vpnInUse = false;
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                Network activeNetwork = cm.getActiveNetwork();
                if (activeNetwork != null) {
                    NetworkCapabilities caps = cm.getNetworkCapabilities(activeNetwork);
                    if (caps != null && caps.hasTransport(NetworkCapabilities.TRANSPORT_VPN)) {
                        vpnInUse = true;
                    }
                }
            }

            // 方法2：通过检查VPN接口
            try {
                List<NetworkInterface> networks = Collections.list(NetworkInterface.getNetworkInterfaces());
                for (NetworkInterface network : networks) {
                    if (!vpnInUse && network.getName().startsWith("tun") || network.getName().startsWith("ppp")) {
                        vpnInUse = true;
                        break;
                    }
                }
            } catch (Exception e) {
                XLog.e(TAG, "检查网络接口失败", e);
            }

            if (vpnInUse) {
                InfoItem warning = new WarningBuilder("checkVpn", null)
                        .addDetail("check", String.valueOf(true))
                        .addDetail("level", "medium")
                        .build();

                reportAbnormal(warning);
                XLog.d(TAG, "检测到VPN连接");
            }

        } catch (Exception e) {
            XLog.e(TAG, "检查VPN状态失败", e);
        }
    }
    private void checkLineageOS() {
        try {
            List<String> abnormalDetails = new ArrayList<>();

            // 方法1: 检查系统属性
            String[] lineageProps = {
                    "ro.build.display.id",
                    "ro.lineage.version",
                    "ro.modversion",
                    "ro.lineage.releasetype",
                    "ro.lineage.build.version",
                    "ro.lineage.device",
                    "ro.lineage.release.type"
            };

            for (String prop : lineageProps) {
                String value = MiscUtil.getSystemProperty(prop);
                if (value != null && value.toLowerCase().contains("lineage")) {
                    abnormalDetails.add("Prop: " +  value);
                }
            }

            // 方法2: 检查特征文件
            String[] lineageFiles = {
                    "/system/addon.d",
                    "/system/etc/init/lineage.rc",
                    "/system/etc/permissions/org.lineageos.platform.xml",
                    "/system/framework/lineage-framework.jar",
                    "/system/etc/permissions/org.lineageos.hardware.xml",
                    "/system/etc/permissions/org.lineageos.weather.xml"
            };

            for (String path : lineageFiles) {
                if (XFile.exists(path)) {
                    abnormalDetails.add("File: " + path);
                }
            }

            // 方法3: 检查系统应用
            String[] lineageApps = {
                    "org.lineageos.updater",              // Lineage更新器
                    "org.lineageos.settings",             // Lineage设置
                    "lineageos.platform",                 // Lineage平台
                    "org.lineageos.recorder",             // Lineage录音机
                    "org.lineageos.profiles",             // Lineage配置文件
                    "org.lineageos.setupwizard",          // Lineage设置向导
                    "org.lineageos.snap",                 // Lineage相机
                    "org.lineageos.weather.provider",     // Lineage天气提供者
                    "org.lineageos.audiofx"               // Lineage音效
            };

            PackageManager pm = context.getPackageManager();
            int lineageAppCount = 0;

            for (String packageName : lineageApps) {
                try {
                    pm.getPackageInfo(packageName, PackageManager.GET_ACTIVITIES);
                    lineageAppCount++;
                    if (lineageAppCount <= 3) { // 只记录前3个发现的应用
                        abnormalDetails.add("LineageOS App: " + packageName);
                    }
                } catch (PackageManager.NameNotFoundException ignored) {
                    // 包未安装，继续检查下一个
                }
            }


            // 方法4: 检查系统指纹
            String fingerprint = Build.FINGERPRINT.toLowerCase();
            if (fingerprint.contains("lineage")) {
                abnormalDetails.add("fingerprint: " + fingerprint);
            }

            // 如果发现任何LineageOS特征
            if (!abnormalDetails.isEmpty()) {
                StringBuilder details = new StringBuilder();
                for (String detail : abnormalDetails) {
                    details.append(detail).append("\n");
                }

                InfoItem warning = new WarningBuilder("checkLineageOS", null)
                        .addDetail("check", details.toString().trim())
                        .addDetail("level", "low")
                        .build();

                reportAbnormal(warning);
              //  XLog.d(TAG, "检测到LineageOS系统: " + details);
            }
        } catch (Exception e) {
            XLog.e(TAG, "LineageOS检测失败", e);
        }
    }
    private void checkGoogleDevice() {
        try {
            List<String> abnormalDetails = new ArrayList<>();

            // 方法1: 检查制造商和品牌
            String manufacturer = Build.MANUFACTURER.toLowerCase();
            String brand = Build.BRAND.toLowerCase();
            String model = Build.MODEL.toLowerCase();

            if (manufacturer.contains("google") || brand.contains("google") ||
                    model.contains("pixel") || model.contains("nexus")) {
                abnormalDetails.add(String.format("DeviceInfo: manufacturer=%s, brand=%s, model=%s",
                        manufacturer, brand, model));
            }

            // 方法2: 检查系统属性
            String[] googleProps = {
                    "ro.product.manufacturer",
                    "ro.product.brand",
                    "ro.product.name",
                    "ro.product.device",
                    "ro.build.flavor",
                    "ro.vendor.build.fingerprint",
                    "ro.bootloader"
            };

            for (String prop : googleProps) {
                String value = MiscUtil.getSystemProperty(prop);
                if (value != null && (value.toLowerCase().contains("google") ||
                        value.toLowerCase().contains("pixel") ||
                        value.toLowerCase().contains("nexus"))) {
                    abnormalDetails.add("Prop: "  + value);
                }
            }

            // 方法3: 检查Google特有应用
            String[] googleApps = {
                    "com.google.android.apps.pixelmigrate",// Pixel迁移工具
                    "com.google.android.apps.restore",     // Pixel数据恢复
                    "com.google.android.apps.wellbeing",   // Digital Wellbeing
                    "com.google.android.apps.safetyhub",   // Personal Safety
                    "com.google.android.apps.turbo",       // Device Health Services
                    "com.google.android.as",               // Device Personalization Services
                    "com.google.android.apps.subscriptions.red" // Google One
            };

            PackageManager pm = context.getPackageManager();
            int googleAppCount = 0;

            for (String packageName : googleApps) {
                try {
                    pm.getPackageInfo(packageName, PackageManager.GET_ACTIVITIES);
                    googleAppCount++;
                    if (googleAppCount <= 3) {
                        abnormalDetails.add("Google App: " + packageName);
                    }
                } catch (PackageManager.NameNotFoundException ignored) {
                    // 包未安装，继续检查下一个
                }
            }


            // 方法4: 检查特征文件
            String[] googleFiles = {
                    "/system/etc/sysconfig/pixel.xml",
                    "/system/etc/sysconfig/pixel_experience_2020.xml",
                    "/system/etc/sysconfig/google.xml",
                    "/system/etc/sysconfig/google_build.xml",
                    "/vendor/etc/sensors/sensor_def_google.xml"
            };

            for (String path : googleFiles) {
                if (XFile.exists(path)) {
                    abnormalDetails.add("File: " + path);
                }
            }

            if (!abnormalDetails.isEmpty()) {
                StringBuilder details = new StringBuilder();
                for (String detail : abnormalDetails) {
                    details.append(detail).append("\n");
                }

                InfoItem warning = new WarningBuilder("checkGoogleDevice", null)
                        .addDetail("check", details.toString().trim())
                        .addDetail("level", "low")
                        .build();

                reportAbnormal(warning);
         //       XLog.d(TAG, "检测到Google设备: " + details);
            }
        } catch (Exception e) {
            XLog.e(TAG, "Google设备检测失败", e);
        }
    }
    /**
     * 检测当前位置是否被模拟
     */
    private void checkMockLocation() {
        try {
            LocationManager locationManager =
                    (LocationManager) context.getSystemService(Context.LOCATION_SERVICE);

            if (locationManager != null) {
                // 先检查GPS位置
                Location gpsLocation = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);
                if (gpsLocation != null && gpsLocation.isFromMockProvider()) {
                    reportMockLocation("GPS", gpsLocation);
                    return;
                }

                // 再检查网络位置
                Location networkLocation = locationManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER);
                if (networkLocation != null && networkLocation.isFromMockProvider()) {
                    reportMockLocation("Network", networkLocation);
                    return;
                }

                // 如果都没有，检查最后一个已知位置
                Location lastLocation = locationManager.getLastKnownLocation(LocationManager.PASSIVE_PROVIDER);
                if (lastLocation != null && lastLocation.isFromMockProvider()) {
                    reportMockLocation("Passive", lastLocation);

                }
            }
        } catch (Exception e) {
            XLog.e(TAG, "Failed to check mock location", e);
        }
    }
    private void reportMockLocation(String provider, Location location) {
        String details = String.format(
                "检测到模拟位置\n提供者: %s\n经度: %f\n纬度: %f",
                provider,
                location.getLongitude(),
                location.getLatitude()
        );

        InfoItem warning = new WarningBuilder("checkMockLocation", null)
                .addDetail("check", details.trim())
                .addDetail("level", "high")
                .build();

        reportAbnormal(warning);
    }
    /**
     * 检测是否安装了具有模拟位置权限的应用
     */
    private void checkAllowMockLocation() {
        try {
            if (!Settings.Secure.getString(context.getContentResolver(),
                    Settings.Secure.ALLOW_MOCK_LOCATION).equals("0")){

                InfoItem warning = new WarningBuilder("checkAllowMockLocation", null)
                        .addDetail("check", "Allow Mock Location")
                        .addDetail("level", "low")
                        .build();

                reportAbnormal(warning);
            }
        } catch (Exception e) {
            XLog.e(TAG, "Failed to check allow mock location setting", e);
        }
    }
    /**
     * 检测是否安装了具有模拟位置权限的应用
     */
    private void checkMockLocationApps() {
        try {
            PackageManager pm = context.getPackageManager();
            List<PackageInfo> packages = pm.getInstalledPackages(PackageManager.GET_PERMISSIONS);
            List<String> mockApps = new ArrayList<>();

            for (PackageInfo packageInfo : packages) {
                if (packageInfo.requestedPermissions != null) {
                    for (String permission : packageInfo.requestedPermissions) {
                        if (permission.equals("android.permission.ACCESS_MOCK_LOCATION")) {
                            try {
                                ApplicationInfo appInfo =
                                        pm.getApplicationInfo(packageInfo.packageName, 0);
                                String appName = pm.getApplicationLabel(appInfo).toString();
                                mockApps.add(appName + " (" + packageInfo.packageName + ")");
                            } catch (PackageManager.NameNotFoundException e) {
                                mockApps.add(packageInfo.packageName);
                            }
                            break;
                        }
                    }
                }
            }

            if (!mockApps.isEmpty()) {
                String details = String.join("\n", mockApps);

                InfoItem warning = new WarningBuilder("checkMockLocationApps", null)
                        .addDetail("check", details.trim())
                        .addDetail("level", "low")
                        .build();

                reportAbnormal(warning);
            }

        } catch (Exception e) {
            XLog.e(TAG, "Failed to check mock location apps", e);
        }
    }

    /**
     * 检测设备是否设置了解锁屏幕的密码、PIN、图案或生物识别
     * false 表示未设置
     */
    private void checkScreenLock() {
        KeyguardManager keyguardManager = (KeyguardManager) context.getSystemService(Context.KEYGUARD_SERVICE);
        if (keyguardManager != null && !keyguardManager.isKeyguardSecure()) {
            InfoItem warning = new WarningBuilder("checkScreenLock", null)
                    .addDetail("check", String.valueOf(false))
                    .addDetail("level", "low")
                    .build();
            reportAbnormal(warning);
        }
    }

    @Override
    public void detect() {
        checkReflectionAvailable();
        checkException();
        checkSimCard();
        checkShizukuFiles();
        checkProxy();
        checkAdbDebug();
        checkDevelopmentSettings();
        checkVpnConnection();
        checkGoogleDevice();
        checkLineageOS();
        checkMockLocation();
        checkAllowMockLocation();
        checkMockLocationApps();
        checkScreenLock();
    }
}

```

`app/src/main/java/com/xiaoc/warlock/Core/detector/RootDetector.java`:

```java
package com.xiaoc.warlock.Core.detector;

import android.content.Context;
import android.content.pm.PackageManager;

import com.xiaoc.warlock.BuildConfig;
import com.xiaoc.warlock.Core.BaseDetector;
import com.xiaoc.warlock.Util.XCommandUtil;
import com.xiaoc.warlock.Util.XFile;
import com.xiaoc.warlock.Util.XLog;
import com.xiaoc.warlock.ui.adapter.InfoItem;
import com.xiaoc.warlock.Util.WarningBuilder;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;

public class RootDetector extends BaseDetector {
    private Method getPropMethod;
    private String TAG = "RootDetector";
    public RootDetector(Context context, EnvironmentCallback callback) {
        super(context, callback);
        initSystemProperties();

    }
    private void initSystemProperties() {
        try {
            Class<?> cls = Class.forName("android.os.SystemProperties");
            getPropMethod = cls.getMethod("get", String.class);
        } catch (Exception e) {
            XLog.e("BootloaderDetector", "反射获取SystemProperties失败", e);
            getPropMethod = null;
        }
    }
    @Override
    public void detect() {
        checkRootPackages();
        checkRootPath();
        checkRootFiles();
        checkSeLinux();
        checkUnLock();
        checkMountFile();
        checkMapsFile();
        checkTeeForLocked();
    }
    private  void checkTeeForLocked() {

        try {
            BootloaderStateChecker.BootloaderStatus status =
                    BootloaderStateChecker.detectStatus(context);
            if (status.getDisplayName().equals("UNLOCKED")){
                InfoItem warning = new WarningBuilder("checkTeeForUnlock", null)
                        .addDetail("check",  status.getDisplayName())
                        .addDetail("level", "medium")
                        .build();
                reportAbnormal(warning);
            }


        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    /**
     * 检查Root相关应用包名
     * 遍历预定义的包名列表，检查是否有已安装的Root应用
     */
    private void checkRootPackages() {
        try {
            PackageManager pm = context.getPackageManager();
            List<String> foundPackages = new ArrayList<>();

            for (String packageName : BuildConfig.ROOT_PACKAGES) {
                try {
                    pm.getPackageInfo(packageName, PackageManager.GET_ACTIVITIES);
                    foundPackages.add(packageName);
                } catch (PackageManager.NameNotFoundException e) {
                    continue;
                }
            }

            if (!foundPackages.isEmpty()) {
                StringBuilder details = new StringBuilder();
                for (String pkg : foundPackages) {
                    details.append(pkg).append("\n");
                }
                InfoItem warning = new WarningBuilder("checkRootApp", null)
                        .addDetail("check", details.toString().trim())
                        .addDetail("level", "low")
                        .build();

                reportAbnormal(warning);
            }
        }catch (Exception e){{

        }}

    }
    /**
     * 检查Root相关文件
     * 遍历预定义的文件路径列表，检查是否存在Root相关文件
     */
    private void checkRootFiles() {
        try {
            List<String> foundFiles = new ArrayList<>();

            // 遍历检查每个文件路径
            for (String path : BuildConfig.ROOT_FILES) {
                File file = new File(path);
                if (file.exists()) {
                    foundFiles.add(path);
                }
            }

            if (!foundFiles.isEmpty()) {

                StringBuilder details = new StringBuilder();
                for (String path : foundFiles) {
                    details.append(path).append("\n");
                }

                InfoItem warning = new WarningBuilder("checkRootFile", null)
                        .addDetail("check", details.toString().trim())
                        .addDetail("level", "medium")
                        .build();

                reportAbnormal(warning);
            }
        }catch (Exception e){

        }

    }
    /**
     * 检查PATH环境变量中是否包含su
     */
    private void checkRootPath() {
        try {
            String path = System.getenv("PATH");
            if (path != null) {
                String[] pathDirs = path.split(":");
                List<String> suPaths = new ArrayList<>();

                for (String dir : pathDirs) {
                    File suFile = new File(dir, "su");
                    if (suFile.exists()) {
                        suPaths.add(suFile.getAbsolutePath());
                    }
                }

                if (!suPaths.isEmpty()) {
                    StringBuilder details = new StringBuilder();
                    for (String suPath : suPaths) {
                        details.append(suPath).append("\n");
                    }

                    InfoItem warning = new WarningBuilder("checkRootPath", null)
                            .addDetail("check", details.toString().trim())
                            .addDetail("level", "medium")
                            .build();

                    reportAbnormal(warning);
                }
            }
        }catch (Exception e){

        }

    }
    /**
     * 检查seLinux安全上下文和状态
     */
    private void checkSeLinux() {
        try {
            List<String> abnormalDetails = new ArrayList<>();

            // 检查seLinux状态
            XCommandUtil.CommandResult seLinuxResult = XCommandUtil.execute("getenforce");
            if (seLinuxResult.isSuccess()) {
                String seLinuxStatus = seLinuxResult.getSuccessMsg();
                if (!seLinuxStatus.trim().equalsIgnoreCase("Enforcing")) {
                    abnormalDetails.add(seLinuxStatus.trim());
                }
            }

            // 检查seLinux上下文
            int pid = android.os.Process.myPid();
            String seLinuxPath = String.format("/proc/%d/attr/prev", pid);

            try {
                BufferedReader reader = new BufferedReader(new FileReader(seLinuxPath));
                String context = reader.readLine();
                reader.close();

                if (context != null && context.equals("u:r:zygote:s0")) {
                    abnormalDetails.add(context);
                }
            } catch (IOException e) {
            }

            if (!abnormalDetails.isEmpty()) {
                StringBuilder details = new StringBuilder();
                for (String detail : abnormalDetails) {
                    details.append(detail).append("\n");
                }

                InfoItem warning = new WarningBuilder("checkSeLinux", null)
                        .addDetail("check", details.toString().trim())
                        .addDetail("level", "medium")
                        .build();

                reportAbnormal(warning);
            }
        }catch (Exception e){

        }
        }

    /**
     * 使用反射的方法获取系统属性
     * @param prop
     * @return
     */
    private String getProperty(String prop) {
        // 先尝试使用反射方式
        if (getPropMethod != null) {
            try {
                Object value = getPropMethod.invoke(null, prop);
                if (value != null) {
                    return value.toString();
                }
            } catch (Exception e) {
                XLog.e(TAG, "反射获取属性失败: " + prop, e);
            }
        }

        // 反射失败则使用命令行方式
        XCommandUtil.CommandResult result = XCommandUtil.execute("getprop " + prop);
        if (result.isSuccess()) {
            return result.getSuccessMsg().trim();
        }
        return "";
    }

    /**
     * 检测设备是否解锁
     */
    private void checkUnLock() {
        try {
            List<String> abnormalProps = new ArrayList<>();

            for (String prop : BuildConfig.BOOTLOADER_PROPS) {
                String value = getProperty(prop).toLowerCase();
                if (value.contains("orange") || value.contains("unlocked")) {
                    abnormalProps.add(prop + ": " + value);
                }
            }
            String oemUnlockAllowed = getProperty("sys.oem_unlock_allowed");
            if ("1".equals(oemUnlockAllowed)) {
                abnormalProps.add("sys.oem_unlock_allowed: "+ oemUnlockAllowed);
            }

            if (!abnormalProps.isEmpty()) {
                StringBuilder details = new StringBuilder();
                for (String prop : abnormalProps) {
                    details.append(prop).append("\n");
                }

                InfoItem warning = new WarningBuilder("checkUnLock", null)
                        .addDetail("check", details.toString().trim())
                        .addDetail("level", "medium")
                        .build();

                reportAbnormal(warning);
            }
        } catch (Exception e) {
            XLog.e(TAG, "checkUnLock失败", e);
        }
    }
    private void checkMountFile() {
        try {
            String mountContent = XFile.readFile("/proc/mounts");
            if (mountContent != null) {
                StringBuilder details = new StringBuilder();
                boolean found = false;

                for (String line : mountContent.split("\n")) {
                    String lowerLine = line.toLowerCase();
                    for (String keyword : BuildConfig.MOUNT_KEYWORDS) {
                        if (lowerLine.contains(keyword)) {
                            details.append("[").append(keyword).append("]: ")
                                    .append(line).append("\n");
                            found = true;
                        }
                    }
                }

                if (found) {
                    InfoItem warning = new WarningBuilder("checkMountFile", null)
                            .addDetail("check", details.toString().trim())
                            .addDetail("level", "medium")
                            .build();

                    reportAbnormal(warning);
                }
            }
        } catch (Exception e) {
            XLog.e(TAG, "Failed to check mount file", e);
        }
    }

    private void checkMapsFile() {
        try {
            String mapsContent = XFile.readFile("/proc/self/maps");
            if (mapsContent != null) {
                StringBuilder details = new StringBuilder();
                boolean found = false;

                for (String line : mapsContent.split("\n")) {
                    String lowerLine = line.toLowerCase();
                    for (String keyword : BuildConfig.MAPS_KEYWORDS) {
                        if (lowerLine.contains(keyword)) {
                            details.append("[").append(keyword).append("]: ")
                                    .append(line).append("\n");
                            found = true;
                        }
                    }
                }

                if (found) {
                    InfoItem warning = new WarningBuilder("checkMapsFile", null)
                            .addDetail("check", details.toString().trim())
                            .addDetail("level", "high")
                            .build();

                    reportAbnormal(warning);
                }
            }
        } catch (Exception e) {
            XLog.e(TAG, "Failed to check maps file", e);
        }
    }
}

```

`app/src/main/java/com/xiaoc/warlock/Core/detector/SandboxDetector.java`:

```java
package com.xiaoc.warlock.Core.detector;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.Application;
import android.content.Context;
import android.os.Build;
import android.os.Handler;
import android.os.Looper;

import androidx.annotation.RequiresApi;

import com.xiaoc.warlock.Core.BaseDetector;
import com.xiaoc.warlock.MainActivity;
import com.xiaoc.warlock.Util.WarningBuilder;
import com.xiaoc.warlock.Util.XCommandUtil;
import com.xiaoc.warlock.Util.XLog;
import com.xiaoc.warlock.manager.ServerManager;
import com.xiaoc.warlock.ui.adapter.InfoItem;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;

public class SandboxDetector extends BaseDetector  {
    private static final String TAG = "SandboxDetector";

    public SandboxDetector(Context context, EnvironmentCallback callback) {
        super(context, callback);
    }
    @Override
    public void detect() {
        checkSandbox();
        checkSandboxByActivityCount();
        checkActivityManagerProxy();

    }
    public static ArrayList<Object> choose(Class<?> targetClass, boolean checkInherit) {
        ArrayList<Object> results = new ArrayList<>();
        try {
            // 获取 ActivityThread 实例
            Class<?> activityThreadClass = Class.forName("android.app.ActivityThread");
            Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod("currentActivityThread");
            currentActivityThreadMethod.setAccessible(true);
            Object currentActivityThread = currentActivityThreadMethod.invoke(null);

            // 获取 mActivities
            Field mActivitiesField = activityThreadClass.getDeclaredField("mActivities");
            mActivitiesField.setAccessible(true);
            Map<Object, Object> activities = (Map<Object, Object>) mActivitiesField.get(currentActivityThread);

            // 遍历所有 Activity
            for (Object record : activities.values()) {
                Field activityField = record.getClass().getDeclaredField("activity");
                activityField.setAccessible(true);
                Object activity = activityField.get(record);

                if (activity != null) {
                    if (checkInherit) {
                        // 检查继承关系
                        if (targetClass.isAssignableFrom(activity.getClass())) {
                            results.add(activity);
                        }
                    } else {
                        // 严格检查类型
                        if (activity.getClass() == targetClass) {
                            results.add(activity);
                        }
                    }
                }
            }
        } catch (Exception e) {
            XLog.e(TAG, "Error during memory scan", e);
        }
        return results;
    }
    private void checkSandbox() {
        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.Q) {
            XCommandUtil.CommandResult result = XCommandUtil.execute("ps -ef");

            if (!result.isSuccess()) {
                XLog.e(TAG, "ps check error: " + result.getErrorMsg());
                return;
            }

            String output = result.getSuccessMsg();
            XLog.d("tttg",output);
            String[] lines = output.split("\n");
            int processCount = 0;
            StringBuilder processDetails = new StringBuilder();

            for (String line : lines) {
                if (!line.contains("warlock")) {
                    processCount++;
                    processDetails.append(line).append("\n");
                    XLog.i(TAG, "ps -ef match -> " + line);
                }
            }

            if (processCount > 2) {
                InfoItem warning = new WarningBuilder("checkSandbox", null)
                        .addDetail("check", processDetails.toString().trim())
                        .addDetail("level", "high")
                        .build();
                reportAbnormal(warning);
            } else {
                XLog.d(TAG, "No sandbox detected in process check");
            }
        }
    }
    private void checkSandboxByActivityCount() {
        try {
            ArrayList<Object> activities = choose(Activity.class, true);
            if (activities != null) {
                ArrayList<Object> suspiciousActivities = new ArrayList<>();
                XLog.e("choose", String.valueOf(activities));
                // 过滤掉我们自己的 Activity
                for (Object activity : activities) {
                    String name = activity.getClass().getName();
                    if (!name.equals(MainActivity.class.getName())) {
                        suspiciousActivities.add(activity);
                    }
                }

                // 如果发现可疑的 Activity
                if (suspiciousActivities.size() >= 1) {
                    StringBuilder details = new StringBuilder();
                    for (Object obj : suspiciousActivities) {
                        details.append(obj.getClass().getName()).append("\n");
                    }

                    InfoItem warning = new WarningBuilder("checkSandboxMemory", null)
                            .addDetail("check", "checkSandboxMemory")
                            .addDetail("details", details.toString().trim())
                            .addDetail("level", "high")
                            .build();

                    reportAbnormal(warning);
                }
            }
        } catch (Exception e) {
            XLog.e(TAG, "Error during sandbox memory check", e);
        }
    }
    private void checkActivityManagerProxy() {
        try {
            List<String> abnormalDetails = new ArrayList<>();

            // 方法1: 检查ActivityManagerNative代理
            checkAMNProxy(abnormalDetails);

            // 方法2: 检查ActivityTaskManager代理 (Android 10及以上)
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                checkATMProxy(abnormalDetails);
            }

            // 方法3: 检查ActivityManagerService代理
            checkAMSProxy(abnormalDetails);

            if (!abnormalDetails.isEmpty()) {
                StringBuilder details = new StringBuilder();
                for (String detail : abnormalDetails) {
                    details.append(detail).append("\n");
                }

                InfoItem warning = new WarningBuilder("checkActivityManagerProxy", null)
                        .addDetail("check", details.toString().trim())
                        .addDetail("level", "high")
                        .build();

                reportAbnormal(warning);
            }
        } catch (Exception e) {
            XLog.e(TAG, "Activity manager proxy detection failed", e);
        }
    }

    /**
     * 检查是否为系统正常的AIDL代理类
     */
    private boolean isSystemStubProxy(String className) {
        return className.contains("$Stub$Proxy") || // 系统AIDL代理
                className.contains(".Stub$Proxy") ||  // 系统AIDL代理的另一种形式
                className.endsWith("Stub");          // 系统AIDL存根
    }

    /**
     * 检查ActivityManagerNative代理
     */
    private void checkAMNProxy(List<String> abnormalDetails) {
        try {
            Class<?> amnClass = Class.forName("android.app.ActivityManagerNative");
            Method getDefaultMethod = amnClass.getDeclaredMethod("getDefault");
            getDefaultMethod.setAccessible(true);

            Object activityManager = getDefaultMethod.invoke(null);

            if (activityManager != null) {
                String className = activityManager.getClass().getName();

                // 排除系统正常的AIDL代理
                if (!isSystemStubProxy(className)) {
                    boolean isProxy = Proxy.isProxyClass(activityManager.getClass());

                    if (isProxy || className.contains("Proxy") ||
                            className.contains("proxy")) {
                        abnormalDetails.add(String.format("Suspicious AMN Proxy: %s", className));

                        if (isProxy) {
                            Object handler = Proxy.getInvocationHandler(activityManager);
                            if (handler != null) {
                                String handlerClass = handler.getClass().getName();
                                // 检查是否为可疑的代理处理器
                                if (!handlerClass.startsWith("android.") &&
                                        !handlerClass.startsWith("com.android.")) {
                                    abnormalDetails.add(String.format("Suspicious Handler: %s",
                                            handlerClass));
                                }
                            }
                        }
                    }
                }
            }
        } catch (Exception ignored) {
        }
    }

    /**
     * 检查ActivityTaskManager代理 (Android 10+)
     */
    @RequiresApi(api = Build.VERSION_CODES.Q)
    private void checkATMProxy(List<String> abnormalDetails) {
        try {
            Class<?> atmClass = Class.forName("android.app.ActivityTaskManager");
            @SuppressLint("BlockedPrivateApi")
            Method getServiceMethod = atmClass.getDeclaredMethod("getService");
            getServiceMethod.setAccessible(true);

            Object taskManager = getServiceMethod.invoke(null);

            if (taskManager != null) {
                String className = taskManager.getClass().getName();

                // 排除系统正常的AIDL代理
                if (!isSystemStubProxy(className)) {
                    boolean isProxy = Proxy.isProxyClass(taskManager.getClass());

                    if (isProxy || className.contains("Proxy") ||
                            className.contains("proxy")) {
                        abnormalDetails.add(String.format("Suspicious ATM Proxy: %s", className));
                    }
                }
            }
        } catch (Exception ignored) {
        }
    }

    /**
     * 检查ActivityManagerService代理
     */
    private void checkAMSProxy(List<String> abnormalDetails) {
        try {
            Class<?> activityManagerClass = Class.forName("android.app.ActivityManager");
            Method getServiceMethod = activityManagerClass.getDeclaredMethod("getService");
            getServiceMethod.setAccessible(true);

            Object ams = getServiceMethod.invoke(null);

            if (ams != null) {
                String className = ams.getClass().getName();

                // 排除系统正常的AIDL代理
                if (!isSystemStubProxy(className)) {
                    boolean isProxy = Proxy.isProxyClass(ams.getClass());

                    if (isProxy || className.contains("Proxy") ||
                            className.contains("proxy")) {
                        abnormalDetails.add(String.format("Suspicious AMS Proxy: %s", className));

                        if (isProxy) {
                            Object handler = Proxy.getInvocationHandler(ams);
                            if (handler != null) {
                                String handlerClass = handler.getClass().getName();
                                // 检查是否为可疑的代理处理器
                                if (!handlerClass.startsWith("android.") &&
                                        !handlerClass.startsWith("com.android.")) {
                                    if (handlerClass.contains("parallel") ||
                                            handlerClass.contains("multiple") ||
                                            handlerClass.contains("multi") ||
                                            handlerClass.contains("clone")) {
                                        abnormalDetails.add(String.format("Multi-App Handler: %s",
                                                handlerClass));
                                    } else {
                                        abnormalDetails.add(String.format("Suspicious Handler: %s",
                                                handlerClass));
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } catch (Exception ignored) {
        }
    }

}
```

`app/src/main/java/com/xiaoc/warlock/Core/detector/SignatureDetector.java`:

```java
package com.xiaoc.warlock.Core.detector;

import android.content.Context;
import android.content.pm.PackageInfo;

import com.xiaoc.warlock.Core.BaseDetector;
import com.xiaoc.warlock.Util.WarningBuilder;
import com.xiaoc.warlock.Util.XLog;
import com.xiaoc.warlock.ui.adapter.InfoItem;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.LinkedHashMap;
import java.util.Map;

public class SignatureDetector extends BaseDetector {
    private static final String TAG = "SignatureDetector";

    public SignatureDetector(Context context, EnvironmentCallback callback) {
        super(context, callback);
    }

    @Override
    public void detect() {
        checkPackageInfoCreator();
    }

    /**
     * 检测PackageInfo.CREATOR的ClassLoader是否被替换
     */
    private void checkPackageInfoCreator() {
        try {
            // 获取PackageInfo.CREATOR字段
            Field creatorField = PackageInfo.class.getDeclaredField("CREATOR");
            creatorField.setAccessible(true);
            Object creator = creatorField.get(null);

            if (creator != null) {
                // 获取CREATOR的ClassLoader
                ClassLoader creatorClassLoader = creator.getClass().getClassLoader();
                // 获取系统ClassLoader
                ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();

                if (creatorClassLoader == null || systemClassLoader == null) {
                    XLog.w(TAG, "ClassLoader is null");
                    return;
                }

                String creatorLoaderName = creatorClassLoader.getClass().getName();
                String systemLoaderName = systemClassLoader.getClass().getName();

                // 检查ClassLoader类型
                if (systemLoaderName.equals(creatorLoaderName)) {
                    // 系统的应该是BootClassLoader，而用户的是PathClassLoader
                    // 如果相等说明被替换了
                    Map<String, String> details = new LinkedHashMap<>();
                    details.put("creatorLoader", creatorLoaderName);
                    details.put("systemLoader", systemLoaderName);
                    details.put("creator", creator.getClass().getName());

                    InfoItem warning = new WarningBuilder("checkPackageInfoCreator", null)
                            .addDetail("check", details.toString())
                            .addDetail("level", "high")
                            .build();

                    reportAbnormal(warning);
                } else {

                }

                // 额外检查CREATOR的实现类
                checkCreatorImplementation(creator);
            }
        } catch (Exception e) {
            XLog.e(TAG, "Failed to check PackageInfo.CREATOR", e);
        }
    }

    /**
     * 检查CREATOR的具体实现
     */
    private void checkCreatorImplementation(Object creator) {
        try {
            // 检查CREATOR是否是预期的Parcelable.Creator实现
            if (!creator.getClass().getName().contains("android.content")) {
                Map<String, String> details = new LinkedHashMap<>();
                details.put("creatorClass", creator.getClass().getName());
                details.put("expectedPackage", "android.content");

                InfoItem warning = new WarningBuilder("checkCreatorImplementation", null)
                        .addDetail("check", details.toString())
                        .addDetail("level", "high")
                        .build();

                reportAbnormal(warning);
            }

            // 检查CREATOR的方法实现
            Method[] methods = creator.getClass().getDeclaredMethods();
            boolean hasCreateFromParcel = false;
            boolean hasNewArray = false;

            for (Method method : methods) {
                if (method.getName().equals("createFromParcel")) {
                    hasCreateFromParcel = true;
                } else if (method.getName().equals("newArray")) {
                    hasNewArray = true;
                }
            }

            if (!hasCreateFromParcel || !hasNewArray) {
                InfoItem warning = new WarningBuilder("checkCreatorMethods", null)
                        .addDetail("check", "CREATOR方法实现异常")
                        .addDetail("level", "high")
                        .addDetail("description", "PackageInfo.CREATOR缺少必要的方法实现")
                        .addDetail("hasCreateFromParcel", String.valueOf(hasCreateFromParcel))
                        .addDetail("hasNewArray", String.valueOf(hasNewArray))
                        .build();

                reportAbnormal(warning);
            }
        } catch (Exception e) {
            XLog.e(TAG, "Failed to check CREATOR implementation", e);
        }
    }
}

```

`app/src/main/java/com/xiaoc/warlock/Core/detector/VirtualDetector.java`:

```java
package com.xiaoc.warlock.Core.detector;

import android.content.Context;
import android.hardware.Sensor;
import android.hardware.SensorManager;
import android.hardware.camera2.CameraManager;

import com.xiaoc.warlock.BuildConfig;
import com.xiaoc.warlock.Core.BaseDetector;
import com.xiaoc.warlock.Util.MiscUtil;
import com.xiaoc.warlock.Util.WarningBuilder;
import com.xiaoc.warlock.Util.XCommandUtil;
import com.xiaoc.warlock.Util.XFile;
import com.xiaoc.warlock.Util.XLog;
import com.xiaoc.warlock.ui.adapter.InfoItem;

import java.io.File;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;

public class VirtualDetector extends BaseDetector {
    private String TAG = "VirtualDetector";
    public VirtualDetector(Context context, EnvironmentCallback callback) {
        super(context, callback);
    }

    @Override
    public void detect() {
        checkEmulator();
        checkEmulatorMounts();
        checkSensorSize();
        checkEmulatorProps();
        checkCameraSize();
    }


    /**
     * 检测设备的摄像头个数
     */
    private void checkCameraSize() {
        try {
            CameraManager manager = (CameraManager) context.getSystemService(Context.CAMERA_SERVICE);
            if (manager == null) return;

            String[] cameraIds = manager.getCameraIdList();


            if (cameraIds.length < BuildConfig.CAMERA_MINIMUM_QUANTITY_LIMIT) {
                InfoItem warning = new WarningBuilder("checkCameraSize", null)
                        .addDetail("cameraSize", String.valueOf(cameraIds.length))
                        .addDetail("level", "medium")
                        .build();

                reportAbnormal(warning);
            }
        } catch (Exception e) {
        }
    }
    /**
     * 检查模拟器特征
     */
    private void checkEmulator() {
        try {
            List<String> abnormalDetails = new ArrayList<>();

            // 检查CPU架构
            String arch = System.getProperty("os.arch");
            if (arch != null && (arch.contains("x86_64") || arch.contains("x86"))) {
                abnormalDetails.add(arch);
            }

            // 检查特征文件
            List<String> foundFiles = new ArrayList<>();
            for (String path : BuildConfig.EMULATOR_FILES) {
                if (XFile.exists(path)) {
                    foundFiles.add(path);
                }
            }

            // 如果特征文件数量大于2个，添加到异常列表
            if (foundFiles.size() > 2) {
                abnormalDetails.addAll(foundFiles);
            }

            if (!abnormalDetails.isEmpty()) {
                StringBuilder details = new StringBuilder();
                for (String detail : abnormalDetails) {
                    details.append(detail).append("\n");
                }

                InfoItem warning = new WarningBuilder("checkEmulator", null)
                        .addDetail("check", details.toString().trim())
                        .addDetail("level", "high")
                        .build();

                reportAbnormal(warning);
                XLog.d(TAG, "检测到模拟器特征: " + details);
            }
        } catch (Exception e) {
            XLog.e(TAG, "检查模拟器状态失败", e);
        }
    }
    /**
     * 检查模拟器挂载点
     */
    private void checkEmulatorMounts() {
        try {
            List<String> abnormalDetails = new ArrayList<>();

            XCommandUtil.CommandResult result = XCommandUtil.execute("cat /proc/mounts");
            if (result.isSuccess()) {
                String mounts = result.getSuccessMsg();

                for (String path : BuildConfig.EMULATOR_MOUNT_PATHS) {
                    if (mounts.contains(path)) {
                        abnormalDetails.add(path);
                    }
                }
            }

            // 如果发现异常，创建警告
            if (!abnormalDetails.isEmpty()) {
                StringBuilder details = new StringBuilder();
                for (String detail : abnormalDetails) {
                    details.append(detail).append("\n");
                }

                InfoItem warning = new WarningBuilder("checkEmulatorMount", null)
                        .addDetail("check", details.toString().trim())
                        .addDetail("level", "high")
                        .build();

                reportAbnormal(warning);
            }
        }catch (Exception e){

        }

    }
    /**
     * 检查传感器数量
     */
    private void checkSensorSize(){
        try {
            //3,检测传感器类型,支持的全部类型传感器
            SensorManager sm = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
            List<Sensor> sensorlist = sm.getSensorList(Sensor.TYPE_ALL);

            ArrayList<Integer> sensorTypeS = new ArrayList<>();
            for (Sensor sensor : sensorlist) {
                //获取传感器类型
                int type = sensor.getType();
                if (!sensorTypeS.contains(type)) {
                    //发现一种类型则添加一种类型
                    sensorTypeS.add(type);
                }
            }

            //我们认为传感器少于20个则认为是风险设备
            if (sensorlist.size() < BuildConfig.SENSOR_MINIMUM_QUANTITY_LIMIT) {
                InfoItem warning = new WarningBuilder("checkSensorSize", null)
                        .addDetail("sensorSize", String.valueOf(sensorlist.size()))
                        .addDetail("level", "high")
                        .build();
                reportAbnormal(warning);

            }
        }catch (Exception e){

        }
    }

    /**
     * 检测设备上的prop是否有模拟器的属性
     */
    private void checkEmulatorProps() {
        try {


            List<String> foundProps = new ArrayList<>();
            for (String prop : BuildConfig.QEMU_PROPS) {
                String value = MiscUtil.getSystemProperty(prop);
                if (value != null && !value.isEmpty()) {
                    foundProps.add(prop + "=" + value);
                }
            }

            if (foundProps.size() >= 3) {
                StringBuilder details = new StringBuilder();
                for (String prop : foundProps) {
                    details.append(prop).append("\n");
                }

                    InfoItem warning = new WarningBuilder("checkEmulatorProps", null)
                            .addDetail("check", details.toString().trim())
                            .addDetail("level", "high")
                            .build();

                    reportAbnormal(warning);


            }
        } catch (Exception e) {
        }
    }
}

```

`app/src/main/java/com/xiaoc/warlock/Core/detector/XposedDetector.java`:

```java
package com.xiaoc.warlock.Core.detector;

import android.content.Context;

import com.xiaoc.warlock.BuildConfig;
import com.xiaoc.warlock.Core.BaseCollector;
import com.xiaoc.warlock.Core.BaseDetector;
import com.xiaoc.warlock.Util.WarningBuilder;
import com.xiaoc.warlock.Util.XFile;
import com.xiaoc.warlock.Util.XLog;
import com.xiaoc.warlock.ui.adapter.InfoItem;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;

public class XposedDetector extends BaseDetector {
    private String TAG = "XposedDetector";
    public XposedDetector(Context context, EnvironmentCallback callback) {
        super(context, callback);
    }

    @Override
    public void detect() {
        checkXposed();
    }
    private void checkXposed() {
        try {

            List<String> foundFiles = new ArrayList<>();
            for (String path : BuildConfig.XPOSED_PATHS) {
                if (XFile.exists(path)) {
                    foundFiles.add(path);
                }
            }

            if (!foundFiles.isEmpty()) {
                StringBuilder details = new StringBuilder();
                for (String file : foundFiles) {
                    details.append(file).append("\n");
                }

                InfoItem warning = new WarningBuilder("checkXposedFile", null)
                        .addDetail("check", details.toString().trim())
                        .addDetail("level", "medium")
                        .build();
                reportAbnormal(warning);
            }
        } catch (Exception e) {
        }
    }
}

```

`app/src/main/java/com/xiaoc/warlock/MainActivity.java`:

```java
package com.xiaoc.warlock;

import android.content.Context;
import android.os.Bundle;
import androidx.appcompat.app.AppCompatActivity;
import com.xiaoc.warlock.Core.CollectCallback;
import com.xiaoc.warlock.Core.Warlock;
import com.xiaoc.warlock.Util.API;
import com.xiaoc.warlock.Util.NativeEngine;
import com.xiaoc.warlock.Util.XLog;
import com.xiaoc.warlock.network.NetworkClient;
import com.xiaoc.warlock.ui.MainUI;
import org.json.JSONObject;
import java.io.BufferedReader;
import java.io.FileReader;


public class MainActivity extends AppCompatActivity implements CollectCallback {
    private static final String TAG = "MainActivity";
    private Context context;
    private boolean javaCollectComplete = false;
    private boolean nativeCollectComplete = false;
    private NetworkClient networkClient;
    
    // 公共静态变量，供Fragment访问
    public static boolean sBothCollectComplete = false;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        //CrashReport.initCrashReport(getApplicationContext(), "56552ffeab", false);
        initEnvironment();
        startCollect();
        XLog.i("boot->"+String.valueOf(getSystemBootTime()));
    }
    public static long getSystemBootTime() {
        try {
            String uptime = new BufferedReader(new FileReader("/proc/uptime"))
                    .readLine().split(" ")[0]; // 读取第一个值（单位：秒）
            return System.currentTimeMillis() - (long)(Double.parseDouble(uptime) * 1000);
        } catch (Exception e) {
            return 0;
        }
    }
    private void initEnvironment() {
        context = this;
        new MainUI(this);
        API.setHideShowWarning();
        XLog.init(this, XLog.DEBUG, true);
        
        // 初始化网络客户端
        networkClient = NetworkClient.getInstance(this);
    }

    private void startCollect() {
        // 启动Java层收集
        startJavaCollect();
        // 启动Native层收集
        NativeEngine.startCollect(this);
    }

    private void startJavaCollect() {
        new Thread(() -> {
            Warlock warlock = Warlock.getInstance(context);
            warlock.collectFingerprint();
            runOnUiThread(() -> {
                javaCollectComplete = true;
                checkAndProcessResult();
            });
        }).start();
    }

    @Override
    public void onNativeCollectComplete() {
        runOnUiThread(() -> {
            nativeCollectComplete = true;
            checkAndProcessResult();
            XLog.d(TAG, "Native collection completed");
        });
    }

    private void checkAndProcessResult() {
        XLog.d(TAG, "Check result - Java: " + javaCollectComplete + ", Native: " + nativeCollectComplete);
        if (!javaCollectComplete || !nativeCollectComplete) {
            return;
        }

        // 设置完成标志
        sBothCollectComplete = true;
        XLog.d(TAG, "Both Java and Native collection completed!");
    }
    
    /**
     * 检查指纹收集是否完成
     * @return 如果Java和Native层都完成，返回true；否则返回false
     */
    public static boolean isCollectionComplete() {
        return sBothCollectComplete;
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        cleanup();
    }

    private void cleanup() {
        javaCollectComplete = false;
        nativeCollectComplete = false;
        // 不重置静态变量，因为其他组件可能依赖这些状态
    }
}
```

`app/src/main/java/com/xiaoc/warlock/Provider/AppProvider.java`:

```java
package com.xiaoc.warlock.Provider;

import android.content.ContentProvider;
import android.content.ContentValues;
import android.content.Intent;
import android.database.Cursor;
import android.net.Uri;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.xiaoc.warlock.Util.AppChecker;
import com.xiaoc.warlock.Util.XLog;
import com.xiaoc.warlock.service.WarLockServer;

public class AppProvider extends ContentProvider {
    static {
        System.loadLibrary("warlockCore");
    }

    @Override
    public boolean onCreate() {
        startWarLockService();
        AppChecker.checkReflectionSupport();
        return true;
    }
    private void startWarLockService() {
        if (getContext() != null) {
            Intent intent = new Intent(getContext(), WarLockServer.class);
            getContext().startService(intent);
        }
    }
    @Nullable
    @Override
    public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) {
        return null;
    }

    @Nullable
    @Override
    public String getType(@NonNull Uri uri) {
        return "";
    }

    @Nullable
    @Override
    public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) {
        return null;
    }

    @Override
    public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) {
        return 0;
    }

    @Override
    public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) {
        return 0;
    }

}

```

`app/src/main/java/com/xiaoc/warlock/Util/API.java`:

```java
package com.xiaoc.warlock.Util;

import android.annotation.SuppressLint;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class API {
    @SuppressLint({"PrivateApi"})
    public static void setHideShowWarning () {
        try {
            Class.forName("android.content.pm.PackageParser$Package").getDeclaredConstructor(String.class).setAccessible(true);
        } catch (Exception e) {
            e.printStackTrace();
        }
        try {
            Class<?> cls = Class.forName("android.app.ActivityThread");
            Method declaredMethod = cls.getDeclaredMethod("currentActivityThread", new Class[0]);
            declaredMethod.setAccessible(true);
            Object invoke = declaredMethod.invoke(null, new Object[0]);
            Field declaredField = cls.getDeclaredField("mHiddenApiWarningShown");
            declaredField.setAccessible(true);
            declaredField.setBoolean(invoke, true);
            XLog.d("setHideShowWarning Sueecss");
        } catch (Exception e2) {
            e2.printStackTrace();
        }

    }
}

```

`app/src/main/java/com/xiaoc/warlock/Util/AppChecker.java`:

```java
package com.xiaoc.warlock.Util;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;

public class AppChecker {
    private static boolean isReflectionSupported = false;

    private AppChecker() {}
    private static  List<String> nonMatchingStack = new ArrayList<>();
    private static boolean isStackTraceBbnormal = false;
    public static void checkReflectionSupport() {
        try {
            Class<?> vmRuntimeClass = Class.forName("dalvik.system.VMRuntime");
            Method getRuntime = vmRuntimeClass.getDeclaredMethod("getRuntime");
            Method setHiddenApiExemptions = vmRuntimeClass.getDeclaredMethod("setHiddenApiExemptions", String[].class);
            isReflectionSupported = true;
        } catch (Exception e) {
            isReflectionSupported = false;
        }
    }

    public static boolean isReflectionSupported() {
        return isReflectionSupported;
    }
    public static void checkStackTrace(Exception e) {
        // 获取异常堆栈
        StackTraceElement[] stackTraceElements = e.getStackTrace();
        // 遍历堆栈中的每一行
        for (StackTraceElement element : stackTraceElements) {
            String className = element.getClassName();
            XLog.e(className);
            if (!className.contains("android.app") &&
                    !className.contains("android.os") &&
                    !className.contains("android.internal")&&
                    !className.contains("com.xiaoc.warlock")&&
                    !className.contains("java.lang.reflect")) {
                isStackTraceBbnormal = true;
                nonMatchingStack.add(element.toString());
            }
        }
    }
    public static boolean isStackTraceBbnormal() {
        return isStackTraceBbnormal;
    }
    public static List<String> getStackTraceBbnormal(){
        return nonMatchingStack;
    }
}

```

`app/src/main/java/com/xiaoc/warlock/Util/ClipboardUtil.java`:

```java
package com.xiaoc.warlock.Util;

import android.content.ClipData;
import android.content.ClipboardManager;
import android.content.Context;
import android.widget.Toast;

import com.xiaoc.warlock.ui.adapter.InfoItem;

public class ClipboardUtil {
    public static void copyInfoItemToClipboard(Context context, InfoItem item, boolean isEnvironmentInfo) {
        StringBuilder content = new StringBuilder();

        if (isEnvironmentInfo) {
            // 环境检测信息的复制格式
            content.append("【").append(item.getTitle()).append("】\n");
            for (InfoItem.DetailItem detail : item.getDetails()) {
                content.append("- ").append(detail.getKey())
                        .append(": ")
                        .append(detail.getValue())
                        .append("\n");
            }
        } else {
            // 设备指纹信息的复制格式
            content.append(item.getTitle()).append("\n");
            for (InfoItem.DetailItem detail : item.getDetails()) {
                content.append(detail.getKey())
                        .append("：")
                        .append(detail.getValue())
                        .append("\n");
            }
        }

        ClipboardManager clipboard = (ClipboardManager)
                context.getSystemService(Context.CLIPBOARD_SERVICE);
        ClipData clip = ClipData.newPlainText(
                isEnvironmentInfo ? "环境检测信息" : "设备信息",
                content.toString()
        );

        if (clipboard != null) {
            clipboard.setPrimaryClip(clip);
            String toastMsg = isEnvironmentInfo ? "已复制检测信息" : "已复制设备信息";
            Toast.makeText(context, toastMsg, Toast.LENGTH_SHORT).show();
        }
    }
}
```

`app/src/main/java/com/xiaoc/warlock/Util/InfoValue.java`:

```java
package com.xiaoc.warlock.Util;

public class InfoValue {
    private int s;          // 状态: 0成功, -1失败, -2未获取
    private Object v;       // 值，可以是String或List

    public InfoValue() {
        this.s = -2;
        this.v = null;
    }

    public InfoValue(int status, Object value) {
        this.s = status;
        this.v = value;
    }

    public static InfoValue success(Object value) {
        return new InfoValue(0, value);
    }

    public static InfoValue fail() {
        return new InfoValue(-1, null);
    }

    public static InfoValue notCollected() {
        return new InfoValue(-2, null);
    }
}

```

`app/src/main/java/com/xiaoc/warlock/Util/MiscUtil.java`:

```java
package com.xiaoc.warlock.Util;

import android.os.Build;

import java.lang.reflect.Method;

public class MiscUtil {
    public static String getSystemProperty(String prop) {
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                // 使用反射获取 SystemProperties
                Class<?> systemProperties = Class.forName("android.os.SystemProperties");
                Method getMethod = systemProperties.getMethod("get", String.class);
                Object value = getMethod.invoke(null, prop);
                return value != null ? value.toString() : "";
            } else {
                // Android P 以下版本直接使用 SystemProperties
                Class<?> systemProperties = Class.forName("android.os.SystemProperties");
                Method getMethod = systemProperties.getMethod("get", String.class);
                Object value = getMethod.invoke(null, prop);
                return value != null ? value.toString() : "";
            }
        } catch (Exception e) {
            XLog.e("MiscUtil", "Failed to get property " + prop + ": " + e.getMessage());
            return "";
        }
    }
}

```

`app/src/main/java/com/xiaoc/warlock/Util/NativeEngine.java`:

```java
package com.xiaoc.warlock.Util;

import com.xiaoc.warlock.Core.CollectCallback;
import com.xiaoc.warlock.Core.DetectCallback;

import java.util.Map;

public class NativeEngine {

//    static {
//        // 加载本地库
//        System.loadLibrary("warlockCore");
//    }

    // 声明本地方法
    public static native String popen(String command);

    public native int open(String path, int flags);
    public static native void startCollect(CollectCallback callback);
    public static native String getCollectedInfo();
    public static native void startDetect(DetectCallback callback);
    public static native void stopDetect();  // 这个方法现在会调用cleanup
}

```

`app/src/main/java/com/xiaoc/warlock/Util/WarningBuilder.java`:

```java
package com.xiaoc.warlock.Util;

import com.xiaoc.warlock.ui.adapter.InfoItem;

public class WarningBuilder {
    private InfoItem infoItem;

    public WarningBuilder(String title, String content) {
        this.infoItem = new InfoItem(title, content);
    }

    public WarningBuilder addDetail(String key, String value) {
        infoItem.addDetail(key, value);
        return this;
    }

    public InfoItem build() {
        return infoItem;
    }
}
```

`app/src/main/java/com/xiaoc/warlock/Util/XCommandUtil.java`:

```java
package com.xiaoc.warlock.Util;

import android.os.Handler;
import android.os.Looper;

import java.io.BufferedReader;
import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;

public class XCommandUtil {
    private static final int BUFFER_SIZE = 16384;// 增加缓冲区大小

    /**
     * 执行shell命令，默认返回命令执行结果
     * @param command 命令
     * @return 命令执行结果
     */
    public static CommandResult execute(String command) {
        return execute(command, true);
    }

    /**
     * 执行shell命令
     * @param command 命令
     * @param needResult 是否需要返回结果
     */
    public static CommandResult execute(String command, boolean needResult) {
        Process process = null;
        try {
            // 使用ProcessBuilder替代Runtime.exec
            ProcessBuilder processBuilder = new ProcessBuilder();
            processBuilder.command("sh", "-c", command);
            process = processBuilder.start();

            if (needResult) {
                // 使用独立线程读取输出流和错误流
                StreamReader outputReader = new StreamReader(process.getInputStream());
                StreamReader errorReader = new StreamReader(process.getErrorStream());

                // 启动读取线程
                Thread outputThread = new Thread(outputReader);
                Thread errorThread = new Thread(errorReader);
                outputThread.start();
                errorThread.start();

                // 等待进程执行完成
                int exitValue = process.waitFor();

                // 等待读取线程完成
                outputThread.join(5000);  // 5秒超时
                errorThread.join(5000);   // 5秒超时

                return new CommandResult(
                        exitValue,
                        outputReader.getOutput(),
                        errorReader.getOutput()
                );
            }

            process.waitFor();
            return new CommandResult(process.exitValue(), "", "");

        } catch (Exception e) {
            e.printStackTrace();
            return new CommandResult(-1, "", e.getMessage());
        } finally {
            if (process != null) {
                process.destroy();
            }
        }
    }
    private static class StreamReader implements Runnable {
        private final InputStream inputStream;
        private final StringBuilder output = new StringBuilder();

        StreamReader(InputStream inputStream) {
            this.inputStream = inputStream;
        }

        @Override
        public void run() {
            try (BufferedReader reader = new BufferedReader(
                    new InputStreamReader(inputStream), BUFFER_SIZE)) {
                char[] buffer = new char[BUFFER_SIZE];
                int len;
                while ((len = reader.read(buffer)) > 0) {
                    output.append(buffer, 0, len);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        String getOutput() {
            return output.toString().trim();
        }
    }
    /**
     * 异步执行shell命令
     * @param command 命令
     * @param callback 回调
     */
    public static void executeAsync(String command, CommandCallback callback) {
        new Thread(() -> {
            CommandResult result = execute(command);
            if (callback != null) {
                new Handler(Looper.getMainLooper()).post(() -> {
                    callback.onComplete(result);
                });
            }
        }).start();
    }

    /**
     * 使用root权限执行命令
     * @param command 命令
     * @return 命令执行结果
     */
    public static CommandResult executeAsRoot(String command) {
        return execute("su -c " + command);
    }

    /**
     * 检查是否有root权限
     * @return 是否有root权限
     */
    public static boolean hasRootPermission() {
        CommandResult result = execute("su -c ls /data");
        return result.isSuccess();
    }

    /**
     * 获取系统属性
     * @param key 属性key
     * @return 属性值
     */
    public static String getSystemProperty(String key) {
        CommandResult result = execute("getprop " + key);
        return result.isSuccess() ? result.successMsg : "";
    }

    /**
     * 安全关闭流
     */
    private static void closeQuietly(Closeable closeable) {
        if (closeable != null) {
            try {
                closeable.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * 命令执行结果
     */
    public static class CommandResult {
        private int exitValue;
        private String successMsg;
        private String errorMsg;

        public CommandResult(int exitValue, String successMsg, String errorMsg) {
            this.exitValue = exitValue;
            this.successMsg = successMsg;
            this.errorMsg = errorMsg;
        }

        public boolean isSuccess() {
            return exitValue == 0;
        }

        public int getExitValue() {
            return exitValue;
        }

        public String getSuccessMsg() {
            return successMsg;
        }

        public String getErrorMsg() {
            return errorMsg;
        }

        @Override
        public String toString() {
            return "CommandResult{" +
                    "exitValue=" + exitValue +
                    ", successMsg='" + successMsg + '\'' +
                    ", errorMsg='" + errorMsg + '\'' +
                    '}';
        }
    }

    /**
     * 命令执行回调
     */
    public interface CommandCallback {
        void onComplete(CommandResult result);
    }
}

```

`app/src/main/java/com/xiaoc/warlock/Util/XFile.java`:

```java
package com.xiaoc.warlock.Util;

import android.content.Context;
import android.os.Build;
import android.os.Environment;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

public class XFile {

    /**
     * 读取文件内容为字符串
     * @param filePath 文件路径
     * @return 文件内容
     */
    public static String readFile(String filePath) {
        StringBuilder content = new StringBuilder();
        try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {
            String line;
            while ((line = reader.readLine()) != null) {
                content.append(line).append("\n");
            }
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
        return content.toString();
    }

    /**
     * 写入字符串到文件
     * @param filePath 文件路径
     * @param content 要写入的内容
     * @param append 是否追加模式
     * @return 是否写入成功
     */
    public static boolean writeFile(String filePath, String content, boolean append) {
        try (FileWriter writer = new FileWriter(filePath, append)) {
            writer.write(content);
            return true;
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
    }
    /**
     * 写入字符串到私有目录下的文件
     * @param context 上下文
     * @param fileName 文件路径
     * @param content 要写入的内容
     * @param append 是否追加模式
     * @return 是否写入成功
     */
    public static  boolean writeExternalFile(Context context,String fileName, String content, boolean append) {
        try {
            File file;
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                // Android 10 及以上
                File dir = context.getExternalFilesDir(null);
                if (dir == null) return false;
                file = new File(dir, fileName);
            } else {
                // Android 10 以下
                File dir = new File(Environment.getExternalStorageDirectory(),
                        "Android/data/" + context.getPackageName());
                file = new File(dir, fileName);
            }

            // 确保目录存在
            File parent = file.getParentFile();
            if (parent != null && !parent.exists()) {
                if (!parent.mkdirs()) return false;
            }

            // 写入文件
            try (FileWriter writer = new FileWriter(file, append)) {
                writer.write(content);
                return true;
            }

        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
    }
    /**
     * 复制文件
     * @param sourcePath 源文件路径
     * @param targetPath 目标文件路径
     * @return 是否复制成功
     */
    public static boolean copyFile(String sourcePath, String targetPath) {
        try (FileInputStream fis = new FileInputStream(sourcePath);
             FileOutputStream fos = new FileOutputStream(targetPath)) {
            byte[] buffer = new byte[1024];
            int length;
            while ((length = fis.read(buffer)) > 0) {
                fos.write(buffer, 0, length);
            }
            return true;
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
    }
    /**
     * 写入字符串到应用私有目录下的文件
     * @param context 上下文
     * @param fileName 文件名
     * @param content 要写入的内容
     * @param append 是否追加模式
     * @return 是否写入成功
     */
    public static boolean writePrivateFile(Context context, String fileName, String content, boolean append) {
        try {
            // 获取应用私有目录
            File dir = context.getFilesDir();  // /data/data/包名/files/
            // 或者使用 context.getDir("custom_dir", Context.MODE_PRIVATE) 创建自定义子目录

            File file = new File(dir, fileName);

            // 确保父目录存在
            File parent = file.getParentFile();
            if (parent != null && !parent.exists()) {
                if (!parent.mkdirs()) return false;
            }

            // 写入文件
            try (FileWriter writer = new FileWriter(file, append)) {
                writer.write(content);
                writer.flush();
                return true;
            }

        } catch (Exception e) {
            XLog.e("FileUtils", "Failed to write private file: " + e.getMessage());
            return false;
        }
    }

    /**
     * 写入字符串到应用私有缓存目录下的文件
     * @param context 上下文
     * @param fileName 文件名
     * @param content 要写入的内容
     * @param append 是否追加模式
     * @return 是否写入成功
     */
    public static boolean writePrivateCacheFile(Context context, String fileName, String content, boolean append) {
        try {
            // 获取应用私有缓存目录
            File dir = context.getCacheDir();  // /data/data/包名/cache/
            File file = new File(dir, fileName);

            // 确保父目录存在
            File parent = file.getParentFile();
            if (parent != null && !parent.exists()) {
                if (!parent.mkdirs()) return false;
            }

            // 写入文件
            try (FileWriter writer = new FileWriter(file, append)) {
                writer.write(content);
                writer.flush();
                return true;
            }

        } catch (Exception e) {
            XLog.e("FileUtils", "Failed to write cache file: " + e.getMessage());
            return false;
        }
    }
    /**
     * 删除文件或目录
     * @param path 文件或目录路径
     * @return 是否删除成功
     */
    public static boolean delete(String path) {
        File file = new File(path);
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            if (files != null) {
                for (File child : files) {
                    delete(child.getPath());
                }
            }
        }
        return file.delete();
    }

    /**
     * 创建目录
     * @param dirPath 目录路径
     * @return 是否创建成功
     */
    public static boolean createDir(String dirPath) {
        File dir = new File(dirPath);
        return dir.exists() || dir.mkdirs();
    }

    /**
     * 检查文件是否存在
     * @param path 文件路径
     * @return 是否存在
     */
    public static boolean exists(String path) {
        return new File(path).exists();
    }

    /**
     * 获取文件大小
     * @param path 文件路径
     * @return 文件大小（字节）
     */
    public static long getFileSize(String path) {
        File file = new File(path);
        return file.exists() && file.isFile() ? file.length() : -1;
    }

    /**
     * 读取整个文件内容为字节数组
     *
     * @param file 要读取的文件
     * @return 文件内容对应的 byte[]
     * @throws IOException 读取失败时抛出
     */
    public static byte[] readFileToByteArray(File file) throws IOException {
        long length = file.length();
        if (length > Integer.MAX_VALUE) {
            throw new IOException("File is too large to fit in a byte array: " + file.getName());
        }

        byte[] bytes = new byte[(int) length];
        FileInputStream fis = null;
        try {
            fis = new FileInputStream(file);
            int offset = 0;
            int numRead;
            while (offset < bytes.length && (numRead = fis.read(bytes, offset, bytes.length - offset)) >= 0) {
                offset += numRead;
            }

            if (offset < bytes.length) {
                throw new IOException("Could not completely read file " + file.getName());
            }
            return bytes;
        } finally {
            if (fis != null) {
                fis.close();
            }
        }
    }
    /**
     * 列出指定目录及其子目录下所有指定后缀名的文件
     *
     * @param dir 起始目录
     * @param extensions 文件扩展名数组，例如 {"ttf"}
     * @param recursive 是否递归子目录
     * @return 文件集合
     */
    public static Collection<File> listFiles(File dir, String[] extensions, boolean recursive) {
        List<File> result = new ArrayList<>();
        if (dir != null && dir.exists() && dir.isDirectory()) {
            File[] files = dir.listFiles();
            if (files != null) {
                for (File file : files) {
                    if (file.isDirectory() && recursive) {
                        result.addAll(listFiles(file, extensions, true));
                    } else {
                        for (String ext : extensions) {
                            if (file.getName().toLowerCase().endsWith("." + ext.toLowerCase())) {
                                result.add(file);
                                break;
                            }
                        }
                    }
                }
            }
        }
        return result;
    }
}
```

`app/src/main/java/com/xiaoc/warlock/Util/XLog.java`:

```java
package com.xiaoc.warlock.Util;

import android.content.Context;
import android.os.Environment;
import android.util.Log;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class XLog {
    private static final String TAG = "XLog";
    private static final String LOG_FOLDER = "logs"; // 日志文件夹名称

    // 日志级别
    public static final int VERBOSE = 1;
    public static final int DEBUG = 2;
    public static final int INFO = 3;
    public static final int WARN = 4;
    public static final int ERROR = 5;
    public static final int NONE = 6;

    private static int currentLevel = DEBUG;
    private static boolean writeToFile = false;
    private static String logDir;
    private static final SimpleDateFormat fileFormat = new SimpleDateFormat("yyyy-MM-dd", Locale.getDefault());
    private static final SimpleDateFormat timeFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS", Locale.getDefault());
    private static final ExecutorService executor = Executors.newSingleThreadExecutor();

    /**
     * 初始化日志系统
     * @param context 上下文
     * @param level 日志级别
     * @param writeFile 是否写入文件
     */
    public static void init(Context context, int level, boolean writeFile) {
        currentLevel = level;
        writeToFile = writeFile;

        if (writeFile && context != null) {
            // 使用应用私有目录
            File dir = new File(context.getFilesDir(), LOG_FOLDER);
            if (!dir.exists()) {
                dir.mkdirs();
            }
            logDir = dir.getAbsolutePath();
        }
    }

    public static void v(String msg) {
        v(TAG, msg);
    }

    public static void d(String msg) {
        d(TAG, msg);
    }

    public static void i(String msg) {
        i(TAG, msg);
    }

    public static void w(String msg) {
        w(TAG, msg);
    }

    public static void e(String msg) {
        e(TAG, msg);
    }

    public static void v(String tag, String msg) {
        if (currentLevel <= VERBOSE) {
            Log.v(tag, msg);
            writeLog('V', tag, msg);
        }
    }

    public static void d(String tag, String msg) {
        if (currentLevel <= DEBUG) {
            Log.d(tag, msg);
            writeLog('D', tag, msg);
        }
    }

    public static void i(String tag, String msg) {
        if (currentLevel <= INFO) {
            Log.i(tag, msg);
            writeLog('I', tag, msg);
        }
    }

    public static void w(String tag, String msg) {
        if (currentLevel <= WARN) {
            Log.w(tag, msg);
            writeLog('W', tag, msg);
        }
    }

    public static void e(String tag, String msg) {
        if (currentLevel <= ERROR) {
            Log.e(tag, msg);
            writeLog('E', tag, msg);
        }
    }

    public static void e(String tag, String msg, Throwable tr) {
        if (currentLevel <= ERROR) {
            Log.e(tag, msg, tr);
            writeLog('E', tag, msg + '\n' + Log.getStackTraceString(tr));
        }
    }

    private static void writeLog(char level, String tag, String msg) {
        if (!writeToFile || logDir == null) return;

        executor.execute(() -> {
            String time = timeFormat.format(new Date());
            String fileName = fileFormat.format(new Date()) + ".log";
            File logFile = new File(logDir, fileName);

            String log = String.format("%s %c/%s: %s\n", time, level, tag, msg);

            try (FileWriter writer = new FileWriter(logFile, true)) {
                writer.append(log);
            } catch (IOException e) {
                Log.e(TAG, "Write log file failed", e);
            }
        });
    }

    /**
     * 获取日志文件列表
     */
    public static File[] getLogFiles() {
        if (!writeToFile || logDir == null) return new File[0];
        File dir = new File(logDir);
        return dir.listFiles((dir1, name) -> name.endsWith(".log"));
    }

    /**
     * 删除指定天数之前的日志
     */
    public static void deleteOldLogs(int days) {
        if (!writeToFile || logDir == null) return;

        executor.execute(() -> {
            File dir = new File(logDir);
            File[] files = dir.listFiles((dir1, name) -> name.endsWith(".log"));
            if (files == null) return;

            long now = System.currentTimeMillis();
            long daysInMillis = days * 24 * 60 * 60 * 1000L;

            for (File file : files) {
                if (now - file.lastModified() > daysInMillis) {
                    file.delete();
                }
            }
        });
    }

    /**
     * 获取日志文件大小
     */
    public static long getLogSize() {
        if (!writeToFile || logDir == null) return 0;

        File dir = new File(logDir);
        File[] files = dir.listFiles((dir1, name) -> name.endsWith(".log"));
        if (files == null) return 0;

        long size = 0;
        for (File file : files) {
            size += file.length();
        }
        return size;
    }
}
```

`app/src/main/java/com/xiaoc/warlock/Util/XNetwork.java`:

```java
package com.xiaoc.warlock.Util;

import android.content.Context;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.os.Handler;
import android.os.Looper;

import androidx.annotation.NonNull;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.FormBody;
import okhttp3.MediaType;
import okhttp3.MultipartBody;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import okhttp3.ResponseBody;

public class XNetwork {
    private static final OkHttpClient client = new OkHttpClient.Builder()
            .connectTimeout(10, TimeUnit.SECONDS)
            .readTimeout(10, TimeUnit.SECONDS)
            .writeTimeout(10, TimeUnit.SECONDS)
            .build();
    /**
     * 检查网络是否可用
     */
    public static boolean isNetworkAvailable(Context context) {
        ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
        if (cm == null) return false;

        NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
        return activeNetwork != null && activeNetwork.isConnectedOrConnecting();
    }

    /**
     * 判断是否是WiFi连接
     */
    public static boolean isWifiConnected(Context context) {
        ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
        if (cm == null) return false;

        NetworkInfo networkInfo = cm.getActiveNetworkInfo();
        return networkInfo != null && networkInfo.getType() == ConnectivityManager.TYPE_WIFI;
    }
    /**
     * GET请求
     * @param url 请求地址
     * @param callback 回调接口
     */
    public static void get(String url, NetworkCallback callback) {
        Request request = new Request.Builder()
                .url(url)
                .get()
                .build();

        executeRequest(request, callback);
    }

    /**
     * POST请求（JSON数据）
     * @param url 请求地址
     * @param jsonBody JSON字符串
     * @param callback 回调接口
     */
    public static void postJson(String url, String jsonBody, NetworkCallback callback) {
        RequestBody body = RequestBody.create(jsonBody, MediaType.parse("application/json; charset=utf-8"));
        Request request = new Request.Builder()
                .url(url)
                .post(body)
                .build();

        executeRequest(request, callback);
    }

    /**
     * POST请求（表单数据）
     * @param url 请求地址
     * @param params 参数Map
     * @param callback 回调接口
     */
    public static void postForm(String url, Map<String, String> params, NetworkCallback callback) {
        FormBody.Builder formBuilder = new FormBody.Builder();
        for (Map.Entry<String, String> entry : params.entrySet()) {
            formBuilder.add(entry.getKey(), entry.getValue());
        }

        Request request = new Request.Builder()
                .url(url)
                .post(formBuilder.build())
                .build();

        executeRequest(request, callback);
    }

    /**
     * 上传文件
     * @param url 请求地址
     * @param file 文件
     * @param callback 回调接口
     */
    public static void uploadFile(String url, File file, NetworkCallback callback) {
        RequestBody requestBody = MultipartBody.create(file, MediaType.parse("application/octet-stream"));
        MultipartBody.Builder multipartBuilder = new MultipartBody.Builder()
                .setType(MultipartBody.FORM)
                .addFormDataPart("file", file.getName(), requestBody);

        Request request = new Request.Builder()
                .url(url)
                .post(multipartBuilder.build())
                .build();

        executeRequest(request, callback);
    }

    /**
     * 下载文件
     * @param url 文件URL
     * @param destFile 目标文件
     * @param callback 下载回调
     */
    public static void downloadFile(String url, File destFile, DownloadCallback callback) {
        Request request = new Request.Builder()
                .url(url)
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@NonNull Call call, @NonNull IOException e) {
                callback.onFailure(e.getMessage());
            }

            @Override
            public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                if (!response.isSuccessful()) {
                    callback.onFailure("下载失败: " + response.code());
                    return;
                }

                ResponseBody body = response.body();
                if (body == null) {
                    callback.onFailure("响应体为空");
                    return;
                }

                long totalBytes = body.contentLength();
                long downloadedBytes = 0;

                try (InputStream is = body.byteStream();
                     FileOutputStream fos = new FileOutputStream(destFile)) {
                    byte[] buffer = new byte[8192];
                    int len;
                    while ((len = is.read(buffer)) != -1) {
                        fos.write(buffer, 0, len);
                        downloadedBytes += len;
                        callback.onProgress((int) (downloadedBytes * 100 / totalBytes));
                    }
                    callback.onSuccess(destFile);
                } catch (Exception e) {
                    callback.onFailure(e.getMessage());
                }
            }
        });
    }

    private static void executeRequest(Request request, NetworkCallback callback) {
        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@NonNull Call call, @NonNull IOException e) {
                Handler mainHandler = new Handler(Looper.getMainLooper());
                mainHandler.post(() -> callback.onFailure(e.getMessage()));
            }

            @Override
            public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                String result = "";
                if (response.body() != null) {
                    result = response.body().string();
                }
                String finalResult = result;
                Handler mainHandler = new Handler(Looper.getMainLooper());
                mainHandler.post(() -> callback.onSuccess(finalResult));
            }
        });
    }

    /**
     * 网络请求回调接口
     */
    public interface NetworkCallback {
        void onSuccess(String response);
        void onFailure(String error);
    }

    /**
     * 下载回调接口
     */
    public interface DownloadCallback {
        void onProgress(int progress);
        void onSuccess(File file);
        void onFailure(String error);
    }
}

```

`app/src/main/java/com/xiaoc/warlock/Util/XString.java`:

```java
package com.xiaoc.warlock.Util;

import java.util.List;

public class XString {
    /**
     * 判断字符串是否为空
     */
    public static boolean isEmpty(String str) {
        return str == null || str.trim().length() == 0;
    }

    /**
     * 判断字符串是否不为空
     */
    public static boolean isNotEmpty(String str) {
        return !isEmpty(str);
    }

    /**
     * 获取字符串的长度，null 返回 0
     */
    public static int length(String str) {
        return str == null ? 0 : str.length();
    }

    /**
     * 首字母大写
     */
    public static String capitalize(String str) {
        if (isEmpty(str)) return str;
        return str.substring(0, 1).toUpperCase() + str.substring(1);
    }

    /**
     * 判断是否是手机号
     */
    public static boolean isPhoneNumber(String phone) {
        if (isEmpty(phone)) return false;
        return phone.matches("^1[3-9]\\d{9}$");
    }

    /**
     * 判断是否是邮箱
     */
    public static boolean isEmail(String email) {
        if (isEmpty(email)) return false;
        return email.matches("^[a-zA-Z0-9_.-]+@[a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]+)*\\.[a-zA-Z0-9]{2,6}$");
    }
    /**
     * 比较两个字符串是否完全相同
     */
    public static boolean compareExact(String str1, String str2) {
        if (str1 == null && str2 == null) return true;
        if (str1 == null || str2 == null) return false;
        return str1.equals(str2);
    }

    /**
     * 比较两个字符串是否相同（忽略大小写）
     */
    public static boolean compareIgnoreCase(String str1, String str2) {
        if (str1 == null && str2 == null) return true;
        if (str1 == null || str2 == null) return false;
        return str1.equalsIgnoreCase(str2);
    }

    /**
     * 比较两个字符串是否相似（忽略空格）
     */
    public static boolean compareIgnoreSpaces(String str1, String str2) {
        if (str1 == null && str2 == null) return true;
        if (str1 == null || str2 == null) return false;
        return str1.replaceAll("\\s+", "").equals(str2.replaceAll("\\s+", ""));
    }

    /**
     * 比较两个字符串并输出差异
     */
    public static String getDifference(String str1, String str2) {
        if (str1 == null && str2 == null) return "Both strings are null";
        if (str1 == null) return "First string is null, second string: " + str2;
        if (str2 == null) return "Second string is null, first string: " + str1;

        StringBuilder diff = new StringBuilder();
        if (str1.equals(str2)) {
            diff.append("Strings are identical");
        } else {
            diff.append("Strings are different:\n");
            diff.append("String 1 (length ").append(str1.length()).append("): ").append(str1).append("\n");
            diff.append("String 2 (length ").append(str2.length()).append("): ").append(str2).append("\n");

            // 找出第一个不同的字符位置
            int minLength = Math.min(str1.length(), str2.length());
            for (int i = 0; i < minLength; i++) {
                if (str1.charAt(i) != str2.charAt(i)) {
                    diff.append("First difference at position ").append(i)
                            .append(" (char1='").append(str1.charAt(i))
                            .append("', char2='").append(str2.charAt(i))
                            .append("')");
                    break;
                }
            }
        }
        return diff.toString();
    }

    /**
     * 计算两个字符串的相似度（使用Levenshtein距离）
     */
    public static double getSimilarity(String str1, String str2) {
        if (str1 == null && str2 == null) return 1.0;
        if (str1 == null || str2 == null) return 0.0;

        int[][] dp = new int[str1.length() + 1][str2.length() + 1];

        for (int i = 0; i <= str1.length(); i++) {
            dp[i][0] = i;
        }

        for (int j = 0; j <= str2.length(); j++) {
            dp[0][j] = j;
        }

        for (int i = 1; i <= str1.length(); i++) {
            for (int j = 1; j <= str2.length(); j++) {
                if (str1.charAt(i - 1) == str2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(dp[i - 1][j - 1] + 1,
                            Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1));
                }
            }
        }

        int maxLength = Math.max(str1.length(), str2.length());
        return 1.0 - (double) dp[str1.length()][str2.length()] / maxLength;
    }
    /**
     * 比较多个字符串是否完全相同
     */
    public static boolean compareExact(String... strings) {
        if (strings == null || strings.length < 2) return true;
        String first = strings[0];
        for (String str : strings) {
            if (!compareExact(first, str)) {
                return false;
            }
        }
        return true;
    }

    /**
     * 比较多个字符串是否相同（忽略大小写）
     */
    public static boolean compareIgnoreCase(String... strings) {
        if (strings == null || strings.length < 2) return true;
        String first = strings[0];
        for (String str : strings) {
            if (!compareIgnoreCase(first, str)) {
                return false;
            }
        }
        return true;
    }

    /**
     * 比较多个字符串是否相似（忽略空格）
     */
    public static boolean compareIgnoreSpaces(String... strings) {
        if (strings == null || strings.length < 2) return true;
        String first = strings[0];
        for (String str : strings) {
            if (!compareIgnoreSpaces(first, str)) {
                return false;
            }
        }
        return true;
    }

    /**
     * 比较字符串列表是否完全相同
     */
    public static boolean compareExact(List<String> strings) {
        if (strings == null || strings.size() < 2) return true;
        String first = strings.get(0);
        for (String str : strings) {
            if (!compareExact(first, str)) {
                return false;
            }
        }
        return true;
    }

    /**
     * 比较字符串列表是否相同（忽略大小写）
     */
    public static boolean compareIgnoreCase(List<String> strings) {
        if (strings == null || strings.size() < 2) return true;
        String first = strings.get(0);
        for (String str : strings) {
            if (!compareIgnoreCase(first, str)) {
                return false;
            }
        }
        return true;
    }

    /**
     * 比较字符串列表是否相似（忽略空格）
     */
    public static boolean compareIgnoreSpaces(List<String> strings) {
        if (strings == null || strings.size() < 2) return true;
        String first = strings.get(0);
        for (String str : strings) {
            if (!compareIgnoreSpaces(first, str)) {
                return false;
            }
        }
        return true;
    }
}

```

`app/src/main/java/com/xiaoc/warlock/Util/XTime.java`:

```java
package com.xiaoc.warlock.Util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

public class XTime {
    private static final String DEFAULT_PATTERN = "yyyy-MM-dd HH:mm:ss";

    /**
     * 获取当前时间戳
     */
    public static long getCurrentTimestamp() {
        return System.currentTimeMillis();
    }

    /**
     * 格式化时间戳
     */
    public static String formatTimestamp(long timestamp, String pattern) {
        SimpleDateFormat sdf = new SimpleDateFormat(pattern, Locale.getDefault());
        return sdf.format(new Date(timestamp));
    }

    /**
     * 格式化当前时间
     */
    public static String formatNow(String pattern) {
        return formatTimestamp(getCurrentTimestamp(), pattern);
    }

    /**
     * 字符串转时间戳
     */
    public static long parseTime(String timeStr, String pattern) {
        try {
            SimpleDateFormat sdf = new SimpleDateFormat(pattern, Locale.getDefault());
            return sdf.parse(timeStr).getTime();
        } catch (ParseException e) {
            e.printStackTrace();
            return 0;
        }
    }
}

```

`app/src/main/java/com/xiaoc/warlock/Util/Xson.java`:

```java
package com.xiaoc.warlock.Util;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Xson {

    private static final Gson gson = new Gson();
    private static final Map<String, InfoValue> dataMap = new HashMap<>();
    private Xson() {
        // 私有构造方法,防止实例化
    }

    /**
     * 将对象转换为JSON字符串
     */
    public static String toJson(Object object) {
        return gson.toJson(object);
    }

    /**
     * 将JSON字符串转换为对象
     */
    public static <T> T fromJson(String json, Class<T> classOfT) {
        return gson.fromJson(json, classOfT);
    }

    /**
     * 将JSON字符串转换为对象列表
     */
    public static <T> List<T> fromJsonList(String json, Class<T> classOfT) {
        Type type = TypeToken.getParameterized(List.class, classOfT).getType();
        return gson.fromJson(json, type);
    }

    /**
     * 将JSON字符串转换为Map
     */
    public static <K, V> Map<K, V> fromJsonMap(String json, Class<K> keyClass, Class<V> valueClass) {
        Type type = TypeToken.getParameterized(Map.class, keyClass, valueClass).getType();
        return gson.fromJson(json, type);
    }
    /**
     * 存储键值对
     * @param key 键
     * @param value 值
     */
    public static void put(String key, InfoValue value) {
        if (key == null) return;
        dataMap.put(key, value);
    }

    /**
     * 将存储的键值对转换为JSON字符串
     * @return JSON字符串
     */
    public static String getMapString(boolean isMatted) {
        if (isMatted){
            return getFormattedJson();
        }
        return gson.toJson(dataMap);
    }
    private static String getFormattedJson() {
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        return gson.toJson(dataMap);
    }
    /**
     * 清空存储的键值对
     */
    public static void clear() {
        dataMap.clear();
    }
}

```

`app/src/main/java/com/xiaoc/warlock/crypto/AESUtil.java`:

```java
package com.xiaoc.warlock.crypto;


import java.util.Arrays;

public class AESUtil {
    // AES S-box
    private static final byte[] SBOX = {
            (byte)0x63, (byte)0x7c, (byte)0x77, (byte)0x7b, (byte)0xf2, (byte)0x6b, (byte)0x6f, (byte)0xc5,
            (byte)0x30, (byte)0x01, (byte)0x67, (byte)0x2b, (byte)0xfe, (byte)0xd7, (byte)0xab, (byte)0x76,
            (byte)0xca, (byte)0x82, (byte)0xc9, (byte)0x7d, (byte)0xfa, (byte)0x59, (byte)0x47, (byte)0xf0,
            (byte)0xad, (byte)0xd4, (byte)0xa2, (byte)0xaf, (byte)0x9c, (byte)0xa4, (byte)0x72, (byte)0xc0,
            (byte)0xb7, (byte)0xfd, (byte)0x93, (byte)0x26, (byte)0x36, (byte)0x3f, (byte)0xf7, (byte)0xcc,
            (byte)0x34, (byte)0xa5, (byte)0xe5, (byte)0xf1, (byte)0x71, (byte)0xd8, (byte)0x31, (byte)0x15,
            (byte)0x04, (byte)0xc7, (byte)0x23, (byte)0xc3, (byte)0x18, (byte)0x96, (byte)0x05, (byte)0x9a,
            (byte)0x07, (byte)0x12, (byte)0x80, (byte)0xe2, (byte)0xeb, (byte)0x27, (byte)0xb2, (byte)0x75,
            (byte)0x09, (byte)0x83, (byte)0x2c, (byte)0x1a, (byte)0x1b, (byte)0x6e, (byte)0x5a, (byte)0xa0,
            (byte)0x52, (byte)0x3b, (byte)0xd6, (byte)0xb3, (byte)0x29, (byte)0xe3, (byte)0x2f, (byte)0x84,
            (byte)0x53, (byte)0xd1, (byte)0x00, (byte)0xed, (byte)0x20, (byte)0xfc, (byte)0xb1, (byte)0x5b,
            (byte)0x6a, (byte)0xcb, (byte)0xbe, (byte)0x39, (byte)0x4a, (byte)0x4c, (byte)0x58, (byte)0xcf,
            (byte)0xd0, (byte)0xef, (byte)0xaa, (byte)0xfb, (byte)0x43, (byte)0x4d, (byte)0x33, (byte)0x85,
            (byte)0x45, (byte)0xf9, (byte)0x02, (byte)0x7f, (byte)0x50, (byte)0x3c, (byte)0x9f, (byte)0xa8,
            (byte)0x51, (byte)0xa3, (byte)0x40, (byte)0x8f, (byte)0x92, (byte)0x9d, (byte)0x38, (byte)0xf5,
            (byte)0xbc, (byte)0xb6, (byte)0xda, (byte)0x21, (byte)0x10, (byte)0xff, (byte)0xf3, (byte)0xd2,
            (byte)0xcd, (byte)0x0c, (byte)0x13, (byte)0xec, (byte)0x5f, (byte)0x97, (byte)0x44, (byte)0x17,
            (byte)0xc4, (byte)0xa7, (byte)0x7e, (byte)0x3d, (byte)0x64, (byte)0x5d, (byte)0x19, (byte)0x73,
            (byte)0x60, (byte)0x81, (byte)0x4f, (byte)0xdc, (byte)0x22, (byte)0x2a, (byte)0x90, (byte)0x88,
            (byte)0x46, (byte)0xee, (byte)0xb8, (byte)0x14, (byte)0xde, (byte)0x5e, (byte)0x0b, (byte)0xdb,
            (byte)0xe0, (byte)0x32, (byte)0x3a, (byte)0x0a, (byte)0x49, (byte)0x06, (byte)0x24, (byte)0x5c,
            (byte)0xc2, (byte)0xd3, (byte)0xac, (byte)0x62, (byte)0x91, (byte)0x95, (byte)0xe4, (byte)0x79,
            (byte)0xe7, (byte)0xc8, (byte)0x37, (byte)0x6d, (byte)0x8d, (byte)0xd5, (byte)0x4e, (byte)0xa9,
            (byte)0x6c, (byte)0x56, (byte)0xf4, (byte)0xea, (byte)0x65, (byte)0x7a, (byte)0xae, (byte)0x08,
            (byte)0xba, (byte)0x78, (byte)0x25, (byte)0x2e, (byte)0x1c, (byte)0xa6, (byte)0xb4, (byte)0xc6,
            (byte)0xe8, (byte)0xdd, (byte)0x74, (byte)0x1f, (byte)0x4b, (byte)0xbd, (byte)0x8b, (byte)0x8a,
            (byte)0x70, (byte)0x3e, (byte)0xb5, (byte)0x66, (byte)0x48, (byte)0x03, (byte)0xf6, (byte)0x0e,
            (byte)0x61, (byte)0x35, (byte)0x57, (byte)0xb9, (byte)0x86, (byte)0xc1, (byte)0x1d, (byte)0x9e,
            (byte)0xe1, (byte)0xf8, (byte)0x98, (byte)0x11, (byte)0x69, (byte)0xd9, (byte)0x8e, (byte)0x94,
            (byte)0x9b, (byte)0x1e, (byte)0x87, (byte)0xe9, (byte)0xce, (byte)0x55, (byte)0x28, (byte)0xdf,
            (byte)0x8c, (byte)0xa1, (byte)0x89, (byte)0x0d, (byte)0xbf, (byte)0xe6, (byte)0x42, (byte)0x68,
            (byte)0x41, (byte)0x99, (byte)0x2d, (byte)0x0f, (byte)0xb0, (byte)0x54, (byte)0xbb, (byte)0x16
    };
    private static final byte[] INV_SBOX = {
            (byte)0x52, (byte)0x09, (byte)0x6A, (byte)0xD5, (byte)0x30, (byte)0x36, (byte)0xA5, (byte)0x38,
            (byte)0xBF, (byte)0x40, (byte)0xA3, (byte)0x9E, (byte)0x81, (byte)0xF3, (byte)0xD7, (byte)0xFB,
            (byte)0x7C, (byte)0xE3, (byte)0x39, (byte)0x82, (byte)0x9B, (byte)0x2F, (byte)0xFF, (byte)0x87,
            (byte)0x34, (byte)0x8E, (byte)0x43, (byte)0x44, (byte)0xC4, (byte)0xDE, (byte)0xE9, (byte)0xCB,
            (byte)0x54, (byte)0x7B, (byte)0x94, (byte)0x32, (byte)0xA6, (byte)0xC2, (byte)0x23, (byte)0x3D,
            (byte)0xEE, (byte)0x4C, (byte)0x95, (byte)0x0B, (byte)0x42, (byte)0xFA, (byte)0xC3, (byte)0x4E,
            (byte)0x08, (byte)0x2E, (byte)0xA1, (byte)0x66, (byte)0x28, (byte)0xD9, (byte)0x24, (byte)0xB2,
            (byte)0x76, (byte)0x5B, (byte)0xA2, (byte)0x49, (byte)0x6D, (byte)0x8B, (byte)0xD1, (byte)0x25,
            (byte)0x72, (byte)0xF8, (byte)0xF6, (byte)0x64, (byte)0x86, (byte)0x68, (byte)0x98, (byte)0x16,
            (byte)0xD4, (byte)0xA4, (byte)0x5C, (byte)0xCC, (byte)0x5D, (byte)0x65, (byte)0xB6, (byte)0x92,
            (byte)0x6C, (byte)0x70, (byte)0x48, (byte)0x50, (byte)0xFD, (byte)0xED, (byte)0xB9, (byte)0xDA,
            (byte)0x5E, (byte)0x15, (byte)0x46, (byte)0x57, (byte)0xA7, (byte)0x8D, (byte)0x9D, (byte)0x84,
            (byte)0x90, (byte)0xD8, (byte)0xAB, (byte)0x00, (byte)0x8C, (byte)0xBC, (byte)0xD3, (byte)0x0A,
            (byte)0xF7, (byte)0xE4, (byte)0x58, (byte)0x05, (byte)0xB8, (byte)0xB3, (byte)0x45, (byte)0x06,
            (byte)0xD0, (byte)0x2C, (byte)0x1E, (byte)0x8F, (byte)0xCA, (byte)0x3F, (byte)0x0F, (byte)0x02,
            (byte)0xC1, (byte)0xAF, (byte)0xBD, (byte)0x03, (byte)0x01, (byte)0x13, (byte)0x8A, (byte)0x6B,
            (byte)0x3A, (byte)0x91, (byte)0x11, (byte)0x41, (byte)0x4F, (byte)0x67, (byte)0xDC, (byte)0xEA,
            (byte)0x97, (byte)0xF2, (byte)0xCF, (byte)0xCE, (byte)0xF0, (byte)0xB4, (byte)0xE6, (byte)0x73,
            (byte)0x96, (byte)0xAC, (byte)0x74, (byte)0x22, (byte)0xE7, (byte)0xAD, (byte)0x35, (byte)0x85,
            (byte)0xE2, (byte)0xF9, (byte)0x37, (byte)0xE8, (byte)0x1C, (byte)0x75, (byte)0xDF, (byte)0x6E,
            (byte)0x47, (byte)0xF1, (byte)0x1A, (byte)0x71, (byte)0x1D, (byte)0x29, (byte)0xC5, (byte)0x89,
            (byte)0x6F, (byte)0xB7, (byte)0x62, (byte)0x0E, (byte)0xAA, (byte)0x18, (byte)0xBE, (byte)0x1B,
            (byte)0xFC, (byte)0x56, (byte)0x3E, (byte)0x4B, (byte)0xC6, (byte)0xD2, (byte)0x79, (byte)0x20,
            (byte)0x9A, (byte)0xDB, (byte)0xC0, (byte)0xFE, (byte)0x78, (byte)0xCD, (byte)0x5A, (byte)0xF4,
            (byte)0x1F, (byte)0xDD, (byte)0xA8, (byte)0x33, (byte)0x88, (byte)0x07, (byte)0xC7, (byte)0x31,
            (byte)0xB1, (byte)0x12, (byte)0x10, (byte)0x59, (byte)0x27, (byte)0x80, (byte)0xEC, (byte)0x5F,
            (byte)0x60, (byte)0x51, (byte)0x7F, (byte)0xA9, (byte)0x19, (byte)0xB5, (byte)0x4A, (byte)0x0D,
            (byte)0x2D, (byte)0xE5, (byte)0x7A, (byte)0x9F, (byte)0x93, (byte)0xC9, (byte)0x9C, (byte)0xEF,
            (byte)0xA0, (byte)0xE0, (byte)0x3B, (byte)0x4D, (byte)0xAE, (byte)0x2A, (byte)0xF5, (byte)0xB0,
            (byte)0xC8, (byte)0xEB, (byte)0xBB, (byte)0x3C, (byte)0x83, (byte)0x53, (byte)0x99, (byte)0x61,
            (byte)0x17, (byte)0x2B, (byte)0x04, (byte)0x7E, (byte)0xBA, (byte)0x77, (byte)0xD6, (byte)0x26,
            (byte)0xE1, (byte)0x69, (byte)0x14, (byte)0x63, (byte)0x55, (byte)0x21, (byte)0x0C, (byte)0x7D
    };
    // 轮常量
    private static final int[] RCON = {
            0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36
    };

    // 分组大小(16字节)
    private static final int BLOCK_SIZE = 16;

    // 密钥扩展
    private int[] expandKey(byte[] key) {
        int Nk = key.length / 4;
        int Nr = Nk + 6;
        int[] w = new int[4 * (Nr + 1)];

        int temp;
        int i = 0;

        while (i < Nk) {
            w[i] = ((key[4*i] & 0xff) << 24) |
                    ((key[4*i+1] & 0xff) << 16) |
                    ((key[4*i+2] & 0xff) << 8) |
                    (key[4*i+3] & 0xff);
            i++;
        }

        i = Nk;
        while (i < w.length) {
            temp = w[i-1];
            if (i % Nk == 0) {
                temp = subWord(rotWord(temp)) ^ RCON[i/Nk - 1];
            }
            w[i] = w[i-Nk] ^ temp;
            i++;
        }

        return w;
    }

    // SubBytes 变换
    private void subBytes(byte[][] state) {
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                state[i][j] = (byte) SBOX[state[i][j] & 0xff];
            }
        }
    }

    // ShiftRows 变换
    private void shiftRows(byte[][] state) {
        byte temp;

        // 第二行左移一位
        temp = state[1][0];
        state[1][0] = state[1][1];
        state[1][1] = state[1][2];
        state[1][2] = state[1][3];
        state[1][3] = temp;

        // 第三行左移两位
        temp = state[2][0];
        state[2][0] = state[2][2];
        state[2][2] = temp;
        temp = state[2][1];
        state[2][1] = state[2][3];
        state[2][3] = temp;

        // 第四行左移三位
        temp = state[3][3];
        state[3][3] = state[3][2];
        state[3][2] = state[3][1];
        state[3][1] = state[3][0];
        state[3][0] = temp;
    }

    // MixColumns 变换
    private void mixColumns(byte[][] state) {
        byte[] temp = new byte[4];

        for (int c = 0; c < 4; c++) {
            for (int i = 0; i < 4; i++) {
                temp[i] = state[i][c];
            }

            state[0][c] = (byte)(gmul(0x02, temp[0]) ^ gmul(0x03, temp[1]) ^ temp[2] ^ temp[3]);
            state[1][c] = (byte)(temp[0] ^ gmul(0x02, temp[1]) ^ gmul(0x03, temp[2]) ^ temp[3]);
            state[2][c] = (byte)(temp[0] ^ temp[1] ^ gmul(0x02, temp[2]) ^ gmul(0x03, temp[3]));
            state[3][c] = (byte)(gmul(0x03, temp[0]) ^ temp[1] ^ temp[2] ^ gmul(0x02, temp[3]));
        }
    }

    // GF(2^8)上的乘法
    private byte gmul(int a, byte b) {
        int p = 0;
        int counter;
        int hi_bit_set;

        for (counter = 0; counter < 8; counter++) {
            if ((b & 1) != 0) {
                p ^= a;
            }
            hi_bit_set = (a & 0x80);
            a <<= 1;
            if (hi_bit_set != 0) {
                a ^= 0x1b;
            }
            b >>= 1;
        }
        return (byte) (p & 0xff);
    }

    /**
     * 加密方法 - 包含自动填充
     * @param data 原始数据
     * @param key 密钥 (16, 24 或 32 字节)
     * @param iv 初始化向量 (16字节)
     * @return 加密后的数据
     */
    public byte[] encrypt(byte[] data, byte[] key, byte[] iv) {
        validateKeyAndIV(key, iv);

        // 进行PKCS7填充
        byte[] paddedData = pkcs7Pad(data);

        byte[] encrypted = new byte[paddedData.length];
        byte[] previousBlock = iv.clone();

        int[] expandedKey = expandKey(key);

        // 按块进行加密
        for (int i = 0; i < paddedData.length; i += BLOCK_SIZE) {
            byte[] block = new byte[BLOCK_SIZE];
            System.arraycopy(paddedData, i, block, 0, BLOCK_SIZE);

            // CBC模式：与前一个块进行XOR
            for (int j = 0; j < BLOCK_SIZE; j++) {
                block[j] ^= previousBlock[j];
            }

            byte[] encryptedBlock = encryptBlock(block, expandedKey);
            System.arraycopy(encryptedBlock, 0, encrypted, i, BLOCK_SIZE);
            previousBlock = encryptedBlock;
        }

        return encrypted;
    }
    /**
     * 解密方法 - 包含自动去除填充
     * @param encrypted 加密数据
     * @param key 密钥 (16, 24 或 32 字节)
     * @param iv 初始化向量 (16字节)
     * @return 解密后的原始数据
     */
    public byte[] decrypt(byte[] encrypted, byte[] key, byte[] iv) {
        validateKeyAndIV(key, iv);

        if (encrypted.length % BLOCK_SIZE != 0) {
            throw new IllegalArgumentException("加密数据长度必须是16的倍数");
        }

        byte[] decrypted = new byte[encrypted.length];
        byte[] previousBlock = iv.clone();

        int[] expandedKey = expandKey(key);

        // 按块进行解密
        for (int i = 0; i < encrypted.length; i += BLOCK_SIZE) {
            byte[] block = new byte[BLOCK_SIZE];
            System.arraycopy(encrypted, i, block, 0, BLOCK_SIZE);

            byte[] decryptedBlock = decryptBlock(block.clone(), expandedKey);

            // CBC模式：与前一个块进行XOR
            for (int j = 0; j < BLOCK_SIZE; j++) {
                decryptedBlock[j] ^= previousBlock[j];
            }

            System.arraycopy(decryptedBlock, 0, decrypted, i, BLOCK_SIZE);
            previousBlock = block;
        }

        // 移除填充
        try {
            return removePadding(decrypted);
        } catch (Exception e) {
            // 如果去除填充失败，返回原始解密数据
            return decrypted;
        }
    }
    // 加密单个块
    private byte[] encryptBlock(byte[] block, int[] expandedKey) {
        byte[][] state = new byte[4][4];

        // 将输入块转换为state数组
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                state[j][i] = block[i * 4 + j];
            }
        }

        // 初始轮密钥加
        addRoundKey(state, expandedKey, 0);

        // 9个标准轮
        for (int round = 1; round < 10; round++) {
            subBytes(state);
            shiftRows(state);
            mixColumns(state);
            addRoundKey(state, expandedKey, round);
        }

        // 最后一轮(没有mixColumns)
        subBytes(state);
        shiftRows(state);
        addRoundKey(state, expandedKey, 10);

        // 将state数组转换回字节数组
        byte[] output = new byte[16];
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                output[i * 4 + j] = state[j][i];
            }
        }

        return output;
    }

    // 轮密钥加
    private void addRoundKey(byte[][] state, int[] expandedKey, int round) {
        for (int i = 0; i < 4; i++) {
            int rk = expandedKey[round * 4 + i];
            for (int j = 0; j < 4; j++) {
                state[j][i] ^= (byte) ((rk >> (24 - j * 8)) & 0xff);
            }
        }
    }

    private int subWord(int word) {
        return (SBOX[(word >> 24) & 0xff] << 24) |
                (SBOX[(word >> 16) & 0xff] << 16) |
                (SBOX[(word >> 8) & 0xff] << 8) |
                SBOX[word & 0xff];
    }

    private int rotWord(int word) {
        return ((word << 8) | ((word >> 24) & 0xff));
    }


    // 解密单个块
    private byte[] decryptBlock(byte[] block, int[] expandedKey) {
        byte[][] state = new byte[4][4];

        // 将输入块转换为state数组
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                state[j][i] = block[i * 4 + j];
            }
        }

        // 初始轮密钥加
        addRoundKey(state, expandedKey, 10);

        // 9个标准轮
        for (int round = 9; round > 0; round--) {
            invShiftRows(state);
            invSubBytes(state);
            addRoundKey(state, expandedKey, round);
            invMixColumns(state);
        }

        // 最后一轮
        invShiftRows(state);
        invSubBytes(state);
        addRoundKey(state, expandedKey, 0);

        // 将state数组转换回字节数组
        byte[] output = new byte[16];
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                output[i * 4 + j] = state[j][i];
            }
        }

        return output;
    }

    // 逆SubBytes变换
    private void invSubBytes(byte[][] state) {
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                state[i][j] = (byte) INV_SBOX[state[i][j] & 0xff];
            }
        }
    }

    // 逆ShiftRows变换
    private void invShiftRows(byte[][] state) {
        byte temp;

        // 第二行右移一位
        temp = state[1][3];
        state[1][3] = state[1][2];
        state[1][2] = state[1][1];
        state[1][1] = state[1][0];
        state[1][0] = temp;

        // 第三行右移两位
        temp = state[2][0];
        state[2][0] = state[2][2];
        state[2][2] = temp;
        temp = state[2][1];
        state[2][1] = state[2][3];
        state[2][3] = temp;

        // 第四行右移三位
        temp = state[3][0];
        state[3][0] = state[3][1];
        state[3][1] = state[3][2];
        state[3][2] = state[3][3];
        state[3][3] = temp;
    }

    // 逆MixColumns变换
    private void invMixColumns(byte[][] state) {
        byte[] temp = new byte[4];

        for (int c = 0; c < 4; c++) {
            for (int i = 0; i < 4; i++) {
                temp[i] = state[i][c];
            }

            state[0][c] = (byte)(gmul(0x0e, temp[0]) ^ gmul(0x0b, temp[1]) ^
                    gmul(0x0d, temp[2]) ^ gmul(0x09, temp[3]));
            state[1][c] = (byte)(gmul(0x09, temp[0]) ^ gmul(0x0e, temp[1]) ^
                    gmul(0x0b, temp[2]) ^ gmul(0x0d, temp[3]));
            state[2][c] = (byte)(gmul(0x0d, temp[0]) ^ gmul(0x09, temp[1]) ^
                    gmul(0x0e, temp[2]) ^ gmul(0x0b, temp[3]));
            state[3][c] = (byte)(gmul(0x0b, temp[0]) ^ gmul(0x0d, temp[1]) ^
                    gmul(0x09, temp[2]) ^ gmul(0x0e, temp[3]));
        }
    }
    /**
     * PKCS7 填充
     */
    private byte[] pkcs7Pad(byte[] data) {
        int padding = BLOCK_SIZE - (data.length % BLOCK_SIZE);
        byte[] paddedData = new byte[data.length + padding];
        System.arraycopy(data, 0, paddedData, 0, data.length);
        for (int i = data.length; i < paddedData.length; i++) {
            paddedData[i] = (byte) padding;
        }
        return paddedData;
    }

    /**
     * 移除PKCS7填充，增加容错处理
     */
    private byte[] removePadding(byte[] paddedData) {
        if (paddedData == null || paddedData.length == 0) {
            return paddedData;
        }

        int padding = paddedData[paddedData.length - 1] & 0xFF;

        // 如果填充值不合理，返回原始数据
        if (padding < 1 || padding > BLOCK_SIZE || padding > paddedData.length) {
            return paddedData;
        }

        // 验证填充
        for (int i = paddedData.length - padding; i < paddedData.length; i++) {
            if ((paddedData[i] & 0xFF) != padding) {
                // 如果填充不一致，返回原始数据
                return paddedData;
            }
        }

        // 移除填充
        return Arrays.copyOfRange(paddedData, 0, paddedData.length - padding);
    }

    /**
     * 验证密钥和IV
     */
    private void validateKeyAndIV(byte[] key, byte[] iv) {
        if (key == null || (key.length != 16 && key.length != 24 && key.length != 32)) {
            throw new IllegalArgumentException("密钥长度必须是16、24或32字节");
        }

        if (iv == null || iv.length != BLOCK_SIZE) {
            throw new IllegalArgumentException("IV必须是16字节");
        }
    }
}


```

`app/src/main/java/com/xiaoc/warlock/crypto/Base64Util.java`:

```java
package com.xiaoc.warlock.crypto;

import java.util.Arrays;

public class Base64Util {
    // Base64 编码表
    private static final char[] ENCODE_TABLE = {
            'A', 'K', 'C', 'D', 'E', 'F', 'G', 'H',
            'I', 'J', 'B', 'L', 'M', 'N', 'O', 'P',
            'Q', 'Z', 'S', 'T', 'U', 'V', 'W', 'X',
            'Y', 'R', 'a', 'b', 'c', 'd', 'e', 'f',
            'm', 'h', 'i', 'j', 'k', 'l', 'g', 'n',
            'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
            'w', 'x', 'y', 'z', '0', '7', '2', '3',
            '4', '5', '6', '1', '8', '9', '=', '/'
    };

    // 填充字符
    private static final char PADDING = '*';

    /**
     * Base64 编码
     */
    public static String encode(byte[] data) {
        if (data == null) {
            return null;
        }

        // 预计算结果字符串长度，避免频繁扩容
        int outputLength = ((data.length + 2) / 3) * 4;
        StringBuilder sb = new StringBuilder(outputLength);

        // 每次处理3个字节
        for (int i = 0; i < data.length; i += 3) {
            int b = ((data[i] & 0xFF) << 16) & 0xFFFFFF;
            if (i + 1 < data.length) {
                b |= (data[i + 1] & 0xFF) << 8;
            }
            if (i + 2 < data.length) {
                b |= (data[i + 2] & 0xFF);
            }

            for (int j = 0; j < 4; j++) {
                if (i * 8 + j * 6 > data.length * 8) {
                    sb.append(PADDING);
                } else {
                    sb.append(ENCODE_TABLE[(b >> 6 * (3 - j)) & 0x3F]);
                }
            }
        }

        return sb.toString();
    }

    /**
     * Base64 解码
     */
    public static byte[] decode(String base64Str) {
        if (base64Str == null) {
            return null;
        }

        // 移除所有空白字符
        base64Str = base64Str.replaceAll("\\s", "");

        // 创建解码表
        int[] decodeTable = new int[128];
        Arrays.fill(decodeTable, -1);
        for (int i = 0; i < ENCODE_TABLE.length; i++) {
            decodeTable[ENCODE_TABLE[i]] = i;
        }

        // 计算输出长度
        int padCount = 0;
        for (int i = base64Str.length() - 1; i >= 0 && base64Str.charAt(i) == PADDING; i--) {
            padCount++;
        }
        int outputLength = (base64Str.length() * 3) / 4 - padCount;

        byte[] result = new byte[outputLength];
        int outputIndex = 0;

        // 每次处理4个字符
        int buffer = 0;
        int bufferLength = 0;

        try {
            for (int i = 0; i < base64Str.length(); i++) {
                char c = base64Str.charAt(i);

                if (c == PADDING) {
                    continue;
                }

                if (c >= 128 || decodeTable[c] == -1) {
                    continue; // 跳过无效字符
                }

                buffer = (buffer << 6) | decodeTable[c];
                bufferLength += 6;

                if (bufferLength >= 8) {
                    bufferLength -= 8;
                    if (outputIndex < result.length) {
                        result[outputIndex++] = (byte) ((buffer >> bufferLength) & 0xFF);
                    }
                }
            }
        } catch (Exception e) {
            // 发生错误时返回已解码的部分
            if (outputIndex > 0) {
                return Arrays.copyOf(result, outputIndex);
            }
            throw new IllegalArgumentException("Invalid Base64 string");
        }

        return result;
    }
}

```

`app/src/main/java/com/xiaoc/warlock/crypto/CompressUtil.java`:

```java
package com.xiaoc.warlock.crypto;

import java.io.ByteArrayOutputStream;
import java.nio.ByteBuffer;
import java.util.zip.CRC32;
import java.util.zip.Deflater;

public class CompressUtil {
    // 魔数和版本号
    private static final byte[] MAGIC = "CZIP".getBytes();
    private static final int VERSION = 1;

    // 头部大小：魔数(4) + 版本(4) + 原始长度(8) + CRC32(8)
    private static final int HEADER_SIZE = 24;

    /**
     * 压缩数据
     */
    public byte[] compress(byte[] data) throws Exception {
        // 1. 计算CRC32校验和
        CRC32 crc = new CRC32();
        crc.update(data);
        long checksum = crc.getValue();

        // 2. 压缩数据
        Deflater deflater = new Deflater(Deflater.BEST_COMPRESSION);
        deflater.setInput(data);
        deflater.finish();

        // 使用ByteArrayOutputStream动态增长
        ByteArrayOutputStream compressed = new ByteArrayOutputStream(data.length);
        byte[] buffer = new byte[1024];

        while (!deflater.finished()) {
            int count = deflater.deflate(buffer);
            compressed.write(buffer, 0, count);
        }
        deflater.end();

        byte[] compressedData = compressed.toByteArray();

        // 3. 构建头部和压缩数据
        ByteBuffer result = ByteBuffer.allocate(HEADER_SIZE + compressedData.length);
        result.put(MAGIC);                    // 魔数
        result.putInt(VERSION);               // 版本号
        result.putLong(data.length);          // 原始数据长度
        result.putLong(checksum);             // CRC32校验和
        result.put(compressedData);           // 压缩后的数据

        return result.array();
    }

}

```

`app/src/main/java/com/xiaoc/warlock/crypto/EncryptUtil.java`:

```java
package com.xiaoc.warlock.crypto;

import com.xiaoc.warlock.Util.XLog;

import java.nio.charset.StandardCharsets;
import java.security.SecureRandom;
import java.util.Arrays;

public class EncryptUtil {
    private String plaintext = "";
    private String base64Result;
    private String uuidMd5;
    private String uuid;
    private String timeStamp;
    private final SecureRandom secureRandom;
    public String result;

    public EncryptUtil(String plaintext){
        this.plaintext = plaintext;
        this.secureRandom = new SecureRandom();
        doEncrypt();
    }
    private void doEncrypt() {
        // 1. 先生成所需的基础数据
        generateBaseData();

        // 2. 生成key和iv
        byte[] key = generateKey();
        byte[] iv = generateIV();
        XLog.d("UUID:"+uuid);
        XLog.d("Key (hex): " + bytesToHex(key));
        XLog.d("Key (string): " + new String(key, StandardCharsets.UTF_8));
        XLog.d("IV (hex): " + bytesToHex(iv));
        XLog.d("IV (string): " + new String(iv, StandardCharsets.UTF_8));
        // 3. 使用AES加密
        byte[] encrypted = encryptData(key, iv);

        // 4. 重排结果
        result = rearrangeResult(Base64Util.encode(encrypted));
        XLog.d("Final result: " + result);
    }

    private void generateBaseData() {
        // Base64编码原文
        base64Result = Base64Util.encode(plaintext.getBytes(StandardCharsets.UTF_8));

        // 生成32位UUID
        uuid = generateHex(32);

        // 计算UUID的MD5
        uuidMd5 = MD5Util.md5(uuid);

        // 获取10位时间戳
        timeStamp = String.valueOf(System.currentTimeMillis() / 1000);
    }

    public String generateHex(int length) {
        byte[] bytes = new byte[length / 2];
        secureRandom.nextBytes(bytes);
        return bytesToHex(bytes);
    }
    private byte[] generateKey() {
        // 1. 将UUID间隔取值，得到两组数据
        char[] first8 = new char[8];
        char[] second8 = new char[8];
        int firstIndex = 0, secondIndex = 0;

        for(int i = 0; i < uuid.length(); i++) {
            if(i % 2 == 0 && firstIndex < 8) {
                first8[firstIndex++] = uuid.charAt(i);
            } else if(secondIndex < 8) {
                second8[secondIndex++] = uuid.charAt(i);
            }
        }

        // 2. 生成16字节的key
        byte[] key = new byte[16];

        // 前8位直接使用first8
        for(int i = 0; i < 8; i++) {
            key[i] = (byte) first8[i];
        }

        // 后8位使用异或结果
        for(int i = 0; i < 8; i++) {
            key[i + 8] = (byte) (first8[i] ^ second8[i]);
        }

        return key;
    }

    private byte[] generateIV() {
        String combined = uuidMd5 + timeStamp; // 42位

        StringBuilder frontPart = new StringBuilder();  // 存储前10位
        StringBuilder backPart = new StringBuilder();   // 存储后11位

        // 2. 从前往后每隔一位取10位
        int frontCount = 0;
        for(int i = 0; frontCount < 10 && i < combined.length(); i += 2) {
            frontPart.append(combined.charAt(i));
            frontCount++;
        }

        // 3. 从后往前每隔一位取11位
        int backCount = 0;
        for(int i = combined.length() - 1; backCount < 11 && i >= 0; i -= 2) {
            backPart.append(combined.charAt(i));
            backCount++;
        }

        // 4. 位移操作
        byte[] iv = new byte[16];
        Arrays.fill(iv, (byte)0);

        // 处理前10位（左移1位）
        String frontStr = frontPart.toString();
        for(int i = 0; i < 8; i++) {
            if(i < frontStr.length()) {
                iv[i] = (byte)((frontStr.charAt(i) << 1) & 0xFF);
            }
        }

        // 处理后11位（右移2位）
        String backStr = backPart.toString();
        for(int i = 0; i < 8; i++) {
            if(i < backStr.length()) {
                iv[i + 8] = (byte)((backStr.charAt(i) >> 2) & 0xFF);
            }
        }

        return iv;
    }

    private byte[] encryptData(byte[] key, byte[] iv) {
        AESUtil aes = new AESUtil();
        return aes.encrypt(base64Result.getBytes(), key,iv);
    }

    private String rearrangeResult(String encryptedBase64) {
        // 1. 拼接MD5、时间戳和UUID
        String combined = uuidMd5 + timeStamp + uuid;
        XLog.d("combined:" + combined);

        // 2. 计算首尾位和
        int sum = Character.getNumericValue(combined.charAt(0)) +
                Character.getNumericValue(combined.charAt(combined.length() - 1));
        XLog.d("sum:" + sum);

        // 3. 将组合字符串按sum值插入到加密结果中
        StringBuilder result = new StringBuilder(encryptedBase64);
        int currentPos = 0;

        // 遍历组合字符串的每个字符
        for(int i = 0; i < combined.length(); i++) {
            currentPos = (currentPos + sum) % result.length();
            // 在当前位置插入字符
            result.insert(currentPos, combined.charAt(i));
        }
        result.append("+").append(sum);

        return result.toString();
    }
    private  String bytesToHex(byte[] bytes) {
        StringBuilder result = new StringBuilder();
        for (byte b : bytes) {
            result.append(String.format("%02x", b));
        }
        return result.toString();
    }
}

```

`app/src/main/java/com/xiaoc/warlock/crypto/MD5Util.java`:

```java
package com.xiaoc.warlock.crypto;

public class MD5Util {
    /**
     * String text = "Hello, World!";
     * String hash = MD5Util.md5(text);
     * System.out.println(hash);
     */
    private static final int[] SHIFT = {
            7, 12, 17, 22,
            5,  9, 14, 20,
            4, 11, 16, 23,
            6, 10, 15, 21
    };

    private static final int[] TABLE = new int[64];

    static {
        for (int i = 0; i < 64; i++) {
            TABLE[i] = (int)(long)((1L << 32) * Math.abs(Math.sin(i + 1)));
        }
    }
    public static String md5(String input) {
        return md5(input.getBytes());
    }
    public static String md5(byte[] message) {

        // 初始化变量
        int a0 = 0x67452301;
        int b0 = 0xefcdab89;
        int c0 = 0x98badcfe;
        int d0 = 0x10325476;

        // 处理消息
        int paddedLength = ((message.length + 8) / 64 + 1) * 64;
        byte[] padded = new byte[paddedLength];
        System.arraycopy(message, 0, padded, 0, message.length);
        padded[message.length] = (byte)0x80;

        long messageLengthBits = (long)message.length * 8;
        for (int i = 0; i < 8; i++) {
            padded[padded.length - 8 + i] = (byte)messageLengthBits;
            messageLengthBits >>>= 8;
        }

        // 主循环
        int[] words = new int[16];
        for (int i = 0; i < padded.length; i += 64) {
            for (int j = 0; j < 16; j++) {
                words[j] = ((padded[i + j * 4] & 0xff)) |
                        ((padded[i + j * 4 + 1] & 0xff) << 8) |
                        ((padded[i + j * 4 + 2] & 0xff) << 16) |
                        ((padded[i + j * 4 + 3] & 0xff) << 24);
            }

            int A = a0;
            int B = b0;
            int C = c0;
            int D = d0;

            // 64轮运算
            for (int j = 0; j < 64; j++) {
                int F = 0;
                int g = 0;

                if (j < 16) {
                    F = (B & C) | (~B & D);
                    g = j;
                } else if (j < 32) {
                    F = (D & B) | (~D & C);
                    g = (5 * j + 1) % 16;
                } else if (j < 48) {
                    F = B ^ C ^ D;
                    g = (3 * j + 5) % 16;
                } else {
                    F = C ^ (B | ~D);
                    g = (7 * j) % 16;
                }

                int temp = D;
                D = C;
                C = B;
                B = B + Integer.rotateLeft(A + F + TABLE[j] + words[g], SHIFT[j % 4 + (j / 16) * 4]);
                A = temp;
            }

            a0 += A;
            b0 += B;
            c0 += C;
            d0 += D;
        }

        // 转换为十六进制字符串
        byte[] digest = new byte[16];
        int[] ints = {a0, b0, c0, d0};
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                digest[i * 4 + j] = (byte)(ints[i] >>> (j * 8));
            }
        }

        StringBuilder result = new StringBuilder();
        for (byte b : digest) {
            result.append(String.format("%02x", b & 0xff));
        }
        return result.toString();
    }
}
```

`app/src/main/java/com/xiaoc/warlock/manager/ServerManager.java`:

```java
package com.xiaoc.warlock.manager;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.os.RemoteException;

import com.xiaoc.warlock.IServerCallback;
import com.xiaoc.warlock.Util.XLog;
import com.xiaoc.warlock.service.WarLockServer;

public class ServerManager {
    private static final String TAG = "ServerManager";
    private static final long HEARTBEAT_INTERVAL = 3000; // 心跳间隔3秒
    private static final int MAX_FAILED_PINGS = 3; // 连续失败3次才报警

    private static ServerManager instance;
    private Context context;
    private IServerCallback sandboxCallback;
    private SandboxCallback callback;
    private ServiceStateCallback stateCallback;
    private boolean isServiceBound = false;

    // 心跳相关字段
    private Handler heartbeatHandler;
    private boolean isHeartbeatRunning = false;
    private int failedPingCount = 0;

    public interface SandboxCallback {
        void onSandboxDetected(String details);
    }

    public interface ServiceStateCallback {
        void onServiceDied(String reason);
    }

    private final Runnable heartbeatRunnable = new Runnable() {
        @Override
        public void run() {
            if (!isServiceBound || sandboxCallback == null) {
                stopHeartbeat();
                return;
            }

            if (!checkServiceAlive()) {
                handleHeartbeatFailure();
            } else {
                failedPingCount = 0; // 重置失败计数
            }

            // 安排下一次心跳
            if (isHeartbeatRunning) {
                heartbeatHandler.postDelayed(this, HEARTBEAT_INTERVAL);
            }
        }
    };

    private final ServiceConnection connection = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            sandboxCallback = IServerCallback.Stub.asInterface(service);
            XLog.d(TAG, "Service connected, checking service alive");

            if (!checkServiceAlive()) {
                handleServiceFailure("Service not responding after binding");
                return;
            }

            isServiceBound = true;
            XLog.d(TAG, "Service verified and ready");
            startHeartbeat();
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
            stopHeartbeat();
            sandboxCallback = null;
            isServiceBound = false;
            handleServiceFailure("Service disconnected unexpectedly");
        }
    };
    private void handleServiceFailure(String reason) {
        XLog.e(TAG, "Service failure: " + reason);

        // 通知服务状态回调
        if (stateCallback != null) {
            stateCallback.onServiceDied(reason);
        }

        // 通知沙箱检测回调
        if (callback != null) {
            callback.onSandboxDetected("Service failure detected: " + reason);
        }

        // 清理状态
        sandboxCallback = null;
        isServiceBound = false;

        try {
            context.unbindService(connection);
        } catch (Exception e) {
            XLog.e(TAG, "Error unbinding service", e);
        }
    }


    private ServerManager(Context context) {
        this.context = context.getApplicationContext();
        heartbeatHandler = new Handler(Looper.getMainLooper());
    }

    public static ServerManager getInstance(Context context) {
        if (instance == null) {
            synchronized (ServerManager.class) {
                if (instance == null) {
                    instance = new ServerManager(context);
                }
            }
        }
        return instance;
    }

    private void handleHeartbeatFailure() {
        failedPingCount++;
        XLog.e(TAG, "Heartbeat failed, count: " + failedPingCount);

        if (failedPingCount >= MAX_FAILED_PINGS) {
            XLog.e(TAG, "Heartbeat failed " + MAX_FAILED_PINGS + " times");
            handleServiceFailure("Service not responding to heartbeat");
            stopHeartbeat();
            rebindService();
        }
    }

    private void startHeartbeat() {
        if (!isHeartbeatRunning) {
            isHeartbeatRunning = true;
            failedPingCount = 0;
            XLog.d(TAG, "Starting heartbeat check");
            heartbeatHandler.post(heartbeatRunnable);
        }
    }

    private void stopHeartbeat() {
        if (isHeartbeatRunning) {
            XLog.d(TAG, "Stopping heartbeat check");
            isHeartbeatRunning = false;
            heartbeatHandler.removeCallbacks(heartbeatRunnable);
        }
    }

    private void rebindService() {
        try {
            context.unbindService(connection);
        } catch (Exception e) {
            XLog.e(TAG, "Error unbinding service during rebind", e);
        }

        sandboxCallback = null;
        isServiceBound = false;

        // 延迟一秒后重新绑定
        heartbeatHandler.postDelayed(new Runnable() {
            @Override
            public void run() {
                bindService();
            }
        }, 1000);
    }

    public void setServiceStateCallback(ServiceStateCallback callback) {
        XLog.d(TAG, "Setting service state callback: " + (callback != null));
        this.stateCallback = callback;
    }

    public void init(SandboxCallback callback) {
        this.callback = callback;
        bindService();
    }

    public boolean isServiceBound() {
        return isServiceBound;
    }

    private boolean checkServiceAlive() {
        if (sandboxCallback == null) {
            XLog.e(TAG, "sandboxCallback is null");
            return false;
        }

        try {
            XLog.d(TAG, "Attempting to ping service");
            sandboxCallback.ping();
            XLog.d(TAG, "Service ping successful");
            return true;
        } catch (RemoteException e) {
            XLog.e(TAG, "Failed to ping service", e);
            return false;
        } catch (Exception e) {
            XLog.e(TAG, "Unexpected error during ping", e);
            return false;
        }
    }

    private void bindService() {
        Intent intent = new Intent(context, WarLockServer.class);
        boolean bindResult = context.bindService(intent, connection, Context.BIND_AUTO_CREATE);
        if (!bindResult) {
            handleServiceFailure("Failed to start isolated service");
            XLog.e(TAG, "Failed to bind to isolated service");
        }
    }
    public void destroy() {
        stopHeartbeat();
        try {
            context.unbindService(connection);
        } catch (Exception e) {
            XLog.e(TAG, "Error unbinding service", e);
        }
        callback = null;
        stateCallback = null;

        if (heartbeatHandler != null) {
            heartbeatHandler.removeCallbacksAndMessages(null);
        }
    }
}
```

`app/src/main/java/com/xiaoc/warlock/network/NetworkClient.java`:

```java
package com.xiaoc.warlock.network;

import android.content.Context;
import android.os.Handler;
import android.os.Looper;

import com.xiaoc.warlock.Util.XLog;
import com.xiaoc.warlock.Util.XNetwork;
import com.xiaoc.warlock.crypto.EncryptUtil;
import com.xiaoc.warlock.ui.adapter.InfoItem;

import org.json.JSONException;
import org.json.JSONObject;
import org.json.JSONArray;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

public class NetworkClient {
    private static final String TAG = "NetworkClient";
    // 确保URL格式正确，必须包含http://或https://前缀
    private static final String BASE_URL = ""; // 替换为实际服务器地址
    private static final String GENERATE_EVENT_ID_ENDPOINT = "/api/generate/event_id";
    private static final String REPORT_DEVICE_ENDPOINT = "/api/device/report";
    private static final String REPORT_RISK_ENDPOINT = "/api/risk/report";
    
    private final Context context;
    private final Executor executor;
    private String eventId;
    private final List<EventIdCallback> eventIdCallbacks = new ArrayList<>();
    private final List<ReportCallback> reportCallbacks = new ArrayList<>();
    private final List<RiskReportCallback> riskReportCallbacks = new ArrayList<>();
    
    private static NetworkClient instance;
    
    public interface EventIdCallback {
        void onEventIdReceived(String eventId);
        void onEventIdError(String error);
    }
    
    public interface ReportCallback {
        void onReportSuccess(String eventId);
        void onReportError(String error);
    }
    
    public interface RiskReportCallback {
        void onRiskReportSuccess(String eventId);
        void onRiskReportError(String error);
    }
    
    private NetworkClient(Context context) {
        this.context = context.getApplicationContext();
        this.executor = Executors.newSingleThreadExecutor();
    }
    
    public static synchronized NetworkClient getInstance(Context context) {
        if (instance == null) {
            instance = new NetworkClient(context);
        }
        return instance;
    }
    
    public void registerEventIdCallback(EventIdCallback callback) {
        if (!eventIdCallbacks.contains(callback)) {
            eventIdCallbacks.add(callback);
        }
    }
    
    public void unregisterEventIdCallback(EventIdCallback callback) {
        eventIdCallbacks.remove(callback);
    }
    
    public void registerReportCallback(ReportCallback callback) {
        if (!reportCallbacks.contains(callback)) {
            reportCallbacks.add(callback);
        }
    }
    
    public void unregisterReportCallback(ReportCallback callback) {
        reportCallbacks.remove(callback);
    }
    
    public void registerRiskReportCallback(RiskReportCallback callback) {
        if (!riskReportCallbacks.contains(callback)) {
            riskReportCallbacks.add(callback);
        }
    }
    
    public void unregisterRiskReportCallback(RiskReportCallback callback) {
        riskReportCallbacks.remove(callback);
    }
    
    public void requestEventId() {
        executor.execute(() -> {
            try {
                String url = BASE_URL + GENERATE_EVENT_ID_ENDPOINT;
                XLog.d(TAG, "请求事件ID URL: " + url);
                
                // 使用XNetwork工具类进行GET请求
                XNetwork.get(url, new XNetwork.NetworkCallback() {
                    @Override
                    public void onSuccess(String response) {
                        try {
                            XLog.d(TAG, "获取事件ID响应: " + response);
                            JSONObject jsonResponse = new JSONObject(response);
                            
                            if (jsonResponse.getBoolean("success")) {
                                eventId = jsonResponse.getString("event_id");
                                XLog.d(TAG, "获取事件ID成功: " + eventId);
                                notifyEventIdReceived(eventId);
                            } else {
                                XLog.e(TAG, "获取事件ID失败: " + jsonResponse.optString("error"));
                                notifyEventIdError("服务器返回错误: " + jsonResponse.optString("error"));
                            }
                        } catch (JSONException e) {
                            XLog.e(TAG, "解析响应失败: " + e.getMessage());
                            notifyEventIdError("解析响应失败: " + e.getMessage());
                        }
                    }
                    
                    @Override
                    public void onFailure(String error) {
                        XLog.e(TAG, "获取事件ID失败: " + error);
                        notifyEventIdError("网络请求失败: " + error);
                    }
                });
            } catch (Exception e) {
                XLog.e(TAG, "创建请求失败: " + e.getMessage());
                notifyEventIdError("创建请求失败: " + e.getMessage());
            }
        });
    }
    
    public void reportDeviceFingerprint(String javaFingerprint, String nativeFingerprint) {
        executor.execute(() -> {
            if (eventId == null || eventId.isEmpty()) {
                XLog.e(TAG, "事件ID为空，无法上报设备指纹");
                notifyReportError("事件ID为空，请先获取事件ID");
                return;
            }
            
            try {
                // 合并Java和Native指纹数据
                JSONObject combined = new JSONObject();
                combined.put("java", javaFingerprint);
                combined.put("native",nativeFingerprint);

                String combinedJson = combined.toString();
                XLog.d(TAG, "合并后的指纹数据: " + combinedJson);

                // 准备请求数据
                JSONObject requestData = new JSONObject();
                requestData.put("event_id", eventId);
                requestData.put("data", combinedJson);

                String url = BASE_URL + REPORT_DEVICE_ENDPOINT;
                XLog.d(TAG, "上报设备指纹URL: " + url);
                
                // 使用XNetwork工具类进行POST请求
                XNetwork.postJson(url, requestData.toString(), new XNetwork.NetworkCallback() {
                    @Override
                    public void onSuccess(String response) {
                        try {
                            XLog.d(TAG, "上报设备指纹响应: " + response);
                            JSONObject jsonResponse = new JSONObject(response);
                            
                            if (jsonResponse.getBoolean("success")) {
                                String receivedEventId = jsonResponse.getString("event_id");
                                XLog.d(TAG, "上报设备指纹成功: " + receivedEventId);
                                notifyReportSuccess(receivedEventId);
                            } else {
                                XLog.e(TAG, "上报设备指纹失败: " + jsonResponse.optString("error"));
                                notifyReportError("服务器返回错误: " + jsonResponse.optString("error"));
                            }
                        } catch (JSONException e) {
                            XLog.e(TAG, "解析响应失败: " + e.getMessage());
                            notifyReportError("解析响应失败: " + e.getMessage());
                        }
                    }
                    
                    @Override
                    public void onFailure(String error) {
                        XLog.e(TAG, "上报设备指纹失败: " + error);
                        notifyReportError("网络请求失败: " + error);
                    }
                });
            } catch (Exception e) {
                XLog.e(TAG, "准备请求数据失败: " + e.getMessage());
                notifyReportError("准备请求数据失败: " + e.getMessage());
            }
        });
    }
    
    /**
     * 上报风险检测结果
     * @param riskItems 风险检测项列表
     */
    public void reportRiskInfo(List<InfoItem> riskItems) {
        executor.execute(() -> {
            if (eventId == null || eventId.isEmpty()) {
                XLog.e(TAG, "事件ID为空，无法上报风险信息");
                notifyRiskReportError("事件ID为空，请先获取事件ID");
                return;
            }
            
            try {
                // 将InfoItem列表转换为JSON数组
                JSONArray riskDataArray = new JSONArray();
                
                for (InfoItem item : riskItems) {
                    JSONObject itemJson = new JSONObject();
                    itemJson.put("title", item.getTitle());
                    
                    // 添加详细信息
                    for (InfoItem.DetailItem detail : item.getDetails()) {
                        itemJson.put(detail.getKey(), detail.getValue());
                    }
                    
                    riskDataArray.put(itemJson);
                }
                
                // 准备请求数据
                JSONObject requestData = new JSONObject();
                requestData.put("event_id", eventId);
                requestData.put("data", riskDataArray);
                
                String url = BASE_URL + REPORT_RISK_ENDPOINT;
                XLog.d(TAG, "上报风险信息URL: " + url);
                XLog.d(TAG, "上报风险数据: " + requestData.toString());
                
                // 使用XNetwork工具类进行POST请求
                XNetwork.postJson(url, requestData.toString(), new XNetwork.NetworkCallback() {
                    @Override
                    public void onSuccess(String response) {
                        try {
                            XLog.d(TAG, "上报风险信息响应: " + response);
                            JSONObject jsonResponse = new JSONObject(response);
                            
                            if (jsonResponse.getBoolean("success")) {
                                String receivedEventId = jsonResponse.getString("event_id");
                                XLog.d(TAG, "上报风险信息成功: " + receivedEventId);
                                notifyRiskReportSuccess(receivedEventId);
                            } else {
                                XLog.e(TAG, "上报风险信息失败: " + jsonResponse.optString("error"));
                                notifyRiskReportError("服务器返回错误: " + jsonResponse.optString("error"));
                            }
                        } catch (JSONException e) {
                            XLog.e(TAG, "解析响应失败: " + e.getMessage());
                            notifyRiskReportError("解析响应失败: " + e.getMessage());
                        }
                    }
                    
                    @Override
                    public void onFailure(String error) {
                        XLog.e(TAG, "上报风险信息失败: " + error);
                        notifyRiskReportError("网络请求失败: " + error);
                    }
                });
            } catch (Exception e) {
                XLog.e(TAG, "准备风险数据失败: " + e.getMessage());
                notifyRiskReportError("准备风险数据失败: " + e.getMessage());
            }
        });
    }
    
    /**
     * 直接设置事件ID，用于测试或从其他来源获取事件ID
     * @param eventId 事件ID
     */
    public void setEventId(String eventId) {
        this.eventId = eventId;
    }
    
    /**
     * 获取当前事件ID
     * @return 当前事件ID，如果未获取则返回null
     */
    public String getEventId() {
        return eventId;
    }
    
    private void notifyEventIdReceived(String eventId) {
        new Handler(Looper.getMainLooper()).post(() -> {
            for (EventIdCallback callback : eventIdCallbacks) {
                callback.onEventIdReceived(eventId);
            }
        });
    }
    
    private void notifyEventIdError(String error) {
        new Handler(Looper.getMainLooper()).post(() -> {
            for (EventIdCallback callback : eventIdCallbacks) {
                callback.onEventIdError(error);
            }
        });
    }
    
    private void notifyReportSuccess(String eventId) {
        new Handler(Looper.getMainLooper()).post(() -> {
            for (ReportCallback callback : reportCallbacks) {
                callback.onReportSuccess(eventId);
            }
        });
    }
    
    private void notifyReportError(String error) {
        new Handler(Looper.getMainLooper()).post(() -> {
            for (ReportCallback callback : reportCallbacks) {
                callback.onReportError(error);
            }
        });
    }
    
    private void notifyRiskReportSuccess(String eventId) {
        new Handler(Looper.getMainLooper()).post(() -> {
            for (RiskReportCallback callback : riskReportCallbacks) {
                callback.onRiskReportSuccess(eventId);
            }
        });
    }
    
    private void notifyRiskReportError(String error) {
        new Handler(Looper.getMainLooper()).post(() -> {
            for (RiskReportCallback callback : riskReportCallbacks) {
                callback.onRiskReportError(error);
            }
        });
    }
} 
```

`app/src/main/java/com/xiaoc/warlock/service/WarLockServer.java`:

```java
package com.xiaoc.warlock.service;

import android.app.Service;
import android.content.Intent;
import android.os.IBinder;
import android.os.RemoteCallbackList;

import com.xiaoc.warlock.IServerCallback;
import com.xiaoc.warlock.Util.XLog;


public class WarLockServer extends Service {
    private static final String TAG = "WarLockServer";

    static {
        System.loadLibrary("warlockServer");
    }

    private final RemoteCallbackList<IServerCallback> callbacks = new RemoteCallbackList<>();

    private final IServerCallback.Stub binder = new IServerCallback.Stub() {
        @Override
        public void onSandboxDetected(String details) {
            notifyDetection(details);
        }

        @Override
        public void ping() {
            XLog.d(TAG, "Service received ping request");
        }
    };


    private native void nativeCheckSandbox();

    @Override
    public IBinder onBind(Intent intent) {
        XLog.d(TAG, "Service onBind called");
        return binder;
    }

    // Native 回调方法
    private void onSandboxDetected(String details) {
        notifyDetection(details);
    }

    private void notifyDetection(String details) {
        // 通知所有注册的回调
        int n = callbacks.beginBroadcast();
        try {
            for (int i = 0; i < n; i++) {
                IServerCallback callback = callbacks.getBroadcastItem(i);
                try {
                    callback.onSandboxDetected(details);
                } catch (Exception e) {
                    XLog.e(TAG, "Failed to notify callback", e);
                }
            }
        } finally {
            callbacks.finishBroadcast();
        }
    }


    public void onCreate() {
        super.onCreate();


        nativeCheckSandbox();
    }


    @Override
    public void onDestroy() {
        super.onDestroy();
        callbacks.kill();
    }
}
```

`app/src/main/java/com/xiaoc/warlock/ui/MainUI.java`:

```java
package com.xiaoc.warlock.ui;


import android.os.Build;
import android.view.View;

import android.view.Window;
import android.view.WindowManager;
import android.widget.ImageButton;

import androidx.viewpager2.widget.ViewPager2;
import androidx.fragment.app.FragmentActivity;

import com.google.android.material.bottomsheet.BottomSheetDialog;

import com.google.android.material.tabs.TabLayout;
import com.google.android.material.tabs.TabLayoutMediator;
import com.xiaoc.warlock.R;
import com.xiaoc.warlock.ui.adapter.ViewPagerAdapter;
import com.xiaoc.warlock.ui.dialog.DialogManager;

public class MainUI {
    private final FragmentActivity activity;
    private ViewPager2 viewPager;
    private TabLayout tabLayout;
    private ViewPagerAdapter pagerAdapter;
    private final DialogManager dialogManager;

    public MainUI(FragmentActivity activity) {
        this.activity = activity;
        this.dialogManager = new DialogManager(activity);

        initUI();
        setupStatusBar();
    }

    private void initUI() {
        // 设置布局
        activity.setContentView(R.layout.activity_main);
        // 设置 Toolbar
        ImageButton menuButton = activity.findViewById(R.id.menuButton);
        menuButton.setOnClickListener(v -> showBottomSheetMenu());

        // 初始化视图
        viewPager = activity.findViewById(R.id.viewPager);
        tabLayout = activity.findViewById(R.id.tabLayout);

        // 设置适配器
        pagerAdapter = new ViewPagerAdapter(activity);
        viewPager.setAdapter(pagerAdapter);

        // 设置离屏页面限制
        viewPager.setOffscreenPageLimit(1);

        // 添加页面切换监听
        viewPager.registerOnPageChangeCallback(new ViewPager2.OnPageChangeCallback() {
            @Override
            public void onPageSelected(int position) {
                super.onPageSelected(position);
                // 在这里处理页面切换事件
            }
        });

        // 设置TabLayout和ViewPager2关联
        new TabLayoutMediator(tabLayout, viewPager, (tab, position) -> {
            String[] titles = new String[]{"设备指纹", "环境检测"};
            tab.setText(titles[position]);
        }).attach();
    }

    private void setupStatusBar() {
        // 设置状态栏透明
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            Window window = activity.getWindow();
            window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
            window.setStatusBarColor(activity.getResources().getColor(R.color.primary_color));

            // 设置状态栏文字颜色
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                View decorView = window.getDecorView();
                decorView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR);
            }
        }
    }


    public void showBottomSheetMenu() {
        BottomSheetDialog dialog = new BottomSheetDialog(activity);
        View view = activity.getLayoutInflater().inflate(R.layout.layout_menu_sheet, null);

        view.findViewById(R.id.btn_about).setOnClickListener(v -> {
            dialog.dismiss();
            dialogManager.showAboutDialog();
        });

//        view.findViewById(R.id.btn_explain).setOnClickListener(v -> {
//            dialog.dismiss();
//            dialogManager.showexplainDialog();
//        });

        view.findViewById(R.id.btn_feedback).setOnClickListener(v -> {
            dialog.dismiss();
            dialogManager.showFeedbackDialog();
        });

        view.findViewById(R.id.btn_settings).setOnClickListener(v -> {
            dialog.dismiss();
            dialogManager.showSettingsDialog();
        });

        dialog.setContentView(view);
        dialog.show();
    }

}
```

`app/src/main/java/com/xiaoc/warlock/ui/adapter/InfoAdapter.java`:

```java
package com.xiaoc.warlock.ui.adapter;

import android.graphics.Color;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;

import com.google.android.material.card.MaterialCardView;
import com.xiaoc.warlock.R;
import com.xiaoc.warlock.Util.ClipboardUtil;

import java.util.ArrayList;
import java.util.List;

public class InfoAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolder> {
    private final List<InfoItem> items;
    private final boolean isEnvironmentInfo;
    private static final int TYPE_NORMAL = 0;
    private static final int TYPE_EMPTY = 1;

    public InfoAdapter(boolean isEnvironmentInfo) {
        this.isEnvironmentInfo = isEnvironmentInfo;
        this.items = new ArrayList<>();
    }
    
    public InfoAdapter(List<InfoItem> items) {
        this.isEnvironmentInfo = false;
        this.items = items;
    }

    @NonNull
    @Override
    public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        if (isEnvironmentInfo && viewType == TYPE_EMPTY) {
            View view = LayoutInflater.from(parent.getContext())
                    .inflate(R.layout.item_empty_state, parent, false);
            return new EmptyViewHolder(view);
        }
        View view = LayoutInflater.from(parent.getContext())
                .inflate(R.layout.item_info_card, parent, false);
        return new InfoViewHolder(view);
    }

    @Override
    public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int position) {
        if (holder instanceof EmptyViewHolder && isEnvironmentInfo) {
            ((EmptyViewHolder) holder).bind();
        } else if (holder instanceof InfoViewHolder) {
            ((InfoViewHolder) holder).bind(items.get(position), isEnvironmentInfo);
        }
    }

    @Override
    public int getItemCount() {
        return isEnvironmentInfo && items.isEmpty() ? 1 : items.size();
    }

    @Override
    public int getItemViewType(int position) {
        return (isEnvironmentInfo && items.isEmpty()) ? TYPE_EMPTY : TYPE_NORMAL;
    }

    public void addItem(InfoItem item) {
        boolean wasEmpty = items.isEmpty();
        items.add(item);

        if (wasEmpty && isEnvironmentInfo) {
            notifyDataSetChanged();
        } else {
            notifyItemInserted(items.size() - 1);
        }
    }

    public void setItems(List<InfoItem> newItems) {
        items.clear();
        items.addAll(newItems);
        notifyDataSetChanged();
    }

    static class InfoViewHolder extends RecyclerView.ViewHolder {
        private final MaterialCardView cardView;
        private final TextView titleText;
        private final ImageView expandIcon;
        private final View headerLayout;
        private final View detailsLayout;
        private final LinearLayout detailsList;

        InfoViewHolder(View view) {
            super(view);
            cardView = (MaterialCardView) view;
            titleText = view.findViewById(R.id.titleText);
            expandIcon = view.findViewById(R.id.expandIcon);
            headerLayout = view.findViewById(R.id.headerLayout);
            detailsLayout = view.findViewById(R.id.detailsLayout);
            detailsList = view.findViewById(R.id.detailsList);
        }

        void bind(InfoItem item, boolean isEnvironmentInfo) {
            titleText.setText(item.getTitle());

            detailsLayout.setVisibility(item.isExpanded() ? View.VISIBLE : View.GONE);
            expandIcon.setRotation(item.isExpanded() ? 180 : 0);

            headerLayout.setOnClickListener(v -> {
                item.setExpanded(!item.isExpanded());
                detailsLayout.setVisibility(item.isExpanded() ? View.VISIBLE : View.GONE);
                expandIcon.animate().rotation(item.isExpanded() ? 180 : 0).setDuration(200).start();
            });

            detailsList.removeAllViews();
            for (InfoItem.DetailItem detail : item.getDetails()) {
                View detailView = LayoutInflater.from(detailsList.getContext())
                        .inflate(R.layout.item_detail, detailsList, false);

                TextView keyText = detailView.findViewById(R.id.keyText);
                TextView valueText = detailView.findViewById(R.id.valueText);

                keyText.setText(detail.getKey());
                valueText.setText(detail.getValue());

                detailsList.addView(detailView);
            }

            cardView.setOnLongClickListener(v -> {
                ClipboardUtil.copyInfoItemToClipboard(v.getContext(), item, isEnvironmentInfo);
                return true;
            });

            cardView.setClickable(true);
            cardView.setFocusable(true);
            cardView.setRippleColorResource(R.color.ripple_color);
        }
    }

    static class EmptyViewHolder extends RecyclerView.ViewHolder {
        private final ImageView emptyStateIcon;
        private final TextView emptyStateTitle;
        private final TextView emptyStateDescription;

        EmptyViewHolder(@NonNull View itemView) {
            super(itemView);
            emptyStateIcon = itemView.findViewById(R.id.emptyStateIcon);
            emptyStateTitle = itemView.findViewById(R.id.emptyStateTitle);
            emptyStateDescription = itemView.findViewById(R.id.emptyStateDescription);
        }

        void bind() {
            emptyStateIcon.setImageResource(R.drawable.ic_security);
            emptyStateIcon.setColorFilter(Color.parseColor("#4CAF50"));
            emptyStateTitle.setText("环境安全");
            emptyStateDescription.setText("未检测到任何安全风险\n您的设备环境运行正常");
        }
    }
}
```

`app/src/main/java/com/xiaoc/warlock/ui/adapter/InfoItem.java`:

```java
package com.xiaoc.warlock.ui.adapter;

import java.util.ArrayList;
import java.util.List;

public class InfoItem {
    private String title;
    private String content;
    private List<DetailItem> details;
    private boolean isExpanded;

    public static class DetailItem {
        private String key;
        private String value;

        public DetailItem(String key, String value) {
            this.key = key;
            this.value = value;
        }

        public String getKey() { return key; }
        public String getValue() { return value; }
    }

    public InfoItem(String title, String content) {
        this.title = title;
        this.content = content;
        this.details = new ArrayList<>();
        this.isExpanded = false;
    }

    public void addDetail(String key, String value) {
        details.add(new DetailItem(key, value));
    }

    public String getTitle() { return title; }
    public String getContent() { return content; }
    public List<DetailItem> getDetails() { return details; }
    public boolean isExpanded() { return isExpanded; }
    public void setExpanded(boolean expanded) { isExpanded = expanded; }
}
```

`app/src/main/java/com/xiaoc/warlock/ui/adapter/ViewPagerAdapter.java`:

```java
package com.xiaoc.warlock.ui.adapter;

import androidx.annotation.NonNull;
import androidx.fragment.app.Fragment;
import androidx.fragment.app.FragmentActivity;
import androidx.viewpager2.adapter.FragmentStateAdapter;
import com.xiaoc.warlock.ui.fragment.FingerprintFragment;
import com.xiaoc.warlock.ui.fragment.EnvironmentFragment;

public class ViewPagerAdapter extends FragmentStateAdapter {
    public ViewPagerAdapter(@NonNull FragmentActivity fragmentActivity) {
        super(fragmentActivity);
    }

    @NonNull
    @Override
    public Fragment createFragment(int position) {
        // 每次需要时创建新的 Fragment 实例
        return position == 0 ? new FingerprintFragment() : new EnvironmentFragment();
    }

    @Override
    public int getItemCount() {
        return 2;
    }
}
```

`app/src/main/java/com/xiaoc/warlock/ui/dialog/DialogManager.java`:

```java
package com.xiaoc.warlock.ui.dialog;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.net.Uri;
import android.os.Handler;
import android.view.View;
import android.widget.TextView;
import android.widget.Toast;

import androidx.appcompat.app.AlertDialog;
import androidx.fragment.app.FragmentActivity;

import com.google.android.material.button.MaterialButton;
import com.google.android.material.dialog.MaterialAlertDialogBuilder;
import com.google.android.material.switchmaterial.SwitchMaterial;
import com.xiaoc.warlock.R;

import java.io.File;

public class DialogManager {
    private final FragmentActivity activity;

    public DialogManager(FragmentActivity activity) {
        this.activity = activity;
    }

    public void showAboutDialog() {
        MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder(activity)
                .setTitle("关于 WarLock")
                .setMessage(
                        "WarLock 是一个设备指纹和环境检测工具，同时具备黑灰产设备感知以及唯一设备的能力。\n\n" +
                                "主要功能：\n" +
                                "• 收集设备信息\n" +
                                "• 检测运行环境安全性\n" +
                                "• 生成设备唯一标识\n" +
                                "• 分析环境特征\n\n" +
                                "开发者：xiaoc\n\n" +
                                "项目开源计划：作者计划在2025年进行改机项目的研发，同时将本项目及其后端完整开源。\n\n"

                )
                .setPositiveButton("确定", null)
                .setNeutralButton("访问项目主页", (dialog, which) -> {
                    // 打开项目主页
                    try {
                        Intent intent = new Intent(Intent.ACTION_VIEW);
                        intent.setData(Uri.parse("https://github.com/imxiaoc996/DeviceWarLock"));
                        activity.startActivity(intent);
                    } catch (Exception e) {
                        Toast.makeText(activity, "无法打开浏览器", Toast.LENGTH_SHORT).show();
                    }
                });

        // 创建并显示对话框
        AlertDialog dialog = builder.create();

        // 设置消息文本的对齐方式（可选）
        TextView messageView = dialog.findViewById(android.R.id.message);
        if (messageView != null) {
            messageView.setTextAlignment(View.TEXT_ALIGNMENT_VIEW_START);
        }

        dialog.show();
    }
    public void showexplainDialog() {
        MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder(activity)
                .setTitle("WarLock 使用说明")
                .setMessage(
                        "隐私保护承诺：\n\n" +
                                "• 所有上传的设备信息及指纹数据将在5天后自动删除\n" +
                                "• 应用列表(AppList)仅用于本地环境检测，绝不上传服务器\n\n" +
                                "核心功能说明：\n\n" +
                                "1. 设备指纹服务\n" +
                                "   • 客户端采集设备特征信息\n" +
                                "   • 服务端通过多重算法生成四重防伪指纹\n\n" +
                                "2. 环境检测服务\n" +
                                "   • 90%的检测逻辑在本地执行\n" +
                                "   • 服务端协助分析设备指纹，提供额外10%的风险识别\n" +
                                "   • 双重校验确保更准确的环境安全评估"
                )
                .setPositiveButton("确定", null);

        // 创建并显示对话框
        AlertDialog dialog = builder.create();

        // 设置消息文本的对齐方式（可选）
        TextView messageView = dialog.findViewById(android.R.id.message);
        if (messageView != null) {
            messageView.setTextAlignment(View.TEXT_ALIGNMENT_VIEW_START);
        }

        dialog.show();
    }
    public void showFeedbackDialog() {
        MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder(activity)
                .setTitle("反馈与支持")
                .setMessage(
                        "您可以通过以下方式反馈问题或获取帮助：\n\n" +
                                "• GitHub Issues：提交问题或建议\n" +
                                "• 微信：xiaoc_engine\n\n" +
                                "如果您觉得这个项目对您有帮助，欢迎：\n\n" +
                                "• 在 GitHub 上点个 Star\n" +
                                "• 推荐给其他开发者\n" +
                                "• 参与项目开发"
                )
                .setPositiveButton("GitHub", (dialog, which) -> {
                    openGitHub();
                })
                .setNegativeButton("关闭", null);

        builder.create().show();
    }
    private void openGitHub() {
        try {
            Intent intent = new Intent(Intent.ACTION_VIEW);
            intent.setData(Uri.parse("https://github.com/imxiaoc996/DeviceWarLock/issues"));
            activity.startActivity(intent);
        } catch (Exception e) {
            Toast.makeText(activity, "无法打开浏览器", Toast.LENGTH_SHORT).show();
        }
    }
    public void showSettingsDialog() {
        MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder(activity)
                .setTitle("设置")
                .setView(createSettingsView());

        AlertDialog dialog = builder.create();
        dialog.show();
    }

    private View createSettingsView() {
        View view = activity.getLayoutInflater().inflate(R.layout.dialog_settings, null);
        initSettingsControls(view);
        return view;
    }

    private void initSettingsControls(View view) {
        SwitchMaterial switchNoReport = view.findViewById(R.id.switch_no_report);
        switchNoReport.setChecked(getNoReportSetting());
        switchNoReport.setOnCheckedChangeListener((buttonView, isChecked) -> {
            if (isChecked) {
                // 当用户尝试开启"不上报"时，显示确认对话框
                new MaterialAlertDialogBuilder(activity)
                        .setTitle("功能说明")
                        .setMessage("开启\"设备信息不上报服务器\"后：\n\n" +
                                "• 将不会生成唯一设备指纹信息\n" +
                                "• 环境检测服务会减少服务端侧的识别逻辑\n" +
                                "• 所有检测仅在本地进行\n\n" +
                                "确定要开启此功能吗？")
                        .setPositiveButton("确定", (dialog, which) -> {
                            saveNoReportSetting(true);
                            Toast.makeText(activity, "设置已保存", Toast.LENGTH_SHORT).show();
                        })
                        .setNegativeButton("取消", (dialog, which) -> {
                            // 如果用户取消，将开关状态改回
                            switchNoReport.setChecked(false);
                        })
                        .show();
            } else {
                // 当用户关闭"不上报"时，直接保存设置
                saveNoReportSetting(false);
                Toast.makeText(activity, "设置已保存", Toast.LENGTH_SHORT).show();
            }
        });

        // 重启应用按钮
        MaterialButton btnRestartApp = view.findViewById(R.id.btn_restart_app);
        btnRestartApp.setOnClickListener(v -> {
            new MaterialAlertDialogBuilder(activity)
                    .setTitle("重启应用")
                    .setMessage("确定要重启应用吗？")
                    .setPositiveButton("确定", (dialog, which) -> restartApp())
                    .setNegativeButton("取消", null)
                    .show();
        });

        // 清除数据按钮
        MaterialButton btnClearData = view.findViewById(R.id.btn_clear_data);
        btnClearData.setOnClickListener(v -> {
            new MaterialAlertDialogBuilder(activity)
                    .setTitle("清除数据")
                    .setMessage("此操作将清除所有已收集的数据，确定继续吗？")
                    .setPositiveButton("确定", (dialog, which) -> clearAllData())
                    .setNegativeButton("取消", null)
                    .show();
        });
    }

    // 保存不上报设置
    private void saveNoReportSetting(boolean noReport) {
        SharedPreferences prefs = activity.getSharedPreferences("settings", Context.MODE_PRIVATE);
        prefs.edit().putBoolean("no_report", noReport).apply();
    }

    // 获取不上报设置
    private boolean getNoReportSetting() {
        SharedPreferences prefs = activity.getSharedPreferences("settings", Context.MODE_PRIVATE);
        return prefs.getBoolean("no_report", false);
    }

    // 重启应用
    private void restartApp() {
        Intent intent = activity.getPackageManager()
                .getLaunchIntentForPackage(activity.getPackageName());
        if (intent != null) {
            intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            activity.startActivity(intent);
            activity.finish();
            Runtime.getRuntime().exit(0);
        }
    }

    // 清除数据
    private void clearAllData() {
        // 清除SharedPreferences
        activity.getSharedPreferences("settings", Context.MODE_PRIVATE)
                .edit().clear().apply();

        // 清除文件
        File dir = activity.getFilesDir();
        deleteRecursive(dir);

        // 清除缓存
        activity.getCacheDir().delete();

        Toast.makeText(activity, "数据已清除", Toast.LENGTH_SHORT).show();

        // 延迟1秒后重启应用
        new Handler().postDelayed(this::restartApp, 1000);
    }

    private void deleteRecursive(File fileOrDirectory) {
        if (fileOrDirectory.isDirectory()) {
            for (File child : fileOrDirectory.listFiles()) {
                deleteRecursive(child);
            }
        }
        fileOrDirectory.delete();
    }
}

```

`app/src/main/java/com/xiaoc/warlock/ui/fragment/EnvironmentFragment.java`:

```java
package com.xiaoc.warlock.ui.fragment;

import android.content.Context;
import android.graphics.Color;
import android.graphics.Rect;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.text.Spannable;
import android.text.SpannableString;
import android.text.SpannableStringBuilder;
import android.text.style.ForegroundColorSpan;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ProgressBar;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.fragment.app.Fragment;
import androidx.recyclerview.widget.DefaultItemAnimator;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import com.xiaoc.warlock.Core.DetectCallback;
import com.xiaoc.warlock.Core.EnvironmentDetector;
import com.xiaoc.warlock.R;
import java.util.ArrayList;

import com.xiaoc.warlock.Util.NativeEngine;
import com.xiaoc.warlock.Util.WarningBuilder;
import com.xiaoc.warlock.Util.XLog;
import com.xiaoc.warlock.network.NetworkClient;
import com.xiaoc.warlock.ui.adapter.InfoAdapter;
import com.xiaoc.warlock.ui.adapter.InfoItem;

import java.util.ArrayList;
import java.util.List;

public class EnvironmentFragment extends Fragment implements EnvironmentDetector.EnvironmentCallback, NetworkClient.RiskReportCallback {
    private RecyclerView recyclerView;
    private InfoAdapter adapter;
    private TextView loadingText;
    private EnvironmentDetector detector;
    private String TAG = "EnvironmentFragment";
    private boolean isDetectionRunning = false;
    private Handler loadingHandler;
    private int dotCount = 0;
    private static final int UPDATE_LOADING_TEXT = 1;
    private final List<InfoItem> pendingWarnings = new ArrayList<>(); // 用于存储延迟期间收到的警告
    private boolean isDelayComplete = false;
    private NetworkClient networkClient;
    private boolean isRiskReportScheduled = false;
    private final List<InfoItem> riskItems = new ArrayList<>(); // 存储风险项
    private Handler riskReportHandler = new Handler(Looper.getMainLooper());
    private static final long RISK_REPORT_DELAY = 10000; // 10秒延迟
    
    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        detector = EnvironmentDetector.getInstance(requireContext());
        loadingHandler = new Handler(Looper.getMainLooper()) {
            @Override
            public void handleMessage(@NonNull Message msg) {
                if (msg.what == UPDATE_LOADING_TEXT && loadingText != null) {
                    updateLoadingText();
                    sendEmptyMessageDelayed(UPDATE_LOADING_TEXT, 500); // 每500ms更新一次
                }
            }
        };
        
        // 初始化网络客户端
        networkClient = NetworkClient.getInstance(requireContext());
        networkClient.registerRiskReportCallback(this);
    }
    @Override
    public View onCreateView(@NonNull LayoutInflater inflater,
                             @Nullable ViewGroup container,
                             @Nullable Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.fragment_environment, container, false);
        recyclerView = view.findViewById(R.id.recyclerView);
        loadingText = view.findViewById(R.id.loadingText);
        return view;
    }
    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        initRecyclerView();
    }

    private void startDetection() {
        if (isDetectionRunning) return; // 防止重复启动

        isDelayComplete = false;
        pendingWarnings.clear();
        riskItems.clear();
        isRiskReportScheduled = false;

        // 启动延时线程
        new Thread(() -> {
            try {
                Thread.sleep(10);
                isDelayComplete = true;

                requireActivity().runOnUiThread(() -> {
                    if (!isAdded()) return;


                    // 显示所有积累的警告
                    for (InfoItem warning : pendingWarnings) {
                        adapter.addItem(warning);
                        
                        // 检查是否为风险项（含有level字段）
                        if (hasLevelField(warning)) {
                            riskItems.add(warning);
                        }
                    }
                    pendingWarnings.clear();

                    // 如果没有警告，也要隐藏加载状态
                    if (adapter.getItemCount() == 0) {
                        showLoading(false);
                    }
                    
                    // 安排10秒后的风险上报（仅一次）
                    if (!riskItems.isEmpty() && !isRiskReportScheduled) {
                        scheduleRiskReport();
                    }
                });

                // 启动检测
                XLog.d(TAG, "Starting Java detection");
                detector.registerCallback(this);
                detector.startDetection();

                XLog.d(TAG, "Starting Native detection");
                NativeEngine.startDetect(nativeCallback);

                isDetectionRunning = true;

            } catch (InterruptedException e) {
                XLog.e(TAG, "Delay interrupted: " + e.getMessage());
            }
        }).start();
    }

    // 检查InfoItem是否包含level字段（风险项）
    private boolean hasLevelField(InfoItem item) {
        for (InfoItem.DetailItem detail : item.getDetails()) {
            if ("level".equals(detail.getKey())) {
                return true;
            }
        }
        return false;
    }

    private void initRecyclerView() {
        LinearLayoutManager layoutManager = new LinearLayoutManager(getContext());
        recyclerView.setLayoutManager(layoutManager);
        adapter = new InfoAdapter(true);
        recyclerView.setAdapter(adapter);

        recyclerView.setItemAnimator(new DefaultItemAnimator());
        recyclerView.addItemDecoration(new RecyclerView.ItemDecoration() {
            @Override
            public void getItemOffsets(@NonNull Rect outRect, @NonNull View view,
                                       @NonNull RecyclerView parent, @NonNull RecyclerView.State state) {
                outRect.bottom = 8;
            }
        });
    }

    private final DetectCallback nativeCallback = new DetectCallback() {
        @Override
        public Context getContext() {
            return requireContext().getApplicationContext();
        }

        @Override
        public void onDetectWarning(String type, String level, String detail) {
            if (!isAdded()) return;

            InfoItem warning = new WarningBuilder(type, null)
                    .addDetail("check", detail)
                    .addDetail("level", level)
                    .build();

            onEnvironmentChanged(warning);
        }
    };
    @Override
    public void onResume() {
        super.onResume();
        if (!isDetectionRunning) {
            showLoading(true);
            startDetection();
        } else if (!riskItems.isEmpty() && !isRiskReportScheduled) {
            // 如果有风险项但没有安排上报，重新安排上报
            XLog.d(TAG, "Fragment恢复，重新安排风险上报");
            scheduleRiskReport();
        }
    }

    @Override
    public void onPause() {
        super.onPause();
        // 取消加载动画相关的消息
        if (loadingHandler != null) {
            loadingHandler.removeMessages(UPDATE_LOADING_TEXT);
        }
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        // 清理Handler资源
        if (loadingHandler != null) {
            loadingHandler.removeCallbacksAndMessages(null);
            loadingHandler = null;
        }
        if (riskReportHandler != null) {
            riskReportHandler.removeCallbacksAndMessages(null);
            riskReportHandler = null;
        }
        
        // 停止检测
        if (detector != null) {
            detector.unregisterCallback(this);
            detector.stopDetection();
        }
        NativeEngine.stopDetect();
        showLoading(false);
        
        // 注销回调
        if (networkClient != null) {
            networkClient.unregisterRiskReportCallback(this);
        }
        
        // 清理列表资源
        synchronized (riskItems) {
            riskItems.clear();
        }
        synchronized (pendingWarnings) {
            pendingWarnings.clear();
        }

        // 清理RecyclerView资源
        if (recyclerView != null) {
            recyclerView.setAdapter(null);
        }
        adapter = null;
    }

    @Override
    public void onEnvironmentChanged(InfoItem newItem) {
        XLog.d(TAG, "Received environment change in fragment: " + newItem.getTitle());
        
        // 检查是否为风险项（含有level字段）
        boolean isRiskItem = hasLevelField(newItem);
        if (isRiskItem) {
            // 无论Fragment是否活跃，都将风险项添加到列表中
            synchronized (riskItems) {
                riskItems.add(newItem);
            }
            XLog.d(TAG, "添加风险项: " + newItem.getTitle());
        }
        
        // 只有在Fragment活跃时才更新UI
        if (isAdded() && !isDetached() && getActivity() != null) {
            try {
                getActivity().runOnUiThread(() -> {
                    if (!isAdded()) return;
    
                    if (!isDelayComplete) {
                        pendingWarnings.add(newItem);
                    } else {
                        showLoading(false);
                        adapter.addItem(newItem);
                    }
                    XLog.d(TAG, "Processed warning in UI: " + newItem.getTitle());
                });
            } catch (Exception e) {
                XLog.e(TAG, "更新UI失败: " + e.getMessage());
            }
        } else {
            XLog.d(TAG, "Fragment不活跃，跳过UI更新");
            // 如果Fragment不活跃，但延迟已完成，仍然将警告添加到pendingWarnings
            if (isDelayComplete && !isRiskItem) {
                synchronized (pendingWarnings) {
                    pendingWarnings.add(newItem);
                }
            }
        }
    }

    // 风险上报任务（延迟10秒）
    private void scheduleRiskReport() {
        if (!isRiskReportScheduled) {
            isRiskReportScheduled = true;
            XLog.d(TAG, "风险上报任务，将在10秒后执行");
            
            // 安排新任务，延迟10秒后执行一次性上报
            riskReportHandler.postDelayed(this::reportRiskItems, RISK_REPORT_DELAY);
        }
    }
    
    // 上报风险项
    private void reportRiskItems() {
        List<InfoItem> itemsToReport;
        
        synchronized (riskItems) {
            if (riskItems.isEmpty()) {
                XLog.d(TAG, "没有风险项需要上报");
                return;
            }
            
            // 创建一个副本，避免并发修改问题
            itemsToReport = new ArrayList<>(riskItems);
        }
        
        // 检查是否有事件ID
        String eventId = networkClient.getEventId();
        if (eventId == null || eventId.isEmpty()) {
            XLog.d(TAG, "没有事件ID，不进行上报");
            return;
        }
        
        XLog.d(TAG, "开始上报风险信息，共 " + itemsToReport.size() + " 项");
        // 上报风险信息（只上报一次）
        networkClient.reportRiskInfo(itemsToReport);
    }

    // NetworkClient.RiskReportCallback 接口实现
    @Override
    public void onRiskReportSuccess(String eventId) {
        XLog.d(TAG, "风险信息上报成功: " + eventId);
    }

    @Override
    public void onRiskReportError(String error) {
        XLog.e(TAG, "风险信息上报失败: " + error);
        isRiskReportScheduled = false;
    }

    private void updateLoadingText() {
        if (!isAdded() || loadingText == null) return;

        dotCount = (dotCount + 1) % 4;
        SpannableStringBuilder builder = new SpannableStringBuilder();
        builder.append("check env ing");

        for (int i = 0; i < dotCount; i++) {
            SpannableString dot = new SpannableString(" .");
            dot.setSpan(new ForegroundColorSpan(Color.parseColor("#2196F3")),
                    0, dot.length(),
                    Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
            builder.append(dot);
        }

        loadingText.setText(builder);
    }
    private void showLoading(boolean show) {
        if (loadingText != null) {
            loadingText.setVisibility(show ? View.VISIBLE : View.GONE);
            recyclerView.setVisibility(show ? View.GONE : View.VISIBLE);

            if (show) {
                dotCount = 0;
                loadingHandler.sendEmptyMessage(UPDATE_LOADING_TEXT);
            } else {
                loadingHandler.removeMessages(UPDATE_LOADING_TEXT);
            }
        }
    }

}
```

`app/src/main/java/com/xiaoc/warlock/ui/fragment/FingerprintFragment.java`:

```java
package com.xiaoc.warlock.ui.fragment;

import android.content.Context;
import android.graphics.Color;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.text.Spannable;
import android.text.SpannableString;
import android.text.SpannableStringBuilder;
import android.text.style.ForegroundColorSpan;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.fragment.app.Fragment;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import com.xiaoc.warlock.Core.FingerprintCollector;
import com.xiaoc.warlock.MainActivity;
import com.xiaoc.warlock.R;
import com.xiaoc.warlock.Util.NativeEngine;
import com.xiaoc.warlock.Util.XLog;
import com.xiaoc.warlock.Util.Xson;
import com.xiaoc.warlock.crypto.EncryptUtil;
import com.xiaoc.warlock.network.NetworkClient;
import com.xiaoc.warlock.ui.adapter.InfoAdapter;
import com.xiaoc.warlock.ui.adapter.InfoItem;

import java.util.ArrayList;
import java.util.List;

public class FingerprintFragment extends Fragment implements FingerprintCollector.FingerprintCallback, 
        NetworkClient.EventIdCallback, NetworkClient.ReportCallback {
    
    private static final String TAG = "FingerprintFragment";
    private RecyclerView recyclerView;
    private TextView loadingText;
    private InfoAdapter adapter;
    private List<InfoItem> infoItems = new ArrayList<>();
    private NetworkClient networkClient;
    private FingerprintCollector fingerprintCollector;
    private String eventId; // 保存接收到的事件ID
    private boolean isCollectionStarted = false; // 标记是否已经开始收集
    private Handler loadingHandler;
    private int dotCount = 0;
    private static final int UPDATE_LOADING_TEXT = 1;
    
    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        // 初始化Handler用于更新加载动画
        loadingHandler = new Handler(Looper.getMainLooper()) {
            @Override
            public void handleMessage(@NonNull Message msg) {
                if (msg.what == UPDATE_LOADING_TEXT && loadingText != null) {
                    updateLoadingText();
                    sendEmptyMessageDelayed(UPDATE_LOADING_TEXT, 500); // 每500ms更新一次
                }
            }
        };
    }
    
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        return inflater.inflate(R.layout.fragment_fingerprint, container, false);
    }
    
    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        
        // 初始化视图
        recyclerView = view.findViewById(R.id.recyclerView);
        loadingText = view.findViewById(R.id.loadingText);
        
        // 设置RecyclerView
        recyclerView.setLayoutManager(new LinearLayoutManager(getContext()));
        adapter = new InfoAdapter(infoItems);
        recyclerView.setAdapter(adapter);
        
        // 初始化网络客户端
        networkClient = NetworkClient.getInstance(requireContext());
        networkClient.registerEventIdCallback(this);
        networkClient.registerReportCallback(this);
        
        // 初始化指纹采集器
        fingerprintCollector = FingerprintCollector.getInstance(requireContext());
        fingerprintCollector.registerCallback(this);
        
        // 先获取事件ID，再等待指纹收集完成
        showLoading(true);
        requestEventId();
        startCheckingCollection();
    }
    
    private void updateLoadingText() {
        if (!isAdded() || loadingText == null) return;
        
        dotCount = (dotCount + 1) % 4;
        SpannableStringBuilder builder = new SpannableStringBuilder();
        builder.append("check fingerprint ing");
        
        for (int i = 0; i < dotCount; i++) {
            SpannableString dot = new SpannableString(" .");
            dot.setSpan(new ForegroundColorSpan(Color.parseColor("#2196F3")),
                    0, dot.length(),
                    Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
            builder.append(dot);
        }
        
        loadingText.setText(builder);
    }
    
    private void showLoading(boolean show) {
        if (loadingText != null) {
            loadingText.setVisibility(show ? View.VISIBLE : View.GONE);
            recyclerView.setVisibility(show ? View.GONE : View.VISIBLE);
            
            if (show) {
                dotCount = 0;
                loadingHandler.sendEmptyMessage(UPDATE_LOADING_TEXT);
            } else {
                loadingHandler.removeMessages(UPDATE_LOADING_TEXT);
            }
        }
    }
    
    private void requestEventId() {
        // 请求事件ID
        networkClient.requestEventId();
    }
    
    private void startCheckingCollection() {
        // 开始轮询检查指纹收集状态
        new Thread(() -> {
            while (!MainActivity.isCollectionComplete()) {
                try {
                    XLog.d(TAG, "等待指纹收集完成...");
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
            
            // 指纹收集完成后，在主线程展示结果
            requireActivity().runOnUiThread(() -> {
                XLog.d(TAG, "指纹收集完成，开始展示");
                displayFingerprintInfo();
                
                // 如果有事件ID，则上报数据
                if (eventId != null && !eventId.isEmpty()) {
                    reportFingerprints(eventId);
                }
                
                showLoading(false);
            });
        }).start();
    }
    
    private void displayFingerprintInfo() {
        if (isCollectionStarted) {
            return; // 避免重复调用
        }
        
        isCollectionStarted = true;
        // 调用收集指纹的方法
        fingerprintCollector.collectFingerprint();
    }
    
    /**
     * 统一显示事件ID或错误信息
     */
    private void displayEventIdInfo(String id, boolean isSuccess, String errorMsg) {
        // 只在主线程中调用
        if (Looper.myLooper() != Looper.getMainLooper()) {
            requireActivity().runOnUiThread(() -> 
                displayEventIdInfo(id, isSuccess, errorMsg));
            return;
        }
        
        // 只有成功时才显示详细信息，失败时使用简化的错误信息
        fingerprintCollector.setAndDisplayEventId(id, isSuccess, null);
    }
    
    @Override
    public void onEventIdReceived(String eventId) {
        XLog.d(TAG, "收到事件ID: " + eventId);
        this.eventId = eventId;
        
        // 存储事件ID，等待指纹收集完成后上报
        if (MainActivity.isCollectionComplete() && !isCollectionStarted) {
            displayFingerprintInfo();
            reportFingerprints(eventId);
            showLoading(false);
        }
    }
    
    @Override
    public void onEventIdError(String error) {
        XLog.e(TAG, "获取事件ID错误: " + error);
        this.eventId = null;
        
        // 等待指纹收集完成后显示错误
        if (MainActivity.isCollectionComplete() && !isCollectionStarted) {
            displayFingerprintInfo();
            displayEventIdInfo("", false, null);
            showLoading(false);
        } else {
            // 将错误信息保存，待展示指纹时一起显示
            new Thread(() -> {
                // 等待指纹收集完成
                while (!MainActivity.isCollectionComplete()) {
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
                
                requireActivity().runOnUiThread(() -> {
                    displayFingerprintInfo();
                    displayEventIdInfo("", false, null);
                    showLoading(false);
                });
            }).start();
        }
    }
    
    private void reportFingerprints(String eventId) {
        if (eventId == null || eventId.isEmpty()) {
            XLog.e(TAG, "事件ID为空，无法上报指纹");
            return;
        }
        
        XLog.d(TAG, "开始上报指纹数据，事件ID: " + eventId);
        String javaFingerprint = Xson.getMapString(true);
        EncryptUtil encryptUtil = new EncryptUtil(javaFingerprint);
        String nativeFingerprint = NativeEngine.getCollectedInfo();
        
        // 上报指纹数据
        networkClient.reportDeviceFingerprint(encryptUtil.result, nativeFingerprint);
    }
    
    @Override
    public void onReportSuccess(String eventId) {
        XLog.d(TAG, "设备指纹上报成功，事件ID: " + eventId);
        displayEventIdInfo(eventId, true, null);
    }
    
    @Override
    public void onReportError(String error) {
        XLog.e(TAG, "设备指纹上报失败: " + error);
        displayEventIdInfo("", false, null);
    }
    
    @Override
    public void onFingerprintCollected(InfoItem item) {
        requireActivity().runOnUiThread(() -> {
            infoItems.add(item);
            adapter.notifyDataSetChanged();
        });
    }
    
    @Override
    public void onDestroyView() {
        super.onDestroyView();
        // 取消注册回调
        fingerprintCollector.unregisterCallback(this);
        networkClient.unregisterEventIdCallback(this);
        networkClient.unregisterReportCallback(this);
        
        // 清理Handler
        if (loadingHandler != null) {
            loadingHandler.removeCallbacksAndMessages(null);
        }
    }
}
```

`app/src/main/res/drawable/button_bg.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <solid android:color="@color/primary_color" />
    <corners android:radius="4dp" />
</shape> 
```

`app/src/main/res/drawable/ic_check_circle.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="#000000"
        android:pathData="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM10,17l-5,-5 1.41,-1.41L10,14.17l7.59,-7.59L19,8l-9,9z"/>
</vector>
```

`app/src/main/res/drawable/ic_expand_more.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="1024"
    android:viewportHeight="1024">
    <path
        android:fillColor="#FF000000"
        android:pathData="M512,693.33c-14.93,0 -29.87,-4.27 -40.53,-14.93l-277.33,-234.67c-27.73,-23.47 -29.87,-64 -8.53,-89.6 23.47,-27.73 64,-29.87 89.6,-8.53L512,546.13l236.8,-200.53c27.73,-23.47 68.27,-19.2 89.6,8.53 23.47,27.73 19.2,68.27 -8.53,89.6l-277.33,234.67c-10.67,10.67 -25.6,14.93 -40.53,14.93z"/>
</vector>
```

`app/src/main/res/drawable/ic_launcher_background.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector
    android:height="108dp"
    android:width="108dp"
    android:viewportHeight="108"
    android:viewportWidth="108"
    xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="#3DDC84"
          android:pathData="M0,0h108v108h-108z"/>
    <path android:fillColor="#00000000" android:pathData="M9,0L9,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,0L19,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M29,0L29,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M39,0L39,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M49,0L49,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M59,0L59,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M69,0L69,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M79,0L79,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M89,0L89,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M99,0L99,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,9L108,9"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,19L108,19"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,29L108,29"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,39L108,39"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,49L108,49"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,59L108,59"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,69L108,69"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,79L108,79"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,89L108,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,99L108,99"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,29L89,29"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,39L89,39"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,49L89,49"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,59L89,59"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,69L89,69"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,79L89,79"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M29,19L29,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M39,19L39,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M49,19L49,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M59,19L59,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M69,19L69,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M79,19L79,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
</vector>

```

`app/src/main/res/drawable/ic_launcher_foreground.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z">
        <aapt:attr name="android:fillColor">
            <gradient
                android:endX="85.84757"
                android:endY="92.4963"
                android:startX="42.9492"
                android:startY="49.59793"
                android:type="linear">
                <item
                    android:color="#44000000"
                    android:offset="0.0" />
                <item
                    android:color="#00000000"
                    android:offset="1.0" />
            </gradient>
        </aapt:attr>
    </path>
    <path
        android:fillColor="#FFFFFF"
        android:fillType="nonZero"
        android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z"
        android:strokeWidth="1"
        android:strokeColor="#00000000" />
</vector>
```

`app/src/main/res/drawable/ic_more_vert.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M12,8c1.1,0 2,-0.9 2,-2s-0.9,-2 -2,-2 -2,0.9 -2,2 0.9,2 2,2zM12,10c-1.1,0 -2,0.9 -2,2s0.9,2 2,2 2,-0.9 2,-2 -0.9,-2 -2,-2zM12,16c-1.1,0 -2,0.9 -2,2s0.9,2 2,2 2,-0.9 2,-2 -0.9,-2 -2,-2z"/>
</vector> 
```

`app/src/main/res/drawable/ic_security.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="#000000"
        android:pathData="M12,1L3,5v6c0,5.55 3.84,10.74 9,12 5.16,-1.26 9,-6.45 9,-12L21,5l-9,-4zM10,17l-4,-4 1.41,-1.41L10,14.17l6.59,-6.59L18,9l-8,8z"/>
</vector>
```

`app/src/main/res/drawable/rounded_card_bg.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <solid android:color="#FFFFFF" />
    <corners android:radius="8dp" />
    <stroke
        android:width="1dp"
        android:color="#E0E0E0" />
</shape> 
```

`app/src/main/res/layout/activity_main.xml`:

```xml
<androidx.coordinatorlayout.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/main"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@color/white"
    android:fitsSystemWindows="false">

    <com.google.android.material.appbar.AppBarLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="@color/primary_color"
        android:fitsSystemWindows="false">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:layout_marginTop="20dp">

            <!-- 修改这里：使用 RelativeLayout 来实现标题和菜单按钮的布局 -->
            <RelativeLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:paddingHorizontal="16dp"
                android:paddingTop="6dp"
                android:paddingBottom="4dp">

                <!-- 标题部分 -->
                <LinearLayout
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:layout_alignParentStart="true"
                    android:layout_centerVertical="true">

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="WarLock"
                        android:textColor="@color/white"
                        android:textSize="20sp"
                        android:textStyle="bold"/>

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Version 1.0.0"
                        android:textColor="#E0FFFFFF"
                        android:textSize="11sp"
                        android:layout_marginTop="1dp"/>
                </LinearLayout>

                <!-- 菜单按钮 -->
                <ImageButton
                    android:id="@+id/menuButton"
                    android:layout_width="48dp"
                    android:layout_height="48dp"
                    android:layout_alignParentEnd="true"
                    android:layout_centerVertical="true"
                    android:background="?attr/selectableItemBackgroundBorderless"
                    android:src="@drawable/ic_more_vert"
                    android:contentDescription="更多选项"
                    android:tint="@color/white"/>

            </RelativeLayout>

            <com.google.android.material.tabs.TabLayout
                android:id="@+id/tabLayout"
                android:layout_width="match_parent"
                android:layout_height="36dp"
                android:background="@color/primary_color"
                app:tabTextColor="@color/white"
                app:tabSelectedTextColor="@color/white"
                app:tabIndicatorColor="@color/white"
                app:tabIndicatorHeight="2dp"
                app:tabGravity="fill"
                app:tabMode="fixed"
                app:tabPadding="6dp"/>

        </LinearLayout>

    </com.google.android.material.appbar.AppBarLayout>

    <androidx.viewpager2.widget.ViewPager2
        android:id="@+id/viewPager"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:layout_behavior="@string/appbar_scrolling_view_behavior"/>

</androidx.coordinatorlayout.widget.CoordinatorLayout>
```

`app/src/main/res/layout/dialog_settings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="16dp">

    <!-- 隐私设置 -->
    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="隐私设置"
        android:textStyle="bold"
        android:textSize="16sp"
        android:layout_marginBottom="8dp"/>

    <com.google.android.material.switchmaterial.SwitchMaterial
        android:id="@+id/switch_no_report"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="设备信息不上报服务器"
        android:checked="false"
        android:layout_marginBottom="16dp"/>

    <!-- 应用操作 -->
    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="应用操作"
        android:textStyle="bold"
        android:textSize="16sp"
        android:layout_marginBottom="8dp"/>

    <com.google.android.material.button.MaterialButton
        android:id="@+id/btn_restart_app"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="重启应用"
        android:layout_marginBottom="8dp"
        style="@style/Widget.MaterialComponents.Button.TextButton"/>

    <com.google.android.material.button.MaterialButton
        android:id="@+id/btn_clear_data"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="清除数据"
        android:textColor="?attr/colorError"
        style="@style/Widget.MaterialComponents.Button.TextButton"/>

</LinearLayout> 
```

`app/src/main/res/layout/fragment_environment.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recyclerView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:clipToPadding="false"
        android:padding="8dp" />

    <TextView
        android:id="@+id/loadingText"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:textSize="18sp"
        android:textColor="@android:color/darker_gray"
        android:visibility="gone" />

</FrameLayout>
```

`app/src/main/res/layout/fragment_fingerprint.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recyclerView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:clipToPadding="false"
        android:padding="8dp"
        android:visibility="gone" />

    <TextView
        android:id="@+id/loadingText"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:textSize="18sp"
        android:textColor="@android:color/darker_gray"
        android:visibility="visible" />

</FrameLayout>
```

`app/src/main/res/layout/item_detail.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="4dp">

    <TextView
        android:id="@+id/keyText"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textSize="14sp"
        android:textColor="@color/text_secondary"/>

    <TextView
        android:id="@+id/valueText"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginStart="8dp"
        android:textSize="14sp"
        android:textColor="@color/text_primary"/>

</LinearLayout>
```

`app/src/main/res/layout/item_empty_state.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.cardview.widget.CardView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_margin="8dp"
    app:cardCornerRadius="8dp"
    app:cardElevation="4dp"
    app:cardBackgroundColor="#F8F9FA">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="24dp"
        android:gravity="center">

        <ImageView
            android:id="@+id/emptyStateIcon"
            android:layout_width="64dp"
            android:layout_height="64dp"
            android:layout_marginBottom="16dp"
            android:src="@drawable/ic_check_circle"
            android:tint="#4CAF50"/>

        <TextView
            android:id="@+id/emptyStateTitle"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="18sp"
            android:textStyle="bold"
            android:textColor="#212529"
            android:layout_marginBottom="8dp"/>

        <TextView
            android:id="@+id/emptyStateDescription"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="14sp"
            android:textColor="#6C757D"
            android:gravity="center"/>

    </LinearLayout>
</androidx.cardview.widget.CardView>
```

`app/src/main/res/layout/item_info_card.xml`:

```xml
<com.google.android.material.card.MaterialCardView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_marginHorizontal="16dp"
    android:layout_marginVertical="8dp"
    app:cardElevation="2dp"
    app:cardCornerRadius="12dp">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical">

        <!-- 标题栏 -->
        <LinearLayout
            android:id="@+id/headerLayout"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:padding="16dp"
            android:gravity="center_vertical">

            <TextView
                android:id="@+id/titleText"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:textSize="16sp"
                android:textStyle="bold"
                android:textColor="@color/text_primary"/>

            <ImageView
                android:id="@+id/expandIcon"
                android:layout_width="24dp"
                android:layout_height="24dp"
                android:src="@drawable/ic_expand_more"/>
        </LinearLayout>

        <!-- 详情内容 -->
        <LinearLayout
            android:id="@+id/detailsLayout"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:paddingHorizontal="12dp"
            android:paddingBottom="12dp"
            android:paddingTop="0dp"
            android:visibility="gone">

            <LinearLayout
                android:id="@+id/detailsList"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"/>

        </LinearLayout>

    </LinearLayout>

</com.google.android.material.card.MaterialCardView>
```

`app/src/main/res/layout/layout_menu_sheet.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="16dp">

    <com.google.android.material.button.MaterialButton
        android:id="@+id/btn_about"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="关于"
        android:textSize="16sp"
        android:gravity="center"
        android:paddingVertical="12dp"
        android:drawablePadding="32dp"
        style="@style/Widget.MaterialComponents.Button.TextButton" />
<!--    <View-->
<!--        android:layout_width="match_parent"-->
<!--        android:layout_height="0.5dp"-->
<!--        android:background="#1F000000" />-->
<!--    <com.google.android.material.button.MaterialButton-->
<!--        android:id="@+id/btn_explain"-->
<!--        android:layout_width="match_parent"-->
<!--        android:layout_height="wrap_content"-->
<!--        android:text="说明"-->
<!--        android:textSize="16sp"-->
<!--        android:gravity="center"-->
<!--        android:paddingVertical="12dp"-->
<!--        android:drawablePadding="32dp"-->
<!--        style="@style/Widget.MaterialComponents.Button.TextButton" />-->
    <View
        android:layout_width="match_parent"
        android:layout_height="0.5dp"
        android:background="#1F000000" />
    <com.google.android.material.button.MaterialButton
        android:id="@+id/btn_feedback"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="反馈"
        android:textSize="16sp"
        android:gravity="center"
        android:paddingVertical="12dp"
        android:drawablePadding="32dp"
        style="@style/Widget.MaterialComponents.Button.TextButton" />
    <View
        android:layout_width="match_parent"
        android:layout_height="0.5dp"
        android:background="#1F000000" />
    <com.google.android.material.button.MaterialButton
        android:id="@+id/btn_settings"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="设置"
        android:textSize="16sp"
        android:gravity="center"
        android:paddingVertical="12dp"
        android:drawablePadding="32dp"
        style="@style/Widget.MaterialComponents.Button.TextButton" />
</LinearLayout> 
```

`app/src/main/res/menu/menu_main.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">
    <item
        android:id="@+id/action_more"
        android:icon="@drawable/ic_more_vert"
        android:title="更多"
        app:showAsAction="always" />
</menu> 
```

`app/src/main/res/menu/menu_popup.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">
    <item
        android:id="@+id/action_about"
        android:title="关于" />
    <item
        android:id="@+id/action_explain"
        android:title="说明" />
    <item
        android:id="@+id/action_feedback"
        android:title="反馈" />
    <item
        android:id="@+id/action_settings"
        android:title="设置" />
</menu> 
```

`app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>
```

`app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>
```

`app/src/main/res/values-night/themes.xml`:

```xml
<resources xmlns:tools="http://schemas.android.com/tools">
    <!-- Base application theme. -->
    <style name="Base.Theme.Warlock" parent="Theme.Material3.DayNight.NoActionBar">
        <!-- Customize your dark theme here. -->
        <!-- <item name="colorPrimary">@color/my_dark_primary</item> -->
    </style>
</resources>
```

`app/src/main/res/values/colors.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="black">#FF000000</color>
    <color name="primary_color">#1A73E8</color>
    <color name="primary_dark_color">#0D47A1</color>
    <color name="accent_color">#00BCD4</color>
        <color name="white">#FFFFFF</color>
        <color name="background_color">#F8F9FA</color>
        <color name="card_background">#FFFFFF</color>
        <color name="text_primary">#202124</color>
        <color name="text_secondary">#5F6368</color>
        <color name="divider_color">#E1E3E6</color>
    <color name="ripple_color">#1F000000</color>
    <color name="error_color">#F44336</color>

</resources>
```

`app/src/main/res/values/strings.xml`:

```xml
<resources>
    <string name="app_name">WarLock</string>
</resources>
```

`app/src/main/res/values/styles.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="ToolbarTitleStyle" parent="TextAppearance.MaterialComponents.Headline6">
        <item name="android:textSize">20sp</item>
        <item name="android:textStyle">bold</item>
    </style>

    <style name="TabTextAppearance" parent="TextAppearance.Design.Tab">
        <item name="android:textSize">16sp</item>
        <item name="android:textStyle">bold</item>
    </style>
    <!-- 基础主题 -->
    <style name="AppTheme" parent="Theme.MaterialComponents.Light.NoActionBar">
        <!-- 主要颜色 -->
        <item name="colorPrimary">@color/primary_color</item>
        <item name="colorPrimaryDark">@color/primary_dark_color</item>
        <item name="colorAccent">@color/accent_color</item>
        <!-- 状态栏配置 -->
        <item name="android:windowTranslucentStatus">true</item>
        <item name="android:windowTranslucentNavigation">true</item>
        <item name="android:fitsSystemWindows">true</item>
    </style>
    <style name="TabTextStyle" parent="TextAppearance.Design.Tab">
        <item name="android:textSize">14sp</item>
        <item name="textAllCaps">false</item>
        <item name="android:textStyle">bold</item>
    </style>
</resources>
```

`app/src/main/res/values/themes.xml`:

```xml
<resources xmlns:tools="http://schemas.android.com/tools">
    <!-- Base application theme. -->
    <style name="Base.Theme.Warlock" parent="Theme.Material3.DayNight.NoActionBar">
        <!-- Customize your light theme here. -->
        <!-- <item name="colorPrimary">@color/my_light_primary</item> -->
    </style>

    <style name="Theme.Warlock" parent="Base.Theme.Warlock" />
</resources>
```

`app/src/main/res/xml/backup_rules.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?><!--
   Sample backup rules file; uncomment and customize as necessary.
   See https://developer.android.com/guide/topics/data/autobackup
   for details.
   Note: This file is ignored for devices older that API 31
   See https://developer.android.com/about/versions/12/backup-restore
-->
<full-backup-content>
    <!--
   <include domain="sharedpref" path="."/>
   <exclude domain="sharedpref" path="device.xml"/>
-->
</full-backup-content>
```

`app/src/main/res/xml/data_extraction_rules.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?><!--
   Sample data extraction rules file; uncomment and customize as necessary.
   See https://developer.android.com/about/versions/12/backup-restore#xml-changes
   for details.
-->
<data-extraction-rules>
    <cloud-backup>
        <!-- TODO: Use <include> and <exclude> to control what is backed up.
        <include .../>
        <exclude .../>
        -->
    </cloud-backup>
    <!--
    <device-transfer>
        <include .../>
        <exclude .../>
    </device-transfer>
    -->
</data-extraction-rules>
```

`app/src/test/java/com/xiaoc/warlock/ExampleUnitTest.java`:

```java
package com.xiaoc.warlock;

import org.junit.Test;

import static org.junit.Assert.*;

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
public class ExampleUnitTest {
    @Test
    public void addition_isCorrect() {
        assertEquals(4, 2 + 2);
    }
}
```

`build.gradle`:

```gradle
// Top-level build file where you can add configuration options common to all sub-projects/modules.


plugins {
    alias(libs.plugins.android.application) apply false
}

```

`gradle.properties`:

```properties
# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. For more details, visit
# https://developer.android.com/r/tools/gradle-multi-project-decoupled-projects
# org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
# Enables namespacing of each library's R class so that its R class includes only the
# resources declared in the library itself and none from the library's dependencies,
# thereby reducing the size of the R class for that library
android.nonTransitiveRClass=true
```

`gradle/libs.versions.toml`:

```toml
[versions]
agp = "8.6.0"
junit = "4.13.2"
junitVersion = "1.2.1"
espressoCore = "3.6.1"
appcompat = "1.7.0"
material = "1.12.0"
activity = "1.9.3"
constraintlayout = "2.2.0"

[libraries]
junit = { group = "junit", name = "junit", version.ref = "junit" }
ext-junit = { group = "androidx.test.ext", name = "junit", version.ref = "junitVersion" }
espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }
appcompat = { group = "androidx.appcompat", name = "appcompat", version.ref = "appcompat" }
material = { group = "com.google.android.material", name = "material", version.ref = "material" }
activity = { group = "androidx.activity", name = "activity", version.ref = "activity" }
constraintlayout = { group = "androidx.constraintlayout", name = "constraintlayout", version.ref = "constraintlayout" }

[plugins]
android-application = { id = "com.android.application", version.ref = "agp" }


```

`gradle/wrapper/gradle-wrapper.properties`:

```properties
#Tue Dec 10 10:33:13 CST 2024
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.7-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

```

`gradlew`:

```
#!/usr/bin/env sh

#
# Copyright 2015 the original author or authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn () {
    echo "$*"
}

die () {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
  NONSTOP* )
    nonstop=true
    ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin or MSYS, switch paths to Windows format before running java
if [ "$cygwin" = "true" -o "$msys" = "true" ] ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`

    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=`expr $i + 1`
    done
    case $i in
        0) set -- ;;
        1) set -- "$args0" ;;
        2) set -- "$args0" "$args1" ;;
        3) set -- "$args0" "$args1" "$args2" ;;
        4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Escape application args
save () {
    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
    echo " "
}
APP_ARGS=`save "$@"`

# Collect all arguments for the java command, following the shell quoting and substitution rules
eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"

exec "$JAVACMD" "$@"

```

`gradlew.bat`:

```bat
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto execute

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`resource/warlock采集字段定义.txt`:

```txt
属性映射：
a1：getProp
a2:所处的安卓架构 64位or32位
a3:通过Settings.Secure拿到 ad_aaid和Google API获取aaid，两个都获取到了就会输出两个的值，如果只有一个获取到了就只会输出一个
a4:cat /proc/sys/kernel/random/boot_id
a5:Android id  Settings.Secure拿到
 a6:DRM ID 做SHA256加密后的结果
a7:谷歌服务拿到device id，content://com.google.android.gsf.gservices  算是Android id的一种
a8:设备厂商
a9:设备型号
a10:context.getApplicationInfo().dataDir; 应用的私有数据目录
a11:getProp fingerprint
a12:获取当前系统的时区信息。timeZone.getID()
a13:Setting字段
a14：/data/app下的私有目录
a15:蓝牙适配器获取获取蓝牙地址
a16:包名
a17：获取电话管理器里面的数据，有：imei、imsi、iccid、line1_number，如果是双卡设备则会去获取第二张卡的信息
a18:获取这些fingerprint："build", "bootimage", "odm", "product", "system_ext", "system", "vendor"，然后使用index[i]+"="+fingerprint(md5)+"&"的结果来拼接。还会返回一个index，这个index代表是在哪些index获取到了
例子：build=1f2be064c72201d4e5413f53579a9f83&odm=1f2be064c72201d4e5413f53579a9f83&product=1f2be064c72201d4e5413f53579a9f83&system_ext=1f2be064c72201d4e5413f53579a9f83&system=1f2be064c72201d4e5413f53579a9f83&vendor=1f2be064c72201d4e5413f53579a9f83
a19:cat /proc/cpuinfo
a20:Serial
a21：设备存储的总字节数 statFs.getTotalBytes()
a22：设备的内存大小 memoryInfo.totalMem
a23：注册一个广播，获取电池状态,new IntentFilter("android.intent.action.BATTERY_CHANGED"),registerReceiver.getIntExtra("health", -1)，如果拿到的int为2则会健康，3则为过热
a24：通过反射获取Android系统中PowerProfile类的电池容量、从系统文件读取、通过BatteryManager、从Build.PROP读取。
a25:遍历SensorList,拿到传感器信息
a26:cat /proc/self/mountstats
a27:获取了前后两颗摄像头的信息。
a28:获取了输入管理器的输入管理器id list，然后拿到这些id的name和vendor
a29:stat /data/misc/keychain/serial_blacklist.txt 返回的Access:  获取到纳米级时间戳
a30:stat /data/misc/keychain/serial_blacklist.txt 返回的Change:  获取到纳米级时间戳
a31stat /data/misc/keychain/serial_blacklist.txt 返回的Modify:  获取到纳米级时间戳
a32：stat /data/misc/keychain/pubkey_blacklist.txt 返回的Modify 获取到纳米级时间戳
a33：stat /data/misc/keychain/pubkey_blacklist.txt 返回的Access 获取到纳米级时间戳
a34：stat /data/misc/keychain/pubkey_blacklist.txt 返回的Change 获取到纳米级时间戳
a35：stat /data/misc/keychain 返回的Access 获取到纳米级时间戳
a36：stat /data/misc/keychain 返回的Change:  获取到纳米级时间戳
a37：stat /sdcard/Download 这里面会有两个值：access和change
a38：stat /sdcard/Android/ 这里面会有两个值：access和change
a39：stat /data/local/tmp 这里面会有两个值：access和change
a40 stat /data/data/com.xiaoc.warlock 。如果返回true则代表存在这个文件
a41:
 "n": "wlan0",                        // 接口名称
"u": true,                           // 是否启用
"display_name": "Wireless Interface", // 显示名称
"loopback": false,                   // 是否回环接口
"virtual": false,                    // 是否虚拟接口
"point_to_point": false,             // 是否点对点接口
"multicast": true,                   // 是否支持多播
"mtu": 1500,                         // 最大传输单元
"mac": "00:11:22:33:44:55",         // MAC地址
"addresses": [                       // IP地址列表
    "192.168.1.100",                // IPv4地址
    "fe80::1234:5678:9abc:def0"     // IPv6地址
]
a42:获取OpenGL ES版本
a43:获取当前Java虚拟机可用的处理器数量、处理器频率、处理器温度
a44:如果能够正常使用反射则v值为true，否则为false
a45:获取当前网络的国家/地区ISO代码
a46:通过WifiManager获取网卡地址
a47:通过两种方式获取签名分别是SignatureX509和Binder的方式
a48:	
a49: 表示数据未开启（对应 DATA_DISCONNECTED）,3: 表示数据已开启（对应其他所有状态）
a50:stat /storage/emulated/0。基本思路是调用stat函数，去获取/storage/emulated/0目录下的块大小和总数据块数量，还有空闲块的数量。
代码逻辑很明显，通过syscall去调用statfs函数，然后获取stat结构体中的数据，最后算一下
t: 总空间（字节）
f: 空闲空间（字节）
a: 可用空间（字节）
bs: 块大小
s: 原始输出字符串
a52：
设备标识：
uuid
ad_aaid
ReaperAssignedDeviceId
IMEI
mdm_uuid
ps_imei
op_security_uuid
ai_stored_imei
device_serial
a53：通过stat获取文件的最近访问时间、最近修改时间、最近改变时间，Innode编号:
/sdcard/Android/data/.nomedia
/sdcard/Android/data/com.google.android.gms
/sdcard/
/storage/emulated/0
a54:屏幕亮度、屏幕尺寸和屏幕超时时间
a55:内部存储（EMMC或UFS闪存）的序列号：/sys/block/mmcblk0/device/serial  （核心）
a56:显示设备序列号：/sys/devices/soc0/serial_number  (核心)
a57:内部存储SD卡的CID：/sys/block/mmcblk0/device/cid（核心）
a58:input设备相关，读取/proc/bus/input/devices，获取注册的input设备信息，比如Name和Sysfs。
a59:输入法列表:
a60:AccountManager->getAccounts
a61:AudioManager->getStreamVolume
a62:MediaDrm->getPropertyString
a63: cat /sys/class/net/wlan0/address
cat /sys/devices/virtual/net/wlan0/address
a64:收集硬盘信息
a65:附近网卡信息
a66:获取IPV6
a67:uname -a
a68:获取App的UID
a69：通过ls -l 获取自己文件路径的Uid
a70：获取一下包名所在的/data/app下的路径。apk源文件路径
com.sankuai.meituan			 美团
com.tencent.mm				 微信
bin.mt.plus					 mt管理器
com.smile.gifmaker			 快手
com.ss.android.ugc.aweme	 抖音
com.eg.android.AlipayGphone  支付宝
a75：系统服务列表
a80：遍历/system/fonts目录下的tf字体文件并拼接起来最后进行md5加密

===========================================================
n1:DRM ID
n2:ro.build.version.release
	ro.product.model
	ro.product.brand
	ro.boot.bootloader
	ro.build.version.securitypatch
	ro.build.version.incremental
	gsm.version.baseband
	gsm.version.ril-impl
	ro.build.fingerprint
	ro.build.description
	ro.build.product
	ro.boot.vbmeta.digest
	ro.hardware
	ro.product.name
	ro.product.board
	ro.recovery_id
	ro.expect.recovery_id
	ro.board.platform
	ro.product.manufacturer
	ro.product.device
	sys.usb.state 检测USB调试开启状态
	ro.setupwizard.mode 也是一个核心，但是未知是什么
	ro.build.id
	ro.build.tags
	ro.build.type
	ro.debuggable
	persist.sys.meid
	=====================然后还有一些不常见的，可能是其他厂商的设备中才会有的字段：
	vendor.serialno
	sys.serialno
	persist.sys.wififactorymac
	ro.boot.deviceid
	ro.rpmb.board
	ro.vold.serialno
	persist.oppo.wlan.macaddress
	persist.sys.oppo.serialno
	ril.serialnumber
	ro.boot.ap_serial
	ro.boot.uniqueno
	persist.sys.oppo.opmuuid
	persist.sys.oppo.nlp.id
	persist.sys.oplus.nlp.id
	persist.sys.dcs.hash
	ro.ril.oem.sno
	ro.ril.oem.psno
	persist.vendor.sys.fp.uid
	ro.ril.miui.imei0
	ro.ril.miui.imei1
	ro.ril.oem.imei
	ro.ril.oem.meid
	persist.radio.imei
	persist.radio.imei1
	persist.radio.imei2
	persist.sys.lite.uid
	persist.radio.serialno
	vendor.boot.serialno
	persist.sys.oneplus.serialno
	ro.meizu.hardware.imei1
	ro.meizu.hardware.imei2
	ro.meizu.hardware.meid
	ro.meizu.hardware.psn
	ro.meizu.hardware.sn
	persist.radio.factory_phone_sn
	persist.radio.factory_sn
	ro.meizu.serialno
	ro.boot.psn
	ro.boot.meid
	ro.boot.imei1
	ro.boot.imei2
	ro.wifimac
	ro.wifimac_2
	ro.vendor.deviceid
	ro.isn
	ro.vendor.isn
	persist.radio.device.imei
	persist.radio.device.imei2
	persist.radio.device.meid
	persist.radio.device.meid2
	persist.asus.serialno
	sys.wifimac
	sys.bt.address
	persist.btpw.bredr
	persist.radio.imei
	persist.radio.imei2
	persist.radio.meid
	persist.radio.meid2
	ro.boot.fpd.uid
	ro.vendor.boot.serialno
	ro.boot.wifimacaddr
	persist.sys.wifi.mac
	persist.sys.wifi_mac
	sys.prop.writeimei
	ril.gm.imei
	ril.cdma.meid
	ro.boot.em.did
	ro.qchip.serialno
	ro.ril.oem.btmac
	ro.ril.oem.ifimac
n3:获取网卡信息，分Android版本去获取，在Android10以下使用Netlinker方式通过SVC去获取，第二是在Android10以及以上通过netlink和Ioctl的方式去获取。
Ioctl的方式只会获取这三张卡的地址："wlan0", "eth0", "rmnet0"
n4:"/system/build.prop" svc openat去获取 不一定能获取到
n5:"/odm/etc/build.prop" svc openat去获取 不一定能获取到
n6:"/product/build.prop" svc openat去获取 不一定能获取到
n7:"/vendor/build.prop" svc openat去获取  不一定能获取到
n8:/proc/sys/kernel/random/uuid svc openat去获取
n9:/sys/block/mmcblk0/device/cid svc openat去获取 
n10:/sys/devices/soc0/serial_number svc openat去获取
n11:/proc/misc svc openat去获取
n12:/proc/sys/kernel/random/boot_id svc openat去获取
n13:获取以下三个值/ popen uname -a / svc uname函数 / 和svc openat去读/proc/version，
n14：popen("getprop", "r")
n15:popen("ip a", "r")。包含这些网卡的信息 {"lo", "dummy0", "wlan0", "wlan1", "eth0", "rmnet0"}。有IP、状态和mac地址。
n16:popen("service list","r")
n17:statfs /storage/emulated/0
n18：Native 获取DRM ID。通过dlsym去导入链接上libmediandk.so，然后调用getPropertyByteArray函数去获取
n19:{
    "Processor": "AArch64 Processor rev 0 (aarch64)",  // CPU型号
    "BogoMIPS": "38.40",                              // CPU性能指标
    "Features": "fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp cpuid asimdrdm lrcpc dcpop asimddp",  // CPU支持的特性
    "CPU implementer": "0x51",                        // CPU制造商代码
    "CPU architecture": "8",                          // CPU架构版本
    "CPU variant": "0xd",                            // CPU变体版本
    "CPU part": "0x805",                             // CPU部件号
    "CPU revision": "14",                            // CPU修订版本
    "Hardware": "Qualcomm Technologies, Inc SM7225",  // 硬件平台
    "processors": ["0", "1", "2", "3", "4", "5", "6", "7"]  // CPU核心列表
}
n20:{
    "cpu_arch": "arm64",           // CPU架构类型
    "Hardware": "Qualcomm SM8550", // 处理器型号
    "board": "taro",               // 主板代号
    "platform": "taro",            // 平台代号
    "hardware": "qcom"             // 硬件厂商
}
n21:
{
    "MemTotal": "5506944 kB",     // 总内存大小
    "MemFree": "286980 kB",       // 空闲内存
    "MemAvailable": "2418212 kB", // 可用内存
    "Buffers": "6456 kB",         // 缓冲区大小
    "Cached": "2257060 kB",       // 缓存大小
    "SwapCached": "176452 kB",    // 交换区缓存
    "Active": "1672620 kB",       // 活跃内存
    "Inactive": "1804084 kB",     // 不活跃内存
    "SwapTotal": "4194300 kB",    // 交换区总大小
    "SwapFree": "3020796 kB",     // 交换区空闲大小
    "Dirty": "304 kB",            // 等待写入磁盘的内存
    "Writeback": "0 kB",          // 正在写入磁盘的内存
    "AnonPages": "1211720 kB",    // 匿名页面大小
    "Mapped": "684688 kB",        // 文件映射大小
    "Shmem": "37016 kB",          // 共享内存大小
    "KReclaimable": "192164 kB"   // 可回收的内核内存
}
```

`settings.gradle`:

```gradle
pluginManagement {
    repositories {
        google {
            content {
                includeGroupByRegex("com\\.android.*")
                includeGroupByRegex("com\\.google.*")
                includeGroupByRegex("androidx.*")
            }
        }
        mavenCentral()
        gradlePluginPortal()
        maven { url 'https://jitpack.io' }

    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        maven { url 'https://jitpack.io' }

        mavenCentral()
    }
}

rootProject.name = "warlock"
include ':app'

```