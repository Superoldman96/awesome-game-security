Project Path: arc_gmh5225_fn-dma-cheat_5f9zy8e1

Source Tree:

```txt
arc_gmh5225_fn-dma-cheat_5f9zy8e1
├── FortniteDma
│   ├── FortniteDma.cpp
│   ├── FortniteDma.vcxproj
│   ├── FortniteDma.vcxproj.filters
│   ├── Settings.hpp
│   ├── UnrealContainers.hpp
│   ├── Utils.hpp
│   └── Weapons.hpp
├── FortniteDma.sln
└── README.md

```

`FortniteDma.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.9.34701.34
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "FortniteDma", "FortniteDma\FortniteDma.vcxproj", "{43160328-25D3-43BC-8A4F-E26EC5759C7A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{43160328-25D3-43BC-8A4F-E26EC5759C7A}.Debug|x64.ActiveCfg = Debug|x64
		{43160328-25D3-43BC-8A4F-E26EC5759C7A}.Debug|x64.Build.0 = Debug|x64
		{43160328-25D3-43BC-8A4F-E26EC5759C7A}.Debug|x86.ActiveCfg = Debug|Win32
		{43160328-25D3-43BC-8A4F-E26EC5759C7A}.Debug|x86.Build.0 = Debug|Win32
		{43160328-25D3-43BC-8A4F-E26EC5759C7A}.Release|x64.ActiveCfg = Release|x64
		{43160328-25D3-43BC-8A4F-E26EC5759C7A}.Release|x64.Build.0 = Release|x64
		{43160328-25D3-43BC-8A4F-E26EC5759C7A}.Release|x86.ActiveCfg = Release|Win32
		{43160328-25D3-43BC-8A4F-E26EC5759C7A}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {6A06B90D-9E0D-447D-A327-CFE44B3ACEB5}
	EndGlobalSection
EndGlobal

```

`FortniteDma/FortniteDma.cpp`:

```cpp
#include <iostream>
#include "Memory/Memory.h"
#include "UnrealContainers.hpp"
#include "Settings.hpp"
#include "Utils.hpp"
#include <thread>

#include "Weapons.hpp"

bool aimbot_in_action;
void aimbot() {
	double damp_coeff = 1; //increase this value to increase starting aggressiveness

	std::vector<MeshInfoContainer> nearest_mesh_info;
	nearest_mesh_info.reserve(10);

	double previous_pitch_error = 0;
	double previous_yaw_error = 0;
	double pitch_integral = 0;
	double yaw_integral = 0;
	//double kp = 0.5; //increase this value to increase aggressiveness
	double last_elapsed = 0;

	auto scatter_handle = mem.CreateScatterHandle();
	auto scatter_handle_write = mem.CreateScatterHandle();
	while (true) {
		double ki = 0.5; //increase this value to increase aggressiveness
		double kd = 15.2; //increase this value to increase aggressiveness
		if (aimbot_in_action && settings::aimbot::enable) {
			if (cache::local_camera.fov < 70) {
				kd = 9.3;
			}
			try {
				// aimbot code
				// Measure performance
				GEN_CHRONO_VAR_WITH_NUM_SUFFIX(start, 0);
				cache::closest_mesh_info = MeshInfoContainer{};

				nearest_mesh_info.clear();
				// Get the nearest 3 mesh info
				{
					// Lock mutex
					std::lock_guard lock(cache::mem_mutex);
					// Get the nearest 3 mesh info if 3 are available, otherwise only one
					int n_elements = min(3, cache::mesh_info_cache.size());
					std::copy_n(cache::mesh_info_cache.begin(), n_elements, std::back_inserter(nearest_mesh_info));
				}

				if (nearest_mesh_info.empty()) {
					EXEC_ON_ARG(std::cout << "No mesh info available" << '\n', false);
					continue;
				}

				//if (mem.GetKeyboard()->IsKeyDown(VK_LBUTTON)) {
				//	if (damp_coeff > 0.5) { //reduce this to increase damping power
				//		damp_coeff -= 0.001;
				//		// reduce this value to reduce damping effect
				//	}
				//}
				//else {
				//	damp_coeff = 1;
				//}


				// Check the distances of cached nearest mesh info
				cache::closest_distance = FLT_MAX;
				for (auto& i : nearest_mesh_info)
				{
					// Get real head bone
					if (!is_valid(i.head_bone) || !is_valid(i.component_to_world)) {
						continue;
					}
					FTransform head_bone = mem.Read<FTransform>(i.head_bone);
					// Get real component to world
					FTransform component_to_world = mem.Read<FTransform>(i.component_to_world);
					Vector2 screen_center = { (double)settings::screen_center_x, (double)settings::screen_center_y };
					Vector3 world_space = get_world_space_coords(head_bone, component_to_world);
					double world_space_distance = world_space.distance(cache::local_camera.location);
					Vector2 a_screen = project_world_to_screen(world_space);
					double distance = 0.999 * (a_screen - screen_center).x * (a_screen - screen_center).x + 0.999 * (a_screen - screen_center).y * (a_screen - screen_center).y + 0.001 * world_space_distance * world_space_distance;
					EXEC_ON_ARG(std::cout << "Distance: " << world_space_distance << '\n', false);
					BYTE is_dying;
					BYTE is_dbno;

					mem.AddScatterReadRequest(scatter_handle, i.player_pawn + offsets::pawn_to_isdying, &is_dying, sizeof(is_dying));
					mem.AddScatterReadRequest(scatter_handle, i.player_pawn + offsets::pawn_to_isdbno, &is_dbno, sizeof(is_dbno));
					mem.ExecuteReadScatter(scatter_handle);
					is_dbno = is_dbno >> 4 & 1;
					is_dying = is_dying >> 4 & 1;

					if (distance < cache::closest_distance && !is_dying && !is_dbno) {
						cache::closest_distance = distance;
						i.cached_head_bone = head_bone;
						i.cached_component_to_world = component_to_world;
						cache::closest_mesh_info = i;
					}
				}

				if (cache::closest_mesh_info.player_state == 0) {
					continue;
				}

				// Get the head bone and component to world of the closest mesh
				FTransform head_bone = cache::closest_mesh_info.cached_head_bone;
				FTransform component_to_world = cache::closest_mesh_info.cached_component_to_world;
				// Get the world space coordinates of the head bone
				Vector3 head_world = get_world_space_coords(head_bone, component_to_world);

				Vector3 velocity = mem.Read<Vector3>(cache::closest_mesh_info.root_component + offsets::component_to_velocity);
				//std::cout << "Velocity: " << velocity.x << " " << velocity.y << " " << velocity.z << std::endl;
				float dist = head_world.distance(cache::local_camera.location);
				Vector3 head_world_adjusted = predict_location(head_world, velocity, projectile_stats::projectile_speed, projectile_stats::gravity_scale, dist);

				// Project the world space coordinates to screen
				Vector2 head_screen = project_world_to_screen(head_world_adjusted);

				// Print the head screen coordinates
				EXEC_ON_DEBUG(std::cout << "Head Screen X: " << head_screen.x << " Y: " << head_screen.y << '\n');

				// Get the center of the screen
				Vector2 screen_center = { (double)settings::screen_center_x, (double)settings::screen_center_y };

				// Calculate the difference between the head screen and the screen center
				Vector2 diff = head_screen - screen_center;

				// Adjust player controller rotation until diff is below a certain threshold

				// Calculate vector length squared
				double vector_length_squared = diff.x * diff.x + diff.y * diff.y;

				if (vector_length_squared > 2 && abs(diff.x) < settings::screen_center_x + 300 && abs(diff.y) < settings::screen_center_y + 300) {
					GEN_CHRONO_VAR_WITH_NUM_SUFFIX(start, 1);
					pitch_integral += -diff.y / settings::screen_center_x;
					yaw_integral += diff.x / settings::screen_center_x;

					double derivative_pitch = -diff.y / settings::screen_center_x - previous_pitch_error;
					double derivative_yaw = diff.x / settings::screen_center_x - previous_yaw_error;

					// Get the player controller rotation
					uintptr_t rotation_input = cache::player_controller + offsets::playercontroller_to_rotationinput;
					uintptr_t rotation_input2 = cache::player_controller + offsets::playercontroller_to_rotationinput2;
					//double smoothness_y = 20.0;
					//double smoothness_x = 20.0;

					// Print the difference
					EXEC_ON_DEBUG(std::cout << "Diff X: " << diff.x << " Y: " << diff.y << '\n');
					/*if (abs(diff.y) < 10) {
						smoothness_y = 30.0;
					}
					if (abs(diff.y) < 5) {
						smoothness_y = 20.0;
					}
					if (abs(diff.x) < 10) {
						smoothness_x = 30.0;
					}
					if (abs(diff.x) < 5) {
						smoothness_x = 20.0;
					}*/
					bool modified = false;
					// Set pitch rotation
					if (abs(diff.y) > 2) {
						modified = true;
						if (cache::local_camera.fov < 39) {
							ki = 0;
							kd = 9.0;
							double input = std::clamp(-diff.y / settings::screen_center_x * 7.0 + pitch_integral * ki + kd * derivative_pitch, -0.2, 0.2);
							mem.AddScatterWriteRequest(scatter_handle_write, rotation_input, &input, sizeof(input));
							
							EXEC_ON_DEBUG(std::cout << "Pitch: " << -diff.y / settings::screen_center_x * 7.0 + pitch_integral * ki + kd * derivative_pitch <<
								'\n');
						}
						else {
							double input = -diff.y / settings::screen_center_x * 13.1 + pitch_integral * ki + kd * derivative_pitch;
							mem.AddScatterWriteRequest(scatter_handle_write, rotation_input, &input, sizeof(input));
							
							EXEC_ON_DEBUG(std::cout << "Pitch: " << -diff.y / settings::screen_center_x * 13.1 + pitch_integral * ki + kd * derivative_pitch <<
								'\n');
						}
					}
					else {
						pitch_integral = 0;
					}

					// Set yaw rotation
					if (abs(diff.x) > 2) {
						modified = true;
						if (cache::local_camera.fov < 39) {
							ki = 0;
							kd = 9.0;
							double input = std::clamp(diff.x / settings::screen_center_x * 7.0 + yaw_integral * ki + kd * derivative_yaw, -0.2, 0.2);
							mem.AddScatterWriteRequest(scatter_handle_write, rotation_input + 0x8, &input, sizeof(input));
							
							EXEC_ON_DEBUG(std::cout << "Yaw: " << diff.x / settings::screen_center_x * 7.0 + yaw_integral * ki + kd * derivative_yaw <<
								'\n');
						}
						else {
							double input = diff.x / settings::screen_center_x * 13.1 + yaw_integral * ki + kd * derivative_yaw;
							mem.AddScatterWriteRequest(scatter_handle_write, rotation_input + 0x8, &input, sizeof(input));
							
							EXEC_ON_DEBUG(std::cout << "Yaw: " << diff.x / settings::screen_center_x * 13.1 + yaw_integral * ki + kd * derivative_yaw <<
								'\n');
						}
					}
					else {
						yaw_integral = 0;
					}
					if (modified) {
						mem.ExecuteWriteScatter(scatter_handle_write);
					}

					previous_pitch_error = -diff.y / settings::screen_center_x;
					previous_yaw_error = diff.x / settings::screen_center_x;
					GEN_CHRONO_VAR_WITH_NUM_SUFFIX(end, 1);
					GET_CHRONO_ELAPSED(elapsed1, end1, start1);
					if (elapsed1.count() - last_elapsed > 0.01) {
						EXEC_ON_ARG(std::cout << "bad performance on MEM WRITE " << elapsed1.count() << '\n', true);
						last_elapsed = elapsed1.count();
					}
				}

				// Print performance
				GEN_CHRONO_VAR_WITH_NUM_SUFFIX(end, 0);
				GET_CHRONO_ELAPSED(elapsed, end0, start0);
				if (elapsed.count() > 0.1) {
					EXEC_ON_ARG(std::cout << "bad performance " << elapsed.count() << '\n', true);
				}
				EXEC_ON_DEBUG(std::cout << "Aimbot performance: " << elapsed.count() << "s" << '\n');
				//Sleep(2);
			}
			catch (std::exception& e) {
				std::cout << e.what() << '\n';
			}
		}
		else {
			previous_pitch_error = 0;
			previous_yaw_error = 0;
			pitch_integral = 0;
			yaw_integral = 0;
		}
		//Sleep(1);
	}
}


void aimbot_activation_thread() {
	while (true) {
		if (mem.GetKeyboard()->IsKeyDown(VK_RBUTTON)) {
			aimbot_in_action = true;
		}
		else {
			aimbot_in_action = false;
		}
		using namespace std::chrono_literals;
		std::this_thread::sleep_for(101ms);
		// Sleep(100);
	}
}

void aimbot_toggle_check_thread() {
	while (true) {
		if (mem.GetKeyboard()->IsKeyDown(VK_NUMPAD0)) {
			if (settings::aimbot::enable) {
				std::cout << "Aimbot disabled" << '\n';
			}
			else {
				std::cout << "Aimbot enabled" << '\n';
			}
			settings::aimbot::enable = !settings::aimbot::enable;
		}
		using namespace std::chrono_literals;
		std::this_thread::sleep_for(203ms);
		// Sleep(200);
	}
}

void weapon_update_thread()
{
	while (true)
	{
		cache::local_pawn = mem.ReadChain(cache::player_controller, { (UINT)offsets::playercontroller_to_pawn });
		auto weapon_name = get_weapon_name();
		if (weapon_name == nullptr || wcslen(weapon_name.get()) == 0)
		{
			// std::wcout << "Failed to get weapon name" << std::endl;
			using namespace std::chrono_literals;
			std::this_thread::sleep_for(1507ms);
			// Sleep(1500);
			continue;
		}
		EXEC_ON_ARG(std::wcout << "Weapon name: " << weapon_name << '\n', false)
		// Get weapon projectile stats from weapon name
		auto weapon_stats = weapon_projectile_map.find(weapon_name.get());
		if (weapon_stats != weapon_projectile_map.end())
		{
			std::wcout << "Weapon projectile stats found" << '\n';
			projectile_stats::projectile_speed = weapon_stats->second.speed;
			projectile_stats::gravity_scale = weapon_stats->second.gravity_scale;
			// std::cout << "Projectile speed: " << projectile_stats::projectile_speed << " Gravity scale: " << projectile_stats::gravity_scale << std::endl;
		}
		else
		{
			// std::wcout << "Weapon projectile stats not found" << std::endl;
			projectile_stats::projectile_speed = 80000.0f;
			projectile_stats::gravity_scale = 0.0f;

		}
		using namespace std::chrono_literals;
		std::this_thread::sleep_for(1507ms);
		// Sleep(1500);
	}
}


int main()
{

	/*if (!mem.Init("testproj.exe", true, true))
	{
		std::cout << "Failed to initialize memory class\n";
		return 1;
	}

	if (!mem.FixCr3())
		std::cout << "Failed to fix CR3" << std::endl;
	else
		std::cout << "CR3 fixed" << std::endl;

	uintptr_t base_address1 = mem.GetBaseDaddy("testproj.exe");

	if (!base_address1)
	{
		std::cout << "Failed to get base address\n";
		return 1;
	}

	uintptr_t uworld = mem.ReadChain(base_address1 + 0x0EABDEE8, { 0x00 });
	uintptr_t local_player_controller = mem.ReadChain(uworld, { 0x1B8, 0x38, 0x00, 0x30 });
	uintptr_t yaw_input = local_player_controller + 0x560;
	while (true) {
		mem.Write<double>(yaw_input, 1.0);
		Sleep(1000 / 250);
	}*/


	if (!mem.Init("FortniteClient-Win64-Shipping.exe", true, true))
	{
		std::cout << "Failed to initialize memory class\n";
		return 1;
	}

	Sleep(2000);

	uintptr_t base_address = mem.GetBaseDaddy("FortniteClient-Win64-Shipping.exe");
	if (!base_address)
	{
		std::cout << "Failed to get base address\n";
		return 1;
	}

	if (!mem.GetKeyboard()->InitKeyboard())
	{
		std::cout << "Failed to initialize keyboard hotkeys through kernel." << '\n';
		return 1;
	}

	cache::camera_view_scatter_handle = mem.CreateScatterHandle();

	cache::uworld = mem.ReadChain(base_address + offsets::uworld, { 0x00 });

	uintptr_t local_player = mem.ReadChain(base_address + offsets::uworld, { 0x00, 0x1D8, 0x38, 0x00 });


	if (!local_player)
	{
		std::cout << "Failed to get local player\n";
		return 1;
	}
	cache::player_controller = mem.ReadChain(local_player, { 0x30 });
	// Print the player controller address
	std::cout << "Player controller address: " << std::hex << cache::player_controller << '\n';
	// Restore decimal output
	std::cout << std::dec;

	cache::local_pawn = mem.ReadChain(cache::player_controller, { (UINT)offsets::playercontroller_to_pawn });
	// Print the player pawn address
	std::cout << "Player pawn address: " << std::hex << cache::local_pawn << '\n';
	// Restore decimal output
	std::cout << std::dec;

	cache::my_team_id = mem.Read<BYTE>(mem.ReadChain(cache::player_controller, { (UINT)offsets::playercontroller_to_playerstate }) + offsets::playerstate_to_teamid);

	// Start a new thread to get all player meshes every 20 seconds
	std::thread get_all_player_meshes_thread(get_all_player_meshes, 500);
	//get_all_player_meshes_thread.detach();

	// Start aimbot toggle check thread
	std::thread aimbot_toggle_check_thread_run(aimbot_toggle_check_thread);
	//aimbot_toggle_check_thread_run.detach();

	// Start aimbot activation thread
	std::thread aimbot_activation_thread_run(aimbot_activation_thread);
	//aimbot_activation_thread_run.detach();

	// Start weapon name print thread
	std::thread print_weapon_name_thread_run(weapon_update_thread);

	// Create aimbot thread
	std::thread aimbot_thread(aimbot);
	aimbot_thread.join();

	//uintptr_t player_controller = mem.ReadChain(local_player, { 0x30 });
	//if (!player_controller)
	//{
	//	std::cout << "Failed to get player controller\n";
	//	return 1;
	//}

	//uintptr_t player_pawn = mem.ReadChain(player_controller, { 0x338 });
	//// Print the player pawn address
	//std::cout << "Player pawn address: " << std::hex << player_pawn << std::endl;
	//// Restore decimal output
	//std::cout << std::dec;
	//if (!player_pawn)
	//{
	//	std::cout << "Failed to get player pawn\n";
	//	return 1;
	//}

	//uintptr_t player_mesh_component = mem.ReadChain(player_pawn, { 0x318 });
	//if (!player_mesh_component)
	//{
	//	std::cout << "Failed to get player mesh component\n";
	//	return 1;
	//}

	//std::cout << "Player mesh component address: " << std::hex << player_mesh_component << std::endl;
	//std::cout << std::dec;

	///*uintptr_t player_mesh = mem.ReadChain(player_root, { 0x280 });
	//if (!player_mesh)
	//{
	//	std::cout << "Failed to get player mesh\n";
	//	return 1;
	//}*/


	//// Get player bone array cache
	//uintptr_t player_bone_array_cache = mem.ReadChain(player_mesh_component, { 0x5f8 });
	//// Print the bone array cache address
	//std::cout << "Bone array cache address: " << std::hex << player_bone_array_cache << std::endl;
	//// Restore decimal output
	//std::cout << std::dec;

	//uintptr_t player_bone_array_final = mem.Read<uintptr_t>(player_mesh_component + 0x5b0);
	//// Print the bone array address
	//std::cout << "Bone array address: " << std::hex << player_bone_array_final << std::endl;
	//// Restore decimal output
	//std::cout << std::dec;

	//while (true)
	//{

	//	/*
	//	* This iterates all the bones of the player and prints their positions
	//	for (unsigned long long i = 0; i < 100; i++)
	//	{
	//		uintptr_t bone = player_bone_array + i * 0x60;
	//		if (!bone)
	//		{
	//			std::cout << "Failed to get bone\n";
	//			return 1;
	//		}

	//		float bone_pos[3] = { };
	//		mem.Read(bone + 0x20, bone_pos, sizeof(bone_pos));

	//		std::cout << "Bone " << i << " X: " << bone_pos[0] << " Y: " << bone_pos[1] << " Z: " << bone_pos[2] << std::endl;

	//	}*/

	//	// Get the bone of the head and print its position
	//	uintptr_t head_bone = player_bone_array_final + 0x60 * 110;

	//	FTransform head_transform = mem.Read<FTransform>(head_bone);
	//	std::cout << "Head X: " << head_transform.translation.x << " Y: " << head_transform.translation.y << " Z: " << head_transform.translation.z << std::endl;

	//	// Convert to world space
	//	FTransform component_to_world = mem.Read<FTransform>(player_mesh_component + 0x1C0);
	//	D3DMATRIX bone_matrix = matrix_multiplication(head_transform.to_matrix_with_scale(), component_to_world.to_matrix_with_scale());
	//	
	//	Vector3 head_world = { bone_matrix._41, bone_matrix._42, bone_matrix._43 };

	//	std::cout << "Head World X: " << head_world.x << " Y: " << head_world.y << " Z: " << head_world.z << std::endl;
	//	// Project world to screen
	//	Vector2 head_screen = project_world_to_screen(head_world);
	//	//Print camera location
	//	//std::cout << "Camera Rotation X: " << cache::local_camera.location.x << " Y: " << cache::local_camera.location.y << " Z: " << cache::local_camera.location.z << "fov: " << cache::local_camera.fov << std::endl;
	//	std::cout << "Head Screen X: " << head_screen.x << " Y: " << head_screen.y << std::endl;

	//	Sleep(1000 / 60);

	//}


	return 0;
}

```

`FortniteDma/FortniteDma.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{43160328-25d3-43bc-8a4f-e26ec5759c7a}</ProjectGuid>
    <RootNamespace>FortniteDma</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;_ITERATOR_DEBUG_LEVEL=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <AdditionalIncludeDirectories>C:\Users\Authority\Desktop\c++ projects\newDmaLibrary\DMALibrary\DMALibrary;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>C:\Users\Authority\Desktop\c++ projects\newDmaLibrary\DMALibrary\lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>DMALibrary.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <AdditionalIncludeDirectories>C:\Users\Authority\Desktop\c++ projects\newDmaLibrary\DMALibrary\DMALibrary;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <FloatingPointModel>Fast</FloatingPointModel>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>C:\Users\Authority\Desktop\c++ projects\newDmaLibrary\DMALibrary\lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>DMALibrary.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="FortniteDma.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Settings.hpp" />
    <ClInclude Include="UnrealContainers.hpp" />
    <ClInclude Include="Utils.hpp" />
    <ClInclude Include="Weapons.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`FortniteDma/FortniteDma.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="FortniteDma.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="UnrealContainers.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Utils.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Settings.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Weapons.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`FortniteDma/Settings.hpp`:

```hpp
#pragma once
namespace settings
{
	inline int width = GetSystemMetrics(SM_CXSCREEN);
	inline int height = GetSystemMetrics(SM_CYSCREEN);
	inline int screen_center_x = width / 2;
	inline int screen_center_y = height / 2;
	inline bool show_menu = true;
	inline int tab = 0;
	namespace aimbot
	{
		inline bool enable = false;
		inline bool show_fov = false;
		inline float fov = 150;
		inline float smoothness = 5;
		inline static const char* aimkey[] = { "Left Mouse Button", "Right Mouse Button" };
		inline static int current_aimkey = 1;
		inline static int current_key = VK_RBUTTON;
	}
	namespace visuals
	{
		inline bool enable = false;
		inline bool box = false;
		inline bool fill_box = false;
		inline bool line = false;
		inline bool distance = false;
	}
}
```

`FortniteDma/UnrealContainers.hpp`:

```hpp
#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Container implementations with iterators. See https://github.com/Fischsalat/UnrealContainers

#include <string>
#include <stdexcept>

namespace UC
{
	typedef int8_t  int8;
	typedef int16_t int16;
	typedef int32_t int32;
	typedef int64_t int64;

	typedef uint8_t  uint8;
	typedef uint16_t uint16;
	typedef uint32_t uint32;
	typedef uint64_t uint64;

	template<typename ArrayElementType>
	class TArray;

	template<typename SparseArrayElementType>
	class TSparseArray;

	template<typename SetElementType>
	class TSet;

	template<typename KeyElementType, typename ValueElementType>
	class TMap;

	template<typename KeyElementType, typename ValueElementType>
	class TPair;

	namespace Iterators
	{
		class FSetBitIterator;

		template<typename ArrayType>
		class TArrayIterator;

		template<class ContainerType>
		class TContainerIterator;

		template<typename SparseArrayElementType>
		using TSparseArrayIterator = TContainerIterator<TSparseArray<SparseArrayElementType>>;

		template<typename SetElementType>
		using TSetIterator = TContainerIterator<TSet<SetElementType>>;

		template<typename KeyElementType, typename ValueElementType>
		using TMapIterator = TContainerIterator<TMap<KeyElementType, ValueElementType>>;
	}


	namespace ContainerImpl
	{
		namespace HelperFunctions
		{
			inline uint32 FloorLog2(uint32 Value)
			{
				uint32 pos = 0;
				if (Value >= 1 << 16) { Value >>= 16; pos += 16; }
				if (Value >= 1 << 8) { Value >>= 8; pos += 8; }
				if (Value >= 1 << 4) { Value >>= 4; pos += 4; }
				if (Value >= 1 << 2) { Value >>= 2; pos += 2; }
				if (Value >= 1 << 1) { pos += 1; }
				return pos;
			}

			inline uint32 CountLeadingZeros(uint32 Value)
			{
				if (Value == 0)
					return 32;

				return 31 - FloorLog2(Value);
			}
		}

		template<int32 Size, uint32 Alignment>
		struct TAlignedBytes
		{
			alignas(Alignment) uint8 Pad[Size];
		};

		template<uint32 NumInlineElements>
		class TInlineAllocator
		{
		public:
			template<typename ElementType>
			class ForElementType
			{
			private:
				static constexpr int32 ElementSize = sizeof(ElementType);
				static constexpr int32 ElementAlign = alignof(ElementType);

				static constexpr int32 InlineDataSizeBytes = NumInlineElements * ElementSize;

			private:
				TAlignedBytes<ElementSize, ElementAlign> InlineData[NumInlineElements];
				ElementType* SecondaryData;

			public:
				ForElementType()
					: InlineData{ 0x0 }, SecondaryData(nullptr)
				{
				}

				ForElementType(ForElementType&&) = default;
				ForElementType(const ForElementType&) = default;

			public:
				ForElementType& operator=(ForElementType&&) = default;
				ForElementType& operator=(const ForElementType&) = default;

			public:
				inline const ElementType* GetAllocation() const { return SecondaryData ? SecondaryData : reinterpret_cast<const ElementType*>(&InlineData); }

				inline uint32 GetNumInlineBytes() const { return NumInlineElements; }
			};
		};

		class FBitArray
		{
		protected:
			static constexpr int32 NumBitsPerDWORD = 32;
			static constexpr int32 NumBitsPerDWORDLogTwo = 5;

		private:
			TInlineAllocator<4>::ForElementType<int32> Data;
			int32 NumBits;
			int32 MaxBits;

		public:
			FBitArray()
				: NumBits(0), MaxBits(Data.GetNumInlineBytes()* NumBitsPerDWORD)
			{
			}

			FBitArray(const FBitArray&) = default;

			FBitArray(FBitArray&&) = default;

		public:
			FBitArray& operator=(FBitArray&&) = default;

			FBitArray& operator=(const FBitArray& Other) = default;

		private:
			inline void VerifyIndex(int32 Index) const { if (!IsValidIndex(Index)) throw std::out_of_range("Index was out of range!"); }

		public:
			inline int32 Num() const { return NumBits; }
			inline int32 Max() const { return MaxBits; }

			inline const uint32* GetData() const { return reinterpret_cast<const uint32*>(Data.GetAllocation()); }

			inline bool IsValidIndex(int32 Index) const { return Index >= 0 && Index < NumBits; }

			inline bool IsValid() const { return GetData() && NumBits > 0; }

		public:
			inline bool operator[](int32 Index) const { VerifyIndex(Index); return GetData()[Index / NumBitsPerDWORD] & (1 << (Index & (NumBitsPerDWORD - 1))); }

			inline bool operator==(const FBitArray& Other) const { return NumBits == Other.NumBits && GetData() == Other.GetData(); }
			inline bool operator!=(const FBitArray& Other) const { return NumBits != Other.NumBits || GetData() != Other.GetData(); }

		public:
			friend Iterators::FSetBitIterator begin(const FBitArray& Array);
			friend Iterators::FSetBitIterator end(const FBitArray& Array);
		};

		template<typename SparseArrayType>
		union TSparseArrayElementOrFreeListLink
		{
			SparseArrayType ElementData;

			struct
			{
				int32 PrevFreeIndex;
				int32 NextFreeIndex;
			};
		};

		template<typename SetType>
		class SetElement
		{
		private:
			template<typename SetDataType>
			friend class TSet;

		private:
			SetType Value;
			int32 HashNextId;
			int32 HashIndex;
		};
	}


	template <typename KeyType, typename ValueType>
	class TPair
	{
	private:
		KeyType First;
		ValueType Second;

	public:
		TPair(KeyType Key, ValueType Value)
			: First(Key), Second(Value)
		{
		}

	public:
		inline       KeyType& Key() { return First; }
		inline const KeyType& Key() const { return First; }

		inline       ValueType& Value() { return Second; }
		inline const ValueType& Value() const { return Second; }
	};

	template<typename ArrayElementType>
	class TArray
	{
	private:
		template<typename ArrayElementType>
		friend class TAllocatedArray;

		template<typename SparseArrayElementType>
		friend class TSparseArray;

	protected:
		static constexpr uint64 ElementAlign = alignof(ArrayElementType);
		static constexpr uint64 ElementSize = sizeof(ArrayElementType);

	protected:
		ArrayElementType* Data;
		int32 NumElements;
		int32 MaxElements;

	public:
		TArray()
			: Data(nullptr), NumElements(0), MaxElements(0)
		{
		}

		TArray(const TArray&) = default;

		TArray(TArray&&) = default;

	public:
		TArray& operator=(TArray&&) = default;
		TArray& operator=(const TArray&) = default;

	private:
		inline int32 GetSlack() const { return MaxElements - NumElements; }

		inline void VerifyIndex(int32 Index) const { if (!IsValidIndex(Index)) throw std::out_of_range("Index was out of range!"); }
	public:
		inline       ArrayElementType& GetUnsafe(int32 Index) { return Data[Index]; }
		inline const ArrayElementType& GetUnsafe(int32 Index) const { return Data[Index]; }

	public:
		/* Adds to the array if there is still space for one more element */
		inline bool Add(const ArrayElementType& Element)
		{
			if (GetSlack() <= 0)
				return false;

			Data[NumElements] = Element;
			NumElements++;

			return true;
		}

		inline bool Remove(int32 Index)
		{
			if (!IsValidIndex(Index))
				return false;

			NumElements--;

			for (int i = Index; i < NumElements; i++)
			{
				/* NumElements was decremented, acessing i + 1 is safe */
				Data[i] = Data[i + 1];
			}

			return true;
		}

		inline void Clear()
		{
			NumElements = 0;

			if (!Data)
				memset(Data, 0, NumElements * ElementSize);
		}

	public:
		inline int32 Num() const { return NumElements; }
		inline int32 Max() const { return MaxElements; }

		inline bool IsValidIndex(int32 Index) const { return Data && Index >= 0 && Index < NumElements; }

		inline bool IsValid() const { return Data && NumElements > 0 && MaxElements >= NumElements; }

	public:
		inline       ArrayElementType& operator[](int32 Index) { VerifyIndex(Index); return Data[Index]; }
		inline const ArrayElementType& operator[](int32 Index) const { VerifyIndex(Index); return Data[Index]; }

		inline bool operator==(const TArray<ArrayElementType>& Other) const { return Data == Other.Data; }
		inline bool operator!=(const TArray<ArrayElementType>& Other) const { return Data != Other.Data; }

		inline explicit operator bool() const { return IsValid(); };

	public:
		template<typename T> friend Iterators::TArrayIterator<T> begin(const TArray& Array);
		template<typename T> friend Iterators::TArrayIterator<T> end(const TArray& Array);
	};

	class FString : public TArray<wchar_t>
	{
	public:
		using TArray::TArray;

		FString(const wchar_t* Str)
		{
			const uint32 NullTerminatedLength = static_cast<uint32>(wcslen(Str) + 0x1);

			Data = const_cast<wchar_t*>(Str);
			NumElements = NullTerminatedLength;
			MaxElements = NullTerminatedLength;
		}

	public:
		inline std::string ToString() const
		{
			if (*this)
			{
				std::wstring WData(Data);
#pragma warning(suppress: 4244)
				return std::string(WData.begin(), WData.end());
			}

			return "";
		}

		inline std::wstring ToWString() const
		{
			if (*this)
				return std::wstring(Data);

			return L"";
		}

	public:
		inline       wchar_t* CStr() { return Data; }
		inline const wchar_t* CStr() const { return Data; }

	public:
		inline bool operator==(const FString& Other) const { return Other ? NumElements == Other.NumElements && wcscmp(Data, Other.Data) == 0 : false; }
		inline bool operator!=(const FString& Other) const { return Other ? NumElements != Other.NumElements || wcscmp(Data, Other.Data) != 0 : true; }
	};

	/*
	* Class to allow construction of a TArray, that uses c-style standard-library memory allocation.
	*
	* Useful for calling functions that expect a buffer of a certain size and do not reallocate that buffer.
	* This avoids leaking memory, if the array would otherwise be allocated by the engine, and couldn't be freed without FMemory-functions.
	*/
	template<typename ArrayElementType>
	class TAllocatedArray : public TArray<ArrayElementType>
	{
	public:
		TAllocatedArray() = delete;

	public:
		TAllocatedArray(int32 Size)
		{
			this->Data = static_cast<ArrayElementType*>(malloc(Size * sizeof(ArrayElementType)));
			this->NumElements = 0x0;
			this->MaxElements = Size;
		}

		~TAllocatedArray()
		{
			if (this->Data)
				free(this->Data);

			this->NumElements = 0x0;
			this->MaxElements = 0x0;
		}

	public:
		inline operator TArray<ArrayElementType>() { return *reinterpret_cast<TArray<ArrayElementType>*>(this); }
		inline operator const TArray<ArrayElementType>() const { return *reinterpret_cast<const TArray<ArrayElementType>*>(this); }
	};

	/*
	* Class to allow construction of an FString, that uses c-style standard-library memory allocation.
	*
	* Useful for calling functions that expect a buffer of a certain size and do not reallocate that buffer.
	* This avoids leaking memory, if the array would otherwise be allocated by the engine, and couldn't be freed without FMemory-functions.
	*/
	class FAllocatedString : public FString
	{
	public:
		FAllocatedString() = delete;

	public:
		FAllocatedString(int32 Size)
		{
			Data = static_cast<wchar_t*>(malloc(Size * sizeof(wchar_t)));
			NumElements = 0x0;
			MaxElements = Size;
		}

		~FAllocatedString()
		{
			if (Data)
				free(Data);

			NumElements = 0x0;
			MaxElements = 0x0;
		}

	public:
		inline operator FString() { return *reinterpret_cast<FString*>(this); }
		inline operator const FString() const { return *reinterpret_cast<const FString*>(this); }
	};
	template<typename SparseArrayElementType>
	class TSparseArray
	{
	private:
		static constexpr uint32 ElementAlign = alignof(SparseArrayElementType);
		static constexpr uint32 ElementSize = sizeof(SparseArrayElementType);

	private:
		using FElementOrFreeListLink = ContainerImpl::TSparseArrayElementOrFreeListLink<ContainerImpl::TAlignedBytes<ElementSize, ElementAlign>>;

	private:
		TArray<FElementOrFreeListLink> Data;
		ContainerImpl::FBitArray AllocationFlags;
		int32 FirstFreeIndex;
		int32 NumFreeIndices;

	public:
		TSparseArray()
			: FirstFreeIndex(-1), NumFreeIndices(0)
		{
		}

		TSparseArray(TSparseArray&&) = default;
		TSparseArray(const TSparseArray&) = default;

	public:
		TSparseArray& operator=(TSparseArray&&) = default;
		TSparseArray& operator=(const TSparseArray&) = default;

	private:
		inline void VerifyIndex(int32 Index) const { if (!IsValidIndex(Index)) throw std::out_of_range("Index was out of range!"); }

	public:
		inline int32 NumAllocated() const { return Data.Num(); }

		inline int32 Num() const { return NumAllocated() - NumFreeIndices; }
		inline int32 Max() const { return Data.Max(); }

		inline bool IsValidIndex(int32 Index) const { return Data.IsValidIndex(Index) && AllocationFlags[Index]; }

		inline bool IsValid() const { return Data.IsValid() && AllocationFlags.IsValid(); }

	public:
		const ContainerImpl::FBitArray& GetAllocationFlags() const { return AllocationFlags; }

	public:
		inline       SparseArrayElementType& operator[](int32 Index) { VerifyIndex(Index); return *reinterpret_cast<SparseArrayElementType*>(&Data.GetUnsafe(Index).ElementData); }
		inline const SparseArrayElementType& operator[](int32 Index) const { VerifyIndex(Index); return *reinterpret_cast<SparseArrayElementType*>(&Data.GetUnsafe(Index).ElementData); }

		inline bool operator==(const TSparseArray<SparseArrayElementType>& Other) const { return Data == Other.Data; }
		inline bool operator!=(const TSparseArray<SparseArrayElementType>& Other) const { return Data != Other.Data; }

	public:
		template<typename T> friend Iterators::TSparseArrayIterator<T> begin(const TSparseArray& Array);
		template<typename T> friend Iterators::TSparseArrayIterator<T> end(const TSparseArray& Array);
	};

	template<typename SetElementType>
	class TSet
	{
	private:
		static constexpr uint32 ElementAlign = alignof(SetElementType);
		static constexpr uint32 ElementSize = sizeof(SetElementType);

	private:
		using SetDataType = ContainerImpl::SetElement<SetElementType>;
		using HashType = ContainerImpl::TInlineAllocator<1>::ForElementType<int32>;

	private:
		TSparseArray<SetDataType> Elements;
		HashType Hash;
		int32 HashSize;

	public:
		TSet()
			: HashSize(0)
		{
		}

		TSet(TSet&&) = default;
		TSet(const TSet&) = default;

	public:
		TSet& operator=(TSet&&) = default;
		TSet& operator=(const TSet&) = default;

	private:
		inline void VerifyIndex(int32 Index) const { if (!IsValidIndex(Index)) throw std::out_of_range("Index was out of range!"); }

	public:
		inline int32 NumAllocated() const { return Elements.NumAllocated(); }

		inline int32 Num() const { return Elements.Num(); }
		inline int32 Max() const { return Elements.Max(); }

		inline bool IsValidIndex(int32 Index) const { return Elements.IsValidIndex(Index); }

		inline bool IsValid() const { return Elements.IsValid(); }

	public:
		const ContainerImpl::FBitArray& GetAllocationFlags() const { return Elements.GetAllocationFlags(); }

	public:
		inline       SetElementType& operator[] (int32 Index) { return Elements[Index].Value; }
		inline const SetElementType& operator[] (int32 Index) const { return Elements[Index].Value; }

		inline bool operator==(const TSet<SetElementType>& Other) const { return Elements == Other.Elements; }
		inline bool operator!=(const TSet<SetElementType>& Other) const { return Elements != Other.Elements; }

	public:
		template<typename T> friend Iterators::TSetIterator<T> begin(const TSet& Set);
		template<typename T> friend Iterators::TSetIterator<T> end(const TSet& Set);
	};

	template<typename KeyElementType, typename ValueElementType>
	class TMap
	{
	public:
		using ElementType = TPair<KeyElementType, ValueElementType>;

	private:
		TSet<ElementType> Elements;

	private:
		inline void VerifyIndex(int32 Index) const { if (!IsValidIndex(Index)) throw std::out_of_range("Index was out of range!"); }

	public:
		inline int32 NumAllocated() const { return Elements.NumAllocated(); }

		inline int32 Num() const { return Elements.Num(); }
		inline int32 Max() const { return Elements.Max(); }

		inline bool IsValidIndex(int32 Index) const { return Elements.IsValidIndex(Index); }

		inline bool IsValid() const { return Elements.IsValid(); }

	public:
		const ContainerImpl::FBitArray& GetAllocationFlags() const { return Elements.GetAllocationFlags(); }

	public:
		inline decltype(auto) Find(const KeyElementType& Key, bool(*Equals)(const KeyElementType& LeftKey, const KeyElementType& RightKey))
		{
			for (auto It = begin(*this); It != end(*this); ++It)
			{
				if (Equals(It->Key(), Key))
					return It;
			}

			return end(*this);
		}

	public:
		inline       ElementType& operator[] (int32 Index) { return Elements[Index]; }
		inline const ElementType& operator[] (int32 Index) const { return Elements[Index]; }

		inline bool operator==(const TMap<KeyElementType, ValueElementType>& Other) const { return Elements == Other.Elements; }
		inline bool operator!=(const TMap<KeyElementType, ValueElementType>& Other) const { return Elements != Other.Elements; }

	public:
		template<typename KeyType, typename ValueType> friend Iterators::TMapIterator<KeyType, ValueType> begin(const TMap& Map);
		template<typename KeyType, typename ValueType> friend Iterators::TMapIterator<KeyType, ValueType> end(const TMap& Map);
	};

	namespace Iterators
	{
		class FRelativeBitReference
		{
		protected:
			static constexpr int32 NumBitsPerDWORD = 32;
			static constexpr int32 NumBitsPerDWORDLogTwo = 5;

		public:
			inline explicit FRelativeBitReference(int32 BitIndex)
				: WordIndex(BitIndex >> NumBitsPerDWORDLogTwo)
				, Mask(1 << (BitIndex & (NumBitsPerDWORD - 1)))
			{
			}

			int32  WordIndex;
			uint32 Mask;
		};

		class FSetBitIterator : public FRelativeBitReference
		{
		private:
			const ContainerImpl::FBitArray& Array;

			uint32 UnvisitedBitMask;
			int32 CurrentBitIndex;
			int32 BaseBitIndex;

		public:
			explicit FSetBitIterator(const ContainerImpl::FBitArray& InArray, int32 StartIndex = 0)
				: FRelativeBitReference(StartIndex)
				, Array(InArray)
				, UnvisitedBitMask((~0U) << (StartIndex & (NumBitsPerDWORD - 1)))
				, CurrentBitIndex(StartIndex)
				, BaseBitIndex(StartIndex & ~(NumBitsPerDWORD - 1))
			{
				if (StartIndex != Array.Num())
					FindFirstSetBit();
			}

		public:
			inline FSetBitIterator& operator++()
			{
				UnvisitedBitMask &= ~this->Mask;

				FindFirstSetBit();

				return *this;
			}

			inline explicit operator bool() const { return CurrentBitIndex < Array.Num(); }

			inline bool operator==(const FSetBitIterator& Rhs) const { return CurrentBitIndex == Rhs.CurrentBitIndex && &Array == &Rhs.Array; }
			inline bool operator!=(const FSetBitIterator& Rhs) const { return CurrentBitIndex != Rhs.CurrentBitIndex || &Array != &Rhs.Array; }

		public:
			inline int32 GetIndex() { return CurrentBitIndex; }

			void FindFirstSetBit()
			{
				const uint32* ArrayData = Array.GetData();
				const int32   ArrayNum = Array.Num();
				const int32   LastWordIndex = (ArrayNum - 1) / NumBitsPerDWORD;

				uint32 RemainingBitMask = ArrayData[this->WordIndex] & UnvisitedBitMask;
				while (!RemainingBitMask)
				{
					++this->WordIndex;
					BaseBitIndex += NumBitsPerDWORD;
					if (this->WordIndex > LastWordIndex)
					{
						CurrentBitIndex = ArrayNum;
						return;
					}

					RemainingBitMask = ArrayData[this->WordIndex];
					UnvisitedBitMask = ~0;
				}

				const uint32 NewRemainingBitMask = RemainingBitMask & (RemainingBitMask - 1);

				this->Mask = NewRemainingBitMask ^ RemainingBitMask;

				CurrentBitIndex = BaseBitIndex + NumBitsPerDWORD - 1 - ContainerImpl::HelperFunctions::CountLeadingZeros(this->Mask);

				if (CurrentBitIndex > ArrayNum)
					CurrentBitIndex = ArrayNum;
			}
		};

		template<typename ArrayType>
		class TArrayIterator
		{
		private:
			TArray<ArrayType>& IteratedArray;
			int32 Index;

		public:
			TArrayIterator(const TArray<ArrayType>& Array, int32 StartIndex = 0x0)
				: IteratedArray(const_cast<TArray<ArrayType>&>(Array)), Index(StartIndex)
			{
			}

		public:
			inline int32 GetIndex() { return Index; }

			inline int32 IsValid() { return IteratedArray.IsValidIndex(GetIndex()); }

		public:
			inline TArrayIterator& operator++() { ++Index; return *this; }
			inline TArrayIterator& operator--() { --Index; return *this; }

			inline       ArrayType& operator*() { return IteratedArray[GetIndex()]; }
			inline const ArrayType& operator*() const { return IteratedArray[GetIndex()]; }

			inline       ArrayType* operator->() { return &IteratedArray[GetIndex()]; }
			inline const ArrayType* operator->() const { return &IteratedArray[GetIndex()]; }

			inline bool operator==(const TArrayIterator& Other) const { return &IteratedArray == &Other.IteratedArray && Index == Other.Index; }
			inline bool operator!=(const TArrayIterator& Other) const { return &IteratedArray != &Other.IteratedArray || Index != Other.Index; }
		};

		template<class ContainerType>
		class TContainerIterator
		{
		private:
			ContainerType& IteratedContainer;
			FSetBitIterator BitIterator;

		public:
			TContainerIterator(const ContainerType& Container, const ContainerImpl::FBitArray& BitArray, int32 StartIndex = 0x0)
				: IteratedContainer(const_cast<ContainerType&>(Container)), BitIterator(BitArray, StartIndex)
			{
			}

		public:
			inline int32 GetIndex() { return BitIterator.GetIndex(); }

			inline int32 IsValid() { return IteratedContainer.IsValidIndex(GetIndex()); }

		public:
			inline TContainerIterator& operator++() { ++BitIterator; return *this; }
			inline TContainerIterator& operator--() { --BitIterator; return *this; }

			inline       auto& operator*() { return IteratedContainer[GetIndex()]; }
			inline const auto& operator*() const { return IteratedContainer[GetIndex()]; }

			inline       auto* operator->() { return &IteratedContainer[GetIndex()]; }
			inline const auto* operator->() const { return &IteratedContainer[GetIndex()]; }

			inline bool operator==(const TContainerIterator& Other) const { return &IteratedContainer == &Other.IteratedContainer && BitIterator == Other.BitIterator; }
			inline bool operator!=(const TContainerIterator& Other) const { return &IteratedContainer != &Other.IteratedContainer || BitIterator != Other.BitIterator; }
		};
	}

	inline Iterators::FSetBitIterator begin(const ContainerImpl::FBitArray& Array) { return Iterators::FSetBitIterator(Array, 0); }
	inline Iterators::FSetBitIterator end(const ContainerImpl::FBitArray& Array) { return Iterators::FSetBitIterator(Array, Array.Num()); }

	template<typename T> inline Iterators::TArrayIterator<T> begin(const TArray<T>& Array) { return Iterators::TArrayIterator<T>(Array, 0); }
	template<typename T> inline Iterators::TArrayIterator<T> end(const TArray<T>& Array) { return Iterators::TArrayIterator<T>(Array, Array.Num()); }

	template<typename T> inline Iterators::TSparseArrayIterator<T> begin(const TSparseArray<T>& Array) { return Iterators::TSparseArrayIterator<T>(Array, Array.GetAllocationFlags(), 0); }
	template<typename T> inline Iterators::TSparseArrayIterator<T> end(const TSparseArray<T>& Array) { return Iterators::TSparseArrayIterator<T>(Array, Array.GetAllocationFlags(), Array.NumAllocated()); }

	template<typename T> inline Iterators::TSetIterator<T> begin(const TSet<T>& Set) { return Iterators::TSetIterator<T>(Set, Set.GetAllocationFlags(), 0); }
	template<typename T> inline Iterators::TSetIterator<T> end(const TSet<T>& Set) { return Iterators::TSetIterator<T>(Set, Set.GetAllocationFlags(), Set.NumAllocated()); }

	template<typename T0, typename T1> inline Iterators::TMapIterator<T0, T1> begin(const TMap<T0, T1>& Map) { return Iterators::TMapIterator<T0, T1>(Map, Map.GetAllocationFlags(), 0); }
	template<typename T0, typename T1> inline Iterators::TMapIterator<T0, T1> end(const TMap<T0, T1>& Map) { return Iterators::TMapIterator<T0, T1>(Map, Map.GetAllocationFlags(), Map.NumAllocated()); }

	static_assert(sizeof(TArray<int32>) == 0x10, "TArray has a wrong size!");
	static_assert(sizeof(TSet<int32>) == 0x50, "TSet has a wrong size!");
	static_assert(sizeof(TMap<int32, int32>) == 0x50, "TMap has a wrong size!");
}

```

`FortniteDma/Utils.hpp`:

```hpp
#pragma once
#include <d3d9.h>
#include <vector>
#include "Settings.hpp"
#include <mutex>
#include <unordered_map>
#pragma comment(lib, "d3d9.lib")
#define M_PI 3.14159265358979323846264338327950288419716939937510
#define DEBUG false
#define EXEC_ON_DEBUG(x) if (DEBUG) { x; }
#define EXEC_ON_ARG(x, y) if (y) { x; }
#define GEN_CHRONO_VAR_WITH_NUM_SUFFIX(x, y) auto x##y = std::chrono::high_resolution_clock::now();
#define GET_CHRONO_ELAPSED(x, y, z) std::chrono::duration<double> x = y - z;


class Vector2
{
public:
	Vector2() : x(0.f), y(0.f) {}
	Vector2(const double _x, const double _y) : x(_x), y(_y) {}

	Vector2 operator-(Vector2 v) const { return { x - v.x, y - v.y }; }
	Vector2 operator+(Vector2 v) const { return { x + v.x, y + v.y }; }
	double x, y;
};

class Vector3
{
public:
	Vector3() : x(0.f), y(0.f), z(0.f) {}
	Vector3(const double _x, const double _y, const double _z) : x(_x), y(_y), z(_z) {}
	double x, y, z;
	double dot(Vector3 v) const { return x * v.x + y * v.y + z * v.z; }
	double distance(Vector3 v) const { return double(sqrtf(powf(v.x - x, 2.0) + powf(v.y - y, 2.0) + powf(v.z - z, 2.0))); }
	Vector3 operator-(Vector3 v) const { return { x - v.x, y - v.y, z - v.z }; }
};

struct FQuat { double x, y, z, w; };
struct FTransform
{
	FQuat rot;
	Vector3 translation;
	UINT8 pad[0x8];
	Vector3 scale;
	UINT8 pad1[0x8];

	[[nodiscard]] D3DMATRIX to_matrix_with_scale() const
	{
		D3DMATRIX m{};
		m._41 = translation.x;
		m._42 = translation.y;
		m._43 = translation.z;
		double x2 = rot.x + rot.x;
		double y2 = rot.y + rot.y;
		double z2 = rot.z + rot.z;
		double xx2 = rot.x * x2;
		double yy2 = rot.y * y2;
		double zz2 = rot.z * z2;
		m._11 = (1.0f - (yy2 + zz2)) * scale.x;
		m._22 = (1.0f - (xx2 + zz2)) * scale.y;
		m._33 = (1.0f - (xx2 + yy2)) * scale.z;
		double yz2 = rot.y * z2;
		double wx2 = rot.w * x2;
		m._32 = (yz2 - wx2) * scale.z;
		m._23 = (yz2 + wx2) * scale.y;
		double xy2 = rot.x * y2;
		double wz2 = rot.w * z2;
		m._21 = (xy2 - wz2) * scale.y;
		m._12 = (xy2 + wz2) * scale.x;
		double xz2 = rot.x * z2;
		double wy2 = rot.w * y2;
		m._31 = (xz2 + wy2) * scale.z;
		m._13 = (xz2 - wy2) * scale.x;
		m._14 = 0.0f;
		m._24 = 0.0f;
		m._34 = 0.0f;
		m._44 = 1.0f;
		return m;
	}
};

inline D3DMATRIX matrix_multiplication(const D3DMATRIX& pm1, const D3DMATRIX& pm2)
{
	D3DMATRIX pout{};
	pout._11 = pm1._11 * pm2._11 + pm1._12 * pm2._21 + pm1._13 * pm2._31 + pm1._14 * pm2._41;
	pout._12 = pm1._11 * pm2._12 + pm1._12 * pm2._22 + pm1._13 * pm2._32 + pm1._14 * pm2._42;
	pout._13 = pm1._11 * pm2._13 + pm1._12 * pm2._23 + pm1._13 * pm2._33 + pm1._14 * pm2._43;
	pout._14 = pm1._11 * pm2._14 + pm1._12 * pm2._24 + pm1._13 * pm2._34 + pm1._14 * pm2._44;
	pout._21 = pm1._21 * pm2._11 + pm1._22 * pm2._21 + pm1._23 * pm2._31 + pm1._24 * pm2._41;
	pout._22 = pm1._21 * pm2._12 + pm1._22 * pm2._22 + pm1._23 * pm2._32 + pm1._24 * pm2._42;
	pout._23 = pm1._21 * pm2._13 + pm1._22 * pm2._23 + pm1._23 * pm2._33 + pm1._24 * pm2._43;
	pout._24 = pm1._21 * pm2._14 + pm1._22 * pm2._24 + pm1._23 * pm2._34 + pm1._24 * pm2._44;
	pout._31 = pm1._31 * pm2._11 + pm1._32 * pm2._21 + pm1._33 * pm2._31 + pm1._34 * pm2._41;
	pout._32 = pm1._31 * pm2._12 + pm1._32 * pm2._22 + pm1._33 * pm2._32 + pm1._34 * pm2._42;
	pout._33 = pm1._31 * pm2._13 + pm1._32 * pm2._23 + pm1._33 * pm2._33 + pm1._34 * pm2._43;
	pout._34 = pm1._31 * pm2._14 + pm1._32 * pm2._24 + pm1._33 * pm2._34 + pm1._34 * pm2._44;
	pout._41 = pm1._41 * pm2._11 + pm1._42 * pm2._21 + pm1._43 * pm2._31 + pm1._44 * pm2._41;
	pout._42 = pm1._41 * pm2._12 + pm1._42 * pm2._22 + pm1._43 * pm2._32 + pm1._44 * pm2._42;
	pout._43 = pm1._41 * pm2._13 + pm1._42 * pm2._23 + pm1._43 * pm2._33 + pm1._44 * pm2._43;
	pout._44 = pm1._41 * pm2._14 + pm1._42 * pm2._24 + pm1._43 * pm2._34 + pm1._44 * pm2._44;
	return pout;
}

inline D3DMATRIX to_matrix(const Vector3& rot, const Vector3& origin = Vector3(0, 0, 0))
{
	double radpitch = (rot.x * M_PI / 180);
	double radyaw = (rot.y * M_PI / 180);
	double radroll = (rot.z * M_PI / 180);
	double sp = sinf(radpitch);
	double cp = cosf(radpitch);
	double sy = sinf(radyaw);
	double cy = cosf(radyaw);
	double sr = sinf(radroll);
	double cr = cosf(radroll);
	D3DMATRIX matrix{};
	matrix.m[0][0] = cp * cy;
	matrix.m[0][1] = cp * sy;
	matrix.m[0][2] = sp;
	matrix.m[0][3] = 0.f;
	matrix.m[1][0] = sr * sp * cy - cr * sy;
	matrix.m[1][1] = sr * sp * sy + cr * cy;
	matrix.m[1][2] = -sr * cp;
	matrix.m[1][3] = 0.f;
	matrix.m[2][0] = -(cr * sp * cy + sr * sy);
	matrix.m[2][1] = cy * sr - cr * sp * sy;
	matrix.m[2][2] = cr * cp;
	matrix.m[2][3] = 0.f;
	matrix.m[3][0] = origin.x;
	matrix.m[3][1] = origin.y;
	matrix.m[3][2] = origin.z;
	matrix.m[3][3] = 1.f;
	return matrix;
}

struct Camera
{
	Vector3 location;
	Vector3 rotation;
	float fov;
};

struct FRotator
{
	double pitch;
	double yaw;
	double roll;
};

struct FNRot
{
	double a;
	char pad_0008[24];
	double b;
	char pad_0028[424];
	double c;
};

struct MeshInfoContainer
{
	uintptr_t player_state{0};
	uintptr_t head_bone;
	FTransform cached_head_bone;
	uintptr_t component_to_world;
	FTransform cached_component_to_world;
	uintptr_t root_component;
	uintptr_t player_pawn;
};

inline bool is_valid(const uintptr_t address)
{
	if (address <= 0x400000 || address == 0xCCCCCCCCCCCCCCCC || address == 0 || address >
		0x7FFFFFFFFFFFFFFF)
	{
		return false;
	}

	return true;
}


namespace offsets
{
	inline int uworld = 0x126cf528;
	inline int uworld_to_pgamestate = 0x160;
	inline int gamestate_to_tpplayerstate_array = 0x2a8;
	inline int playerstate_to_ppawn = 0x308;
	inline int playerstate_to_isabot = 0x29a;
	inline int playerstate_to_teamid = 0x1211;
	inline int pawn_to_pmeshcomponent = 0x318;
	inline int pawn_to_controller = 0x2c8;
	inline int meshcomponent_to_bonearray = 0x5b0;
	inline int meshcomponent_to_componenttoworld = 0x1c0;
	inline int playercontroller_to_rotationinput = 0x520;
	inline int playercontroller_to_rotationinput2 = 0x810;
	inline int playercontroller_to_playerstate = 0x298;
	inline int playercontroller_to_pawn = 0x338;
	inline int pawn_to_isdying = 0x758;
	inline int pawn_to_isdbno = 0x982;
	inline int pawn_to_isattacking = 0x6987;
	inline int pawn_to_currentweapon = 0xa68;
	inline int pawn_to_rootcomponent = 0x198;
	inline int weapon_to_weapondata = 0x500;
	inline int weapondata_to_weaponname = 0x40;
	inline int weaponname_to_buf = 0x28;
	inline int component_to_velocity = 0x168;
}

namespace cache
{
	inline uintptr_t uworld;
	inline uintptr_t game_instance;
	inline uintptr_t local_players;
	inline uintptr_t player_controller;
	inline uintptr_t local_pawn;
	inline uintptr_t root_component;
	inline uintptr_t player_state;
	inline BYTE my_team_id;
	inline uintptr_t game_state;
	inline uintptr_t player_array;
	inline int player_count;
	inline double closest_distance;
	inline uintptr_t closest_mesh;
	inline MeshInfoContainer closest_mesh_info;
	inline Camera local_camera;
	inline std::vector<MeshInfoContainer> mesh_info;
	// Hashmap that maps player state to mesh info
	inline std::unordered_map<uintptr_t, MeshInfoContainer> mesh_info_map;
	// mesh_info cache to be used by aimbot thread
	inline std::vector<MeshInfoContainer> mesh_info_cache;
	inline std::vector<MeshInfoContainer> mesh_info_cache_copy;
	// Mutex for DMA memory read between threads
	inline std::mutex mem_mutex;
	inline VMMDLL_SCATTER_HANDLE camera_view_scatter_handle;
}

inline Camera get_view_point()
{
	Camera view_point{};
	uintptr_t location_pointer;
	uintptr_t rotation_pointer;
	mem.AddScatterReadRequest(cache::camera_view_scatter_handle, cache::uworld + 0x110, &location_pointer, sizeof(uintptr_t));
	mem.AddScatterReadRequest(cache::camera_view_scatter_handle, cache::uworld + 0x120, &rotation_pointer, sizeof(uintptr_t));
	mem.ExecuteReadScatter(cache::camera_view_scatter_handle);

	FNRot fnrot{};
	mem.AddScatterReadRequest(cache::camera_view_scatter_handle, rotation_pointer, &fnrot.a, sizeof(double));
	mem.AddScatterReadRequest(cache::camera_view_scatter_handle, rotation_pointer + 0x20, &fnrot.b, sizeof(double));
	mem.AddScatterReadRequest(cache::camera_view_scatter_handle, rotation_pointer + 0x1D0, &fnrot.c, sizeof(double));
	mem.ExecuteReadScatter(cache::camera_view_scatter_handle);

	float fov;
	mem.AddScatterReadRequest(cache::camera_view_scatter_handle, location_pointer, &view_point.location, sizeof(Vector3));
	mem.AddScatterReadRequest(cache::camera_view_scatter_handle, cache::player_controller + 0x394, &fov, sizeof(float));
	mem.ExecuteReadScatter(cache::camera_view_scatter_handle);
	view_point.rotation.x = asin(fnrot.c) * (180.0 / M_PI);
	view_point.rotation.y = ((atan2(fnrot.a * -1, fnrot.b) * (180.0 / M_PI)) * -1) * -1;
	view_point.fov = fov * 90.f;
	//EXEC_ON_DEBUG(std::cout << "Location: " << view_point.location.x << " " << view_point.location.y << " " << view_point.location.z << " " << view_point.fov << std::endl);

	return view_point;
}

inline Vector2 project_world_to_screen(const Vector3& world_location)
{
	cache::local_camera = get_view_point();
	D3DMATRIX temp_matrix = to_matrix(cache::local_camera.rotation);
	Vector3 vaxisx = Vector3(temp_matrix.m[0][0], temp_matrix.m[0][1], temp_matrix.m[0][2]);
	Vector3 vaxisy = Vector3(temp_matrix.m[1][0], temp_matrix.m[1][1], temp_matrix.m[1][2]);
	Vector3 vaxisz = Vector3(temp_matrix.m[2][0], temp_matrix.m[2][1], temp_matrix.m[2][2]);
	Vector3 vdelta = world_location - cache::local_camera.location;
	Vector3 vtransformed = Vector3(vdelta.dot(vaxisy), vdelta.dot(vaxisz), vdelta.dot(vaxisx));
	if (vtransformed.z < 1) vtransformed.z = 1;
	return { settings::screen_center_x + vtransformed.x * ((settings::screen_center_x / tanf(cache::local_camera.fov * M_PI / 360))) / vtransformed.z, settings::screen_center_y - vtransformed.y * ((settings::screen_center_x / tanf(cache::local_camera.fov * M_PI / 360))) / vtransformed.z };
}

inline Vector3 get_updated_viewpoint_location()
{
	uintptr_t location_pointer = mem.Read<uintptr_t>(cache::uworld + 0x110);
	return mem.Read<Vector3>(location_pointer);
}

inline Vector3 get_world_space_coords(const FTransform& head_bone, const FTransform& component_to_world)
{
	D3DMATRIX bone_matrix = matrix_multiplication(head_bone.to_matrix_with_scale(), component_to_world.to_matrix_with_scale());
	return { bone_matrix._41, bone_matrix._42, bone_matrix._43 };
}

struct CompareDistance
{
	bool operator()(const MeshInfoContainer& a, const MeshInfoContainer& b) const
	{
		// Distance from center screen
		Vector2 screen_center = { (double)settings::screen_center_x, (double)settings::screen_center_y };
		Vector3 world_space_a = get_world_space_coords(a.cached_head_bone, a.cached_component_to_world);
		Vector3 world_space_b = get_world_space_coords(b.cached_head_bone, b.cached_component_to_world);
		Vector2 a_screen = project_world_to_screen(world_space_a);
		Vector2 b_screen = project_world_to_screen(world_space_b);
		double world_space_distance_a = world_space_a.distance(cache::local_camera.location);
		double world_space_distance_b = world_space_b.distance(cache::local_camera.location);
		double a_distance = 0.699 * (a_screen - screen_center).x * (a_screen - screen_center).x + 0.699 * (a_screen - screen_center).y * (a_screen - screen_center).y + 0.301 * world_space_distance_a * world_space_distance_a;
		double b_distance = 0.699 * (b_screen - screen_center).x * (b_screen - screen_center).x + 0.699 * (b_screen - screen_center).y * (b_screen - screen_center).y + 0.301 * world_space_distance_b * world_space_distance_b;
		return a_distance < b_distance;
	}
};

inline uintptr_t get_all_player_meshes(int interval) {
	uintptr_t pgame_state = mem.Read<uintptr_t>(cache::uworld + offsets::uworld_to_pgamestate);
	uintptr_t player_state_tarray = pgame_state + offsets::gamestate_to_tpplayerstate_array;
	cache::player_array = player_state_tarray;

	// Set mesh_info capacity to 200
	cache::mesh_info.reserve(200);
	// Set mesh_info_cache capacity to 200
	cache::mesh_info_cache.reserve(200);
	// Set mesh_info_cache_copy capacity to 200
	cache::mesh_info_cache_copy.reserve(200);

	uintptr_t player_state_arr[200];
	auto scatter_handle = mem.CreateScatterHandle();

	while (true) {
		{
			try {

				// Measure performance
				auto start = std::chrono::high_resolution_clock::now();

				if (!is_valid(cache::player_array)) {
					uintptr_t pgame_state = mem.Read<uintptr_t>(cache::uworld + offsets::uworld_to_pgamestate);
					uintptr_t player_state_tarray = pgame_state + offsets::gamestate_to_tpplayerstate_array;
					cache::player_array = player_state_tarray;
				}

				int player_count = mem.Read<int>(cache::player_array + 0x8);
				cache::player_count = player_count;

				uintptr_t player_array_cursor = mem.Read<uintptr_t>(cache::player_array);
				if (!is_valid(player_array_cursor)) {
					continue;
				}

				cache::mesh_info.clear();

				mem.Read(player_array_cursor, player_state_arr, player_count * 0x8);

				// Update all mesh info for all player states in player_state_arr found in mesh_info, otherwise read mesh info from memory and add it to mesh_info
				for (int i = 0; i < player_count; i++) {
					// Lock mutex
					//std::lock_guard<std::mutex> lock(cache::mem_mutex);
					// 
					// Check if player state in player_state_arr is found in mesh_info_map
					/*if (cache::mesh_info_map.find(player_state_arr[i]) != cache::mesh_info_map.end()) {
						auto cached_mesh_info = cache::mesh_info_map[player_state_arr[i]];
						cached_mesh_info.cached_head_bone = mem.Read<FTransform>(cached_mesh_info.head_bone);
						cached_mesh_info.cached_component_to_world = mem.Read<FTransform>(cached_mesh_info.component_to_world);
						cache::mesh_info.push_back(cached_mesh_info);
						continue;
					}*/
					// Update mesh info for player state
					uintptr_t player_state = player_state_arr[i];
					if (!is_valid(player_state)) {
						continue;
					}
					BYTE player_team_id;
					uintptr_t player_pawn;
					BYTE is_bot;
					mem.AddScatterReadRequest(scatter_handle, player_state + offsets::playerstate_to_teamid, &player_team_id, sizeof(BYTE));
					mem.AddScatterReadRequest(scatter_handle, player_state + offsets::playerstate_to_ppawn, &player_pawn, sizeof(uintptr_t));
					mem.AddScatterReadRequest(scatter_handle, player_state + offsets::playerstate_to_isabot, &is_bot, sizeof(BYTE));
					mem.ExecuteReadScatter(scatter_handle);
					is_bot = is_bot >> 3 & 1;
					if (player_team_id == cache::my_team_id) {
						continue;
					}
					if (!is_valid(player_pawn)) {
						continue;
					}

					bool is_attacking_bot = false;
					if (is_bot) {
						is_attacking_bot = mem.Read<BYTE>(mem.ReadChain(player_state, { (UINT)offsets::playerstate_to_ppawn }) + offsets::pawn_to_isattacking) == 3;
					}
					if (is_bot && !is_attacking_bot) {
						continue;
					}

					uintptr_t player_controller;
					uintptr_t player_mesh_component;
					uintptr_t root_component;
					mem.AddScatterReadRequest(scatter_handle, player_pawn + offsets::pawn_to_controller, &player_controller, sizeof(uintptr_t));
					mem.AddScatterReadRequest(scatter_handle, player_pawn + offsets::pawn_to_pmeshcomponent, &player_mesh_component, sizeof(uintptr_t));
					mem.AddScatterReadRequest(scatter_handle, player_pawn + offsets::pawn_to_rootcomponent, &root_component, sizeof(uintptr_t));
					mem.ExecuteReadScatter(scatter_handle);
					if (!is_valid(player_mesh_component)) {
						continue;
					}
					// skip local player
					if (player_controller == cache::player_controller) {
						continue;
					}

					uintptr_t player_bone_array;
					uintptr_t player_bone_array_cache;
					uintptr_t component_to_world = player_mesh_component + offsets::meshcomponent_to_componenttoworld;

					mem.AddScatterReadRequest(scatter_handle, player_mesh_component + offsets::meshcomponent_to_bonearray, &player_bone_array, sizeof(uintptr_t));
					mem.AddScatterReadRequest(scatter_handle, player_mesh_component + offsets::meshcomponent_to_bonearray + 0x10, &player_bone_array_cache, sizeof(uintptr_t));
					mem.ExecuteReadScatter(scatter_handle);

					if (!is_valid(player_bone_array)) {
						player_bone_array = player_bone_array_cache;
						if (!is_valid(player_bone_array)) {
							continue;
						}
					}

					if (!is_valid(component_to_world)) {
						continue;
					}

					uintptr_t head_bone = player_bone_array + 0x60 * 110;

					FTransform head_transform;
					FTransform component_to_world_transform;
					mem.AddScatterReadRequest(scatter_handle, head_bone, &head_transform, sizeof(FTransform));
					mem.AddScatterReadRequest(scatter_handle, component_to_world, &component_to_world_transform, sizeof(FTransform));
					mem.ExecuteReadScatter(scatter_handle);

					cache::mesh_info.push_back({ player_state, head_bone, head_transform, component_to_world, component_to_world_transform, root_component, player_pawn });
					//cache::mesh_info_map[player_state] = { player_state, head_bone, head_transform, component_to_world, component_to_world_transform };
				}


				//// Update camera location
				//cache::local_camera.location = get_updated_viewpoint_location();
				// Sort by distance
				//cache::mesh_info_cache_copy = cache::mesh_info;

				std::ranges::sort(cache::mesh_info, CompareDistance());
				{
					// Lock mutex
					std::lock_guard lock(cache::mem_mutex);
					// Recreate mesh_info_cache
					cache::mesh_info_cache.clear();
					int numElementsToCopy = min(static_cast<int>(cache::mesh_info.size()), 5);
					EXEC_ON_ARG(std::cout << "Num elements to copy: " << numElementsToCopy << '\n', false);
					std::copy_n(cache::mesh_info.begin(), numElementsToCopy, std::back_inserter(cache::mesh_info_cache));
				}


				// Print performance
				auto end = std::chrono::high_resolution_clock::now();
				std::chrono::duration<double> elapsed = end - start;
				EXEC_ON_DEBUG(std::cout << "Time to read all player meshes: " << elapsed.count() << "s" << '\n');
			}
			catch (std::exception& e) {
				EXEC_ON_DEBUG(std::cout << "Error reading player meshes: " << e.what() << '\n');
			}
		}

		std::this_thread::sleep_for(std::chrono::milliseconds(interval));
		// Sleep(interval);
	}
}

inline Vector3 predict_location(Vector3 target, const Vector3& target_velocity, float projectile_speed,
                                float projectile_gravity_scale, float distance)
{
	if (projectile_speed == 0)
	{
		return target;
	}
	float horizontalTime = distance / projectile_speed;
	float verticalTime = distance / projectile_speed;

	//std::cout << "Horizontal time: " << horizontalTime << std::endl;
	//std::cout << "Vertical time: " << verticalTime << std::endl;

	target.x += target_velocity.x * horizontalTime;
	target.y += target_velocity.y * horizontalTime;
	target.z += target_velocity.z * verticalTime +
		abs(-980 * projectile_gravity_scale) * 0.5f * (verticalTime * verticalTime);

	return target;
}

inline std::unique_ptr<wchar_t[]> get_weapon_name() {
	uintptr_t current_weapon = mem.Read<uintptr_t>(cache::local_pawn + offsets::pawn_to_currentweapon);
	if (!is_valid(current_weapon)) {
		return nullptr;
	}

	uintptr_t weapon_data = mem.Read<uintptr_t>(current_weapon + offsets::weapon_to_weapondata);
	if (!is_valid(weapon_data)) {
		return nullptr;
	}

	uintptr_t weapon_text_data = mem.Read<uintptr_t>(weapon_data + offsets::weapondata_to_weaponname);
	if (!is_valid(weapon_text_data)) {
		return nullptr;
	}

	uintptr_t weapon_name_buffer = mem.Read<uintptr_t>(weapon_text_data + offsets::weaponname_to_buf);
	if (!is_valid(weapon_name_buffer)) {
		return nullptr;
	}
	UINT weapon_name_length = mem.Read<UINT>(weapon_text_data + offsets::weaponname_to_buf + 0x8);
	if (weapon_name_length == 0 || weapon_name_length > 50) {
		return nullptr;
	}

	std::unique_ptr<wchar_t[]> weapon_name = std::make_unique<wchar_t[]>(weapon_name_length + 1);
	mem.Read(weapon_name_buffer, weapon_name.get(), weapon_name_length * sizeof(wchar_t));
	weapon_name[weapon_name_length] = L'\0';
	return weapon_name;
}
```

`FortniteDma/Weapons.hpp`:

```hpp
#pragma once
#include <map>
#include <string>

// Fortnite Weapon Data
namespace projectile_stats
{
	inline float projectile_speed = 0;
	inline float gravity_scale = 0;
}

struct weapon_projectile_data
{
	float speed;
	float gravity_scale;
};

// Map weapon names to projectile data
static std::map<std::wstring, weapon_projectile_data> weapon_projectile_map = {
	{L"Default", {0.0f, 0.0f}},
	{L"Rifle", {0.0f, 0.0f}},
	{L"Tactical Assault Rifle", {80000.0f, 3.5f}},
	{L"Striker AR", {80000.0f, 3.5f}},
	{L"Nemesis AR", {80000.0f, 3.5f}},
	{L"Huntress DMR", {96000.0f, 2.5f}},
	{L"Harbinger SMG", {70000.0f, 3.0f}},
	{L"Hades' Harbinger SMG", {70000.0f, 3.0f}},
	{L"Thunder Burst SMG", {70000.0f, 3.0f}},
	{L"Warforged Assault Rifle", {80000.0f, 3.5f}},
	{L"Ares' Warforged Assault Rifle", {80000.0f, 3.5f}},
	{L"Reaper Sniper Rifle", {50000.0f, 3.5f}},
	{L"Drum Gun", {75000.0f, 3.0f}},
	{L"Midas Drum Gun", {75000.0f, 3.0f}},
};

```

`README.md`:

```md
# fn-dma-cheat
```