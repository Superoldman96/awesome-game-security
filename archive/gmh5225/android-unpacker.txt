Project Path: arc_gmh5225_android-unpacker_bs2n49x3

Source Tree:

```txt
arc_gmh5225_android-unpacker_bs2n49x3
├── AHPL0.pdf
├── LICENSE.txt
├── README.md
├── corellium-android-unpacking
├── gdb-scripts
│   ├── README.md
│   ├── playdead.sh
│   └── playnice.sh
├── hide-emu
│   ├── Android.mk
│   ├── Makefile
│   ├── README.md
│   └── hide.c
└── native-unpacker
    ├── Android.mk
    ├── Makefile
    ├── README.md
    ├── definitions.h
    ├── kisskiss.c
    └── kisskiss.h

```

`LICENSE.txt`:

```txt

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`README.md`:

```md
android-unpacker
================

Android Unpacker presented at Defcon 22: Android Hacker Protection Level 0

Contents
--------

 - AHPL0 - Android Hacker Protection Level 0 + some blackphone stuff slides
 - gdb-scripts/ - Bash script for unpacking bangcle/secshell; requires gdb/adb
 - native-unpacker/ - Unpacker for APKProtect/Bangcle/LIAPP/Qihoo Packer that runs natively, no dependency on gdb
 - hide-qemu/ - Small hacks for hiding the qemu/debuggers, specifically from APKProtect
 - corellium-android-unpacking/ - A more realistic approach to unpacking things, dynamically and with automation around it

Disclaimer
----------

This presentation and code are meant for education and research purposes only. Do as you please with it, but accept any and all responsibility for your actions. The tools were created specifically to assist in malware reversing and analysis - be careful.

License
-------

    Copyright 2014-2020 Tim 'diff' Strazzere <diff@protonmail.com>

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

```

`gdb-scripts/README.md`:

```md
Generic gdb unpacking scripts
=============
Assumptions made:
- there is only one device running for adb to connect to (target device)
- folder named framework/ is full of /system/framework/ files from target device
- target device have root access (emulator is best and verified)
- target apk is installed
- target apk is currently running
- baksmali and smali are located in ~/bin/*
- gdb binary is pushed to /data/local/tmp/

Playdead - Bangcle unpacking script
--------
Works on a year+ old sample and one found as recenty as today (7/16/04)
Older samples may require a 4.3 or lower device, new samples appear to work on 4.4 well

**Usage:**

1. Ensure you have the gdb binary pushed to /data/local/tmp/ and the baksmali/smali and frameworks set up like the scripts references (or change the script).
Also ensure you only have one device connected and accessable to adb.
The application you wish to unpack should be installed and running.
<pre>
$ ./playdead.sh com.package.name.to.unpack
</pre>

2. Reverse!

This isn't really a good script, or the best way. Though I wanted to ensure people might have a decent example of getting this type of scripting/unpacking type working.


Playnice - Secshell unpacking script
--------
Works almost identically to playdead with similar assumptions,
but scans for a DEX header instead of ODEX, and uses gdb find instead of examine.

**Usage:**

<pre>
$ ./playnice.sh com.package.name.to.unpack
</pre>

```

`gdb-scripts/playdead.sh`:

```sh
#!/bin/bash
#
# Playdead - Bangcle generic unpacking script
#
# Tim 'diff' Strazzere <strazz@gmail.com>
#
# Assumptions made:
#  - there is only one device running for adb to connect to (target device)
#  - folder named framework/ is full of /system/framework/ files from target device
#  - target device have root access (emulator is best and verified)
#  - target apk is installed
#  - target apk is currently running
#  - baksmali and smali are located in ~/bin/*
#
# Works on a year+ old sample and one found as recenty as today (7/16/04)
# Older samples may require a 4.3 or lower device, new samples appear to work on
# 4.4 well
#

PACKAGE=$1
ODEX_MAGIC='dey\n036'
SERVICE_PID=`adb shell ps | grep $PACKAGE | head -1 | tr -s ' ' | cut -d ' ' -f 2`

get_memory_address() {
    last_line=''
    CLONE=$(get_clone)

    adb shell su -c cat /proc/$SERVICE_PID/maps | while read line
    do
	if [[ $line != */* ]]
	then
	    MEM_LINE=$line
            MEM_LINE=`echo -n $MEM_LINE | cut -c1-17`
            MEMORY_START=`echo -n $MEM_LINE | cut -d'-' -f1`
            PEEKED=$(peek_memory)

            # Found a candidate
            if [[ "$PEEKED" = "$ODEX_MAGIC" ]]
            then
		echo `echo -n $MEM_LINE`
		break
	    fi
	fi
    done
}

get_clone() {
    retained_return=$(adb shell ls /proc/$SERVICE_PID/task/ | tail -1)
    echo ${retained_return}
}

dump_memory() {
    echo $(adb shell su -c /data/local/tmp/gdb --batch --pid $CLONE -ex "dump memory /data/local/tmp/dump.odex 0x$MEMORY_START 0x$MEMORY_END")
}

peek_memory() {
    echo $(adb shell su -c /data/local/tmp/gdb --batch --pid $CLONE -ex "x/s 0x$MEMORY_START" | cut -d'"' -f2 | cut -c1-8 | tail -1)
}

if [[ $SERVICE_PID != '' ]]
then
    echo "Attempting to find memory address for $PACKAGE inside $SERVICE_PID"
    MEM_LINE=$(get_memory_address)

    if [[ $MEM_LINE ]]
    then
	echo "Found optimized dex at $MEM_LINE"
	MEMORY_START=`echo -n $MEM_LINE | cut -d'-' -f1`
	MEMORY_END=`echo -n $MEM_LINE | cut -d'-' -f2`
	CLONE=$(get_clone)
	if [[ $CLONE ]]
	then
	    echo "Got clone $CLONE attempting to dump memory from 0x$MEMORY_START to 0x$MEMORY_END"
	    blah=$(dump_memory)
	    if [[ $blah ]]
	    then
		echo "Pulling dumped file..."
		adb pull /data/local/tmp/dump.odex
		adb shell rm /data/local/tmp/dump.odex
		echo "Deodexing..."
		java -jar ~/bin/baksmali-2.0.3.jar -x dump.odex -d framework/ -o temp-smali
		echo "Re-dexing..."
		java -jar ~/bin/smali-2.0.3.jar temp-smali -o debangcled.dex
		echo "Cleaning up..."
		rm -rf temp-smali/ dump.odex
	    fi
	fi
    else
	echo 'Unable to find memory region to dump!'
    fi
else
    echo "Unable to find pid for $PACKAGE"
fi

```

`gdb-scripts/playnice.sh`:

```sh
#!/bin/bash
#
# Playnice - SecShell generic unpacking script
#
# Dwayne Yuen
#
# Functions almost identically to the playdead bangcle unpacker, with some minor differences
# - searches for a dex header instead of odex
# - uses gdb find to find the dex header
#
# Requires gdb to be in /data/local/tmp
#

PACKAGE=$1
DEX_MAGIC='dex\n035'
FOUND_STR='pattern found.'
SERVICE_PID=`adb shell "ps" | grep $PACKAGE | head -1 | tr -s ' ' | cut -d ' ' -f 2`
SAVEIFS=$IFS
IFS=$(echo -en "\n\b")

if [[ $SERVICE_PID != '' ]]
then
    echo "Attempting to find memory address for $PACKAGE inside $SERVICE_PID"
    CLONE=$(adb shell su -c "ls /proc/$SERVICE_PID/task/" | tail -1 | tr -d "\r")
    echo "Found clone pid at $CLONE"

    for line in $(adb shell su -c "cat /proc/$CLONE/maps"); do
	if [[ $line != */* ]]
	then
	    MEM_LINE=$line
            MEM_LINE=`echo -n $MEM_LINE | cut -c1-17`
            MEMORY_START=`echo -n $MEM_LINE | cut -d'-' -f1`
            MEMORY_END=`echo -n $MEM_LINE | cut -d'-' -f2`

            echo "Searching 0x$MEMORY_START - 0x$MEMORY_END for \"$DEX_MAGIC\""
            FOUND=($(adb shell su -c "/data/local/tmp/gdb --batch --pid $CLONE -ex 'find 0x$MEMORY_START, 0x$MEMORY_END, \"$DEX_MAGIC\"'" | tail -2))

            # Search for "pattern found"
            echo ${FOUND[1]} | grep -q $FOUND_STR
            if [[ $? -eq 0 ]]; then
		DEX_START=$(echo ${FOUND[0]} | tr -d "\r")
		break
            fi
	fi
    done


    if [ -n "$DEX_START" ]
    then
	    echo "Found dex at $DEX_START"
	    if [ -n "$CLONE" ]
	    then
	        echo "Got clone $CLONE attempting to dump memory from $DEX_START to 0x$MEMORY_END"
	        blah=$(adb shell su -c "/data/local/tmp/gdb --batch --pid $CLONE -ex 'dump memory /data/local/tmp/dump.dex $DEX_START 0x$MEMORY_END'")
	        if [[ $blah ]]
	        then
		        echo "Pulling dumped file..."
		        adb pull /data/local/tmp/dump.dex
		        adb shell rm /data/local/tmp/dump.dex
	        fi
	    fi
    else
	    echo 'Unable to find memory region to dump!'
    fi
else
    echo "Unable to find pid for $PACKAGE"
fi

IFS=$SAVEIFS

```

`hide-emu/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

LOCAL_LDLIBS := -llog

LOCAL_SRC_FILES := \
  hide.c
LOCAL_C_INCLUDE := $(SYSROOT)/usr/include/

LOCAL_MODULE := hide
LOCAL_MODULE_TAGS := optional

include $(BUILD_SHARED_LIBRARY)

include $(call all-makefiles-under,$(LOCAL_PATH))

```

`hide-emu/Makefile`:

```
LOCAL_ARM_MODE := arm

all:
	ndk-build NDK_PROJECT_PATH=. APP_BUILD_SCRIPT=./Android.mk 

install:
	adb push libs/armeabi/libhide.so /data/local/tmp/libhide.so

clean:
	rm -rf libs/
	rm -rf obj/
	rm *~

```

`hide-emu/README.md`:

```md
StupidQemuHide
=============

Very basic ld_preload hack to circumvent the anti-qemud detection in APKProtect

**Usage:**

1. Compile: (Assumes ndk-build and $SYSROOT are properly set)
<pre>
      $ make
</pre>

2. Push to the device
<pre>
      $ make install
</pre>

2. preload the library and run the command you want to hook:
<pre>
      $adb shell
      #setprop wrap.%PACKAGE_NAME% LD_PRELOAD=/data/local/tmp/libhide.so
</pre>

Run the APK, it should now be wrapped - though it will be much more slow since this is a bad hack.

```

`hide-emu/hide.c`:

```c
/*
 * stupid hide qemu ld_preload hack for APKProtect
 *
 * Tim "diff" Strazzere <strazz@gmail.com>
 *
 * Likely took a some of code from @pof :)
 *   https://github.com/poliva/ldpreloadhook
 */

#include <stdlib.h>
#include <dlfcn.h>
#include <android/log.h>

#define LOG_TAG "StupidHideQemu"
#define LOGD(...)  __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)
#define DPRINTF(...)  __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)

static void _libhook_init() __attribute__ ((constructor));
static void _libhook_init() {   
  LOGD("[] Hooking!\n");
}

size_t strlen(const char* s) {

  static size_t (*func_strlen) (const char *) = NULL;
  int retval = 0;

  if(! func_strlen)
    func_strlen = (size_t (*) (const char*)) dlsym (RTLD_NEXT, "strlen");

  if(strcmp(s, "/system/bin/qemud") == 0) {
    LOGD("[] Caught apkprotect checking for the qemu");
    return 1;
  }

  return func_strlen(s);
}

```

`native-unpacker/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)

TARGET_PIE := true
NDK_APP_PIE := true

include $(CLEAR_VARS)

LOCAL_SRC_FILES := \
  kisskiss.c
LOCAL_C_INCLUDE := \
  kisskiss.h \
  definitions.h

LOCAL_MODULE := kisskiss
LOCAL_MODULE_TAGS := optional

# Allow execution on android-16+
LOCAL_CFLAGS += -fPIE
LOCAL_LDFLAGS += -fPIE -pie

include $(BUILD_EXECUTABLE)

include $(call all-makefiles-under,$(LOCAL_PATH))

```

`native-unpacker/Makefile`:

```
LOCAL_ARM_MODE := arm
abi?=x86_64

all: check build

check:
ifeq (, $(shell which ndk-build))
        $(error "No 'ndk-build' in PATH, please install Android NDK and configure properly")
endif

build:
	ndk-build NDK_PROJECT_PATH=. APP_BUILD_SCRIPT=./Android.mk

install:
	adb push libs/$(abi)/kisskiss /data/local/tmp/

clean:
	rm -rf *.c~
	rm -rf *.h~
	rm -rf obj/

```

`native-unpacker/README.md`:

```md
Kisskiss - Unpacker for various Android packers/protectors
=============

Basic example of an easy unpacker for Android. Heavily commented so hopefully people can understand the flow and thinking behind the hacks going on.

Currently supports:
 - Bangcle (SecNeo)
 - APKProtect
 - LIAPP (prerelease demo)
 - Qihoo Android Packers
 - Jaigu

This _should_ work on ARM and x86 devices. Please note that ptrace can and often is disabled or messed up on newer SELinux devices. You should either use a device/emulator which does not have SELinux enabled or disable it prior to ruinning this.

**Compiling:**

The only prerequisite for the unpacker to build is to have the Android NDK [installed](https://developer.android.com/ndk/guides/setup.html#install).

**Usage:**

1. Compile: (Assumes the NDK was properly installed and `PATH` variable updated, see link above)
<pre>
      $ make
</pre>

2. Push to the device
<pre>
      $ make install abi={armeabi-v7a, arm64-v8a, x86, x86_64}
</pre>

2. Run the APK to unpack and then run the unpacker
<pre>
      $adb shell ./data/local/tmp/kisskiss com.package.name.to.unpack
</pre>

Follow the outputs instructions and pull the odex, deodex as needed and enjoy reversing!

```

`native-unpacker/definitions.h`:

```h
/*
 * Header file for the definitions of packers/protectors
 *
 * Tim "diff" Strazzere <strazz@gmail.com>
 */

typedef struct {
  char* name;
  char* description;
  char* filter;
  char* marker;
} packer;

static packer packers[] = {

  // APKProtect
  {
    "APKProtect v1->5",
    "APKProtect generialized detection",
    // This is actually the filter APKProtect uses itself for finding it's own odex to modify
    ".apk@",
    "/libAPKProtect"
  },

  // Bangcle (??) or something equally silly
  {
    "Bangcle (?) silly version",
    "Something silly used by malware",
    "/app_lib/classes.dex",
    "/app_lib/"
  },

  {
    "Bangle SGMain version",
    "A seemingly one off of Bangcle (SecNeo)",
    "/libsgmain_",
    "/libsgmain.so"
  },

  /*
  // Jaigu
  {
    "Jaigu",
    "Jaigu generic unpacker",
    "/.jiagu/libjiagu.so",
    // Always after the last dalvik cache
  },
  */

  // LIAPP
  {
    "LIAPP 'Egg' (v1->?)",
    "LockIn APP (lockincomp.com)",
    "LIAPPEgg.dex",
    "/LIAPPEgg"
  },

  // Qihoo 'Monster'
  {
    "Qihoo 'Monster' (v1->?)",
    "Qihoo unknown version, code named 'monster'",
    "monster.dex",
    "/libprotectClass"
  }
};

```

`native-unpacker/kisskiss.c`:

```c
/*
 * Unpacker for various Android packers/protectors
 *
 * Tim 'diff' Strazzere <strazz@gmail.com>
 *"
 * For education use only - find them malwares
 *
 *
 * Tested against malware packed with the following;
 *     - Bangcle (All versions)
 *     - APKProtect (native versions w/ crypto)
 *     - LIAPP (prereleased demo)
 *     - Qihoo Packer
 *     - Jiagu
 *
 *
 * This will dump the dex or optimized dex (odex) files from
 * the system, meaning you will have to pull the
 * framework files to be able to deodex (in needed)
 * for the original dex file.
 *
 * For APKProtect, it should be combined with the
 * LD_PRELOAD hook'er to avoid the QEMU detection
 * if running on an emulator
 */

#include "kisskiss.h"

int main(int argc, char *argv[]) {

  printf("[*] Android Dalvik Unpacker/Unprotector - <strazz@gmail.com>\n");

  if(argc <= 0) {
    printf(" [!] Nothing to unpack, quitting\n");
    return 0;
  }

  if(getuid() != 0) {
    printf(" [!] Not root, quitting\n");
    return -1;
  }

  char *package_name = argv[1];
  printf(" [+] Hunting for %s\n", package_name);

  uint32_t pid = get_process_pid(package_name);
  if(pid <= 0) {
    printf(" [!] Process could not be found!\n");
    return -1;
  }
  printf(" [+] %d is service pid\n", pid);

  uint32_t tracer = checkTracer(pid);

  uint32_t clone_pid = get_clone_pid(pid);
  if(clone_pid <= 0) {
    printf(" [!] A suitable clone process could not be found!");
    return -1;
  }
  printf(" [+] %d is clone pid\n", clone_pid);

  uint32_t clone_tracer = checkTracer(clone_pid);

  int mem_file = attach_get_memory(clone_pid);
  if(mem_file == -1) {
    perror(" [!] An error occurred attaching and finding the memory ");
    return -1;
  }

  // Determine if we are dealing with APKProtect or Bangcle
  packer *found_packer = determine_packer(clone_pid, mem_file);
  if(found_packer == NULL) {
    printf("  [*] No packer found on clone_pid %d, falling back to service_pid %d\n", clone_pid, pid);
    mem_file = attach_get_memory(pid);
    if(mem_file == -1) {
      perror(" [!] An error occurred attaching and finding the memory ");
      return -1;
    }

    found_packer = determine_packer(pid, mem_file);
  }
  if(found_packer != NULL && strcmp(found_packer->name, "Bangle Test") == 0) {
    printf("  [+] Since filter is Bangle Test, switching to look at the pid attached to service_pid, %d\n", tracer);
    clone_pid = tracer;
    mem_file = attach_get_memory(clone_pid);
    if(mem_file == -1) {
      perror(" [!] An error occurred attaching and finding the memory ");
      return -1;
    }
  }

  char *filter = NULL;
  if(found_packer != NULL) {
    filter = found_packer->filter;
  }

  memory_region *memory[128] = { 0, 0 };
  int found = find_magic_memory(clone_pid, mem_file, memory, filter);
  if(found <= 0) {
    printf(" [!] Something unexpected happened, new version of packer/protectors? Or it wasn't packed/protected!\n");
    return -1;
  }

  char class_path[strlen(package_name)];
  strncpy(class_path, package_name, strlen(package_name) + 1);
  replaceAll(class_path, (char) '.', (char) '/');

  printf(" [+] Found %d potentially interesting memory locations...\n", found);
  int output = 0;
  for(int i = 0; i < found; i++) {
    // Build a safe file to dump to and call the memory dumping function
    char *dumped_file_name = malloc(strlen(static_safe_location) + strlen(package_name) + strlen(suffix) + 1 /* _ */ + (found == 0 ? 1 : (int) (log10(found) + 1) + 1));
    sprintf(dumped_file_name, "%s%s%s_%d", static_safe_location, package_name, suffix, output);
    int result = dump_memory(class_path, mem_file, memory[i], dumped_file_name, (found_packer != NULL));
    if(result < 0) {
      perror(" [!] An issue occurred trying to dump the memory to a file ");
      return -1;
    } else if(result == 0) {
      // Potential system dex file
    } else {
      printf(" [+] Unpacked/protected file dumped to : %s\n", dumped_file_name);
      output++;
    }
  }
  close(mem_file);
  ptrace(PTRACE_DETACH, clone_pid, NULL, 0);
  return 1;
}

uint32_t checkTracer(uint32_t pid) {
  char status[1024];
  snprintf(status, sizeof(status), "/proc/%u/status", pid);
  FILE *status_file = NULL;

  if((status_file = fopen(status, "r")) == NULL) {
    perror("  [!] Unable to check status of pid ");
    return -1;
  }

  char key[1024];
  uint32_t value;
  uint32_t tracerpid = 0;
  while(fscanf(status_file, "%s\t%u\n", key, &value) >= 0) {
    if(strcmp(key, "TracerPid:") == 0 && value != 0) {
      printf("  [*] Warning, process %u seems to be traced by %d, likely an anti-debug trick!\n", pid, value);
      tracerpid = value;
    }
  }

  fclose(status_file);
  return tracerpid;
}

void replaceAll(char* str, char oldChar, char newChar) {
    int i = 0;
    while(str[i] != '\0') {
        if(str[i] == oldChar)
            str[i] = newChar;
        i++;
    }
}

int checkFd(int fd) {
  return fcntl(fd, F_GETFD) != -1 || errno != EBADF;
}

/*
 * Since most of these tools provide "anti-debugging" features using ptrace,
 * we are going to take advantage of the Android app lifecycle and just steal
 * the memory form a cloned process which is never ptraced.
 *
 * This function will simply recurse through the given pids /proc/pid/task/
 * directory and collect the last one, which has always worked in tests done.
 */
uint32_t get_clone_pid(uint32_t service_pid) {
  DIR *service_pid_dir;
  char service_pid_directory[1024];
  sprintf(service_pid_directory, "/proc/%d/task/", service_pid);

  if((service_pid_dir = opendir(service_pid_directory)) == NULL)
    return -1;

  struct dirent* directory_entry = NULL;
  struct dirent* last_entry = NULL;
  while((directory_entry = readdir(service_pid_dir)) != NULL) {
    last_entry = directory_entry;
  }

  if(last_entry == NULL)
    return -1;

  closedir(service_pid_dir);
  return atoi(last_entry->d_name);
}

/*
 * Using a known package name, recurse through the /proc/pid
 * directory and look at the cmdline for the package name, this
 * should give us the "parent" pid for any package we are looking
 * for, which is then referenced as "service_id"
 */
uint32_t get_process_pid(const char *target_package_name) {
  char self_pid[10];
  sprintf(self_pid, "%u", getpid());

  DIR *proc = NULL;

  if((proc = opendir("/proc")) == NULL)
    return -1;

  struct dirent *directory_entry = NULL;
  while((directory_entry = readdir(proc)) != NULL) {

    if (directory_entry == NULL)
      return -1;

    // We don't care if it's self or our own pid
    if (strcmp(directory_entry->d_name, "self") == 0 ||
	strcmp(directory_entry->d_name, self_pid) == 0)
      continue;

      char cmdline[1024];
      snprintf(cmdline, sizeof(cmdline), "/proc/%s/cmdline", directory_entry->d_name);
      FILE *cmdline_file = NULL;
      // Attempt to iterate to next one if failed...
      if((cmdline_file = fopen(cmdline, "r")) == NULL)
	continue;

      char process_name[1024];
      fscanf(cmdline_file, "%s", process_name);

      fclose(cmdline_file);

      if(strcmp(process_name, target_package_name) == 0) {
	closedir(proc);
	return atoi(directory_entry->d_name);
      }
    }

  closedir(proc);
  return -1;
}

/*
 * Extremely weak filtering process, looks for known shared libs
 * that are mapped to memory.
 */
packer *determine_packer(uint32_t clone_pid, int memory_fd) {
  char maps[1024];
  snprintf(maps, sizeof(maps), "/proc/%d/maps", clone_pid);

  printf(" [+] Attempting to detect packer/protector...\n");

  FILE *maps_file = NULL;
  if((maps_file = fopen(maps, "r")) == NULL)
    return NULL;

  // Scan the /proc/pid/maps file and currently hardcoded shared lib names
  char mem_line[1024];
  while(fscanf(maps_file, "%[^\n]\n", mem_line) >= 0) {
    // Iterate through all markers to find proper filter
    int i;
    for(i = 0; i < sizeof(packers) / sizeof(packers[0]); i++) {
      if(strstr(mem_line, packers[i].marker) != NULL) {
	printf("  [*] Found %s\n", packers[i].name);
	return &packers[i];
      }
    }
  }
  printf("  [*] Nothing special found, hunting for all dex and odex magic bytes...\n");

  return NULL;
}

/*
 * Find the "magic" memory location we want, usually an odex so we are currently
 * recursing through the /proc/pid/maps and peeopling at memory locations using
 * the peek_memory function.
 *
 * returns number of interesting memory locations found
 */
int find_magic_memory(uint32_t clone_pid, int memory_fd, memory_region *memory[], char *extra_filter) {
  char maps[1024];
  snprintf(maps, sizeof(maps), "/proc/%d/maps", clone_pid);

  FILE *maps_file = NULL;
  if((maps_file = fopen(maps, "r")) == NULL)
    return -1;

  // Scan the /proc/pid/maps file and find possible memory of interest
  // Currently this loops until we find the /last/ odex file which is usually correct
  char mem_line[1024];
  int found = 0;
  while(fscanf(maps_file, "%[^\n]\n", mem_line) >= 0) {

    // For APKProtect we want the odex file that is mapped to memory
    // so we are looking for an extra_filter match on the odex
    if(extra_filter != NULL && strstr(mem_line, extra_filter) == NULL) {
      continue;
    }

    // Otherwise we are looking for the location that bangcle allocates the odex to,
    // this is a very ugly way to just try and get the directly mapped meory
    if(extra_filter == NULL && (strstr(mem_line, "/") != NULL || strstr(mem_line, "[") != NULL))
      continue;

    char mem_address_start[10];
    char mem_address_end[10];
    sscanf(mem_line, "%8[^-]-%8[^ ]", mem_address_start, mem_address_end);

    uint64_t mem_start = strtoul(mem_address_start, NULL, 16);

    // Peek and see if the memory is what we wanted
    off64_t offset = peek_memory(memory_fd, mem_start);
    // If we had a filter and didn't find a dex or odex, just return it anyway
    // This allows us to return non-dex file things (like an apk, jar or zip)
    if(extra_filter != NULL && offset < 0)
      offset = 0;

    if(offset >= 0) {
      // Found a magic
      memory[found] = malloc(sizeof(memory_region));
      memory[found]->start = mem_start + offset;
      memory[found++]->end = strtoull(mem_address_end, NULL, 16);
    } else if(offset == -99) {
      // No offset found
    } else {
      perror(" [!] Error peeking at memory ");
    }
  }

  fclose(maps_file);
  return found;
}

// Just peek at the memory to see if it contains an odex we want
// return value is the offset into memory of magic being found
off64_t peek_memory(int memory_file, uint64_t address) {
  char buffer[8];

  int read = pread64(memory_file, buffer, 8, address);
  if(read < 0) {
    fprintf(stderr, "  [!] pread seems to have failed at 0x%llx\n", address);
    return -1;
  }

  if(read != 8) {
    return -1;
  }
  // We are currently just dumping odex or jar files, letting the packers/protectors do all
  // the heavy lifting for us
  char* result = strstr(buffer, dex_magic);
  if(result != NULL)
    return result - buffer;

  result = strstr(buffer, odex_magic);
  if(result != NULL)
    return result - buffer;

  return -99;
}

/*
 * Dump a given memory location via a file descriptor, "memory_region"
 * and a given file_name for output.
 */
int dump_memory(char* class_path, int memory_fd, memory_region *memory, const char *file_name, int ignore_class_path) {
  int ret = 0;
  char *buffer = malloc(memory->end - memory->start);

  printf(" [+] Attempting to search inside memory region 0x%llx to 0x%llx\n", memory->start, memory->end);

  if(checkFd < 0) {
    perror("  [!] Appears to be an issue with memory fd ");
    return -1;
  }

  ssize_t read = pread64(memory_fd, buffer, (size_t)(memory->end - memory->start), (off64_t)(memory->start));
  if(read < 0) {
    fprintf(stderr, "  [!] pread seems to have failed for 0x%llx to 0x%llx\n", memory->start, memory->end);
    return -1;
  }

  if((memory->end - memory->start) != read) {
    printf("  [!] pread did not read the expected amount of memory!\n");
    return -1;
  }

  off64_t *contained_offset = memmem(buffer, (size_t)(memory->end - memory->start), class_path, strlen(class_path));

  FILE *dump = NULL;

  if(contained_offset != NULL || ignore_class_path == 1) {
    if(contained_offset != NULL)
      printf("  [+] Memory region 0x%llx to 0x%llx contained anticipated class path %s\n", memory->start, memory->end, class_path);

    FILE *dump = fopen(file_name, "wb");
    ret = -1;
    if(dump != NULL) {
      if(fwrite(buffer, memory->end - memory->start, 1, dump) > 0) {
	ret = 1;
      }

      fclose(dump);
    } else {
      perror("  [!] Error opening a file to write ");
    }
  } else {
    printf("  [-] Likely a system file found, ignoring...\n");
    ret = 0;
  }

  free(buffer);
  return ret;
}

// Perform all that ptrace magic
int attach_get_memory(uint32_t pid) {
  char mem[1024];
  snprintf(mem, sizeof(mem), "/proc/%d/mem", pid);

  // Attach to process so we can peek/dump
  if (0 != ptrace(PTRACE_ATTACH, pid, NULL, NULL))
    return -1;

  // Get the mem file so we can read when we want too
  int mem_file;
  if(!(mem_file = open(mem, O_RDONLY)))
    return -1;

  return mem_file;
}

```

`native-unpacker/kisskiss.h`:

```h
/*
 * kisskiss.h
 *
 * Tim "diff" Strazzere <strazz@gmail.com>
 */

#include "definitions.h"

#include <stdlib.h>
#include <stdio.h>
#include <sys/ptrace.h>
#include <dirent.h>
#include <fcntl.h> // open / O_RDONLY
#include <unistd.h> // close
#include <errno.h> // perror
#include <string.h> // strlen
#include <math.h> // log10

static const char* dex_magic = "dex\n0";
static const char* odex_magic = "dey\n036";
static const char* static_safe_location = "/data/local/tmp/";
static const char* suffix = ".dumped_odex";

typedef struct {
  uint64_t start;
  uint64_t end;
} memory_region;

uint32_t checkTracer(uint32_t pid);
void replaceAll(char* str, char oldChar, char newChar);
int checkFd(int fd);
uint32_t get_clone_pid(uint32_t service_pid);
uint32_t get_process_pid(const char* target_package_name);
packer  *determine_packer(uint32_t clone_pid, int memory_fd);
int find_magic_memory(uint32_t clone_pid, int memory_fd, memory_region *memory[], char* extra_filter);
off64_t peek_memory(int memory_file, uint64_t address);
int dump_memory(char* package_name, int memory_fd, memory_region *memory, const char* file_name, int ignore_class_path);
int attach_get_memory(uint32_t pid);

```