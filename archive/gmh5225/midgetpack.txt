Project Path: arc_gmh5225_midgetpack_myi_vetu

Source Tree:

```txt
arc_gmh5225_midgetpack_myi_vetu
├── CMakeLists.txt
├── ConfigureChecks.cmake
├── DefineOptions.cmake
├── LICENSE
├── README
├── cmake
│   └── Modules
│       ├── CheckCCompilerFlagSSP.cmake
│       ├── DefineCMakeDefaults.cmake
│       ├── DefineCompilerFlags.cmake
│       ├── DefinePlatformDefaults.cmake
│       ├── FindArgp.cmake
│       └── MacroEnsureOutOfSourceBuild.cmake
├── config.h.cmake
└── src
    ├── CMakeLists.txt
    ├── include
    │   ├── aes.h
    │   ├── elf.h
    │   ├── midgetpack.h
    │   ├── sha256.h
    │   ├── shared.h
    │   └── stub.h
    ├── packer
    │   ├── CMakeLists.txt
    │   ├── crypto.c
    │   ├── elf.c
    │   ├── midgetpack.c
    │   └── mpkex.c
    ├── shared
    │   ├── CMakeLists.txt
    │   ├── aes.c
    │   ├── crypto.c
    │   ├── curve25519_ref.c
    │   └── sha256.c
    ├── stub
    │   ├── CMakeLists.txt
    │   ├── freebsd_amd64.s
    │   ├── freebsd_x86.s
    │   ├── linux_amd64.s
    │   ├── linux_armv6.s
    │   ├── linux_x86.s
    │   ├── pack_amd64.s
    │   ├── pack_armv6.s
    │   ├── pack_common.c
    │   ├── pack_x86.s
    │   └── precompiled
    │       ├── stub_freebsd_amd64
    │       ├── stub_freebsd_x86
    │       ├── stub_linux_amd64
    │       ├── stub_linux_armv6
    │       └── stub_linux_x86
    └── tests
        ├── CMakeLists.txt
        ├── banner
        └── test.c

```

`CMakeLists.txt`:

```txt
project(midgetpack C)

# Required cmake version
cmake_minimum_required(VERSION 2.6.0)

# global needed variables
set(APPLICATION_NAME ${PROJECT_NAME})

set(APPLICATION_VERSION_MAJOR "0")
set(APPLICATION_VERSION_MINOR "1")
set(APPLICATION_VERSION_PATCH "0")

set(APPLICATION_VERSION "${APPLICATION_VERSION_MAJOR}.${APPLICATION_VERSION_MINOR}.${APPLICATION_VERSION_PATCH}")

# where to look first for cmake modules, before ${CMAKE_ROOT}/Modules/ is checked
set(CMAKE_MODULE_PATH
  ${CMAKE_SOURCE_DIR}/cmake/Modules
)

# add definitions
include(DefineCMakeDefaults)
include(DefinePlatformDefaults)
include(DefineCompilerFlags)
include(DefineOptions.cmake)

# disallow in-source build
include(MacroEnsureOutOfSourceBuild)
macro_ensure_out_of_source_build("${PROJECT_NAME} requires an out of source build. Please create a separate build directory and run 'cmake /path/to/${PROJECT_NAME} [options]' there.")

# Test for presence of 64 bits/32 bits compiler
#include(CheckCCompilerFlagSSP)
include(CheckCCompilerFlag)
SET(SAFE_CMAKE_REQUIRED_FLAGS ${CMAKE_REQUIRED_FLAGS})
SET(CMAKE_REQUIRED_FLAGS "-m64")
check_c_compiler_flag("-m64" CCOMPILER_64)
SET(CMAKE_REQUIRED_FLAGS "-m32")
check_c_compiler_flag("-m32" CCOMPILER_32)
SET(CMAKE_REQUIRED_FLAGS "-march=armv6")
check_c_compiler_flag("-march=armv6" CCOMPILER_ARMV6)
SET(CMAKE_REQUIRED_FLAGS ${SAFE_CMAKE_REQUIRED_FLAGS})

if(CCOMPILER_32 OR WITH_PRECOMPILED_STUBS)
	set(HAVE_LINUX_X86 1)
	set(HAVE_FREEBSD_X86 1)
endif(CCOMPILER_32 OR WITH_PRECOMPILED_STUBS)

if(CCOMPILER_64 OR WITH_PRECOMPILED_STUBS)
	set(HAVE_LINUX_AMD64 1)
	set(HAVE_FREEBSD_AMD64 1)
endif(CCOMPILER_64 OR WITH_PRECOMPILED_STUBS)

if(CCOMPILER_ARMV6 OR WITH_PRECOMPILED_STUBS)
	set(HAVE_LINUX_ARMV6 1)
endif(CCOMPILER_ARMV6 OR WITH_PRECOMPILED_STUBS)

# config.h checks
include(ConfigureChecks.cmake)
configure_file(config.h.cmake ${CMAKE_CURRENT_BINARY_DIR}/config.h)

# check subdirectories
add_subdirectory(src)

# cmake config files
#set(LIBSSH_LIBRARY_NAME @CMAKE_SHARED_LIBRARY_PREFIX@ssh@CMAKE_SHARED_LIBRARY_SUFFIX@)
#set(LIBSSH_THREADS_LIBRARY_NAME @CMAKE_SHARED_LIBRARY_PREFIX@ssh@CMAKE_SHARED_LIBRARY_SUFFIX@)

#configure_file(${PROJECT_NAME}-config.cmake.in ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}-config.cmake @ONLY)
#configure_file(${PROJECT_NAME}-config-version.cmake.in ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}-config-version.cmake @ONLY)

# in tree build settings
#configure_file(libssh-build-tree-settings.cmake.in ${CMAKE_CURRENT_BINARY_DIR}/libssh-build-tree-settings.cmake @ONLY)


```

`ConfigureChecks.cmake`:

```cmake
include(CheckIncludeFile)
include(CheckSymbolExists)
include(CheckFunctionExists)
include(CheckLibraryExists)
include(CheckTypeSize)
include(CheckCXXSourceCompiles)
include(TestBigEndian)

set(PACKAGE ${APPLICATION_NAME})
set(VERSION ${APPLICATION_VERSION})
set(DATADIR ${DATA_INSTALL_DIR})
set(LIBDIR ${LIB_INSTALL_DIR})
set(PLUGINDIR "${PLUGIN_INSTALL_DIR}-${LIBRARY_SOVERSION}")
set(SYSCONFDIR ${SYSCONF_INSTALL_DIR})

set(BINARYDIR ${CMAKE_BINARY_DIR})
set(SOURCEDIR ${CMAKE_SOURCE_DIR})

function(COMPILER_DUMPVERSION _OUTPUT_VERSION)
    # Remove whitespaces from the argument.
    # This is needed for CC="ccache gcc" cmake ..
    string(REPLACE " " "" _C_COMPILER_ARG "${CMAKE_C_COMPILER_ARG1}")

    execute_process(
        COMMAND
            ${CMAKE_C_COMPILER} ${_C_COMPILER_ARG} -dumpversion
        OUTPUT_VARIABLE _COMPILER_VERSION
    )

    string(REGEX REPLACE "([0-9])\\.([0-9])(\\.[0-9])?" "\\1\\2"
           _COMPILER_VERSION "${_COMPILER_VERSION}")

    set(${_OUTPUT_VERSION} ${_COMPILER_VERSION} PARENT_SCOPE)
endfunction()

if(CMAKE_COMPILER_IS_GNUCC AND NOT MINGW AND NOT OS2)
    compiler_dumpversion(GNUCC_VERSION)
    if (NOT GNUCC_VERSION EQUAL 34)
        set(CMAKE_REQUIRED_FLAGS "-fvisibility=hidden")
        check_c_source_compiles(
"void __attribute__((visibility(\"default\"))) test() {}
int main(void){ return 0; }
" WITH_VISIBILITY_HIDDEN)
        set(CMAKE_REQUIRED_FLAGS "")
    endif (NOT GNUCC_VERSION EQUAL 34)
endif(CMAKE_COMPILER_IS_GNUCC AND NOT MINGW AND NOT OS2)

# HEADER FILES
check_include_file(argp.h HAVE_ARGP_H)
check_include_file(unistd.h HAVE_UNISTD_H)

if (NOT WIN32)
    test_big_endian(WORDS_BIGENDIAN)
endif (NOT WIN32)

```

`DefineOptions.cmake`:

```cmake
option(WITH_STUB_DEBUG "Build with STUB debug support" OFF)
option(WITH_PACKER_DEBUG "Build with PACKER debug support" OFF)
option(WITH_CRYPTO_DEBUG "Build with CRYPTO debug support" OFF)
option(WITH_PRECOMPILED_STUBS "Build with the available precompiled stubs" ON)

if(WITH_STUB_DEBUG)
	set(LOADER_DEBUG ON)
ENDIF(WITH_STUB_DEBUG)

if(WITH_PACKER_DEBUG)
	set(PACKER_DEBUG ON)
ENDIF(WITH_PACKER_DEBUG)

if(WITH_CRYPTO_DEBUG)
	set(CRYPTO_DEBUG ON)
ENDIF(WITH_CRYPTO_DEBUG)



```

`LICENSE`:

```
License for axTLS (aes.c)

axTLS uses a BSD style license:

Copyright (c) 2008, Cameron Rich All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer. Redistributions in binary
form must reproduce the above copyright notice, this list of conditions and
the following disclaimer in the documentation and/or other materials
provided with the distribution. Neither the name of the axTLS Project nor
the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.


License for scrypt (sha256.c)
/*-
 * Copyright 2005,2007,2009 Colin Percival
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

License for midgetpack (all other files excluding curve25519_ref.c)
/*-
 * Copyright 2014 Aris Adamantiadis <aris@badcode.be>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


```

`README`:

```
  Midgetpack
  ~-~-~-~-~-
    aris@badcode.be
  
  Table of contents:
  
1- What is Midgetpack
2- Features
3- Use
4- Shortcomings
5- Installation

***********************************************************

1- What is Midgetpack

 Midgetpack is a binary packer for ELF binaries, such as burneye, upx or 
 other tools. Its goal is to protect your assets (tools, exploits) when using
 them on untrusted systems (e.g on a monitored customer's system during a
 pentest).
 Midgetpack contains two modes of operation: password and curve25519 key exchange.
 
 The password mode is the classical password that is asked when starting the
 binary. I believe the binary to be secure against cracking if you choose a
 strong password, but once someone has both binary and password he can do whatever
 he wants.
 
 The curve25519 is the real advantage of midgetpack. In this mode, you do not
 provide any password or key. Instead, a key file is generated at packing time.
 This key file must be used everytime you wish to use the binary. When you start
 the binary, it will give a challenge and expect a response. You copy/paste the
 challenge in the input of the mpkex tool and receive a response containing the
 encrypted key to the binary.
 This key exchange is protected by Curve25519 key exchange, the key is encrypted
 with aes-128 and the whole exchange is authenticated with HMAC-SHA256 to avoid
 generic man-in-the-middle attacks.
 This mode is truly secure as eavesdropping the terminal will *not* be enough to
 recover the key or the unprotected binary.
 
2- Features

 Midgetpack is able to pack binaries in different architectures using the same
 executable. This makes possible to pack an x86 binary on an amd64 one.
 
 Currently Linux and freebsd are supported.
 CPU supported: x86-32, x86-64, arm
 
 Encryption: 
  - Password (PBKCS2, AES128-cbc, HMAC-SHA256)
  - curve25519 (Curve25519 kex, AES128-cbc, HMAC-SHA256)
  
3- Use
 As stated above, there are 2 different operation modes: password and curve25519.
 
 - Password:
   $ ./midgetpack -o binary -p src/tests/test32-dynamic 
   x86 ELF file
   Adding new pheader with vaddr base badd000, offset 0 of filesz 5eca
   Please enter password:
   Enter the password again:
   $ chmod +x binary 
   $ ./binary 
   starting stub...
   Password: 
   Hello, world !
 
 - Curve25519
   $ ./midgetpack -o binary -c src/tests/test32-dynamic
   x86 ELF file
   Adding new pheader with vaddr base badd000, offset 0 of filesz 5eca
   Key data written in file key
   
   Then, two consoles are needed:
 
 $ ./binary                            | $ src/packer/mpkex key 
starting stub...                       | Waiting for challenge...
challenge:                             |
ZABpaSpiAkNzJTFKkiE3S7mW-vC7YrcBainilU |
1yScpWEWZB9epppJHeicqd9wj4             |
                                       | ZABpaSpiAkNzJTFKkiE3S7mW-vC7YrcBainilU
                                       | 1yScpWEWZB9epppJHeicqd9wj4
                                       | Response:
                                       | jvDFJApVgXUASz-7hLj_2BJ40ppY0EsJ9GOsM-f
                                       | 7pkBVFsu6cnV4XWBSO5nz82lVopPJJ5PRy7Pi-l
                                       | urGgtPDDAA
jvDFJApVgXUASz-7hLj_2BJ40ppY0EsJ9GOsM- | $ 
f7pkBVFsu6cnV4XWBSO5nz82lVopPJJ5PRy7Pi |
-lurGgtPDDAA                           |
Hello, world !                         |

4- Shortcomings

 The password version of midgetpack is not very secure. The password is currently
 echoed back so it appears in cleartext on honeypots. However it may be enough when
 there's good confidence that the system is not monitored.
 
 The Curve25519 version is stronger, but is subject to replay attacks if the PRNG
 can be forced to replay same numbers. To do so, an attacker would need to hook
 /dev/urandom, the rdtsc instruction and the ELF Aux vector on the first run
 to force output of the same numbers.
 
 The Curve25519 version is also vulnerable to some active man-in-the middle attacks
 in which an attacker would need to extract the HMAC key from the binary and dynamically
 replace the binary's challenge with its own.
 
 Both these attacks are unlikely to be seen in the wild.
 
 Both versions are vulnerable to snapshots attacks, in which a snapshot of the VM or
 the running process is taken in order to analyse the cleartext version of the binary.
 Reducing the impact of these attacks may be a target for next versions.
 
5- Installation

 Requirements:
 - cmake
 - C compiler (tested with gcc, may fail on clang)

 $ mkdir build/
 $ cd build/
 $ cmake ..
  (note: cmake .. -DWITH_PRECOMPILED_STUBS if you don't want any binary blob)
 $ make
 $ src/packer/midgetpack -o packed -P mypassword src/tests/test32-dynamic
 $ ./packed


```

`cmake/Modules/CheckCCompilerFlagSSP.cmake`:

```cmake
# - Check whether the C compiler supports a given flag in the
# context of a stack checking compiler option.

# CHECK_C_COMPILER_FLAG_SSP(FLAG VARIABLE)
#
#  FLAG - the compiler flag
#  VARIABLE - variable to store the result
#
#  This actually calls check_c_source_compiles.
#  See help for CheckCSourceCompiles for a listing of variables
#  that can modify the build.

# Copyright (c) 2006, Alexander Neundorf, <neundorf@kde.org>
#
# Redistribution and use is allowed according to the terms of the BSD license.
# For details see the accompanying COPYING-CMAKE-SCRIPTS file.


include(CheckCSourceCompiles)

function(CHECK_C_COMPILER_FLAG_SSP _FLAG _RESULT)
   set(SAFE_CMAKE_REQUIRED_DEFINITIONS "${CMAKE_REQUIRED_DEFINITIONS}")
   set(CMAKE_REQUIRED_DEFINITIONS "${_FLAG}")
   check_c_source_compiles("int main(int argc, char **argv) { char buffer[256]; return buffer[argc]=0;}" ${_RESULT})
   set(CMAKE_REQUIRED_DEFINITIONS "${SAFE_CMAKE_REQUIRED_DEFINITIONS}")
endfunction(CHECK_C_COMPILER_FLAG_SSP)

```

`cmake/Modules/DefineCMakeDefaults.cmake`:

```cmake
# Always include srcdir and builddir in include path
# This saves typing ${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_CURRENT_BINARY} in
# about every subdir
# since cmake 2.4.0
set(CMAKE_INCLUDE_CURRENT_DIR ON)

# Put the include dirs which are in the source or build tree
# before all other include dirs, so the headers in the sources
# are prefered over the already installed ones
# since cmake 2.4.1
set(CMAKE_INCLUDE_DIRECTORIES_PROJECT_BEFORE ON)

# Use colored output
# since cmake 2.4.0
set(CMAKE_COLOR_MAKEFILE ON)

# Define the generic version of the libraries here
set(GENERIC_LIB_VERSION "0.1.0")
set(GENERIC_LIB_SOVERSION "0")

# Set the default build type to release with debug info
if (NOT CMAKE_BUILD_TYPE)
  set(CMAKE_BUILD_TYPE RelWithDebInfo
    CACHE STRING
      "Choose the type of build, options are: None Debug Release RelWithDebInfo MinSizeRel."
  )
endif (NOT CMAKE_BUILD_TYPE)

# Create the compile command database for clang by default
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

```

`cmake/Modules/DefineCompilerFlags.cmake`:

```cmake
# define system dependent compiler flags

include(CheckCCompilerFlag)
include(CheckCCompilerFlagSSP)

if (UNIX AND NOT WIN32)
    #
    # Define GNUCC compiler flags
    #
    if (${CMAKE_C_COMPILER_ID} MATCHES "(GNU|Clang)")

        # add -Wconversion ?
        set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -std=gnu99 -pedantic -pedantic-errors")
        set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -Wextra -Wshadow -Wmissing-prototypes -Wdeclaration-after-statement")
        set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wunused -Wfloat-equal -Wpointer-arith -Wwrite-strings -Wformat-security")
        set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wmissing-format-attribute")

        # with -fPIC
        #check_c_compiler_flag("-fPIC" WITH_FPIC)
        #if (WITH_FPIC)
        #    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fPIC")
        #endif (WITH_FPIC)

        #check_c_compiler_flag_ssp("-fstack-protector" WITH_STACK_PROTECTOR)
        #if (WITH_STACK_PROTECTOR)
        #    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fstack-protector")
        #endif (WITH_STACK_PROTECTOR)

        if (CMAKE_BUILD_TYPE)
            string(TOLOWER "${CMAKE_BUILD_TYPE}" CMAKE_BUILD_TYPE_LOWER)
            if (CMAKE_BUILD_TYPE_LOWER MATCHES (release|relwithdebinfo|minsizerel))
                check_c_compiler_flag("-Wp,-D_FORTIFY_SOURCE=2" WITH_FORTIFY_SOURCE)
                if (WITH_FORTIFY_SOURCE)
                    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wp,-D_FORTIFY_SOURCE=2")
                endif (WITH_FORTIFY_SOURCE)
            endif()
        endif()
    endif (${CMAKE_C_COMPILER_ID} MATCHES "(GNU|Clang)")

    #
    # Check for large filesystem support
    #
    if (CMAKE_SIZEOF_VOID_P MATCHES "8")
        # with large file support
        execute_process(
            COMMAND
                getconf LFS64_CFLAGS
            OUTPUT_VARIABLE
                _lfs_CFLAGS
            ERROR_QUIET
            OUTPUT_STRIP_TRAILING_WHITESPACE
        )
    else (CMAKE_SIZEOF_VOID_P MATCHES "8")
        # with large file support
        execute_process(
            COMMAND
                getconf LFS_CFLAGS
            OUTPUT_VARIABLE
                _lfs_CFLAGS
            ERROR_QUIET
            OUTPUT_STRIP_TRAILING_WHITESPACE
        )
    endif (CMAKE_SIZEOF_VOID_P MATCHES "8")
    if (_lfs_CFLAGS)
        string(REGEX REPLACE "[\r\n]" " " "${_lfs_CFLAGS}" "${${_lfs_CFLAGS}}")
        #These flags cause problems on cross compile
		#set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${_lfs_CFLAGS}")
    endif (_lfs_CFLAGS)

endif (UNIX AND NOT WIN32)

if (MSVC)
    # Use secure functions by defaualt and suppress warnings about
    #"deprecated" functions
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} /D _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES=1")
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} /D _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT=1")
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} /D _CRT_NONSTDC_NO_WARNINGS=1 /D _CRT_SECURE_NO_WARNINGS=1")
endif (MSVC)

# This removes this annoying warning
# "warning: 'BN_CTX_free' is deprecated: first deprecated in OS X 10.7 [-Wdeprecated-declarations]"
if (OSX)
	set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wno-deprecated-declarations")
endif (OSX)


```

`cmake/Modules/DefinePlatformDefaults.cmake`:

```cmake
# Set system vars

if (CMAKE_SYSTEM_NAME MATCHES "Linux")
    set(LINUX TRUE)
endif(CMAKE_SYSTEM_NAME MATCHES "Linux")

if (CMAKE_SYSTEM_NAME MATCHES "FreeBSD")
    set(FREEBSD TRUE)
    set(BSD TRUE)
endif (CMAKE_SYSTEM_NAME MATCHES "FreeBSD")

if (CMAKE_SYSTEM_NAME MATCHES "OpenBSD")
    set(OPENBSD TRUE)
    set(BSD TRUE)
endif (CMAKE_SYSTEM_NAME MATCHES "OpenBSD")

if (CMAKE_SYSTEM_NAME MATCHES "NetBSD")
    set(NETBSD TRUE)
    set(BSD TRUE)
endif (CMAKE_SYSTEM_NAME MATCHES "NetBSD")

if (CMAKE_SYSTEM_NAME MATCHES "(Solaris|SunOS)")
    set(SOLARIS TRUE)
endif (CMAKE_SYSTEM_NAME MATCHES "(Solaris|SunOS)")

if (CMAKE_SYSTEM_NAME MATCHES "OS2")
    set(OS2 TRUE)
endif (CMAKE_SYSTEM_NAME MATCHES "OS2")

if (CMAKE_SYSTEM_NAME MATCHES "Darwin")
	set (OSX TRUE)
endif (CMAKE_SYSTEM_NAME MATCHES "Darwin")

```

`cmake/Modules/FindArgp.cmake`:

```cmake
# - Try to find Argp
# Once done this will define
#
#  ARGP_FOUND - system has Argp
#  ARGP_INCLUDE_DIRS - the Argp include directory
#  ARGP_LIBRARIES - Link these to use Argp
#  ARGP_DEFINITIONS - Compiler switches required for using Argp
#
#  Copyright (c) 2010 Andreas Schneider <asn@cryptomilk.org>
#
#  Redistribution and use is allowed according to the terms of the New
#  BSD license.
#  For details see the accompanying COPYING-CMAKE-SCRIPTS file.
#


if (ARGP_LIBRARIES AND ARGP_INCLUDE_DIRS)
  # in cache already
  set(ARGP_FOUND TRUE)
else (ARGP_LIBRARIES AND ARGP_INCLUDE_DIRS)

  find_path(ARGP_INCLUDE_DIR
    NAMES
      argp.h
    PATHS
      /usr/include
      /usr/local/include
      /opt/local/include
      /sw/include
  )

  find_library(ARGP_LIBRARY
    NAMES
      argp
    PATHS
      /usr/lib
      /usr/local/lib
      /opt/local/lib
      /sw/lib
  )

  set(ARGP_INCLUDE_DIRS
    ${ARGP_INCLUDE_DIR}
  )

  if (ARGP_LIBRARY)
    set(ARGP_LIBRARIES
        ${ARGP_LIBRARIES}
        ${ARGP_LIBRARY}
    )
  endif (ARGP_LIBRARY)

  include(FindPackageHandleStandardArgs)
  find_package_handle_standard_args(Argp DEFAULT_MSG ARGP_LIBRARIES ARGP_INCLUDE_DIRS)

  # show the ARGP_INCLUDE_DIRS and ARGP_LIBRARIES variables only in the advanced view
  mark_as_advanced(ARGP_INCLUDE_DIRS ARGP_LIBRARIES)

endif (ARGP_LIBRARIES AND ARGP_INCLUDE_DIRS)


```

`cmake/Modules/MacroEnsureOutOfSourceBuild.cmake`:

```cmake
# - MACRO_ENSURE_OUT_OF_SOURCE_BUILD(<errorMessage>)
# MACRO_ENSURE_OUT_OF_SOURCE_BUILD(<errorMessage>)

# Copyright (c) 2006, Alexander Neundorf, <neundorf@kde.org>
#
# Redistribution and use is allowed according to the terms of the BSD license.
# For details see the accompanying COPYING-CMAKE-SCRIPTS file.

macro (MACRO_ENSURE_OUT_OF_SOURCE_BUILD _errorMessage)

   string(COMPARE EQUAL "${CMAKE_SOURCE_DIR}" "${CMAKE_BINARY_DIR}" _insource)
   if (_insource)
     message(SEND_ERROR "${_errorMessage}")
     message(FATAL_ERROR "Remove the file CMakeCache.txt in ${CMAKE_SOURCE_DIR} first.")
   endif (_insource)

endmacro (MACRO_ENSURE_OUT_OF_SOURCE_BUILD)

```

`config.h.cmake`:

```cmake
#cmakedefine LOADER_DEBUG
#cmakedefine PACKER_DEBUG
#cmakedefine CRYPTO_DEBUG
#cmakedefine HAVE_LINUX_X86
#cmakedefine HAVE_LINUX_AMD64
#cmakedefine HAVE_LINUX_ARMV6
#cmakedefine HAVE_FREEBSD_X86
#cmakedefine HAVE_FREEBSD_AMD64

```

`src/CMakeLists.txt`:

```txt
project(midgetpack C)

if (BSD OR SOLARIS OR OSX)
    find_package(Argp)
endif (BSD OR SOLARIS OR OSX)


set(MPACK_INCLUDE_DIRS
  ${CMAKE_SOURCE_DIR}/src/include
  ${CMAKE_BINARY_DIR}
  ${ARGP_INCLUDE_DIR}
  CACHE INTERNAL "include directory"
)

include_directories(
  ${MPACK_INCLUDE_DIRS}
)

SET(CMAKE_REQUIRED_FLAGS ${CMAKE_REQUIRED_FLAGS} "-g")
add_subdirectory(shared)
add_subdirectory(stub)
add_subdirectory(packer)
add_subdirectory(tests)


```

`src/include/aes.h`:

```h
/*
 * Copyright (c) 2007, Cameron Rich
 * 
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, 
 *   this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice, 
 *   this list of conditions and the following disclaimer in the documentation 
 *   and/or other materials provided with the distribution.
 * * Neither the name of the axTLS project nor the names of its contributors 
 *   may be used to endorse or promote products derived from this software 
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @file crypto.h
 */

#ifndef HEADER_AES_H
#define HEADER_AES_H

#include <stdint.h>
#include <arpa/inet.h>
#ifndef EXP_FUNC
#define EXP_FUNC
#endif

/**************************************************************************
 * AES declarations 
 **************************************************************************/

#define AES_MAXROUNDS			14
#define AES_BLOCKSIZE           16
#define AES_IV_SIZE             16

typedef struct aes_key_st 
{
    uint16_t rounds;
    uint16_t key_size;
    uint32_t ks[(AES_MAXROUNDS+1)*8];
    uint8_t iv[AES_IV_SIZE];
} AES_CTX;

typedef enum
{
    AES_MODE_128,
    AES_MODE_256
} AES_MODE;

void AES_set_key(AES_CTX *ctx, const uint8_t *key, 
        const uint8_t *iv, AES_MODE mode);
void AES_cbc_encrypt(AES_CTX *ctx, const uint8_t *msg, 
        uint8_t *out, int length);
void AES_cbc_decrypt(AES_CTX *ks, const uint8_t *in, uint8_t *out, int length);
void AES_convert_key(AES_CTX *ctx);


#endif 

```

`src/include/elf.h`:

```h
/* This file defines standard ELF types, structures, and macros.
   Copyright (C) 1995-2003,2004,2005,2006,2007,2008,2009,2010
	Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/* elf.h is a re-implementation of ELF headers *
 * so they are exactly identical on all platforms
 * and avoid traps on some OS.
 */

#ifndef ELF_H_
#define ELF_H_

#include <stdint.h>

/* Type for a 16-bit quantity.  */
typedef uint16_t Elf32_Half;
typedef uint16_t Elf64_Half;

/* Types for signed and unsigned 32-bit quantities.  */
typedef uint32_t Elf32_Word;
typedef uint32_t Elf64_Word;

typedef uint64_t Elf64_Xword;

/* Type of addresses.  */
typedef uint32_t Elf32_Addr;
typedef uint64_t Elf64_Addr;

/* Type of file offsets.  */
typedef uint32_t Elf32_Off;
typedef uint64_t Elf64_Off;


/* The ELF file header.  This appears at the start of every ELF file.  */

#define EI_NIDENT (16)

typedef struct
{
  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
  Elf32_Half	e_type;			/* Object file type */
  Elf32_Half	e_machine;		/* Architecture */
  Elf32_Word	e_version;		/* Object file version */
  Elf32_Addr	e_entry;		/* Entry point virtual address */
  Elf32_Off	e_phoff;		/* Program header table file offset */
  Elf32_Off	e_shoff;		/* Section header table file offset */
  Elf32_Word	e_flags;		/* Processor-specific flags */
  Elf32_Half	e_ehsize;		/* ELF header size in bytes */
  Elf32_Half	e_phentsize;		/* Program header table entry size */
  Elf32_Half	e_phnum;		/* Program header table entry count */
  Elf32_Half	e_shentsize;		/* Section header table entry size */
  Elf32_Half	e_shnum;		/* Section header table entry count */
  Elf32_Half	e_shstrndx;		/* Section header string table index */
} Elf32_Ehdr;

typedef struct
{
  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
  Elf64_Half	e_type;			/* Object file type */
  Elf64_Half	e_machine;		/* Architecture */
  Elf64_Word	e_version;		/* Object file version */
  Elf64_Addr	e_entry;		/* Entry point virtual address */
  Elf64_Off	e_phoff;		/* Program header table file offset */
  Elf64_Off	e_shoff;		/* Section header table file offset */
  Elf64_Word	e_flags;		/* Processor-specific flags */
  Elf64_Half	e_ehsize;		/* ELF header size in bytes */
  Elf64_Half	e_phentsize;		/* Program header table entry size */
  Elf64_Half	e_phnum;		/* Program header table entry count */
  Elf64_Half	e_shentsize;		/* Section header table entry size */
  Elf64_Half	e_shnum;		/* Section header table entry count */
  Elf64_Half	e_shstrndx;		/* Section header string table index */
} Elf64_Ehdr;

/* Fields in the e_ident array.  The EI_* macros are indices into the
   array.  The macros under each EI_* macro are the values the byte
   may have.  */

#define EI_MAG0		0		/* File identification byte 0 index */
#define ELFMAG0		0x7f		/* Magic number byte 0 */

#define EI_MAG1		1		/* File identification byte 1 index */
#define ELFMAG1		'E'		/* Magic number byte 1 */

#define EI_MAG2		2		/* File identification byte 2 index */
#define ELFMAG2		'L'		/* Magic number byte 2 */

#define EI_MAG3		3		/* File identification byte 3 index */
#define ELFMAG3		'F'		/* Magic number byte 3 */

/* Conglomeration of the identification bytes, for easy testing as a word.  */
#define	ELFMAG		"\177ELF"
#define	SELFMAG		4

#define EI_CLASS	4		/* File class byte index */
#define ELFCLASSNONE	0		/* Invalid class */
#define ELFCLASS32	1		/* 32-bit objects */
#define ELFCLASS64	2		/* 64-bit objects */
#define ELFCLASSNUM	3


#define EI_OSABI	7		/* OS ABI identification */
#define ELFOSABI_NONE		0	/* UNIX System V ABI */
#define ELFOSABI_SYSV		0	/* Alias.  */
#define ELFOSABI_HPUX		1	/* HP-UX */
#define ELFOSABI_NETBSD		2	/* NetBSD.  */
#define ELFOSABI_GNU		3	/* GNU.  */
#define ELFOSABI_LINUX		3	/* Alias for ELFOSABI_GNU.  */
#define ELFOSABI_SOLARIS	6	/* Sun Solaris.  */
#define ELFOSABI_AIX		7	/* IBM AIX.  */
#define ELFOSABI_IRIX		8	/* SGI Irix.  */
#define ELFOSABI_FREEBSD	9	/* FreeBSD.  */
#define ELFOSABI_TRU64		10	/* Compaq TRU64 UNIX.  */
#define ELFOSABI_MODESTO	11	/* Novell Modesto.  */
#define ELFOSABI_OPENBSD	12	/* OpenBSD.  */
#define ELFOSABI_ARM_AEABI	64	/* ARM EABI */
#define ELFOSABI_ARM		97	/* ARM */
#define ELFOSABI_STANDALONE	255	/* Standalone (embedded) application */

#define EI_ABIVERSION	8		/* ABI version */

#define EI_PAD		9		/* Byte index of padding bytes */

/* Legal values for e_type (object file type).  */

#define ET_NONE		0		/* No file type */
#define ET_REL		1		/* Relocatable file */
#define ET_EXEC		2		/* Executable file */
#define ET_DYN		3		/* Shared object file */
#define ET_CORE		4		/* Core file */
#define	ET_NUM		5		/* Number of defined types */
#define ET_LOOS		0xfe00		/* OS-specific range start */
#define ET_HIOS		0xfeff		/* OS-specific range end */
#define ET_LOPROC	0xff00		/* Processor-specific range start */
#define ET_HIPROC	0xffff		/* Processor-specific range end */

/* Legal values for e_machine (architecture).  */

#define EM_NONE		 0		/* No machine */
#define EM_386		 3		/* Intel 80386 */
#define EM_X86_64	62		/* AMD x86-64 architecture */
#define EM_ARM		40		/* ARM */

/* Program segment header.  */

typedef struct
{
  Elf32_Word	p_type;			/* Segment type */
  Elf32_Off	p_offset;		/* Segment file offset */
  Elf32_Addr	p_vaddr;		/* Segment virtual address */
  Elf32_Addr	p_paddr;		/* Segment physical address */
  Elf32_Word	p_filesz;		/* Segment size in file */
  Elf32_Word	p_memsz;		/* Segment size in memory */
  Elf32_Word	p_flags;		/* Segment flags */
  Elf32_Word	p_align;		/* Segment alignment */
} Elf32_Phdr;

typedef struct
{
  Elf64_Word	p_type;			/* Segment type */
  Elf64_Word	p_flags;		/* Segment flags */
  Elf64_Off	p_offset;		/* Segment file offset */
  Elf64_Addr	p_vaddr;		/* Segment virtual address */
  Elf64_Addr	p_paddr;		/* Segment physical address */
  Elf64_Xword	p_filesz;		/* Segment size in file */
  Elf64_Xword	p_memsz;		/* Segment size in memory */
  Elf64_Xword	p_align;		/* Segment alignment */
} Elf64_Phdr;

/* Legal values for p_type (segment type).  */

#define	PT_NULL		0		/* Program header table entry unused */
#define PT_LOAD		1		/* Loadable program segment */
#define PT_DYNAMIC	2		/* Dynamic linking information */
#define PT_INTERP	3		/* Program interpreter */
#define PT_NOTE		4		/* Auxiliary information */
#define PT_SHLIB	5		/* Reserved */
#define PT_PHDR		6		/* Entry for header table itself */
#define PT_TLS		7		/* Thread-local storage segment */
#define	PT_NUM		8		/* Number of defined types */

/* Legal values for p_flags (segment flags).  */

#define PF_X		(1 << 0)	/* Segment is executable */
#define PF_W		(1 << 1)	/* Segment is writable */
#define PF_R		(1 << 2)	/* Segment is readable */
#define PF_MASKOS	0x0ff00000	/* OS-specific */
#define PF_MASKPROC	0xf0000000	/* Processor-specific */

typedef struct
{
  uint32_t a_type;		/* Entry type */
  union
    {
      uint32_t a_val;		/* Integer value */
      /* We use to have pointer elements added here.  We cannot do that,
	 though, since it does not work when using 32-bit definitions
	 on 64-bit platforms and vice versa.  */
    } a_un;
} Elf32_auxv_t;

typedef struct
{
  uint64_t a_type;		/* Entry type */
  union
    {
      uint64_t a_val;		/* Integer value */
      /* We use to have pointer elements added here.  We cannot do that,
	 though, since it does not work when using 32-bit definitions
	 on 64-bit platforms and vice versa.  */
    } a_un;
} Elf64_auxv_t;

/* Legal values for a_type (entry type).  */

#define AT_NULL		0		/* End of vector */
#define AT_IGNORE	1		/* Entry should be ignored */
#define AT_EXECFD	2		/* File descriptor of program */
#define AT_PHDR		3		/* Program headers for program */
#define AT_PHENT	4		/* Size of program header entry */
#define AT_PHNUM	5		/* Number of program headers */
#define AT_PAGESZ	6		/* System page size */
#define AT_BASE		7		/* Base address of interpreter */
#define AT_FLAGS	8		/* Flags */
#define AT_ENTRY	9		/* Entry point of program */
#define AT_NOTELF	10		/* Program is not ELF */
#define AT_UID		11		/* Real uid */
#define AT_EUID		12		/* Effective uid */
#define AT_GID		13		/* Real gid */
#define AT_EGID		14		/* Effective gid */
#define AT_CLKTCK	17		/* Frequency of times() */

/* Some more special a_type values describing the hardware.  */
#define AT_PLATFORM	15		/* String identifying platform.  */
#define AT_HWCAP	16		/* Machine dependent hints about
					   processor capabilities.  */

/* This entry gives some information about the FPU initialization
   performed by the kernel.  */
#define AT_FPUCW	18		/* Used FPU control word.  */

/* Cache block sizes.  */
#define AT_DCACHEBSIZE	19		/* Data cache block size.  */
#define AT_ICACHEBSIZE	20		/* Instruction cache block size.  */
#define AT_UCACHEBSIZE	21		/* Unified cache block size.  */

/* A special ignored value for PPC, used by the kernel to control the
   interpretation of the AUXV. Must be > 16.  */
#define AT_IGNOREPPC	22		/* Entry should be ignored.  */

#define	AT_SECURE	23		/* Boolean, was exec setuid-like?  */

#define AT_BASE_PLATFORM 24		/* String identifying real platforms.*/

#define AT_RANDOM	25		/* Address of 16 random bytes.  */

#define AT_EXECFN	31		/* Filename of executable.  */

/* Pointer to the global system page used for system calls and other
   nice things.  */
#define AT_SYSINFO	32
#define AT_SYSINFO_EHDR	33

/* Shapes of the caches.  Bits 0-3 contains associativity; bits 4-7 contains
   log2 of line size; mask those to get cache size.  */
#define AT_L1I_CACHESHAPE	34
#define AT_L1D_CACHESHAPE	35
#define AT_L2_CACHESHAPE	36
#define AT_L3_CACHESHAPE	37


#endif /* ELF_H_ */

```

`src/include/midgetpack.h`:

```h
/*
 * Copyright 2014 Aris Adamantiadis <aris@badcode.be>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <stdint.h>
#include "config.h"
#include "shared.h"

#define BASE_ADDR 0xda79000
enum architecture_e {
  ARCH_x86 = 1,
  ARCH_AMD64,
  ARCH_ARM,
  ARCH_UNSUPPORTED,
  ARCH_INVALID
};

#define KEY_FILE_MAGIC_0 ((uint8_t)'M')
#define KEY_FILE_MAGIC_1 ((uint8_t)'P')
#define KEY_FILE_MAGIC_2 ((uint8_t)'\x7f')
#define KEY_FILE_MAGIC_3 ((uint8_t)'\x9f')

/* key file structure */
struct key_file {
	uint8_t magic[4];
	char filename[32];
	uint8_t master_key[AES128_KEY_LEN];
	uint8_t authentication_key[AES128_KEY_LEN];
};

/* elf.c */
struct elf_file_s {
  unsigned char *data;
  size_t size;
  enum architecture_e arch;
};

struct elf_file_s *elf_file_open(const char *filename);
void elf_file_free(struct elf_file_s *file);
enum architecture_e elf_get_arch(struct elf_file_s *file);
enum os_e elf_get_os(struct elf_file_s *file);
void elf_set_os(uint8_t *stub, enum os_e os);
void elf_add_pheader_32(unsigned char *stub, uint32_t vaddr, uint32_t offset, size_t len);
void elf_add_pheader_64(unsigned char *stub, uint64_t vaddr, uint64_t offset, size_t len);

/* embedded data */
unsigned char* get_x86_stub(size_t *size);

/* crypto.c */

char *ask_password(void);
void encrypt_payload(void *payload, size_t len, uint8_t encryptkey[AES128_KEY_LEN],
		uint8_t IV[AES128_KEY_LEN]);

int generate_password_parameters(uint8_t encryption_salt[8], uint8_t password_salt[8]);
int generate_curve25519_parameters(uint8_t encryption_salt[8],
		uint8_t master_key[AES128_KEY_LEN],
		uint8_t authentication_key[AES128_KEY_LEN]);

```

`src/include/sha256.h`:

```h
/*-
 * Copyright 2005,2007,2009 Colin Percival
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: src/lib/libmd/sha256.h,v 1.2 2006/01/17 15:35:56 phk Exp $
 */

#ifndef _SHA256_H_
#define _SHA256_H_

#include <sys/types.h>

#include <stdint.h>

typedef struct SHA256Context {
	uint32_t state[8];
	uint32_t count[2];
	unsigned char buf[64];
} SHA256_CTX;

typedef struct HMAC_SHA256Context {
	SHA256_CTX ictx;
	SHA256_CTX octx;
} HMAC_SHA256_CTX;

void	SHA256_Init(SHA256_CTX *);
void	SHA256_Update(SHA256_CTX *, const void *, size_t);
void	SHA256_Final(unsigned char [32], SHA256_CTX *);
void	HMAC_SHA256_Init(HMAC_SHA256_CTX *, const void *, size_t);
void	HMAC_SHA256_Update(HMAC_SHA256_CTX *, const void *, size_t);
void	HMAC_SHA256_Final(unsigned char [32], HMAC_SHA256_CTX *);

/**
 * PBKDF2_SHA256(passwd, passwdlen, salt, saltlen, c, buf, dkLen):
 * Compute PBKDF2(passwd, salt, c, dkLen) using HMAC-SHA256 as the PRF, and
 * write the output to buf.  The value dkLen must be at most 32 * (2^32 - 1).
 */
void	PBKDF2_SHA256(const uint8_t *, size_t, const uint8_t *, size_t,
    uint64_t, uint8_t *, size_t);

#endif /* !_SHA256_H_ */

```

`src/include/shared.h`:

```h
/*
 * Copyright 2014 Aris Adamantiadis <aris@badcode.be>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef SHARED_H_
#define SHARED_H_

#include "config.h"
#include <stdint.h>
#include <sys/types.h>

#ifndef SHA256_DIGEST_LEN
#define SHA256_DIGEST_LEN 32
#endif

#define AES128_KEY_LEN 16

#define ZERO(x) memset_s((&x),'\0', sizeof(x));

/* common data structures */
#define MAGIC 0xf00dbea7
enum pack_type {
	PACK_TYPE_PASSWORD = 1,
	PACK_TYPE_CURVE25519 = 2
};

enum os_e {
  OS_LINUX = 1,
  OS_FREEBSD,
  OS_UNSUPPORTED,
  OS_INVALID
};

#define STUB_DATA(BITS) \
	struct stub_data_ ## BITS {\
		uint32_t magic;\
		uint ## BITS ## _t data_base;\
		uint32_t data_len;\
		uint ## BITS ## _t banner_addr;\
		uint32_t banner_len;\
		enum pack_type type;\
		uint8_t checksum[32];\
		uint8_t password_salt[8];\
		uint32_t hash_loops; \
		uint8_t encryption_salt[8];\
		/* symmetric HMAC key for authentication of curve25519\
		 * exchange parameters */\
		uint8_t authentication_key[16];\
	} //__attribute__((packed))
STUB_DATA(32);
STUB_DATA(64);

void memset_s(void *v, int c, size_t n);

void compute_session_keys(uint8_t encryptkey[AES128_KEY_LEN],
		uint8_t IV[AES128_KEY_LEN],
		uint8_t integrity[AES128_KEY_LEN],
		uint8_t master_key[AES128_KEY_LEN],
		uint8_t encryption_salt[8]);

void compute_session_keys_password (char *password, int iterations,
		uint8_t encryptkey[16],
		uint8_t IV[16],
		uint8_t integrity[16],
		uint8_t encryption_salt[8],
		uint8_t password_salt[8]
		);
void compute_checksum(void *payload, size_t len, uint8_t integrity[SHA256_DIGEST_LEN],
		uint8_t checksum[SHA256_DIGEST_LEN]);
void b64_encode(char *dest, size_t dest_size, uint8_t *input, size_t input_size);
int b64_decode(uint8_t *dest, size_t dest_size, char *input, size_t input_size);

/* curve25519_ref.c */
#define CURVE25519_KEY_LEN 32

/* q = p**n */
int crypto_scalarmult(unsigned char q[CURVE25519_KEY_LEN],
  const unsigned char n[CURVE25519_KEY_LEN],
  const unsigned char p[CURVE25519_KEY_LEN]);
/* q = base**n */
int crypto_scalarmult_base(unsigned char q[CURVE25519_KEY_LEN],
  const unsigned char n[CURVE25519_KEY_LEN]);

struct curve25519_request{
	uint8_t pubkey[CURVE25519_KEY_LEN];
	uint8_t authentication[16];
};

struct curve25519_reply{
	uint8_t pubkey[CURVE25519_KEY_LEN];
	uint8_t encrypted_master[AES128_KEY_LEN];
	uint8_t authentication[16];
};

/* this function is defined differently in packer and stub */
int get_random(uint8_t *dest, size_t len);
void print_key(const char *name, uint8_t *key, int len);

#endif /* SHARED_H_ */

```

`src/include/stub.h`:

```h
/*
 * Copyright 2014 Aris Adamantiadis <aris@badcode.be>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef _STUB_H_
#define _STUB_H_

/* definitions specific to the stub */
#include <stdint.h>
#include <sys/mman.h>
#include "shared.h"
#include "elf.h"
#include "config.h"

void *memcpy(void *dest, void *src, size_t len);
off_t strlen(char *s);
void* memset(void *p, int val, size_t len);
int memcmp(const void *s1, const void *s2, size_t n);
char *strchr(const char *s, int c);

void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset);
int read(int fd, void *dest, size_t len);
int getpid(void);
int close(int fd);
int write(int fd, const void *data, size_t len);
void gettsc(uint32_t tsc[2]);
void *get_oep(char **base);
enum os_e get_os();

#ifndef ARCH_X86
#ifndef ARCH_AMD64
#ifndef ARCH_ARM
/* X86 as a fallback */
#warning "No architecture defined !"
#define ARCH_X86
#endif
#endif
#endif

#if defined(ARCH_X86) || defined(ARCH_ARM)
typedef Elf32_auxv_t Elf_auxv_t;

typedef Elf32_Ehdr Elf_Ehdr;
typedef Elf32_Phdr Elf_Phdr;
typedef Elf32_Addr Elf_Addr;
typedef struct stub_data_32 stub_data;

#endif
#ifdef ARCH_AMD64
typedef Elf64_auxv_t Elf_auxv_t;

typedef Elf64_Ehdr Elf_Ehdr;
typedef Elf64_Phdr Elf_Phdr;
typedef Elf64_Addr Elf_Addr;
typedef struct stub_data_64 stub_data;
#endif

#endif

/* Linux */
#define TCGETS 0x5401
#define TCSETS 0x5402
/* FreeBSD */
#define TIOCGETA 0x402c7413
#define TIOCSETA 0x802c7414
typedef unsigned char   cc_t;
typedef unsigned int    speed_t;
typedef unsigned int    tcflag_t;

#define NCCS 19
struct termios {
        tcflag_t c_iflag;               /* input mode flags */
        tcflag_t c_oflag;               /* output mode flags */
        tcflag_t c_cflag;               /* control mode flags */
        tcflag_t c_lflag;               /* local mode flags */
        cc_t c_line;                    /* line discipline */
        cc_t c_cc[NCCS];                /* control characters */
	    speed_t     c_ispeed;   /* input speed */
    	speed_t     c_ospeed;   /* output speed */
};

#define LINUX_ECHO 0x08
#define FREEBSD_ECHO 0x08
int ioctl(int fd, int code, void *param);

```

`src/packer/CMakeLists.txt`:

```txt
project(midgetpack C)

set(midgetpack_SRCS
	crypto.c
	elf.c
	midgetpack.c
)

set(mpkex_SRCS
	crypto.c
	mpkex.c
)

include_directories(
	${MPACK_INCLUDE_DIRS}
)

add_executable(midgetpack ${midgetpack_SRCS})
target_link_libraries(midgetpack ${MP_SHARED_STATIC_LIBRARY} ${MP_STUBS} ${ARGP_LIBRARY})

add_executable(mpkex ${mpkex_SRCS})
target_link_libraries(mpkex ${MP_SHARED_STATIC_LIBRARY} ${ARGP_LIBRARY})


```

`src/packer/crypto.c`:

```c
/*
 * Copyright 2014 Aris Adamantiadis <aris@badcode.be>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include "midgetpack.h"
#include "sha256.h"
#include "aes.h"

int get_random(uint8_t *dest, size_t len){
	int fd;
	int rc;
	fd=open("/dev/urandom",O_RDONLY);
	if (fd < 0){
		perror("Opening /dev/urandom");
	}
	rc = read(fd, dest, len);
	close(fd);
	if(rc != (int)len)
		return -1;
	else
		return 0;
}

char *ask_password(void){
	char *p1, *p2;
	char *p;
	p=getpass("Please enter password:");
	p1=strdup(p);
	memset_s(p,0,strlen(p));

	p=getpass("Enter the password again:");
	p2=strdup(p);
	memset_s(p,0,strlen(p));

	if (strcmp(p1,p2)!= 0){
		printf("Passwords do not match\n");
		memset_s(p2,0,strlen(p2));
		memset_s(p1,0,strlen(p1));
		free(p2);
		free(p1);
		return NULL;
	}

	memset_s(p2,0,strlen(p2));
	free(p2);
	return p1;
}

#ifdef CRYPTO_DEBUG
void print_key(const char *name, uint8_t *key, int len){
	int i;
	uint32_t *v=(uint32_t *)key;
	printf("key %s: ",name);
	for (i=0;i<len/4;++i){
		printf("%x ", v[i]);
	}
	printf("\n");
}
#endif

void encrypt_payload(void *payload, size_t len, uint8_t encryptkey[16], uint8_t IV[16]){
	AES_CTX ctx;
	AES_set_key(&ctx, encryptkey, IV, AES_MODE_128);
#ifdef CRYPTO_DEBUG
	printf("Aes_encrypt (%x %d) = ", *(uint32_t *)payload, (int)len);
#endif
	/* do the encryption in-place to spare memory */
	AES_cbc_encrypt(&ctx, payload, payload, len);
#ifdef CRYPTO_DEBUG
	printf("%x\n", *(uint32_t *)payload);
#endif
}

int generate_password_parameters(uint8_t encryption_salt[8], uint8_t password_salt[8]){
	int rc;
	rc = get_random(encryption_salt, 8);
	rc |= get_random(password_salt, 8);
	if (rc != 0){
		printf("Error getting entropy\n");
		return -1;
	}
	return 0;
}

int generate_curve25519_parameters(uint8_t encryption_salt[8],
		uint8_t master_key[AES128_KEY_LEN],
		uint8_t authentication_key[AES128_KEY_LEN]){
	int rc;
	rc = get_random(encryption_salt, 8);
	rc |= get_random(master_key, AES128_KEY_LEN);
	rc |= get_random(authentication_key, AES128_KEY_LEN);
	if (rc != 0){
		printf("Error getting entropy\n");
		return -1;
	}
	return 0;
}

```

`src/packer/elf.c`:

```c
/*
 * Copyright 2014 Aris Adamantiadis <aris@badcode.be>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>
#include "midgetpack.h"
#include "elf.h"

struct elf_file_s *elf_file_open(const char *filename){
  int fd = -1;
  struct elf_file_s *file = NULL;
  struct stat statbuf;
  size_t r;
  off_t total=0;
  int pad;
  unsigned char buffer[4096];

  fd = open(filename, O_RDONLY);
  if (fd < 0){
    perror("Opening file");
    goto err;
  }
  file = malloc(sizeof(struct elf_file_s));
  if(file == NULL)
    goto err;
  memset(file, 0, sizeof(*file));

  if (fstat(fd, &statbuf) < 0){
    perror("fstat");
    goto err;
  }
  file->size = statbuf.st_size;
  /* leave enough space for padding */
  pad = (16 - file->size%16)% 16;
  /* blocks must be 16 bytes padded */
  file->size += pad;

  file->data = malloc(file->size);
  if (file->data == NULL){
    fprintf(stderr, "Could not allocate memory\n");
    goto err;
  }
  while (total < statbuf.st_size){
    size_t s = (size_t)(statbuf.st_size - total) >  sizeof(buffer) ? sizeof(buffer) : (size_t)(statbuf.st_size - total);
    r = read(fd, buffer, s);
    if (r <= 0){
      perror("reading file");
      goto err;
    }
    memcpy(file->data + total, buffer, r);
    total += r;
  }
  memset(file->data + statbuf.st_size, 0, pad);
  return file;

err:
  if(file != NULL){
    if(file->data != NULL){
      free(file->data);
      file->data = NULL;
    }
    free(file);
    file = NULL;
  }
  if (fd >= 0)
    close(fd);
  return NULL;
}

void elf_file_free(struct elf_file_s *file){
  if(file != NULL) {
    if(file->data != NULL){
      free(file->data);
      file->data = NULL;
    }
    free(file);
  }
}

enum architecture_e elf_get_arch(struct elf_file_s *file){
  Elf32_Ehdr *header32 = (Elf32_Ehdr *)file->data;
  Elf64_Ehdr *header64 = (Elf64_Ehdr *)file->data;
  if (file->size < sizeof(*header32))
    return ARCH_INVALID;
  if (memcmp(header32->e_ident, ELFMAG, 4) != 0)
    return ARCH_INVALID;
  switch(header32->e_ident[EI_CLASS]) {
    case ELFCLASS32:
      if (header32->e_machine == EM_386){
        file->arch = ARCH_x86;
        return ARCH_x86;
      }
      if (header32->e_machine == EM_ARM){
    	  file->arch = ARCH_ARM;
    	  return ARCH_ARM;
      }
      return ARCH_UNSUPPORTED;
    case ELFCLASS64:
      if(file->size < sizeof(*header64)){
        return ARCH_INVALID;
      }
      if(header64->e_machine == EM_X86_64){
        file->arch = ARCH_AMD64;
        return ARCH_AMD64;
      }
      return ARCH_UNSUPPORTED;
  }
  return ARCH_INVALID;
}

enum os_e elf_get_os(struct elf_file_s *file){
  Elf32_Ehdr *header32 = (Elf32_Ehdr *)file->data;
  if (file->size < sizeof(*header32))
    return OS_INVALID;
  if (memcmp(header32->e_ident, ELFMAG, 4) != 0)
    return OS_INVALID;
  switch(header32->e_ident[EI_OSABI]) {
    case ELFOSABI_FREEBSD:
      return OS_FREEBSD;
    case ELFOSABI_LINUX:
    case ELFOSABI_SYSV:
      return OS_LINUX;
    default:
      return OS_UNSUPPORTED;
  }
  return OS_INVALID;
}

/** @brief overwrite the OS definition in the ELF header
 * of the stub, so it runs in the required OS.
 */
void elf_set_os(uint8_t *stub, enum os_e os){
	/* ELF32 and ELF64 use common fields for ABI */
	Elf32_Ehdr *header = (Elf32_Ehdr *)stub;
	switch(os){
	case OS_LINUX:
		header->e_ident[EI_OSABI] = ELFOSABI_SYSV;
		break;
	case OS_FREEBSD:
		header->e_ident[EI_OSABI] = ELFOSABI_FREEBSD;
		break;
	default:
		printf("Invalid OS %d\n", os);
	}
}

#define ELF_ADD_PHEADER(BITS) \
	void elf_add_pheader_ ## BITS (unsigned char *stub, uint ## BITS ## _t vaddr, \
			uint ## BITS ## _t offset, size_t len){ \
		Elf ## BITS ## _Ehdr *header = (Elf ## BITS ## _Ehdr *)stub; \
		Elf ## BITS ## _Phdr *pheader = (Elf ## BITS ## _Phdr *)(stub + header->e_phoff + \
				header->e_phnum * header->e_phentsize); \
		printf("Adding new pheader with vaddr base %" PRIu64 ", offset %" PRIu64 " of filesz %" PRIu32 "\n",\
			(int64_t)vaddr, (int64_t)offset, (uint32_t)len);\
		pheader->p_type = PT_LOAD;\
		pheader->p_offset = offset;\
		pheader->p_vaddr = vaddr + offset;\
		pheader->p_paddr = vaddr + offset;\
		pheader->p_filesz = len;\
		pheader->p_memsz = len;\
		pheader->p_flags = PF_R | PF_W | PF_X;\
		pheader->p_align = 0x1000;\
		header->e_phnum++;\
}

ELF_ADD_PHEADER(32)
ELF_ADD_PHEADER(64)



```

`src/packer/midgetpack.c`:

```c
/*
 * Copyright 2014 Aris Adamantiadis <aris@badcode.be>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <stdio.h>
#include <string.h>
#include <argp.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include "midgetpack.h"
#include "shared.h"
#include "sha256.h"
#include "aes.h"

const char *argp_program_version = "midgetpack 0.1 (c) Aris Adamantiadis";
const char args_doc[] = "file";
const char doc[] ="Midgetpack: an ELF file packer.\nSupported architectures:\n"
#ifdef HAVE_LINUX_X86
		"  linux/x86\n"
#endif
#ifdef HAVE_LINUX_AMD64
		"  linux/amd64\n"
#endif
#ifdef HAVE_LINUX_ARMV6
		"  linux/armv6\n"
#endif
#ifdef HAVE_FREEBSD_X86
		"  freebsd/x86\n"
#endif
#ifdef HAVE_FREEBSD_AMD64
		"  freebsd/amd64\n"
#endif
		"";

/* understood options */
static struct argp_option options[]={
	{
		.name="usepassword",
		.key='p',
		.arg=NULL,
		.flags=0,
		.doc="Use password encryption (default)",
		.group=1
	}, {
		.name="password",
		.key='P',
		.arg="password",
		.flags=0,
		.doc="Use this password (don't ask)",
		.group=1
	}, {
		.name="iterations",
		.key='i',
		.arg="iterations",
		.flags=0,
		.doc="Hash password with n iterations (default=20000)",
		.group=1
	}, {
		.name="curve25519",
		.key='c',
		.arg=NULL,
		.flags=0,
		.doc="Use curve25519 key exchange",
		.group=2
	}, {
		.name="output",
		.key='o',
		.arg="file",
		.flags=0,
		.doc="Output file [a.out]",
		.group=0
	}, {
		.name="keyfile",
		.key='k',
		.arg="keyfile",
		.flags=0,
		.doc="Output key file [key]",
		.group=2
	},
	{
		.name="banner",
		.key='b',
		.arg="bannerfile",
		.flags=0,
		.doc="Banner to show upon starting",
		.group=0
	},
	{NULL, 0, NULL, 0, NULL, 0}
};

struct config {
	enum pack_type pack_type;
	const char *outfile;
	char *keyfile;
	char *elffile;
	char *bannerfile;
	char *password;
	int loops;
} config = {
	.pack_type=PACK_TYPE_PASSWORD,
	.outfile="a.out",
	.keyfile=NULL,
	.elffile=NULL,
	.bannerfile=NULL,
	.password=NULL,
	.loops=20000
};

static error_t parse_opt (int key, char *arg, struct argp_state *state) {
	switch(key){
	case 'p':
		config.pack_type=PACK_TYPE_PASSWORD;
		break;
	case 'c':
		config.pack_type=PACK_TYPE_CURVE25519;
		break;
	case 'o':
		config.outfile=arg;
		break;
	case 'k':
		config.keyfile=arg;
		break;
	case 'b':
		config.bannerfile=arg;
		break;
	case 'P':
		config.pack_type=PACK_TYPE_PASSWORD;
		config.password = arg;
		break;
	case 'i':
		config.pack_type = PACK_TYPE_PASSWORD;
		config.loops = atoi(arg);
		if (config.loops <= 0){
			printf("iterations parameter must be a positive integer\n");
			return -1;
		}
		break;
	case ARGP_KEY_ARG:
		config.elffile = arg;
		break;
	case ARGP_KEY_END:
		if (state->arg_num < 1) {
			/* Not enough arguments. */
			argp_usage (state);
		}
		break;
	default:
		return ARGP_ERR_UNKNOWN;
	}
	return 0;
}
static struct argp argp = {options, parse_opt, args_doc, doc, NULL, NULL, NULL};

static int build_packed_file(struct elf_file_s *file);

int main(int argc, char **argv) {
  struct elf_file_s *file;
  argp_parse (&argp, argc, argv, 0, 0, NULL);

  file = elf_file_open(config.elffile);
  if (file == NULL)
    return 1;
  switch (elf_get_arch(file)){
    case ARCH_x86:
      printf("x86 ELF file\n");
      break;
    case ARCH_AMD64:
      printf("amd64 ELF file\n");
      break;
    case ARCH_ARM:
      printf("arm ELF file\n");
      break;
    case ARCH_INVALID:
      printf("Invalid ELF file\n");
      break;
    case ARCH_UNSUPPORTED:
      printf("Unsupported ELF architecture\n");
      break;
  }
  build_packed_file(file);
  elf_file_free(file);
  return 0;
}

#ifdef HAVE_LINUX_X86
extern unsigned char _binary_stub_linux_x86_start[];
extern size_t _binary_stub_linux_x86_size;
#endif

#ifdef HAVE_FREEBSD_X86
extern unsigned char _binary_stub_freebsd_x86_start[];
extern size_t _binary_stub_freebsd_x86_size;
#endif

#ifdef HAVE_LINUX_AMD64
extern unsigned char _binary_stub_linux_amd64_start[];
extern size_t _binary_stub_linux_amd64_size;
#endif

#ifdef HAVE_FREEBSD_AMD64
extern unsigned char _binary_stub_freebsd_amd64_start[];
extern size_t _binary_stub_freebsd_amd64_size;
#endif

#ifdef HAVE_LINUX_ARMV6
extern unsigned char _binary_stub_linux_armv6_start[];
extern size_t _binary_stub_linux_armv6_size;
#endif

enum stubs_enum {
#ifdef HAVE_LINUX_X86
	STUB_LINUX_X86 = 0,
#endif
#ifdef HAVE_FREEBSD_X86
	STUB_FREEBSD_X86,
#endif
#ifdef HAVE_LINUX_AMD64
	STUB_LINUX_AMD64,
#endif
#ifdef HAVE_FREEBSD_AMD64
	STUB_FREEBSD_AMD64,
#endif
#ifdef HAVE_LINUX_ARMV6
	STUB_LINUX_ARMV6,
#endif
	STUB_END
};

struct stub {
	uint8_t *base;
	size_t size;
} stubs[]={
#ifdef HAVE_LINUX_X86
	{
		.base= _binary_stub_linux_x86_start,
		.size=(size_t) &_binary_stub_linux_x86_size
	},
#endif
#ifdef HAVE_FREEBSD_X86
	{
		.base= _binary_stub_freebsd_x86_start,
		.size=(size_t) &_binary_stub_freebsd_x86_size
	},
#endif
#ifdef HAVE_LINUX_AMD64
	{
		.base=_binary_stub_linux_amd64_start,
		.size=(size_t) &_binary_stub_linux_amd64_size
	},
#endif
#ifdef HAVE_FREEBSD_AMD64
	{
		.base=_binary_stub_freebsd_amd64_start,
		.size=(size_t) &_binary_stub_freebsd_amd64_size
	},
#endif
#ifdef HAVE_LINUX_ARMV6
	{
		.base=_binary_stub_linux_armv6_start,
		.size=(size_t) &_binary_stub_linux_armv6_size
	},
#endif
	{ NULL, 0 }
};

static int update_descriptor(enum architecture_e arch, unsigned char *stub,
		size_t size, struct stub_data_64 *tmpdesc){
	struct stub_data_32 *desc;
	size_t i;
	for(i=0;i<size-sizeof(*desc);++i){ 
		desc=(struct stub_data_32 *)&stub[i];
		if(desc->magic == MAGIC){
			break;
		}
	}
	if (desc == NULL)
		return -1;
	if (arch == ARCH_AMD64){
		/* desc is in fact a 64 bits desc */
		memcpy(desc, tmpdesc, sizeof(*tmpdesc));
	} else {
		desc->data_base = tmpdesc->data_base;
		desc->data_len = tmpdesc->data_len;
		desc->banner_addr = tmpdesc->banner_addr;
		desc->banner_len = tmpdesc->banner_len;
		desc->type = tmpdesc->type;
		desc->hash_loops = tmpdesc->hash_loops;
		memcpy(desc->checksum, tmpdesc->checksum, sizeof(desc->checksum));
		memcpy(desc->password_salt, tmpdesc->password_salt, sizeof(desc->password_salt));
		memcpy(desc->encryption_salt, tmpdesc->encryption_salt, sizeof(desc->encryption_salt));
		memcpy(desc->authentication_key, tmpdesc->authentication_key, sizeof(desc->authentication_key));
	}
	return 0;
}

static int build_password(struct elf_file_s *file, struct stub_data_64 *desc){
	uint8_t encryptkey[AES128_KEY_LEN], IV[AES128_KEY_LEN], integrity[16];
	char *password;
	int rc;

	if (config.password != NULL) {
		password = config.password;
	} else {
		password = ask_password();
		if(password == NULL)
			return -1;
	}
	rc = generate_password_parameters(desc->encryption_salt, desc->password_salt);
	if (rc != 0)
		return -1;
	compute_session_keys_password(
			password, config.loops,
			encryptkey, IV, integrity,
			desc->encryption_salt,
			desc->password_salt);
#ifdef CRYPTO_DEBUG
	print_key("encrypt_salt", desc->encryption_salt, sizeof(desc->encryption_salt));
	print_key("password salt", desc->password_salt, sizeof(desc->password_salt));
	print_key("enckey", encryptkey, AES128_KEY_LEN);
	print_key("IV", IV, AES128_KEY_LEN);
	print_key("integrity", integrity, AES128_KEY_LEN);
#endif
	compute_checksum(file->data, file->size, integrity, desc->checksum);
#ifdef CRYPTO_DEBUG
	print_key("checksum", desc->checksum, 32);
#endif
	encrypt_payload(file->data, file->size, encryptkey, IV);
	return 0;
}

static int build_curve25519(struct elf_file_s *file, struct stub_data_64 *desc){
	uint8_t encryptkey[AES128_KEY_LEN], IV[AES128_KEY_LEN], integrity[AES128_KEY_LEN];
	struct key_file keydata;
	char keyfile[128];
	int rc;
	int i=1;
	FILE *f;

	ZERO(keydata);
	rc = generate_curve25519_parameters(desc->encryption_salt, keydata.master_key,
			desc->authentication_key);
	if (rc != 0)
		return -1;
	compute_session_keys(
			encryptkey, IV, integrity,
			keydata.master_key,
			desc->encryption_salt
			);
#ifdef CRYPTO_DEBUG
	print_key("enckey", encryptkey, AES128_KEY_LEN);
	print_key("IV", IV, AES128_KEY_LEN);
	print_key("integrity", integrity, AES128_KEY_LEN);
#endif
	compute_checksum(file->data, file->size, integrity, desc->checksum);
#ifdef CRYPTO_DEBUG
	print_key("checksum", desc->checksum, 32);
#endif
	encrypt_payload(file->data, file->size, encryptkey, IV);
	if(config.keyfile == NULL){
		snprintf(keyfile, sizeof(keyfile), "%s", "key");
		while(1){
			if(access(keyfile, F_OK) == 0){
				snprintf(keyfile, sizeof(keyfile),"key.%d",i);
				++i;
			} else {
				break;
			}
		}
	} else {
		snprintf(keyfile, sizeof(keyfile), "%s", config.keyfile);
	}
	f = fopen(keyfile,"w");
	if(f == NULL){
		printf("Error opening %s\n",keyfile);
		return -1;
	}
	keydata.magic[0]=KEY_FILE_MAGIC_0;
	keydata.magic[1]=KEY_FILE_MAGIC_1;
	keydata.magic[2]=KEY_FILE_MAGIC_2;
	keydata.magic[3]=KEY_FILE_MAGIC_3;
	snprintf(keydata.filename, sizeof(keydata.filename), "%s", keyfile);
	memcpy(keydata.authentication_key, desc->authentication_key,
			sizeof(desc->authentication_key));
	fwrite(&keydata, sizeof(keydata),1, f);
	fclose(f);
	printf("Key data written in file %s\n",keyfile);
	ZERO(keydata);
	ZERO(encryptkey);
	ZERO(IV);
	ZERO(integrity);
	return 0;
}

static int get_banner(char **banner, size_t *size){
	char buffer[4096];
	FILE *f;
	int r;

	if(config.bannerfile == NULL){
		*banner = NULL;
		*size = 0;
		return 0;
	}
	f = fopen(config.bannerfile, "r");
	if(f == NULL){
		printf("Cannot open banner file %s\n",config.bannerfile);
		return -1;
	}
	r=fread(buffer,1,sizeof(buffer)-1, f);
	fclose(f);
	if (r<0){
		printf("Error while reading banner file\n");
		return -1;
	}
	if (r==0){
		*banner=NULL;
		*size=0;
		return 0;
	}
	buffer[r]='\0';
	*size=r;
	*banner=malloc(r+1);
	memcpy(*banner, buffer, r+1);
	return 0;
}

static int build_packed_file(struct elf_file_s *file){
	unsigned char *stub;
	size_t size;
	int out;
	struct stub_data_64 tmp_desc;
	char *banner;
	size_t bannersize=0;
	enum architecture_e arch;
	enum os_e os;
	int rc;

	arch = elf_get_arch(file);
	os = elf_get_os(file);

	if (get_banner(&banner, &bannersize) < 0)
		return -1;
	if(banner != NULL)
		printf("banner: %d\n", (int)bannersize);
	switch (arch){
	case ARCH_x86:
		switch(os){
#ifdef HAVE_LINUX_X86
		case OS_LINUX:
			stub = stubs[STUB_LINUX_X86].base;
			size = stubs[STUB_LINUX_X86].size;
			elf_add_pheader_32(stub, BASE_ADDR + 4096, size, file->size + bannersize);
			break;
#endif
#ifdef HAVE_FREEBSD_X86
		case OS_FREEBSD:
			stub = stubs[STUB_FREEBSD_X86].base;
			size = stubs[STUB_FREEBSD_X86].size;
			elf_add_pheader_32(stub, BASE_ADDR + 4096, size, file->size + bannersize);
			break;
#endif
		default:
			printf("unsupported OS\n");
			break;
		}
		break;
	case ARCH_AMD64:
		switch(os){
		case OS_LINUX:
#ifdef HAVE_LINUX_AMD64
			stub = stubs[STUB_LINUX_AMD64].base;
			size = stubs[STUB_LINUX_AMD64].size;
			elf_add_pheader_64(stub, BASE_ADDR + 4096, size, file->size + bannersize);
			break;
#endif
		case OS_FREEBSD:
#ifdef HAVE_FREEBSD_AMD64
			stub = stubs[STUB_FREEBSD_AMD64].base;
			size = stubs[STUB_FREEBSD_AMD64].size;
			elf_add_pheader_64(stub, BASE_ADDR + 4096, size, file->size + bannersize);
			break;
#endif
		default:
			printf("Unsupported OS\n");
			break;
		}
		break;
		case ARCH_ARM:
			switch(os){
	#ifdef HAVE_LINUX_ARMV6
			case OS_LINUX:
				stub = stubs[STUB_LINUX_ARMV6].base;
				size = stubs[STUB_LINUX_ARMV6].size;
				elf_add_pheader_32(stub, BASE_ADDR + 4096, size, file->size + bannersize);
				break;
	#endif
			default:
				printf("Unsupported OS\n");
				break;
			}
		break;
	default:
		printf("Unsupported architecture\n");
		return -1;
	}

	tmp_desc.data_base = BASE_ADDR + size + 4096;
	tmp_desc.data_len = file->size;
	tmp_desc.banner_addr = tmp_desc.data_base + tmp_desc.data_len;
	tmp_desc.banner_len = bannersize;
	tmp_desc.type = config.pack_type;
	tmp_desc.hash_loops = config.loops;
	switch(config.pack_type){
	case PACK_TYPE_PASSWORD:
		rc = build_password(file, &tmp_desc);
		break;
	case PACK_TYPE_CURVE25519:
		rc = build_curve25519(file, &tmp_desc);
		break;
	}
	if (rc != 0)
		return rc;
	update_descriptor(arch, stub, size, &tmp_desc);
	elf_set_os(stub, os);
	out = open(config.outfile,O_WRONLY | O_CREAT,0755);
	if(out < 0){
		printf("Cannot open output file %s\n", config.outfile);
		return -1;
	}
	write(out, stub, size);
	write(out, file->data, file->size);
	if (banner != NULL)
		write(out, banner, bannersize);
	close(out);
	free(banner);
	return 0;
}

```

`src/packer/mpkex.c`:

```c
/*
 * Copyright 2014 Aris Adamantiadis <aris@badcode.be>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <stdio.h>
#include <string.h>
#include <argp.h>
#include <unistd.h>
#include <fcntl.h>
#include "midgetpack.h"
#include "shared.h"
#include "sha256.h"
#include "aes.h"

const char *argp_program_version = "midgetpack key exchange 0.1 (c) Aris Adamantiadis";
const char args_doc[] = "keyfile";
const char doc[] ="Midgetpack key exchange)";

/* understood options */
static struct argp_option options[]={
	{NULL, 0, NULL, 0, NULL, 0}
};

struct config {
	char *keyfile;
} config = {
	.keyfile=NULL,
};

static error_t parse_opt (int key, char *arg, struct argp_state *state) {
	switch(key){
	case ARGP_KEY_ARG:
		config.keyfile = arg;
		break;
	case ARGP_KEY_END:
		if (state->arg_num < 1) {
			/* Not enough arguments. */
			argp_usage (state);
		}
		break;
	default:
		return ARGP_ERR_UNKNOWN;
	}
	return 0;
}
static struct argp argp = {options, parse_opt, args_doc, doc, NULL, NULL, NULL};
struct key_file keyfile;

int main(int argc, char **argv) {
	int r;
	int fd;
	char buffer[128];
	struct curve25519_request req;
	struct curve25519_reply reply;
	uint8_t authentication[SHA256_DIGEST_LEN];
	uint8_t shared_secret[CURVE25519_KEY_LEN];
	uint8_t private[CURVE25519_KEY_LEN];
	HMAC_SHA256_CTX ctx;
	AES_CTX aes;
	char *ptr;

	argp_parse (&argp, argc, argv, 0, 0, NULL);
	fd=open(config.keyfile, O_RDONLY);
	if (fd < 0){
		printf("Cannot open file %s\n",config.keyfile);
		return 1;
	}
	r = read(fd, &keyfile, sizeof(keyfile));
	if (r != sizeof(keyfile)){
		printf("Cannot read keyfile (file too short ?)\n");
		return 1;
	}
	close(fd);
	if ((keyfile.magic[0] != KEY_FILE_MAGIC_0) ||
			(keyfile.magic[1] != KEY_FILE_MAGIC_1) ||
			(keyfile.magic[2] != KEY_FILE_MAGIC_2) ||
			(keyfile.magic[3] != KEY_FILE_MAGIC_3)) {
		printf("Wrong magic\n");
		return 1;
	}
	printf("Waiting for challenge...\n");
	r = read(0, buffer, sizeof(buffer));
	ptr=strchr(buffer,'\n');
	if(ptr != NULL)
		*ptr = '\0';
	ptr=strchr(buffer,'\r');
	if(ptr != NULL)
		*ptr = '\0';
	b64_decode((uint8_t *)&req, sizeof(req), buffer, strlen(buffer));
	HMAC_SHA256_Init(&ctx, keyfile.authentication_key,
			sizeof(keyfile.authentication_key));
	HMAC_SHA256_Update(&ctx, req.pubkey, sizeof(req.pubkey));
	HMAC_SHA256_Final(authentication, &ctx);
	if(memcmp(authentication, req.authentication, sizeof(req.authentication)) != 0){
		printf("MAC authentication error\n");
#ifdef CRYPTO_DEBUG
		print_key("authentication key", keyfile.authentication_key, sizeof(keyfile.authentication_key));
		print_key("pubkey", req.pubkey, sizeof(req.pubkey));
		print_key("expected", req.authentication, sizeof(req.authentication));
		print_key("calculated", authentication, 16);
#endif
		return 1;
	}
	get_random(private, sizeof(private));
	crypto_scalarmult_base(reply.pubkey, private);
	crypto_scalarmult(shared_secret, private, req.pubkey);
	AES_set_key(&aes, &shared_secret[0], &shared_secret[16], AES_MODE_128);
	AES_cbc_encrypt(&aes, keyfile.master_key, reply.encrypted_master, AES_BLOCKSIZE);

#ifdef CRYPTO_DEBUG
	print_key("shared secret", shared_secret, sizeof(shared_secret));
	print_key("master key", keyfile.master_key, sizeof(keyfile.master_key));
	print_key("encrypted master key", reply.encrypted_master,
			sizeof(reply.encrypted_master));
#endif

	HMAC_SHA256_Init(&ctx, keyfile.authentication_key,
			sizeof(keyfile.authentication_key));
	HMAC_SHA256_Update(&ctx, shared_secret, CURVE25519_KEY_LEN);
	HMAC_SHA256_Update(&ctx, reply.encrypted_master, AES128_KEY_LEN);
	HMAC_SHA256_Final(authentication, &ctx);
	memcpy(reply.authentication, authentication, sizeof(reply.authentication));
	b64_encode(buffer,sizeof(buffer),(uint8_t *)&reply, sizeof(reply));
	printf("Response:\n%s\n",buffer);
	return 0;
}

```

`src/shared/CMakeLists.txt`:

```txt
project(mpack-shared C)

set(MP_SHARED_STATIC_LIBRARY
	mp_shared_static
	CACHE INTERNAL "midgetpack-shared static library"
)

set(mp_shared_SRCS
	aes.c
	crypto.c
	curve25519_ref.c
	sha256.c
)

include_directories(
	${MPACK_INCLUDE_DIRS}
)

add_library(${MP_SHARED_STATIC_LIBRARY} STATIC ${mp_shared_SRCS})
set_target_properties(
	${MP_SHARED_STATIC_LIBRARY}
	PROPERTIES
	OUTPUT_NAME
	shared
	ARCHIVE_OUTPUT_DIRECTORY
	${CMAKE_CURRENT_BINARY_DIR}/${OUTPUT_SUFFIX}
	COMPILE_FLAGS
	"-O2 -g"
)

if(WITH_STUB_DEBUG)
	set (FLAGS "-O0 -g -fno-stack-protector")
else(WITH_STUB_DEBUG)
	set (FLAGS "-Os -fno-stack-protector")
endif(WITH_STUB_DEBUG)
If(CCOMPILER_64)

set(MP_SHARED_STATIC_LIBRARY_AMD64
	mp_shared_static_amd64
	CACHE INTERNAL "midgetpack-shared_amd64 static library"
)

add_library(${MP_SHARED_STATIC_LIBRARY_AMD64} STATIC ${mp_shared_SRCS})
set_target_properties(
	${MP_SHARED_STATIC_LIBRARY_AMD64}
	PROPERTIES
	OUTPUT_NAME
	shared_amd64
	ARCHIVE_OUTPUT_DIRECTORY
	${CMAKE_CURRENT_BINARY_DIR}/${OUTPUT_SUFFIX}
	COMPILE_FLAGS
	"${FLAGS} -m64"
)

Endif(CCOMPILER_64)

If(CCOMPILER_32)

set(MP_SHARED_STATIC_LIBRARY_X86
	mp_shared_static_x86
	CACHE INTERNAL "midgetpack-shared_x86 static library"
)

add_library(${MP_SHARED_STATIC_LIBRARY_X86} STATIC ${mp_shared_SRCS})
set_target_properties(
	${MP_SHARED_STATIC_LIBRARY_X86}
	PROPERTIES
	OUTPUT_NAME
	shared_x86
	ARCHIVE_OUTPUT_DIRECTORY
	${CMAKE_CURRENT_BINARY_DIR}/${OUTPUT_SUFFIX}
	COMPILE_FLAGS
	"${FLAGS} -m32"
)

Endif(CCOMPILER_32)

If(CCOMPILER_ARMV6)

set(MP_SHARED_STATIC_LIBRARY_ARMV6
	mp_shared_static_armv6
	CACHE INTERNAL "midgetpack-shared_armv6 static library"
)

add_library(${MP_SHARED_STATIC_LIBRARY_ARMV6} STATIC ${mp_shared_SRCS})
set_target_properties(
	${MP_SHARED_STATIC_LIBRARY_ARMV6}
	PROPERTIES
	OUTPUT_NAME
	shared_armv6
	ARCHIVE_OUTPUT_DIRECTORY
	${CMAKE_CURRENT_BINARY_DIR}/${OUTPUT_SUFFIX}
	COMPILE_FLAGS
	"${FLAGS} -march=armv6"
)

Endif(CCOMPILER_ARMV6)


```

`src/shared/aes.c`:

```c
/*
 * Copyright (c) 2007, Cameron Rich
 * 
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, 
 *   this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice, 
 *   this list of conditions and the following disclaimer in the documentation 
 *   and/or other materials provided with the distribution.
 * * Neither the name of the axTLS project nor the names of its contributors 
 *   may be used to endorse or promote products derived from this software 
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * AES implementation - this is a small code version. There are much faster
 * versions around but they are much larger in size (i.e. they use large 
 * submix tables).
 */

#include <string.h>
//#include "os_port.h"
//#include "crypto.h"
#include "aes.h"

/* all commented out in skeleton mode */
#ifndef CONFIG_SSL_SKELETON_MODE

#define rot1(x) (((x) << 24) | ((x) >> 8))
#define rot2(x) (((x) << 16) | ((x) >> 16))
#define rot3(x) (((x) <<  8) | ((x) >> 24))

static inline uint32_t swap_bytes(uint32_t x){
	union {
		uint8_t b[4];
		uint32_t d;
	} u;
	u.b[0]=(x >> 24) & 0xff;
	u.b[1]=(x >> 16) & 0xff;
	u.b[2]=(x >> 8) & 0xff;
	u.b[3]=x & 0xff;
	return u.d;
}
/* 
 * This cute trick does 4 'mul by two' at once.  Stolen from
 * Dr B. R. Gladman <brg@gladman.uk.net> but I'm sure the u-(u>>7) is
 * a standard graphics trick
 * The key to this is that we need to xor with 0x1b if the top bit is set.
 * a 1xxx xxxx   0xxx 0xxx First we mask the 7bit,
 * b 1000 0000   0000 0000 then we shift right by 7 putting the 7bit in 0bit,
 * c 0000 0001   0000 0000 we then subtract (c) from (b)
 * d 0111 1111   0000 0000 and now we and with our mask
 * e 0001 1011   0000 0000
 */
#define mt  0x80808080
#define ml  0x7f7f7f7f
#define mh  0xfefefefe
#define mm  0x1b1b1b1b
#define mul2(x,t)	((t)=((x)&mt), \
			((((x)+(x))&mh)^(((t)-((t)>>7))&mm)))

#define inv_mix_col(x,f2,f4,f8,f9) (\
			(f2)=mul2(x,f2), \
			(f4)=mul2(f2,f4), \
			(f8)=mul2(f4,f8), \
			(f9)=(x)^(f8), \
			(f8)=((f2)^(f4)^(f8)), \
			(f2)^=(f9), \
			(f4)^=(f9), \
			(f8)^=rot3(f2), \
			(f8)^=rot2(f4), \
			(f8)^rot1(f9))

/*
 * AES S-box
 */
static const uint8_t aes_sbox[256] =
{
	0x63,0x7C,0x77,0x7B,0xF2,0x6B,0x6F,0xC5,
	0x30,0x01,0x67,0x2B,0xFE,0xD7,0xAB,0x76,
	0xCA,0x82,0xC9,0x7D,0xFA,0x59,0x47,0xF0,
	0xAD,0xD4,0xA2,0xAF,0x9C,0xA4,0x72,0xC0,
	0xB7,0xFD,0x93,0x26,0x36,0x3F,0xF7,0xCC,
	0x34,0xA5,0xE5,0xF1,0x71,0xD8,0x31,0x15,
	0x04,0xC7,0x23,0xC3,0x18,0x96,0x05,0x9A,
	0x07,0x12,0x80,0xE2,0xEB,0x27,0xB2,0x75,
	0x09,0x83,0x2C,0x1A,0x1B,0x6E,0x5A,0xA0,
	0x52,0x3B,0xD6,0xB3,0x29,0xE3,0x2F,0x84,
	0x53,0xD1,0x00,0xED,0x20,0xFC,0xB1,0x5B,
	0x6A,0xCB,0xBE,0x39,0x4A,0x4C,0x58,0xCF,
	0xD0,0xEF,0xAA,0xFB,0x43,0x4D,0x33,0x85,
	0x45,0xF9,0x02,0x7F,0x50,0x3C,0x9F,0xA8,
	0x51,0xA3,0x40,0x8F,0x92,0x9D,0x38,0xF5,
	0xBC,0xB6,0xDA,0x21,0x10,0xFF,0xF3,0xD2,
	0xCD,0x0C,0x13,0xEC,0x5F,0x97,0x44,0x17,
	0xC4,0xA7,0x7E,0x3D,0x64,0x5D,0x19,0x73,
	0x60,0x81,0x4F,0xDC,0x22,0x2A,0x90,0x88,
	0x46,0xEE,0xB8,0x14,0xDE,0x5E,0x0B,0xDB,
	0xE0,0x32,0x3A,0x0A,0x49,0x06,0x24,0x5C,
	0xC2,0xD3,0xAC,0x62,0x91,0x95,0xE4,0x79,
	0xE7,0xC8,0x37,0x6D,0x8D,0xD5,0x4E,0xA9,
	0x6C,0x56,0xF4,0xEA,0x65,0x7A,0xAE,0x08,
	0xBA,0x78,0x25,0x2E,0x1C,0xA6,0xB4,0xC6,
	0xE8,0xDD,0x74,0x1F,0x4B,0xBD,0x8B,0x8A,
	0x70,0x3E,0xB5,0x66,0x48,0x03,0xF6,0x0E,
	0x61,0x35,0x57,0xB9,0x86,0xC1,0x1D,0x9E,
	0xE1,0xF8,0x98,0x11,0x69,0xD9,0x8E,0x94,
	0x9B,0x1E,0x87,0xE9,0xCE,0x55,0x28,0xDF,
	0x8C,0xA1,0x89,0x0D,0xBF,0xE6,0x42,0x68,
	0x41,0x99,0x2D,0x0F,0xB0,0x54,0xBB,0x16,
};

/*
 * AES is-box
 */
static const uint8_t aes_isbox[256] = 
{
    0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,
    0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,
    0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,
    0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,
    0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,
    0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,
    0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,
    0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,
    0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,
    0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,
    0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,
    0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,
    0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,
    0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,
    0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,
    0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,
    0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,
    0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,
    0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,
    0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,
    0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,
    0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,
    0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,
    0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,
    0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,
    0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,
    0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,
    0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,
    0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,
    0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,
    0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,
    0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d
};

static const unsigned char Rcon[30]=
{
	0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,
	0x1b,0x36,0x6c,0xd8,0xab,0x4d,0x9a,0x2f,
	0x5e,0xbc,0x63,0xc6,0x97,0x35,0x6a,0xd4,
	0xb3,0x7d,0xfa,0xef,0xc5,0x91,
};

/* ----- static functions ----- */
static void AES_encrypt(const AES_CTX *ctx, uint32_t *data);
static void AES_decrypt(const AES_CTX *ctx, uint32_t *data);

/* Perform doubling in Galois Field GF(2^8) using the irreducible polynomial
   x^8+x^4+x^3+x+1 */
static unsigned char AES_xtime(uint32_t x)
{
	return (x&0x80) ? (x<<1)^0x1b : x<<1;
}

/**
 * Set up AES with the key/iv and cipher size.
 */
void AES_set_key(AES_CTX *ctx, const uint8_t *key, 
        const uint8_t *iv, AES_MODE mode)
{
    int i, ii;
    uint32_t *W, tmp, tmp2;
    const unsigned char *ip;
    int words;

    switch (mode)
    {
        case AES_MODE_128:
            i = 10;
            words = 4;
            break;

        case AES_MODE_256:
            i = 14;
            words = 8;
            break;

        default:        /* fail silently */
            return;
    }

    ctx->rounds = i;
    ctx->key_size = words;
    W = ctx->ks;
    for (i = 0; i < words; i+=2)
    {
        W[i+0]=	((uint32_t)key[ 0]<<24)|
            ((uint32_t)key[ 1]<<16)|
            ((uint32_t)key[ 2]<< 8)|
            ((uint32_t)key[ 3]    );
        W[i+1]=	((uint32_t)key[ 4]<<24)|
            ((uint32_t)key[ 5]<<16)|
            ((uint32_t)key[ 6]<< 8)|
            ((uint32_t)key[ 7]    );
        key += 8;
    }

    ip = Rcon;
    ii = 4 * (ctx->rounds+1);
    for (i = words; i<ii; i++)
    {
        tmp = W[i-1];

        if ((i % words) == 0)
        {
            tmp2 =(uint32_t)aes_sbox[(tmp    )&0xff]<< 8;
            tmp2|=(uint32_t)aes_sbox[(tmp>> 8)&0xff]<<16;
            tmp2|=(uint32_t)aes_sbox[(tmp>>16)&0xff]<<24;
            tmp2|=(uint32_t)aes_sbox[(tmp>>24)     ];
            tmp=tmp2^(((unsigned int)*ip)<<24);
            ip++;
        }

        if ((words == 8) && ((i % words) == 4))
        {
            tmp2 =(uint32_t)aes_sbox[(tmp    )&0xff]    ;
            tmp2|=(uint32_t)aes_sbox[(tmp>> 8)&0xff]<< 8;
            tmp2|=(uint32_t)aes_sbox[(tmp>>16)&0xff]<<16;
            tmp2|=(uint32_t)aes_sbox[(tmp>>24)     ]<<24;
            tmp=tmp2;
        }

        W[i]=W[i-words]^tmp;
    }

    /* copy the iv across */
    memcpy(ctx->iv, iv, 16);
}

/**
 * Change a key for decryption.
 */
void AES_convert_key(AES_CTX *ctx)
{
    int i;
    uint32_t *k,w,t1,t2,t3,t4;

    k = ctx->ks;
    k += 4;

    for (i= ctx->rounds*4; i > 4; i--)
    {
        w= *k;
        w = inv_mix_col(w,t1,t2,t3,t4);
        *k++ =w;
    }
}

/**
 * Encrypt a byte sequence (with a block size 16) using the AES cipher.
 */
void AES_cbc_encrypt(AES_CTX *ctx, const uint8_t *msg, uint8_t *out, int length)
{
    int i;
    uint32_t tin[4], tout[4], iv[4];

    memcpy(iv, ctx->iv, AES_IV_SIZE);
    for (i = 0; i < 4; i++)
        tout[i] = swap_bytes(iv[i]);

    for (length -= AES_BLOCKSIZE; length >= 0; length -= AES_BLOCKSIZE)
    {
        uint32_t msg_32[4];
        uint32_t out_32[4];
        memcpy(msg_32, msg, AES_BLOCKSIZE);
        msg += AES_BLOCKSIZE;

        for (i = 0; i < 4; i++)
            tin[i] = swap_bytes(msg_32[i])^tout[i];

        AES_encrypt(ctx, tin);

        for (i = 0; i < 4; i++)
        {
            tout[i] = tin[i]; 
            out_32[i] = swap_bytes(tout[i]);
        }

        memcpy(out, out_32, AES_BLOCKSIZE);
        out += AES_BLOCKSIZE;
    }

    for (i = 0; i < 4; i++)
        iv[i] = swap_bytes(tout[i]);
    memcpy(ctx->iv, iv, AES_IV_SIZE);
}

/**
 * Decrypt a byte sequence (with a block size 16) using the AES cipher.
 */
void AES_cbc_decrypt(AES_CTX *ctx, const uint8_t *msg, uint8_t *out, int length)
{
    int i;
    uint32_t tin[4], xor[4], tout[4], data[4], iv[4];

    memcpy(iv, ctx->iv, AES_IV_SIZE);
    for (i = 0; i < 4; i++)
        xor[i] = swap_bytes(iv[i]);

    for (length -= 16; length >= 0; length -= 16)
    {
        uint32_t msg_32[4];
        uint32_t out_32[4];
        memcpy(msg_32, msg, AES_BLOCKSIZE);
        msg += AES_BLOCKSIZE;

        for (i = 0; i < 4; i++)
        {
            tin[i] = swap_bytes(msg_32[i]);
            data[i] = tin[i];
        }

        AES_decrypt(ctx, data);

        for (i = 0; i < 4; i++)
        {
            tout[i] = data[i]^xor[i];
            xor[i] = tin[i];
            out_32[i] = swap_bytes(tout[i]);
        }

        memcpy(out, out_32, AES_BLOCKSIZE);
        out += AES_BLOCKSIZE;
    }

    for (i = 0; i < 4; i++)
        iv[i] = swap_bytes(xor[i]);
    memcpy(ctx->iv, iv, AES_IV_SIZE);
}

/**
 * Encrypt a single block (16 bytes) of data
 */
static void AES_encrypt(const AES_CTX *ctx, uint32_t *data)
{
    /* To make this code smaller, generate the sbox entries on the fly.
     * This will have a really heavy effect upon performance.
     */
    uint32_t tmp[4];
    uint32_t tmp1, old_a0, a0, a1, a2, a3, row;
    int curr_rnd;
    int rounds = ctx->rounds; 
    const uint32_t *k = ctx->ks;

    /* Pre-round key addition */
    for (row = 0; row < 4; row++)
        data[row] ^= *(k++);

    /* Encrypt one block. */
    for (curr_rnd = 0; curr_rnd < rounds; curr_rnd++)
    {
        /* Perform ByteSub and ShiftRow operations together */
        for (row = 0; row < 4; row++)
        {
            a0 = (uint32_t)aes_sbox[(data[row%4]>>24)&0xFF];
            a1 = (uint32_t)aes_sbox[(data[(row+1)%4]>>16)&0xFF];
            a2 = (uint32_t)aes_sbox[(data[(row+2)%4]>>8)&0xFF]; 
            a3 = (uint32_t)aes_sbox[(data[(row+3)%4])&0xFF];

            /* Perform MixColumn iff not last round */
            if (curr_rnd < (rounds - 1))
            {
                tmp1 = a0 ^ a1 ^ a2 ^ a3;
                old_a0 = a0;
                a0 ^= tmp1 ^ AES_xtime(a0 ^ a1);
                a1 ^= tmp1 ^ AES_xtime(a1 ^ a2);
                a2 ^= tmp1 ^ AES_xtime(a2 ^ a3);
                a3 ^= tmp1 ^ AES_xtime(a3 ^ old_a0);
            }

            tmp[row] = ((a0 << 24) | (a1 << 16) | (a2 << 8) | a3);
        }

        /* KeyAddition - note that it is vital that this loop is separate from
           the MixColumn operation, which must be atomic...*/ 
        for (row = 0; row < 4; row++)
            data[row] = tmp[row] ^ *(k++);
    }
}

/**
 * Decrypt a single block (16 bytes) of data
 */
static void AES_decrypt(const AES_CTX *ctx, uint32_t *data)
{ 
    uint32_t tmp[4];
    uint32_t xt0,xt1,xt2,xt3,xt4,xt5,xt6;
    uint32_t a0, a1, a2, a3, row;
    int curr_rnd;
    int rounds = ctx->rounds;
    const uint32_t *k = ctx->ks + ((rounds+1)*4);

    /* pre-round key addition */
    for (row=4; row > 0;row--)
        data[row-1] ^= *(--k);

    /* Decrypt one block */
    for (curr_rnd = 0; curr_rnd < rounds; curr_rnd++)
    {
        /* Perform ByteSub and ShiftRow operations together */
        for (row = 4; row > 0; row--)
        {
            a0 = aes_isbox[(data[(row+3)%4]>>24)&0xFF];
            a1 = aes_isbox[(data[(row+2)%4]>>16)&0xFF];
            a2 = aes_isbox[(data[(row+1)%4]>>8)&0xFF];
            a3 = aes_isbox[(data[row%4])&0xFF];

            /* Perform MixColumn iff not last round */
            if (curr_rnd<(rounds-1))
            {
                /* The MDS cofefficients (0x09, 0x0B, 0x0D, 0x0E)
                   are quite large compared to encryption; this 
                   operation slows decryption down noticeably. */
                xt0 = AES_xtime(a0^a1);
                xt1 = AES_xtime(a1^a2);
                xt2 = AES_xtime(a2^a3);
                xt3 = AES_xtime(a3^a0);
                xt4 = AES_xtime(xt0^xt1);
                xt5 = AES_xtime(xt1^xt2);
                xt6 = AES_xtime(xt4^xt5);

                xt0 ^= a1^a2^a3^xt4^xt6;
                xt1 ^= a0^a2^a3^xt5^xt6;
                xt2 ^= a0^a1^a3^xt4^xt6;
                xt3 ^= a0^a1^a2^xt5^xt6;
                tmp[row-1] = ((xt0<<24)|(xt1<<16)|(xt2<<8)|xt3);
            }
            else
                tmp[row-1] = ((a0<<24)|(a1<<16)|(a2<<8)|a3);
        }

        for (row = 4; row > 0; row--)
            data[row-1] = tmp[row-1] ^ *(--k);
    }
}

#endif

```

`src/shared/crypto.c`:

```c
/*
 * Copyright 2014 Aris Adamantiadis <aris@badcode.be>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <string.h>
#include <stdio.h>
#include "shared.h"
#include "sha256.h"

void memset_s(void *v, int c, size_t n) {
	volatile uint8_t *p = v;
	while (n--)
		*p++ = c;
}

void compute_session_keys(uint8_t encryptkey[AES128_KEY_LEN],
		uint8_t IV[AES128_KEY_LEN],
		uint8_t integrity[AES128_KEY_LEN],
		uint8_t master_key[AES128_KEY_LEN],
		uint8_t encryption_salt[8]){

	uint8_t long_encryptkey[SHA256_DIGEST_LEN];
	uint8_t	long_IV[SHA256_DIGEST_LEN];
	uint8_t long_integrity[SHA256_DIGEST_LEN];

	HMAC_SHA256_CTX ctx;

	HMAC_SHA256_Init(&ctx, master_key, AES128_KEY_LEN);
	HMAC_SHA256_Update(&ctx,encryption_salt, 8);
	HMAC_SHA256_Update(&ctx, "encryption", 10);
	HMAC_SHA256_Final(long_encryptkey, &ctx);

	HMAC_SHA256_Init(&ctx, master_key, AES128_KEY_LEN);
	HMAC_SHA256_Update(&ctx,encryption_salt, 8);
	HMAC_SHA256_Update(&ctx, "IV", 2);
	HMAC_SHA256_Final(long_IV, &ctx);

	HMAC_SHA256_Init(&ctx, master_key, AES128_KEY_LEN);
	HMAC_SHA256_Update(&ctx,encryption_salt, 8);
	HMAC_SHA256_Update(&ctx, "integrity", 9);
	HMAC_SHA256_Final(long_integrity, &ctx);

	memcpy(encryptkey, long_encryptkey, AES128_KEY_LEN);
	memcpy(IV, long_IV, AES128_KEY_LEN);
	memcpy(integrity, long_integrity, AES128_KEY_LEN);
	ZERO(long_encryptkey);
	ZERO(long_IV);
	ZERO(long_integrity);
	ZERO(ctx);
}

void compute_session_keys_password (char *password, int iterations,
		uint8_t encryptkey[16],
		uint8_t IV[16],
		uint8_t integrity[16],
		uint8_t encryption_salt[8],
		uint8_t password_salt[8]
		){

	uint8_t master_key[AES128_KEY_LEN];
	/* compute the password hash */
	PBKDF2_SHA256((uint8_t *)password, strlen(password), password_salt, 8, iterations,
			master_key, sizeof(master_key));
#ifdef CRYPTO_DEBUG
	print_key("masterkey", master_key, sizeof(master_key));
#endif
	compute_session_keys(encryptkey, IV, integrity, master_key, encryption_salt);
	ZERO(master_key);
}

void compute_checksum(void *payload, size_t len, uint8_t integrity[AES128_KEY_LEN],
		uint8_t checksum[SHA256_DIGEST_LEN]){
	HMAC_SHA256_CTX ctx;
	HMAC_SHA256_Init(&ctx, integrity, AES128_KEY_LEN);
	HMAC_SHA256_Update(&ctx, payload, len);
	HMAC_SHA256_Final(checksum, &ctx);
}

char alphabet[]="ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz-_";
/* This is not a real base 64. I don't care, it's not the purpose */
void b64_encode(char *dest, size_t dest_size, uint8_t *input, size_t input_size){
	size_t i,j,o;
	uint32_t value;
	uint8_t offset;
	o=0;
	for (i=0;i<input_size;i+=3){
		switch(input_size - i){
		case 1:
			value = input[i];
			break;
		case 2:
			value = input[i] + (input[i+1] << 8);
			break;
		default:
			value = input[i] + (input[i+1] << 8) + (input[i+2] << 16);
		}
		for (j=0;j<4;++j){
			offset = value & 0x3f;
			value >>= 6;
			dest[o++] = alphabet[offset];
			if(o >= dest_size){
				dest[o-1]='\0';
				return;
			}
		}
	}
	dest[o]='\0';
}

int b64_decode(uint8_t *dest, size_t dest_size, char *input, size_t input_size){
	size_t i,j, o;
	uint32_t value;
	char *ptr;
	int rc = 0;

	o=0;
	/* not interested in partial chunks */
	input_size -= input_size % 4;
	if ((input_size / 4) *3 > dest_size)
		rc = -1;
	for (i=0;i<input_size;i+=4){
		value = 0;
		/* the decoding is opposite endian from encoding */
		for(j=4;j>0; --j){
			value <<=6;
			ptr = strchr(alphabet, input[i+j-1]);
			if(ptr == NULL)
				return -1;
			value |= (ptr-alphabet);
		}
		for(j=0;j<3 && o<dest_size; ++j){
			dest[o++]=value & 0xff;
			value >>=8;
		}
	}
	return rc;
}

```

`src/shared/curve25519_ref.c`:

```c
/*
version 20081011
Matthew Dempsky
Public domain.
Derived from public domain code by D. J. Bernstein.
*/

#include "shared.h"

static const unsigned char base[32] = {9};

int crypto_scalarmult_base(unsigned char *q,
  const unsigned char *n)
{
  return crypto_scalarmult(q,n,base);
}

static void add(unsigned int out[32],const unsigned int a[32],const unsigned int b[32])
{
  unsigned int j;
  unsigned int u;
  u = 0;
  for (j = 0;j < 31;++j) { u += a[j] + b[j]; out[j] = u & 255; u >>= 8; }
  u += a[31] + b[31]; out[31] = u;
}

static void sub(unsigned int out[32],const unsigned int a[32],const unsigned int b[32])
{
  unsigned int j;
  unsigned int u;
  u = 218;
  for (j = 0;j < 31;++j) {
    u += a[j] + 65280 - b[j];
    out[j] = u & 255;
    u >>= 8;
  }
  u += a[31] - b[31];
  out[31] = u;
}

static void squeeze(unsigned int a[32])
{
  unsigned int j;
  unsigned int u;
  u = 0;
  for (j = 0;j < 31;++j) { u += a[j]; a[j] = u & 255; u >>= 8; }
  u += a[31]; a[31] = u & 127;
  u = 19 * (u >> 7);
  for (j = 0;j < 31;++j) { u += a[j]; a[j] = u & 255; u >>= 8; }
  u += a[31]; a[31] = u;
}

static const unsigned int minusp[32] = {
 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128
} ;

static void freeze(unsigned int a[32])
{
  unsigned int aorig[32];
  unsigned int j;
  unsigned int negative;

  for (j = 0;j < 32;++j) aorig[j] = a[j];
  add(a,a,minusp);
  negative = -((a[31] >> 7) & 1);
  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);
}

static void mult(unsigned int out[32],const unsigned int a[32],const unsigned int b[32])
{
  unsigned int i;
  unsigned int j;
  unsigned int u;

  for (i = 0;i < 32;++i) {
    u = 0;
    for (j = 0;j <= i;++j) u += a[j] * b[i - j];
    for (j = i + 1;j < 32;++j) u += 38 * a[j] * b[i + 32 - j];
    out[i] = u;
  }
  squeeze(out);
}

static void mult121665(unsigned int out[32],const unsigned int a[32])
{
  unsigned int j;
  unsigned int u;

  u = 0;
  for (j = 0;j < 31;++j) { u += 121665 * a[j]; out[j] = u & 255; u >>= 8; }
  u += 121665 * a[31]; out[31] = u & 127;
  u = 19 * (u >> 7);
  for (j = 0;j < 31;++j) { u += out[j]; out[j] = u & 255; u >>= 8; }
  u += out[j]; out[j] = u;
}

static void square(unsigned int out[32],const unsigned int a[32])
{
  unsigned int i;
  unsigned int j;
  unsigned int u;

  for (i = 0;i < 32;++i) {
    u = 0;
    for (j = 0;j < i - j;++j) u += a[j] * a[i - j];
    for (j = i + 1;j < i + 32 - j;++j) u += 38 * a[j] * a[i + 32 - j];
    u *= 2;
    if ((i & 1) == 0) {
      u += a[i / 2] * a[i / 2];
      u += 38 * a[i / 2 + 16] * a[i / 2 + 16];
    }
    out[i] = u;
  }
  squeeze(out);
}

static void c_select(unsigned int p[64],unsigned int q[64],const unsigned int r[64],const unsigned int s[64],unsigned int b)
{
  unsigned int j;
  unsigned int t;
  unsigned int bminus1;

  bminus1 = b - 1;
  for (j = 0;j < 64;++j) {
    t = bminus1 & (r[j] ^ s[j]);
    p[j] = s[j] ^ t;
    q[j] = r[j] ^ t;
  }
}

static void mainloop(unsigned int work[64],const unsigned char e[32])
{
  unsigned int xzm1[64];
  unsigned int xzm[64];
  unsigned int xzmb[64];
  unsigned int xzm1b[64];
  unsigned int xznb[64];
  unsigned int xzn1b[64];
  unsigned int a0[64];
  unsigned int a1[64];
  unsigned int b0[64];
  unsigned int b1[64];
  unsigned int c1[64];
  unsigned int r[32];
  unsigned int s[32];
  unsigned int t[32];
  unsigned int u[32];
  unsigned int j;
  unsigned int b;
  int pos;

  for (j = 0;j < 32;++j) xzm1[j] = work[j];
  xzm1[32] = 1;
  for (j = 33;j < 64;++j) xzm1[j] = 0;

  xzm[0] = 1;
  for (j = 1;j < 64;++j) xzm[j] = 0;

  for (pos = 254;pos >= 0;--pos) {
    b = e[pos / 8] >> (pos & 7);
    b &= 1;
    c_select(xzmb,xzm1b,xzm,xzm1,b);
    add(a0,xzmb,xzmb + 32);
    sub(a0 + 32,xzmb,xzmb + 32);
    add(a1,xzm1b,xzm1b + 32);
    sub(a1 + 32,xzm1b,xzm1b + 32);
    square(b0,a0);
    square(b0 + 32,a0 + 32);
    mult(b1,a1,a0 + 32);
    mult(b1 + 32,a1 + 32,a0);
    add(c1,b1,b1 + 32);
    sub(c1 + 32,b1,b1 + 32);
    square(r,c1 + 32);
    sub(s,b0,b0 + 32);
    mult121665(t,s);
    add(u,t,b0);
    mult(xznb,b0,b0 + 32);
    mult(xznb + 32,s,u);
    square(xzn1b,c1);
    mult(xzn1b + 32,r,work);
    c_select(xzm,xzm1,xznb,xzn1b,b);
  }

  for (j = 0;j < 64;++j) work[j] = xzm[j];
}

static void recip(unsigned int out[32],const unsigned int z[32])
{
  unsigned int z2[32];
  unsigned int z9[32];
  unsigned int z11[32];
  unsigned int z2_5_0[32];
  unsigned int z2_10_0[32];
  unsigned int z2_20_0[32];
  unsigned int z2_50_0[32];
  unsigned int z2_100_0[32];
  unsigned int t0[32];
  unsigned int t1[32];
  int i;

  /* 2 */ square(z2,z);
  /* 4 */ square(t1,z2);
  /* 8 */ square(t0,t1);
  /* 9 */ mult(z9,t0,z);
  /* 11 */ mult(z11,z9,z2);
  /* 22 */ square(t0,z11);
  /* 2^5 - 2^0 = 31 */ mult(z2_5_0,t0,z9);

  /* 2^6 - 2^1 */ square(t0,z2_5_0);
  /* 2^7 - 2^2 */ square(t1,t0);
  /* 2^8 - 2^3 */ square(t0,t1);
  /* 2^9 - 2^4 */ square(t1,t0);
  /* 2^10 - 2^5 */ square(t0,t1);
  /* 2^10 - 2^0 */ mult(z2_10_0,t0,z2_5_0);

  /* 2^11 - 2^1 */ square(t0,z2_10_0);
  /* 2^12 - 2^2 */ square(t1,t0);
  /* 2^20 - 2^10 */ for (i = 2;i < 10;i += 2) { square(t0,t1); square(t1,t0); }
  /* 2^20 - 2^0 */ mult(z2_20_0,t1,z2_10_0);

  /* 2^21 - 2^1 */ square(t0,z2_20_0);
  /* 2^22 - 2^2 */ square(t1,t0);
  /* 2^40 - 2^20 */ for (i = 2;i < 20;i += 2) { square(t0,t1); square(t1,t0); }
  /* 2^40 - 2^0 */ mult(t0,t1,z2_20_0);

  /* 2^41 - 2^1 */ square(t1,t0);
  /* 2^42 - 2^2 */ square(t0,t1);
  /* 2^50 - 2^10 */ for (i = 2;i < 10;i += 2) { square(t1,t0); square(t0,t1); }
  /* 2^50 - 2^0 */ mult(z2_50_0,t0,z2_10_0);

  /* 2^51 - 2^1 */ square(t0,z2_50_0);
  /* 2^52 - 2^2 */ square(t1,t0);
  /* 2^100 - 2^50 */ for (i = 2;i < 50;i += 2) { square(t0,t1); square(t1,t0); }
  /* 2^100 - 2^0 */ mult(z2_100_0,t1,z2_50_0);

  /* 2^101 - 2^1 */ square(t1,z2_100_0);
  /* 2^102 - 2^2 */ square(t0,t1);
  /* 2^200 - 2^100 */ for (i = 2;i < 100;i += 2) { square(t1,t0); square(t0,t1); }
  /* 2^200 - 2^0 */ mult(t1,t0,z2_100_0);

  /* 2^201 - 2^1 */ square(t0,t1);
  /* 2^202 - 2^2 */ square(t1,t0);
  /* 2^250 - 2^50 */ for (i = 2;i < 50;i += 2) { square(t0,t1); square(t1,t0); }
  /* 2^250 - 2^0 */ mult(t0,t1,z2_50_0);

  /* 2^251 - 2^1 */ square(t1,t0);
  /* 2^252 - 2^2 */ square(t0,t1);
  /* 2^253 - 2^3 */ square(t1,t0);
  /* 2^254 - 2^4 */ square(t0,t1);
  /* 2^255 - 2^5 */ square(t1,t0);
  /* 2^255 - 21 */ mult(out,t1,z11);
}

int crypto_scalarmult(unsigned char *q,
  const unsigned char *n,
  const unsigned char *p)
{
  unsigned int work[96];
  unsigned char e[32];
  unsigned int i;
  for (i = 0;i < 32;++i) e[i] = n[i];
  e[0] &= 248;
  e[31] &= 127;
  e[31] |= 64;
  for (i = 0;i < 32;++i) work[i] = p[i];
  mainloop(work,e);
  recip(work + 32,work + 32);
  mult(work + 64,work,work + 32);
  freeze(work + 64);
  for (i = 0;i < 32;++i) q[i] = work[64 + i];
  return 0;
}


```

`src/shared/sha256.c`:

```c
/*-
 * Copyright 2005,2007,2009 Colin Percival
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
//#include "scrypt_platform.h"

#include <sys/types.h>

#include <stdint.h>
#include <string.h>

//#include "sysendian.h"

#include "sha256.h"

static inline uint32_t
be32dec(const void *pp)
{
    const uint8_t *p = (uint8_t const *)pp;

    return ((uint32_t)(p[3]) + ((uint32_t)(p[2]) << 8) +
        ((uint32_t)(p[1]) << 16) + ((uint32_t)(p[0]) << 24));
}

static inline void
be32enc(void *pp, uint32_t x)
{
    uint8_t * p = (uint8_t *)pp;

    p[3] = x & 0xff;
    p[2] = (x >> 8) & 0xff;
    p[1] = (x >> 16) & 0xff;
    p[0] = (x >> 24) & 0xff;
}

/*
 * Encode a length len/4 vector of (uint32_t) into a length len vector of
 * (unsigned char) in big-endian form.  Assumes len is a multiple of 4.
 */
static void
be32enc_vect(unsigned char *dst, const uint32_t *src, size_t len)
{
	size_t i;

	for (i = 0; i < len / 4; i++)
		be32enc(dst + i * 4, src[i]);
}

/*
 * Decode a big-endian length len vector of (unsigned char) into a length
 * len/4 vector of (uint32_t).  Assumes len is a multiple of 4.
 */
static void
be32dec_vect(uint32_t *dst, const unsigned char *src, size_t len)
{
	size_t i;

	for (i = 0; i < len / 4; i++)
		dst[i] = be32dec(src + i * 4);
}

/* Elementary functions used by SHA256 */
#define Ch(x, y, z)	((x & (y ^ z)) ^ z)
#define Maj(x, y, z)	((x & (y | z)) | (y & z))
#define SHR(x, n)	(x >> n)
#define ROTR(x, n)	((x >> n) | (x << (32 - n)))
#define S0(x)		(ROTR(x, 2) ^ ROTR(x, 13) ^ ROTR(x, 22))
#define S1(x)		(ROTR(x, 6) ^ ROTR(x, 11) ^ ROTR(x, 25))
#define s0(x)		(ROTR(x, 7) ^ ROTR(x, 18) ^ SHR(x, 3))
#define s1(x)		(ROTR(x, 17) ^ ROTR(x, 19) ^ SHR(x, 10))

/* SHA256 round function */
#define RND(a, b, c, d, e, f, g, h, k)			\
	t0 = h + S1(e) + Ch(e, f, g) + k;		\
	t1 = S0(a) + Maj(a, b, c);			\
	d += t0;					\
	h  = t0 + t1;

/* Adjusted round function for rotating state */
#define RNDr(S, W, i, k)			\
	RND(S[(64 - i) % 8], S[(65 - i) % 8],	\
	    S[(66 - i) % 8], S[(67 - i) % 8],	\
	    S[(68 - i) % 8], S[(69 - i) % 8],	\
	    S[(70 - i) % 8], S[(71 - i) % 8],	\
	    W[i] + k)

/*
 * SHA256 block compression function.  The 256-bit state is transformed via
 * the 512-bit input block to produce a new state.
 */
static void
SHA256_Transform(uint32_t * state, const unsigned char block[64])
{
	uint32_t W[64];
	uint32_t S[8];
	uint32_t t0, t1;
	int i;

	/* 1. Prepare message schedule W. */
	be32dec_vect(W, block, 64);
	for (i = 16; i < 64; i++)
		W[i] = s1(W[i - 2]) + W[i - 7] + s0(W[i - 15]) + W[i - 16];

	/* 2. Initialize working variables. */
	memcpy(S, state, 32);

	/* 3. Mix. */
	RNDr(S, W, 0, 0x428a2f98);
	RNDr(S, W, 1, 0x71374491);
	RNDr(S, W, 2, 0xb5c0fbcf);
	RNDr(S, W, 3, 0xe9b5dba5);
	RNDr(S, W, 4, 0x3956c25b);
	RNDr(S, W, 5, 0x59f111f1);
	RNDr(S, W, 6, 0x923f82a4);
	RNDr(S, W, 7, 0xab1c5ed5);
	RNDr(S, W, 8, 0xd807aa98);
	RNDr(S, W, 9, 0x12835b01);
	RNDr(S, W, 10, 0x243185be);
	RNDr(S, W, 11, 0x550c7dc3);
	RNDr(S, W, 12, 0x72be5d74);
	RNDr(S, W, 13, 0x80deb1fe);
	RNDr(S, W, 14, 0x9bdc06a7);
	RNDr(S, W, 15, 0xc19bf174);
	RNDr(S, W, 16, 0xe49b69c1);
	RNDr(S, W, 17, 0xefbe4786);
	RNDr(S, W, 18, 0x0fc19dc6);
	RNDr(S, W, 19, 0x240ca1cc);
	RNDr(S, W, 20, 0x2de92c6f);
	RNDr(S, W, 21, 0x4a7484aa);
	RNDr(S, W, 22, 0x5cb0a9dc);
	RNDr(S, W, 23, 0x76f988da);
	RNDr(S, W, 24, 0x983e5152);
	RNDr(S, W, 25, 0xa831c66d);
	RNDr(S, W, 26, 0xb00327c8);
	RNDr(S, W, 27, 0xbf597fc7);
	RNDr(S, W, 28, 0xc6e00bf3);
	RNDr(S, W, 29, 0xd5a79147);
	RNDr(S, W, 30, 0x06ca6351);
	RNDr(S, W, 31, 0x14292967);
	RNDr(S, W, 32, 0x27b70a85);
	RNDr(S, W, 33, 0x2e1b2138);
	RNDr(S, W, 34, 0x4d2c6dfc);
	RNDr(S, W, 35, 0x53380d13);
	RNDr(S, W, 36, 0x650a7354);
	RNDr(S, W, 37, 0x766a0abb);
	RNDr(S, W, 38, 0x81c2c92e);
	RNDr(S, W, 39, 0x92722c85);
	RNDr(S, W, 40, 0xa2bfe8a1);
	RNDr(S, W, 41, 0xa81a664b);
	RNDr(S, W, 42, 0xc24b8b70);
	RNDr(S, W, 43, 0xc76c51a3);
	RNDr(S, W, 44, 0xd192e819);
	RNDr(S, W, 45, 0xd6990624);
	RNDr(S, W, 46, 0xf40e3585);
	RNDr(S, W, 47, 0x106aa070);
	RNDr(S, W, 48, 0x19a4c116);
	RNDr(S, W, 49, 0x1e376c08);
	RNDr(S, W, 50, 0x2748774c);
	RNDr(S, W, 51, 0x34b0bcb5);
	RNDr(S, W, 52, 0x391c0cb3);
	RNDr(S, W, 53, 0x4ed8aa4a);
	RNDr(S, W, 54, 0x5b9cca4f);
	RNDr(S, W, 55, 0x682e6ff3);
	RNDr(S, W, 56, 0x748f82ee);
	RNDr(S, W, 57, 0x78a5636f);
	RNDr(S, W, 58, 0x84c87814);
	RNDr(S, W, 59, 0x8cc70208);
	RNDr(S, W, 60, 0x90befffa);
	RNDr(S, W, 61, 0xa4506ceb);
	RNDr(S, W, 62, 0xbef9a3f7);
	RNDr(S, W, 63, 0xc67178f2);

	/* 4. Mix local working variables into global state */
	for (i = 0; i < 8; i++)
		state[i] += S[i];

	/* Clean the stack. */
	memset(W, 0, 256);
	memset(S, 0, 32);
	t0 = t1 = 0;
}

static unsigned char PAD[64] = {
	0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

/* Add padding and terminating bit-count. */
static void
SHA256_Pad(SHA256_CTX * ctx)
{
	unsigned char len[8];
	uint32_t r, plen;

	/*
	 * Convert length to a vector of bytes -- we do this now rather
	 * than later because the length will change after we pad.
	 */
	be32enc_vect(len, ctx->count, 8);

	/* Add 1--64 bytes so that the resulting length is 56 mod 64 */
	r = (ctx->count[1] >> 3) & 0x3f;
	plen = (r < 56) ? (56 - r) : (120 - r);
	SHA256_Update(ctx, PAD, (size_t)plen);

	/* Add the terminating bit-count */
	SHA256_Update(ctx, len, 8);
}

/* SHA-256 initialization.  Begins a SHA-256 operation. */
void
SHA256_Init(SHA256_CTX * ctx)
{

	/* Zero bits processed so far */
	ctx->count[0] = ctx->count[1] = 0;

	/* Magic initialization constants */
	ctx->state[0] = 0x6A09E667;
	ctx->state[1] = 0xBB67AE85;
	ctx->state[2] = 0x3C6EF372;
	ctx->state[3] = 0xA54FF53A;
	ctx->state[4] = 0x510E527F;
	ctx->state[5] = 0x9B05688C;
	ctx->state[6] = 0x1F83D9AB;
	ctx->state[7] = 0x5BE0CD19;
}

/* Add bytes into the hash */
void
SHA256_Update(SHA256_CTX * ctx, const void *in, size_t len)
{
	uint32_t bitlen[2];
	uint32_t r;
	const unsigned char *src = in;

	/* Number of bytes left in the buffer from previous updates */
	r = (ctx->count[1] >> 3) & 0x3f;

	/* Convert the length into a number of bits */
	bitlen[1] = ((uint32_t)len) << 3;
	bitlen[0] = (uint32_t)(len >> 29);

	/* Update number of bits */
	if ((ctx->count[1] += bitlen[1]) < bitlen[1])
		ctx->count[0]++;
	ctx->count[0] += bitlen[0];

	/* Handle the case where we don't need to perform any transforms */
	if (len < 64 - r) {
		memcpy(&ctx->buf[r], src, len);
		return;
	}

	/* Finish the current block */
	memcpy(&ctx->buf[r], src, 64 - r);
	SHA256_Transform(ctx->state, ctx->buf);
	src += 64 - r;
	len -= 64 - r;

	/* Perform complete blocks */
	while (len >= 64) {
		SHA256_Transform(ctx->state, src);
		src += 64;
		len -= 64;
	}

	/* Copy left over data into buffer */
	memcpy(ctx->buf, src, len);
}

/*
 * SHA-256 finalization.  Pads the input data, exports the hash value,
 * and clears the context state.
 */
void
SHA256_Final(unsigned char digest[32], SHA256_CTX * ctx)
{

	/* Add padding */
	SHA256_Pad(ctx);

	/* Write the hash */
	be32enc_vect(digest, ctx->state, 32);

	/* Clear the context state */
	memset((void *)ctx, 0, sizeof(*ctx));
}

/* Initialize an HMAC-SHA256 operation with the given key. */
void
HMAC_SHA256_Init(HMAC_SHA256_CTX * ctx, const void * _K, size_t Klen)
{
	unsigned char pad[64];
	unsigned char khash[32];
	const unsigned char * K = _K;
	size_t i;

	/* If Klen > 64, the key is really SHA256(K). */
	if (Klen > 64) {
		SHA256_Init(&ctx->ictx);
		SHA256_Update(&ctx->ictx, K, Klen);
		SHA256_Final(khash, &ctx->ictx);
		K = khash;
		Klen = 32;
	}

	/* Inner SHA256 operation is SHA256(K xor [block of 0x36] || data). */
	SHA256_Init(&ctx->ictx);
	memset(pad, 0x36, 64);
	for (i = 0; i < Klen; i++)
		pad[i] ^= K[i];
	SHA256_Update(&ctx->ictx, pad, 64);

	/* Outer SHA256 operation is SHA256(K xor [block of 0x5c] || hash). */
	SHA256_Init(&ctx->octx);
	memset(pad, 0x5c, 64);
	for (i = 0; i < Klen; i++)
		pad[i] ^= K[i];
	SHA256_Update(&ctx->octx, pad, 64);

	/* Clean the stack. */
	memset(khash, 0, 32);
}

/* Add bytes to the HMAC-SHA256 operation. */
void
HMAC_SHA256_Update(HMAC_SHA256_CTX * ctx, const void *in, size_t len)
{

	/* Feed data to the inner SHA256 operation. */
	SHA256_Update(&ctx->ictx, in, len);
}

/* Finish an HMAC-SHA256 operation. */
void
HMAC_SHA256_Final(unsigned char digest[32], HMAC_SHA256_CTX * ctx)
{
	unsigned char ihash[32];

	/* Finish the inner SHA256 operation. */
	SHA256_Final(ihash, &ctx->ictx);

	/* Feed the inner hash to the outer SHA256 operation. */
	SHA256_Update(&ctx->octx, ihash, 32);

	/* Finish the outer SHA256 operation. */
	SHA256_Final(digest, &ctx->octx);

	/* Clean the stack. */
	memset(ihash, 0, 32);
}

/**
 * PBKDF2_SHA256(passwd, passwdlen, salt, saltlen, c, buf, dkLen):
 * Compute PBKDF2(passwd, salt, c, dkLen) using HMAC-SHA256 as the PRF, and
 * write the output to buf.  The value dkLen must be at most 32 * (2^32 - 1).
 */
void
PBKDF2_SHA256(const uint8_t * passwd, size_t passwdlen, const uint8_t * salt,
    size_t saltlen, uint64_t c, uint8_t * buf, size_t dkLen)
{
	HMAC_SHA256_CTX PShctx, hctx;
	size_t i;
	uint8_t ivec[4];
	uint8_t U[32];
	uint8_t T[32];
	uint64_t j;
	int k;
	size_t clen;

	/* Compute HMAC state after processing P and S. */
	HMAC_SHA256_Init(&PShctx, passwd, passwdlen);
	HMAC_SHA256_Update(&PShctx, salt, saltlen);

	/* Iterate through the blocks. */
	for (i = 0; i * 32 < dkLen; i++) {
		/* Generate INT(i + 1). */
		be32enc(ivec, (uint32_t)(i + 1));

		/* Compute U_1 = PRF(P, S || INT(i)). */
		memcpy(&hctx, &PShctx, sizeof(HMAC_SHA256_CTX));
		HMAC_SHA256_Update(&hctx, ivec, 4);
		HMAC_SHA256_Final(U, &hctx);

		/* T_i = U_1 ... */
		memcpy(T, U, 32);

		for (j = 2; j <= c; j++) {
			/* Compute U_j. */
			HMAC_SHA256_Init(&hctx, passwd, passwdlen);
			HMAC_SHA256_Update(&hctx, U, 32);
			HMAC_SHA256_Final(U, &hctx);

			/* ... xor U_j ... */
			for (k = 0; k < 32; k++)
				T[k] ^= U[k];
		}

		/* Copy as many bytes as necessary into buf. */
		clen = dkLen - i * 32;
		if (clen > 32)
			clen = 32;
		memcpy(&buf[i * 32], T, clen);
	}

	/* Clean PShctx, since we never called _Final on it. */
	memset(&PShctx, 0, sizeof(HMAC_SHA256_CTX));
}

```

`src/stub/CMakeLists.txt`:

```txt
project(mpack-stub C ASM-ATT)

set(mp_stub_SRCS
	pack_common.c
)
include(DefinePlatformDefaults)

include_directories(
	${MPACK_INCLUDE_DIRS}
)

# list of compiled stubs to link in the lib
set (mp_stubs_BINS)

if(WITH_STUB_DEBUG)
	set (FLAGS "-O0 -g -fno-stack-protector")
	set (LDFLAGS "")
else(WITH_STUB_DEBUG)
	set (FLAGS "-Os -fno-stack-protector")
	set (LDFLAGS "--strip-all")
endif(WITH_STUB_DEBUG)

if(FREEBSD)
	set(MACHINE_X86 "elf_i386_fbsd")
	set(MACHINE_AMD64 "elf_x86_64_fbsd")
else(FREEBSD)
	set(MACHINE_X86 "elf_i386")
	set(MACHINE_AMD64 "elf_x86_64")
	set(MACHINE_ARMV6 "armelf_linux_eabi")
endif(FREEBSD)

# Compile the C sources for one architecture and generate
# a libstub_static_${ARCH} library
function(COMPILE_ARCH_LIB _ARCH _FLAGS)
	set(_MP_LIBSTUB
		mp_libstub_static_${_ARCH}
		CACHE INTERNAL "libstub${_ARCH} static library"
	)

	add_library(${_MP_LIBSTUB} STATIC ${mp_stub_SRCS})
	set_target_properties(
		${_MP_LIBSTUB}
		PROPERTIES
		OUTPUT_NAME
		stub${_ARCH}
		ARCHIVE_OUTPUT_DIRECTORY
		${CMAKE_CURRENT_BINARY_DIR}/${OUTPUT_SUFFIX}
		COMPILE_FLAGS
		"${FLAGS} ${_FLAGS}"
	)
endfunction(COMPILE_ARCH_LIB)

set(CMAKE_C_LINK_EXECUTABLE 
	"/usr/bin/ld <CMAKE_C_LINK_FLAGS> <LINK_FLAGS> <OBJECTS> -o <TARGET>  <LINK_LIBRARIES>"
)

# compile for an ARCH,OS pair
function(COMPILE_ARCH_OS _OS _ARCH _CFLAGS _LDFLAGS _ASFLAGS _LIBS)
	set(_SOURCES pack_${_ARCH}.s ${_OS}_${_ARCH}.s)
#	message("sources: ${_SOURCES}")
	set(_EXECUTABLE stub_${_OS}_${_ARCH}) 
	add_executable(${_EXECUTABLE} ${_SOURCES})
	set_source_files_properties(${_SOURCES} PROPERTIES COMPILE_FLAGS "${_ASFLAGS}")

	SET(CMAKE_SHARED_LIBRARY_LINK_C_FLAGS "")
	target_link_libraries(
		${_EXECUTABLE} 
		mp_libstub_static_${_ARCH}
		"mp_shared_static_${_ARCH}"
		${_LIBS}
	)
	message("Exec: ${_EXECUTABLE}")	
	set_target_properties(
		${_EXECUTABLE}
		PROPERTIES
		LINK_FLAGS
		"${LDFLAGS} -static ${_LDFLAGS}"
	)
	
	add_custom_command(
		OUTPUT "${_EXECUTABLE}.o"
		COMMAND "ld" "-r" "-b" "binary" "-o" "${_EXECUTABLE}.o" "${_EXECUTABLE}"
		DEPENDS "${_EXECUTABLE}"
	)

	set (mp_stubs_BINS 
		"${_EXECUTABLE}.o"
		${mp_stubs_BINS}
		PARENT_SCOPE
	)
endfunction(COMPILE_ARCH_OS) 

function(ADD_PRECOMPILED _OS _ARCH)
	set(_EXECUTABLE "stub_${_OS}_${_ARCH}")
	add_custom_command(
		OUTPUT "${_EXECUTABLE}"
		COMMAND "cp" "${CMAKE_SOURCE_DIR}/src/stub/precompiled/${_EXECUTABLE}" "${_EXECUTABLE}"
	)
	add_custom_command(
		OUTPUT "${_EXECUTABLE}.o"
		COMMAND "ld" "-r" "-b" "binary" "-o" "${_EXECUTABLE}.o" "${_EXECUTABLE}"
		DEPENDS "${_EXECUTABLE}"
	)
	set (mp_stubs_BINS 
		"${_EXECUTABLE}.o"
		${mp_stubs_BINS}
		PARENT_SCOPE
	)
endfunction(ADD_PRECOMPILED)

If(CCOMPILER_32)
	compile_arch_lib("x86" "-m32 -DARCH_X86")
	compile_arch_os("linux" "x86" "-m32 -DARCH_X86" 
		"-Ai386:intel --oformat elf32-i386 -m ${MACHINE_X86} -Ttext=0xbadc0f4 -Tdata=0xbafb450"
		"--32"
		""
	)
	compile_arch_os("freebsd" "x86" "-m32 -DARCH_X86" 
		"-Ai386:intel --oformat elf32-i386 -m ${MACHINE_X86} -Ttext=0xbadc0f4 -Tdata=0xbafb450"
		"--32"
		""
	)
else(CCOMPILER_32)
	if(WITH_PRECOMPILED_STUBS)
		message("Using precompiled x86")
		add_precompiled("linux" "x86")
		add_precompiled("freebsd" "x86")
	endif(WITH_PRECOMPILED_STUBS)
endif(CCOMPILER_32)

If(CCOMPILER_64)
	compile_arch_lib("amd64" "-m64 -DARCH_AMD64")
	compile_arch_os("linux" "amd64" "-m64 -DARCH_AMD64"
		" -Ai386:x86-64 --oformat elf64-x86-64 -m ${MACHINE_AMD64} -Ttext=0xba000f0 -Tdata=0xba10000"
		"--64"
		""
	)	
	compile_arch_os("freebsd" "amd64" "-m64 -DARCH_AMD64"
		" -Ai386:x86-64 --oformat elf64-x86-64 -m ${MACHINE_AMD64} -Ttext=0xba000f0 -Tdata=0xba10000"
		"--64"
		""
	)
else(CCOMPILER_64)
	if(WITH_PRECOMPILED_STUBS)
		message("Using precompiled amd64")
		add_precompiled("linux" "amd64")
		add_precompiled("freebsd" "amd64")
	endif(WITH_PRECOMPILED_STUBS)
endif(CCOMPILER_64)

If(CCOMPILER_ARMV6)
	compile_arch_lib("armv6" "-march=armv6 -DARCH_ARM")
	compile_arch_os("linux" "armv6" "-march=armv6 -DARCH_ARM" 
		"-Aarmv6 -m ${MACHINE_ARMV6} -Ttext=0xbadc0e4 -Tdata=0xbafb450 -lgcc -lc"
		"-march=armv6"
		"gcc"		#libgcc needed for ARMv6
	)
else(CCOMPILER_ARMV6)
	if(WITH_PRECOMPILED_STUBS)
		message("Using precompiled arm")
		add_precompiled("linux" "armv6")
	endif(WITH_PRECOMPILED_STUBS)
endif(CCOMPILER_ARMV6)


set(MP_STUBS stubs
	CACHE INTERNAL "midgetpack stubs static library"
)

set_source_files_properties(
	${MP_STUBS}
	PROPERTIES
	GENERATED On
)

add_library(${MP_STUBS} STATIC ${mp_stubs_BINS})
set_target_properties(
	${MP_STUBS}
	PROPERTIES
	OUTPUT_NAME stubs
	ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/${OUTPUT_SUFFIX}
	LINKER_LANGUAGE C
)



```

`src/stub/freebsd_amd64.s`:

```s
# Copyright 2014 Aris Adamantiadis <aris@badcode.be>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#

.globl mmap
.globl write
.globl read
.globl open
.globl close
.globl exit
.globl munmap
.globl getpid
.globl ioctl
.globl get_os

.text
# syscalls conventions
# User:
# %rdi, %rsi, %rdx, %rcx, %r8 and %r9
# kernel
# %rdi, %rsi, %rdx, %r10, %r8 and %r9.

mmap:
	push %r10
	mov %rcx, %r10
	#shr $0xc, %rbp # mmap2 uses *4096
	mov $477, %rax # sys_mmap
	syscall
	pop %r10
	ret

syscall1:
syscall2:
syscall3:
	syscall
	ret

munmap:
	mov $73, %rax # sys_unmap
	jmp syscall2

write:
	mov $4, %rax # sys_write
	jmp syscall3

read:
	mov $3, %rax # sys_read
	jmp syscall3

open:
	mov $5, %rax # sys_open
	jmp syscall3

close:
	mov $6, %rax # sys_close
	jmp syscall1

exit:
	mov $1, %rax # sys_exit
	jmp syscall1

getpid:
	mov $20, %rax #sys_getpid
	syscall
	ret

ioctl:
	mov $54, %rax
	jmp syscall3

get_os:
	mov $2, %rax
	ret


```

`src/stub/freebsd_x86.s`:

```s
# Copyright 2014 Aris Adamantiadis <aris@badcode.be>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#

.globl mmap
.globl write
.globl read
.globl open
.globl close
.globl exit
.globl munmap
.globl getpid
.globl get_os
.globl ioctl

.text
mmap:
	push %ebp
	mov %esp, %ebp
	#we need to push 6 arguments and a zero
	push %ebx #save ebx
	push $0
	mov 28(%ebp), %ebx
	push %ebx

	mov 24(%ebp), %ebx
	push %ebx

	mov 20(%ebp), %ebx
	push %ebx

	mov 16(%ebp), %ebx
	push %ebx

	mov 12(%ebp), %ebx
	push %ebx

	mov 8(%ebp), %ebx
	push %ebx

	push $0 # dummy saved eip	
	mov $477, %eax # sys_mmap
	int $0x80
	add $32, %esp
	pop %ebx
	leave
	ret

syscall:
	# eax preloaded in caller
	int $0x80
	ret

munmap:
	mov $73, %eax # sys_unmap
	jmp syscall

write:
	mov $4, %eax # sys_write
	jmp syscall

read:
	mov $3, %eax # sys_read
	jmp syscall

open:
	mov $5, %eax # sys_open
	jmp syscall

close:
	mov $6, %eax # sys_close
	jmp syscall

exit:
	mov $1, %eax # sys_exit
	jmp syscall

getpid:
	mov $20, %eax #sys_getpid
	jmp syscall

get_os:
	mov $2, %eax
	ret
ioctl:
	mov $54, %eax
	jmp syscall

```

`src/stub/linux_amd64.s`:

```s
# Copyright 2014 Aris Adamantiadis <aris@badcode.be>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#

.globl mmap
.globl write
.globl read
.globl open
.globl close
.globl exit
.globl munmap
.globl getpid
.globl get_os
.globl ioctl

.text
# syscalls conventions
# User:
# %rdi, %rsi, %rdx, %rcx, %r8 and %r9
# kernel
# %rdi, %rsi, %rdx, %r10, %r8 and %r9.

mmap:
	push %r10
	mov %rcx, %r10
	#shr $0xc, %rbp # mmap2 uses *4096
	mov $9, %rax # sys_mmap2
	syscall
	pop %r10
	ret

syscall1:
syscall2:
syscall3:
	syscall
	ret

munmap:
	mov $11, %rax # sys_unmap
	jmp syscall2

write:
	mov $1, %rax # sys_write
	jmp syscall3

read:
	mov $0, %rax # sys_read
	jmp syscall3

open:
	mov $2, %rax # sys_open
	jmp syscall3

close:
	mov $3, %rax # sys_close
	jmp syscall1

exit:
	mov $60, %rax # sys_exit
	jmp syscall1

getpid:
	mov $39, %rax #sys_getpid
	syscall
	ret
ioctl:
	mov $16, %rax #sys_ioctl
	jmp syscall3

get_os:
	mov $1, %rax
	ret


```

`src/stub/linux_armv6.s`:

```s
# Copyright 2014 Aris Adamantiadis <aris@badcode.be>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#

.globl mmap
.globl write
.globl read
.globl open
.globl close
.globl exit
.globl munmap
.globl getpid
.globl get_os
.globl ioctl

.text

mmap:
	push {r4,r5,r7}
	mov r7, #192
	ldr r4, [sp, #12]
	ldr r5, [sp, #16]
	lsr r5, r5, #12
	svc 0x0
	pop {r7,r5,r4}
	bx lr

munmap:
	push {r7}
	mov r7, #91
	svc 0x0
	pop {r7}
	bx lr

write:
	push {r7}
	mov r7, #4
	svc 0x0
	pop {r7}
	bx lr

read:
	push {r7}
	mov r7, #3
	svc 0x0
	pop {r7}
	bx lr

open:
	push {r7}
	mov r7, #5
	svc 0x0
	pop {r7}
	bx lr

close:
	push {r7}
	mov r7, #6
	svc 0x0
	pop {r7}
	bx lr

exit:
	push {r7}
	mov r7, #1
	svc 0x0
	pop {r7}
	bx lr

getpid:
	push {r7}
	mov r7, #20
	svc 0x0
	pop {r7}
	bx lr

ioctl:
	push {r7}
	mov r7, #54
	svc 0x0
	pop {r7}
	bx lr

get_os:
	mov r0, #1
	bx lr

```

`src/stub/linux_x86.s`:

```s
# Copyright 2014 Aris Adamantiadis <aris@badcode.be>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#

.globl mmap
.globl write
.globl read
.globl open
.globl close
.globl exit
.globl munmap
.globl getpid
.globl ioctl
.globl get_os

.text
mmap:
	push %ebp
	mov %esp, %ebp
	sub $0x4, %esp # save space for return value
	pusha
	push %ebp #ebp will be overwritten
	mov 0x8(%ebp), %ebx
	mov 0xc(%ebp), %ecx
	mov 0x10(%ebp), %edx
	mov 0x14(%ebp), %esi
	mov 0x18(%ebp), %edi
	mov 0x1c(%ebp), %ebp
	shr $0xc, %ebp # mmap2 uses *4096
	mov $0xc0, %eax # sys_mmap2
	int $0x80
	pop %ebp
	mov %eax, -0x4(%ebp)
	popa
	mov -0x4(%ebp), %eax
	leave
	ret

syscall3:
	push %ebp
	mov %esp, %ebp
	push %ebx
	push %ecx
	push %edx
	mov 0x8(%ebp), %ebx
	mov 0xc(%ebp), %ecx
	mov 0x10(%ebp), %edx
	# eax preloaded in caller
	int $0x80
	pop %edx
	pop %ecx
	pop %ebx
	leave
	ret

syscall1:
	push %ebx
	mov 0x8(%esp), %ebx
	# eax is preloaded in caller
	int $0x80
	pop %ebx
	ret

syscall2:
	push %ebx
	push %ecx
	mov 0xc(%esp), %ebx
	mov 0x10(%esp), %ecx
	# eax is preloaded in caller
	int $0x80
	pop %ecx
	pop %ebx
	ret

munmap:
	mov $91, %eax # sys_unmap
	jmp syscall2

write:
	mov $4, %eax # sys_write
	jmp syscall3

read:
	mov $3, %eax # sys_read
	jmp syscall3

open:
	mov $5, %eax # sys_open
	jmp syscall3

close:
	mov $6, %eax # sys_close
	jmp syscall1

exit:
	mov $1, %eax # sys_exit
	jmp syscall1

getpid:
	mov $20, %eax #sys_getpid
	int $0x80
	ret
ioctl:
	mov $54, %eax #sys_ioctl
	jmp syscall3

get_os:
	mov $1, %eax
	ret

```

`src/stub/pack_amd64.s`:

```s
# Copyright 2014 Aris Adamantiadis <aris@badcode.be>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#

.globl _start
.globl gettsc

.text
_start:
	mov %rsp, %rbp
	push %rbx
	push %rcx
	push %rdx
	push %rsi
	push %rdi
	mov %rbp, %rdi # first param to get_oep
	call get_oep 
	pop %rdi
	pop %rsi
	pop %rdx
	pop %rcx
	pop %rbx
	xor %rbp, %rbp
	push %rax
	xor %rax, %rax
	ret

gettsc:
	rdtsc
	mov %eax, (%rdi)
	mov %edx, 0x4(%rdi)
	ret


```

`src/stub/pack_armv6.s`:

```s
# Copyright 2014 Aris Adamantiadis <aris@badcode.be>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#

.globl _start
.globl gettsc

.text
_start:
	push {r0}
	push {r0}
	add r0, sp, #8
	push {r1,r2,r3,r4,r5,r6,r7,r8,r9,sl,fp,lr}
	mov fp, sp
	blx get_oep
	pop {r1,r2,r3,r4,r5,r6,r7,r8,r9,sl,fp,lr}
	str r0,[sp, #4]
	pop {r0, pc}

gettsc:
	bx lr

```

`src/stub/pack_common.c`:

```c
/*
 * Copyright 2014 Aris Adamantiadis <aris@badcode.be>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/* pack_common.c
 * This is where the packer payload executes
 */
#include "stub.h"
#include "config.h"
//#include <unistd.h>
#include <stdarg.h>
#include <fcntl.h>
#include <stdlib.h>
#include "sha256.h"
#include "aes.h"
#include "shared.h"

stub_data descriptor = {
	.magic = MAGIC,
};

#define PAGE_ALIGN(x) ((x + 0xfff)&~0xfff)
#define PAGE_ALIGN_DOWN(x) ((x) &~0xfff) 

void *memcpy(void *dest, void *src, size_t len){
	register size_t i;
	for(i=0;i<len;++i){
		((unsigned char *)dest)[i]=((unsigned char*)src)[i];
	}
	return dest;
}

static void write_dec(int v){
	char buffer[12]="";
	int i=0;
	unsigned int c=1000000000; /* 10**9 */
	unsigned int v2;
	if (v<0){
		buffer[i]='-';
		++i;
		v2 = (unsigned int)-v;
	} else {
		v2 = v;
	}
	while(c >= 1){
		int num = v2/c;
        v2 = v2 - c*num;
		buffer[i]= '0' + num;
		c = c/10;
		++i;
	}
	buffer[i]=0;
	write(1, buffer, i);
}

static void write_hex(unsigned int v){
	unsigned int c = 0xf0000000;
	char alphabet[]="0123456789abcdef";
	int i=0;
	char buffer[9]="";
	while(c > 0){
		buffer[i]=alphabet[(v & c) >> ((7-i)*4)];
		++i;
		c >>=4;
	}
	buffer[i]='\0';
	write(1,buffer,i);
}

#ifdef ARCH_AMD64
static void write_hex64(uint64_t v){
	uint64_t c = 0xf000000000000000;
	char alphabet[]="0123456789abcdef";
	int i=0;
	char buffer[17]="";
	while(c > 0){
		buffer[i]=alphabet[(v & c) >> ((15-i)*4)];
		++i;
		c >>=4;
	}
	buffer[i]='\0';
	write(1,buffer,i);
}
#endif

off_t strlen(char *s){
	register int i;
	for(i=0;s[i];++i)
		;
	return i;
}

void* memset(void *p, int val, size_t len){
	register size_t i;
	for(i=0;i<len;++i)
		((char *)p)[i]=val;
	return p;
}

int memcmp(const void *s1, const void *s2, size_t n){
	size_t i;
	for (i=0;i<n;++i){
		if(((uint8_t *)s1)[i] != ((uint8_t *)s2)[i]){
			return ((uint8_t *)s1)[i] < ((uint8_t *)s2)[i] ? -1:1;
		}
	}
	return 0;
}

char *strchr(const char *s, int c){
	int i;
	for(i=0;s[i]!='\0';++i)
		if(s[i] == c)
			return (char *)s + i;
	return NULL;
}

static int myprintf(const char *format, ...){
	va_list ap;
	const char *s;
	const char *p;
	union {
		int intv;
		char *charv;
		unsigned int uintv;
		uint64_t uint64v;
	} param;

	va_start(ap, format);
	p=s=format;
	while(*p != 0){
		while(*p && *p != '%')
			++p;
		if(p!=s){
			write(1, s, p-s);
			s=p;
		}
		if(*p == '%'){
			switch(p[1]){
				case 's':
					param.charv = va_arg(ap, char *);
					write(1, param.charv, strlen(param.charv));
					break;
				case 'd':
					param.intv = va_arg(ap, int);
					write_dec(param.intv);
					break;
				case 'x':
					param.uintv = va_arg(ap, unsigned int);
					write_hex(param.uintv);
					break;
				case 'p':
#if defined(ARCH_X86) || defined(ARCH_ARM)
					param.uintv = va_arg(ap, unsigned int);
					write_hex(param.uintv);
					break;
#else
					param.uint64v = va_arg(ap, uint64_t);
					write_hex64(param.uint64v);
					break;
#endif
				case '\0':
					goto end;
			}
			p += 2;
			s=p;
		}
	}
end:
	va_end(ap);
	return 0;
}

static int MP_MAP_ANON=0;
static int IO_SET=0;
static int IO_GET=0;
static int ECHO=0;
/* some constants have different values depending on OS */
static void init_constants(void){
	enum os_e os = get_os();
	switch(os){
	case OS_LINUX:
		MP_MAP_ANON = 0x20;
		IO_GET = TCGETS;
		IO_SET = TCSETS;
		ECHO = LINUX_ECHO;
		break;
	case OS_FREEBSD:
		MP_MAP_ANON = 0x1000;
		IO_GET = TIOCGETA;
		IO_SET = TIOCSETA;
		ECHO = FREEBSD_ECHO;
		break;
	default:
		break;
	}

}
static Elf_auxv_t *find_auxv(char **base){
	char **ptr = base;

	++ptr; /* argc */
	while(*ptr != NULL){
		++ptr; /* argv[i] */
	}
	++ptr;
	while(*ptr != NULL){
		++ptr; /* environ[i] */
	}
	++ptr;
	return (Elf_auxv_t *)ptr;
}

static void fix_auxv(Elf_auxv_t *auxv, Elf_Ehdr *elf, void *program_base, void *interp_base){
	int i;
	for(i=0;auxv[i].a_type != 0;++i){
#ifdef LOADER_DEBUG
		myprintf("aux %d : %p -> ",auxv[i].a_type,
			auxv[i].a_un.a_val);
#endif
		switch(auxv[i].a_type){
			case AT_PHDR:
				auxv[i].a_un.a_val = (Elf_Addr)program_base + elf->e_phoff;
				break;
			case AT_ENTRY:
				auxv[i].a_un.a_val = elf->e_entry;
				break;
			case AT_PHNUM:
				auxv[i].a_un.a_val = elf->e_phnum;
				break;
			case AT_BASE:
				auxv[i].a_un.a_val = PAGE_ALIGN_DOWN((Elf_Addr)interp_base);
				break;
		}
#ifdef LOADER_DEBUG
		myprintf("%p\n",auxv[i].a_un.a_val);
#endif
	}
}

static size_t elf_total_size(Elf_Phdr *phs, int n){
	Elf_Phdr *first=NULL, *last=NULL;
	int i;
	size_t totallen;
	for(i=0;i<n;++i){
		if(phs[i].p_type == PT_LOAD){
			if(first == NULL)
				first=&phs[i];
			last=&phs[i];
		}
	}
	totallen = last->p_vaddr + last->p_memsz - PAGE_ALIGN_DOWN(first->p_vaddr);
#ifdef LOADER_DEBUG
	myprintf("total len %d %x\n",totallen,totallen);
#endif
	return totallen;
}

static void clean_pages(char *base, Elf_Phdr *p){
	size_t len = p->p_vaddr - PAGE_ALIGN_DOWN(p->p_vaddr);
	if(len > 0){
		memset(base + PAGE_ALIGN_DOWN(p->p_vaddr), 0, len);
	}

	len = p->p_memsz - p->p_filesz;
	
	if(len >0){
		memset(base + p->p_vaddr + p->p_filesz, 0, len);
	}

	len = PAGE_ALIGN(p->p_vaddr + p->p_memsz) - (p->p_vaddr + p->p_memsz);
	if(len > 0){
		memset(base + p->p_vaddr + p->p_memsz, 0, len);
	}
}
	

/* map the interpreter, return the entrypoint */
/* returns NULL if program has no interpreter */
static void *map_loader(Elf_Ehdr *elf, Elf_Phdr *phs, void **interpr_base_p){
	int i;
	char interp[128];
	size_t len;
	char *interp_base = NULL;
	int fd;
	char header[1024];
	void *ret;
#ifdef ARCH_X86
	static char bsd_interp[]="/libexec/ld-elf.so.1";
	static char bsd_interp32[]="/libexec/ld-elf32.so.1";
	int changed_interp=0;
#endif	
	for (i=0; i<elf->e_phnum; ++i){
		if(phs[i].p_type == PT_INTERP)
			break;
	}
	if (i>= elf->e_phnum)
		return NULL;
	len = phs[i].p_filesz;
	if (len > sizeof(interp) -1)
		len = sizeof(interp) -1;
	memcpy(interp, ((char *)elf) + phs[i].p_offset, len);
	interp[len]='\0';
#ifdef ARCH_X86
	/* FreeBSD requires the kernel to modify the loader name when */
	/* running on x86-64. Bad design IMO, here's a workaround     */
	if(memcmp(interp,bsd_interp, sizeof(bsd_interp))==0){
			memcpy(interp,bsd_interp32,sizeof(bsd_interp32));
			changed_interp=1;
	}
#endif
#ifdef LOADER_DEBUG
	myprintf("Opening %s\n",interp);
#endif
	fd = open(interp, O_RDONLY);
#ifdef ARCH_X86
	if (fd < 0 && changed_interp){
#ifdef LOADER_DEBUG
		myprintf("Fallback on %s\n", bsd_interp);
#endif
		memcpy(interp, bsd_interp, sizeof(bsd_interp));
		fd = open(bsd_interp, O_RDONLY);
	}
#endif
	if (fd <0){
		myprintf("Could not open interpreter %s (%d), mismatch 32/64 bits ?\n",
			interp, fd);
		exit(1);
	}
	read(fd, header, 1024);
	elf=(Elf_Ehdr *) header;
	phs=(Elf_Phdr *) ((char *)header + elf->e_phoff);
#ifdef LOADER_DEBUG
	myprintf("Elf header at %x\n",header);
	myprintf("%d pheaders starting at %p\n",elf->e_phnum,elf->e_phoff);
#endif

	len = elf_total_size(phs, elf->e_phnum);
	len = PAGE_ALIGN(len);
	interp_base = mmap(NULL, len , PROT_READ|PROT_WRITE,
			MAP_PRIVATE | MP_MAP_ANON, -1, 0);
	if (interp_base == NULL){
		myprintf("mapping error\n");
		return NULL;
	}
#ifdef LOADER_DEBUG
	myprintf("base mapped at %p\n",interp_base);
#endif

#if 0	
	for (i=0;i<elf->e_phnum; ++i){
#ifdef LOADER_DEBUG
		myprintf("pheader %d:%p type %d vaddr %p filesz %x\n", i,
			&phs[i],
			phs[i].p_type, phs[i].p_vaddr, phs[i].p_filesz);
#endif
		if(phs[i].p_type == PT_LOAD){
				len = elf_total_size(phs, elf->e_phnum);
				len = PAGE_ALIGN(len);
#ifdef LOADER_DEBUG
				myprintf("first map len: %d\n",len);
#endif
				interp_base = mmap(NULL, len
					, PROT_EXEC | PROT_READ | PROT_WRITE,
					MAP_PRIVATE,
					fd, 0);
				if (interp_base == NULL){
					myprintf("mapping error\n");
					return NULL;
				}
#ifdef LOADER_DEBUG
				myprintf("base mapped at %p\n",interp_base);
#endif
				clean_pages(interp_base, &phs[i]);
				/* clean unmapped memory that was overly mapped */
				//memset(interp_base + phs[i].p_memsz, 0, len - phs[i].p_memsz);
				++i;
				break;
		}
	}
#endif
	/* first page loaded, now fixed mmap of the others */
	for(i=0;i<elf->e_phnum; ++i){
		if(phs[i].p_type == PT_LOAD){
#ifdef LOADER_DEBUG
				myprintf("pheader %d:%p type %d vaddr %p filesz %p\n", i,
				&phs[i],
				phs[i].p_type, phs[i].p_vaddr, phs[i].p_filesz);
#endif

				ret = mmap(
					interp_base + PAGE_ALIGN_DOWN(phs[i].p_vaddr),
					PAGE_ALIGN((phs[i].p_vaddr & 0xfff) + phs[i].p_memsz),
					PROT_EXEC | PROT_READ | PROT_WRITE,
					MAP_PRIVATE |MAP_FIXED,
					fd, PAGE_ALIGN_DOWN(phs[i].p_offset));
				if (ret == NULL){
					myprintf("mapping error\n");
					return NULL;
				}
#ifdef LOADER_DEBUG
				myprintf("page mapped at %p\n",ret);
#endif
				clean_pages(interp_base, &phs[i]);
		}
	}
	close(fd);
#ifdef LOADER_DEBUG
	myprintf("interpreter entrypoint at %p\n",interp_base +elf->e_entry);
#endif
	*interpr_base_p = interp_base;
	return (void *)(interp_base + elf->e_entry);
}

uint8_t entropy_pool[SHA256_DIGEST_LEN];
/* We have 3 entropy sources:
 * - random values given in auxv at startup (32 bytes)
 * - /dev/urandom
 * - rdtsc + gettimeofday
 */
static void reseed_pool(Elf_auxv_t *auxv){
	SHA256_CTX ctx;
	int i;
	int fd;
	uint8_t buffer[32];
	uint32_t tsc[2];

	SHA256_Init(&ctx);

	gettsc(tsc);
	SHA256_Update(&ctx, tsc, sizeof(tsc));
#ifdef AT_RANDOM
	for (i=0; auxv[i].a_type != AT_NULL; ++i){
		switch(auxv[i].a_type){
		case AT_RANDOM:
			/* 16 random bytes */
			SHA256_Update(&ctx, (void *)auxv[i].a_un.a_val, 16);
			break;
		}
	}
#endif
	gettsc(tsc);
	SHA256_Update(&ctx, tsc, sizeof(tsc));

	fd = open("/dev/urandom", O_RDONLY);
	if(fd >= 0){
		read(fd, buffer, sizeof(buffer));
		SHA256_Update(&ctx, buffer, sizeof(buffer));
		close(fd);
	} else {
		fd = open("/dev/random", O_RDONLY);
		if (fd >= 0){
			/* /dev/random is more expensive to use */
			read(fd, buffer, 8);
			SHA256_Update(&ctx, buffer, 8);
			close(fd);
		}
	}
	for (i=0;i<32;++i){
		getpid();
		gettsc(tsc);
		SHA256_Update(&ctx, tsc, sizeof(tsc));
	}
	SHA256_Final(entropy_pool, &ctx);
}

int get_random(uint8_t *buffer, size_t len){
	int i;
	uint8_t shabuf[SHA256_DIGEST_LEN];
	HMAC_SHA256_CTX ctx;
	size_t left;

	for (i=0, left=len; left > 0 ; ++i){
		HMAC_SHA256_Init(&ctx, entropy_pool, 32);
		HMAC_SHA256_Update(&ctx, "generate", 8);
		HMAC_SHA256_Final(shabuf, &ctx);

		HMAC_SHA256_Init(&ctx, entropy_pool, 32);
		HMAC_SHA256_Update(&ctx, "reseed", 6);
		HMAC_SHA256_Final(entropy_pool, &ctx);

		memcpy(buffer + i*SHA256_DIGEST_LEN, shabuf,
				left > SHA256_DIGEST_LEN ? SHA256_DIGEST_LEN: left);
		if (left > SHA256_DIGEST_LEN)
			left -= SHA256_DIGEST_LEN;
		else
			left = 0;
	}
	ZERO(shabuf);
	ZERO(ctx);

	return len;
}

static void decrypt_payload(void *payload, size_t len, uint8_t encryptkey[16],
		uint8_t IV[16]){
	AES_CTX ctx;
	int pad = (16 - len%16)% 16;

	/* blocks must be 16 bytes padded */
	len += pad;
#ifdef CRYPTO_DEBUG
	myprintf("Aes_decrypt (%x %d) = ", *(uint32_t *)payload, len);
#endif
	AES_set_key(&ctx, encryptkey, IV, AES_MODE_128);
	AES_convert_key(&ctx);
	/* do the encryption in-place to spare memory */
	AES_cbc_decrypt(&ctx, payload, payload, len);
#ifdef CRYPTO_DEBUG
	myprintf("%x\n", *(uint32_t *)payload);
#endif
	ZERO(ctx);
}

static void ask_password(char *pwd, size_t len){
	size_t i;
	int rc;
	struct termios term;
	myprintf("Password: ");
	ioctl(0, IO_GET, &term);
	term.c_lflag &= ~ECHO;
	ioctl(0, IO_SET, &term);
	
	for(i=0;i<len;++i){
		rc = read(0, &pwd[i], 1);
		if (rc < 0){
			pwd[i]='\0';
			goto end;
		}
		if(pwd[i]=='\n' || pwd[i]=='\r'){
			pwd[i]='\0';
			goto end;
		}
	}
	pwd[len-1]='\0';
	end:
	ioctl(0, IO_GET, &term);
	term.c_lflag |= ECHO;
	ioctl(0, IO_SET, &term);
	myprintf("\n");

	return;
}
#ifdef CRYPTO_DEBUG
void print_key(const char *name, uint8_t *key, int len){
	int i;
	uint32_t *v=(uint32_t *)key;
	myprintf("%s: ",name);
	for (i=0;i<len/4;++i){
		myprintf("%x ", v[i]);
	}
	myprintf("\n");
}
#endif

static void decrypt_password(uint8_t *encryptkey, uint8_t *IV, uint8_t *integrity){
	char password[128];

	ask_password(password, sizeof(password));
#ifdef CRYPTO_DEBUG
	print_key("encrypt_salt",descriptor.encryption_salt, sizeof(descriptor.encryption_salt));
	print_key("password salt", descriptor.password_salt, sizeof(descriptor.password_salt));
#endif
	compute_session_keys_password(
			password, descriptor.hash_loops,
			encryptkey, IV, integrity,
			descriptor.encryption_salt,
			descriptor.password_salt);
	ZERO(password);
}

static void decrypt_curve25519(uint8_t *encryptkey, uint8_t *IV, uint8_t *integrity){
	uint8_t private[CURVE25519_KEY_LEN];
	uint8_t pubkey[CURVE25519_KEY_LEN];
	uint8_t shared_secret[CURVE25519_KEY_LEN];
	uint8_t authentication[SHA256_DIGEST_LEN];
	uint8_t master_key[AES128_KEY_LEN];
	struct curve25519_request req;
	struct curve25519_reply reply;
	char buffer[128];
	HMAC_SHA256_CTX ctx;
	AES_CTX aes;
	int rc;

	get_random(private, CURVE25519_KEY_LEN);
	crypto_scalarmult_base(pubkey, private);

	memcpy(req.pubkey, pubkey, sizeof(pubkey));
	HMAC_SHA256_Init(&ctx, descriptor.authentication_key,
			sizeof(descriptor.authentication_key));
	HMAC_SHA256_Update(&ctx, pubkey, sizeof(pubkey));
	HMAC_SHA256_Final(authentication, &ctx);
	memcpy(req.authentication, authentication, sizeof(req.authentication));
#ifdef CRYPTO_DEBUG
	print_key("authentication key", descriptor.authentication_key,
			sizeof(descriptor.authentication_key));
	print_key("pubkey", req.pubkey, sizeof(req.pubkey));
	print_key("authentication", req.authentication, sizeof(req.authentication));
#endif
	b64_encode(buffer, sizeof(buffer), (uint8_t *)&req, sizeof(req));
	myprintf("challenge:\n%s\n", buffer);
	rc = read(0, buffer, sizeof(buffer) -1);
	if(rc <= 0){
		myprintf("Reading fail\n");
		exit(1);
	}
	buffer[rc]=0;
	b64_decode((uint8_t *)&reply, sizeof(reply),buffer, strlen(buffer));
	crypto_scalarmult(shared_secret, private, reply.pubkey);
	HMAC_SHA256_Init(&ctx, descriptor.authentication_key,
			sizeof(descriptor.authentication_key));
	HMAC_SHA256_Update(&ctx, shared_secret, CURVE25519_KEY_LEN);
	HMAC_SHA256_Update(&ctx, reply.encrypted_master, AES128_KEY_LEN);
	HMAC_SHA256_Final(authentication, &ctx);

	if(memcmp(authentication, reply.authentication,
			sizeof(reply.authentication)) != 0){
		myprintf("Curve25519 key exchange failed !\n");
		exit(1);
	}

	AES_set_key(&aes, &shared_secret[0], &shared_secret[16],AES_MODE_128);
	// AES decryption fudge */
	AES_convert_key(&aes);
	AES_cbc_decrypt(&aes, reply.encrypted_master, master_key, AES128_KEY_LEN);
	compute_session_keys(encryptkey,IV,integrity,master_key, descriptor.encryption_salt);
	ZERO(aes);
	ZERO(ctx);
	ZERO(buffer);
	ZERO(req);
	ZERO(reply);
	ZERO(master_key);
	ZERO(authentication);
	ZERO(shared_secret);
	ZERO(pubkey);
	ZERO(private);
}

static void decrypt(){
	uint8_t encryptkey[AES128_KEY_LEN], IV[AES128_KEY_LEN],
			integrity[16],
			checksum[SHA256_DIGEST_LEN];

	switch(descriptor.type){
	case PACK_TYPE_PASSWORD:
		decrypt_password(encryptkey, IV, integrity);
		break;
	case PACK_TYPE_CURVE25519:
		decrypt_curve25519(encryptkey, IV, integrity);
		break;
	}
#ifdef CRYPTO_DEBUG
	print_key("enckey", encryptkey, AES128_KEY_LEN);
	print_key("IV", IV, AES128_KEY_LEN);
	print_key("integrity", integrity, AES128_KEY_LEN);
#endif
	decrypt_payload((void *)descriptor.data_base, descriptor.data_len,
			encryptkey, IV);
	compute_checksum((void *)descriptor.data_base, descriptor.data_len,
			integrity, checksum);
#ifdef CRYPTO_DEBUG
	print_key("file cheksum", descriptor.checksum, 32);
	print_key("calculated checksum", checksum, 32);
#endif
	if(memcmp(checksum, descriptor.checksum, SHA256_DIGEST_LEN) != 0){
			myprintf("Integrity error. Good password ?\n");
			exit(1);
	}
	ZERO(encryptkey);
	ZERO(integrity);
	ZERO(IV);
}

void *get_oep(char **base){
	Elf_Ehdr *elf = (void *)descriptor.data_base;
	Elf_Phdr *phs;
	Elf_auxv_t *auxv;
	int pcount;
	int i=0;
	void *interpr=NULL;
	void *interpr_base=NULL;
	void *entry=NULL;
	void *ret;
	void *program_base = NULL;

	myprintf("starting stub ...\n" );
	init_constants();
	auxv = find_auxv(base);

	reseed_pool(auxv);
	if (descriptor.banner_len > 0){
		write(1, (void *)descriptor.banner_addr, descriptor.banner_len);
	}
	decrypt();
	phs = (Elf_Phdr *)(descriptor.data_base + elf->e_phoff);
	pcount = elf->e_phnum;
	for (i=0;i<pcount;++i){
		if(phs[i].p_type == PT_LOAD){
			ret = mmap((void *)PAGE_ALIGN_DOWN(phs[i].p_vaddr),
					PAGE_ALIGN((phs[i].p_vaddr & 0xfff) + phs[i].p_memsz),
					PROT_EXEC | PROT_READ | PROT_WRITE, 
					MAP_PRIVATE | MAP_FIXED  | MP_MAP_ANON,
					-1, 0);
			if (ret == NULL){
				return NULL;
			}
			memcpy((void *)phs[i].p_vaddr, 
				(void *)(descriptor.data_base + phs[i].p_offset),
				phs[i].p_filesz);
			if(program_base == NULL)
				program_base=(void *)PAGE_ALIGN_DOWN((Elf_Addr)ret);
#ifdef LOADER_DEBUG
			myprintf("Loaded program header %d at %p (%d)\n", i, phs[i].p_vaddr, phs[i].p_filesz);
#endif
		}
	}
	entry = (void *) elf->e_entry;
	interpr = map_loader(elf, phs, &interpr_base);
	fix_auxv(auxv, elf, program_base, interpr_base);
	/* Don't let the whole unpacked binary in memory */
	munmap((void *)PAGE_ALIGN_DOWN(descriptor.data_base),
			PAGE_ALIGN(descriptor.data_len + (descriptor.data_base & 0xfff)));
	if (interpr != NULL)
		return interpr;
	else	
		return entry;
}

```

`src/stub/pack_x86.s`:

```s
# Copyright 2014 Aris Adamantiadis <aris@badcode.be>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#

.globl _start
.globl gettsc

.text
_start:
	mov %esp, %ebp
	push %ebx
	push %ecx
	push %edx
	push %esi
	push %edi
	push %ebp # first param to get_oep
	call get_oep 
	add $4, %esp
	pop %edi
	pop %esi
	pop %edx
	pop %ecx
	pop %ebx
	xor %ebp, %ebp
	push %eax
	xor %eax, %eax
	ret

gettsc:
	push %ebx
	rdtsc
	mov 0x8(%esp), %ebx
	mov %eax, (%ebx)
	mov %edx, 0x4(%ebx)
	pop %ebx
	ret


```

`src/tests/CMakeLists.txt`:

```txt
project(tests C)

set(tests_SRCS
	test.c
)

include_directories(
	${MPACK_INCLUDE_DIRS}
)

If(CCOMPILER_64)

add_executable(test-amd64-static ${tests_SRCS})
add_executable(test-amd64-dynamic ${tests_SRCS})

set_target_properties(
	test-amd64-static
	PROPERTIES
	COMPILE_FLAGS
	"-static -m64"
	LINK_FLAGS "-static -m64"
)

set_target_properties(
	test-amd64-dynamic
	PROPERTIES
	COMPILE_FLAGS
	"-m64"
	LINK_FLAGS "-m64"
)

Endif(CCOMPILER_64)

If(CCOMPILER_32)

add_executable(test-x86-static ${tests_SRCS})
add_executable(test-x86-dynamic ${tests_SRCS})

set_target_properties(
	test-x86-static
	PROPERTIES
	COMPILE_FLAGS
	"-static -m32"
	LINK_FLAGS "-static -m32"
)

set_target_properties(
	test-x86-dynamic
	PROPERTIES
	COMPILE_FLAGS
	"-m32"
	LINK_FLAGS "-m32"
)

Endif(CCOMPILER_32)

If(CCOMPILER_ARMV6)

add_executable(test-arm-static ${tests_SRCS})
add_executable(test-arm-dynamic ${tests_SRCS})

set_target_properties(
	test-arm-static
	PROPERTIES
	COMPILE_FLAGS
	"-static -march=armv6"
	LINK_FLAGS "-static -march=armv6"
)

set_target_properties(
	test-arm-dynamic
	PROPERTIES
	COMPILE_FLAGS
	"-march=armv6"
	LINK_FLAGS "-march=armv6"
)

Endif(CCOMPILER_ARMV6)

```

`src/tests/banner`:

```
 / * * * * * * * * * * * * \
* Welcome to midgetpack !   *
* Use this software wisely !*
 \  ~~~ Aris               /
   * * * * * * * * * * * *


```

`src/tests/test.c`:

```c
#include <stdio.h>

int main(){
	printf("Hello, world !\n");
	return 0;
}

```