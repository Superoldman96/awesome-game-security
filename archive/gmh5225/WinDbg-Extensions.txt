Project Path: arc_gmh5225_WinDbg-Extensions_cyuh9t2e

Source Tree:

```txt
arc_gmh5225_WinDbg-Extensions_cyuh9t2e
├── Callback Extension
│   ├── Callback Extension.sln
│   └── Callbacks
│       ├── Callbacks.vcxproj
│       ├── Callbacks.vcxproj.filters
│       ├── callbacks.cpp
│       ├── callbacks.h
│       ├── dllmain.cpp
│       ├── framework.h
│       ├── pch.cpp
│       └── pch.h
├── Images
│   └── all.PNG
└── README.md

```

`Callback Extension/Callback Extension.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31005.135
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Callbacks", "Callbacks\Callbacks.vcxproj", "{C0384D36-D080-41BC-AC7C-3BCF5B0AF64D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{C0384D36-D080-41BC-AC7C-3BCF5B0AF64D}.Debug|x64.ActiveCfg = Debug|x64
		{C0384D36-D080-41BC-AC7C-3BCF5B0AF64D}.Debug|x64.Build.0 = Debug|x64
		{C0384D36-D080-41BC-AC7C-3BCF5B0AF64D}.Debug|x86.ActiveCfg = Debug|Win32
		{C0384D36-D080-41BC-AC7C-3BCF5B0AF64D}.Debug|x86.Build.0 = Debug|Win32
		{C0384D36-D080-41BC-AC7C-3BCF5B0AF64D}.Release|x64.ActiveCfg = Release|x64
		{C0384D36-D080-41BC-AC7C-3BCF5B0AF64D}.Release|x64.Build.0 = Release|x64
		{C0384D36-D080-41BC-AC7C-3BCF5B0AF64D}.Release|x86.ActiveCfg = Release|Win32
		{C0384D36-D080-41BC-AC7C-3BCF5B0AF64D}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {A6CD035B-83FA-4D24-BF58-CA45C323E807}
	EndGlobalSection
EndGlobal

```

`Callback Extension/Callbacks/Callbacks.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{c0384d36-d080-41bc-ac7c-3bcf5b0af64d}</ProjectGuid>
    <RootNamespace>Callbacks</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;CALLBACKS_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <AdditionalDependencies>dbgeng.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;CALLBACKS_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <AdditionalDependencies>dbgeng.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;CALLBACKS_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <AdditionalDependencies>dbgeng.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;CALLBACKS_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <AdditionalDependencies>dbgeng.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="callbacks.h" />
    <ClInclude Include="framework.h" />
    <ClInclude Include="pch.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="callbacks.cpp" />
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Callback Extension/Callbacks/Callbacks.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="framework.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="callbacks.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="callbacks.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Callback Extension/Callbacks/callbacks.cpp`:

```cpp
// callbacks.cpp : Defines the exported functions for the DLL.
//

#include "pch.h"
#include "framework.h"
#include "callbacks.h"

WINDBG_EXTENSION_APIS ExtensionApis;

PIDebugClient g_pDebugClient = nullptr;
PIDebugControl g_pDebugControl = nullptr;
PIDebugSymbols g_pSymbols = nullptr;

/// <summary>
/// Init will intiate the global variables used by this extension to use printing, symbols, etc.
/// </summary>
/// <returns>S_OK if successful</returns>
HRESULT init()
{
    HRESULT hResult = DebugCreate(__uuidof(IDebugClient), reinterpret_cast<PVOID*>(&g_pDebugClient));
    if (FAILED(hResult))
    {
        g_pDebugControl->Output(DEBUG_OUTPUT_ERROR, "[%ws::%d] Failed with status: %d\n", __FUNCTIONW__, __LINE__, hResult);
        return hResult;
    }

    hResult = g_pDebugClient->QueryInterface(__uuidof(IDebugControl), reinterpret_cast<PVOID*>(&g_pDebugControl));
    if (FAILED(hResult))
    {
        g_pDebugControl->Output(DEBUG_OUTPUT_ERROR, "[%ws::%d] Failed with status: %d\n", __FUNCTIONW__, __LINE__, hResult);
        return hResult;
    }

    ExtensionApis.nSize = sizeof(ExtensionApis);
    hResult = g_pDebugControl->GetWindbgExtensionApis64(&ExtensionApis);
    if (FAILED(hResult))
    {
        g_pDebugControl->Output(DEBUG_OUTPUT_ERROR, "[%ws::%d] Failed with status: %d\n", __FUNCTIONW__, __LINE__, hResult);
        return hResult;
    }

    hResult = g_pDebugClient->QueryInterface(__uuidof(IDebugSymbols), reinterpret_cast<PVOID*>(&g_pSymbols));
    if (FAILED(hResult))
    {
        g_pDebugControl->Output(DEBUG_OUTPUT_ERROR, "[%ws::%d] Failed with status: %d\n", __FUNCTIONW__, __LINE__, hResult);
        return hResult;
    }
    return hResult;
}

/// <summary>
/// This will enumerate all Load Image Routine callbacks registered on a system. It will show the pointer
/// that it's located at, as well as the function of that callback. 
/// </summary>
/// <returns>S_OK if successful</returns>
HRESULT enumerateLoadImageRoutines()
{
    std::string SymbolName(MAX_SYMBOL_LENGTH, '\0');
    std::ostringstream ss;

    ULONG64 PspLoadImageNotifyRoutine = 0;
    ULONG64 PspLoadImageNotifyRoutineCount = 0;

    ULONG64 LoadImageRoutineCount = 0;
    ULONG64 temp = 0;

    HRESULT hResult = g_pSymbols->GetOffsetByName("nt!PspLoadImageNotifyRoutine", &PspLoadImageNotifyRoutine);
    if (FAILED(hResult))
    {
        g_pDebugControl->Output(DEBUG_OUTPUT_ERROR, "[%ws::%d] Failed with status: %d\n", __FUNCTIONW__, __LINE__, hResult);
        return hResult;
    }

    hResult = g_pSymbols->GetOffsetByName("nt!PspLoadImageNotifyRoutineCount", &PspLoadImageNotifyRoutineCount);
    if (FAILED(hResult))
    {
        g_pDebugControl->Output(DEBUG_OUTPUT_ERROR, "[%ws::%d] Failed with status: %d\n", __FUNCTIONW__, __LINE__, hResult);
        return hResult;
    }

    //
    // Get the total count for PspLoadImageNotifyRoutineCount
    //
    ReadPointer(PspLoadImageNotifyRoutineCount, &LoadImageRoutineCount);

    g_pDebugControl->Output(DEBUG_OUTPUT_DEBUGGEE, "The following Load Image Notify routines are registered on the system:\n");
    for (int i = 0; i < LoadImageRoutineCount; i++)
    {
        UINT64 ImageCallbackPointer = 0;
        UINT64 ImageCallbackAddress = 0;

        ULONG64 Displacement = 0;

        ReadPointer(PspLoadImageNotifyRoutine, &ImageCallbackPointer);
        ImageCallbackPointer &= ~15;
        ImageCallbackPointer += sizeof(ImageCallbackPointer);

        ReadPointer(ImageCallbackPointer, &ImageCallbackAddress);

        hResult = g_pSymbols->GetNameByOffset(ImageCallbackAddress, &SymbolName[0], static_cast<ULONG>(SymbolName.size()), NULL, &Displacement);
        if (FAILED(hResult))
        {
            return hResult;
        }

        if (Displacement != 0)
        {
            ss << std::hex << "+" << Displacement;

            SymbolName.insert(strlen(SymbolName.c_str()), ss.str().c_str());

            ss.str(std::string());
        }

        g_pDebugControl->Output(DEBUG_OUTPUT_DEBUGGEE, "%p: %s\n", ImageCallbackPointer, SymbolName.c_str());
        PspLoadImageNotifyRoutine += sizeof(PspLoadImageNotifyRoutine);
    }

    return hResult;
}

/// <summary>
/// This will enumerate all Create Thread Routine callbacks registered on a system. It will show the pointer
/// that it's located at, as well as the function of that callback. 
/// </summary>
/// <returns>S_OK if successful</returns>
HRESULT enumerateCreateThreadRoutines()
{
    std::string SymbolName(MAX_SYMBOL_LENGTH, '\0');
    std::ostringstream ss;

    ULONG64 PspCreateThreadNotifyRoutineNonSystemCount = 0;
    ULONG64 PspCreateThreadNotifyRoutineCount = 0;
    ULONG64 PspCreateThreadNotifyRoutine = 0;

    ULONG64 ThreadCallbacksCount = 0;
    ULONG64 temp = 0;

    //
    // Not quite sure if this particular symbol is needed, but it doesn't hurt to include it
    //
    HRESULT hResult = g_pSymbols->GetOffsetByName("nt!PspCreateThreadNotifyRoutineNonSystemCount", &PspCreateThreadNotifyRoutineNonSystemCount);
    if (FAILED(hResult))
    {
        g_pDebugControl->Output(DEBUG_OUTPUT_ERROR, "[%ws::%d] Failed with status: %d\n", __FUNCTIONW__, __LINE__, hResult);
        return hResult;
    }

    hResult = g_pSymbols->GetOffsetByName("nt!PspCreateThreadNotifyRoutineCount", &PspCreateThreadNotifyRoutineCount);
    if (FAILED(hResult))
    {
        g_pDebugControl->Output(DEBUG_OUTPUT_ERROR, "[%ws::%d] Failed with status: %d\n", __FUNCTIONW__, __LINE__, hResult);
        return hResult;
    }

    hResult = g_pSymbols->GetOffsetByName("nt!PspCreateThreadNotifyRoutine", &PspCreateThreadNotifyRoutine);
    if (FAILED(hResult))
    {
        g_pDebugControl->Output(DEBUG_OUTPUT_ERROR, "[%ws::%d] Failed with status: %d\n", __FUNCTIONW__, __LINE__, hResult);
        return hResult;
    }

    //
    // Get the total count for PspCreateThreadNotifyRoutine
    //
    ReadPointer(PspCreateThreadNotifyRoutineNonSystemCount, &temp);
    ThreadCallbacksCount += temp;

    ReadPointer(PspCreateThreadNotifyRoutineCount, &temp);
    ThreadCallbacksCount += temp;

    g_pDebugControl->Output(DEBUG_OUTPUT_DEBUGGEE, "The following Create Thread Notify routines are registered on the system:\n");
    for (int i = 0; i < ThreadCallbacksCount; i++)
    {
        UINT64 ThreadCallbackPointer = 0;
        UINT64 ThreadCallbackAddress = 0;
        ULONG64 Displacement = 0;

        ReadPointer(PspCreateThreadNotifyRoutine, &ThreadCallbackPointer);
        ThreadCallbackPointer &= ~15;
        ThreadCallbackPointer += sizeof(ThreadCallbackPointer);

        ReadPointer(ThreadCallbackPointer, &ThreadCallbackAddress);

        hResult = g_pSymbols->GetNameByOffset(ThreadCallbackAddress, &SymbolName[0], static_cast<ULONG>(SymbolName.size()), NULL, &Displacement);
        if (FAILED(hResult))
        {
            return hResult;
        }

        if (Displacement != 0)
        {
            ss << std::hex << "+" << Displacement;

            SymbolName.insert(strlen(SymbolName.c_str()), ss.str().c_str());

            ss.str(std::string());
        }

        g_pDebugControl->Output(DEBUG_OUTPUT_DEBUGGEE, "%p: %s\n", ThreadCallbackPointer, SymbolName.c_str());
        PspCreateThreadNotifyRoutine += sizeof(PspCreateThreadNotifyRoutine);
    }

    return hResult;
}

/// <summary>
/// This will enumerate all Create Process Routine callbacks registered on a system. It will show the pointer
/// that it's located at, as well as the function of that callback. 
/// </summary>
/// <returns>S_OK if successful</returns>
HRESULT enumerateCreateProcessRoutines()
{
    std::string SymbolName(MAX_SYMBOL_LENGTH, '\0');
    std::ostringstream ss;

    ULONG64 PspCreateProcessNotifyRoutineExCount = 0;
    ULONG64 PspCreateProcessNotifyRoutineCount = 0;
    ULONG64 PspCreateProcessNotifyRoutine = 0;

    ULONG64 ProcessCallbacksCount = 0;
    ULONG64 temp = 0;

    HRESULT hResult = g_pSymbols->GetOffsetByName("nt!PspCreateProcessNotifyRoutineExCount", &PspCreateProcessNotifyRoutineExCount);
    if (FAILED(hResult))
    {
        g_pDebugControl->Output(DEBUG_OUTPUT_ERROR, "[%ws::%d] Failed with status: %d\n", __FUNCTIONW__, __LINE__, hResult);
        return hResult;
    }

    hResult = g_pSymbols->GetOffsetByName("nt!PspCreateProcessNotifyRoutineCount", &PspCreateProcessNotifyRoutineCount);
    if (FAILED(hResult))
    {
        g_pDebugControl->Output(DEBUG_OUTPUT_ERROR, "[%ws::%d] Failed with status: %d\n", __FUNCTIONW__, __LINE__, hResult);
        return hResult;
    }

    hResult = g_pSymbols->GetOffsetByName("nt!PspCreateProcessNotifyRoutine", &PspCreateProcessNotifyRoutine);
    if (FAILED(hResult))
    {
        g_pDebugControl->Output(DEBUG_OUTPUT_ERROR, "[%ws::%d] Failed with status: %d\n", __FUNCTIONW__, __LINE__, hResult);
        return hResult;
    }

    //
    // Get the total count for both PspCreateProcessNotifyRoutine/Ex
    //
    ReadPointer(PspCreateProcessNotifyRoutineExCount, &temp);
    ProcessCallbacksCount += temp;

    ReadPointer(PspCreateProcessNotifyRoutineCount, &temp);
    ProcessCallbacksCount += temp;

    g_pDebugControl->Output(DEBUG_OUTPUT_DEBUGGEE, "The following Create Process Notify routines are registered on the system:\n");
    for (int i = 0; i < ProcessCallbacksCount; i++)
    {
        UINT64 ProcessCallbackPointer = 0;
        UINT64 ProcessCallbackAddress = 0;
        ULONG64 Displacement = 0;

        ReadPointer(PspCreateProcessNotifyRoutine, &ProcessCallbackPointer);
        ProcessCallbackPointer &= ~15;
        ProcessCallbackPointer += sizeof(ProcessCallbackPointer);

        ReadPointer(ProcessCallbackPointer, &ProcessCallbackAddress);

        hResult = g_pSymbols->GetNameByOffset(ProcessCallbackAddress, &SymbolName[0], static_cast<ULONG>(SymbolName.size()), NULL, &Displacement);
        if (FAILED(hResult))
        {
            return hResult;
        }

        if (Displacement != 0)
        {
            ss << std::hex << "+" << Displacement;

            SymbolName.insert(strlen(SymbolName.c_str()), ss.str().c_str());

            ss.str(std::string());
        }

        g_pDebugControl->Output(DEBUG_OUTPUT_DEBUGGEE, "%p: %s\n", ProcessCallbackPointer, SymbolName.c_str());
        PspCreateProcessNotifyRoutine += sizeof(PspCreateProcessNotifyRoutine);
    }

    return hResult;
}

void cleanUpAndExit()
{
    if (g_pSymbols != nullptr)
    {
        g_pSymbols->Release();
    }

    if (g_pDebugControl != nullptr)
    {
        g_pDebugControl->Release();
    }

    if (g_pDebugClient != nullptr)
    {
        g_pDebugClient->Release();
    }
}

CALLBACK_API HRESULT callbacks(PIDebugClient, PCSTR args)
{
    if (*args == NULL)
    {
        g_pDebugControl->Output(DEBUG_OUTPUT_DEBUGGEE, "Please specify a type of callback or check out the help command.\n");
        return S_FALSE;
    }

    if (strcmp(args, "process") == 0)
    {
        enumerateCreateProcessRoutines();
    }
    else if (strcmp(args, "thread") == 0)
    {
        enumerateCreateThreadRoutines();
    }
    else if (strcmp(args, "image") == 0)
    {
        enumerateLoadImageRoutines();
    }
    else if (strcmp(args, "all") == 0)
    {
        enumerateCreateProcessRoutines();
        g_pDebugControl->Output(DEBUG_OUTPUT_DEBUGGEE, "\n");

        enumerateCreateThreadRoutines();
        g_pDebugControl->Output(DEBUG_OUTPUT_DEBUGGEE, "\n");

        enumerateLoadImageRoutines();
    }
    else if (strcmp(args, "help") == 0)
    {
        g_pDebugControl->Output(DEBUG_OUTPUT_DEBUGGEE,
            "Provide a callback type you are interested in.\n"
            "The different types are: process, thread, image, or all\n"
        );
    }
    else
    {
        g_pDebugControl->Output(DEBUG_OUTPUT_DEBUGGEE, "Unable to recognize the callback argument: %s.\n", args);
        return S_FALSE;
    }

    return S_OK;
}


/// EOF
```

`Callback Extension/Callbacks/callbacks.h`:

```h
// The following ifdef block is the standard way of creating macros which make exporting
// from a DLL simpler. All files within this DLL are compiled with the DLL11_EXPORTS
// symbol defined on the command line. This symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see
// DLL11_API functions as being imported from a DLL, whereas this DLL sees symbols
// defined with this macro as being exported.

#ifndef CALLBACK_EXPORTS
#define CALLBACK_API __declspec(dllexport)
#else
#define CALLBACK_API __declspec(dllimport)
#endif

typedef IDebugClient* PIDebugClient;
typedef IDebugControl* PIDebugControl;
typedef IDebugSymbols* PIDebugSymbols;

HRESULT init();
HRESULT enumerateLoadImageRoutines();
HRESULT enumerateCreateThreadRoutines();
HRESULT enumerateCreateProcessRoutines();
void cleanUpAndExit();

EXTERN_C CALLBACK_API HRESULT CALLBACK callbacks(
	_In_ PIDebugClient,
	_In_ PCSTR args
);


/// EOF
```

`Callback Extension/Callbacks/dllmain.cpp`:

```cpp
// dllmain.cpp : Defines the entry point for the DLL application.
#include "pch.h"

EXTERN_C
__declspec(dllexport)
HRESULT CALLBACK DebugExtensionInitialize(
    _In_ PULONG Version,
    _In_ PULONG
)
{
    *Version = DEBUG_EXTENSION_VERSION(MAJOR, MINOR);

    return init();
}

EXTERN_C
__declspec(dllexport)
void CALLBACK DebugExtensionNotify(
    _In_ ULONG,
    _In_ ULONG64
)
{
    return;
}

EXTERN_C
__declspec(dllexport)
void CALLBACK DebugExtensionUninitialize()
{
    cleanUpAndExit();
    return;
}


/// EOF
```

`Callback Extension/Callbacks/framework.h`:

```h
#pragma once

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif // !WIN32_LEAN_AND_MEAN

#ifndef KDEXT_64BIT
#define KDEXT_64BIT
#endif // !KDEXT_64BIT

#include <windows.h>
#include <DbgEng.h>
#include <string>
#include <sstream>
#include <WDBGEXTS.H>

#include "callbacks.h"

#define MAJOR	1
#define MINOR	0
#define MAX_SYMBOL_LENGTH	256


/// EOF
```

`Callback Extension/Callbacks/pch.cpp`:

```cpp
// pch.cpp: source file corresponding to the pre-compiled header

#include "pch.h"

// When you are using pre-compiled headers, this source file is necessary for compilation to succeed.

```

`Callback Extension/Callbacks/pch.h`:

```h
// pch.h: This is a precompiled header file.
// Files listed below are compiled only once, improving build performance for future builds.
// This also affects IntelliSense performance, including code completion and many code browsing features.
// However, files listed here are ALL re-compiled if any one of them is updated between builds.
// Do not add files here that you will be updating frequently as this negates the performance advantage.

#ifndef PCH_H
#define PCH_H

// add headers that you want to pre-compile here
#include "framework.h"

#endif //PCH_H


/// EOF
```

`README.md`:

```md
# WinDbg-Extensions
## Callback Extension
Callbacks.dll is a WinDbg extension that will enumerate all pointers inside of the following symbols for callbacks that are registered on the system:
1. nt!PspCreateProcessNotifyRoutine
2. nt!PspCreateThreadNotifyRoutine
3. nt!PspLoadImageNotifyRoutine

![picture](https://github.com/ch3rn0byl/WinDbg-Extensions/blob/main/Images/all.PNG)

## How to use?
The extension takes in either of the four parameters: _process_, _image_, _thread_, or _all_. 
This just makes life a little bit easier when you're doing whatever it is you're doing with them.  

This just lists the callbacks, nothing more nothing less but as I continue working on my shenanigans...I will make sure to continue adding on to this.

Have fun!

```