Project Path: arc_gmh5225_external-warzone-cheat_ouqnabot

Source Tree:

```txt
arc_gmh5225_external-warzone-cheat_ouqnabot
├── README.md
├── kdmapper.exe
├── modern_warfare
│   ├── core
│   │   ├── driver
│   │   │   └── driver.h
│   │   ├── game
│   │   │   ├── offsets.h
│   │   │   ├── sdk.cpp
│   │   │   └── sdk.h
│   │   ├── main.cpp
│   │   ├── overlay
│   │   │   ├── hijack
│   │   │   │   ├── hijack.cpp
│   │   │   │   └── hijack.h
│   │   │   └── renderer
│   │   │       ├── colors.cpp
│   │   │       ├── fonts.cpp
│   │   │       ├── internal.cpp
│   │   │       ├── internal.h
│   │   │       ├── renderer.cpp
│   │   │       ├── renderer.h
│   │   │       └── scene.cpp
│   │   └── utils
│   │       ├── vectors.cpp
│   │       ├── vectors.h
│   │       └── xor.h
│   ├── modern_warfare.vcxproj
│   └── modern_warfare.vcxproj.filters
├── modern_warfare.sln
└── modern_warfare_driver
    ├── core
    │   ├── main.cpp
    │   └── utils
    │       ├── imports.h
    │       └── memory.h
    ├── modern_warfare_driver.inf
    ├── modern_warfare_driver.vcxproj
    └── modern_warfare_driver.vcxproj.filters

```

`README.md`:

```md


# external_warzone_cheat
### External warzone cheat with manual mapped driver (function hook), overlay (nvidia hijack), simple esp, no recoil

## Offsests are NOT up to date 

modern wareafee or warzone or blizzardds whatever their anti cheat is not very good ,,... (excpet their hwid bans are pretty anouning) anywayws thier anti cheat is only usemrode so of course our sexy manual mapped drievr will be veyr nice for this game.... the ovrrlay is pretty fine except for the tranprant flag that gets added [here](https://github.com/NMan1/external_warzone_cheat/blob/7774b0ed2b498ce880edd19a7388f938ac207f6c/modern_warfare/core/overlay/hijack/hijack.cpp#L18) since the nvidia overlay deosnt have the transprent flag we add that but that can be alittle suspicouss for the anit cheat since a new flag has been added to a legit window. The top most is taken care of [here](https://github.com/NMan1/external_warzone_cheat/blob/7774b0ed2b498ce880edd19a7388f938ac207f6c/modern_warfare/core/overlay/renderer/scene.cpp#L40). So if u really care but its really not a massive deal if ur just poarniod u can find a way to rmeove the transprant flag or hook getwindowlong to reutnr nothing who cares its not worth the effort their anticheat is dog shit actually they also maybe take [screenshots too so maybe u should compentsate for that hint hint](https://github.com/NMan1/external_warzone_cheat/blob/7774b0ed2b498ce880edd19a7388f938ac207f6c/modern_warfare/core/overlay/hijack/hijack.cpp#L28) [this](https://www.unknowncheats.me/forum/anti-cheat-bypass/220597-overlay-window-using-ws_ex_topmost-2.html) or [this](https://www.unknowncheats.me/forum/anti-cheat-bypass/349662-method-using-ws_ex_layered-style-overlay.html) can help u regarding the WS_EX_TRANSPARENT  fkag.

esp is very basic but u can expand it if u want there is a draw box function.
no recoil is commented out cuz offset not work but if u want to ad that probaly just create a new thread so esp and recoil are sepreate.

DEL key unoads overlay and cheat.

Compile x64 release, kdmapper driver. Run modern_wareafre_client.exe when in game

# Vids

https://user-images.githubusercontent.com/44145464/122661983-2b12a680-d155-11eb-844f-a86223c0f5a0.mp4

https://user-images.githubusercontent.com/44145464/122662032-7c229a80-d155-11eb-84cb-53dfba539db9.mp4


# Credits:

https://github.com/es3n1n/nvidia-overlay-renderer/
  - for the hijacking structure
 
albxrn for function hook pasta 

unkowncheats modern warefare fourm for offsets and decprytion

```

`modern_warfare.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30709.64
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "modern_warfare_client", "modern_warfare\modern_warfare.vcxproj", "{4A69FC80-8531-4350-B836-A1076D2FD136}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "modern_warfare_driver", "modern_warfare_driver\modern_warfare_driver.vcxproj", "{30EAC4AD-21EC-4982-B136-2BB9C1361551}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4A69FC80-8531-4350-B836-A1076D2FD136}.Debug|ARM.ActiveCfg = Debug|Win32
		{4A69FC80-8531-4350-B836-A1076D2FD136}.Debug|ARM64.ActiveCfg = Debug|Win32
		{4A69FC80-8531-4350-B836-A1076D2FD136}.Debug|x64.ActiveCfg = Debug|x64
		{4A69FC80-8531-4350-B836-A1076D2FD136}.Debug|x64.Build.0 = Debug|x64
		{4A69FC80-8531-4350-B836-A1076D2FD136}.Debug|x86.ActiveCfg = Debug|Win32
		{4A69FC80-8531-4350-B836-A1076D2FD136}.Debug|x86.Build.0 = Debug|Win32
		{4A69FC80-8531-4350-B836-A1076D2FD136}.Release|ARM.ActiveCfg = Release|Win32
		{4A69FC80-8531-4350-B836-A1076D2FD136}.Release|ARM64.ActiveCfg = Release|Win32
		{4A69FC80-8531-4350-B836-A1076D2FD136}.Release|x64.ActiveCfg = Release|x64
		{4A69FC80-8531-4350-B836-A1076D2FD136}.Release|x64.Build.0 = Release|x64
		{4A69FC80-8531-4350-B836-A1076D2FD136}.Release|x86.ActiveCfg = Release|Win32
		{4A69FC80-8531-4350-B836-A1076D2FD136}.Release|x86.Build.0 = Release|Win32
		{30EAC4AD-21EC-4982-B136-2BB9C1361551}.Debug|ARM.ActiveCfg = Debug|ARM
		{30EAC4AD-21EC-4982-B136-2BB9C1361551}.Debug|ARM.Build.0 = Debug|ARM
		{30EAC4AD-21EC-4982-B136-2BB9C1361551}.Debug|ARM.Deploy.0 = Debug|ARM
		{30EAC4AD-21EC-4982-B136-2BB9C1361551}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{30EAC4AD-21EC-4982-B136-2BB9C1361551}.Debug|ARM64.Build.0 = Debug|ARM64
		{30EAC4AD-21EC-4982-B136-2BB9C1361551}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{30EAC4AD-21EC-4982-B136-2BB9C1361551}.Debug|x64.ActiveCfg = Debug|x64
		{30EAC4AD-21EC-4982-B136-2BB9C1361551}.Debug|x64.Build.0 = Debug|x64
		{30EAC4AD-21EC-4982-B136-2BB9C1361551}.Debug|x64.Deploy.0 = Debug|x64
		{30EAC4AD-21EC-4982-B136-2BB9C1361551}.Debug|x86.ActiveCfg = Debug|Win32
		{30EAC4AD-21EC-4982-B136-2BB9C1361551}.Debug|x86.Build.0 = Debug|Win32
		{30EAC4AD-21EC-4982-B136-2BB9C1361551}.Debug|x86.Deploy.0 = Debug|Win32
		{30EAC4AD-21EC-4982-B136-2BB9C1361551}.Release|ARM.ActiveCfg = Release|ARM
		{30EAC4AD-21EC-4982-B136-2BB9C1361551}.Release|ARM.Build.0 = Release|ARM
		{30EAC4AD-21EC-4982-B136-2BB9C1361551}.Release|ARM.Deploy.0 = Release|ARM
		{30EAC4AD-21EC-4982-B136-2BB9C1361551}.Release|ARM64.ActiveCfg = Release|ARM64
		{30EAC4AD-21EC-4982-B136-2BB9C1361551}.Release|ARM64.Build.0 = Release|ARM64
		{30EAC4AD-21EC-4982-B136-2BB9C1361551}.Release|ARM64.Deploy.0 = Release|ARM64
		{30EAC4AD-21EC-4982-B136-2BB9C1361551}.Release|x64.ActiveCfg = Release|x64
		{30EAC4AD-21EC-4982-B136-2BB9C1361551}.Release|x64.Build.0 = Release|x64
		{30EAC4AD-21EC-4982-B136-2BB9C1361551}.Release|x64.Deploy.0 = Release|x64
		{30EAC4AD-21EC-4982-B136-2BB9C1361551}.Release|x86.ActiveCfg = Release|Win32
		{30EAC4AD-21EC-4982-B136-2BB9C1361551}.Release|x86.Build.0 = Release|Win32
		{30EAC4AD-21EC-4982-B136-2BB9C1361551}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {F07BEE3F-562E-4CF1-A73A-62601F46C319}
	EndGlobalSection
EndGlobal

```

`modern_warfare/core/driver/driver.h`:

```h
#pragma once
#include <cstdint>
#include <memory>
#include <string_view>
#include <windows.h>
#include <TlHelp32.h>
#include <mutex>
#include <iostream>
#include "../game/sdk.h"

typedef struct _COPY_MEMORY {
	void*		buffer;
	ULONG64		address;
	ULONG		size;
	HANDLE		pid;
	bool		get_pid;
	bool		base;
	bool		peb;
	bool		read;
	bool		write;
	const char* module_name;
	const char* process_name;
}COPY_MEMORY;

namespace driver {
	static std::once_flag flag;

	template<typename ... A>
	uint64_t call_hook(const A ... arguments)
	{
		std::call_once(flag, [] { LoadLibrary("user32.dll"); });
		void* control_function = GetProcAddress(LoadLibrary("win32u.dll"), "NtOpenCompositionSurfaceSectionInfo");
		const auto control = static_cast<uint64_t(__stdcall*)(A...)>(control_function);
		return control(arguments ...);
	}

	static HANDLE get_process_id(const char* process_name) {
		COPY_MEMORY m{};
		m.get_pid = true;
		m.process_name = process_name;
		call_hook(&m);

		return m.pid;
	}

	static uintptr_t get_module_base_address(const char* module_name) {
		COPY_MEMORY m{};
		m.base = true;
		m.pid = sdk::process_id;
		m.module_name = module_name;
		call_hook(&m);

		return (uintptr_t)m.buffer;
	}

	static uintptr_t get_peb() {
		COPY_MEMORY m{};
		m.peb = true;
		m.pid = sdk::process_id;
		call_hook(&m);

		return (uintptr_t)m.buffer;
	}

	template <typename type>
	type read(ULONG64 address) {
		type buffer{};

		COPY_MEMORY m{};
		m.read = true;
		m.pid = sdk::process_id;
		m.address = address;
		m.buffer = &buffer;
		m.size = sizeof(type);

		call_hook(&m);
		return buffer;
	}

	template <typename type>
	void write(ULONG64 address, type value, ULONG size = sizeof(value))
	{
		COPY_MEMORY m{};
		m.write = true;
		m.pid = sdk::process_id;
		m.address = address;
		m.buffer = &value;
		m.size = size;

		call_hook(&m);
	}
}
```

`modern_warfare/core/game/offsets.h`:

```h
#pragma once

/* UPDATED - 2021-08-09 */

namespace offsets
{
	constexpr auto camera_base = 0x14417F80;
	constexpr auto camera_pos = 0x1D8;
	constexpr auto game_mode = 0x0;
	constexpr auto local_index = 0x27540;
	constexpr auto name_array = 0x17226E58;
	constexpr auto name_array_padding = 0x4C70;
	constexpr auto ref_def_ptr = 0x1721BBB0;
	constexpr auto score_base = 0x0;
	constexpr auto weapon_definition = 0x0;
	constexpr auto client_info = 0x17219218;
	constexpr auto client_base = 0x9DBF8;

	namespace bones
	{
		constexpr auto bone_base = 0x0;
		constexpr auto distribute = 0x0;
		constexpr auto size = 0x150;
		constexpr auto visible = 0x0;
	}

	namespace directx
	{
		constexpr auto command_queue = 0x0;
		constexpr auto swap_chain = 0x0;
	}

	namespace other
	{
		constexpr auto recoil = 0x0;
	}

	namespace player
	{
		constexpr auto dead_1 = 0x64BD;
		constexpr auto dead_2 = 0x7FB0;
		constexpr auto pos_info = 0x448;
		constexpr auto size = 0x3AA8;
		constexpr auto stance = 0x76C;
		constexpr auto team_id = 0x2DF4;
		constexpr auto valid = 0x488;
		constexpr auto weapon_index = 0x0;
	}
}

```

`modern_warfare/core/game/sdk.cpp`:

```cpp
#include "sdk.h"
#include "..\driver\driver.h"
#include "offsets.h"

namespace sdk {
	HANDLE	  process_id = NULL;
	uintptr_t module_base = NULL;
	uintptr_t peb = NULL;
	HWND      hwnd = NULL;

	uintptr_t client_info = NULL;
	uintptr_t client_info_base = NULL;

	BOOL CALLBACK enum_windows(HWND hwnd, LPARAM param) {
		DWORD process_id;
		GetWindowThreadProcessId(hwnd, &process_id);
		if (process_id == param)
		{
			sdk::hwnd = hwnd;
			return false;
		}
		return true;
	}

	void set_game_hwnd() {
		EnumWindows(enum_windows, (LPARAM)sdk::process_id);
	}

	bool in_game() {
		return driver::read<int>(sdk::module_base + offsets::game_mode) > 1;
	}

	int player_count() {
		return driver::read<uintptr_t>(sdk::module_base + offsets::game_mode);
	}

	int local_index() {
		auto local_index = driver::read<uintptr_t>(sdk::client_info + offsets::local_index);
		return driver::read<int>(local_index + 0x1FC);
	}
		
	bool player_t::is_valid() {
		return driver::read<bool>(address + offsets::player::valid);
	}
		
	bool player_t::dead() {
		auto dead1 = driver::read<bool>(address + offsets::player::dead_1);
		auto dead2 = driver::read<bool>(address + offsets::player::dead_2);
		return dead1 || dead2;
	}

	int player_t::team_id() {
		return driver::read<int>(address + offsets::player::team_id);
	}

	vec3_t player_t::get_pos() {
		auto local_pos = driver::read<uintptr_t>(address + offsets::player::pos_info);
		return driver::read<vec3_t>(local_pos + 0x40);
	}

	vec3_t get_camera_position() {
		auto camera = driver::read<uintptr_t>(sdk::module_base + offsets::camera_base);
		if (!camera)
			return {};

		return driver::read<vec3_t>(camera + offsets::camera_pos);
	}

	bool world_to_screen(vec3_t world_location, vec2_t& out, vec3_t camera_pos, int screen_width, int screen_height, vec2_t fov, vec3_t matricies[3]) {
		auto local = world_location - camera_pos;
		auto trans = vec3_t{
			local.dot(matricies[1]),
			local.dot(matricies[2]),
			local.dot(matricies[0])
		};

		if (trans.z < 0.01f) {
			return false;
		}

		out.x = ((float)screen_width / 2.0) * (1.0 - (trans.x / fov.x / trans.z));
		out.y = ((float)screen_height  / 2.0) * (1.0 - (trans.y / fov.y / trans.z));

		if (out.x < 1 || out.y < 1 || (out.x > sdk::ref_def.width) || (out.y > sdk::ref_def.height)) {
			return false;
		}

		return true;
	}

	bool w2s(vec3_t world_position, vec2_t& screen_position) {
		return world_to_screen(world_position, screen_position, get_camera_position(), ref_def.width, ref_def.height, ref_def.view.tan_half_fov, ref_def.view.axis);
	}

	float units_to_m(float units) {
		return units * 0.0254;
	}

	ref_def_t ref_def;
}

namespace decryption {
	uintptr_t get_client_info() {
		uint64_t RAX = 0, RBX = 0, RCX = 0, RDX = 0, R8 = 0, RDI = 0, RSI = 0, R9 = 0, R10 = 0, R11 = 0, R12 = 0, R13 = 0, R14 = 0, R15 = 0;

		RBX = driver::read<uint64_t>(sdk::module_base + 0x17224118);
		R8 = sdk::peb; // mov r8,gs:[rax]
		RAX = sdk::module_base;
		RBX += RAX;
		RAX = RBX;
		RAX >>= 0x10;
		RBX ^= RAX;
		RAX = RBX;
		RCX = 0x0;
		RAX >>= 0x20;
		RAX ^= RBX;
		RCX = _rotl64(RCX, 0x10);
		RCX ^= driver::read<uint64_t>(sdk::module_base + 0x660D10A);
		RCX = _byteswap_uint64(RCX);
		RBX = driver::read<uint64_t>(RCX + 0x13);
		RBX *= RAX;
		RAX = 0x76D048452DCF6909;
		RBX -= R8;
		R8 = ~R8;
		RBX *= RAX;
		RAX = sdk::module_base + 0x2C8CD073;
		R8 += RAX;
		RBX ^= R8;
		return RBX;
	}

	uintptr_t get_client_info_base() {
		uint64_t RAX = 0, RBX = 0, RCX = 0, RDX = 0, RSP = 0, R8 = 0, RDI = 0, RSI = 0, R9 = 0, R10 = 0, R11 = 0, R12 = 0, R13 = 0, R14 = 0, R15 = 0;

		RAX = driver::read<uint64_t>(sdk::client_info + offsets::client_base);
		RBX = sdk::peb; // mov rbx,gs:[rcx]
		// test rax,rax
		// je 00007FF77524D6C8h
		RCX = RBX;
		RCX <<= 0x21;
		RCX = _byteswap_uint64(RCX);
		RCX &= 0xF;
		// cmp rcx,0Eh
		// ja 00007FF77524D2A4h
		switch (RCX) {
		case 0: {
			R9 = driver::read<uint64_t>(sdk::module_base + 0x660D140);
			RCX = 0x0;
			RCX = _rotl64(RCX, 0x10);
			RCX ^= R9;
			RCX = _byteswap_uint64(RCX);
			RAX *= driver::read<uint64_t>(RCX + 0xB);
			RCX = RAX;
			RCX >>= 0x18;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x30;
			RAX ^= RCX;
			RCX = sdk::module_base;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x8;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x10;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x20;
			RAX ^= RCX;
			RCX = 0x345963FE4F9F5BC7;
			RAX *= RCX;
			RCX = 0x1BC0D0E9288C6DB3;
			RAX += RCX;
			RAX += RBX;
			RCX = sdk::module_base;
			RAX -= RCX;
			return RAX;
		}
		case 1: {
			R11 = sdk::module_base + 0x6064722A;
			R10 = driver::read<uint64_t>(sdk::module_base + 0x660D140);
			RCX = RBX;
			RCX ^= R11;
			RAX -= RCX;
			RCX = RAX;
			RCX >>= 0x11;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x22;
			RAX ^= RCX;
			RAX ^= RBX;
			RCX = sdk::module_base + 0x28AB;
			RCX = ~RCX;
			RCX -= RBX;
			RAX += RCX;
			RCX = 0x16A1C31B3D93A83F;
			RAX *= RCX;
			RCX = 0xD0C234BF8A55764B;
			RAX *= RCX;
			RCX = 0x0;
			RCX = _rotl64(RCX, 0x10);
			RCX ^= R10;
			RCX = _byteswap_uint64(RCX);
			RAX *= driver::read<uint64_t>(RCX + 0xB);
			RCX = 0xB75E6F62B4DBBCC1;
			RAX *= RCX;
			return RAX;
		}
		case 2: {
			R14 = sdk::module_base + 0x30A5;
			R10 = driver::read<uint64_t>(sdk::module_base + 0x660D140);
			RCX = RAX;
			RCX >>= 0x15;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x2A;
			RAX ^= RCX;
			RCX = RBX;
			RCX = ~RCX;
			RCX ^= R14;
			RAX -= RCX;
			RCX = 0x0;
			RCX = _rotl64(RCX, 0x10);
			RCX ^= R10;
			RCX = _byteswap_uint64(RCX);
			RAX *= driver::read<uint64_t>(RCX + 0xB);
			RCX = 0x5D11A30DE94FFEDE;
			RAX += RCX;
			RCX = RAX;
			RCX >>= 0x1B;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x36;
			RAX ^= RCX;
			RAX ^= RBX;
			RCX = 0x1D2CA89A1A1BE3D9;
			RAX ^= RCX;
			RCX = 0xDD63D27B22050957;
			RAX *= RCX;
			return RAX;
		}
		case 3: {
			R14 = sdk::module_base + 0x7B3CDBC1;
			R10 = driver::read<uint64_t>(sdk::module_base + 0x660D140);
			RDX = RBX;
			RDX = ~RDX;
			RCX = R14;
			RCX = ~RCX;
			RDX *= RCX;
			RAX += RDX;
			RCX = RAX;
			RCX >>= 0x26;
			RCX ^= RAX;
			RAX = RCX + RBX;
			RCX = sdk::module_base;
			RAX -= RCX;
			RAX -= 0x7736E4C5;
			RCX = 0xA4C7B3171334DA2E;
			RAX ^= RCX;
			RCX = 0x667B75570F23711D;
			RAX *= RCX;
			RCX = 0x7E05078E8B5B3EDA;
			RAX -= RCX;
			RCX = 0x0;
			RCX = _rotl64(RCX, 0x10);
			RCX ^= R10;
			RCX = _byteswap_uint64(RCX);
			RAX *= driver::read<uint64_t>(RCX + 0xB);
			return RAX;
		}
		case 4: {
			R9 = driver::read<uint64_t>(sdk::module_base + 0x660D140);
			RAX ^= RBX;
			RCX = 0x0;
			RCX = _rotl64(RCX, 0x10);
			RCX ^= R9;
			RCX = _byteswap_uint64(RCX);
			RCX = driver::read<uint64_t>(RCX + 0xB);
			RSP = 0x64DE26759A457153;
			RCX *= RSP;
			RAX *= RCX;
			RCX = RAX;
			RCX >>= 0x24;
			RAX ^= RCX;
			RCX = 0x49AF5B2E74070925;
			RAX *= RCX;
			RCX = 0xB5CC279242DD0301;
			RAX *= RCX;
			return RAX;
		}
		case 5: {
			R11 = driver::read<uint64_t>(sdk::module_base + 0x660D140);
			R15 = sdk::module_base + 0x6BA9;
			RDX = sdk::module_base + 0x5F9E55C9;
			RDX = ~RDX;
			RDX ^= RBX;
			RCX = RAX;
			RAX = 0xBF5978C960F6BB4B;
			RAX ^= RCX;
			RAX += RDX;
			RDX = sdk::module_base + 0x28877536;
			RCX = RAX;
			RCX >>= 0x18;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x30;
			RAX ^= RCX;
			RCX = RBX;
			RCX = ~RCX;
			RCX *= R15;
			RAX ^= RCX;
			R8 = 0x0;
			R8 = _rotl64(R8, 0x10);
			R8 ^= R11;
			RCX = RBX;
			RCX *= RDX;
			RDX = RAX;
			RDX -= RCX;
			RCX = 0x84229F2B4FE6843B;
			R8 = _byteswap_uint64(R8);
			RAX = driver::read<uint64_t>(R8 + 0xB);
			RAX *= RDX;
			RAX *= RCX;
			RAX ^= RBX;
			return RAX;
		}
		case 6: {
			R15 = sdk::module_base + 0xE397;
			R10 = driver::read<uint64_t>(sdk::module_base + 0x660D140);
			RCX = sdk::module_base;
			RAX += RCX;
			RCX = sdk::module_base;
			RAX += RCX;
			RCX = 0x4030351D523D85BB;
			RAX += RCX;
			RCX = RBX;
			RCX ^= R15;
			RAX += RCX;
			RCX = 0x71A01F36E5BF55AF;
			RAX *= RCX;
			RCX = RAX;
			RCX >>= 0x10;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x20;
			RCX ^= RAX;
			RDX = 0x0;
			RDX = _rotl64(RDX, 0x10);
			RDX ^= R10;
			RDX = _byteswap_uint64(RDX);
			RAX = driver::read<uint64_t>(RDX + 0xB);
			RDX = sdk::module_base + 0x31AFF9CE;
			RAX *= RCX;
			RCX = RBX;
			RCX *= RDX;
			RAX -= RCX;
			return RAX;
		}
		case 7: {
			R10 = driver::read<uint64_t>(sdk::module_base + 0x660D140);
			R15 = sdk::module_base + 0x9CF0;
			RCX = RAX;
			RCX >>= 0x19;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x32;
			RAX ^= RCX;
			RCX = sdk::module_base;
			RCX += 0x16E9;
			RCX += RBX;
			RAX ^= RCX;
			RDX = 0x0;
			RDX = _rotl64(RDX, 0x10);
			RDX ^= R10;
			RCX = RBX;
			RDX = _byteswap_uint64(RDX);
			RCX ^= R15;
			RDX = driver::read<uint64_t>(RDX + 0xB);
			RAX *= RDX;
			RAX -= RCX;
			RCX = RAX;
			RCX >>= 0xA;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x14;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x28;
			RAX ^= RCX;
			RCX = 0x201300BD919020EB;
			RAX *= RCX;
			RCX = 0x136871F8B2311042;
			RAX += RCX;
			RCX = 0xE0229051A9F3C38B;
			RAX ^= RCX;
			return RAX;
		}
		case 8: {
			R15 = sdk::module_base + 0x6C04;
			R10 = driver::read<uint64_t>(sdk::module_base + 0x660D140);
			RCX = 0x0;
			RCX = _rotl64(RCX, 0x10);
			RCX ^= R10;
			RCX = _byteswap_uint64(RCX);
			RDX = driver::read<uint64_t>(RCX + 0xB);
			RCX = 0x866F75E98D0D53B1;
			RDX *= RAX;
			RAX = RBX;
			RAX *= R15;
			RDX += RAX;
			RDX ^= RBX;
			RAX = RDX;
			RAX >>= 0x20;
			RAX ^= RDX;
			RAX ^= RCX;
			RCX = 0x9E0D951F0C28F90B;
			RAX *= RCX;
			RCX = 0x78503CB374B04FAD;
			RAX *= RCX;
			RCX = RAX;
			RCX >>= 0x2;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x4;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x8;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x10;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x20;
			RAX ^= RCX;
			return RAX;
		}
		case 9: {
			R14 = sdk::module_base + 0x6CFB74E0;
			R11 = sdk::module_base + 0x7F309832;
			R9 = driver::read<uint64_t>(sdk::module_base + 0x660D140);
			RCX = 0x0;
			RCX = _rotl64(RCX, 0x10);
			RCX ^= R9;
			RCX = _byteswap_uint64(RCX);
			RAX *= driver::read<uint64_t>(RCX + 0xB);
			RAX ^= RBX;
			RAX ^= R14;
			RCX = RAX;
			RCX >>= 0x17;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x2E;
			RAX ^= RCX;
			RCX = 0xD7356E290A5B1FBA;
			RAX += RCX;
			RCX = sdk::module_base;
			RAX ^= RCX;
			RCX = 0xD80D8A31210F08D3;
			RAX *= RCX;
			RCX = R11;
			RCX = ~RCX;
			RCX ^= RBX;
			RAX -= RCX;
			RCX = RAX;
			RCX >>= 0x9;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x12;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x24;
			RAX ^= RCX;
			return RAX;
		}
		case 10: {
			R9 = driver::read<uint64_t>(sdk::module_base + 0x660D140);
			R11 = sdk::module_base + 0x6AD2A7C4;
			RAX -= RBX;
			RAX ^= RBX;
			RCX = 0x29222BE3E0E2FFB;
			RAX ^= R11;
			R11 = sdk::module_base;
			RAX *= RCX;
			RCX = 0x5BB04B85CD9365D;
			RAX -= RBX;
			RAX += RCX;
			RAX += R11;
			RCX = 0x0;
			RCX = _rotl64(RCX, 0x10);
			RCX ^= R9;
			RCX = _byteswap_uint64(RCX);
			RAX *= driver::read<uint64_t>(RCX + 0xB);
			RCX = 0x5FC588EC700475F3;
			RAX *= RCX;
			RCX = RAX;
			RCX >>= 0xC;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x18;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x30;
			RAX ^= RCX;
			return RAX;
		}
		case 11: {
			R10 = driver::read<uint64_t>(sdk::module_base + 0x660D140);
			R14 = sdk::module_base + 0xCF97;
			RDX = R14;
			RDX = ~RDX;
			RDX++;
			RDX += RBX;
			RAX ^= RDX;
			RCX = sdk::module_base + 0xCA22;
			RAX += RBX;
			RDX = sdk::module_base;
			RAX += RCX;
			RCX = RBX;
			RCX = ~RCX;
			RCX -= RDX;
			RCX -= 0x1236;
			RAX ^= RCX;
			RCX = 0x48502E6384BA9941;
			RAX *= RCX;
			RCX = 0x5EB925E16D423E1E;
			RAX -= RCX;
			RCX = 0x0;
			RCX = _rotl64(RCX, 0x10);
			RCX ^= R10;
			RCX = _byteswap_uint64(RCX);
			RAX *= driver::read<uint64_t>(RCX + 0xB);
			RCX = 0xE5AB625D3BB65BBF;
			RAX *= RCX;
			RCX = RAX;
			RCX >>= 0x1F;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x3E;
			RAX ^= RCX;
			return RAX;
		}
		case 12: {
			R15 = sdk::module_base + 0xEE34;
			R10 = driver::read<uint64_t>(sdk::module_base + 0x660D140);
			RCX = RBX + 1;
			RCX *= R15;
			RAX += RCX;
			RAX ^= RBX;
			RCX = 0xBF0F6EC504339C71;
			RAX *= RCX;
			RCX = 0x62753D45ABF968CD;
			RAX -= RCX;
			RCX = 0x28C82E52D21EB6AB;
			RAX -= RCX;
			RCX = 0x0;
			RCX = _rotl64(RCX, 0x10);
			RCX ^= R10;
			RCX = _byteswap_uint64(RCX);
			RAX *= driver::read<uint64_t>(RCX + 0xB);
			RCX = RAX;
			RCX >>= 0xB;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x16;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x2C;
			RAX ^= RCX;
			RCX = sdk::module_base;
			RAX ^= RCX;
			return RAX;
		}
		case 13: {
			R10 = driver::read<uint64_t>(sdk::module_base + 0x660D140);
			RCX = 0x0;
			RCX = _rotl64(RCX, 0x10);
			RCX ^= R10;
			RCX = _byteswap_uint64(RCX);
			RAX *= driver::read<uint64_t>(RCX + 0xB);
			RCX = RAX;
			RCX >>= 0x2;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x4;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x8;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x10;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x20;
			RAX ^= RCX;
			RDX = RAX;
			RDX >>= 0x22;
			RDX ^= RAX;
			RCX = 0xAB96BD5255F50EEF;
			RAX = sdk::module_base + 0x4795B778;
			RAX = ~RAX;
			RAX ^= RBX;
			RAX += RDX;
			RAX *= RCX;
			RAX -= RBX;
			RCX = 0x697DECF064AB09C3;
			RAX *= RCX;
			RCX = RBX;
			RSP = sdk::module_base + 0xE842;
			RCX *= RSP;
			RAX += RCX;
			return RAX;
		}
		case 14: {
			R9 = driver::read<uint64_t>(sdk::module_base + 0x660D140);
			RCX = RAX;
			RCX >>= 0xB;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x16;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x2C;
			RAX ^= RCX;
			RCX = 0x0;
			RCX = _rotl64(RCX, 0x10);
			RCX ^= R9;
			RCX = _byteswap_uint64(RCX);
			RCX = driver::read<uint64_t>(RCX + 0xB);
			RSP = 0xF2B84228009F892B;
			RCX *= RSP;
			RAX *= RCX;
			R10 = 0x21D0F0E2660F5094;
			RCX = RBX;
			RCX = ~RCX;
			RSP = sdk::module_base + 0x2E00;
			RCX *= RSP;
			RCX += R10;
			RAX += RCX;
			RCX = RAX;
			RCX >>= 0x10;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x20;
			RAX ^= RCX;
			RCX = 0x1E450D45A88B3DC9;
			RAX *= RCX;
			RCX = RAX;
			RCX >>= 0x17;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x2E;
			RAX ^= RCX;
			return RAX;
		}
		case 15: {
			R9 = driver::read<uint64_t>(sdk::module_base + 0x660D140);
			RCX = sdk::module_base;
			RAX ^= RCX;
			RCX = 0x104FF8B4C43406AD;
			RAX += RCX;
			RCX = 0x16DB4431461A3E29;
			RAX *= RCX;
			RCX = 0x0;
			RCX = _rotl64(RCX, 0x10);
			RCX ^= R9;
			RCX = _byteswap_uint64(RCX);
			RAX *= driver::read<uint64_t>(RCX + 0xB);
			RCX = RAX;
			RCX >>= 0x13;
			RAX ^= RCX;
			RCX = RAX;
			RCX >>= 0x26;
			RAX ^= RCX;
			RCX = sdk::module_base;
			RAX -= RCX;
			RAX += 0xFFFFFFFFFFFF9A85;
			RAX += RBX;
			RCX = 0x11B2D7215841BEB4;
			RSP = sdk::module_base;
			RCX -= RSP;
			RAX += RCX;
			return RAX;
		}
		default:
			return 0;
		}
	}

	uint64_t get_bone() {
		uint64_t RAX = sdk::module_base, RBX = sdk::module_base, RCX = sdk::module_base, RDX = sdk::module_base, R8 = sdk::module_base, RDI = sdk::module_base, R9 = sdk::module_base, R10 = sdk::module_base, R11 = sdk::module_base, R12 = sdk::module_base, R13 = sdk::module_base, R14 = sdk::module_base, R15 = sdk::module_base, RSI = sdk::module_base, RSP = sdk::module_base, RBP = sdk::module_base;
		RDX = driver::read<uint64_t>(sdk::module_base + 0x15B582C8);
		
		if (!RDX)
			return 0;
		R8 = sdk::peb;
		R8 = (~R8);
		// test rdx,rdx
		// je near ptr 00000000024FFDFEh
		RAX = R8;
		RAX = _rotl64(RAX, 0x28);
		RAX &= 0xF;
		switch (RAX)
		{
		case 0:
		{
			R14 = sdk::module_base + 0x4D63FF68;
			R11 = sdk::module_base + 0xE7E;
			RBX = driver::read<uint64_t>(sdk::module_base + 0x6CC41F9);
			RAX = 0x38330DCD6D3EE86B;
			RDX *= RAX;
			RAX = 0x62FA53C3F4793FE6;
			RDX ^= RAX;
			RAX = R8;
			RAX = (~RAX);
			RDX += RAX;
			RAX = sdk::module_base + 0x572A;
			RDX += RAX;
			RAX = RDX;
			RAX >>= 0x1A;
			RDX ^= RAX;
			RAX = RDX;
			RAX >>= 0x34;
			RDX ^= RAX;
			RCX = R14;
			RCX = (~RCX);
			RCX += R8;
			RAX = 0xBA6195B9FE5C98BF;
			RAX += RDX;
			RDX = RCX;
			RDX ^= RAX;
			// mov rax,[rbp+598h]
			RAX -= R11;
			RAX = 0; // Special case
			RAX = _rotl64(RAX, 0x10);
			RAX ^= RBX;
			RAX = (~RAX);
			if (!((void*)(RAX + 0x15))) return 0xFFFFFFFFFFFFFFFF; RDX *= driver::read<uint64_t>(RAX + 0x15);
			RDX -= R8;
			return RDX;
		}
		case 1:
		{
			RBX = driver::read<uint64_t>(sdk::module_base + 0x6CC41F9);
			
			R11 = sdk::module_base + 0xE7E;
			R12 = sdk::module_base + 0x3FC;
			RCX = R8 + R12;
			RAX = RDX + R8;
			RDX = RCX;
			RDX ^= RAX;
			RAX = 0xB0D1385078A56D19;
			RDX *= RAX;
			// mov rax,[rbp+598h]
			RAX -= R11;
			RAX = 0; // Special case
			RAX = _rotl64(RAX, 0x10);
			RAX ^= RBX;
			RAX = (~RAX);
			if (!((void*)(RAX + 0x15))) return 0xFFFFFFFFFFFFFFFF; RAX = driver::read<uint64_t>(RAX + 0x15);
			RDX *= RAX;
			RAX = sdk::module_base;
			RDX -= RAX;
			RAX = RDX;
			RAX >>= 0x1D;
			RDX ^= RAX;
			RAX = RDX;
			RAX >>= 0x3A;
			RDX ^= RAX;
			RAX = 0xD1151DF1B15559FB;
			RDX *= RAX;
			RAX = 0x14B61D0484FBBE03;
			RDX *= RAX;
			return RDX;
		}
		case 2:
		{
			R11 = sdk::module_base + 0xE7E;
			R10 = driver::read<uint64_t>(sdk::module_base + 0x6CC41F9);
			RAX = 0xCC268FDEC36DA697;
			RDX *= RAX;
			// mov rax,[rbp+598h]
			RAX -= R11;
			RAX = 0; // Special case
			RAX = _rotl64(RAX, 0x10);
			RAX ^= R10;
			RAX = (~RAX);
			if (!((void*)(RAX + 0x15))) return 0xFFFFFFFFFFFFFFFF; RDX *= driver::read<uint64_t>(RAX + 0x15);
			RAX = sdk::module_base + 0x40F5FF82;
			RAX = (~RAX);
			RAX -= R8;
			RDX ^= RAX;
			RAX = RDX;
			RAX >>= 0x19;
			RDX ^= RAX;
			RAX = RDX;
			RAX >>= 0x32;
			RDX ^= RAX;
			RAX = 0x70067EEE063A673C;
			RDX += RAX;
			RDX -= R8;
			RAX = sdk::module_base;
			RDX ^= RAX;
			return RDX;
		}
		case 3:
		{
			R11 = sdk::module_base + 0xE7E;
			R9 = driver::read<uint64_t>(sdk::module_base + 0x6CC41F9);
			RAX = RDX;
			RAX >>= 0x12;
			RDX ^= RAX;
			RAX = RDX;
			RAX >>= 0x24;
			RDX ^= RAX;
			RAX = RDX;
			RAX >>= 0x1F;
			RDX ^= RAX;
			RAX = RDX;
			RAX >>= 0x3E;
			RDX ^= RAX;
			RAX = 0x57A81BEC6516033D;
			RDX += RAX;
			// mov rax,[rbp+598h]
			RAX -= R11;
			RAX = 0; // Special case
			RAX = _rotl64(RAX, 0x10);
			RAX ^= R9;
			RAX = (~RAX);
			if (!((void*)(RAX + 0x15))) return 0xFFFFFFFFFFFFFFFF; RDX *= driver::read<uint64_t>(RAX + 0x15);
			RAX = RDX;
			RAX >>= 0x7;
			RDX ^= RAX;
			RAX = RDX;
			RAX >>= 0xE;
			RDX ^= RAX;
			RAX = RDX;
			RAX >>= 0x1C;
			RDX ^= RAX;
			RAX = RDX;
			RAX >>= 0x38;
			RDX ^= RAX;
			RAX = 0x96699980B562505;
			RDX *= RAX;
			RAX = sdk::module_base;
			RDX ^= RAX;
			return RDX;
		}
		case 4:
		{
			R11 = sdk::module_base + 0xE7E;
			RBX = driver::read<uint64_t>(sdk::module_base + 0x6CC41F9);
			RAX = 0x1B512279D332955D;
			RDX -= RAX;
			// mov rax,[rbp+598h]
			RAX -= R11;
			RAX = 0; // Special case
			RAX = _rotl64(RAX, 0x10);
			RAX ^= RBX;
			RAX = (~RAX);
			if (!((void*)(RAX + 0x15))) return 0xFFFFFFFFFFFFFFFF; RDX *= driver::read<uint64_t>(RAX + 0x15);
			RAX = RDX;
			RAX >>= 0x22;
			RDX ^= RAX;
			RDX ^= R8;
			RAX = 0x3EE6F0C8BA258B0A;
			RDX += RAX;
			RAX = sdk::module_base + 0x2415;
			RAX -= R8;
			RDX += RAX;
			RAX = 0x8A1CDFF81DB6DFF;
			RDX *= RAX;
			RDX += R8;
			return RDX;
		}
		case 5:
		{
			R10 = driver::read<uint64_t>(sdk::module_base + 0x6CC41F9);
			R11 = sdk::module_base + 0xE7E;
			// mov rax,[rbp+598h]
			RAX -= R11;
			RAX = 0; // Special case
			RAX = _rotl64(RAX, 0x10);
			RAX ^= R10;
			RAX = (~RAX);
			if (!((void*)(RAX + 0x15))) return 0xFFFFFFFFFFFFFFFF; RDX *= driver::read<uint64_t>(RAX + 0x15);
			RAX = sdk::module_base;
			RDX -= RAX;
			RAX = 0x547FD4FF3C645CA9;
			RDX *= RAX;
			RAX = RDX;
			RAX >>= 0xF;
			RDX ^= RAX;
			RAX = RDX;
			RAX >>= 0x1E;
			RDX ^= RAX;
			RAX = RDX;
			RAX >>= 0x3C;
			RDX ^= RAX;
			RAX = RDX;
			RAX >>= 0xC;
			RDX ^= RAX;
			RAX = RDX;
			RAX >>= 0x18;
			RDX ^= RAX;
			RAX = RDX;
			RAX >>= 0x30;
			RDX ^= RAX;
			RAX = 0x781D9F1F2D40889D;
			RDX += RAX;
			RAX = sdk::module_base;
			RDX -= RAX;
			RAX = 0x954A92102762092A;
			RDX ^= RAX;
			return RDX;
		}
		case 6:
		{
			R11 = sdk::module_base + 0xE7E;
			R14 = sdk::module_base + 0x4F53;
			R10 = driver::read<uint64_t>(sdk::module_base + 0x6CC41F9);
			RAX = 0x7C9D860BE61BBC43;
			RDX *= RAX;
			RAX = R14;
			RAX *= R8;
			RDX -= RAX;
			RDX ^= R8;
			RDX += R8;
			RAX = RDX;
			RAX >>= 0x1F;
			RDX ^= RAX;
			RAX = RDX;
			RAX >>= 0x3E;
			RDX ^= RAX;
			RAX = 0x7034B0F1930C5EDC;
			RDX -= RAX;
			// mov rax,[rbp+598h]
			RAX -= R11;
			RAX = 0; // Special case
			RAX = _rotl64(RAX, 0x10);
			RAX ^= R10;
			RAX = (~RAX);
			if (!((void*)(RAX + 0x15))) return 0xFFFFFFFFFFFFFFFF; RAX = driver::read<uint64_t>(RAX + 0x15);
			RDX *= RAX;
			RAX = 0x7B2C304B4173C6F7;
			RDX -= RAX;
			return RDX;
		}
		case 7:
		{
			RBX = driver::read<uint64_t>(sdk::module_base + 0x6CC41F9);
			R11 = sdk::module_base + 0xE7E;
			R12 = sdk::module_base + 0xB0FF;
			RDX -= R8;
			RAX = RDX;
			RAX >>= 0x28;
			RDX ^= RAX;
			RAX = 0xF27E20A569493D17;
			RDX *= RAX;
			RAX = 0x4A436F8C9A9684F2;
			RDX += RAX;
			// mov rax,[rbp+598h]
			RAX -= R11;
			RAX = 0; // Special case
			RAX = _rotl64(RAX, 0x10);
			RAX ^= RBX;
			RAX = (~RAX);
			if (!((void*)(RAX + 0x15))) return 0xFFFFFFFFFFFFFFFF; RAX = driver::read<uint64_t>(RAX + 0x15);
			RSP = 0x746D10714AE9CA49;
			RAX *= RSP;
			RDX *= RAX;
			RCX = R12;
			RCX = (~RCX);
			RAX = R8;
			RAX = (~RAX);
			RCX *= RAX;
			RDX += RCX;
			RAX = RDX;
			RAX >>= 0x1D;
			RDX ^= RAX;
			RAX = RDX;
			RAX >>= 0x3A;
			RDX ^= RAX;
			return RDX;
		}
		case 8:
		{
			RBX = driver::read<uint64_t>(sdk::module_base + 0x6CC41F9);
			R11 = sdk::module_base + 0xE7E;
			R13 = sdk::module_base + 0x1987;
			R12 = sdk::module_base + 0x59DAB869;
			RAX = sdk::module_base;
			RDX += RAX;
			RCX = sdk::module_base + 0xC5;
			RAX = RDX;
			RCX *= R8;
			RDX = 0xCC9633BEB940B34E;
			RDX ^= RAX;
			RDX += RCX;
			RAX = RDX;
			RAX >>= 0x1B;
			RDX ^= RAX;
			RAX = RDX;
			RAX >>= 0x36;
			RDX ^= RAX;
			RAX = 0xAA9085BB5AF94951;
			RDX *= RAX;
			// mov rax,[rbp+598h]
			RAX -= R11;
			RAX = 0; // Special case
			RAX = _rotl64(RAX, 0x10);
			RAX ^= RBX;
			RAX = (~RAX);
			if (!((void*)(RAX + 0x15))) return 0xFFFFFFFFFFFFFFFF; RDX *= driver::read<uint64_t>(RAX + 0x15);
			RAX = R8;
			RAX = (~RAX);
			RAX ^= R12;
			RDX -= RAX;
			RAX = R8 + R13;
			RDX += RAX;
			return RDX;
		}
		case 9:
		{
			R11 = sdk::module_base + 0xE7E;
			R10 = driver::read<uint64_t>(sdk::module_base + 0x6CC41F9);
			RAX = RDX;
			RAX >>= 0x28;
			RDX ^= RAX;
			// mov rax,[rbp+598h]
			RAX -= R11;
			RAX = 0; // Special case
			RAX = _rotl64(RAX, 0x10);
			RAX ^= R10;
			RAX = (~RAX);
			if (!((void*)(RAX + 0x15))) return 0xFFFFFFFFFFFFFFFF; RAX = driver::read<uint64_t>(RAX + 0x15);
			RDX *= RAX;
			RAX = sdk::module_base;
			RDX += RAX;
			RAX = sdk::module_base;
			RDX ^= RAX;
			RAX = 0x2EB32E09A3A9483F;
			RDX ^= RAX;
			RAX = sdk::module_base;
			RDX -= R8;
			RDX -= RAX;
			RDX -= 0x4CF2;
			RAX = sdk::module_base;
			RDX += RAX;
			RAX = 0x5B85E9BB26723E73;
			RDX *= RAX;
			return RDX;
		}
		case 10:
		{
			RBX = driver::read<uint64_t>(sdk::module_base + 0x6CC41F9);
			R11 = sdk::module_base + 0xE7E;
			RAX = R8;
			RAX -= sdk::module_base;
			RAX += 0xFFFFFFFFCDBB51AB;
			RDX += RAX;
			RAX = RDX;
			RAX >>= 0x17;
			RDX ^= RAX;
			RAX = RDX;
			RAX >>= 0x2E;
			RDX ^= RAX;
			RAX = 0xC12A2DA65C4961CD;
			RDX *= RAX;
			RAX = sdk::module_base;
			RDX += RAX;
			RAX = 0xF9373B84DED5636B;
			RDX ^= RAX;
			RAX = 0x91CDED26ACFB0DBB;
			RDX ^= RAX;
			RAX = RDX;
			// mov rcx,[rbp+598h]
			RDX = sdk::module_base;
			RCX -= R11;
			RAX ^= RDX;
			RCX = 0; // Special case
			RCX = _rotl64(RCX, 0x10);
			RCX ^= RBX;
			RCX = (~RCX);
			if (!((void*)(RCX + 0x15))) return 0xFFFFFFFFFFFFFFFF; RDX = driver::read<uint64_t>(RCX + 0x15);
			RDX *= RAX;
			return RDX;
		}
		case 11:
		{
			RBX = driver::read<uint64_t>(sdk::module_base + 0x6CC41F9);
			R11 = sdk::module_base + 0xE7E;
			R15 = sdk::module_base + 0x5A01ECB2;
			RAX = RDX;
			RAX >>= 0x11;
			RDX ^= RAX;
			RAX = RDX;
			RAX >>= 0x22;
			RDX ^= RAX;
			RAX = 0xDE0B65ACC065BF3F;
			RDX *= RAX;
			RAX = sdk::module_base;
			RDX ^= RAX;
			RAX = 0x1641BCAE40423EA9;
			RDX *= RAX;
			RCX = sdk::module_base + 0x1;
			RAX = sdk::module_base + 0x1AF73A5E;
			RAX = (~RAX);
			RAX += R8;
			RCX += RAX;
			RDX += RCX;
			// mov rax,[rbp+598h]
			RAX -= R11;
			RAX = 0; // Special case
			RAX = _rotl64(RAX, 0x10);
			RAX ^= RBX;
			RAX = (~RAX);
			if (!((void*)(RAX + 0x15))) return 0xFFFFFFFFFFFFFFFF; RDX *= driver::read<uint64_t>(RAX + 0x15);
			RAX = R15;
			RAX *= R8;
			RDX -= RAX;
			return RDX;
		}
		case 12:
		{
			RBX = driver::read<uint64_t>(sdk::module_base + 0x6CC41F9);
			R11 = sdk::module_base + 0xE7E;
			R12 = sdk::module_base + 0xE486;
			RAX = RDX;
			RAX >>= 0x10;
			RDX ^= RAX;
			RAX = RDX;
			RAX >>= 0x20;
			RDX ^= RAX;
			RAX = 0xF9625ECE5BB27C2F;
			RDX *= RAX;
			RAX = RDX;
			RAX >>= 0x25;
			RDX ^= RAX;
			RAX = sdk::module_base;
			RDX -= RAX;
			RAX = sdk::module_base + 0xE0F2;
			RAX = (~RAX);
			RAX *= R8;
			RDX ^= RAX;
			// mov rcx,[rbp+598h]
			RCX -= R11;
			RCX = 0; // Special case
			RAX = RDX;
			RCX = _rotl64(RCX, 0x10);
			RCX ^= RBX;
			RDX = 0xD0C187FCC55A5035;
			RAX ^= RDX;
			RCX = (~RCX);
			if (!((void*)(RCX + 0x15))) return 0xFFFFFFFFFFFFFFFF; RDX = driver::read<uint64_t>(RCX + 0x15);
			RDX *= RAX;
			RAX = R12;
			RAX ^= R8;
			RDX -= RAX;
			return RDX;
		}
		case 13:
		{
			RBX = driver::read<uint64_t>(sdk::module_base + 0x6CC41F9);
			R11 = sdk::module_base + 0xE7E;
			R12 = sdk::module_base + 0xEEA3;
			RAX = 0x5C08B7D7B4223813;
			RDX ^= RAX;
			RAX = RDX;
			RAX >>= 0x1C;
			RDX ^= RAX;
			RAX = RDX;
			RAX >>= 0x38;
			RDX ^= RAX;
			RAX = R12;
			RAX ^= R8;
			RDX += RAX;
			RAX = 0x1D4CED329660DAAB;
			RDX *= RAX;
			// mov rcx,[rbp+598h]
			RCX -= R11;
			RCX = 0; // Special case
			RCX = _rotl64(RCX, 0x10);
			RCX ^= RBX;
			RAX = sdk::module_base;
			RDX -= RAX;
			RCX = (~RCX);
			RAX = R8 + 0xFFFFFFFFD665307A;
			RAX += RDX;
			if (!((void*)(RCX + 0x15))) return 0xFFFFFFFFFFFFFFFF; RDX = driver::read<uint64_t>(RCX + 0x15);
			RDX *= RAX;
			RAX = RDX;
			RAX >>= 0xC;
			RDX ^= RAX;
			RAX = RDX;
			RAX >>= 0x18;
			RDX ^= RAX;
			RAX = RDX;
			RAX >>= 0x30;
			RDX ^= RAX;
			RAX = sdk::module_base;
			RDX += RAX;
			return RDX;
		}
		case 14:
		{
			RBX = driver::read<uint64_t>(sdk::module_base + 0x6CC41F9);
			R11 = sdk::module_base + 0xE7E;
			R15 = sdk::module_base + 0x1E21A51C;
			R13 = sdk::module_base + 0x225E76E1;
			R12 = sdk::module_base + 0x1CCE7CED;
			RAX = R15;
			RAX *= R8;
			RDX -= RAX;
			RDX += R8;
			RCX = R8;
			RCX = (~RCX);
			RDX += R13;
			RDX += RCX;
			RAX = RDX;
			RAX >>= 0xF;
			RDX ^= RAX;
			RAX = RDX;
			RAX >>= 0x1E;
			RDX ^= RAX;
			RAX = RDX;
			RAX >>= 0x3C;
			RDX ^= RAX;
			RAX = 0xC1EAFB913E323975;
			RDX *= RAX;
			RAX = sdk::module_base;
			RDX -= RAX;
			RAX = R12;
			RAX *= R8;
			RDX += RAX;
			// mov rax,[rbp+598h]
			RAX -= R11;
			RAX = 0; // Special case
			RAX = _rotl64(RAX, 0x10);
			RAX ^= RBX;
			RAX = (~RAX);
			if (!((void*)(RAX + 0x15))) return 0xFFFFFFFFFFFFFFFF; RDX *= driver::read<uint64_t>(RAX + 0x15);
			return RDX;
		}
		case 15:
		{
			R11 = sdk::module_base + 0xE7E;
			R15 = sdk::module_base + 0x3EF00DB9;
			R12 = sdk::module_base + 0x49C6D582;
			R13 = sdk::module_base + 0x10E06777;
			RBX = driver::read<uint64_t>(sdk::module_base + 0x6CC41F9);
			RAX = 0xF02A39098305851B;
			RDX *= RAX;
			RAX = 0x42A2DDF2A13458E5;
			RDX *= RAX;
			RAX = R12;
			RAX ^= R8;
			RAX += R8;
			RDX += RAX;
			RAX = RDX;
			RAX >>= 0x14;
			RDX ^= RAX;
			RAX = RDX;
			RAX >>= 0x28;
			RDX ^= RAX;
			RAX = R8 + R15;
			RDX ^= RAX;
			// mov rcx,[rbp+598h]
			RCX -= R11;
			RCX = 0; // Special case
			RCX = _rotl64(RCX, 0x10);
			RAX = R8;
			RAX = (~RAX);
			RCX ^= RBX;
			RAX *= R13;
			RCX = (~RCX);
			RAX ^= RDX;
			if (!((void*)(RCX + 0x15))) return 0xFFFFFFFFFFFFFFFF; RDX = driver::read<uint64_t>(RCX + 0x15);
			RDX *= RAX;
			return RDX;
		}
		default:
			return 0;
		}
	}

	uint32_t get_bone_index(uint32_t index) {
		uint64_t RAX = 0, RBX = 0, RCX = 0, RDX = 0, R8 = 0, RDI = 0, R9 = 0, R10 = 0, R11 = 0, R12 = 0, R13 = 0, R14 = 0, RSI = 0, RSP = 0, RBP = 0;
		RBX = index;
		RCX = RBX * 0x13C8;
		RAX = 0x76BCF2ED12008595;
		RBX = sdk::module_base;
		RAX = _umul128(RAX, RCX, &RDX);
		R10 = 0xE09B4B5F1CC2E2BF;
		RDX >>= 0xC;
		RAX = RDX * 0x227F;
		RCX -= RAX;
		RAX = 0xCED712414B44733D;
		R8 = RCX * 0x227F;
		RAX = _umul128(RAX, R8, &RDX);
		RDX >>= 0xD;
		RAX = RDX * 0x279B;
		R8 -= RAX;
		RAX = 0x8ACAD5AD8637C643;
		RAX = _umul128(RAX, R8, &RDX);
		RCX = R8;
		R8 &= 0x1;
		RDX >>= 0xC;
		RAX = RDX * 0x1D83;
		RCX -= RAX;
		RAX = R8 + RCX * 0x2;
		RAX = driver::read<uint16_t>(RBX + RAX * 0x2 + 0x6CCE950);
		R8 = RAX * 0x13C8;
		RAX = R10;
		RAX = _umul128(RAX, R8, &RDX);
		RAX = R10;
		RDX >>= 0xD;
		RCX = RDX * 0x2479;
		R8 -= RCX;
		R9 = R8 * 0x48AA;
		RAX = _umul128(RAX, R9, &RDX);
		RDX >>= 0xD;
		RAX = RDX * 0x2479;
		R9 -= RAX;
		RAX = 0x204081020408103;
		RAX = _umul128(RAX, R9, &RDX);
		RAX = R9;
		RAX -= RDX;
		RAX >>= 0x1;
		RAX += RDX;
		RAX >>= 0x7;
		RCX = RAX * 0xFE;
		RAX = 0xCD85689039B0AD13;
		RAX = _umul128(RAX, R9, &RDX);
		RAX = R9;
		RAX -= RDX;
		RAX >>= 0x1;
		RAX += RDX;
		RAX >>= 0x6;
		RCX += RAX;
		RAX = RCX * 0x8E;
		RCX = R9 + R9 * 0x8;
		RCX <<= 0x4;
		RCX -= RAX;
		RSI = driver::read<uint16_t>(RCX + RBX + 0x6CD5F60);
		
		return RSI;
	}

	struct ref_def_key {
		int ref0;
		int ref1;
		int ref2;
	};

	uintptr_t get_ref_def() {
		ref_def_key crypt = driver::read<ref_def_key>(sdk::module_base + offsets::ref_def_ptr);
		uint64_t baseAddr = sdk::module_base;

		DWORD lower = crypt.ref0 ^ (crypt.ref2 ^ (uint64_t)(baseAddr + offsets::ref_def_ptr)) * ((crypt.ref2 ^ (uint64_t)(baseAddr + offsets::ref_def_ptr)) + 2);
		DWORD upper = crypt.ref1 ^ (crypt.ref2 ^ (uint64_t)(baseAddr + offsets::ref_def_ptr + 0x4)) * ((crypt.ref2 ^ (uint64_t)(baseAddr + offsets::ref_def_ptr + 0x4)) + 2);

		return (uint64_t)upper << 32 | lower; 
	}
}

```

`modern_warfare/core/game/sdk.h`:

```h
#pragma once
#include <cstdint>
#include <windows.h>
#include "..\utils\vectors.h"

namespace sdk {
	extern HANDLE	 process_id;
	extern uintptr_t module_base;
	extern uintptr_t peb;
	extern HWND      hwnd;

	extern uintptr_t client_info;
	extern uintptr_t client_info_base;

	struct ref_def_view {
		vec2_t tan_half_fov;
		char pad[0xC];
		vec3_t axis[3];
	};

	struct ref_def_t {
		int x;
		int y;
		int width;
		int height;
		ref_def_view view;
	};

	extern struct ref_def_t ref_def;

	void set_game_hwnd();

	bool in_game();

	int player_count();

	int local_index();

	class player_t {
	public:
		player_t(uintptr_t address) {
			this->address = address;
		}

		uintptr_t address{};

		bool is_valid();

		bool dead();

		int team_id();

		vec3_t get_pos();
	};

	bool w2s(vec3_t world_position, vec2_t& screen_position);

	float units_to_m(float units);
}

namespace decryption {
	uintptr_t get_client_info();

	uintptr_t get_client_info_base();

	uint64_t get_bone();

	uint32_t get_bone_index(uint32_t index);

	uintptr_t get_ref_def();
}

```

`modern_warfare/core/main.cpp`:

```cpp
#include <iostream>
#include "driver/driver.h"
#include "game/offsets.h"
#include "overlay/hijack/hijack.h"
#include "overlay/renderer/renderer.h"
#include <string>

#define ERROR(msg) std::cout << "[-] " << msg << std::endl; std::cin.get(); exit(EXIT_FAILURE); 
#define ASSERT(cond, msg) if (!cond) { ERROR(msg) }

int main() {
	sdk::process_id = driver::get_process_id("ModernWarfare.exe");
	ASSERT(sdk::process_id, "failed to find pid");

	sdk::module_base = driver::get_module_base_address("ModernWarfare.exe");
	ASSERT(sdk::module_base, "failed to module base");

	sdk::peb = driver::get_peb();
	ASSERT(sdk::peb, "failed to find peb");

	sdk::set_game_hwnd();
	ASSERT(sdk::hwnd, "failed to find window handle");

	ASSERT(hijack::init(), "failed to hijack nvidia overlay");
	ASSERT(renderer::init(), "failed to initlize renderer");

	sdk::client_info = decryption::get_client_info();
	ASSERT(sdk::client_info, "failed to find client_info");

	sdk::client_info_base = decryption::get_client_info_base();
	ASSERT(sdk::client_info_base, "failed to find client_info_base");

	auto ref_def_ptr = decryption::get_ref_def();
	ASSERT(ref_def_ptr, "failed to find ref_def_ptr");

	std::cout << "[-] log" << std::endl;
	std::cout << "	[~] pid:  " << std::hex << sdk::process_id << std::endl;
	std::cout << "	[~] base: " << std::hex << sdk::module_base << std::endl;
	std::cout << "	[~] peb:  " << std::hex << sdk::peb << std::endl;
	std::cout << "	[~] hwnd: " << std::hex << sdk::hwnd << std::endl;
	std::cout << "	[~] client_info:      " << std::hex << sdk::client_info << std::endl;
	std::cout << "	[~] client_info_base: " << std::hex << sdk::client_info_base << std::endl;

	sdk::ref_def = driver::read<sdk::ref_def_t>(ref_def_ptr);

	while (!GetAsyncKeyState(VK_DELETE)) {
		renderer::scene::start();

		renderer::scene::text(vec2_t(sdk::ref_def.width-115, 5), L"overflow", renderer::colors::red_color, renderer::fonts::watermark_font);

		sdk::player_t local(sdk::client_info_base + (sdk::local_index() * offsets::player::size));
		auto local_pos = local.get_pos();
		auto local_team = local.team_id();

		for (int i = 0; i < 150; i++) {
			sdk::player_t player(sdk::client_info_base + (i * offsets::player::size));
			if (!player.is_valid() || player.dead()) {
				continue;
			}

			if (player.team_id() == local_team) {
				continue;
			}

			vec2_t screen; vec3_t pos = player.get_pos();
			if (sdk::w2s(pos, screen)) {
				auto dist = sdk::units_to_m(local_pos.distance_to(pos));

				if (dist < 225) {
					wchar_t buf[6];
					swprintf(buf, sizeof(buf), L"[%.1f]m", dist); // not very efficent
					renderer::scene::text(screen, buf, renderer::colors::red_color, renderer::fonts::tahoma_font);					
				}
			}
		}
		renderer::scene::end();

		sdk::ref_def = driver::read<sdk::ref_def_t>(decryption::get_ref_def());
	}
	renderer::shutdown();

	// no recoil
	//while (true) {
	//	if (GetAsyncKeyState(VK_LBUTTON)) {
	//		DWORD64 r12 = client_info + offsets::other::recoil;
	//		DWORD64 rsi = r12 + 0x4;
	//		DWORD edx = driver::read<DWORD64>(r12 + 0xC);
	//		DWORD ecx = edx;
	//		ecx = ecx ^ (DWORD)r12;
	//		DWORD eax = ecx + 2;
	//		eax = eax * ecx;
	//		ecx = edx;
	//		ecx = ecx ^ (DWORD)rsi;
	//		driver::write(r12, eax, sizeof(float));
	//		eax = ecx + 2;
	//		eax = ecx + 2;
	//		eax = eax * ecx;
	//		driver::write(rsi, eax, sizeof(float));
	//	}
	//}

	return 0;
}

```

`modern_warfare/core/overlay/hijack/hijack.cpp`:

```cpp
#include <iostream>
#include "hijack.h"

namespace hijack {
	HWND hijacked_hwnd{};
	RECT window_rect{};
	D2D1_SIZE_U window_size{};

	bool init() {
		hijacked_hwnd = FindWindowW(L"CEF-OSC-WIDGET", L"NVIDIA GeForce Overlay");
		if (!hijacked_hwnd) {
			std::cout << "[-] failed to find target window handle" << std::endl;
			return false;
		}

		auto apply_window_styles = []() {
			// style trasnperant
			SetWindowLongW(hijacked_hwnd, -20, static_cast<LONG_PTR>((static_cast<int>(GetWindowLongW(hijacked_hwnd, -20)) | 0x20)));

			// transparency
			MARGINS margin = { -1, -1, -1, -1 };
			DwmExtendFrameIntoClientArea(hijacked_hwnd, &margin);
			if (!SetLayeredWindowAttributes(hijacked_hwnd, 0x000000, 0xFF, 0x02)) {
				std::cout << "[-]" << " failed to set hijacked window attributes" << std::endl;
				return false;
			}

			SetWindowDisplayAffinity(hijacked_hwnd, WDA_EXCLUDEFROMCAPTURE);

			return true;
		};

		if (!apply_window_styles()) {
			return false;
		}

		ShowWindow(hijacked_hwnd, SW_SHOW);
		GetClientRect(hijacked_hwnd, &window_rect);
		window_size = D2D1::SizeU(window_rect.right - window_rect.left, window_rect.bottom - window_rect.top);

		return true;
	}
}

```

`modern_warfare/core/overlay/hijack/hijack.h`:

```h
#pragma once
#include <d2d1.h>
#include <stdio.h>
#include <dwmapi.h> 
#pragma comment(lib, "Dwmapi.lib") 

namespace hijack {
	extern HWND hijacked_hwnd;
	extern RECT window_rect;
	extern D2D1_SIZE_U window_size;

	bool init();
}

```

`modern_warfare/core/overlay/renderer/colors.cpp`:

```cpp
#include "renderer.h"

namespace renderer {
	namespace colors {
		ID2D1SolidColorBrush* white_color = nullptr;
		ID2D1SolidColorBrush* red_color = nullptr;
		ID2D1SolidColorBrush* green_color = nullptr;
		ID2D1SolidColorBrush* blue_color = nullptr;
		ID2D1SolidColorBrush* black_color = nullptr;

		bool init( ) {
			internal::render_target->CreateSolidColorBrush( D2D1::ColorF( D2D1::ColorF::White ), &white_color );
			internal::render_target->CreateSolidColorBrush( D2D1::ColorF( D2D1::ColorF::Red ), &red_color );
			internal::render_target->CreateSolidColorBrush( D2D1::ColorF( D2D1::ColorF::Green ), &green_color );
			internal::render_target->CreateSolidColorBrush( D2D1::ColorF( D2D1::ColorF::Blue ), &blue_color );
			internal::render_target->CreateSolidColorBrush( D2D1::ColorF( D2D1::ColorF::Black ), &black_color );
			return true;
		}

		void shutdown( ) {
			white_color->Release( );
			red_color->Release( );
			green_color->Release( );
			blue_color->Release( );
			black_color->Release( );
		}
	}
}

```

`modern_warfare/core/overlay/renderer/fonts.cpp`:

```cpp
#include "renderer.h"


namespace renderer {
	namespace fonts {
		IDWriteTextFormat* watermark_font = nullptr;
		IDWriteTextFormat* tahoma_font = nullptr;

		bool init( ) {
			if (FAILED(internal::factory->CreateTextFormat(L"Tahoma", NULL, DWRITE_FONT_WEIGHT_REGULAR, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL, 22, L"en-us", &watermark_font))) {
				return false;
			}
			
			if (FAILED(internal::factory->CreateTextFormat(L"Tahoma", NULL, DWRITE_FONT_WEIGHT_REGULAR, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL, 13.0, L"en-us", &tahoma_font))) {
				return false;
			}

			return true;
		}

		void shutdown( ) {
			watermark_font->Release( );
			tahoma_font->Release( );
		}
	}
}
```

`modern_warfare/core/overlay/renderer/internal.cpp`:

```cpp
#include "internal.h"
#include <iostream>


namespace renderer {
	namespace internal {
		ID2D1Factory* d2d = nullptr;
		ID2D1HwndRenderTarget* render_target = nullptr;
		IDWriteFactory* factory = nullptr;

		bool init() {
			if (FAILED(D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &d2d))) {
				std::cout << "[-] failed to create render factory" << std::endl;		
				return false;
			}

			if (FAILED(DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory), reinterpret_cast<IUnknown**>((&factory))))) {
				std::cout << "[-] failed to create write factory" << std::endl;
				return false;
			}

			if (FAILED(d2d->CreateHwndRenderTarget(D2D1::RenderTargetProperties(D2D1_RENDER_TARGET_TYPE_DEFAULT, D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN, D2D1_ALPHA_MODE_PREMULTIPLIED)),
				D2D1::HwndRenderTargetProperties(hijack::hijacked_hwnd, hijack::window_size), &render_target))) {
				std::cout << "[-] failed to create render target" << std::endl;
				return false;
			}

			return true;
		}

		void shutdown( ) {
			d2d->Release( );
			factory->Release( );
			render_target->Release( );
		}
	}
}
```

`modern_warfare/core/overlay/renderer/internal.h`:

```h
#pragma once
#include "../hijack/hijack.h"

#include <stdio.h>
#include <dwmapi.h> 
#include <d2d1.h>
#include <dwrite.h>
#pragma comment(lib, "Dwrite")

#pragma comment(lib, "Dwmapi.lib") 
#pragma comment(lib, "d2d1.lib")


namespace renderer {
	namespace internal {
		extern ID2D1Factory* d2d;
		extern ID2D1HwndRenderTarget* render_target;
		extern IDWriteFactory* factory;

		bool init( );
		void shutdown( );
	}
}

```

`modern_warfare/core/overlay/renderer/renderer.cpp`:

```cpp
#include "renderer.h"
#include <iostream>


namespace renderer {
	bool init( ) {
		if (!internal::init()) {
			std::cout << "[-] renderer internal init failed" << std::endl;
			return false;
		}
		
		if (!colors::init()) {
			std::cout << "[-] renderer colors init failed" << std::endl;
			return false;
		}
		
		if (!fonts::init()) {
			std::cout << "[-] renderer fonts init failed" << std::endl;
			return false;
		}

		return true;
	}

	void shutdown() {
		scene::shutdown();
		internal::shutdown();
		colors::shutdown();
		fonts::shutdown();
	}
}

```

`modern_warfare/core/overlay/renderer/renderer.h`:

```h
#pragma once
#include "internal.h"
#include "../../utils/vectors.h"

namespace renderer {
	namespace colors {
		extern ID2D1SolidColorBrush* white_color;
		extern ID2D1SolidColorBrush* red_color;
		extern ID2D1SolidColorBrush* green_color;
		extern ID2D1SolidColorBrush* blue_color;
		extern ID2D1SolidColorBrush* black_color;

		bool init();
		void shutdown();
	}

	namespace fonts {
		extern IDWriteTextFormat* watermark_font;
		extern IDWriteTextFormat* tahoma_font;
		bool init();
		void shutdown();
	}

	namespace scene {
		void start(); 
		void begin();
		void end();
		void clear();
		void shutdown();

		void text(vec2_t pos, const wchar_t* text, ID2D1SolidColorBrush* color, IDWriteTextFormat* font);
		void box(int x, int y, int width, int height, int thick, ID2D1SolidColorBrush* color);
	}

	bool init();
	void shutdown();
}
```

`modern_warfare/core/overlay/renderer/scene.cpp`:

```cpp
#include "renderer.h"
#include "../../game/sdk.h"
#include <iostream>

namespace renderer {
	namespace scene {
		void start() {
			begin();
			clear();
		}

		void begin() {
			internal::render_target->BeginDraw();
		}
		
		void end() {
			internal::render_target->EndDraw();

			// code below is really just for convience, without the if statement you would have to
			// manually close each window as when clicking onto the game the focus doesnt close the 
			// other window. Comment it out and u will see what I mean. the statement fixes it
			// by brigning overlay to topmost (removes flag imdeallty) then putting game winodw
			// right under it 

			static bool toggle = true;
			if (GetForegroundWindow() == sdk::hwnd) {
				if (toggle) {
					SetWindowPos(hijack::hijacked_hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);
					SetWindowPos(hijack::hijacked_hwnd, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);
					ShowWindow(hijack::hijacked_hwnd, SW_SHOW);
					toggle = false;
				}
			}
			else {
				ShowWindow(hijack::hijacked_hwnd, SW_HIDE);
				toggle = true;
			}

			// sets game window under overlay
			SetWindowPos(sdk::hwnd, hijack::hijacked_hwnd, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
		}

		void clear() {
			internal::render_target->Clear();
		}

		void text(vec2_t pos, const wchar_t* text, ID2D1SolidColorBrush* color, IDWriteTextFormat* font) {
			internal::render_target->DrawTextA( text, lstrlenW( text ), font, pos.rect(), color, D2D1_DRAW_TEXT_OPTIONS_NONE, DWRITE_MEASURING_MODE_NATURAL );
		}

		void box(int x, int y, int width, int height, int thick, ID2D1SolidColorBrush* color) {
			internal::render_target->DrawRectangle(D2D1::RectF(x, y, x + width, y + height), color, thick);
		}

		void shutdown() {
			begin();
			clear();
			end();
		}
	}
}
```

`modern_warfare/core/utils/vectors.cpp`:

```cpp
#include "vectors.h"
#include <cstdint>
#include <algorithm>
#include <iomanip>
#include <random>

float bits_to_float(std::uint32_t i) {
	union convertor_t
	{
		float f;
		unsigned long ul;
	}tmp;

	tmp.ul = i;
	return tmp.f;
}

vec3_t::vec3_t(void) {
	x = y = z = 0.0f;
}

vec3_t::vec3_t(float fx, float fy, float fz) {
	x = fx;
	y = fy;
	z = fz;
}

vec3_t::~vec3_t(void) {
};

void vec3_t::init(float ix, float iy, float iz) {
	x = ix; y = iy; z = iz;
}

vec3_t vec3_t::clamp(void) {
	x = std::clamp(x, -89.0f, 89.0f);
	y = std::clamp(std::remainder(y, 360.0f), -180.0f, 180.0f);
	z = std::clamp(z, -50.0f, 50.0f);
	return vec3_t(x, y, z);
}

vec3_t vec3_t::clamped() {
	vec3_t clamped = *this;
	clamped.clamp();
	return clamped;
}

float vec3_t::normalize_float() {
	vec3_t res = *this;
	float l = res.length();
	if (l != 0.0f) {
		res /= l;
	}
	else {
		res.x = res.y = res.z = 0.0f;
	}
	return l;
}

float vec3_t::distance_to(const vec3_t& other) {
	vec3_t delta;
	delta.x = x - other.x;
	delta.y = y - other.y;
	delta.z = z - other.z;

	return delta.length();
}

void vec3_t::normalize(void) {
	auto vec_normalize = [&](vec3_t& v) {
		auto l = v.length();

		if (l != 0.0f) {
			v.x /= l;
			v.y /= l;
			v.z /= l;
		}
		else {
			v.x = v.y = 0.0f; v.z = 1.0f;
		}

		return l;
	};

	vec_normalize(*this);
}

vec3_t vec3_t::normalized(void) {
	vec3_t vec(*this);
	vec.normalize();

	return vec;
}

float vec3_t::length(void) {
	auto sqr = [](float n) {
		return static_cast<float>(n * n);
	};

	return sqrt(sqr(x) + sqr(y) + sqr(z));
}

float vec3_t::length_2d_sqr(void) const {
	return (x * x + y * y);
}

float vec3_t::dot(const vec3_t other) {
	return (x * other.x + y * other.y + z * other.z);
}

float vec3_t::dot(const float* other) {
	const vec3_t& a = *this;

	return(a.x * other[0] + a.y * other[1] + a.z * other[2]);
}

D2D1_RECT_F vec2_t::rect() {
	return D2D1::RectF(static_cast<FLOAT>(x), static_cast<FLOAT>(y), static_cast<FLOAT>(INT_MAX), static_cast<FLOAT>(INT_MAX));
}

```

`modern_warfare/core/utils/vectors.h`:

```h
#pragma once
#include <limits>
#include <algorithm>
#include <cmath>
#include <d2d1.h>

extern float bits_to_float(std::uint32_t i);
#define M_PI 3.14159265358979323846
#define M_RADPI		57.295779513082f
#define M_PI_F		((float)(M_PI))	// Shouldn't collide with anything.
#define RAD2DEG( x  )  ( (float)(x) * (float)(180.f / M_PI_F) )
#define DEG2RAD( x  )  ( (float)(x) * (float)(M_PI_F / 180.f) )

#define FLOAT32_NAN_BITS     ( std::uint32_t ) 0x7FC00000	// not a number!
#define FLOAT32_NAN          bits_to_float( FLOAT32_NAN_BITS )
#define VEC_T_NAN FLOAT32_NAN

#define ASSERT( _exp ) ( (void ) 0 )

template <typename T>
T clip_number(const T& n, const T& lower, const T& upper) {
	if (n < lower) return lower;
	if (n > upper) return upper;
	return n;
}

class vec3_t {
public:
	vec3_t();
	vec3_t(float, float, float);
	~vec3_t();

	float x, y, z;

	vec3_t& operator+=(const vec3_t& v) {
		x += v.x; y += v.y; z += v.z; return *this;
	}
	vec3_t& operator-=(const vec3_t& v) {
		x -= v.x; y -= v.y; z -= v.z; return *this;
	}
	vec3_t& operator*=(float v) {
		x *= v; y *= v; z *= v; return *this;
	}
	bool operator==(const vec3_t& v) {
		return (x == v.x) && (y == v.y);
	}
	vec3_t operator+(const vec3_t& v) {
		return vec3_t{ x + v.x, y + v.y, z + v.z };
	}
	vec3_t operator-(const vec3_t& v) {
		return vec3_t{ x - v.x, y - v.y, z - v.z };
	}
	vec3_t operator*(float fl) const {
		return vec3_t(x * fl, y * fl, z * fl);
	}
	vec3_t operator*(const vec3_t& v) const {
		return vec3_t(x * v.x, y * v.y, z * v.z);
	}
	vec3_t& operator/=(float fl) {
		x /= fl;
		y /= fl;
		z /= fl;
		return *this;
	}
	auto operator-(const vec3_t& other) const -> vec3_t {
		auto buf = *this;

		buf.x -= other.x;
		buf.y -= other.y;
		buf.z -= other.z;

		return buf;
	}

	auto operator/(float other) const {
		vec3_t vec;
		vec.x = x / other;
		vec.y = y / other;
		vec.z = z / other;
		return vec;
	}

	float& operator[](int i) {
		return ((float*)this)[i];
	}
	float operator[](int i) const {
		return ((float*)this)[i];
	}

	inline float Length2D() const
	{
		return sqrt((x * x) + (y * y));
	}
	void crossproduct(vec3_t v1, vec3_t v2, vec3_t cross_p) const //ijk = xyz
	{
		cross_p.x = (v1.y * v2.z) - (v1.z * v2.y); //i
		cross_p.y = -((v1.x * v2.z) - (v1.z * v2.x)); //j
		cross_p.z = (v1.x * v2.y) - (v1.y * v2.x); //k
	}
	vec3_t Cross(const vec3_t& vOther) const
	{
		vec3_t res;
		crossproduct(*this, vOther, res);
		return res;
	}

	void init(float ix, float iy, float iz);
	vec3_t clamp();
	vec3_t clamped();
	vec3_t normalized();
	float normalize_float();
	float distance_to(const vec3_t& other);
	void normalize();
	float length();
	float length_2d_sqr(void) const;
	float dot(const vec3_t other);
	float dot(const float* other);
};

// has to be hear
inline vec3_t operator*(float lhs, const vec3_t& rhs) {
	return vec3_t(rhs.x * lhs, rhs.x * lhs, rhs.x * lhs);
}

struct matrix_t
{
	matrix_t() { }
	matrix_t(
		float m00, float m01, float m02, float m03,
		float m10, float m11, float m12, float m13,
		float m20, float m21, float m22, float m23)
	{
		mat_val[0][0] = m00;	mat_val[0][1] = m01; mat_val[0][2] = m02; mat_val[0][3] = m03;
		mat_val[1][0] = m10;	mat_val[1][1] = m11; mat_val[1][2] = m12; mat_val[1][3] = m13;
		mat_val[2][0] = m20;	mat_val[2][1] = m21; mat_val[2][2] = m22; mat_val[2][3] = m23;
	}

	//-----------------------------------------------------------------------------
	// Creates a matrix where the X axis = forward
	// the Y axis = left, and the Z axis = up
	//-----------------------------------------------------------------------------
	void init(const vec3_t& xAxis, const vec3_t& yAxis, const vec3_t& zAxis, const vec3_t& vecOrigin)
	{
		mat_val[0][0] = xAxis.x; mat_val[0][1] = yAxis.x; mat_val[0][2] = zAxis.x; mat_val[0][3] = vecOrigin.x;
		mat_val[1][0] = xAxis.y; mat_val[1][1] = yAxis.y; mat_val[1][2] = zAxis.y; mat_val[1][3] = vecOrigin.y;
		mat_val[2][0] = xAxis.z; mat_val[2][1] = yAxis.z; mat_val[2][2] = zAxis.z; mat_val[2][3] = vecOrigin.z;
	}

	//-----------------------------------------------------------------------------
	// Creates a matrix where the X axis = forward
	// the Y axis = left, and the Z axis = up
	//-----------------------------------------------------------------------------
	matrix_t(const vec3_t& xAxis, const vec3_t& yAxis, const vec3_t& zAxis, const vec3_t& vecOrigin)
	{
		init(xAxis, yAxis, zAxis, vecOrigin);
	}

	inline void set_origin(vec3_t const& p)
	{
		mat_val[0][3] = p.x;
		mat_val[1][3] = p.y;
		mat_val[2][3] = p.z;
	}

	inline void invalidate(void)
	{
		for (int i = 0; i < 3; i++)
		{
			for (int j = 0; j < 4; j++)
			{
				mat_val[i][j] = VEC_T_NAN;
			}
		}
	}

	float* operator[](int i) { ASSERT((i >= 0) && (i < 3)); return mat_val[i]; }
	const float* operator[](int i) const { ASSERT((i >= 0) && (i < 3)); return mat_val[i]; }
	float* base() { return &mat_val[0][0]; }
	const float* base() const { return &mat_val[0][0]; }

	float mat_val[3][4];
};

class vec2_t {
public:
	float x, y;

	vec2_t() {
		x = 0; y = 0;
	};
	vec2_t(float X, float Y) {
		x = X; y = Y;
	};
	vec2_t(vec3_t vec) {
		x = vec.x; y = vec.y;
	}

	inline vec2_t operator*(const float n) const {
		return vec2_t(x * n, y * n);
	}
	inline vec2_t operator+(const vec2_t& v) const {
		return vec2_t(x + v.x, y + v.y);
	}
	inline vec2_t operator-(const vec2_t& v) const {
		return vec2_t(x - v.x, y - v.y);
	}
	inline void operator+=(const vec2_t& v) {
		x += v.x;
		y += v.y;
	}
	inline void operator-=(const vec2_t& v) {
		x -= v.x;
		y -= v.y;
	}

	bool operator==(const vec2_t& v) const {
		return (v.x == x && v.y == y);
	}
	bool operator!=(const vec2_t& v) const {
		return (v.x != x || v.y != y);
	}

	inline float length() {
		return sqrt((x * x) + (y * y));
	}

	D2D1_RECT_F rect();
};

```

`modern_warfare/core/utils/xor.h`:

```h
#pragma once
/*
 * Copyright 2017 - 2018 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#define JM_XORSTR_DISABLE_AVX_INTRINSICS 1

#ifndef JM_XORSTR_HPP
#define JM_XORSTR_HPP

#include <immintrin.h>
#include <cstdint>
#include <cstddef>
#include <utility>

#define xorstr(str)                                              \
    ::jm::make_xorstr(                                           \
        []() { return str; },                                    \
        std::make_index_sequence<sizeof(str) / sizeof(*str)>{},  \
        std::make_index_sequence<::jm::detail::_buffer_size<sizeof(str)>()>{})
#define xorstr_(str) xorstr(str).crypt_get()

#ifdef _MSC_VER
#define XORSTR_FORCEINLINE __forceinline
#else
#define XORSTR_FORCEINLINE __attribute__((always_inline))
#endif

 // you can define this macro to get possibly faster code on gcc/clang
 // at the expense of constants being put into data section.
#if !defined(XORSTR_ALLOW_DATA)
// MSVC - no volatile
// GCC and clang - volatile everywhere
#if defined(__clang__) || defined(__GNUC__)
#define XORSTR_VOLATILE volatile
#endif

#endif
#ifndef XORSTR_VOLATILE
#define XORSTR_VOLATILE
#endif

namespace jm {

	namespace detail {

		template<std::size_t S>
		struct unsigned_;

		template<>
		struct unsigned_<1> {
			using type = std::uint8_t;
		};
		template<>
		struct unsigned_<2> {
			using type = std::uint16_t;
		};
		template<>
		struct unsigned_<4> {
			using type = std::uint32_t;
		};

		template<auto C, auto...>
		struct pack_value_type {
			using type = decltype(C);
		};

		template<std::size_t Size>
		constexpr std::size_t _buffer_size()
		{
			return ((Size / 16) + (Size % 16 != 0)) * 2;
		}

		template<auto... Cs>
		struct tstring_ {
			using value_type                  = typename pack_value_type<Cs...>::type;
			constexpr static std::size_t size = sizeof...(Cs);
			constexpr static value_type  str[size] = { Cs... };

			constexpr static std::size_t buffer_size = _buffer_size<sizeof(str)>();
			constexpr static std::size_t buffer_align =
#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
			((sizeof(str) > 16) ? 32 : 16);
#else
				16;
#endif
		};

		template<std::size_t I, std::uint64_t K>
		struct _ki {
			constexpr static std::size_t   idx = I;
			constexpr static std::uint64_t key = K;
		};

		template<std::uint32_t Seed>
		constexpr std::uint32_t key4() noexcept
		{
			std::uint32_t value = Seed;
			for (char c : __TIME__)
				value = static_cast<std::uint32_t>((value ^ c) * 16777619ull);
			return value;
		}

		template<std::size_t S>
		constexpr std::uint64_t key8()
		{
			constexpr auto first_part = key4<2166136261 + S>();
			constexpr auto second_part = key4<first_part>();
			return (static_cast<std::uint64_t>(first_part) << 32) | second_part;
		}

		// clang and gcc try really hard to place the constants in data
		// sections. to counter that there was a need to create an intermediate
		// constexpr string and then copy it into a non constexpr container with
		// volatile storage so that the constants would be placed directly into
		// code.
		template<class T, std::uint64_t... Keys>
		struct string_storage {
			std::uint64_t storage[T::buffer_size];

			XORSTR_FORCEINLINE constexpr string_storage() noexcept : storage{ Keys... }
			{
				using cast_type =
					typename unsigned_<sizeof(typename T::value_type)>::type;
				constexpr auto value_size = sizeof(typename T::value_type);
				// puts the string into 64 bit integer blocks in a constexpr
				// fashion
				for (std::size_t i = 0; i < T::size; ++i)
					storage[i / (8 / value_size)] ^=
					(std::uint64_t{ static_cast<cast_type>(T::str[i]) }
				<< ((i % (8 / value_size)) * 8 * value_size));
			}
		};

	} // namespace detail

	template<class T, class... Keys>
	class xor_string {
		alignas(T::buffer_align) std::uint64_t _storage[T::buffer_size];

		// _single functions needed because MSVC crashes without them
		XORSTR_FORCEINLINE void _crypt_256_single(const std::uint64_t* keys,
			std::uint64_t* storage) noexcept

		{
			_mm256_store_si256(
				reinterpret_cast<__m256i*>(storage),
				_mm256_xor_si256(
					_mm256_load_si256(reinterpret_cast<const __m256i*>(storage)),
					_mm256_load_si256(reinterpret_cast<const __m256i*>(keys))));
		}

		template<std::size_t... Idxs>
		XORSTR_FORCEINLINE void _crypt_256(const std::uint64_t* keys,
			std::index_sequence<Idxs...>) noexcept
		{
			(_crypt_256_single(keys + Idxs * 4, _storage + Idxs * 4), ...);
		}

		XORSTR_FORCEINLINE void _crypt_128_single(const std::uint64_t* keys,
			std::uint64_t* storage) noexcept
		{
			_mm_store_si128(
				reinterpret_cast<__m128i*>(storage),
				_mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(storage)),
					_mm_load_si128(reinterpret_cast<const __m128i*>(keys))));
		}

		template<std::size_t... Idxs>
		XORSTR_FORCEINLINE void _crypt_128(const std::uint64_t* keys,
			std::index_sequence<Idxs...>) noexcept
		{
			(_crypt_128_single(keys + Idxs * 2, _storage + Idxs * 2), ...);
		}

		// loop generates vectorized code which places constants in data dir
		XORSTR_FORCEINLINE constexpr void _copy() noexcept
		{
			constexpr detail::string_storage<T, Keys::key...> storage;
			static_cast<void>(std::initializer_list<std::uint64_t>{
				(const_cast<XORSTR_VOLATILE std::uint64_t*>(_storage))[Keys::idx] =
					storage.storage[Keys::idx]... });
		}

	public:
		using value_type    = typename T::value_type;
		using size_type     = std::size_t;
		using pointer       = value_type *;
		using const_pointer = const pointer;

		XORSTR_FORCEINLINE xor_string() noexcept { _copy(); }

		XORSTR_FORCEINLINE constexpr size_type size() const noexcept
		{
			return T::size - 1;
		}

		XORSTR_FORCEINLINE void crypt() noexcept
		{
			alignas(T::buffer_align) std::uint64_t keys[T::buffer_size];
			static_cast<void>(std::initializer_list<std::uint64_t>{
				(const_cast<XORSTR_VOLATILE std::uint64_t*>(keys))[Keys::idx] =
					Keys::key... });

			_copy();

#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
			_crypt_256(keys, std::make_index_sequence<T::buffer_size / 4>{});
			if constexpr (T::buffer_size % 4 != 0)
				_crypt_128(keys, std::index_sequence<T::buffer_size / 2 - 1>{});
#else
			_crypt_128(keys, std::make_index_sequence<T::buffer_size / 2>{});
#endif
		}

		XORSTR_FORCEINLINE const_pointer get() const noexcept
		{
			return reinterpret_cast<const_pointer>(_storage);
		}

		XORSTR_FORCEINLINE const_pointer crypt_get() noexcept
		{
			crypt();
			return reinterpret_cast<const_pointer>(_storage);
		}
	};

	template<class Tstr, std::size_t... StringIndices, std::size_t... KeyIndices>
	XORSTR_FORCEINLINE constexpr auto
		make_xorstr(Tstr str_lambda,
			std::index_sequence<StringIndices...>,
			std::index_sequence<KeyIndices...>) noexcept
	{
		return xor_string<detail::tstring_<str_lambda()[StringIndices]...>,
			detail::_ki<KeyIndices, detail::key8<KeyIndices>()>...>{};
	}

} // namespace jm

#endif // include guard
```

`modern_warfare/modern_warfare.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{4a69fc80-8531-4350-b836-a1076d2fd136}</ProjectGuid>
    <RootNamespace>modernwarfare</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>modern_warfare_client</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <AdditionalIncludeDirectories>"SDK Path\Include"</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>"SDK Path\Lib"</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <AdditionalIncludeDirectories>"SDK Path\Include"</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>"SDK Path\Lib"</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="core\driver\driver.h" />
    <ClInclude Include="core\game\offsets.h" />
    <ClInclude Include="core\game\sdk.h" />
    <ClInclude Include="core\overlay\hijack\hijack.h" />
    <ClInclude Include="core\overlay\renderer\internal.h" />
    <ClInclude Include="core\overlay\renderer\renderer.h" />
    <ClInclude Include="core\utils\vectors.h" />
    <ClInclude Include="core\utils\xor.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="core\game\sdk.cpp" />
    <ClCompile Include="core\main.cpp" />
    <ClCompile Include="core\overlay\hijack\hijack.cpp" />
    <ClCompile Include="core\overlay\renderer\colors.cpp" />
    <ClCompile Include="core\overlay\renderer\fonts.cpp" />
    <ClCompile Include="core\overlay\renderer\internal.cpp" />
    <ClCompile Include="core\overlay\renderer\renderer.cpp" />
    <ClCompile Include="core\overlay\renderer\scene.cpp" />
    <ClCompile Include="core\utils\vectors.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`modern_warfare/modern_warfare.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="core\driver\driver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="core\game\offsets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="core\game\sdk.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="core\utils\vectors.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="core\utils\xor.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="core\overlay\hijack\hijack.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="core\overlay\renderer\internal.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="core\overlay\renderer\renderer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="core\main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="core\game\sdk.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="core\overlay\hijack\hijack.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="core\overlay\renderer\colors.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="core\overlay\renderer\fonts.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="core\overlay\renderer\internal.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="core\overlay\renderer\renderer.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="core\overlay\renderer\scene.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="core\utils\vectors.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`modern_warfare_driver/core/main.cpp`:

```cpp
#include "utils\memory.h"
#include "utils\imports.h"

NTSTATUS hook_handler(PVOID called_param)
{
	COPY_MEMORY* m = (COPY_MEMORY*)called_param;

	if (m->get_pid) {
		m->pid = memory::get_process_id(m->process_name);
	}
	else if (m->base) {
		PEPROCESS process;
		if (NT_SUCCESS(PsLookupProcessByProcessId(m->pid, &process))) {
			m->buffer = (void*)memory::get_module_base_x64(process);
		}
	}
	else if (m->peb) {
		PEPROCESS process;
		if (NT_SUCCESS(PsLookupProcessByProcessId(m->pid, &process))) {
			m->buffer = (void*)PsGetProcessPeb(process);
		}
	}
	else if (m->read) {
		memory::read_kernel_memory(m->pid, (PVOID)m->address, m->buffer, m->size);
	}
	else if (m->write) {
		memory::write_kernel_memory(m->pid, m->buffer, (PVOID)m->address, m->size);
	}
	
	return STATUS_SUCCESS;
}

void real_entry() {
	DbgPrintEx(0, 0, "real entry called.\n");

	if (memory::call_kernel_function(&hook_handler)) {
		DbgPrintEx(0, 0, "function hooked.\n");
	} 
	else {
		DbgPrintEx(0, 0, "failed to hook function.\n");
	}
}

extern "C" NTSTATUS DriverEntry(PDRIVER_OBJECT  driver_object, PUNICODE_STRING registry_path)
{
	UNREFERENCED_PARAMETER(driver_object);
	UNREFERENCED_PARAMETER(registry_path);
	return STATUS_SUCCESS;
}
```

`modern_warfare_driver/core/utils/imports.h`:

```h
#pragma once
#include <ntdef.h>
#include <ntifs.h>
#include <ntddk.h>
#include <windef.h>
#include <ntstrsafe.h>

typedef struct PiDDBCacheEntry
{
	LIST_ENTRY		List;
	UNICODE_STRING	DriverName;
	ULONG			TimeDateStamp;
	NTSTATUS		LoadStatus;
	char			_0x0028[16];
}PIDCacheobj;

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES        16

typedef struct _IMAGE_DATA_DIRECTORY
{
	ULONG VirtualAddress;
	ULONG Size;
} IMAGE_DATA_DIRECTORY, * PIMAGE_DATA_DIRECTORY;

typedef struct _IMAGE_OPTIONAL_HEADER64
{
	USHORT Magic;
	UCHAR MajorLinkerVersion;
	UCHAR MinorLinkerVersion;
	ULONG SizeOfCode;
	ULONG SizeOfInitializedData;
	ULONG SizeOfUninitializedData;
	ULONG AddressOfEntryPoint;
	ULONG BaseOfCode;
	ULONGLONG ImageBase;
	ULONG SectionAlignment;
	ULONG FileAlignment;
	USHORT MajorOperatingSystemVersion;
	USHORT MinorOperatingSystemVersion;
	USHORT MajorImageVersion;
	USHORT MinorImageVersion;
	USHORT MajorSubsystemVersion;
	USHORT MinorSubsystemVersion;
	ULONG Win32VersionValue;
	ULONG SizeOfImage;
	ULONG SizeOfHeaders;
	ULONG CheckSum;
	USHORT Subsystem;
	USHORT DllCharacteristics;
	ULONGLONG SizeOfStackReserve;
	ULONGLONG SizeOfStackCommit;
	ULONGLONG SizeOfHeapReserve;
	ULONGLONG SizeOfHeapCommit;
	ULONG LoaderFlags;
	ULONG NumberOfRvaAndSizes;
	struct _IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER64, * PIMAGE_OPTIONAL_HEADER64;

typedef struct _IMAGE_FILE_HEADER
{
	USHORT Machine;
	USHORT NumberOfSections;
	ULONG TimeDateStamp;
	ULONG PointerToSymbolTable;
	ULONG NumberOfSymbols;
	USHORT SizeOfOptionalHeader;
	USHORT Characteristics;
} IMAGE_FILE_HEADER, * PIMAGE_FILE_HEADER;

typedef struct _IMAGE_NT_HEADERS64
{
	ULONG Signature;
	struct _IMAGE_FILE_HEADER FileHeader;
	struct _IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, * PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_SECTION_HEADER
{
	UCHAR  Name[8];
	union
	{
		ULONG PhysicalAddress;
		ULONG VirtualSize;
	} Misc;
	ULONG VirtualAddress;
	ULONG SizeOfRawData;
	ULONG PointerToRawData;
	ULONG PointerToRelocations;
	ULONG PointerToLinenumbers;
	USHORT  NumberOfRelocations;
	USHORT  NumberOfLinenumbers;
	ULONG Characteristics;
} IMAGE_SECTION_HEADER, * PIMAGE_SECTION_HEADER;

extern "C" NTSYSAPI
PIMAGE_NT_HEADERS
NTAPI
RtlImageNtHeader(PVOID Base);


typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation,
	SystemProcessorInformation,
	SystemPerformanceInformation,
	SystemTimeOfDayInformation,
	SystemPathInformation,
	SystemProcessInformation,
	SystemCallCountInformation,
	SystemDeviceInformation,
	SystemProcessorPerformanceInformation,
	SystemFlagsInformation,
	SystemCallTimeInformation,
	SystemModuleInformation = 0x0B
} SYSTEM_INFORMATION_CLASS,
* PSYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_PROCESS_INFO
{
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	LARGE_INTEGER WorkingSetPrivateSize;
	ULONG HardFaultCount;
	ULONG NumberOfThreadsHighWatermark;
	ULONGLONG CycleTime;
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	UNICODE_STRING ImageName;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	HANDLE InheritedFromUniqueProcessId;
	ULONG HandleCount;
	ULONG SessionId;
	ULONG_PTR UniqueProcessKey;
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG PageFaultCount;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	SIZE_T QuotaPeakPagedPoolUsage;
	SIZE_T QuotaPagedPoolUsage;
	SIZE_T QuotaPeakNonPagedPoolUsage;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
	LARGE_INTEGER ReadOperationCount;
	LARGE_INTEGER WriteOperationCount;
	LARGE_INTEGER OtherOperationCount;
	LARGE_INTEGER ReadTransferCount;
	LARGE_INTEGER WriteTransferCount;
	LARGE_INTEGER OtherTransferCount;
}SYSTEM_PROCESS_INFO, * PSYSTEM_PROCESS_INFO;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

typedef struct _PEB_LDR_DATA {
	ULONG Length;
	BOOLEAN Initialized;
	PVOID SsHandle;
	LIST_ENTRY ModuleListLoadOrder;
	LIST_ENTRY ModuleListMemoryOrder;
	LIST_ENTRY ModuleListInitOrder;
} PEB_LDR_DATA, * PPEB_LDR_DATA;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
	BYTE Reserved1[16];
	PVOID Reserved2[10];
	UNICODE_STRING ImagePathName;
	UNICODE_STRING CommandLine;
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

typedef void(__stdcall* PPS_POST_PROCESS_INIT_ROUTINE)(void); // not exported

typedef struct _PEB {
	BYTE Reserved1[2];
	BYTE BeingDebugged;
	BYTE Reserved2[1];
	PVOID Reserved3[2];
	PPEB_LDR_DATA Ldr;
	PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
	PVOID Reserved4[3];
	PVOID AtlThunkSListPtr;
	PVOID Reserved5;
	ULONG Reserved6;
	PVOID Reserved7;
	ULONG Reserved8;
	ULONG AtlThunkSListPtr32;
	PVOID Reserved9[45];
	BYTE Reserved10[96];
	PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
	BYTE Reserved11[128];
	PVOID Reserved12[1];
	ULONG SessionId;
} PEB, * PPEB;

typedef struct _LDR_DATA_TABLE_ENTRY {
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;  // in bytes
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;  // LDR_*
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY HashLinks;
	PVOID SectionPointer;
	ULONG CheckSum;
	ULONG TimeDateStamp;
	//    PVOID			LoadedImports;
	//    // seems they are exist only on XP !!! PVOID
	//    EntryPointActivationContext;	// -same-
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

extern "C" __declspec(dllimport) NTSTATUS NTAPI ZwProtectVirtualMemory
(
	HANDLE ProcessHandle,
	PVOID* BaseAddress,
	PULONG ProtectSize,
	ULONG NewProtect,
	PULONG OldProtect
);

extern "C" NTKERNELAPI PVOID NTAPI RtlFindExportedRoutineByName(_In_ PVOID ImageBase, _In_ PCCH RoutineName);

extern "C" NTSTATUS ZwQuerySystemInformation(ULONG InfoClass, PVOID Buffer, ULONG Length, PULONG ReturnLength);

extern "C" NTKERNELAPI PPEB PsGetProcessPeb(IN PEPROCESS Process);

extern "C" NTSYSAPI PIMAGE_NT_HEADERS NTAPI RtlImageNtHeader(PVOID Base);

extern "C" NTKERNELAPI PVOID PsGetProcessSectionBaseAddress(__in PEPROCESS Process);

extern "C" NTSTATUS NTAPI MmCopyVirtualMemory
(
	PEPROCESS SourceProcess,
	PVOID SourceAddress,
	PEPROCESS TargetProcess,
	PVOID TargetAddress,
	SIZE_T BufferSize,
	KPROCESSOR_MODE PreviousMode,
	PSIZE_T ReturnSize
);

typedef struct _COPY_MEMORY {
	void* buffer;
	ULONG64		address;
	ULONG		size;
	HANDLE		pid;
	bool		get_pid;
	bool		base;
	bool		peb;
	bool		read;
	bool		write;
	const char* module_name;
	const char* process_name;
}COPY_MEMORY;
```

`modern_warfare_driver/core/utils/memory.h`:

```h
#pragma once
#include "imports.h"

namespace memory {
	PVOID get_system_module_base(const char* module_name) {
		ULONG bytes = 0;
		NTSTATUS status = ZwQuerySystemInformation(SystemModuleInformation, 0, bytes, &bytes);

		if (!bytes)
			return 0;

		PRTL_PROCESS_MODULES modules = (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag(NonPagedPool, bytes, 0x454E4F45); // 'ENON'

		status = ZwQuerySystemInformation(SystemModuleInformation, modules, bytes, &bytes);

		if (!NT_SUCCESS(status))
			return 0;

		PRTL_PROCESS_MODULE_INFORMATION module = modules->Modules;
		PVOID module_base = 0, module_size = 0;

		for (ULONG i = 0; i < modules->NumberOfModules; i++)
		{
			if (strcmp((char*)module[i].FullPathName, module_name) == 0)
			{
				module_base = module[i].ImageBase;
				module_size = (PVOID)module[i].ImageSize;
				break;
			}
		}

		if (modules)
			ExFreePoolWithTag(modules, 0);

		if (module_base <= 0)
			return 0;

		return module_base;
	}

	ULONG64 get_module_base_x64(PEPROCESS proc) {
		return (ULONG64)PsGetProcessSectionBaseAddress(proc);
	}

	HANDLE get_process_id(const char* process_name) {
		ULONG buffer_size = 0;
		ZwQuerySystemInformation(SystemProcessInformation, NULL, NULL, &buffer_size);

		auto buffer = ExAllocatePoolWithTag(NonPagedPool, buffer_size, 'mder');
		if (!buffer) {
			DbgPrintEx(0, 0, "failed to allocate pool (get_process_id)");
			return 0;
		}
		
		ANSI_STRING process_name_ansi = {};
		UNICODE_STRING process_name_unicode = {};
		RtlInitAnsiString(&process_name_ansi, process_name);
		if (!NT_SUCCESS(RtlAnsiStringToUnicodeString(&process_name_unicode, &process_name_ansi, TRUE))) {
			DbgPrintEx(0, 0, "failed to convert string (get_process_id)");
			RtlFreeUnicodeString(&process_name_unicode);
			return 0;
		}

		auto process_info = (PSYSTEM_PROCESS_INFO)buffer;
		if (NT_SUCCESS(ZwQuerySystemInformation(SystemProcessInformation, process_info, buffer_size, NULL))) {
			while (process_info->NextEntryOffset) {
				if (!RtlCompareUnicodeString(&process_name_unicode, &process_info->ImageName, true)) {
					DbgPrintEx(0, 0, "process name: %wZ | process ID: %d\n", process_info->ImageName, process_info->UniqueProcessId);
					RtlFreeUnicodeString(&process_name_unicode);
					return process_info->UniqueProcessId;
				}
				process_info = (PSYSTEM_PROCESS_INFO)((BYTE*)process_info + process_info->NextEntryOffset);
			}
		}
		else {
			ExFreePoolWithTag(buffer, 'mder');
			return 0;
		}
	}

	PVOID get_system_module_export(const char* module_name, LPCSTR routine_name)
	{
		PVOID lpModule = memory::get_system_module_base(module_name);

		if (!lpModule)
			return NULL;

		return RtlFindExportedRoutineByName(lpModule, routine_name);
	}

	bool write_to_read_only_memory(void* address, void* buffer, size_t size) {

		PMDL Mdl = IoAllocateMdl(address, size, FALSE, FALSE, NULL);

		if (!Mdl)
			return false;

		// Locking and mapping memory with RW-rights:
		MmProbeAndLockPages(Mdl, KernelMode, IoReadAccess);
		PVOID Mapping = MmMapLockedPagesSpecifyCache(Mdl, KernelMode, MmNonCached, NULL, FALSE, NormalPagePriority);
		MmProtectMdlSystemAddress(Mdl, PAGE_READWRITE);

		// Write your buffer to mapping:
		RtlCopyMemory(Mapping, buffer, size);

		// Resources freeing:
		MmUnmapLockedPages(Mapping, Mdl);
		MmUnlockPages(Mdl);
		IoFreeMdl(Mdl);

		return true;
	}

	bool call_kernel_function(void* kernel_function_address) {
		if (!kernel_function_address)
			return false;

		PVOID* dxgk_routine
			= reinterpret_cast<PVOID*>(memory::get_system_module_export("\\SystemRoot\\System32\\drivers\\dxgkrnl.sys", "NtOpenCompositionSurfaceSectionInfo"));

		if (!dxgk_routine) {
			return false;
		}

		BYTE dxgk_original[] = { 0x4C, 0x8B, 0xDC, 0x49, 0x89, 0x5B, 0x18, 0x4D, 0x89, 0x4B, 0x20, 0x49, 0x89, 0x4B, 0x08 };

		BYTE shell_code_start[]
		{
			0x48, 0xB8 // mov rax, [xxx]
		};

		BYTE shell_code_end[]
		{
			0xFF, 0xE0, // jmp rax
			0xCC //
		};

		RtlSecureZeroMemory(&dxgk_original, sizeof(dxgk_original));
		memcpy((PVOID)((ULONG_PTR)dxgk_original), &shell_code_start, sizeof(shell_code_start));
		uintptr_t test_address = reinterpret_cast<uintptr_t>(kernel_function_address);
		memcpy((PVOID)((ULONG_PTR)dxgk_original + sizeof(shell_code_start)), &test_address, sizeof(void*));
		memcpy((PVOID)((ULONG_PTR)dxgk_original + sizeof(shell_code_start) + sizeof(void*)), &shell_code_end, sizeof(shell_code_end));
		write_to_read_only_memory(dxgk_routine, &dxgk_original, sizeof(dxgk_original));

		return true;
	}

	bool read_kernel_memory(HANDLE pid, PVOID address, PVOID buffer, SIZE_T size) {
		if (!address || !buffer || !size)
			return false;
		
		SIZE_T bytes = 0;
		PEPROCESS process;
		if (!NT_SUCCESS(PsLookupProcessByProcessId(pid, &process))) {
			DbgPrintEx(0, 0, "process lookup failed (read)");
			return false;
		}

		return MmCopyVirtualMemory(process, address, PsGetCurrentProcess(), buffer, size, KernelMode, &bytes) == STATUS_SUCCESS;
	}

	bool write_kernel_memory(HANDLE pid, PVOID address, PVOID buffer, SIZE_T size) {
		if (!address || !buffer || !size)
			return false;

		SIZE_T bytes = 0;
		PEPROCESS process;
		if (!NT_SUCCESS(PsLookupProcessByProcessId(pid, &process))) {
			DbgPrintEx(0, 0, "process lookup failed (write)");
			return false;
		}

		return MmCopyVirtualMemory(PsGetCurrentProcess(), address, process, buffer, size, KernelMode, &bytes) == STATUS_SUCCESS;
	}

	NTSTATUS protect_virtual_memory(HANDLE pid, PVOID address, ULONG size, ULONG protection, ULONG& protection_out)
	{
		if (!pid || !address || !size || !protection)
			return STATUS_INVALID_PARAMETER;

		NTSTATUS status = STATUS_SUCCESS;
		PEPROCESS target_process = nullptr;

		if (!NT_SUCCESS(PsLookupProcessByProcessId(reinterpret_cast<HANDLE>(pid), &target_process)))
		{
			return STATUS_NOT_FOUND;
		}

		//PVOID address = reinterpret_cast<PVOID>( memory_struct->address );
		//ULONG size = (ULONG)( memory_struct->size );
		//ULONG protection = memory_struct->protection;
		ULONG protection_old = 0;

		KAPC_STATE state;
		KeStackAttachProcess(target_process, &state);

		status = ZwProtectVirtualMemory(NtCurrentProcess(), &address, &size, protection, &protection_old);

		KeUnstackDetachProcess(&state);

		if (NT_SUCCESS(status))
			protection_out = protection_old;

		ObDereferenceObject(target_process);
		return status;
	}
}
```

`modern_warfare_driver/modern_warfare_driver.inf`:

```inf
;
; modern_warfare_driver.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=modern_warfare_driver.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockDown=1

[DestinationDirs]
DefaultDestDir = 12
modern_warfare_driver_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
modern_warfare_driver.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%modern_warfare_driver.DeviceDesc%=modern_warfare_driver_Device, Root\modern_warfare_driver ; TODO: edit hw-id

[modern_warfare_driver_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
modern_warfare_driver.sys

;-------------- Service installation
[modern_warfare_driver_Device.NT.Services]
AddService = modern_warfare_driver,%SPSVCINST_ASSOCSERVICE%, modern_warfare_driver_Service_Inst

; -------------- modern_warfare_driver driver install sections
[modern_warfare_driver_Service_Inst]
DisplayName    = %modern_warfare_driver.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\modern_warfare_driver.sys

;
;--- modern_warfare_driver_Device Coinstaller installation ------
;

[modern_warfare_driver_Device.NT.CoInstallers]
AddReg=modern_warfare_driver_Device_CoInstaller_AddReg
CopyFiles=modern_warfare_driver_Device_CoInstaller_CopyFiles

[modern_warfare_driver_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[modern_warfare_driver_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[modern_warfare_driver_Device.NT.Wdf]
KmdfService =  modern_warfare_driver, modern_warfare_driver_wdfsect
[modern_warfare_driver_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "modern_warfare_driver Installation Disk"
modern_warfare_driver.DeviceDesc = "modern_warfare_driver Device"
modern_warfare_driver.SVCDESC = "modern_warfare_driver Service"

```

`modern_warfare_driver/modern_warfare_driver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{30EAC4AD-21EC-4982-B136-2BB9C1361551}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>modern_warfare_driver</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.20348.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <AdditionalIncludeDirectories>C:\Program Files (x86)\Windows Kits\10\Include\10.0.20348.0\km;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <TreatWarningAsError>false</TreatWarningAsError>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <AdditionalOptions>/INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <EntryPointSymbol>real_entry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <AdditionalIncludeDirectories>C:\Program Files (x86)\Windows Kits\10\Include\10.0.20348.0\km;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <TreatWarningAsError>false</TreatWarningAsError>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <AdditionalOptions>/INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <EntryPointSymbol>real_entry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="modern_warfare_driver.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="core\main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="core\utils\imports.h" />
    <ClInclude Include="core\utils\memory.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`modern_warfare_driver/modern_warfare_driver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="modern_warfare_driver.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="core\main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="core\utils\imports.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="core\utils\memory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```