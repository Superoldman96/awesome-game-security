Project Path: arc_gmh5225_CE-lua-extensions_l_p05eav

Source Tree:

```txt
arc_gmh5225_CE-lua-extensions_l_p05eav
├── ExtensionsLoader.lua
├── README.md
├── extensions
│   ├── AA_macros.lua
│   ├── BetterCommentEdit.lua
│   ├── DeleteAllBreakpoints.lua
│   ├── EXPERIMENTALnew-addresslist-temp-helper.lua
│   ├── GetFunctionCallers.lua
│   ├── INCOMPLETE_CommentsList.lua
│   ├── LuaEngineInsertTemplate.lua
│   ├── SelectCurrentFunctionExpand.lua
│   ├── customTimer.lua
│   ├── lua51stackviewer32bit.lua
│   └── lua53stackviewer64bit.lua
└── photo-examples
    ├── delallbp.png
    ├── expandscf.png
    └── fastfilter_example.png

```

`ExtensionsLoader.lua`:

```lua
--[[
Author: Skyrimfus
Discord ID: 244490308782391316
Name: Extensions Loader
Version: Public version 1.0

Written for CE 7.4


Description: 
	This extension checks for a folder called 'Extensions' located inside CE autorun folder.
	If it finds it, it scans that whole folder(and all sub-folders) and runs every .lua file

--]]
require('lfs')

local fExt = getAutorunPath().."\\Extensions\\"
local Folders = {fExt}
local Files = {}

local function fld(fExt)
	for folder in lfs.dir(fExt) do
		if not string.match(folder,"%.") then
			Folders[#Folders+1] = fExt..folder.."\\"
			fld(Folders[#Folders])
		end
	end
end



fld(fExt)

for i=1, #Folders do
 for file in lfs.dir(Folders[i]) do
  if file ~= "." and file ~= ".." and string.match(file,'^[^!]+.%.lua') then
    Files[#Files+1] = Folders[i].."\\"..file
  end
 end
end


for i=1, #Files do
	local opf = io.open(Files[i],"r")
	local rf = opf.read(opf,"*a")
	local fu = loadstring(rf)
	io.close(opf)
	fu()
end
```

`README.md`:

```md
# CE-lua-extensions
Various LUA extensions for Cheat Engine

Instructions:

Place in your Cheat Engine's autorun folder

```

`extensions/AA_macros.lua`:

```lua
--Place in autorun folder
--In auto assembler you can use definemacro(name,line1;line2)
--This will only register the macro, to use it in a script use:
--macro(name)
--this will produce the following assembly at the line(s) of the macro():
--line1
--line2
--Macros are global(you can use macros from outside the defining script)
(function()
local defined_macros = {}
registerAutoAssemblerCommand("definemacro", function(p, s)
local name = p:split(",")
local macro = table.concat({p:split(",")},",",2)
macro = macro:gsub(";","\n")
defined_macros[name] = macro
end)
registerAutoAssemblerCommand("macro", function(name, s)
if defined_macros[name] == nil then return nil, "Macro: '"..name.."' does not exist!" end
return defined_macros[name]
end)
end)()

```

`extensions/BetterCommentEdit.lua`:

```lua
--[[
Author: Skyrimfus
Discord ID: 244490308782391316
Name: Better Comments
Version: Public version 2.0

Written for CE 7.4


Description: 
	This extension replaces "Set/Change comment" in CE's Memory Viewer with a custom one.
	Pressing enter or clicking on the "OK" button will write your input as a comment and close the window.
	Pressing esc or clicking on the "Cancel" button will cancel any changes and close the window.
	
	Pressing shift and enter will write a new-line.


--]]

local fm,memo,pnl,bOk,bCancel,selAddress
local mvf = getMemoryViewForm()

fm = createForm(false)
fm.Caption = "Comment for:"
fm.OnClose = nil
fm.BorderStyle = bsSizeable

memo = createMemo(fm)
memo.Lines.Text = "Generating..."
memo.Anchors = "[akTop,akLeft,akRight,akBottom]"
memo.AnchorSideRight.Side = asrRight
memo.AnchorSideRight.Control = fm
memo.Scrollbars = ssVertical


pnl = createPanel(fm)
pnl.BevelOuter = 0
pnl.Anchors = "[akBottom,akLeft]"
pnl.AnchorSideLeft.Control = fm
pnl.AnchorSideLeft.Side = asrCenter
pnl.AnchorSideBottom.Control = fm
pnl.AnchorSideBottom.Side = asrBottom
pnl.Width = 150
pnl.Height  = 40


memo.AnchorSideBottom.Side = asrTop
memo.AnchorSideBottom.Control = pnl


bOk = createButton(fm)
bOk.Caption = "OK"
bOk.Anchors = "[akTop,akLeft]"
bOk.AnchorSideTop.Control = pnl
bOk.AnchorSideTop.Side = asrCenter
bOk.AnchorSideLeft.Control = pnl
bOk.AnchorSideLeft.Side = asrLeft
bOk.setSize(70,22)


bCancel = createButton(fm)
bCancel.Caption = "Cancel"
bCancel.Anchors = "[akRight,akTop]"
bCancel.AnchorSideTop.Control = pnl
bCancel.AnchorSideTop.Side = asrCenter
bCancel.AnchorSideRight.Control = pnl
bCancel.AnchorSideRight.Side = asrRight
bCancel.setSize(70,22)


local function ok()
	setComment(selAddress,memo.Lines.Text)
	fm.hide()
end

local function cancel()
	fm.hide()
end

memo.OnKeyDown= function(key)
 if isKeyPressed(VK_RETURN) and not isKeyPressed(VK_LSHIFT) then
  ok()
 end
 if isKeyPressed(VK_ESCAPE) then
  cancel()
 end
end

bOk.OnClick = ok
bCancel.OnClick = cancel

mvf.miUserdefinedComment.OnClick = function()
	selAddress = mvf.Disassemblerview.SelectedAddress
	fm.setPosition(mvf.Left,mvf.Top)
	fm.Caption = string.format("Comment for: %X %%s (shows the autguess value)",selAddress)
	memo.Lines.Text = getComment(selAddress)
	fm.show()
	memo.setFocus()
	memo.SelStart = #(memo.Lines.Text)

end


```

`extensions/DeleteAllBreakpoints.lua`:

```lua
 --[[
Author: Skyrimfus
Discord ID: 244490308782391316
Name: Delete All Breakpoints
Version: Public version 2.0

Written for CE 7.4


Description: 
	This extension adds a option inside the breakpoint window that delets all breakpoints(Hotkey: Ctrl+Del)

--]]
 
 
 
function removeAllBp()
	local bpl = debug_getBreakpointList()
	for i=1,#bpl do
		debug_removeBreakpoint(bpl[i])
	end
end


local function addMi(fm)
	local pop = fm.ListView1.PopupMenu
	local orig = pop.onpopup
	local mi = createMenuItem(pop)
	mi.Caption = "Delete All"
	mi.ShortCut = "Ctrl+Del"
	mi.OnClick = removeAllBp
	pop.Items.add(mi)
	
	pop.onpopup = function(s)
		if fm.ListView1.Items.Count == 0 then
			mi.Enabled = false
		else
			mi.Enabled = true
		end
		orig(s)
	end


end


registerFormAddNotification(function(fm)
	if fm.ClassName == 'TfrmBreakpointlist' then
		fm.registerCreateCallback(addMi)
	end
end)
```

`extensions/EXPERIMENTALnew-addresslist-temp-helper.lua`:

```lua
--Version 1.2
--Author: Skyrimfus
--[[
Changelog
----1.0-----
  First version

----1.1-----
  Saving the table in any way(except with lua) should now only save the Main Address List

----1.2-----
  Added a menu-item and implementation of saving the TEMP AL as new Cheat Table
--]]


local addr,originalAL,parent,obtn,btn,btn2,al,tm,tempAL,mi,oldSaveTable,sd

MainForm.registerFirstShowCallback(function()
showMessage("You have loaded an extension that adds an extra address list. It is highly experimental and can corrupt/override/delete tables you load into it. Use at your own risk and backup any table you load with this extension!")
local oldhandler, oMIS, oSA
oldhandler=MainForm.actSave.OnExecute
oldSaveTable = saveTable

function saveTable(...)
 args = {...}
 if type(args[#args]) == "table" then
  if args[#args][1] == "saveTemp" then
    print("temp")--save our temp
    return
  end
 end
 btn.OnClick()
 oldSaveTable(...)--save the main
end

MainForm.actSave.OnExecute=function(sender)
  btn.OnClick()
  oldhandler(sender)
end

oMIS = MainForm.miSave.OnClick
MainForm.miSave.OnClick = function(s)
  btn.OnClick()
  oMIS(s)
end

oSA = MainForm.Save1.OnClick
MainForm.Save1.OnClick = function(s)
--[[
 showMessage("before save as")
 oSA(s)
 showMessage("aftet save as")
 --]]
end




addr = readPointerLocal(tonumber("0x"..string.format("%s",AddressList.Parent):match("userdata: (.+)")))-0x14D8
originalAL = readPointerLocal(tonumber("0x"..string.format("%s",AddressList):match("userdata: (.+)")))
parent = AddressList.Parent
obtn = MainForm.btnMemoryView
btn = createButton(MainForm.btnMemoryView.Parent)
	btn.Caption = "Main Address List"
        btn.Anchors = obtn.Anchors
        btn.AnchorSideBottom = obtn.AnchorSideBottom
        btn.AnchorSideLeft.Control = obtn
        btn.AnchorSideLeft.Side = asrRight
        btn.AnchorSideRight = obtn.AnchorSideRight
        btn.AnchorSideTop = obtn.AnchorSideTop
        btn.Height = obtn.Height
        btn.Width = 100
        btn.Enabled = false
		btn.OnClick = function()
			--Main Address List is visible:
			writePointerLocal(addr,originalAL)
			btn.Enabled = false
			btn2.Enabled = true
			al.Visible = false
			AddressList.Visible = true
			MainForm.UpdateTimer.Enabled = true
			tm.Enabled = false
		end

btn2 = createButton(MainForm.btnMemoryView.Parent)
		btn2.Caption = "Temp Address List"
        btn2.Anchors = obtn.Anchors
        btn2.AnchorSideBottom = obtn.AnchorSideBottom
        btn2.AnchorSideLeft.Control = btn
        btn2.AnchorSideLeft.Side = asrRight
        btn2.AnchorSideRight = obtn.AnchorSideRight
        btn2.AnchorSideTop = obtn.AnchorSideTop
        btn2.Height = obtn.Height
        btn2.Width = 100
		btn2.OnClick = function()
			--Temp Address List:
			writePointerLocal(addr,tempAL)
			btn.Enabled = true
			btn2.Enabled = false
			al.Visible = true
			AddressList.Visible = false
			MainForm.UpdateTimer.Enabled = false
			tm.Enabled = true
		end


al = createComponentClass("TAddresslist",parent)
  al.Parent = parent
  al.Visible = false
  al.Height = AddressList.Height
  al.Width = AddressList.Width
  al.BevelColor = 0x005fbf
  al.BevelWidth = 5
  al.Anchors = AddressList.Anchors
  al.AnchorSideBottom = AddressList.AnchorSideBottom
  al.AnchorSideLeft = AddressList.AnchorSideLeft
  al.AnchorSideRight = AddressList.AnchorSideRight
  al.AnchorSideTop = AddressList.AnchorSideTop
  
  
  if tm then tm.destroy() end
	tm = createTimer()
	tm.Interval = GetSettings().Value["Update interval"]--GetSettings().Value["Freeze interval"]
	tm.OnTimer = function()
	 al.repaint()--update the values
    end
  
	
    al.List.PopupMenu = AddressList.PopupMenu

  
	for i=0, AddressList.Header.Sections.Count-1 do
	  al.Header.Sections[i].Width = AddressList.Header.Sections[i].Width
	end
	tempAL = readPointerLocal(tonumber("0x"..string.format("%s",al):match("userdata: (.+)")))
	
mi = createMenuItem(AddressList.PopupMenu)
	mi.Caption = "Save Temp Address List as new table"
	mi.ImageIndex = 4
	AddressList.PopupMenu.Items.insert(0,mi)
	mi.OnClick = function()
	    if not sd.execute() then return end
		btn2.OnClick()
		oldSaveTable(sd.FileName)
	end
	
sd = createSaveDialog(MainForm)
	sd.DefaultExt = ".ct"
	sd.Filter = "Cheat Engine Tables (*.CT)|*.CT"


end)   
```

`extensions/GetFunctionCallers.lua`:

```lua
--[[
Author: Skyrimfus
Discord ID: 244490308782391316
Name: Get Function Callers
Version: Public version 1.0

Written for CE 7.4


Description: 
	This extension is a tool that you can use to figure where the function got called from, and how many times
	Tool can be opened from Memory Viewer->Tools->Function Callers


--]]
local fm,ed,lv,tm,btn,mn,mi
local started = false

local mvf = getMemoryViewForm()
local menu = mvf.Extra1
local mi = createMenuItem(menu)
mi.Caption = "Function Callers"
menu.insert(mvf.miLuaEngine.MenuIndex+1,mi)


fm = createForm(false)
fm.Caption = "Function callers"
fm.Width = 500
fm.BorderStyle = bsSizeable


mi.OnClick = function()
	fm.show()
end

btn = createButton(fm)
btn.Anchors = "[akTop,akRight]"
btn.Width = 100
btn.Hint = "Hold shift to select the current address in the dissasembler"
btn.ShowHint = true
btn.Caption = "Start"
btn.AnchorSideRight.Control = fm
btn.AnchorSideRight.Side = asrRight
btn.tabOrder = 1

ed = createEdit(fm)
ed.Anchors = "[akTop,akLeft,akRight]"
ed.AnchorSideRight.Control = btn
ed.AnchorSideRight.Side = asrLeft



lv = createListView(fm)
lv.MultiSelect = true
lv.OnDblClick = function(s) if s.Selected == nil then return end;getMemoryViewForm().DisassemblerView.SelectedAddress = getAddressSafe(s.Selected.Caption) end
lv.ReadOnly = true
lv.RowSelect = true
lv.Top = 25
lv.Anchors = "[akTop,akBottom,akLeft,akRight]"
lv.AnchorSideRight.Control = fm
lv.AnchorSideRight.Side = asrRight
lv.AnchorSideBottom.Control = fm
lv.AnchorSideBottom.Side = asrBottom
cAddr = lv.Columns.add()
cAddr.Caption = "Address"
cAddr.Width = 300
cHits = lv.Columns.add()
cHits.Caption = "Count"
cHits.Width = 100


mn = createPopupMenu(lv)
mi = createMenuItem(mn)
mi.Caption = "Copy"
mi.Shortcut = "CTRL+C"
mn.Images = MainForm.mfImageList
mi.ImageIndex = 20
mi.OnClick = function()
	local str = ""
	for i=0,lv.Items.Count-1 do
		if lv.Items[i].Selected then str = str..lv.Items[i].Caption.." | "..lv.Items[i].SubItems[0].."\n" end
	end
	writeToClipboard(str)

end
mn.Items.add(mi)
lv.PopupMenu = mn
mn.onPopup = function() mi.Enabled = lv.Selected or false and true end

fm.OnClose = function()
	started = false
	btn.Caption = "Start"
	if tm then tm.destroy() end
	if bAddr then debug_removeBreakpoint(bAddr) end
	fm.hide()
end

btn.OnClick = function()
    if isKeyPressed(VK_SHIFT) then ed.Text = getNameFromAddress(getMemoryViewForm().disassemblerview.SelectedAddress) end
	bAddr = getAddressSafe(ed.Text)
	if bAddr == nil then messageDialog("Error","Could not resolve address!",1);return end

	if not started then
		started = true
		btn.Caption = "Stop"

                lv.clear()
		rAddr = {}
		debug_removeBreakpoint(bAddr)
		debug_setBreakpoint(bAddr,function()
			ret = readPointer(RSP)
			if rAddr[ret] == nil then
				rAddr[ret] = 0
			end
			rAddr[ret] = rAddr[ret]+1
		end)

		if tm then tm.destroy() end
		tm = createTimer()
		tm.Parent = fm
		tm.Interval = 50
		lAddr = {}
		tm.OnTimer = function()
			for i in pairs(rAddr) do
				if lAddr[i] == nil then
					lAddr[i] = lv.Items.add()
					--lAddr[i].Caption = string.format("%X",i)
					lAddr[i].Caption = getNameFromAddress(i)
					lAddr[i].SubItems.add(0)
				end
				lAddr[i].SubItems[0] = rAddr[i]
			end
		end

	else
		started = false
		btn.Caption = "Start"
		if tm then tm.destroy() end
		debug_removeBreakpoint(bAddr)

	end




end
ed.OnKeyDown = function(key)if isKeyPressed(VK_RETURN) then btn.OnClick()end end



```

`extensions/INCOMPLETE_CommentsList.lua`:

```lua
--version 1.5 for testing...
useGetAllComments = true

if getAllComments == nil then
useGetAllComments =  false
function getAllComments()
  local results={}

  local ss=createStringStream()

  saveTable(ss)

  local xp=require("xmlSimple").newParser()
  local parsed=xp:ParseXmlText(ss.DataString)
  if parsed and parsed.CheatTable.DisassemblerComments then
    for i=1,parsed.CheatTable.DisassemblerComments:numChildren() do
      local ce=parsed.CheatTable.DisassemblerComments:children()[i]
      local e={}
      e.Address=getAddressSafe(ce.Address:value())

      if ce.Comment then
		results[e.Address] = ce.Comment:value()
      end


    end
  else
    results=nil
  end

  ss.destroy()

  return results or {}
end


end



dasmComments = createDisassembler()
arrComments = {}
arrDeleted = {}

function updateComments()
lvComments.beginUpdate()
 for i in pairs(arrComments) do
	local r = {pcall(string.find,string.upper(arrComments[i].comment),string.upper(edtSearch.Text))}
	
	if r[1]and r[2] then--string.find(string.upper(arrComments[i].comment),string.upper(edtSearch.Text)) then
		if arrDeleted[i] then
			--print("adding",arrComments[i].comment)
			local it=lvComments.Items.add()
			it.Caption = getComment(i)
			dasmComments.disassemble(i)
			local opcode = dasmComments.LastDisassembleData.opcode
			it.SubItems.Text = string.format("%X\n%s %s",i,opcode,(opcode == "??" and "" or dasmComments.LastDisassembleData.parameters))
	
			
			
			arrDeleted[i] = nil
			arrComments[i]['lvItem'] = it
		end
	else
		if arrDeleted[i] == nil then
			--print("removing",arrComments[i].comment)
			arrComments[i].lvItem.delete()
			arrDeleted[i] = true		
		end
	end
 end
lvComments.endUpdate()
end

function updateCommentsForce()
 if getAllComments == nil then 
	print("To force update the comments list, you need to have the getAllComments function!")
	return
 end
 
 arrComments = {}
 arrDeleted = {}
 lvComments.clear()
 local comments = getAllComments()
 for i,v in pairs(comments) do
  lvComments.beginUpdate()
  --if edtSearch.Text == '' or string.find(string.upper(v),string.upper(edtSearch.Text)) then
	  local it = lvComments.Items.add()
	     arrComments[i] = {}
         arrComments[i]['comment'] = v 
		 arrComments[i]['lvItem'] = it
	  it.Caption = v
	  dasmComments.disassemble(i)
	  local opcode = dasmComments.LastDisassembleData.opcode
	  it.SubItems.Text = string.format("%X\n%s %s",i,opcode,(opcode == "??" and "" or dasmComments.LastDisassembleData.parameters))
  --end
  lvComments.endUpdate()
 end
end

function diffDetected(a,c)
c = tostring(c)
 if arrComments[a] == nil then --not in the list so add it
  arrComments[a] = {}
  arrComments[a]['comment'] = c   
  local it = lvComments.Items.add()
  it.Caption = c
  dasmComments.disassemble(a)
  local opcode = dasmComments.LastDisassembleData.opcode
  it.SubItems.Text = string.format("%X\n%s %s",a,opcode,(opcode == "??" and "" or dasmComments.LastDisassembleData.parameters))

  
 
  
  arrComments[a]['lvItem'] = it
  
 elseif c:gsub("%s+","") == "" then
  --print("comment deleted",c)
  arrComments[a].lvItem.delete()
  arrComments[a] = nil
 else
  arrComments[a].comment = c
  arrComments[a].lvItem.Caption = c
end

end

----------GUI BEGIN----------------
frmCommentsList = createForm(false)
 frmCommentsList.Caption = "Comments list"
 frmCommentsList.BorderStyle = bsSizeable
 frmCommentsList.Width = 700
 frmCommentsList.Height = 400

lblSearch = createLabel(frmCommentsList)
 lblSearch.Caption = "Search:"
 lblSearch.Left = 5
 lblSearch.Top = 5

edtSearch = createEdit(frmCommentsList)
 edtSearch.AnchorSideLeft.Control = lblSearch
 edtSearch.AnchorSideLeft.Side = asrRight
 edtSearch.AnchorSideRight.Control = frmCommentsList
 edtSearch.AnchorSideRight.Side = asrRight

 edtSearch.BorderSpacing.Left = 5
 edtSearch.BorderSpacing.Right = 5
 edtSearch.Anchors = "akTop,akLeft,akRight"

lvComments = createListview(frmCommentsList)
 lvComments.Anchors = "akTop,akLeft,akRight,akBottom"
 lvComments.AnchorSideTop.Control = edtSearch
 lvComments.AnchorSideTop.Side = asrBottom
 lvComments.BorderSpacing.Top = 5
 lvComments.AnchorSideRight.Control = frmCommentsList
 lvComments.AnchorSideRight.Side = asrRight
 lvComments.AnchorSideBottom.Control = frmCommentsList
 lvComments.AnchorSideBottom.Side = asrBottom
 lvComments.RowSelect = true
 lvComments.ReadOnly = true
 lvComments.HideSelection = false


 lcComments = lvComments.Columns.add()
  lcComments.Caption = "Comments"
  lcComments.Width = 280

 lcAddress= lvComments.Columns.add()
  lcAddress.Caption = "Address"
  lcAddress.Width = 75

 lcOpcode = lvComments.Columns.add()
  lcOpcode.Caption = "Opcode"
  lcOpcode.Width = 320


if getAllComments ~= nil then
 btnForceUpdate =  createComponentClass('TSpeedButton', frmCommentsList)
 btnForceUpdate.Parent = frmCommentsList
 btnForceUpdate.Images = MainForm.mfImageList
 btnForceUpdate.ImageIndex = 15
 btnForceUpdate.ImageWidth = 20
 btnForceUpdate.OnClick = updateCommentsForce
 
 btnForceUpdate.Hint = useGetAllComments and "Force refresh list" or "Force refresh list(WARNING! NOT A NAITIVE IMPLEMENTATION" 
 
 btnForceUpdate.ShowHint = true
 btnForceUpdate.ParentShowHint = false
  
  btnForceUpdate.Height = 25
  btnForceUpdate.Width = btnForceUpdate.Height
  edtSearch.AnchorSideRight.Control = btnForceUpdate
  edtSearch.AnchorSideRight.Side = asrLeft
 
 
  btnForceUpdate.Anchors = "akRight, akTop"
  
  btnForceUpdate.AnchorSideRight.Control = frmCommentsList
   btnForceUpdate.AnchorSideRight.Side = asrRight
   btnForceUpdate.BorderSpacing.Right = 5



end
----------GUI END----------------------

local mf = getMemoryViewForm()
local pm = mf.DisassemblerView.PopupMenu
local pmi,gg,gg2
for i = 0, pm.Items.Count-1 do
 if pm.Items[i].Name == 'miUserdefinedComment' then
  pmi = pm.Items[i]
  break
 end
end
if not gg then gg = pmi.OnClick end
if not gg2 then gg2 = setComment end

pmi.OnClick = function(s)
addr = mf.DisassemblerView.SelectedAddress
local cmb = getComment(addr)
gg(s)
local cma = getComment(addr)

if cmb ~= cma then
 diffDetected(addr,cma)
end
end

setComment = function(a,c)
local cmb = getComment(a)
if cmb ~= c then 
 diffDetected(a,c)
end

gg2(a,c)
end

frmCommentsList.OnClose = function() frmCommentsList.hide() end
frmCommentsList.OnShow = function() updateComments() end

lvComments.OnDblClick = function(s) getMemoryViewForm().DisassemblerView.SelectedAddress = "0x"..s.Selected.SubItems[0] end
edtSearch.OnChange = function(s) updateComments() end






--Create menu shit for memory view:
 menuView = getMemoryViewForm().Menu.Items[2]
 miCommentsList = createMenuItem(menuView)
  miCommentsList.Caption = "Comments list"
  miCommentsList.ImageIndex = 69 --nice
  miCommentsList.OnClick = frmCommentsList.show
  miCommentsList.setShortcut("Ctrl+Shift+B")
 menuView.insert(7,miCommentsList)
 


```

`extensions/LuaEngineInsertTemplate.lua`:

```lua
local fm,mi,m_insert,pop,templates,name,script,split_pos

--[[
if hk then hk.destroy() end
hk = createHotkey(function()
	print("Cursor at:", getLuaEngine().mScript.SelStart)
end, VK_CONTROL)
--]]
templates = 
{
[==[
Create Timer
if tm then tm.destroy() end
tm = createTimer()
tm.Interval = 500
tm.OnTimer = function()
%caret%
end
]==],
[==[
Debug_breakpoint
addr = %dasmSelectedAddress%
debug_removeBreakpoint(addr)
debug_setBreakpoint(addr,function()
%caret%
end)
]==], 
[==[
Enum functions
local modules = enumModules()
for i=1,#modules do
 local export = enumExports(getAddress(modules[i].Name))
 if type(export) ~= "table" then goto cont end
 for j,v in pairs(export) do
    if j:match("%caret%") then
     printf("ADDRESS: %X, NAME: %s", v,j)
    end
 end
 ::cont::
end
]==],
}



local function insert(tpos, text)
	local pos = tpos
	if pos < 1 then pos = 1 end
	fm.mScript.Lines.Text= (fm.mScript.Lines.Text):sub(1,pos)..text..(fm.mScript.Lines.Text):sub(pos+1)
	fm.mScript.SelStart = tpos
end


fm = getLuaEngine()
pop = fm.mScript.PopupMenu
m_insert = createMenuItem(pop)
m_insert.Caption = "Insert"
pop.Items.Insert(0,m_insert)


for i=1,#templates do
    split_pos = (templates[i]):find("\n")
	name = (templates[i]):sub(1,split_pos)
	
	
	mi = createMenuItem(m_insert)
	mi.Caption = name
	m_insert.add(mi)
	
	mi.OnClick = function(s)
		local i = s.MenuIndex+1
		split_pos = (templates[i]):find("\n")
		script = (templates[i]):sub(split_pos+1)
		local caret = fm.mScript.SelStart-1
		if caret < 0 then caret = 0 end
		local original = fm.mScript.Lines.Text
		script = original:sub(1,caret)..script..original:sub(caret+1)
		script = (script):gsub("%%dasmSelectedAddress%%",string.format("0x%X",getMemoryViewForm().disassemblerview.SelectedAddress))
		
		fm.mScript.Lines.Text = script
		local bt = stringToByteTable(fm.mScript.Lines.Text)
		for i=1, #bt do 
			if bt[i] == 37 --[[% char]--]] and byteTableToString({bt[i+1],bt[i+2],bt[i+3],bt[i+4],bt[i+5],bt[i+6]}) == "caret%" then
				fm.mScript.Lines.Text = (fm.mScript.Lines.Text):gsub("%%caret%%","")
				fm.mScript.selStart = i
				return
			end
		end
		
	end
	
end



```

`extensions/SelectCurrentFunctionExpand.lua`:

```lua
--[[
Author: Skyrimfus
Discord ID: 244490308782391316
Name: Expand Select Current Function
Version: Public version 2.5

Written for CE 7.4


Description: 
	This extension expands the "select current function" and adds the following options:
		- Select current function and goto top
		- Select current function and goto bottom
		- Select current function and copy bottom opcode


--]]

local fm = getMemoryViewForm()
local pop = fm.MenuItem2--get menu item
local orig = pop.OnClick--get original function 
pop.OnClick = nil--disable the original function so that it doesn't exec when menu expands

local goTop = createMenuItem(pop_scf)
	goTop.Caption = "Select function and goto top"
	goTop.OnClick = orig
	
local goBot = createMenuItem(pop_scf)
	goBot.Caption = "Select function and goto bottom"
	goBot.OnClick = function(s)
						orig(s)
						--Basic variable swaping:
						local tmp = fm.DisassemblerView.SelectedAddress
						fm.DisassemblerView.SelectedAddress = fm.DisassemblerView.SelectedAddress2
						fm.DisassemblerView.SelectedAddress2 = tmp
					end
					
local cpyOpc = createMenuItem(pop_scf)
	cpyOpc.Caption = "Select function and copy bottom opcode"
	cpyOpc.OnClick = function(s)
						orig(s)
						writeToClipboard(({splitDisassembledString(disassemble(fm.DisassemblerView.SelectedAddress2))})[2])
					 end

pop.add(goTop);pop.add(goBot);pop.add(cpyOpc)
```

`extensions/customTimer.lua`:

```lua
--This code was made to explain how you can implement timers from "scratch"
--usage: same as createTimer() but with addTimer()
--doesn't support one-shot timers
--if you leave the sleep(1) commented 1 cpu will run at 100%
timerArray = {}
function addTimer()
	local timerObject = {Interval=0,Enabled=0,OnTimer=0,  LastTick=0, selfIndex = #timerArray+1}
	timerArray[timerObject.selfIndex] = timerObject
	timerObject.destroy = function()
		for i=timerObject.selfIndex, #timerArray do
			timerArray[i] = timerArray[i+1]
			if timerArray[i] then timerArray[i].selfIndex = i end
		end
	end
	return timerObject
end


timerThread = createThread(function(t)--make sure to nil the var when you do timerThread.terminate()
while not t.Terminated do
	local tick = getTickCount()
	for i=1,#timerArray do
		local timer = timerArray[i]
		if tick - timer.LastTick >= timer.Interval then
			if timer.Enabled and type(timer.OnTimer) == "function" then timer.OnTimer() end
			timer.LastTick = tick
		end
	end
--sleep(1)--thread will go to 100%
end
end)

```

`extensions/lua51stackviewer32bit.lua`:

```lua
if fm then fm.destroy() end
local fs,ss--,fm
local L--lua state
local stack_top, stack_bot, elements

local typedef = {"boolean","lightuserdata","number","string","table","function","userdata","thread","numtags"}
typedef[-1] = "none"
typedef[0] = "nil"
local function tovalue(i,id)
	if id==1 then--bool
		return readInteger(stack_top+(i<<3)) == 0 and "false" or "true"
	elseif id==4 then--string
                 addr = getAddressSafe(readInteger(stack_top+(i<<3))+0x10)
		return readString(addr,500)
	elseif id==3 then--number
		local b = readBytes(stack_top+(i<<3),4,true)
		return "int:"..byteTableToDword(b).." |float:"..byteTableToFloat(b)
	else
		return "not implemented"
	end
end


fs = [=[<?xml version="1.0" encoding="utf-8"?>
<FormData>
  <frmStackViewer Class="TCEForm" Encoding="Ascii85">y.jSP,AtI}36KC(,L;uPUFHi$sH)a@BaMa#Gz%oAfZ9b?h8S:$Hge2sTlE9FsQNekf-d=M^g2vlLIUD3K--/.;wA39xkuOek@]XqP%Bw(w[0O-RP6ClOTg}%Jw]Lc)^/Dn:J!/g9@w8#n7;nIn}jZG/@%S]!2Dr6x$6o%MJ{U*Gh!9GoyHXL8OH*yE+uNYX!cos0-XTV)WqxG!H9_[W/h@Pn823B*L^pa9FeIqQ:p([!w%})o)5%^:]xJh%d7J0Dqkg)3lES;P=r)LZ2%O)s*t1$),KnB9qkSnZ)$E9@y]R3eCy?f3AM0t)B}B/1RK4G!=K)W]4[7Pmg%l6EELzcjW{Heoa_8A(*{lMxQBRa47-@2uY/!GyA3-HwJlX?AtG/#!T;qBtRvc(T7dI5nu}i)MU92+Evri@M9RMsYKa9wR/]F=81X/-@Pp9-mTmeZB;WEonLokiuD^tNP)HSTcAQ{29ah+!H5TJIrU_JYLp7Z]%nVHgy#@)VTx@TfzqN(AyTcZziFKGQzNR,YqP+J^1#OEC@wB/F=BE*!aV+s,_1ng5oo*-]?7kgurE(+IF[/T3^yuM/AlM/@[-I6eU8WU-Y$,)#5d-YYiQurPUiDV!A;lykg/r{WfzJ8RQjI.9TGDrJi]r7H0h[6dZ97@edSPn*;ev[RJ,#O*({N%/nZ{GFe+A#Zx=aW6rc!1N^]q:%E(Wv-+Bjf+3+(15]mu^fx%o}1NW5GANLU*cFJz#aAXzw62@Jg%/:AkjVZixnD-=**^u!B!s9#Jidy;J[Lvs+sq^U+4!hU++^mc{SNfh^]242+rbWU_g8^eM#O+Cd*tW3lzK[l60UvtZ?(ZD.;:1uIA:zQ5Jt(JY:2L</frmStackViewer>
</FormData>
]=]
ss = createStringStream(fs)
fm = createFormFromStream(ss)
ss.destroy()

fm.inLuaState.OnChange = function(s)
L = getAddressSafe(s.Text)
end







local tm = createTimer(fm)
tm.Interval = 100
tm.OnTimer = function()
	if L == nil then return end
	stack_top = readPointer(L+0xC)
	stack_bot = readPointer(L+0x8)
	elements = (stack_bot-stack_top)>>3
	fm.inStackBot.Text = string.format("%X",stack_bot)
	fm.inStackTop.Text = string.format("%X",stack_top)
	fm.lElements.Caption = "Elements: "..elements
        if elements > 20 then return end
	fm.lvStack.Items.clear()
	for i=1,elements do
		local it = fm.lvStack.Items.add()
		local typeID = readInteger(stack_top+(i<<3)+4)&0xF
		it.Caption = i
		it.SubItems.add(typedef[typeID])
		it.SubItems.add(tovalue(i,typeID))
	end

end




fm.show()

```

`extensions/lua53stackviewer64bit.lua`:

```lua
if fm then fm.destroy() end
local fs,ss--,fm
local L--lua state
local stack_top, stack_bot, elements

local typedef = {"boolean","lightuserdata","number","string","table","function","userdata","thread","numtags"}
typedef[-1] = "none"
typedef[0] = "nil"
local function tovalue(i,id)
	if id==1 then--bool
		return readInteger(stack_top+(i<<4)) == 0 and "false" or "true"
	elseif id==4 then--string
		return readString(readInteger(stack_top+(i<<4))+0x20,500)
	elseif id==3 then--number
		return readInteger(stack_top+(i<<4))
	else
		return "not implemented"
	end
end


fs = [=[<?xml version="1.0" encoding="utf-8"?>
<FormData>
  <frmStackViewer Class="TCEForm" Encoding="Ascii85">y.jSP,AtI}36KC(,L;uPUFHi$sH)a@BaMa#Gz%oAfZ9b?h8S:$Hge2sTlE9FsQNekf-d=M^g2vlLIUD3K--/.;wA39xkuOek@]XqP%Bw(w[0O-RP6ClOTg}%Jw]Lc)^/Dn:J!/g9@w8#n7;nIn}jZG/@%S]!2Dr6x$6o%MJ{U*Gh!9GoyHXL8OH*yE+uNYX!cos0-XTV)WqxG!H9_[W/h@Pn823B*L^pa9FeIqQ:p([!w%})o)5%^:]xJh%d7J0Dqkg)3lES;P=r)LZ2%O)s*t1$),KnB9qkSnZ)$E9@y]R3eCy?f3AM0t)B}B/1RK4G!=K)W]4[7Pmg%l6EELzcjW{Heoa_8A(*{lMxQBRa47-@2uY/!GyA3-HwJlX?AtG/#!T;qBtRvc(T7dI5nu}i)MU92+Evri@M9RMsYKa9wR/]F=81X/-@Pp9-mTmeZB;WEonLokiuD^tNP)HSTcAQ{29ah+!H5TJIrU_JYLp7Z]%nVHgy#@)VTx@TfzqN(AyTcZziFKGQzNR,YqP+J^1#OEC@wB/F=BE*!aV+s,_1ng5oo*-]?7kgurE(+IF[/T3^yuM/AlM/@[-I6eU8WU-Y$,)#5d-YYiQurPUiDV!A;lykg/r{WfzJ8RQjI.9TGDrJi]r7H0h[6dZ97@edSPn*;ev[RJ,#O*({N%/nZ{GFe+A#Zx=aW6rc!1N^]q:%E(Wv-+Bjf+3+(15]mu^fx%o}1NW5GANLU*cFJz#aAXzw62@Jg%/:AkjVZixnD-=**^u!B!s9#Jidy;J[Lvs+sq^U+4!hU++^mc{SNfh^]242+rbWU_g8^eM#O+Cd*tW3lzK[l60UvtZ?(ZD.;:1uIA:zQ5Jt(JY:2L</frmStackViewer>
</FormData>
]=]
ss = createStringStream(fs)
fm = createFormFromStream(ss)
ss.destroy()

fm.inLuaState.OnChange = function(s)
L = getAddressSafe(s.Text)
end







local tm = createTimer(fm)
tm.Interval = 100
tm.OnTimer = function()
	if L == nil then return end
	stack_top = readPointer(readPointer(L+0x20))
	stack_bot = readPointer(L+0x10)
	elements = (stack_bot-stack_top-0x10)>>4
	fm.inStackBot.Text = string.format("%X",stack_bot)
	fm.inStackTop.Text = string.format("%X",stack_top)
	fm.lElements.Caption = "Elements: "..elements
	
	
	fm.lvStack.Items.clear()
	for i=1,elements do
		local it = fm.lvStack.Items.add()
		local typeID = readInteger(stack_top+(i<<4)+8)&0xF
		it.Caption = i
		it.SubItems.add(typedef[typeID])
		it.SubItems.add(tovalue(i,typeID))
	end
	
end




fm.show()

```