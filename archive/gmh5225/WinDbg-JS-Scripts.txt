Project Path: arc_gmh5225_WinDbg-JS-Scripts_00m78ii6

Source Tree:

```txt
arc_gmh5225_WinDbg-JS-Scripts_00m78ii6
├── LICENSE.txt
├── ManifestVersion.txt
├── README.md
├── common.js
├── config.xml.template
├── gdb
│   └── memory.py
├── manifest.1.xml
├── memory.js
├── noexcept.js
└── x64.js

```

`LICENSE.txt`:

```txt
Copyright © 2020-2022 AO Kaspersky Lab. All Rights Reserved.
 
Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
 
The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.
 
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

`ManifestVersion.txt`:

```txt
1
1.0.0.0
1
```

`README.md`:

```md
## JS scripts for WinDbg

This is a collection of WinDbg JS scripts useful for dumps analysis.

### Basic usage:

To use JS scripts in WinDbg you need WinDbg Preview or regular WinDbg from February 2019 or later.

You can load scripts by hand:
1. Load JS engine first: .load jsprovider.dll
2. Then load script: .scriptload <script filename with full path>

--or--

You can use it through the WinDbg extension gallery. This feature is available in WinDbg Preview 1.0.1902 and up or latest regular WinDbg.
Docs are here https://github.com/microsoft/WinDbg-Samples/tree/master/Manifest
Gallery describes all commands in all scripts and automatically loads the required script if you try to use a command from it.

The gallery has already been prepared here but one step needs to be done by hand.
1. The gallery files are: ManifestVersion.txt, manifest.N.xml and config.xml.template.
2. You have to copy config.xml.template to config.xml
3. Open config.xml in your favorite editor and for the LocalCacheRootFolder node set Value to the absolute path to that directory.
4. Save changes.
5. Open WinDbg with any dump - all you need is the WinDbg console.
6. Load the gallery with command: .settings load <config.xml with absoltute path>
7. If the command is absent then your WinDng is too old.
8. If config.xml was loaded successfully, save it: .settings save
9. Next close WinDbg, open again and try any script command - it should work without any additional action.

### Commands:

**common.js**

- **!exccandidates [0x<thread ID>]**
  Searches for possible exception records in stack
  of the thread specified by <thread ID> or in stack of the current thread.

- **!walk_stdmap 0x<head ptr>**
  Dumps all elements of the map (no interpretation, just dds) with address <head ptr>.
  The <head ptr> should be taken from _Myhead field of std::map

**noexcept.js**

- **!fix_stack**
  Try to show corrected stack of the current thread if it is shown wrong due to an exception from noexcept function.

**x64.js**

- **!x32stacks**
  Try to show x32 stacks of all threads in x64 kernel dump.

```

`common.js`:

```js
/*///////////////////////////////////////////////////////////////////////
MIT License

Copyright (c) 2020 AO Kaspersky Lab. All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
/*////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////
// Common utilities
//
// Note! Parameters should be passed with 0x or in "". Otherwise you got an error "Error: Unable to bind name ...".
//
// !exccandidates [<thread id>] - search for exception candidates in the specified thread. If no thread is specified current one will be used.
//
// !walk_stdmap <head ptr(_Myhead field of std::map)> - walk std::map blocks
//
/////////////////////////////////////////////////////////////////////////

"use strict";

// Utilities
function GetStringParameter(param)
{
    if (typeof param == "object")
    {
        return param.toString(16);
    }

    return "" + param.toString(16);
}

function PrintCommandOutput(output)
{
    for (var line of output)
        host.diagnostics.debugLog(line + "\n");
}

// Search thread stack for exception candidates (x86 only)
function GetStackBase(thread)
{
    var StackBase = 0;

    // try to get stack limits from the TEB
    try
    {
        if (thread == 0)
        {// current thread
            host.diagnostics.debugLog("Searching for exception candidate in current thread\n");
            StackBase = host.currentThread.Environment.EnvironmentBlock.NtTib.StackBase.address - 0x100000;
        }
        else
        {
            var threadId = GetStringParameter(thread);
            host.diagnostics.debugLog("Searching for exception candidate in thread with TID 0x" + threadId + "\n");
            StackBase = host.currentProcess.Threads[Number.parseInt(threadId, 16)].Environment.EnvironmentBlock.NtTib.StackBase.address - 0x100000;
        }
        return StackBase;
    }
    catch (err)
    {
        host.diagnostics.debugLog("Error " + err.name + ": " + err.message + "\n");
    }

    // Oops, TEB is unavalable, guess by ESP
    host.diagnostics.debugLog("Guess stack limits by ESP\n");
    if (thread == 0)
    {// current thread
        StackBase = host.currentThread.Registers.User.esp & 0xFFF00000;
    }
    else
    {
        var threadId = GetStringParameter(thread);
        StackBase = host.currentProcess.Threads[Number.parseInt(threadId, 16)].Registers.User.esp & 0xFFF00000;
    }
    return StackBase;
}

function __FindExceptionCandidates(thread = 0)
{
    var SearchBase = GetStackBase(thread);
    host.diagnostics.debugLog("Stack top: 0x" + SearchBase.toString(16) + "\n\n");

    // search in stack sequence of values @gs @fs @es @ds
    var ctl = host.namespace.Debugger.Utility.Control;
    var cmd = "s -[1]d 0x" + SearchBase.toString(16) + " L?0x100000 @gs @fs @es @ds";
    var output = ctl.ExecuteCommand(cmd);
    var foundCount = 0;
    for (var line of output)
    {
        if (line.length == 0)
            continue;

        // found entries
        var address = host.parseInt64(line, 16);
        address = address - 0x8c;
        
        // try to find exception record
        var output1 = ctl.ExecuteCommand("s -[1]d " + (address - 0x100).toString(16) + " L0x100 0x" + address.toString(16));
        var nearestEntry = 0;
        try
        {
            for (var line1 of output1)
            {
                nearestEntry = host.parseInt64(line1, 16);
            }
        }
        catch(err)
        {
            nearestEntry = 0;
        }
        
        // ok, found
        if (nearestEntry != 0)
        {
            var erAddress = host.memory.readMemoryValues(nearestEntry - 4, 1, 4, false);
            var exceptionCode = host.memory.readMemoryValues(nearestEntry + 4, 1, 4, false);
            host.diagnostics.debugLog("Found exception " + foundCount++ + "\n");
            host.diagnostics.debugLog(".exr 0x" + erAddress[0].toString(16) + " - exception code 0x" + exceptionCode[0].toString(16) + "\n");
            host.diagnostics.debugLog(".cxr 0x" + address.toString(16) + "\n");
        }
    }
    
    if (foundCount == 0)
        host.diagnostics.debugLog("No exception candidate found\n");
    
    return foundCount;
}

// Walk std::map blocks (x86 only)
function __DumpStdMapItem(item, head, count)
{
    host.diagnostics.debugLog("\nItem 0x" + item.toString(16) + "\n----------------------------------------------------\n");
    PrintCommandOutput(host.namespace.Debugger.Utility.Control.ExecuteCommand("ddp 0x" + (item + 12).toString(16)));
    ++count.val;
    
    var left = host.memory.readMemoryValues(item + 0, 1, 4, false);
    if (left[0] != head)
        __DumpStdMapItem(left[0], head, count);
    var right = host.memory.readMemoryValues(item + 8, 1, 4, false);
    if (right[0] != head)
        __DumpStdMapItem(right[0], head, count);
}

function __WalkStdMap(head)
{
    var headPtrStr = GetStringParameter(head);
    var headPtr = Number.parseInt(headPtrStr, 16);
    host.diagnostics.debugLog("Walking std::map from head 0x" + headPtr.toString(16) + "\n");

    // get parent item - the real head of map
    var ctl = host.namespace.Debugger.Utility.Control;
    var realHead = host.memory.readMemoryValues(headPtr + 4, 1, 4, false);
    host.diagnostics.debugLog("Root entry 0x" + realHead[0].toString(16) + "\n");
    let count = {val: 0};
    if (realHead[0] != headPtr)
        __DumpStdMapItem(realHead[0], headPtr, count);

    host.diagnostics.debugLog("\nMap has " + count.val.toString() + " items\n");
    return count.val;
}

// Register aliases
function initializeScript()
{
    return [new host.apiVersionSupport(1, 2),
            new host.functionAlias(__FindExceptionCandidates, "exccandidates"),
            new host.functionAlias(__WalkStdMap, "walk_stdmap")];
}

```

`config.xml.template`:

```template
<?xml version="1.0" encoding="UTF-8"?>
<Settings Version="1">
  <Namespace Name="Extensions">
    <Setting Name="ExtensionRepository" Type="VT_BSTR" Value="Implicit"></Setting>
    <Namespace Name="ExtensionRepositories">
      <Namespace Name="KL WinDbg Script Gallery">
        <Setting Name="Id" Type="VT_BSTR" Value="9853FFCF-144E-44B3-A45B-A789DDC45A6B"></Setting>
        <Setting Name="LocalCacheRootFolder" Type="VT_BSTR" Value="\absolute\path\to\the\xmlmanifest\directory"></Setting>
        <Setting Name="IsEnabled" Type="VT_BOOL" Value="true"></Setting>
      </Namespace>
    </Namespace>
  </Namespace>
</Settings>
```

`gdb/memory.py`:

```py
#/usr/bin/python
#
##################################################################################
#
# MIT License
#
# Copyright (c) 2022 AO Kaspersky Lab. All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
##################################################################################
#
# Memory utilities
#

import chunk
import struct
import sys
from functools import lru_cache
import gdb

def CastULong(v):
    mask = (1 << 64) - 1
    return int(v.cast(gdb.Value(mask).type)) & mask

def AlignAddress(address, align):
    return address + ((align - (address % align)) % align)

@lru_cache()
def ReadMemory_Int(addr):
    """Return an integer read from memory."""
    sz = 8
    mem = gdb.selected_inferior().read_memory(addr, sz).tobytes()
    return struct.unpack("{}Q".format('<'), mem)[0]

@lru_cache()
def LookupType(name):
    try:
        return gdb.lookup_type(name).strip_typedefs()
    except RuntimeError:
        return None

def FindHeapBase():
    return int(gdb.parse_and_eval("mp_->sbrk_base"))

def FindMainArena():
    return AlignAddress(CastULong(gdb.parse_and_eval("(void *)&__malloc_hook")) + 8, 0x20)

class Arena:
    """Heap arena class"""

    def __init__(self, addr, malloc_state_type):
        arena = gdb.parse_and_eval("*{:#x}".format(addr))
        self.m_addr = int(arena.address)
        self.m_arena = arena.cast(malloc_state_type)
        return

    def __getitem__(self, item):
        return self.m_arena[item]

    def __getattr__(self, attr):
        return self.m_arena[attr]

def GetMainArena():
    malloc_state_type = LookupType("struct malloc_state")
    main_arena = FindMainArena()
    return Arena(main_arena, malloc_state_type)


class Chunk:
    """Heap chunk class"""

    def __init__(self, addr):
        self.ptrsize = 8
        self.base_address = addr
        self.address = addr + 2 * self.ptrsize
        self.size_addr = int(self.address - self.ptrsize)
        self.prev_size_addr = self.base_address
        return

    @property
    def size(self):
        return ReadMemory_Int(self.size_addr) & (~0x07)

    @property
    def user_size(self):
        current_size = self.size
        if current_size == 0:
            return current_size
        if self.m_bit:
            return current_size - 2 * self.ptrsize
        return current_size - self.ptrsize

    @property
    def prev_chunk_size(self):
        return ReadMemory_Int(self.prev_size_addr)

    def get_next_chunk(self):
        return Chunk(self.base_address + self.size)

    @property
    def p_bit(self):
        return ReadMemory_Int(self.size_addr) & 0x01 == 0x01

    @property
    def m_bit(self):
        return ReadMemory_Int(self.size_addr) & 0x02 == 0x02

    @property
    def a_bit(self):
        return ReadMemory_Int(self.size_addr) & 0x04 == 0x04

    @property
    def busy(self):
        if self.m_bit:
            return True
        return self.get_next_chunk().p_bit

def GetChunks():
    addr = FindHeapBase()
    main_arena = GetMainArena()
    while True:
        chunk = Chunk(addr)
        yield chunk
        if chunk.size == 0:
            break
        addr += chunk.size
        if addr >= main_arena.top:
            break


def AddItem(d, val):
    if d.get(val) is None:
        d[val] = 1
    else:
        d[val] = d[val] + 1

def SplitStringIntoTwixes(s):
    for pos in range(len(s), 1, -2):
        i = int(s[pos-2:pos], 16)
        yield chr(i) if i > 21 else '.'

def HexIntToAscii(v):
    return "".join(SplitStringIntoTwixes(v))

def PrintTopStats(d):
    s = sorted(d.items(), key=lambda x: x[1], reverse=True)
    i = 0
    for k, v in s:
        print("{} - '{}': {}".format(k, HexIntToAscii(k), v))
        i = i + 1
        if i > 10:
            break

class HeapAllocStats(gdb.Command):
    """Collect heap allocation stats"""

    def __init__ (self):
        super (HeapAllocStats, self).__init__ ("heap_alloc_stats", gdb.COMMAND_USER)

    def invoke (self, arg, from_tty):
        if gdb.selected_inferior().pid == 0:
            print("There is no running program\n")
            return

        stat_int1 = dict();
        stat_int2 = dict();
        stat_int3 = dict();
        stat_int4 = dict();
        stat_double_int1 = dict();
        stat_double_int2 = dict();
        stat_quad_int = {};
        busy_chunk_count = 0

        for ch in GetChunks():
            if ch.busy:
                busy_chunk_count = busy_chunk_count + 1
                size = ch.user_size
                i1 = 0
                i2 = 0
                i3 = 0
                i4 = 0
                if size >= 32:
                    i1 = ReadMemory_Int(ch.address)
                    i2 = ReadMemory_Int(ch.address + 8)
                    i3 = ReadMemory_Int(ch.address + 16)
                    i4 = ReadMemory_Int(ch.address + 24)
                elif size >= 24:
                    i1 = ReadMemory_Int(ch.address)
                    i2 = ReadMemory_Int(ch.address + 8)
                    i3 = ReadMemory_Int(ch.address + 16)
                elif size >= 16:
                    i1 = ReadMemory_Int(ch.address)
                    i2 = ReadMemory_Int(ch.address + 8)
                elif size >= 8:
                    i1 = ReadMemory_Int(ch.address)
                else:
                    continue
                AddItem(stat_int1, "{:016x}".format(i1))
                AddItem(stat_int2, "{:016x}".format(i2))
                AddItem(stat_int3, "{:016x}".format(i3))
                AddItem(stat_int4, "{:016x}".format(i4))
                AddItem(stat_double_int1, "{:016x}{:016x}".format(i2, i1))
                AddItem(stat_double_int2, "{:016x}{:016x}".format(i4, i3))
                AddItem(stat_quad_int, "{:016x}{:016x}{:016x}{:016x}".format(i4, i3, i2, i1))
        print("Total {} busy chunks\n".format(busy_chunk_count))

        print("--- Top by first int ---");
        PrintTopStats(stat_int1);
        print("\n--- Top by second int ---\n");
        PrintTopStats(stat_int2);
        print("\n--- Top by third int ---\n");
        PrintTopStats(stat_int3);
        print("\n--- Top by fourth int ---\n");
        PrintTopStats(stat_int4);
        print("\n--- Top by first double int ---\n");
        PrintTopStats(stat_double_int1);
        print("\n--- Top by second double int ---\n");
        PrintTopStats(stat_double_int2);
        print("\n--- Top by quad int ---\n");
        PrintTopStats(stat_quad_int);


if __name__ == "__main__":

    if sys.version_info[0] == 2:
        err("Python3 is required")

    else:
        gdb.execute("set python print-stack full")

        HeapAllocStats()

```

`manifest.1.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<ExtensionPackages Version="1.0.0.0" Compression="none">
    <ExtensionPackage>
        <Name>CommonHelpers</Name>
        <Version>1.0.0.1</Version>
        <Description>Some common helpers.</Description>
        <Components>
            <ScriptComponent Name="CommonHelpers" Type="Engine" File="common.js" FilePathKind="RepositoryRelative">
                <FunctionAliases>
                    <FunctionAlias Name="exccandidates">
                        <AliasItem>
                            <Syntax>
                                <![CDATA[!exccandidates 0x[<thread ID>]]]>
                            </Syntax>
                            <Description>
                                <![CDATA[Searches for possible exception records in stack of the thread specified by [<thread ID>] or in stack of the current thread]]>
                            </Description>
                        </AliasItem>
                    </FunctionAlias>
                    <FunctionAlias Name="walk_stdmap">
                        <AliasItem>
                            <Syntax>
                                <![CDATA[!walk_stdmap [<head ptr(_Myhead field of std::map)>]]]>
                            </Syntax>
                            <Description>
                                <![CDATA[Dumps all elements of the map (no interpretation, just dds) with address [<head ptr>]. The [<head ptr>] should be taken from _Myhead field of std::map]]>
                            </Description>
                        </AliasItem>
                    </FunctionAlias>
                </FunctionAliases>
            </ScriptComponent>
        </Components>
    </ExtensionPackage>

    <ExtensionPackage>
        <Name>NoexceptHelper</Name>
        <Version>1.0.0.1</Version>
        <Description>Shows correct stack if it is shown wrong due to exception from noexcept functions.</Description>
        <Components>
            <ScriptComponent Name="NoexceptHelper" Type="Engine" File="noexcept.js" FilePathKind="RepositoryRelative">
                <FunctionAliases>
                    <FunctionAlias Name="fix_stack">
                        <AliasItem>
                            <Syntax>
                                <![CDATA[!fix_stack]]>
                            </Syntax>
                            <Description>
                                <![CDATA[Try to show corrected stack of the current thread if it is shown wrong due to an exception from noexcept function.]]>
                            </Description>
                        </AliasItem>
                    </FunctionAlias>
                </FunctionAliases>
            </ScriptComponent>
        </Components>
    </ExtensionPackage>

    <ExtensionPackage>
        <Name>X64Helper</Name>
        <Version>1.0.0.1</Version>
        <Description>Try to show x32 stacks of all threads in x64 dump.</Description>
        <Components>
            <ScriptComponent Name="X64Helper" Type="Engine" File="x64.js" FilePathKind="RepositoryRelative">
                <FunctionAliases>
                    <FunctionAlias Name="x32stacks">
                        <AliasItem>
                            <Syntax>
                                <![CDATA[!x32stacks]]>
                            </Syntax>
                            <Description>
                                <![CDATA[Try to show x32 stacks of all threads in x64 dump.]]>
                            </Description>
                        </AliasItem>
                    </FunctionAlias>
                </FunctionAliases>
            </ScriptComponent>
        </Components>
    </ExtensionPackage>

    <ExtensionPackage>
        <Name>MemoryHelpers</Name>
        <Version>1.0.0.1</Version>
        <Description>Heap and memory helpers.</Description>
        <Components>
            <ScriptComponent Name="MemoryHelpers" Type="Engine" File="memory.js" FilePathKind="RepositoryRelative">
                <FunctionAliases>
                    <FunctionAlias Name="av_heap_alloc_stats">
                        <AliasItem>
                            <Syntax>
                                <![CDATA[!av_heap_alloc_stats 0x[<heap address>], 0x[<block size in hex>]]]>
                            </Syntax>
                            <Description>
                                <![CDATA[Collect stats about allocation stacks of block with size [<block size in hex>] in heap [<heap address>]. Note! This command requires AppVerifier for heap to be enabled]]>
                            </Description>
                        </AliasItem>
                    </FunctionAlias>
                    <FunctionAlias Name="heap_alloc_stats">
                        <AliasItem>
                            <Syntax>
                                <![CDATA[!heap_alloc_stats 0x[<heap address>]]]>
                            </Syntax>
                            <Description>
                                <![CDATA[Collect stats about data in the first 16 bytes of blocks in heap [<heap address>]]]>
                            </Description>
                        </AliasItem>
                    </FunctionAlias>
                </FunctionAliases>
            </ScriptComponent>
        </Components>
    </ExtensionPackage>
</ExtensionPackages>
```

`memory.js`:

```js
/*///////////////////////////////////////////////////////////////////////
MIT License

Copyright (c) 2021-2022 AO Kaspersky Lab. All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
/*////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////
// Memory utilities
//
// Note! Parameters should be passed with 0x or in "". Otherwise you got an error "Error: Unable to bind name ...".
//
// !av_heap_alloc_stats <heap address>, <block size in hex> - walk list of memory blocks of specified size in heap and collect stats about allocation stacks.
//
// !heap_alloc_stats <heap_address> - walk list of memory blocks in the heap and collect stats about the contents
//
/////////////////////////////////////////////////////////////////////////

"use strict";

// Utilities
function GetStringParameter(param)
{
    if (typeof param == "object")
    {
        return param.toString(16);
    }

    return "" + param.toString(16);
}

function PrintCommandOutput(output)
{
    for (var line of output)
        host.diagnostics.debugLog(line + "\n");
}

function* CreateCacheReader(filename)
{
    var reader = host.namespace.Debugger.Utility.FileSystem.CreateTextReader(filename, "Utf8");
    try
    {
        for (var line = reader.ReadLine(); line.length > 0; line = reader.ReadLine())
        {
            yield line;
        }
    }
    catch(err)
    {
        if (err.message != "Cannot read past end of file") {
            host.diagnostics.debugLog("Cache read error: " + err.message + "\n");
        }
        return "";
    }

    return "";
}

function GetDataForProcessing(heap)
{
    var heapAddress = GetStringParameter(heap);
    var heapCacheFilename = "heap_" + heapAddress + ".cache";

    // cache filename have to depends on dump filename
    try {
        if (host.namespace.Debugger.Sessions[0].Attributes.Target.Details.DumpFileName.length > 0) {
            heapCacheFilename = host.namespace.Debugger.Sessions[0].Attributes.Target.Details.DumpFileName + "_" + heapCacheFilename;
        }
    } catch (err) {
        host.diagnostics.debugLog("Dump name getting error: " + err.message + "\n");
    }

    if (host.namespace.Debugger.Utility.FileSystem.FileExists(heapCacheFilename)) {
        return CreateCacheReader(heapCacheFilename);
    }

    var output = host.namespace.Debugger.Utility.Control.ExecuteCommand("!heap -s -a -c -h " + heapAddress);
    var cacheFile = host.namespace.Debugger.Utility.FileSystem.CreateFile(heapCacheFilename, "CreateAlways");
    var writer = host.namespace.Debugger.Utility.FileSystem.CreateTextWriter(cacheFile, "Utf8");

    var errorCount = 0;
    var writeLineCount = 0;
    for (let line of output) {
        ++writeLineCount;
        try {
            if (line.length > 0) {
                writer.WriteLine(line);
            }
        } catch (err) {
            if (errorCount < 20) {
                host.diagnostics.debugLog("Cache write error at line " + writeLineCount.toString(10) + ": " + err.toString() + "\n");
            }
            ++errorCount;
        }
    }
    cacheFile.Close();
    host.diagnostics.debugLog("Total write errors: " + errorCount.toString(10) + "\n");
    return output;
}

function AddItem(stat, key)
{
    if (stat.has(key)) {
        stat.set(key, stat.get(key) + 1);
    } else {
        stat.set(key, 1);
    }
}

function __CollectAvHeapAllocationStats(heap, blockSize)
{
    var stat = new Map();
    var lineCount = 0;
    var output = GetDataForProcessing(heap);

    var regExpText = "^([0-9A-Fa-f]{8})\\sB\\sabcdaaa[0-9A-Fa-f]\\s[0-9A-Fa-f]{8}\\s" + ('0000000' + blockSize.toString(16)).slice(-8) + "\\s(.+)$";
    //host.diagnostics.debugLog("RegExp: " + regExpText + "\n");
    var lineRE = new RegExp(regExpText);

    var matched = 0;
    try
    {
        for (var line of output)
        {
            //host.diagnostics.debugLog("block " + line + "\n");
            ++lineCount;

            var parsed = line.match(lineRE);
            if (parsed) {
                ++matched;

                var address = host.parseInt64(parsed[1], 16);
                var stackPtr = host.parseInt64(host.memory.readMemoryValues(address + 0x20, 1, 4), 10);
                //host.diagnostics.debugLog("  " + address.toString(16) + " - " + stackPtr.toString(16) + "\n");
                AddItem(stat, stackPtr);
            }

        }
    }
    catch(err)
    {
        //host.diagnostics.debugLog("Error: " + err.toString() + "\n");
    }

    host.diagnostics.debugLog("Matched: 0x" + matched.toString(16) + " blocks\n");
    host.diagnostics.debugLog("-------------------------------------------------------------\n");

    // iterate map sorted by value
    stat[Symbol.iterator] = function* () {
        yield* [...this.entries()].sort((a, b) => b[1] - a[1]);
    }

    for (let [key, value] of stat) {
        host.diagnostics.debugLog("\n=== stack at 0x" + ('0000000' + key.toString(16)).slice(-8) + ' - ' + value.toString(10) + " blocks ===\n");

        var output = host.namespace.Debugger.Utility.Control.ExecuteCommand("dds " + (key + 0xC).toString(16) + " L20");
        PrintCommandOutput(output);
    }

    host.diagnostics.debugLog("\n");
    return lineCount;
}

function hex2ascii(str)
{
    var hex = str.toString();
    var res = '';
    for (var i = hex.length - 2; i >= 0; i -= 2) {
        var code = parseInt(hex.substr(i, 2), 16);
        if (code < 21) {
            res += ".";
        } else {
            res += String.fromCharCode(code);
        }
    }
    return res;
}

function PrintTopStats(stat)
{
    // iterate map sorted by value
    stat[Symbol.iterator] = function* () {
        yield* [...this.entries()].sort((a, b) => b[1] - a[1]);
    }

    var i = 0;
    for (let [key, value] of stat) {
        host.diagnostics.debugLog(key + " \"" + hex2ascii(key) + "\": " + value.toString(10) + "\n");
        if (++i > 10) {
            break;
        }
    }
}

function __CollectHeapAllocationStats(heap) {
    var stat_Dword1 = new Map();
    var stat_Dword2 = new Map();
    var stat_Dword3 = new Map();
    var stat_Dword4 = new Map();
    var stat_Qword1 = new Map();
    var stat_Qword2 = new Map();
    var lineCount = 0;
    var output = GetDataForProcessing(heap);

    var regExpText = "^[0-9A-Fa-f]{8,16}\\s[bB]\\s([0-9A-Fa-f]{8})\\s([0-9A-Fa-f]{8})\\s([0-9A-Fa-f]{8})\\s([0-9A-Fa-f]{8})\\s(.+)$";
    //host.diagnostics.debugLog("RegExp: " + regExpText + "\n");
    var lineRE = new RegExp(regExpText);

    var matched = 0;
    try {
        for (var line of output) {
            //host.diagnostics.debugLog("block " + line + "\n");
            ++lineCount;

            var parsed = line.match(lineRE);
            if (parsed) {
                ++matched;
                //host.diagnostics.debugLog("Parsed\n  " + parsed[1] + "\n  " + parsed[2] + "\n  " + parsed[3] + "\n  " + parsed[4] + "\n");

                AddItem(stat_Dword1, parsed[1]);
                AddItem(stat_Dword2, parsed[2]);
                AddItem(stat_Dword3, parsed[3]);
                AddItem(stat_Dword4, parsed[4]);
                AddItem(stat_Qword1, parsed[2] + parsed[1]);
                AddItem(stat_Qword2, parsed[4] + parsed[3]);
            }
        }
    }
    catch (err) {
        //host.diagnostics.debugLog("Error: " + err.toString() + "\n");
    }

    host.diagnostics.debugLog("Matched: 0x" + matched.toString(16) + " blocks\n");
    
    host.diagnostics.debugLog("\n--- Top by first dword ---\n");
    PrintTopStats(stat_Dword1);
    host.diagnostics.debugLog("\n--- Top by second dword ---\n");
    PrintTopStats(stat_Dword2);
    host.diagnostics.debugLog("\n--- Top by third dword ---\n");
    PrintTopStats(stat_Dword3);
    host.diagnostics.debugLog("\n--- Top by fourth dword ---\n");
    PrintTopStats(stat_Dword4);
    host.diagnostics.debugLog("\n--- Top by first qword ---\n");
    PrintTopStats(stat_Qword1);
    host.diagnostics.debugLog("\n--- Top by second qword ---\n");
    PrintTopStats(stat_Qword2);

    host.diagnostics.debugLog("\n");
    return lineCount;
}

// Register aliases
function initializeScript()
{
    return [new host.apiVersionSupport(1, 2),
        new host.functionAlias(__CollectAvHeapAllocationStats, "av_heap_alloc_stats"),
        new host.functionAlias(__CollectHeapAllocationStats, "heap_alloc_stats")];
}

```

`noexcept.js`:

```js
/*///////////////////////////////////////////////////////////////////////
MIT License

Copyright (c) 2020-2022 AO Kaspersky Lab. All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
/*////////////////////////////////////////////////////////////////////////

"use strict";

/////////////////////////////////////////////////////////////////////////
//
// !fix_stack - try to show corrected stack of the current thread if it is shown wrong due to an exception from noexcept function
//
/////////////////////////////////////////////////////////////////////////

// Try to print fixed stack of the current thread
function __FixStack()
{
    var mode = 0;
    var lineRE = /^([0-9A-Fa-f]{1,4})\s+([0-9A-Fa-f]+)\s+([0-9A-Fa-f]+)\s+([0-9A-Fa-f]+)\s+([0-9A-Fa-f]+)\s+([0-9A-Fa-f]+)\s+(.+)$/;
    var prevEBP = "";
    var warningFound = false;
    var linesMap = new Map();
    var output = host.namespace.Debugger.Utility.Control.ExecuteCommand("kb");
    for (var line of output)
    {
        if (mode == 0)
        {// search for keyword
            if (!warningFound && line.includes("Following frames may be wrong."))
            {
                warningFound = true;
                continue;
            }
            else if (line.includes("ntdll!ExecuteHandler2+"))
            {
                if (warningFound)
                {
                    mode = 2
                }
                else
                {
                    mode = 1
                }
            }
            else
            {
                host.diagnostics.debugLog(line + "\n");

                var parsed = line.match(lineRE);
                if (parsed)
                {
                    prevEBP = parsed[2];
                }
            }
        }
        else if (mode == 1)
        {// search for warning
            if (line.includes("Following frames may be wrong."))
            {
                warningFound = true;
                mode = 2;
            }
        }
        else
        {// fill map
            var parsed = line.match(lineRE);
            if (parsed)
            {
                // skip addresses without symbols
                if (parsed[7].startsWith("0x"))
                {
                    continue;
                }

                // skip some symbols
                if (!["ntdll!ExecuteHandler2+", "ntdll!ExecuteHandler+", "ntdll!KiUserExceptionDispatcher+", "KERNELBASE!RaiseException+"]
                    .every(str => !parsed[7].startsWith(str)))
                {
                    continue;
                }

                linesMap.set(parsed[2], line);
            }
        }
    }

    if (!warningFound || (prevEBP.length == 0))
    {
        host.diagnostics.debugLog("Error: nothing to fix\n");
        return 1;
    }

    var nextCaller = "";
    var nextAddress = "";
    var ebpRE = /^([0-9A-Fa-f]+)\s+([0-9A-Fa-f]+)/;
    var symRE = /^([0-9A-Fa-f]+)\s+([0-9A-Fa-f]+)\s*(.*)$/;
    for (; prevEBP != "00000000";)
    {
        if (nextCaller.length > 0)
        {
            host.diagnostics.debugLog("-- " + prevEBP + " " + nextAddress + " 00000000 00000000 00000000 " + nextCaller + "\n");
        }

        var output = host.namespace.Debugger.Utility.Control.ExecuteCommand("dds " + prevEBP + " L2");
        if (output.length < 2)
        {
            host.diagnostics.debugLog("Error: nothing to parse\n");
            break;
        }

        var parsedEbp = output[0].match(ebpRE);
        if (!parsedEbp)
        {
            host.diagnostics.debugLog("Error: cannot find next frame\n");
            break;
        }

        var newEbp = parsedEbp[2];
        var zero = true;
        for (let letter of newEbp) {
            if (letter != '0')
            {
                zero = false;
                break;
            }
        }
        if (zero)
        {// end of stack
            break;
        }

        prevEBP = newEbp;

        // search map for it
        if (linesMap.has(prevEBP))
        {
            var print = false;
            var it = linesMap.entries();
            for (let item of it)
            {
                if (print)
                {
                    host.diagnostics.debugLog(item[1] + "\n");
                }
                else if (item[0] == prevEBP)
                {
                    print = true;
                    host.diagnostics.debugLog(item[1] + "\n");
                }
            }
            break;
        }

        // get symbol
        var parsedSym = output[1].match(symRE);
        if (!parsedSym)
        {
            host.diagnostics.debugLog("Error: cannot find next symbol\n");
            break;
        }

        nextAddress = parsedSym[2];
        nextCaller = parsedSym[3];
    }

    return 0;
}

// Register aliases
function initializeScript()
{
    return [new host.apiVersionSupport(1, 2),
            new host.functionAlias(__FixStack, "fix_stack")];
}

```

`x64.js`:

```js
/*///////////////////////////////////////////////////////////////////////
MIT License

Copyright (c) 2020 AO Kaspersky Lab. All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
/*////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////
// x64 utilities
//
// Note! Parameters should be passed with 0x or in "". Otherwise you got an error "Error: Unable to bind name ...".
//
// !x32stacks <process> - dump x32 stacks of specified process
//
/////////////////////////////////////////////////////////////////////////

"use strict";
 
 function GetStringParameter(param)
{
    if (typeof param == "object")
    {
        return param.toString(16);
    }

    return "" + param;
}

// Display x32 stacks of threads of process
function __X32Stacks(proc)
{
    var procId = GetStringParameter(proc);
    
    host.diagnostics.debugLog("Dumping x32 stacks of process " + procId + "\n\n");
    
    var reThread = /^\s*THREAD\s+([0-9,a-f]+)\s+Cid.*/;
    
    var ctl = host.namespace.Debugger.Utility.Control;   
    ctl.ExecuteCommand(".process /p /r " + procId);
    var output = ctl.ExecuteCommand("!process " + procId + " 4");
    var threadCount = 0;
    for (var line of output)
    {
        //host.diagnostics.debugLog(line + "\n");
        var res = line.match(reThread);
        if (res != null)
        {
            host.diagnostics.debugLog("Thread " + res[1] + "\n");
            var output1 = ctl.ExecuteCommand(".thread /w " + res[1] + "; k");
            for (var line1 of output1)
            {
                host.diagnostics.debugLog(line1 + "\n");
            }
            host.diagnostics.debugLog("\n");
            ++threadCount;

            var output2 = ctl.ExecuteCommand("!wow64exts.sw");
            for (var line2 of output2)
            {
                if (line2.indexOf("Switched to Guest (WoW) mode") != -1)
                {
                    ctl.ExecuteCommand("!wow64exts.sw");
                    break;
                }
            }
        }
    }
    
    return threadCount;
}

// Register aliases
function initializeScript()
{
    return [new host.apiVersionSupport(1, 2),
            new host.functionAlias(__X32Stacks, "x32stacks")];
}

```