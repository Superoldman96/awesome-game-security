Project Path: arc_gmh5225_emulator_gyywdyq8

Source Tree:

```txt
arc_gmh5225_emulator_gyywdyq8
├── CMakeLists.txt
├── CMakePresets.json
├── LICENSE
├── README.md
├── cmake
│   ├── compiler-env.cmake
│   └── utils.cmake
├── deps
│   ├── CMakeLists.txt
│   ├── mini-gdbstub
│   ├── mini-gdbstub.cmake
│   ├── phnt
│   ├── reflect
│   └── unicorn
├── docs
│   └── images
│       ├── preview.jpg
│       └── yt.jpg
└── src
    ├── CMakeLists.txt
    ├── analyzer
    │   ├── CMakeLists.txt
    │   ├── main.cpp
    │   ├── object_watching.hpp
    │   ├── reflect_extension.hpp
    │   ├── reflect_type_info.hpp
    │   ├── resource.rc
    │   ├── resources
    │   │   └── icon.ico
    │   └── std_include.hpp
    ├── bad-sample
    │   ├── CMakeLists.txt
    │   └── bad.cpp
    ├── common
    │   ├── CMakeLists.txt
    │   ├── empty.cpp
    │   └── utils
    │       ├── buffer_accessor.hpp
    │       ├── concurrency.hpp
    │       ├── finally.hpp
    │       ├── io.cpp
    │       ├── io.hpp
    │       ├── nt_handle.hpp
    │       └── timer.hpp
    ├── emulator
    │   ├── CMakeLists.txt
    │   ├── address_utils.hpp
    │   ├── emulator.hpp
    │   ├── memory_manager.cpp
    │   ├── memory_manager.hpp
    │   ├── memory_permission.hpp
    │   ├── memory_region.hpp
    │   ├── scoped_hook.hpp
    │   ├── serialization.hpp
    │   ├── typed_emulator.hpp
    │   ├── x64_emulator.hpp
    │   └── x64_register.hpp
    ├── fuzzer
    │   ├── CMakeLists.txt
    │   ├── main.cpp
    │   ├── resource.rc
    │   ├── resources
    │   │   └── icon.ico
    │   └── std_include.hpp
    ├── fuzzing-engine
    │   ├── CMakeLists.txt
    │   ├── fuzzer.cpp
    │   ├── fuzzer.hpp
    │   ├── input_generator.cpp
    │   ├── input_generator.hpp
    │   ├── random_generator.cpp
    │   └── random_generator.hpp
    ├── unicorn-emulator
    │   ├── CMakeLists.txt
    │   ├── function_wrapper.hpp
    │   ├── object.hpp
    │   ├── unicorn.hpp
    │   ├── unicorn_hook.hpp
    │   ├── unicorn_memory_regions.hpp
    │   ├── unicorn_x64_emulator.cpp
    │   └── unicorn_x64_emulator.hpp
    └── windows-emulator
        ├── CMakeLists.txt
        ├── context_frame.cpp
        ├── context_frame.hpp
        ├── debugging
        │   ├── gdb_stub.cpp
        │   ├── gdb_stub.hpp
        │   └── x64_gdb_stub_handler.hpp
        ├── emulator_utils.hpp
        ├── handles.hpp
        ├── logger.cpp
        ├── logger.hpp
        ├── memory_utils.hpp
        ├── module
        │   ├── mapped_module.hpp
        │   ├── module_manager.cpp
        │   ├── module_manager.hpp
        │   ├── module_mapping.cpp
        │   └── module_mapping.hpp
        ├── process_context.hpp
        ├── std_include.hpp
        ├── syscalls.cpp
        ├── syscalls.hpp
        ├── windows_emulator.cpp
        └── windows_emulator.hpp

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.26.4)

##########################################

option(MOMO_ENABLE_SANITIZER "Enable sanitizer" OFF)

##########################################

set(CMAKE_DISABLE_IN_SOURCE_BUILD ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

set(CMAKE_OSX_DEPLOYMENT_TARGET 11.0)
set(CMAKE_OSX_ARCHITECTURES "arm64;x86_64")

##########################################

project(emulator LANGUAGES C CXX)

##########################################

set_property(GLOBAL PROPERTY USE_FOLDERS ON)

##########################################

include(cmake/utils.cmake)
include(cmake/compiler-env.cmake)

##########################################

momo_set_new_artifact_directory()

##########################################

momo_add_subdirectory_and_get_targets("deps" EXTERNAL_TARGETS)
momo_add_subdirectory_and_get_targets("src" OWN_TARGETS)

##########################################

momo_targets_set_folder("External Dependencies" ${EXTERNAL_TARGETS})

momo_targets_exclude_from_all(${EXTERNAL_TARGETS})
momo_targets_disable_warnings(${EXTERNAL_TARGETS})

momo_targets_expose_includes(${OWN_TARGETS})
momo_targets_set_warnings_as_errors(${OWN_TARGETS})

```

`CMakePresets.json`:

```json
{
    "version": 6,
    "cmakeMinimumRequired": {
        "major": 3,
        "minor": 26,
        "patch": 4
    },
    "configurePresets": [
        {
            "name": "build",
            "hidden": true,
            "binaryDir": "${sourceDir}/build/${presetName}"
        },
        {
            "name": "ninja",
            "hidden": true,
            "generator": "Ninja"
        },
        {
            "name": "release",
            "inherits": [
                "ninja",
                "build"
            ],
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Release"
            }
        },
        {
            "name": "debug",
            "inherits": [
                "ninja",
                "build"
            ],
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Debug"
            }
        },
        {
            "name": "vs2022",
            "generator": "Visual Studio 17 2022",
            "inherits": "build"
        }
    ],
    "buildPresets": [
        {
            "name": "release",
            "configurePreset": "release"
        },
        {
            "name": "debug",
            "configurePreset": "debug"
        }
    ],
    "workflowPresets": [
        {
            "name": "release",
            "steps": [
                {
                    "type": "configure",
                    "name": "release"
                },
                {
                    "type": "build",
                    "name": "release"
                }
            ]
        },
        {
            "name": "debug",
            "steps": [
                {
                    "type": "configure",
                    "name": "debug"
                },
                {
                    "type": "build",
                    "name": "debug"
                }
            ]
        }
    ]
}
```

`LICENSE`:

```
Creative Commons Legal Code

Attribution-NonCommercial 3.0 Unported

    CREATIVE COMMONS CORPORATION IS NOT A LAW FIRM AND DOES NOT PROVIDE
    LEGAL SERVICES. DISTRIBUTION OF THIS LICENSE DOES NOT CREATE AN
    ATTORNEY-CLIENT RELATIONSHIP. CREATIVE COMMONS PROVIDES THIS
    INFORMATION ON AN "AS-IS" BASIS. CREATIVE COMMONS MAKES NO WARRANTIES
    REGARDING THE INFORMATION PROVIDED, AND DISCLAIMS LIABILITY FOR
    DAMAGES RESULTING FROM ITS USE.

License

THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE
COMMONS PUBLIC LICENSE ("CCPL" OR "LICENSE"). THE WORK IS PROTECTED BY
COPYRIGHT AND/OR OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS
AUTHORIZED UNDER THIS LICENSE OR COPYRIGHT LAW IS PROHIBITED.

BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE
TO BE BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY
BE CONSIDERED TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS
CONTAINED HERE IN CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND
CONDITIONS.

1. Definitions

 a. "Adaptation" means a work based upon the Work, or upon the Work and
    other pre-existing works, such as a translation, adaptation,
    derivative work, arrangement of music or other alterations of a
    literary or artistic work, or phonogram or performance and includes
    cinematographic adaptations or any other form in which the Work may be
    recast, transformed, or adapted including in any form recognizably
    derived from the original, except that a work that constitutes a
    Collection will not be considered an Adaptation for the purpose of
    this License. For the avoidance of doubt, where the Work is a musical
    work, performance or phonogram, the synchronization of the Work in
    timed-relation with a moving image ("synching") will be considered an
    Adaptation for the purpose of this License.
 b. "Collection" means a collection of literary or artistic works, such as
    encyclopedias and anthologies, or performances, phonograms or
    broadcasts, or other works or subject matter other than works listed
    in Section 1(f) below, which, by reason of the selection and
    arrangement of their contents, constitute intellectual creations, in
    which the Work is included in its entirety in unmodified form along
    with one or more other contributions, each constituting separate and
    independent works in themselves, which together are assembled into a
    collective whole. A work that constitutes a Collection will not be
    considered an Adaptation (as defined above) for the purposes of this
    License.
 c. "Distribute" means to make available to the public the original and
    copies of the Work or Adaptation, as appropriate, through sale or
    other transfer of ownership.
 d. "Licensor" means the individual, individuals, entity or entities that
    offer(s) the Work under the terms of this License.
 e. "Original Author" means, in the case of a literary or artistic work,
    the individual, individuals, entity or entities who created the Work
    or if no individual or entity can be identified, the publisher; and in
    addition (i) in the case of a performance the actors, singers,
    musicians, dancers, and other persons who act, sing, deliver, declaim,
    play in, interpret or otherwise perform literary or artistic works or
    expressions of folklore; (ii) in the case of a phonogram the producer
    being the person or legal entity who first fixes the sounds of a
    performance or other sounds; and, (iii) in the case of broadcasts, the
    organization that transmits the broadcast.
 f. "Work" means the literary and/or artistic work offered under the terms
    of this License including without limitation any production in the
    literary, scientific and artistic domain, whatever may be the mode or
    form of its expression including digital form, such as a book,
    pamphlet and other writing; a lecture, address, sermon or other work
    of the same nature; a dramatic or dramatico-musical work; a
    choreographic work or entertainment in dumb show; a musical
    composition with or without words; a cinematographic work to which are
    assimilated works expressed by a process analogous to cinematography;
    a work of drawing, painting, architecture, sculpture, engraving or
    lithography; a photographic work to which are assimilated works
    expressed by a process analogous to photography; a work of applied
    art; an illustration, map, plan, sketch or three-dimensional work
    relative to geography, topography, architecture or science; a
    performance; a broadcast; a phonogram; a compilation of data to the
    extent it is protected as a copyrightable work; or a work performed by
    a variety or circus performer to the extent it is not otherwise
    considered a literary or artistic work.
 g. "You" means an individual or entity exercising rights under this
    License who has not previously violated the terms of this License with
    respect to the Work, or who has received express permission from the
    Licensor to exercise rights under this License despite a previous
    violation.
 h. "Publicly Perform" means to perform public recitations of the Work and
    to communicate to the public those public recitations, by any means or
    process, including by wire or wireless means or public digital
    performances; to make available to the public Works in such a way that
    members of the public may access these Works from a place and at a
    place individually chosen by them; to perform the Work to the public
    by any means or process and the communication to the public of the
    performances of the Work, including by public digital performance; to
    broadcast and rebroadcast the Work by any means including signs,
    sounds or images.
 i. "Reproduce" means to make copies of the Work by any means including
    without limitation by sound or visual recordings and the right of
    fixation and reproducing fixations of the Work, including storage of a
    protected performance or phonogram in digital form or other electronic
    medium.

2. Fair Dealing Rights. Nothing in this License is intended to reduce,
limit, or restrict any uses free from copyright or rights arising from
limitations or exceptions that are provided for in connection with the
copyright protection under copyright law or other applicable laws.

3. License Grant. Subject to the terms and conditions of this License,
Licensor hereby grants You a worldwide, royalty-free, non-exclusive,
perpetual (for the duration of the applicable copyright) license to
exercise the rights in the Work as stated below:

 a. to Reproduce the Work, to incorporate the Work into one or more
    Collections, and to Reproduce the Work as incorporated in the
    Collections;
 b. to create and Reproduce Adaptations provided that any such Adaptation,
    including any translation in any medium, takes reasonable steps to
    clearly label, demarcate or otherwise identify that changes were made
    to the original Work. For example, a translation could be marked "The
    original work was translated from English to Spanish," or a
    modification could indicate "The original work has been modified.";
 c. to Distribute and Publicly Perform the Work including as incorporated
    in Collections; and,
 d. to Distribute and Publicly Perform Adaptations.

The above rights may be exercised in all media and formats whether now
known or hereafter devised. The above rights include the right to make
such modifications as are technically necessary to exercise the rights in
other media and formats. Subject to Section 8(f), all rights not expressly
granted by Licensor are hereby reserved, including but not limited to the
rights set forth in Section 4(d).

4. Restrictions. The license granted in Section 3 above is expressly made
subject to and limited by the following restrictions:

 a. You may Distribute or Publicly Perform the Work only under the terms
    of this License. You must include a copy of, or the Uniform Resource
    Identifier (URI) for, this License with every copy of the Work You
    Distribute or Publicly Perform. You may not offer or impose any terms
    on the Work that restrict the terms of this License or the ability of
    the recipient of the Work to exercise the rights granted to that
    recipient under the terms of the License. You may not sublicense the
    Work. You must keep intact all notices that refer to this License and
    to the disclaimer of warranties with every copy of the Work You
    Distribute or Publicly Perform. When You Distribute or Publicly
    Perform the Work, You may not impose any effective technological
    measures on the Work that restrict the ability of a recipient of the
    Work from You to exercise the rights granted to that recipient under
    the terms of the License. This Section 4(a) applies to the Work as
    incorporated in a Collection, but this does not require the Collection
    apart from the Work itself to be made subject to the terms of this
    License. If You create a Collection, upon notice from any Licensor You
    must, to the extent practicable, remove from the Collection any credit
    as required by Section 4(c), as requested. If You create an
    Adaptation, upon notice from any Licensor You must, to the extent
    practicable, remove from the Adaptation any credit as required by
    Section 4(c), as requested.
 b. You may not exercise any of the rights granted to You in Section 3
    above in any manner that is primarily intended for or directed toward
    commercial advantage or private monetary compensation. The exchange of
    the Work for other copyrighted works by means of digital file-sharing
    or otherwise shall not be considered to be intended for or directed
    toward commercial advantage or private monetary compensation, provided
    there is no payment of any monetary compensation in connection with
    the exchange of copyrighted works.
 c. If You Distribute, or Publicly Perform the Work or any Adaptations or
    Collections, You must, unless a request has been made pursuant to
    Section 4(a), keep intact all copyright notices for the Work and
    provide, reasonable to the medium or means You are utilizing: (i) the
    name of the Original Author (or pseudonym, if applicable) if supplied,
    and/or if the Original Author and/or Licensor designate another party
    or parties (e.g., a sponsor institute, publishing entity, journal) for
    attribution ("Attribution Parties") in Licensor's copyright notice,
    terms of service or by other reasonable means, the name of such party
    or parties; (ii) the title of the Work if supplied; (iii) to the
    extent reasonably practicable, the URI, if any, that Licensor
    specifies to be associated with the Work, unless such URI does not
    refer to the copyright notice or licensing information for the Work;
    and, (iv) consistent with Section 3(b), in the case of an Adaptation,
    a credit identifying the use of the Work in the Adaptation (e.g.,
    "French translation of the Work by Original Author," or "Screenplay
    based on original Work by Original Author"). The credit required by
    this Section 4(c) may be implemented in any reasonable manner;
    provided, however, that in the case of a Adaptation or Collection, at
    a minimum such credit will appear, if a credit for all contributing
    authors of the Adaptation or Collection appears, then as part of these
    credits and in a manner at least as prominent as the credits for the
    other contributing authors. For the avoidance of doubt, You may only
    use the credit required by this Section for the purpose of attribution
    in the manner set out above and, by exercising Your rights under this
    License, You may not implicitly or explicitly assert or imply any
    connection with, sponsorship or endorsement by the Original Author,
    Licensor and/or Attribution Parties, as appropriate, of You or Your
    use of the Work, without the separate, express prior written
    permission of the Original Author, Licensor and/or Attribution
    Parties.
 d. For the avoidance of doubt:

     i. Non-waivable Compulsory License Schemes. In those jurisdictions in
        which the right to collect royalties through any statutory or
        compulsory licensing scheme cannot be waived, the Licensor
        reserves the exclusive right to collect such royalties for any
        exercise by You of the rights granted under this License;
    ii. Waivable Compulsory License Schemes. In those jurisdictions in
        which the right to collect royalties through any statutory or
        compulsory licensing scheme can be waived, the Licensor reserves
        the exclusive right to collect such royalties for any exercise by
        You of the rights granted under this License if Your exercise of
        such rights is for a purpose or use which is otherwise than
        noncommercial as permitted under Section 4(b) and otherwise waives
        the right to collect royalties through any statutory or compulsory
        licensing scheme; and,
   iii. Voluntary License Schemes. The Licensor reserves the right to
        collect royalties, whether individually or, in the event that the
        Licensor is a member of a collecting society that administers
        voluntary licensing schemes, via that society, from any exercise
        by You of the rights granted under this License that is for a
        purpose or use which is otherwise than noncommercial as permitted
        under Section 4(c).
 e. Except as otherwise agreed in writing by the Licensor or as may be
    otherwise permitted by applicable law, if You Reproduce, Distribute or
    Publicly Perform the Work either by itself or as part of any
    Adaptations or Collections, You must not distort, mutilate, modify or
    take other derogatory action in relation to the Work which would be
    prejudicial to the Original Author's honor or reputation. Licensor
    agrees that in those jurisdictions (e.g. Japan), in which any exercise
    of the right granted in Section 3(b) of this License (the right to
    make Adaptations) would be deemed to be a distortion, mutilation,
    modification or other derogatory action prejudicial to the Original
    Author's honor and reputation, the Licensor will waive or not assert,
    as appropriate, this Section, to the fullest extent permitted by the
    applicable national law, to enable You to reasonably exercise Your
    right under Section 3(b) of this License (right to make Adaptations)
    but not otherwise.

5. Representations, Warranties and Disclaimer

UNLESS OTHERWISE MUTUALLY AGREED TO BY THE PARTIES IN WRITING, LICENSOR
OFFERS THE WORK AS-IS AND MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY
KIND CONCERNING THE WORK, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE,
INCLUDING, WITHOUT LIMITATION, WARRANTIES OF TITLE, MERCHANTIBILITY,
FITNESS FOR A PARTICULAR PURPOSE, NONINFRINGEMENT, OR THE ABSENCE OF
LATENT OR OTHER DEFECTS, ACCURACY, OR THE PRESENCE OF ABSENCE OF ERRORS,
WHETHER OR NOT DISCOVERABLE. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION
OF IMPLIED WARRANTIES, SO SUCH EXCLUSION MAY NOT APPLY TO YOU.

6. Limitation on Liability. EXCEPT TO THE EXTENT REQUIRED BY APPLICABLE
LAW, IN NO EVENT WILL LICENSOR BE LIABLE TO YOU ON ANY LEGAL THEORY FOR
ANY SPECIAL, INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES
ARISING OUT OF THIS LICENSE OR THE USE OF THE WORK, EVEN IF LICENSOR HAS
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

7. Termination

 a. This License and the rights granted hereunder will terminate
    automatically upon any breach by You of the terms of this License.
    Individuals or entities who have received Adaptations or Collections
    from You under this License, however, will not have their licenses
    terminated provided such individuals or entities remain in full
    compliance with those licenses. Sections 1, 2, 5, 6, 7, and 8 will
    survive any termination of this License.
 b. Subject to the above terms and conditions, the license granted here is
    perpetual (for the duration of the applicable copyright in the Work).
    Notwithstanding the above, Licensor reserves the right to release the
    Work under different license terms or to stop distributing the Work at
    any time; provided, however that any such election will not serve to
    withdraw this License (or any other license that has been, or is
    required to be, granted under the terms of this License), and this
    License will continue in full force and effect unless terminated as
    stated above.

8. Miscellaneous

 a. Each time You Distribute or Publicly Perform the Work or a Collection,
    the Licensor offers to the recipient a license to the Work on the same
    terms and conditions as the license granted to You under this License.
 b. Each time You Distribute or Publicly Perform an Adaptation, Licensor
    offers to the recipient a license to the original Work on the same
    terms and conditions as the license granted to You under this License.
 c. If any provision of this License is invalid or unenforceable under
    applicable law, it shall not affect the validity or enforceability of
    the remainder of the terms of this License, and without further action
    by the parties to this agreement, such provision shall be reformed to
    the minimum extent necessary to make such provision valid and
    enforceable.
 d. No term or provision of this License shall be deemed waived and no
    breach consented to unless such waiver or consent shall be in writing
    and signed by the party to be charged with such waiver or consent.
 e. This License constitutes the entire agreement between the parties with
    respect to the Work licensed here. There are no understandings,
    agreements or representations with respect to the Work not specified
    here. Licensor shall not be bound by any additional provisions that
    may appear in any communication from You. This License may not be
    modified without the mutual written agreement of the Licensor and You.
 f. The rights granted under, and the subject matter referenced, in this
    License were drafted utilizing the terminology of the Berne Convention
    for the Protection of Literary and Artistic Works (as amended on
    September 28, 1979), the Rome Convention of 1961, the WIPO Copyright
    Treaty of 1996, the WIPO Performances and Phonograms Treaty of 1996
    and the Universal Copyright Convention (as revised on July 24, 1971).
    These rights and subject matter take effect in the relevant
    jurisdiction in which the License terms are sought to be enforced
    according to the corresponding provisions of the implementation of
    those treaty provisions in the applicable national law. If the
    standard suite of rights granted under applicable copyright law
    includes additional rights not granted under this License, such
    additional rights are deemed to be included in the License; this
    License is not intended to restrict the license of any rights under
    applicable law.


Creative Commons Notice

    Creative Commons is not a party to this License, and makes no warranty
    whatsoever in connection with the Work. Creative Commons will not be
    liable to You or any party on any legal theory for any damages
    whatsoever, including without limitation any general, special,
    incidental or consequential damages arising in connection to this
    license. Notwithstanding the foregoing two (2) sentences, if Creative
    Commons has expressly identified itself as the Licensor hereunder, it
    shall have all rights and obligations of Licensor.

    Except for the limited purpose of indicating to the public that the
    Work is licensed under the CCPL, Creative Commons does not authorize
    the use by either party of the trademark "Creative Commons" or any
    related trademark or logo of Creative Commons without the prior
    written consent of Creative Commons. Any permitted use will be in
    compliance with Creative Commons' then-current trademark usage
    guidelines, as may be published on its website or otherwise made
    available upon request from time to time. For the avoidance of doubt,
    this trademark restriction does not form part of the License.

    Creative Commons may be contacted at https://creativecommons.org/.
```

`README.md`:

```md
<h1 align="center">
	Windows User Space Emulator
	<br>
	<a href="https://github.com/momo5502/emulator#License-1-ov-file"><img src="https://img.shields.io/badge/license-CC%20BY--NC%203.0-00B0F8"/></a>
	<a href="https://github.com/momo5502/emulator/actions"><img src="https://img.shields.io/github/actions/workflow/status/momo5502/emulator/build.yml?branch=main&label=build&logo=github"/></a>
	<a href="https://github.com/momo5502/emulator/issues"><img src="https://img.shields.io/github/issues/momo5502/emulator?color=F8B000"/></a>
	<img src="https://img.shields.io/github/commit-activity/m/momo5502/emulator?color=FF3131"/>
</h1>

A high-performance Windows process emulator that operates at the syscall level, providing full control over process execution through comprehensive hooking capabilities.

Built in C++ and powered by the Unicorn Engine.

## Key Features

* __Syscall-Level Emulation__: Instead of reimplementing Windows APIs, the emulator operates at the syscall level, allowing it to leverage existing system DLLs
* __Advanced Memory Management__: Supports Windows-specific memory types including reserved, committed, built on top of Unicorn's memory management
* __Complete PE Loading__: Handles executable and DLL loading with proper memory mapping, relocations, and TLS
* __Exception Handling__: Implements Windows structured exception handling (SEH) with proper exception dispatcher and unwinding support
* __Threading Support__: Provides a scheduled (round-robin) threading model
* __State Management__: Supports both full state serialization and fast in-memory snapshots
* __Debugging Interface__: Implements GDB serial protocol for integration with common debugging tools (IDA Pro, GDB, LLDB, VS Code, ...)

Perfect for security research, malware analysis, and DRM research where fine-grained control over process execution is required.

## Code Disclaimer

The project is still in a very early, prototypy state. The code still needs a lot of cleanup and many features and syscalls need to be implemented. However, constant progress is being made :)

## Preview

![Preview](./docs/images/preview.jpg)

## YouTube Overview

[![YouTube video](./docs/images/yt.jpg)](https://www.youtube.com/watch?v=Y6NXwI7x7Og)

Click <a href="https://docs.google.com/presentation/d/1pha4tFfDMpVzJ_ehJJ21SA_HAWkufQBVYQvh1IFhVls/edit">here</a> for the slides.

## License

Commercial use of this project is not permitted without prior authorization.  
Please contact me for inquiries about obtaining a commercial license.

```

`cmake/compiler-env.cmake`:

```cmake
include_guard()

##########################################
# System identification

set(OSX OFF)
set(LINUX OFF)
set(WIN OFF)

if(CMAKE_SYSTEM_NAME MATCHES "Linux")
    set(LINUX ON)
elseif(CMAKE_SYSTEM_NAME MATCHES "Darwin")
    set(OSX ON)
elseif(CMAKE_SYSTEM_NAME MATCHES "Windows")
    set(WIN ON)
endif()

##########################################

cmake_policy(SET CMP0069 NEW) 
set(CMAKE_POLICY_DEFAULT_CMP0069 NEW)

set(CMAKE_POSITION_INDEPENDENT_CODE ON)
set(CMAKE_INTERPROCEDURAL_OPTIMIZATION ON)

##########################################

if(UNIX)
  momo_add_c_and_cxx_compile_options(-fvisibility=hidden)
endif()

##########################################

if(LINUX)
  add_link_options(
    -Wl,--no-undefined
    -Wl,--gc-sections
    -Wl,-z,now
    -Wl,-z,noexecstack
    -static-libstdc++
  )

  momo_add_c_and_cxx_compile_options(
    -ffunction-sections
    -fdata-sections
    -fstack-protector-strong
    -fdiagnostics-color=always
  )

  add_compile_definitions(
    _REENTRANT
    _THREAD_SAFE
  )

  if(NOT MOMO_ENABLE_SANITIZER)
    add_compile_definitions(
      _FORTIFY_SOURCE=2
    )
  endif()

  set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -pie")
endif()

##########################################

if(MSVC)
  string(REPLACE "/EHsc" "" CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}")
  string(REPLACE "/EHs" "" CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}")

  momo_add_c_and_cxx_compile_options(
    /sdl
    /GS
    /Gy
    /EHa
    #/guard:cf
  )

  momo_add_compile_options(CXX
    /Zc:__cplusplus
  )

  add_link_options(
    /INCREMENTAL:NO
  )

  momo_add_c_and_cxx_release_compile_options(
    /Ob2
    #/GL
  )

  momo_add_release_link_options(
    #/LTCG
  )
endif()

##########################################

if(MOMO_ENABLE_SANITIZER)
momo_add_c_and_cxx_compile_options(
  -fsanitize=address
)
endif()

##########################################

set(CMAKE_MSVC_RUNTIME_LIBRARY MultiThreaded$<$<CONFIG:Debug>:Debug>DLL)

##########################################

if(MSVC)
  add_link_options(
    $<$<NOT:$<STREQUAL:${CMAKE_MSVC_RUNTIME_LIBRARY},MultiThreaded>>:/NODEFAULTLIB:libcmt.lib>
    $<$<NOT:$<STREQUAL:${CMAKE_MSVC_RUNTIME_LIBRARY},MultiThreadedDLL>>:/NODEFAULTLIB:msvcrt.lib>
    $<$<NOT:$<STREQUAL:${CMAKE_MSVC_RUNTIME_LIBRARY},MultiThreadedDebug>>:/NODEFAULTLIB:libcmtd.lib>
    $<$<NOT:$<STREQUAL:${CMAKE_MSVC_RUNTIME_LIBRARY},MultiThreadedDebugDLL>>:/NODEFAULTLIB:msvcrtd.lib>
  )
endif()

##########################################

set(OPT_DEBUG "-O0 -g")
set(OPT_RELEASE "-O3 -g")

if(MSVC)
  set(OPT_DEBUG "/Od /Ob0 /Zi")
  set(OPT_RELEASE "/O2 /Ob2 /Zi")

  add_link_options(/DEBUG)
endif()

set(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} ${OPT_DEBUG}")
set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} ${OPT_DEBUG}")

set(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} ${OPT_RELEASE}")
set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} ${OPT_RELEASE}")

##########################################

if(CMAKE_GENERATOR MATCHES "Visual Studio")
  momo_add_c_and_cxx_compile_options(/MP)
endif()

```

`cmake/utils.cmake`:

```cmake
include_guard()

##########################################

function(momo_silence_deprecation_warnings)
    set(CMAKE_WARN_DEPRECATED_OLD ${CMAKE_WARN_DEPRECATED} PARENT_SCOPE)
    set(CMAKE_WARN_DEPRECATED OFF CACHE BOOL "" FORCE)
endfunction()

##########################################

function(momo_restore_deprecation_warnings)
    set(CMAKE_WARN_DEPRECATED ${CMAKE_WARN_DEPRECATED_OLD} CACHE BOOL "" FORCE)
endfunction()

##########################################

function(momo_target_exclude_from_all target)
  set_target_properties(${target} PROPERTIES EXCLUDE_FROM_ALL 1)
  #set_target_properties(${target} PROPERTIES EXCLUDE_FROM_DEFAULT_BUILD 1)
endfunction()

##########################################

function(momo_targets_exclude_from_all)
  foreach(target ${ARGV})
    momo_target_exclude_from_all(${target})
  endforeach()
endfunction()

##########################################

function(momo_target_set_folder folder target)
  #get_target_property(CURRENT_FOLDER ${target} FOLDER)
  #if(NOT CURRENT_FOLDER)
    set_target_properties(${target} PROPERTIES FOLDER "${folder}")
  #endif()
endfunction()

##########################################

function(momo_targets_set_folder folder)
  foreach(target ${ARGN})
    momo_target_set_folder(${folder} ${target})
  endforeach()
endfunction()

##########################################

function(momo_target_disable_compile_commands target)
  set_target_properties(${target} PROPERTIES EXPORT_COMPILE_COMMANDS OFF)
endfunction()

##########################################

function(momo_targets_disable_compile_commands)
  foreach(target ${ARGV})
    momo_target_disable_compile_commands(${target})
  endforeach()
endfunction()

##########################################

function(momo_target_expose_includes target)
  get_target_property(target_type ${target} TYPE)
  if("${target_type}" STREQUAL "UTILITY")
    return()
  endif()

  get_target_property(TARGET_SOURCE_DIR ${target} SOURCE_DIR)
  target_include_directories(${target} INTERFACE ${TARGET_SOURCE_DIR}/..)
endfunction()

##########################################

function(momo_targets_expose_includes)
  foreach(target ${ARGV})
  momo_target_expose_includes(${target})
  endforeach()
endfunction()

##########################################

function(momo_target_compile_options language target mode)
  foreach(compile_option ${ARGN})
    target_compile_options(${target} ${mode}
      $<$<COMPILE_LANGUAGE:${language}>:${compile_option}>
    )
  endforeach()
endfunction()

##########################################

function(momo_target_c_and_cxx_compile_options)
  momo_target_compile_options(C ${ARGV})
  momo_target_compile_options(CXX ${ARGV})
endfunction()

##########################################

macro(momo_target_remove_compile_option target option)
    get_target_property(target_flags ${target} COMPILE_OPTIONS)
    if(target_flags)
        list(REMOVE_ITEM target_flags ${option})
        set_target_properties(${target} PROPERTIES COMPILE_OPTIONS "${target_flags}")
    endif()

    get_target_property(target_interface_flags ${target} INTERFACE_COMPILE_OPTIONS)
    if(target_interface_flags)
        list(REMOVE_ITEM target_interface_flags ${option})
        set_target_properties(${target} PROPERTIES INTERFACE_COMPILE_OPTIONS "${target_interface_flags}")
    endif()
endmacro()

##########################################

macro(momo_target_remove_compile_options target)
  foreach(option ${ARGV})
    momo_target_remove_compile_option(${target} ${option})
  endforeach()
endmacro()

##########################################

function(momo_add_compile_options language)
  foreach(option ${ARGN})
    add_compile_options(
      $<$<COMPILE_LANGUAGE:${language}>:${option}>
    )
  endforeach()
endfunction()

##########################################

function(momo_add_release_compile_options language)
  foreach(option ${ARGN})
    add_compile_options(
      $<$<COMPILE_LANGUAGE:${language}>:$<$<CONFIG:RELEASE>:${option}>>
      $<$<COMPILE_LANGUAGE:${language}>:$<$<CONFIG:RELWITHDEBINFO>:${option}>>
    )
  endforeach()
endfunction()

##########################################

function(momo_add_release_link_options)
  foreach(option ${ARGN})
    add_link_options(
      $<$<CONFIG:RELEASE>:${option}>
      $<$<CONFIG:RELWITHDEBINFO>:${option}>
    )
  endforeach()
endfunction()

##########################################

function(momo_add_c_and_cxx_compile_options)
  momo_add_compile_options(C ${ARGV})
  momo_add_compile_options(CXX ${ARGV})
endfunction()

##########################################

function(momo_add_c_and_cxx_release_compile_options)
  momo_add_release_compile_options(C ${ARGV})
  momo_add_release_compile_options(CXX ${ARGV})
endfunction()

##########################################

function(momo_target_disable_warnings target)
  get_target_property(target_type ${target} TYPE)
  if(("${target_type}" STREQUAL "INTERFACE_LIBRARY") OR ("${target_type}" STREQUAL "UTILITY"))
    return()
  endif()

  momo_target_remove_compile_options(${target} /W3 -W3 /W4 -W4)

  if(MSVC)
  set(compile_options
    /W0
    /D_CRT_SECURE_NO_WARNINGS=1
  )
  endif()

  momo_target_c_and_cxx_compile_options(${target} PRIVATE ${compile_options})

  set_target_properties(${target} PROPERTIES MOMO_WARNINGS_DISABLE ON)
endfunction()

##########################################

function(momo_targets_disable_warnings)
  foreach(target ${ARGV})
    momo_target_disable_warnings(${target})
  endforeach()
endfunction()

##########################################

function(momo_target_set_warnings_as_errors target)
  get_target_property(target_type ${target} TYPE)
  if(("${target_type}" STREQUAL "INTERFACE_LIBRARY") OR ("${target_type}" STREQUAL "UTILITY"))
    return()
  endif()

  get_target_property(warnings_disabled ${target} MOMO_WARNINGS_DISABLE)
  if(warnings_disabled)
    return()
  endif()

  set(compile_options)

  if(MSVC)
    set(compile_options /W4 /WX)
  endif()

  target_compile_options(${target} PRIVATE
    $<$<COMPILE_LANGUAGE:C>:$<$<CONFIG:RELEASE>:${compile_options}>>
    $<$<COMPILE_LANGUAGE:CXX>:$<$<CONFIG:RELEASE>:${compile_options}>>
    $<$<COMPILE_LANGUAGE:C>:$<$<CONFIG:RELWITHDEBINFO>:${compile_options}>>
    $<$<COMPILE_LANGUAGE:CXX>:$<$<CONFIG:RELWITHDEBINFO>:${compile_options}>>
  )
endfunction()

##########################################

function(momo_targets_set_warnings_as_errors)
  foreach(target ${ARGV})
    momo_target_set_warnings_as_errors(${target})
  endforeach()
endfunction()

##########################################

function(momo_get_all_targets var)
    set(targets)
    momo_get_all_targets_recursive(targets ${CMAKE_CURRENT_SOURCE_DIR})
    set(${var} ${targets} PARENT_SCOPE)
endfunction()

##########################################

macro(momo_get_all_targets_recursive targets dir)
    get_property(subdirectories DIRECTORY ${dir} PROPERTY SUBDIRECTORIES)
    foreach(subdir ${subdirectories})
        momo_get_all_targets_recursive(${targets} ${subdir})
    endforeach()

    get_property(current_targets DIRECTORY ${dir} PROPERTY BUILDSYSTEM_TARGETS)
    list(APPEND ${targets} ${current_targets})
endmacro()

##########################################

macro(momo_list_difference list_a list_to_remove result)
  set(${result} ${list_a})
  list(REMOVE_ITEM ${result} ${list_to_remove})
endmacro()

##########################################

macro(momo_set_artifact_directory directory)
  set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${directory})
  set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG ${directory})
  set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE ${directory})
  set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${directory})
  set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG ${directory})
  set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_RELEASE ${directory})
  set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${directory})
  set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_DEBUG ${directory})
  set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELEASE ${directory})
endmacro()

##########################################

macro(momo_set_new_artifact_directory)
  get_property(IS_MULTI_CONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
  if(IS_MULTI_CONFIG)
      set(ARTIFACT_FOLDER_NAME "artifacts-$<LOWER_CASE:$<CONFIG>>")
  else()
      set(ARTIFACT_FOLDER_NAME "artifacts")
  endif()

  set(ARTIFACT_DIRECTORY "${CMAKE_BINARY_DIR}/${ARTIFACT_FOLDER_NAME}")
  momo_set_artifact_directory(${ARTIFACT_DIRECTORY})
endmacro()

##########################################

macro(momo_add_subdirectory_and_get_targets directory targets)
  momo_get_all_targets(EXISTING_TARGETS)
  add_subdirectory(${directory})
  momo_get_all_targets(ALL_TARGETS)

  momo_list_difference("${ALL_TARGETS}" "${EXISTING_TARGETS}" ${targets})
endmacro()

##########################################

macro(momo_target_include_libraries target mode)
  foreach(inc_target ${ARGN})
    target_include_directories(${target} ${mode}
      $<TARGET_PROPERTY:${inc_target},INTERFACE_INCLUDE_DIRECTORIES>
      $<TARGET_PROPERTY:${inc_target},PUBLIC_INCLUDE_DIRECTORIES>
    )
  endforeach()
endmacro()

##########################################

function(momo_strip_target target)
  if (CMAKE_BUILD_TYPE STREQUAL "Debug")
    return()
  endif()

  if(NOT MSVC)
    if(NOT DEFINED STRIP_COMMAND)
      set(STRIP_COMMAND strip)
    endif()

    if(NOT DEFINED STRIP_FLAGS)
      set(STRIP_FLAGS -g -s)
      if(OSX)
        set(STRIP_FLAGS -x)
      endif()
    endif()

    set(IN_FILE "$<TARGET_FILE:${target}>")
    set(OUT_FILE "$<TARGET_FILE_DIR:${target}>/$<TARGET_FILE_PREFIX:${target}>$<TARGET_FILE_BASE_NAME:${target}>-unstripped$<TARGET_FILE_SUFFIX:${target}>")

    add_custom_command(TARGET ${target} POST_BUILD 
      COMMAND ${CMAKE_COMMAND} -E copy ${IN_FILE} ${OUT_FILE}
      COMMAND "${STRIP_COMMAND}" ${STRIP_FLAGS} "${IN_FILE}"
      COMMENT "Strippping ${target}"
    )
  endif()
endfunction()

##########################################

macro(momo_assign_source_group)
  source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${ARGN})
endmacro()

```

`deps/CMakeLists.txt`:

```txt
set(UNICORN_ARCH "x86" CACHE STRING "")

add_subdirectory(unicorn)
add_subdirectory(phnt)

##########################################

add_library(reflect INTERFACE)
target_include_directories(reflect INTERFACE
    "${CMAKE_CURRENT_LIST_DIR}/reflect"
)

##########################################

include(mini-gdbstub.cmake)
```

`deps/mini-gdbstub.cmake`:

```cmake
file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  mini-gdbstub/lib/*.c
)

list(SORT SRC_FILES)

add_library(mini-gdbstub ${SRC_FILES})

target_include_directories(mini-gdbstub PUBLIC
    "${CMAKE_CURRENT_LIST_DIR}/mini-gdbstub/include"
)

```

`src/CMakeLists.txt`:

```txt
add_subdirectory(common)
add_subdirectory(emulator)
add_subdirectory(unicorn-emulator)
add_subdirectory(windows-emulator)
add_subdirectory(analyzer)
add_subdirectory(fuzzing-engine)
add_subdirectory(fuzzer)
add_subdirectory(bad-sample)

```

`src/analyzer/CMakeLists.txt`:

```txt
file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  *.cpp
  *.hpp
  *.rc
)

list(SORT SRC_FILES)

add_executable(analyzer ${SRC_FILES})

momo_assign_source_group(${SRC_FILES})

target_precompile_headers(analyzer PRIVATE std_include.hpp)

target_link_libraries(analyzer PRIVATE
  common
  reflect
  windows-emulator
)

set_property(GLOBAL PROPERTY VS_STARTUP_PROJECT analyzer)

momo_strip_target(analyzer)

```

`src/analyzer/main.cpp`:

```cpp
#include "std_include.hpp"

#include <windows_emulator.hpp>
#include <debugging/x64_gdb_stub_handler.hpp>

#include "object_watching.hpp"

bool use_gdb = false;

namespace
{
	void watch_system_objects(windows_emulator& win_emu)
	{
		//watch_object(win_emu, *win_emu.current_thread().teb);
		watch_object(win_emu, win_emu.process().peb);
		watch_object(win_emu, win_emu.process().kusd);
		auto* params_hook = watch_object(win_emu, win_emu.process().process_params);

		win_emu.emu().hook_memory_write(win_emu.process().peb.value() + offsetof(PEB, ProcessParameters), 0x8,
		                                [&](const uint64_t address, size_t, const uint64_t value)
		                                {
			                                const auto target_address = win_emu.process().peb.value() + offsetof(
				                                PEB, ProcessParameters);

			                                if (address == target_address)
			                                {
				                                const emulator_object<RTL_USER_PROCESS_PARAMETERS> obj{
					                                win_emu.emu(), value
				                                };

				                                win_emu.emu().delete_hook(params_hook);
				                                params_hook = watch_object(win_emu, obj);
			                                }
		                                });
	}

	void run_emulation(windows_emulator& win_emu)
	{
		try
		{
			if (use_gdb)
			{
				const auto* address = "0.0.0.0:28960";
				win_emu.logger.print(color::pink, "Waiting for GDB connection on %s...\n", address);

				x64_gdb_stub_handler handler{win_emu.emu()};
				run_gdb_stub(handler, "i386:x86-64", gdb_registers.size(), address);
			}
			else
			{
				while (true)
				{
					win_emu.emu().start_from_ip();
					if (win_emu.switch_thread)
					{
						win_emu.perform_thread_switch();
						continue;
					}

					break;
				}
			}
		}
		catch (...)
		{
			win_emu.logger.print(color::red, "Emulation failed at: 0x%llX\n", win_emu.emu().read_instruction_pointer());
			throw;
		}

		win_emu.logger.print(color::red, "Emulation terminated!\n");
	}

	void run(const std::string_view application)
	{
		windows_emulator win_emu{
			application, {}
		};

		(void)&watch_system_objects;
		//watch_system_objects(win_emu);
		win_emu.buffer_stdout = false;
		//win_emu.verbose_calls = true;

		const auto& exe = *win_emu.process().executable;

		const auto text_start = exe.image_base + 0x1000;
		const auto text_end = exe.image_base + 0x52000;
		constexpr auto scan_size = 0x100;

		win_emu.emu().hook_memory_read(text_start, scan_size, [&](const uint64_t address, size_t, uint64_t)
		{
			const auto rip = win_emu.emu().read_instruction_pointer();
			if (rip >= text_start && rip < text_end)
			{
				win_emu.logger.print(color::green, "Reading from executable .text: 0x%llX at 0x%llX\n", address, rip);
			}
		});

		run_emulation(win_emu);
	}
}

int main(const int argc, char** argv)
{
	if (argc <= 1)
	{
		puts("Application not specified!");
		return 1;
	}

	//setvbuf(stdout, nullptr, _IOFBF, 0x10000);
	if (argc > 2 && argv[1] == "-d"s)
	{
		use_gdb = true;
	}

	try
	{
		do
		{
			run(argv[use_gdb ? 2 : 1]);
		}
		while (use_gdb);

		return 0;
	}
	catch (std::exception& e)
	{
		puts(e.what());

#if defined(_WIN32) && 0
		MessageBoxA(nullptr, e.what(), "ERROR", MB_ICONERROR);
#endif
	}

	return 1;
}

#ifdef _WIN32
int WINAPI WinMain(HINSTANCE, HINSTANCE, PSTR, int)
{
	return main(__argc, __argv);
}
#endif

```

`src/analyzer/object_watching.hpp`:

```hpp
#pragma once

#include "reflect_type_info.hpp"

template <typename T>
emulator_hook* watch_object(windows_emulator& emu, emulator_object<T> object)
{
	const reflect_type_info<T> info{};

	return emu.emu().hook_memory_read(object.value(), object.size(),
	                                  [i = std::move(info), object, &emu](const uint64_t address, size_t, uint64_t)
	                                  {
		                                  const auto rip = emu.emu().read_instruction_pointer();

		                                  const auto offset = address - object.value();
		                                  emu.logger.log("Object access: %s - 0x%llX (%s) at 0x%llX (%s)\n", i.get_type_name().c_str(),
		                                                 offset,
		                                                 i.get_member_name(offset).c_str(), rip,
		                                                 emu.process().module_manager.find_name(rip));
	                                  });
}

```

`src/analyzer/reflect_extension.hpp`:

```hpp
#pragma once

namespace {
	template<bool Cond> struct REFLECT_FWD_LIKE2 { template<class T> using type = std::remove_reference_t<T>&&; };
	template<> struct REFLECT_FWD_LIKE2<true> { template<class T> using type = std::remove_reference_t<T>&; };
} // to speed up compilation times

#define REFLECT_FWD(...) static_cast<decltype(__VA_ARGS__)&&>(__VA_ARGS__)
#define REFLECT_FWD_LIKE(T, ...) static_cast<typename ::REFLECT_FWD_LIKE2<::std::is_lvalue_reference_v<T>>::template type<decltype(__VA_ARGS__)>>(__VA_ARGS__)

namespace reflect::inline v1_2_3 {
	namespace detail
	{
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 65>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 66>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 67>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 68>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 69>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 70>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 71>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 72>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 73>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 74>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 75>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 76>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 77>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 78>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 79>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 80>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 81>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 82>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 83>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 84>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 85>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 86>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 87>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 88>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 89>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 90>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 91>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 92>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 93>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 94>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 95>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 96>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 97>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 98>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 99>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 100>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 101>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 102>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 103>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 104>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 105>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104, _105] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 106>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104, _105, _106] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 107>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 108>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107, _108] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 109>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 110>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109), REFLECT_FWD_LIKE(T, _110)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 111>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109), REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 112>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109), REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 113>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109), REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 114>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109), REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113), REFLECT_FWD_LIKE(T, _114)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 115>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109), REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113), REFLECT_FWD_LIKE(T, _114), REFLECT_FWD_LIKE(T, _115)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 116>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109), REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113), REFLECT_FWD_LIKE(T, _114), REFLECT_FWD_LIKE(T, _115), REFLECT_FWD_LIKE(T, _116)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 117>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116, _117] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109), REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113), REFLECT_FWD_LIKE(T, _114), REFLECT_FWD_LIKE(T, _115), REFLECT_FWD_LIKE(T, _116), REFLECT_FWD_LIKE(T, _117)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 118>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116, _117, _118] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109), REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113), REFLECT_FWD_LIKE(T, _114), REFLECT_FWD_LIKE(T, _115), REFLECT_FWD_LIKE(T, _116), REFLECT_FWD_LIKE(T, _117), REFLECT_FWD_LIKE(T, _118)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 119>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116, _117, _118, _119] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109), REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113), REFLECT_FWD_LIKE(T, _114), REFLECT_FWD_LIKE(T, _115), REFLECT_FWD_LIKE(T, _116), REFLECT_FWD_LIKE(T, _117), REFLECT_FWD_LIKE(T, _118), REFLECT_FWD_LIKE(T, _119)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 120>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116, _117, _118, _119, _120] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109), REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113), REFLECT_FWD_LIKE(T, _114), REFLECT_FWD_LIKE(T, _115), REFLECT_FWD_LIKE(T, _116), REFLECT_FWD_LIKE(T, _117), REFLECT_FWD_LIKE(T, _118), REFLECT_FWD_LIKE(T, _119), REFLECT_FWD_LIKE(T, _120)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 121>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116, _117, _118, _119, _120, _121] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109), REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113), REFLECT_FWD_LIKE(T, _114), REFLECT_FWD_LIKE(T, _115), REFLECT_FWD_LIKE(T, _116), REFLECT_FWD_LIKE(T, _117), REFLECT_FWD_LIKE(T, _118), REFLECT_FWD_LIKE(T, _119), REFLECT_FWD_LIKE(T, _120), REFLECT_FWD_LIKE(T, _121)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 122>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116, _117, _118, _119, _120, _121, _122] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109), REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113), REFLECT_FWD_LIKE(T, _114), REFLECT_FWD_LIKE(T, _115), REFLECT_FWD_LIKE(T, _116), REFLECT_FWD_LIKE(T, _117), REFLECT_FWD_LIKE(T, _118), REFLECT_FWD_LIKE(T, _119), REFLECT_FWD_LIKE(T, _120), REFLECT_FWD_LIKE(T, _121), REFLECT_FWD_LIKE(T, _122)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 123>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116, _117, _118, _119, _120, _121, _122, _123] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109), REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113), REFLECT_FWD_LIKE(T, _114), REFLECT_FWD_LIKE(T, _115), REFLECT_FWD_LIKE(T, _116), REFLECT_FWD_LIKE(T, _117), REFLECT_FWD_LIKE(T, _118), REFLECT_FWD_LIKE(T, _119), REFLECT_FWD_LIKE(T, _120), REFLECT_FWD_LIKE(T, _121), REFLECT_FWD_LIKE(T, _122), REFLECT_FWD_LIKE(T, _123)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 124>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116, _117, _118, _119, _120, _121, _122, _123, _124] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109), REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113), REFLECT_FWD_LIKE(T, _114), REFLECT_FWD_LIKE(T, _115), REFLECT_FWD_LIKE(T, _116), REFLECT_FWD_LIKE(T, _117), REFLECT_FWD_LIKE(T, _118), REFLECT_FWD_LIKE(T, _119), REFLECT_FWD_LIKE(T, _120), REFLECT_FWD_LIKE(T, _121), REFLECT_FWD_LIKE(T, _122), REFLECT_FWD_LIKE(T, _123), REFLECT_FWD_LIKE(T, _124)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 125>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116, _117, _118, _119, _120, _121, _122, _123, _124, _125] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109), REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113), REFLECT_FWD_LIKE(T, _114), REFLECT_FWD_LIKE(T, _115), REFLECT_FWD_LIKE(T, _116), REFLECT_FWD_LIKE(T, _117), REFLECT_FWD_LIKE(T, _118), REFLECT_FWD_LIKE(T, _119), REFLECT_FWD_LIKE(T, _120), REFLECT_FWD_LIKE(T, _121), REFLECT_FWD_LIKE(T, _122), REFLECT_FWD_LIKE(T, _123), REFLECT_FWD_LIKE(T, _124), REFLECT_FWD_LIKE(T, _125)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 126>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116, _117, _118, _119, _120, _121, _122, _123, _124, _125, _126] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109), REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113), REFLECT_FWD_LIKE(T, _114), REFLECT_FWD_LIKE(T, _115), REFLECT_FWD_LIKE(T, _116), REFLECT_FWD_LIKE(T, _117), REFLECT_FWD_LIKE(T, _118), REFLECT_FWD_LIKE(T, _119), REFLECT_FWD_LIKE(T, _120), REFLECT_FWD_LIKE(T, _121), REFLECT_FWD_LIKE(T, _122), REFLECT_FWD_LIKE(T, _123), REFLECT_FWD_LIKE(T, _124), REFLECT_FWD_LIKE(T, _125), REFLECT_FWD_LIKE(T, _126)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 127>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116, _117, _118, _119, _120, _121, _122, _123, _124, _125, _126, _127] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109), REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113), REFLECT_FWD_LIKE(T, _114), REFLECT_FWD_LIKE(T, _115), REFLECT_FWD_LIKE(T, _116), REFLECT_FWD_LIKE(T, _117), REFLECT_FWD_LIKE(T, _118), REFLECT_FWD_LIKE(T, _119), REFLECT_FWD_LIKE(T, _120), REFLECT_FWD_LIKE(T, _121), REFLECT_FWD_LIKE(T, _122), REFLECT_FWD_LIKE(T, _123), REFLECT_FWD_LIKE(T, _124), REFLECT_FWD_LIKE(T, _125), REFLECT_FWD_LIKE(T, _126), REFLECT_FWD_LIKE(T, _127)); }
		template<class Fn, class T> [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 128>) noexcept { auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116, _117, _118, _119, _120, _121, _122, _123, _124, _125, _126, _127, _128] = REFLECT_FWD(t); return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109), REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113), REFLECT_FWD_LIKE(T, _114), REFLECT_FWD_LIKE(T, _115), REFLECT_FWD_LIKE(T, _116), REFLECT_FWD_LIKE(T, _117), REFLECT_FWD_LIKE(T, _118), REFLECT_FWD_LIKE(T, _119), REFLECT_FWD_LIKE(T, _120), REFLECT_FWD_LIKE(T, _121), REFLECT_FWD_LIKE(T, _122), REFLECT_FWD_LIKE(T, _123), REFLECT_FWD_LIKE(T, _124), REFLECT_FWD_LIKE(T, _125), REFLECT_FWD_LIKE(T, _126), REFLECT_FWD_LIKE(T, _127), REFLECT_FWD_LIKE(T, _128)); }
	}
}

#undef REFLECT_FWD_LIKE
#undef REFLECT_FWD

```

`src/analyzer/reflect_type_info.hpp`:

```hpp
#pragma once

#include "reflect_extension.hpp"
#include <reflect>

template <typename T>
class reflect_type_info
{
public:
	reflect_type_info()
	{
		this->type_name_ = reflect::type_name<T>();

		reflect::for_each<T>([this](auto I)
		{
			const auto member_name = reflect::member_name<I, T>();
			const auto member_offset = reflect::offset_of<I, T>();

			this->members_[member_offset] = member_name;
		});
	}

	std::string get_member_name(const size_t offset) const
	{
		size_t last_offset{};
		std::string_view last_member{};

		for (const auto& member : this->members_)
		{
			if (offset == member.first)
			{
				return member.second;
			}

			if (offset < member.first)
			{
				const auto diff = offset - last_offset;
				return std::string(last_member) + "+" + std::to_string(diff);
			}

			last_offset = member.first;
			last_member = member.second;
		}

		return "<N/A>";
	}

	const std::string& get_type_name() const
	{
		return this->type_name_;
	}

private:
	std::string type_name_{};
	std::map<size_t, std::string> members_{};
};

```

`src/analyzer/resource.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "windows.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "#include ""windows.h""\r\n"
    "\0"
END

2 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,0
 PRODUCTVERSION 1,0,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE VFT_DLL
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "momo5502"
            VALUE "FileDescription", "Windows Emulator"
            VALUE "FileVersion", "1.0.0.0"
            VALUE "InternalName", "emulator"
            VALUE "LegalCopyright", "All rights reserved."
            VALUE "OriginalFilename", "emulator.exe"
            VALUE "ProductName", "emulator"
            VALUE "ProductVersion", "1.0.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

/////////////////////////////////////////////////////////////////////////////
//
// Binary Data
//

GLFW_ICON       ICON   "resources/icon.ico"


#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`src/analyzer/std_include.hpp`:

```hpp
#pragma once

#ifdef _WIN32
#pragma warning(push)
#pragma warning(disable: 4005)
#pragma warning(disable: 4127)
#pragma warning(disable: 4201)
#pragma warning(disable: 4244)
#pragma warning(disable: 4245)
#pragma warning(disable: 4324)
#pragma warning(disable: 4458)
#pragma warning(disable: 4471)
#pragma warning(disable: 4505)
#pragma warning(disable: 4702)
#pragma warning(disable: 4996)
#pragma warning(disable: 5054)
#pragma warning(disable: 6011)
#pragma warning(disable: 6297)
#pragma warning(disable: 6385)
#pragma warning(disable: 6386)
#pragma warning(disable: 6387)
#pragma warning(disable: 26110)
#pragma warning(disable: 26451)
#pragma warning(disable: 26444)
#pragma warning(disable: 26451)
#pragma warning(disable: 26489)
#pragma warning(disable: 26495)
#pragma warning(disable: 26498)
#pragma warning(disable: 26812)
#pragma warning(disable: 28020)

#define WIN32_LEAN_AND_MEAN
#define NOMINMAX

#include <map>
#include <set>
#include <list>
#include <array>
#include <deque>
#include <queue>
#include <thread>
#include <ranges>
#include <atomic>
#include <vector>
#include <mutex>
#include <string>
#include <chrono>
#include <memory>
#include <fstream>
#include <functional>
#include <filesystem>
#include <optional>
#include <stdexcept>
#include <string_view>
#include <unordered_set>
#include <condition_variable>

#include <cassert>

#define NTDDI_WIN11_GE 0
#define PHNT_VERSION PHNT_WIN11
#include <phnt_windows.h>
#include <phnt.h>
#include <ntgdi.h>

#ifdef _WIN32
#pragma warning(pop)
#endif

#ifdef max
#undef max
#endif

#ifdef min
#undef min
#endif
#endif

using namespace std::literals;

```

`src/bad-sample/CMakeLists.txt`:

```txt
file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  *.cpp
  *.hpp
  *.rc
)

list(SORT SRC_FILES)

add_executable(bad-sample ${SRC_FILES})

momo_assign_source_group(${SRC_FILES})

```

`src/bad-sample/bad.cpp`:

```cpp
#include <cstdint>
#include <cstdio>
#include <Windows.h>

#define THE_SIZE 30

extern "C" __declspec(noinline) __declspec(dllexport)
void vulnerable(const uint8_t* data, const size_t size)
{
	if (size < 10)
	{
		return;
	}

	if (data[9] != 'A')
	{
		return;
	}

	if (data[8] != 'B')
	{
		return;
	}

	if (data[7] != 'C')
	{
		return;
	}

	if (data[2] != 'V')
	{
		return;
	}

	if (data[4] != 'H')
	{
		return;
	}

	if (size < 100)
	{
		return;
	}

	*(int*)1 = 1;
}

uint8_t buffer[THE_SIZE] = {};


int main(int argc, const char* argv[])
{
	const void* input = buffer;
	auto size = sizeof(buffer);

	if (argc > 1)
	{
		input = argv[1];
		size = strlen(argv[1]);
	}

	vulnerable((uint8_t*)input, size);
	return 0;
}

```

`src/common/CMakeLists.txt`:

```txt
file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  *.cpp
  *.hpp
)

add_library(common ${SRC_FILES})

momo_assign_source_group(${SRC_FILES})

target_include_directories(common INTERFACE "${CMAKE_CURRENT_LIST_DIR}")

set(THREADS_PREFER_PTHREAD_FLAG ON)
find_package(Threads REQUIRED)
target_link_libraries(common PUBLIC
  Threads::Threads
)

```

`src/common/utils/buffer_accessor.hpp`:

```hpp
#pragma once
#include <span>
#include <cstdint>
#include <stdexcept>

namespace utils
{
	template <typename T, typename S = const uint8_t>
		requires(std::is_trivially_copyable_v<T> && std::is_same_v<uint8_t, std::remove_cv_t<S>>)
	class safe_object_accessor
	{
	public:
		safe_object_accessor(const std::span<S> buffer, const size_t offset)
			: buffer_(buffer)
			  , offset_(offset)
		{
		}

		/*****************************************************************************
		 * Object is copied to make sure platform-dependent alignment requirements
		 * are respected
		 ****************************************************************************/

		T get(const size_t element_index = 0) const
		{
			T value{};
			memcpy(&value, get_valid_pointer(element_index), size);
			return value;
		}

		void set(const T value, const size_t element_index = 0) const
		{
			memcpy(get_valid_pointer(element_index), &value, size);
		}

	private:
		static constexpr auto size = sizeof(T);

		std::span<S> buffer_{};
		size_t offset_{};

		S* get_valid_pointer(const size_t element_index) const
		{
			const auto start_offset = offset_ + (size * element_index);
			const auto end_offset = start_offset + size;
			if (end_offset > buffer_.size())
			{
				throw std::runtime_error("Buffer accessor overflow");
			}

			return buffer_.data() + start_offset;
		}
	};

	template <typename T>
		requires(std::is_same_v<uint8_t, std::remove_cv_t<T>>)
	class safe_buffer_accessor
	{
	public:
		safe_buffer_accessor(const std::span<T> buffer)
			: buffer_(buffer)
		{
		}

		template <typename S>
		safe_buffer_accessor(const safe_buffer_accessor<S>& obj)
			: buffer_(obj.get_buffer())
		{
		}

		template <typename S>
		safe_object_accessor<S, T> as(const size_t offset) const
		{
			return {this->buffer_, offset};
		}

		T* get_pointer_for_range(const size_t offset, const size_t size) const
		{
			this->validate(offset, size);
			return this->buffer_.data() + offset;
		}

		void validate(const size_t offset, const size_t size) const
		{
			const auto end = offset + size;
			if (end > buffer_.size())
			{
				throw std::runtime_error("Buffer accessor overflow");
			}
		}

		template <typename S = char>
		std::basic_string<S> as_string(const size_t offset) const
		{
			safe_object_accessor<S> string_accessor{this->buffer_, offset};
			std::basic_string<S> result{};

			while (true)
			{
				auto value = string_accessor.get(result.size());
				if (!value)
				{
					return result;
				}

				result.push_back(std::move(value));
			}
		}

		std::span<T> get_buffer() const
		{
			return this->buffer_;
		}

	private:
		const std::span<T> buffer_{};
	};
}

```

`src/common/utils/concurrency.hpp`:

```hpp
#pragma once

#include <mutex>

namespace utils::concurrency
{
	template <typename T, typename MutexType = std::mutex>
	class container
	{
	public:
		template <typename R = void, typename F>
		R access(F&& accessor) const
		{
			std::lock_guard<MutexType> _{mutex_};
			return accessor(object_);
		}

		template <typename R = void, typename F>
		R access(F&& accessor)
		{
			std::lock_guard<MutexType> _{mutex_};
			return accessor(object_);
		}

		template <typename R = void, typename F>
		R access_with_lock(F&& accessor) const
		{
			std::unique_lock<MutexType> lock{mutex_};
			return accessor(object_, lock);
		}

		template <typename R = void, typename F>
		R access_with_lock(F&& accessor)
		{
			std::unique_lock<MutexType> lock{mutex_};
			return accessor(object_, lock);
		}

		T& get_raw() { return object_; }
		const T& get_raw() const { return object_; }

		T copy() const
		{
			std::unique_lock<MutexType> lock{mutex_};
			return object_;
		}

		std::unique_lock<MutexType> acquire_lock()
		{
			return std::unique_lock<MutexType>{mutex_};
		}

	private:
		mutable MutexType mutex_{};
		T object_{};
	};
}

```

`src/common/utils/finally.hpp`:

```hpp
#pragma once
#include <utility>
#include <type_traits>

namespace utils
{
	/*
	 * Copied from here: https://github.com/microsoft/GSL/blob/e0880931ae5885eb988d1a8a57acf8bc2b8dacda/include/gsl/util#L57
	 */

	template <class F>
	class final_action
	{
	public:
		static_assert(!std::is_reference<F>::value && !std::is_const<F>::value &&
			!std::is_volatile<F>::value,
			"Final_action should store its callable by value");

		explicit final_action(F f) noexcept : f_(std::move(f))
		{
		}

		final_action(final_action&& other) noexcept
			: f_(std::move(other.f_)), invoke_(std::exchange(other.invoke_, false))
		{
		}

		final_action(const final_action&) = delete;
		final_action& operator=(const final_action&) = delete;
		final_action& operator=(final_action&&) = delete;

		~final_action() noexcept
		{
			if (invoke_) f_();
		}

		// Added by momo5502
		void cancel()
		{
			invoke_ = false;
		}

	private:
		F f_;
		bool invoke_{true};
	};

	template <class F>
	final_action<typename std::remove_cv<typename std::remove_reference<F>::type>::type>
	finally(F&& f) noexcept
	{
		return final_action<typename std::remove_cv<typename std::remove_reference<F>::type>::type>(
			std::forward<F>(f));
	}
}
```

`src/common/utils/io.cpp`:

```cpp
#include "io.hpp"
#include <fstream>
#include <sstream>

namespace utils::io
{
	bool remove_file(const std::filesystem::path& file)
	{
		std::error_code ec{};
		return std::filesystem::remove(file, ec) && !ec;
	}

	bool move_file(const std::filesystem::path& src, const std::filesystem::path& target)
	{
		copy_folder(src, target);
		return remove_file(src);
	}

	bool file_exists(const std::filesystem::path& file)
	{
		return std::ifstream(file).good();
	}

	bool write_file(const std::filesystem::path& file, const std::vector<uint8_t>& data, const bool append)
	{
		if (file.has_parent_path())
		{
			io::create_directory(file.parent_path());
		}

		std::basic_ofstream<uint8_t> stream(
			file, std::ios::binary | std::ofstream::out | (append ? std::ofstream::app : std::ofstream::out));

		if (stream.is_open())
		{
			stream.write(data.data(), static_cast<std::streamsize>(data.size()));
			stream.close();
			return true;
		}

		return false;
	}

	std::vector<uint8_t> read_file(const std::filesystem::path& file)
	{
		std::vector<uint8_t> data;
		read_file(file, &data);
		return data;
	}

	bool read_file(const std::filesystem::path& file, std::vector<uint8_t>* data)
	{
		if (!data) return false;
		data->clear();

		std::ifstream stream(file, std::ios::binary);
		if (!stream) return false;

		*data = std::vector<uint8_t>{(std::istreambuf_iterator<char>(stream)), std::istreambuf_iterator<char>()};
		return true;
	}

	std::size_t file_size(const std::filesystem::path& file)
	{
		std::ifstream stream(file, std::ios::binary);

		if (stream)
		{
			stream.seekg(0, std::ios::end);
			return static_cast<std::size_t>(stream.tellg());
		}

		return 0;
	}

	bool create_directory(const std::filesystem::path& directory)
	{
		std::error_code ec{};
		return std::filesystem::create_directories(directory, ec) && !ec;
	}

	bool directory_exists(const std::filesystem::path& directory)
	{
		std::error_code ec{};
		return std::filesystem::is_directory(directory, ec) && !ec;
	}

	bool directory_is_empty(const std::filesystem::path& directory)
	{
		std::error_code ec{};
		return std::filesystem::is_empty(directory, ec) && !ec;
	}

	void copy_folder(const std::filesystem::path& src, const std::filesystem::path& target)
	{
		std::error_code ec{};
		std::filesystem::copy(src, target,
		                      std::filesystem::copy_options::overwrite_existing |
		                      std::filesystem::copy_options::recursive, ec);
	}

	std::vector<std::filesystem::path> list_files(const std::filesystem::path& directory, const bool recursive)
	{
		std::error_code code{};
		std::vector<std::filesystem::path> files;

		if (recursive)
		{
			for (auto& file : std::filesystem::recursive_directory_iterator(directory, code))
			{
				files.push_back(file.path());
			}
		}
		else
		{
			for (auto& file : std::filesystem::directory_iterator(directory, code))
			{
				files.push_back(file.path());
			}
		}

		return files;
	}
}

```

`src/common/utils/io.hpp`:

```hpp
#pragma once

#include <string>
#include <vector>
#include <filesystem>

namespace utils::io
{
	bool remove_file(const std::filesystem::path& file);
	bool move_file(const std::filesystem::path& src, const std::filesystem::path& target);
	bool file_exists(const std::filesystem::path& file);
	bool write_file(const std::filesystem::path& file, const std::vector<uint8_t>& data, bool append = false);
	bool read_file(const std::filesystem::path& file, std::vector<uint8_t>* data);
	std::vector<uint8_t> read_file(const std::filesystem::path& file);
	size_t file_size(const std::filesystem::path& file);
	bool create_directory(const std::filesystem::path& directory);
	bool directory_exists(const std::filesystem::path& directory);
	bool directory_is_empty(const std::filesystem::path& directory);
	void copy_folder(const std::filesystem::path& src, const std::filesystem::path& target);

	std::vector<std::filesystem::path> list_files(const std::filesystem::path& directory, bool recursive = false);
}

```

`src/common/utils/nt_handle.hpp`:

```hpp
#pragma once

#define NOMINMAX
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>

#include <type_traits>

namespace utils::nt
{
	using HandleFunction = HANDLE();

	inline HANDLE null_handle()
	{
		return nullptr;
	}

	inline HANDLE invalid_handle()
	{
		return INVALID_HANDLE_VALUE;
	}

	template <HandleFunction InvalidHandleFunction = null_handle>
	class handle
	{
	public:
		handle() = default;

		handle(const HANDLE h)
			: handle_(h)
		{
		}

		~handle()
		{
			if (*this)
			{
				CloseHandle(this->handle_);
				this->handle_ = InvalidHandleFunction();
			}
		}

		handle(const handle&) = delete;
		handle& operator=(const handle&) = delete;

		handle(handle&& obj) noexcept
			: handle()
		{
			this->operator=(std::move(obj));
		}

		handle& operator=(handle&& obj) noexcept
		{
			if (this != &obj)
			{
				this->~handle();
				this->handle_ = obj.handle_;
				obj.handle_ = InvalidHandleFunction();
			}

			return *this;
		}

		handle& operator=(HANDLE h) noexcept
		{
			this->~handle();
			this->handle_ = h;

			return *this;
		}

		[[nodiscard]] operator bool() const
		{
			return this->handle_ != InvalidHandleFunction();
		}

		[[nodiscard]] operator HANDLE() const
		{
			return this->handle_;
		}

	private:
		HANDLE handle_{InvalidHandleFunction()};
	};
}

```

`src/common/utils/timer.hpp`:

```hpp
#pragma once

#include <chrono>

namespace utils
{
	template <typename Clock = std::chrono::high_resolution_clock>
	class timer
	{
	public:
		void update()
		{
			this->point_ = Clock::now();
		}

		bool has_elapsed(typename Clock::duration duration) const
		{
			const auto now = Clock::now();
			const auto diff = now - this->point_;
			return diff > duration;
		}

	private:
		typename Clock::time_point point_{ Clock::now() };
	};
}

```

`src/emulator/CMakeLists.txt`:

```txt
file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  *.cpp
  *.hpp
  *.rc
)

list(SORT SRC_FILES)

add_library(emulator ${SRC_FILES})

target_include_directories(emulator INTERFACE
    "${CMAKE_CURRENT_LIST_DIR}"
)

```

`src/emulator/address_utils.hpp`:

```hpp
#pragma once
#include <cstdint>

template <typename T>
T* offset_pointer(void* data, const size_t offset)
{
	return reinterpret_cast<T*>(static_cast<uint8_t*>(data) + offset);
}

template <typename T>
const T* offset_pointer(const void* data, const size_t offset)
{
	return reinterpret_cast<const T*>(static_cast<const uint8_t*>(data) + offset);
}

inline bool is_within_start_and_end(const uint64_t value, const uint64_t start, const uint64_t end)
{
	return value >= start && value < end;
}

inline bool is_within_start_and_length(const uint64_t value, const uint64_t start, const uint64_t length)
{
	return is_within_start_and_end(value, start, start + length);
}

inline bool regions_intersect(const uint64_t start1, const uint64_t end1, const uint64_t start2, const uint64_t end2)
{
	return start1 < end2 && start2 < end1;
}

inline bool regions_with_length_intersect(const uint64_t start1, const uint64_t length1, const uint64_t start2,
                                          const uint64_t length2)
{
	return regions_intersect(start1, start1 + length1, start2, start2 + length2);
}

inline uint64_t align_down(const uint64_t value, const uint64_t alignment)
{
	return value & ~(alignment - 1);
}

inline uint64_t align_up(const uint64_t value, const uint64_t alignment)
{
	return align_down(value + (alignment - 1), alignment);
}

inline uint64_t page_align_down(const uint64_t value, const uint64_t page_size = 0x1000)
{
	return align_down(value, page_size);
}

inline uint64_t page_align_up(const uint64_t value, const uint64_t page_size = 0x1000)
{
	return align_up(value, page_size);
}

```

`src/emulator/emulator.hpp`:

```hpp
#pragma once
#include <chrono>
#include <functional>
#include <cassert>

#include "memory_manager.hpp"

struct emulator_hook;

using memory_operation = memory_permission;

enum class instruction_hook_continuation : bool
{
	run_instruction = false,
	skip_instruction = true,
};

enum class memory_violation_continuation : bool
{
	stop = false,
	resume = true,
};

enum class memory_violation_type : uint8_t
{
	unmapped,
	protection,
};

struct basic_block
{
	uint64_t address;
	size_t instruction_count;
	size_t size;
};

using edge_generation_hook_callback = std::function<void(const basic_block& current_block,
                                                         const basic_block& previous_block)>;
using basic_block_hook_callback = std::function<void(const basic_block& block)>;

using instruction_hook_callback = std::function<instruction_hook_continuation()>;

using interrupt_hook_callback = std::function<void(int interrupt)>;
using simple_memory_hook_callback = std::function<void(uint64_t address, size_t size, uint64_t value)>;
using complex_memory_hook_callback = std::function<void(uint64_t address, size_t size, uint64_t value, memory_operation operation)>;
using memory_violation_hook_callback = std::function<memory_violation_continuation(
	uint64_t address, size_t size, memory_operation operation,
	memory_violation_type type)>;

class emulator : public memory_manager
{
public:
	emulator() = default;

	emulator(const emulator&) = delete;
	emulator& operator=(const emulator&) = delete;

	emulator(emulator&&) = delete;
	emulator& operator=(emulator&&) = delete;

	virtual void start(uint64_t start, uint64_t end = 0, std::chrono::microseconds timeout = {}, size_t count = 0) = 0;
	virtual void stop() = 0;

	virtual void read_raw_register(int reg, void* value, size_t size) = 0;
	virtual void write_raw_register(int reg, const void* value, size_t size) = 0;

	virtual std::vector<std::byte> save_registers() = 0;
	virtual void restore_registers(const std::vector<std::byte>& register_data) = 0;

	virtual emulator_hook* hook_memory_violation(uint64_t address, size_t size,
	                                             memory_violation_hook_callback callback) = 0;

	virtual emulator_hook* hook_memory_access(uint64_t address, size_t size, memory_operation filter,
	                                          complex_memory_hook_callback callback) = 0;
	virtual emulator_hook* hook_instruction(int instruction_type, instruction_hook_callback callback) = 0;

	virtual emulator_hook* hook_interrupt(interrupt_hook_callback callback) = 0;

	virtual emulator_hook* hook_edge_generation(edge_generation_hook_callback callback) = 0;
	virtual emulator_hook* hook_basic_block(basic_block_hook_callback callback) = 0;

	virtual void delete_hook(emulator_hook* hook) = 0;

	emulator_hook* hook_memory_violation(memory_violation_hook_callback callback)
	{
		return this->hook_memory_violation(0, std::numeric_limits<size_t>::max(), std::move(callback));
	}

	emulator_hook* hook_memory_read(const uint64_t address, const size_t size, simple_memory_hook_callback callback)
	{
		return this->hook_simple_memory_access(address, size, std::move(callback), memory_operation::read);
	}

	emulator_hook* hook_memory_write(const uint64_t address, const size_t size, simple_memory_hook_callback callback)
	{
		return this->hook_simple_memory_access(address, size, std::move(callback), memory_operation::write);
	}

	emulator_hook* hook_memory_execution(const uint64_t address, const size_t size,
	                                     simple_memory_hook_callback callback)
	{
		return this->hook_simple_memory_access(address, size, std::move(callback), memory_operation::exec);
	}

	void serialize(utils::buffer_serializer& buffer) const
	{
		this->perform_serialization(buffer, false);
	}

	void deserialize(utils::buffer_deserializer& buffer)
	{
		this->perform_deserialization(buffer, false);
	}

	void save_snapshot()
	{
		utils::buffer_serializer serializer{};
		this->perform_serialization(serializer, true);
		this->last_snapshot_data_ = serializer.move_buffer();
	}

	void restore_snapshot()
	{
		if (this->last_snapshot_data_.empty())
		{
			return;
		}

		utils::buffer_deserializer deserializer{this->last_snapshot_data_};
		this->perform_deserialization(deserializer, true);
	}

private:
	std::vector<std::byte> last_snapshot_data_{};

	emulator_hook* hook_simple_memory_access(const uint64_t address, const size_t size,
	                                         simple_memory_hook_callback callback, const memory_operation operation)
	{
		assert((static_cast<uint8_t>(operation) & (static_cast<uint8_t>(operation) - 1)) == 0);
		return this->hook_memory_access(address, size, operation,
		                                [c = std::move(callback)](const uint64_t a, const size_t s, const uint64_t value,
		                                                          memory_operation)
		                                {
			                                c(a, s, value);
		                                });
	}

	void perform_serialization(utils::buffer_serializer& buffer, const bool is_snapshot) const
	{
		this->serialize_state(buffer, is_snapshot);
		this->serialize_memory_state(buffer, is_snapshot);
	}

	void perform_deserialization(utils::buffer_deserializer& buffer, const bool is_snapshot)
	{
		this->deserialize_state(buffer, is_snapshot);
		this->deserialize_memory_state(buffer, is_snapshot);
	}

	virtual void serialize_state(utils::buffer_serializer& buffer, bool is_snapshot) const = 0;
	virtual void deserialize_state(utils::buffer_deserializer& buffer, bool is_snapshot) = 0;
};

```

`src/emulator/memory_manager.cpp`:

```cpp
#include "memory_manager.hpp"

#include "memory_region.hpp"
#include "address_utils.hpp"

#include <vector>
#include <optional>
#include <stdexcept>
#include <cassert>

namespace
{
	constexpr auto MIN_ALLOCATION_ADDRESS = 0x0000000000010000ULL;
	constexpr auto MAX_ALLOCATION_ADDRESS = 0x00007ffffffeffffULL;

	void split_regions(memory_manager::committed_region_map& regions, const std::vector<uint64_t>& split_points)
	{
		for (auto i = regions.begin(); i != regions.end(); ++i)
		{
			for (const auto split_point : split_points)
			{
				if (is_within_start_and_length(split_point, i->first, i->second.length) && i->first != split_point)
				{
					const auto first_length = split_point - i->first;
					const auto second_length = i->second.length - first_length;

					i->second.length = first_length;

					regions[split_point] = memory_manager::committed_region{second_length, i->second.pemissions};
				}
			}
		}
	}

	void merge_regions(memory_manager::committed_region_map& regions)
	{
		for (auto i = regions.begin(); i != regions.end();)
		{
			assert(i->second.length > 0);

			auto next = i;
			std::advance(next, 1);

			if (next == regions.end())
			{
				break;
			}

			assert(next->second.length > 0);

			const auto end = i->first + i->second.length;
			assert(end <= next->first);

			if (end != next->first || i->second.pemissions != next->second.pemissions)
			{
				++i;
				continue;
			}

			i->second.length += next->second.length;
			regions.erase(next);
		}
	}
}

static void serialize(utils::buffer_serializer& buffer, const memory_manager::committed_region& region)
{
	buffer.write<uint64_t>(region.length);
	buffer.write(region.pemissions);
}

static void deserialize(utils::buffer_deserializer& buffer, memory_manager::committed_region& region)
{
	region.length = static_cast<size_t>(buffer.read<uint64_t>());
	region.pemissions = buffer.read<memory_permission>();
}

static void serialize(utils::buffer_serializer& buffer, const memory_manager::reserved_region& region)
{
	buffer.write<uint64_t>(region.length);
	buffer.write_map(region.committed_regions);
}

static void deserialize(utils::buffer_deserializer& buffer, memory_manager::reserved_region& region)
{
	region.length = static_cast<size_t>(buffer.read<uint64_t>());
	buffer.read_map(region.committed_regions);
}

void memory_manager::serialize_memory_state(utils::buffer_serializer& buffer, const bool is_snapshot) const
{
	buffer.write_map(this->reserved_regions_);

	if (is_snapshot)
	{
		return;
	}

	std::vector<uint8_t> data{};

	for (const auto& reserved_region : this->reserved_regions_)
	{
		for (const auto& region : reserved_region.second.committed_regions)
		{
			data.resize(region.second.length);

			this->read_memory(region.first, data.data(), region.second.length);

			buffer.write(data.data(), region.second.length);
		}
	}
}

void memory_manager::deserialize_memory_state(utils::buffer_deserializer& buffer, const bool is_snapshot)
{
	if (!is_snapshot)
	{
		for (const auto& reserved_region : this->reserved_regions_)
		{
			for (const auto& region : reserved_region.second.committed_regions)
			{
				this->unmap_memory(region.first, region.second.length);
			}
		}
	}

	buffer.read_map(this->reserved_regions_);

	if (is_snapshot)
	{
		return;
	}

	std::vector<uint8_t> data{};

	for (const auto& reserved_region : this->reserved_regions_)
	{
		for (const auto& region : reserved_region.second.committed_regions)
		{
			data.resize(region.second.length);

			buffer.read(data.data(), region.second.length);

			this->map_memory(region.first, region.second.length, region.second.pemissions);
			this->write_memory(region.first, data.data(), region.second.length);
		}
	}
}

bool memory_manager::protect_memory(const uint64_t address, const size_t size, const memory_permission permissions,
                                    memory_permission* old_permissions)
{
	const auto entry = this->find_reserved_region(address);
	if (entry == this->reserved_regions_.end())
	{
		return false;
	}

	const auto end = address + size;
	const auto region_end = entry->first + entry->second.length;

	if (region_end < end)
	{
		throw std::runtime_error("Cross region protect not supported yet!");
	}

	std::optional<memory_permission> old_first_permissions{};

	auto& committed_regions = entry->second.committed_regions;
	split_regions(committed_regions, {address, end});

	for (auto& sub_region : committed_regions)
	{
		if (sub_region.first >= end)
		{
			break;
		}

		const auto sub_region_end = sub_region.first + sub_region.second.length;
		if (sub_region.first >= address && sub_region_end <= end)
		{
			if (!old_first_permissions.has_value())
			{
				old_first_permissions = sub_region.second.pemissions;
			}

			this->apply_memory_protection(sub_region.first, sub_region.second.length, permissions);
			sub_region.second.pemissions = permissions;
		}
	}

	if (old_permissions)
	{
		*old_permissions = old_first_permissions.value_or(memory_permission::none);
	}

	merge_regions(committed_regions);
	return true;
}

bool memory_manager::allocate_memory(const uint64_t address, const size_t size, const memory_permission permissions,
                                     const bool reserve_only)
{
	if (this->overlaps_reserved_region(address, size))
	{
		return false;
	}

	const auto entry = this->reserved_regions_.try_emplace(address, size).first;

	if (!reserve_only)
	{
		this->map_memory(address, size, permissions);
		entry->second.committed_regions[address] = committed_region{size, permissions};
	}

	return true;
}

bool memory_manager::commit_memory(const uint64_t address, const size_t size, const memory_permission permissions)
{
	const auto entry = this->find_reserved_region(address);
	if (entry == this->reserved_regions_.end())
	{
		return false;
	}

	const auto end = address + size;
	const auto region_end = entry->first + entry->second.length;

	if (region_end < end)
	{
		throw std::runtime_error("Cross region commit not supported yet!");
	}

	auto& committed_regions = entry->second.committed_regions;
	split_regions(committed_regions, {address, end});

	uint64_t last_region_start{};
	const committed_region* last_region{nullptr};

	for (auto& sub_region : committed_regions)
	{
		if (sub_region.first >= end)
		{
			break;
		}

		const auto sub_region_end = sub_region.first + sub_region.second.length;
		if (sub_region.first >= address && sub_region_end <= end)
		{
			const auto map_start = last_region ? (last_region_start + last_region->length) : address;
			const auto map_length = sub_region.first - map_start;

			if (map_length > 0)
			{
				this->map_memory(map_start, map_length, permissions);
				committed_regions[map_start] = committed_region{map_length, permissions};
			}

			last_region_start = sub_region.first;
			last_region = &sub_region.second;
		}
	}

	if (!last_region || (last_region_start + last_region->length) < end)
	{
		const auto map_start = last_region ? (last_region_start + last_region->length) : address;
		const auto map_length = end - map_start;

		this->map_memory(map_start, map_length, permissions);
		committed_regions[map_start] = committed_region{map_length, permissions};
	}

	merge_regions(committed_regions);
	return true;
}

bool memory_manager::decommit_memory(const uint64_t address, const size_t size)
{
	const auto entry = this->find_reserved_region(address);
	if (entry == this->reserved_regions_.end())
	{
		return false;
	}

	const auto end = address + size;
	const auto region_end = entry->first + entry->second.length;

	if (region_end < end)
	{
		throw std::runtime_error("Cross region decommit not supported yet!");
	}

	auto& committed_regions = entry->second.committed_regions;

	split_regions(committed_regions, {address, end});

	for (auto i = committed_regions.begin(); i != committed_regions.end();)
	{
		if (i->first >= end)
		{
			break;
		}

		const auto sub_region_end = i->first + i->second.length;
		if (i->first >= address && sub_region_end <= end)
		{
			this->unmap_memory(i->first, i->second.length);
			i = committed_regions.erase(i);
			continue;
		}

		++i;
	}

	return true;
}

bool memory_manager::release_memory(const uint64_t address, size_t size)
{
	const auto entry = this->reserved_regions_.find(address);
	if (entry == this->reserved_regions_.end())
	{
		return false;
	}

	if (!size)
	{
		size = entry->second.length;
	}

	if (size > entry->second.length)
	{
		throw std::runtime_error("Cross region release not supported yet!");
	}

	const auto end = address + size;
	auto& committed_regions = entry->second.committed_regions;

	split_regions(committed_regions, {end});

	for (auto i = committed_regions.begin(); i != committed_regions.end();)
	{
		if (i->first >= end)
		{
			break;
		}

		const auto sub_region_end = i->first + i->second.length;
		if (i->first >= address && sub_region_end <= end)
		{
			this->unmap_memory(i->first, i->second.length);
			i = committed_regions.erase(i);
		}
		else
		{
			++i;
		}
	}

	entry->second.length -= size;
	if (entry->second.length > 0)
	{
		this->reserved_regions_[address + size] = std::move(entry->second);
	}

	this->reserved_regions_.erase(entry);
	return true;
}

uint64_t memory_manager::find_free_allocation_base(const size_t size, const uint64_t start) const
{
	uint64_t start_address =
		std::max(MIN_ALLOCATION_ADDRESS, start ? start : 0x100000000ULL);

	for (const auto& region : this->reserved_regions_)
	{
		const auto region_end = region.first + region.second.length;
		if (region_end < start_address)
		{
			continue;
		}

		if (!regions_with_length_intersect(start_address, size, region.first, region.second.length))
		{
			return start_address;
		}

		start_address = page_align_up(region_end);
	}

	if (start_address + size <= MAX_ALLOCATION_ADDRESS)
	{
		return start_address;
	}

	return 0;
}

region_info memory_manager::get_region_info(const uint64_t address)
{
	region_info result{};
	result.start = MIN_ALLOCATION_ADDRESS;
	result.length = MAX_ALLOCATION_ADDRESS - result.start;
	result.pemissions = memory_permission::none;
	result.allocation_base = {};
	result.allocation_length = result.length;
	result.is_committed = false;
	result.is_reserved = false;

	if (this->reserved_regions_.empty())
	{
		return result;
	}

	auto upper_bound = this->reserved_regions_.upper_bound(address);
	if (upper_bound == this->reserved_regions_.begin())
	{
		result.length = upper_bound->first - result.start;
		return result;
	}

	const auto entry = --upper_bound;
	const auto lower_end = entry->first + entry->second.length;
	if (lower_end <= address)
	{
		result.start = lower_end;
		result.length = MAX_ALLOCATION_ADDRESS - result.start;
		return result;
	}

	// We have a reserved region
	const auto& reserved_region = entry->second;
	const auto& committed_regions = reserved_region.committed_regions;

	result.is_reserved = true;
	result.allocation_base = entry->first;
	result.allocation_length = reserved_region.length;
	result.start = result.allocation_base;
	result.length = result.allocation_length;

	if (committed_regions.empty())
	{
		return result;
	}

	auto committed_bound = committed_regions.upper_bound(address);
	if (committed_bound == committed_regions.begin())
	{
		result.length = committed_bound->first - result.start;
		return result;
	}

	const auto committed_entry = --committed_bound;
	const auto committed_lower_end = committed_entry->first + committed_entry->second.length;
	if (committed_lower_end <= address)
	{
		result.start = committed_lower_end;
		result.length = lower_end - result.start;
		return result;
	}

	result.is_committed = true;
	result.start = committed_entry->first;
	result.length = committed_entry->second.length;
	result.pemissions = committed_entry->second.pemissions;

	return result;
}

memory_manager::reserved_region_map::iterator memory_manager::find_reserved_region(const uint64_t address)
{
	if (this->reserved_regions_.empty())
	{
		return this->reserved_regions_.end();
	}

	auto upper_bound = this->reserved_regions_.upper_bound(address);
	if (upper_bound == this->reserved_regions_.begin())
	{
		return this->reserved_regions_.end();
	}

	const auto entry = --upper_bound;
	if (entry->first + entry->second.length <= address)
	{
		return this->reserved_regions_.end();
	}

	return entry;
}

bool memory_manager::overlaps_reserved_region(const uint64_t address, const size_t size) const
{
	for (const auto& region : this->reserved_regions_)
	{
		if (regions_with_length_intersect(address, size, region.first, region.second.length))
		{
			return true;
		}
	}

	return false;
}

```

`src/emulator/memory_manager.hpp`:

```hpp
#pragma once
#include <map>

#include "memory_region.hpp"
#include "address_utils.hpp"
#include "serialization.hpp"

struct region_info : basic_memory_region
{
	uint64_t allocation_base{};
	size_t allocation_length{};
	bool is_reserved{};
	bool is_committed{};
};

class memory_manager
{
public:
	struct committed_region
	{
		size_t length{};
		memory_permission pemissions{};
	};

	using committed_region_map = std::map<uint64_t, committed_region>;

	struct reserved_region
	{
		size_t length{};
		committed_region_map committed_regions{};
	};

	virtual ~memory_manager() = default;

	template <typename T>
	T read_memory(const uint64_t address)
	{
		T value{};
		this->read_memory(address, &value, sizeof(value));
		return value;
	}

	template <typename T>
	void write_memory(const uint64_t address, const T& value)
	{
		this->write_memory(address, &value, sizeof(value));
	}

	virtual void read_memory(uint64_t address, void* data, size_t size) const = 0;
	virtual bool try_read_memory(uint64_t address, void* data, size_t size) const = 0;
	virtual void write_memory(uint64_t address, const void* data, size_t size) = 0;

	bool protect_memory(uint64_t address, size_t size, memory_permission permissions,
	                    memory_permission* old_permissions = nullptr);

	bool allocate_memory(uint64_t address, size_t size, memory_permission permissions,
	                     bool reserve_only = false);

	bool commit_memory(uint64_t address, size_t size, memory_permission permissions);
	bool decommit_memory(uint64_t address, size_t size);

	bool release_memory(uint64_t address, size_t size);

	uint64_t find_free_allocation_base(size_t size, uint64_t start = 0) const;

	region_info get_region_info(uint64_t address);

	uint64_t allocate_memory(const size_t size, const memory_permission permissions, const bool reserve_only = false)
	{
		const auto allocation_base = this->find_free_allocation_base(size);
		if (!allocate_memory(allocation_base, size, permissions, reserve_only))
		{
			return 0;
		}

		return allocation_base;
	}

private:
	using reserved_region_map = std::map<uint64_t, reserved_region>;
	reserved_region_map reserved_regions_{};

	reserved_region_map::iterator find_reserved_region(uint64_t address);
	bool overlaps_reserved_region(uint64_t address, size_t size) const;

	virtual void map_memory(uint64_t address, size_t size, memory_permission permissions) = 0;
	virtual void unmap_memory(uint64_t address, size_t size) = 0;

	virtual void apply_memory_protection(uint64_t address, size_t size, memory_permission permissions) = 0;

protected:
	void serialize_memory_state(utils::buffer_serializer& buffer, bool is_snapshot) const;
	void deserialize_memory_state(utils::buffer_deserializer& buffer, bool is_snapshot);
};

```

`src/emulator/memory_permission.hpp`:

```hpp
#pragma once
#include <cstdint>

enum class memory_permission : uint8_t
{
	none = 0,
	read = 1 << 0,
	write = 1 << 1,
	exec = 1 << 2,
	read_write = read | write,
	all = read | write | exec
};

/*****************************************************************************
 *
 ****************************************************************************/

inline constexpr memory_permission
operator&(const memory_permission x, const memory_permission y)
{
	return static_cast<memory_permission>
		(static_cast<uint8_t>(x) & static_cast<uint8_t>(y));
}

inline constexpr memory_permission
operator|(const memory_permission x, const memory_permission y)
{
	return static_cast<memory_permission>
		(static_cast<uint8_t>(x) | static_cast<uint8_t>(y));
}

inline constexpr memory_permission
operator^(const memory_permission x, const memory_permission y)
{
	return static_cast<memory_permission>
		(static_cast<uint8_t>(x) ^ static_cast<uint8_t>(y));
}

inline constexpr memory_permission
operator~(memory_permission x)
{
	return static_cast<memory_permission>(~static_cast<uint8_t>(x));
}

inline memory_permission&
operator&=(memory_permission& x, const memory_permission y)
{
	x = x & y;
	return x;
}

inline memory_permission&
operator|=(memory_permission& x, const memory_permission y)
{
	x = x | y;
	return x;
}

inline memory_permission&
operator^=(memory_permission& x, const memory_permission y)
{
	x = x ^ y;
	return x;
}

```

`src/emulator/memory_region.hpp`:

```hpp
#pragma once
#include "memory_permission.hpp"

struct basic_memory_region
{
	uint64_t start{};
	size_t length{};
	memory_permission pemissions{};
};

struct memory_region : basic_memory_region
{
	bool committed{};
};

```

`src/emulator/scoped_hook.hpp`:

```hpp
#pragma once
#include "emulator.hpp"

class scoped_hook
{
public:
	scoped_hook() = default;

	scoped_hook(emulator& emu, emulator_hook* hook)
		: emu_(&emu)
		  , hook_(hook)
	{
	}

	~scoped_hook()
	{
		this->remove();
	}

	scoped_hook(const scoped_hook&) = delete;
	scoped_hook& operator=(const scoped_hook&) = delete;

	scoped_hook(scoped_hook&& obj) noexcept
	{
		this->operator=(std::move(obj));
	}

	scoped_hook& operator=(scoped_hook&& obj) noexcept
	{
		if (this != &obj)
		{
			this->remove();
			this->emu_ = obj.emu_;
			this->hook_ = obj.hook_;

			obj.hook_ = {};
		}

		return *this;
	}

	void remove()
	{
		if (this->hook_)
		{
			this->emu_->delete_hook(this->hook_);
			this->hook_ = {};
		}
	}

private:
	emulator* emu_{};
	emulator_hook* hook_{};
};

```

`src/emulator/serialization.hpp`:

```hpp
#pragma once

#include <span>
#include <vector>
#include <string_view>
#include <stdexcept>
#include <cstring>
#include <optional>

namespace utils
{
	class buffer_serializer;
	class buffer_deserializer;

	template <typename T>
	concept Serializable = requires(T a, const T ac, buffer_serializer& serializer, buffer_deserializer& deserializer)
	{
		{ ac.serialize(serializer) } -> std::same_as<void>;
		{ a.deserialize(deserializer) } -> std::same_as<void>;
	};

	/* Use concept instead, to prevent overhead of virtual function calls
	struct serializable
	{
		virtual ~serializable() = default;
		virtual void serialize(buffer_serializer& buffer) const = 0;
		virtual void deserialize(buffer_deserializer& buffer) = 0;
	};
	*/

	namespace detail
	{
		template <typename, typename = void>
		struct has_serialize_function : std::false_type
		{
		};

		template <typename T>
		struct has_serialize_function<T, std::void_t<decltype(serialize(std::declval<buffer_serializer&>(),
		                                                                std::declval<const T&>()))>>
			: std::true_type
		{
		};

		template <typename, typename = void>
		struct has_deserialize_function : std::false_type
		{
		};

		template <typename T>
		struct has_deserialize_function<T, std::void_t<decltype(deserialize(
			                                std::declval<buffer_deserializer&>(), std::declval<T&>()))>>
			: std::true_type
		{
		};
	}

	class buffer_deserializer
	{
	public:
		template <typename T>
		buffer_deserializer(const std::span<T> buffer)
			: buffer_(reinterpret_cast<const std::byte*>(buffer.data()), buffer.size() * sizeof(T))
		{
			static_assert(std::is_trivially_copyable_v<T>, "Type must be trivially copyable");
		}

		template <typename T>
		buffer_deserializer(const std::vector<T>& buffer)
			: buffer_deserializer(std::span(buffer))
		{
		}

		std::span<const std::byte> read_data(const size_t length)
		{
#ifndef NDEBUG
			const uint64_t real_old_size = this->offset_;
#endif

			if (this->offset_ + length > this->buffer_.size())
			{
				throw std::runtime_error("Out of bounds read from byte buffer");
			}

			const std::span result(this->buffer_.data() + this->offset_, length);
			this->offset_ += length;


#ifndef NDEBUG
			uint64_t old_size{};
			if (this->offset_ + sizeof(old_size) > this->buffer_.size())
			{
				throw std::runtime_error("Out of bounds read from byte buffer");
			}

			memcpy(&old_size, this->buffer_.data() + this->offset_, sizeof(old_size));
			if (old_size != real_old_size)
			{
				throw std::runtime_error("Reading from serialized buffer mismatches written data!");
			}

			this->offset_ += sizeof(old_size);
#endif

			return result;
		}

		void read(void* data, const size_t length)
		{
			const auto span = this->read_data(length);
			memcpy(data, span.data(), length);
		}

		template <typename T>
		void read(T& object)
		{
			if constexpr (Serializable<T>)
			{
				object.deserialize(*this);
			}
			else if constexpr (detail::has_deserialize_function<T>::value)
			{
				deserialize(*this, object);
			}
			else if constexpr (std::is_trivially_copyable_v<T>)
			{
				union
				{
					T* type_{};
					void* void_;
				} pointers;

				pointers.type_ = &object;

				this->read(pointers.void_, sizeof(object));
			}
			else
			{
				static_assert(std::false_type::value, "Key must be trivially copyable or implement serializable!");
				std::abort();
			}
		}

		template <typename T>
		T read()
		{
			T object{};
			this->read(object);
			return object;
		}

		template <typename T>
		void read_optional(std::optional<T>& val)
		{
			if (this->read<bool>())
			{
				val = this->read<T>();
			}
			else
			{
				val = {};
			}
		}

		template <typename T>
		void read_vector(std::vector<T>& result)
		{
			const auto size = this->read<uint64_t>();
			result.clear();
			result.reserve(size);

			for (uint64_t i = 0; i < size; ++i)
			{
				result.emplace_back(this->read<T>());
			}
		}

		template <typename T>
		std::vector<T> read_vector()
		{
			std::vector<T> result{};
			this->read_vector(result);
			return result;
		}

		template <typename Map>
		void read_map(Map& map)
		{
			using key_type = typename Map::key_type;
			using value_type = typename Map::mapped_type;

			map.clear();

			const auto size = this->read<uint64_t>();

			for (uint64_t i = 0; i < size; ++i)
			{
				auto key = this->read<key_type>();
				auto value = this->read<value_type>();

				map[std::move(key)] = std::move(value);
			}
		}

		template <typename Map>
		Map read_map()
		{
			Map map{};
			this->read_map(map);
			return map;
		}

		template <typename T = char>
		void read_string(std::basic_string<T>& result)
		{
			const auto size = this->read<uint64_t>();

			result.clear();
			result.reserve(size);

			for (uint64_t i = 0; i < size; ++i)
			{
				result.push_back(this->read<T>());
			}
		}

		template <typename T= char>
		std::basic_string<T> read_string()
		{
			std::basic_string<T> result{};
			this->read_string(result);
			return result;
		}

		size_t get_remaining_size() const
		{
			return this->buffer_.size() - offset_;
		}

		std::span<const std::byte> get_remaining_data()
		{
			return this->read_data(this->get_remaining_size());
		}

		size_t get_offset() const
		{
			return this->offset_;
		}

	private:
		size_t offset_{0};
		std::span<const std::byte> buffer_{};
	};

	class buffer_serializer
	{
	public:
		buffer_serializer() = default;

		void write(const void* buffer, const size_t length)
		{
#ifndef NDEBUG
			const uint64_t old_size = this->buffer_.size();
#endif

			const auto* byte_buffer = static_cast<const std::byte*>(buffer);
			this->buffer_.insert(this->buffer_.end(), byte_buffer, byte_buffer + length);

#ifndef NDEBUG
			const auto* security_buffer = reinterpret_cast<const std::byte*>(&old_size);
			this->buffer_.insert(this->buffer_.end(), security_buffer, security_buffer + sizeof(old_size));
#endif
		}

		void write(const buffer_serializer& object)
		{
			const auto& buffer = object.get_buffer();
			this->write(buffer.data(), buffer.size());
		}

		template <typename T>
		void write(const T& object)
		{
			if constexpr (Serializable<T>)
			{
				object.serialize(*this);
			}
			else if constexpr (detail::has_serialize_function<T>::value)
			{
				serialize(*this, object);
			}
			else if constexpr (std::is_trivially_copyable_v<T>)
			{
				union
				{
					const T* type_{};
					const void* void_;
				} pointers;

				pointers.type_ = &object;

				this->write(pointers.void_, sizeof(object));
			}
			else
			{
				static_assert(std::false_type::value, "Key must be trivially copyable or implement serializable!");
				std::abort();
			}
		}

		template <typename T>
		void write_optional(const std::optional<T>& val)
		{
			this->write(val.has_value());

			if (val.has_value())
			{
				this->write(*val);
			}
		}

		template <typename T>
		void write_span(const std::span<T> vec)
		{
			this->write(static_cast<uint64_t>(vec.size()));

			for (const auto& v : vec)
			{
				this->write(v);
			}
		}

		template <typename T>
		void write_vector(const std::vector<T> vec)
		{
			this->write_span(std::span(vec));
		}

		template <typename T>
		void write_string(const std::basic_string_view<T> str)
		{
			this->write_span<const T>(str);
		}

		template <typename T>
		void write_string(const std::basic_string<T>& str)
		{
			this->write_string(std::basic_string_view<T>(str));
		}

		template <typename Map>
		void write_map(const Map& map)
		{
			this->write<uint64_t>(map.size());

			for (const auto& entry : map)
			{
				this->write(entry.first);
				this->write(entry.second);
			}
		}

		const std::vector<std::byte>& get_buffer() const
		{
			return this->buffer_;
		}

		std::vector<std::byte> move_buffer()
		{
			return std::move(this->buffer_);
		}

	private:
		std::vector<std::byte> buffer_{};
	};

	template <>
	inline void buffer_deserializer::read<std::string>(std::string& object)
	{
		object = this->read_string<char>();
	}

	template <>
	inline void buffer_deserializer::read<std::wstring>(std::wstring& object)
	{
		object = this->read_string<wchar_t>();
	}

	template <>
	inline void buffer_serializer::write<std::string>(const std::string& object)
	{
		this->write_string(object);
	}

	template <>
	inline void buffer_serializer::write<std::wstring>(const std::wstring& object)
	{
		this->write_string(object);
	}
}

```

`src/emulator/typed_emulator.hpp`:

```hpp
#pragma once

#include "emulator.hpp"

template <typename PointerType, typename Register, Register InstructionPointer, Register
          StackPointer, typename HookableInstructions>
class typed_emulator : public emulator
{
public:
	using registers = Register;
	using pointer_type = PointerType;
	using hookable_instructions = HookableInstructions;

	static constexpr size_t pointer_size = sizeof(pointer_type);
	static constexpr registers stack_pointer = StackPointer;
	static constexpr registers instruction_pointer = InstructionPointer;

	void start_from_ip(const std::chrono::microseconds timeout = {}, const size_t count = 0)
	{
		this->start(this->read_instruction_pointer(), 0, timeout, count);
	}

	void write_register(registers reg, const void* value, const size_t size)
	{
		this->write_raw_register(static_cast<int>(reg), value, size);
	}

	void read_register(registers reg, void* value, const size_t size)
	{
		this->read_raw_register(static_cast<int>(reg), value, size);
	}

	template <typename T = pointer_type>
	T reg(const registers regid)
	{
		T value{};
		this->read_register(regid, &value, sizeof(value));
		return value;
	}

	template <typename T = pointer_type, typename S>
	void reg(const registers regid, const S& maybe_value)
	{
		T value = static_cast<T>(maybe_value);
		this->write_register(regid, &value, sizeof(value));
	}

	pointer_type read_instruction_pointer()
	{
		return this->reg(instruction_pointer);
	}

	pointer_type read_stack_pointer()
	{
		return this->reg(stack_pointer);
	}

	pointer_type read_stack(const size_t index)
	{
		pointer_type result{};
		const auto sp = this->read_stack_pointer();

		this->read_memory(sp + (index * pointer_size), &result, sizeof(result));

		return result;
	}

	void push_stack(const pointer_type& value)
	{
		const auto sp = this->read_stack_pointer() - pointer_size;
		this->reg(stack_pointer, sp);
		this->write_memory(sp, &value, sizeof(value));
	}

	pointer_type pop_stack()
	{
		pointer_type result{};
		const auto sp = this->read_stack_pointer();
		this->read_memory(sp, &result, sizeof(result));
		this->reg(stack_pointer, sp + pointer_size);

		return result;
	}

	emulator_hook* hook_instruction(hookable_instructions instruction_type, instruction_hook_callback callback)
	{
		return this->hook_instruction(static_cast<int>(instruction_type), std::move(callback));
	}

private:
	emulator_hook* hook_instruction(int instruction_type, instruction_hook_callback callback) override = 0;

	void read_raw_register(int reg, void* value, size_t size) override = 0;
	void write_raw_register(int reg, const void* value, size_t size) override = 0;
};

```

`src/emulator/x64_emulator.hpp`:

```hpp
#pragma once
#include "typed_emulator.hpp"
#include "x64_register.hpp"

enum class x64_hookable_instructions
{
	invalid,
	syscall,
	cpuid,
	rdtsc,
	rdtscp,
};

using x64_emulator = typed_emulator<uint64_t, x64_register, x64_register::rip,
                                    x64_register::rsp, x64_hookable_instructions>;

```

`src/emulator/x64_register.hpp`:

```hpp
#pragma once

enum class x64_register
{
	invalid = 0,
	ah,
	al,
	ax,
	bh,
	bl,
	bp,
	bpl,
	bx,
	ch,
	cl,
	cs,
	cx,
	dh,
	di,
	dil,
	dl,
	ds,
	dx,
	eax,
	ebp,
	ebx,
	ecx,
	edi,
	edx,
	eflags,
	eip,
	es = eip + 2,
	esi,
	esp,
	fpsw,
	fs,
	gs,
	ip,
	rax,
	rbp,
	rbx,
	rcx,
	rdi,
	rdx,
	rip,
	rsi = rip + 2,
	rsp,
	si,
	sil,
	sp,
	spl,
	ss,
	cr0,
	cr1,
	cr2,
	cr3,
	cr4,
	cr8 = cr4 + 4,
	dr0 = cr8 + 8,
	dr1,
	dr2,
	dr3,
	dr4,
	dr5,
	dr6,
	dr7,
	fp0 = dr7 + 9,
	fp1,
	fp2,
	fp3,
	fp4,
	fp5,
	fp6,
	fp7,
	k0,
	k1,
	k2,
	k3,
	k4,
	k5,
	k6,
	k7,
	mm0,
	mm1,
	mm2,
	mm3,
	mm4,
	mm5,
	mm6,
	mm7,
	r8,
	r9,
	r10,
	r11,
	r12,
	r13,
	r14,
	r15,
	st0,
	st1,
	st2,
	st3,
	st4,
	st5,
	st6,
	st7,
	xmm0,
	xmm1,
	xmm2,
	xmm3,
	xmm4,
	xmm5,
	xmm6,
	xmm7,
	xmm8,
	xmm9,
	xmm10,
	xmm11,
	xmm12,
	xmm13,
	xmm14,
	xmm15,
	xmm16,
	xmm17,
	xmm18,
	xmm19,
	xmm20,
	xmm21,
	xmm22,
	xmm23,
	xmm24,
	xmm25,
	xmm26,
	xmm27,
	xmm28,
	xmm29,
	xmm30,
	xmm31,
	ymm0,
	ymm1,
	ymm2,
	ymm3,
	ymm4,
	ymm5,
	ymm6,
	ymm7,
	ymm8,
	ymm9,
	ymm10,
	ymm11,
	ymm12,
	ymm13,
	ymm14,
	ymm15,
	ymm16,
	ymm17,
	ymm18,
	ymm19,
	ymm20,
	ymm21,
	ymm22,
	ymm23,
	ymm24,
	ymm25,
	ymm26,
	ymm27,
	ymm28,
	ymm29,
	ymm30,
	ymm31,
	zmm0,
	zmm1,
	zmm2,
	zmm3,
	zmm4,
	zmm5,
	zmm6,
	zmm7,
	zmm8,
	zmm9,
	zmm10,
	zmm11,
	zmm12,
	zmm13,
	zmm14,
	zmm15,
	zmm16,
	zmm17,
	zmm18,
	zmm19,
	zmm20,
	zmm21,
	zmm22,
	zmm23,
	zmm24,
	zmm25,
	zmm26,
	zmm27,
	zmm28,
	zmm29,
	zmm30,
	zmm31,
	r8b,
	r9b,
	r10b,
	r11b,
	r12b,
	r13b,
	r14b,
	r15b,
	r8d,
	r9d,
	r10d,
	r11d,
	r12d,
	r13d,
	r14d,
	r15d,
	r8w,
	r9w,
	r10w,
	r11w,
	r12w,
	r13w,
	r14w,
	r15w,
	idtr,
	gdtr,
	ldtr,
	tr,
	fpcw,
	fptag,
	msr,
	mxcsr,
	fs_base,
	gs_base,
	flags,
	rflags,
	fip,
	fcs,
	fdp,
	fds,
	fop,
	end, // Must be last
};

```

`src/fuzzer/CMakeLists.txt`:

```txt
file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  *.cpp
  *.hpp
  *.rc
)

list(SORT SRC_FILES)

add_executable(fuzzer ${SRC_FILES})

momo_assign_source_group(${SRC_FILES})

target_precompile_headers(fuzzer PRIVATE std_include.hpp)

target_link_libraries(fuzzer PRIVATE
  common
  fuzzing-engine
  windows-emulator
)

momo_strip_target(fuzzer)

```

`src/fuzzer/main.cpp`:

```cpp
#include "std_include.hpp"

#include <windows_emulator.hpp>
#include <fuzzer.hpp>

#include "utils/finally.hpp"

bool use_gdb = false;

namespace
{
	void run_emulation(windows_emulator& win_emu)
	{
		try
		{
			win_emu.logger.disable_output(true);
			win_emu.emu().start_from_ip();

			if (win_emu.process().exception_rip.has_value())
			{
				throw std::runtime_error("Exception!");
			}
		}
		catch (...)
		{
			win_emu.logger.disable_output(false);
			win_emu.logger.print(color::red, "Emulation failed at: 0x%llX\n", win_emu.emu().read_instruction_pointer());
			throw;
		}

		win_emu.logger.disable_output(false);
	}

	void forward_emulator(windows_emulator& win_emu)
	{
		const auto target = win_emu.process().executable->find_export("vulnerable");
		win_emu.emu().hook_memory_execution(target, 1, [&](uint64_t, size_t, uint64_t)
		{
			win_emu.emu().stop();
		});

		run_emulation(win_emu);
	}

	struct fuzzer_executer : fuzzer::executer
	{
		windows_emulator emu{};
		std::span<const std::byte> emulator_data{};
		std::unordered_set<uint64_t> visited_blocks{};
		const std::function<fuzzer::coverage_functor>* handler{nullptr};


		fuzzer_executer(std::span<const std::byte> data)
			: emulator_data(data)
		{
			emu.fuzzing = true;
			emu.emu().hook_basic_block([&](const basic_block& block)
			{
				if (this->handler && visited_blocks.emplace(block.address).second)
				{
					(*this->handler)(block.address);
				}
			});

			utils::buffer_deserializer deserializer{emulator_data};
			emu.deserialize(deserializer);
			emu.save_snapshot();

			const auto ret = emu.emu().read_stack(0);

			emu.emu().hook_memory_execution(ret, 1, [&](uint64_t, size_t, uint64_t)
			{
				emu.emu().stop();
			});
		}

		void restore_emulator()
		{
			/*utils::buffer_deserializer deserializer{ emulator_data };
			emu.deserialize(deserializer);*/
			emu.restore_snapshot();
		}

		fuzzer::execution_result execute(std::span<const uint8_t> data,
		                                 const std::function<fuzzer::coverage_functor>& coverage_handler) override
		{
			//printf("Input size: %zd\n", data.size());
			this->handler = &coverage_handler;
			this->visited_blocks.clear();

			restore_emulator();

			const auto memory = emu.emu().allocate_memory(page_align_up(std::max(data.size(), 1ULL)),
			                                              memory_permission::read_write);
			emu.emu().write_memory(memory, data.data(), data.size());

			emu.emu().reg(x64_register::rcx, memory);
			emu.emu().reg<uint64_t>(x64_register::rdx, data.size());

			try
			{
				run_emulation(emu);
				return fuzzer::execution_result::success;
			}
			catch (...)
			{
				return fuzzer::execution_result::error;
			}
		}
	};

	struct my_fuzzer_handler : fuzzer::handler
	{
		std::vector<std::byte> emulator_state{};
		std::atomic_bool stop_fuzzing{false};

		my_fuzzer_handler(std::vector<std::byte> emulator_state)
			: emulator_state(std::move(emulator_state))
		{
		}

		std::unique_ptr<fuzzer::executer> make_executer() override
		{
			return std::make_unique<fuzzer_executer>(emulator_state);
		}

		bool stop() override
		{
			return stop_fuzzing;
		}
	};

	void run_fuzzer(const windows_emulator& base_emulator)
	{
		const auto concurrency = std::thread::hardware_concurrency() + 2;

		utils::buffer_serializer serializer{};
		base_emulator.serialize(serializer);

		my_fuzzer_handler handler{serializer.move_buffer()};

		fuzzer::run(handler, concurrency);
	}

	void run(const std::string_view application)
	{
		windows_emulator win_emu{
			application, {}
		};

		forward_emulator(win_emu);
		run_fuzzer(win_emu);
	}
}

int main(const int argc, char** argv)
{
	if (argc <= 1)
	{
		puts("Application not specified!");
		return 1;
	}

	//setvbuf(stdout, nullptr, _IOFBF, 0x10000);
	if (argc > 2 && argv[1] == "-d"s)
	{
		use_gdb = true;
	}

	try
	{
		do
		{
			run(argv[use_gdb ? 2 : 1]);
		}
		while (use_gdb);

		return 0;
	}
	catch (std::exception& e)
	{
		puts(e.what());

#if defined(_WIN32) && 0
		MessageBoxA(nullptr, e.what(), "ERROR", MB_ICONERROR);
#endif
	}

	return 1;
}

#ifdef _WIN32
int WINAPI WinMain(HINSTANCE, HINSTANCE, PSTR, int)
{
	return main(__argc, __argv);
}
#endif

```

`src/fuzzer/resource.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "windows.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "#include ""windows.h""\r\n"
    "\0"
END

2 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,0
 PRODUCTVERSION 1,0,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE VFT_DLL
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "momo5502"
            VALUE "FileDescription", "Windows Emulator"
            VALUE "FileVersion", "1.0.0.0"
            VALUE "InternalName", "emulator"
            VALUE "LegalCopyright", "All rights reserved."
            VALUE "OriginalFilename", "emulator.exe"
            VALUE "ProductName", "emulator"
            VALUE "ProductVersion", "1.0.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

/////////////////////////////////////////////////////////////////////////////
//
// Binary Data
//

GLFW_ICON       ICON   "resources/icon.ico"


#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`src/fuzzer/std_include.hpp`:

```hpp
#pragma once

#ifdef _WIN32
#pragma warning(push)
#pragma warning(disable: 4005)
#pragma warning(disable: 4127)
#pragma warning(disable: 4201)
#pragma warning(disable: 4244)
#pragma warning(disable: 4245)
#pragma warning(disable: 4324)
#pragma warning(disable: 4458)
#pragma warning(disable: 4471)
#pragma warning(disable: 4505)
#pragma warning(disable: 4702)
#pragma warning(disable: 4996)
#pragma warning(disable: 5054)
#pragma warning(disable: 6011)
#pragma warning(disable: 6297)
#pragma warning(disable: 6385)
#pragma warning(disable: 6386)
#pragma warning(disable: 6387)
#pragma warning(disable: 26110)
#pragma warning(disable: 26451)
#pragma warning(disable: 26444)
#pragma warning(disable: 26451)
#pragma warning(disable: 26489)
#pragma warning(disable: 26495)
#pragma warning(disable: 26498)
#pragma warning(disable: 26812)
#pragma warning(disable: 28020)

#define WIN32_LEAN_AND_MEAN
#define NOMINMAX

#include <map>
#include <set>
#include <list>
#include <array>
#include <deque>
#include <queue>
#include <thread>
#include <ranges>
#include <atomic>
#include <vector>
#include <mutex>
#include <string>
#include <chrono>
#include <memory>
#include <fstream>
#include <functional>
#include <filesystem>
#include <optional>
#include <stdexcept>
#include <string_view>
#include <unordered_set>
#include <condition_variable>

#include <cassert>

#define NTDDI_WIN11_GE 0
#define PHNT_VERSION PHNT_WIN11
#include <phnt_windows.h>
#include <phnt.h>
#include <ntgdi.h>

#ifdef _WIN32
#pragma warning(pop)
#endif

#ifdef max
#undef max
#endif

#ifdef min
#undef min
#endif
#endif

using namespace std::literals;

```

`src/fuzzing-engine/CMakeLists.txt`:

```txt
file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  *.cpp
  *.hpp
  *.rc
)

list(SORT SRC_FILES)

add_library(fuzzing-engine ${SRC_FILES})

momo_assign_source_group(${SRC_FILES})

target_link_libraries(fuzzing-engine PRIVATE
  common
)

target_include_directories(fuzzing-engine INTERFACE
    "${CMAKE_CURRENT_LIST_DIR}"
)

momo_strip_target(fuzzing-engine)

```

`src/fuzzing-engine/fuzzer.cpp`:

```cpp
#include "fuzzer.hpp"
#include "input_generator.hpp"

namespace fuzzer
{
	namespace
	{
		class fuzzing_context
		{
		public:
			fuzzing_context(input_generator& generator, handler& handler)
				: generator(generator)
				  , handler(handler)
			{
			}

			void stop()
			{
				this->stop_ = true;
			}

			bool should_stop()
			{
				if (this->stop_)
				{
					return true;
				}

				if (!handler.stop())
				{
					return false;
				}

				this->stop_ = true;
				return true;
			}

			input_generator& generator;
			handler& handler;
			std::atomic_uint64_t executions{0};

		private:
			std::atomic_bool stop_{false};
		};

		void perform_fuzzing_iteration(fuzzing_context& context, executer& executer)
		{
			++context.executions;
			context.generator.access_input([&](const std::span<const uint8_t> input)
			{
				uint64_t score{0};
				const auto result = executer.execute(input, [&](uint64_t)
				{
					++score;
				});

				if (result == execution_result::error)
				{
					printf("Found error!\n");
					context.stop();
				}

				return score;
			});
		}

		void worker(fuzzing_context& context)
		{
			const auto executer = context.handler.make_executer();

			while (!context.should_stop())
			{
				perform_fuzzing_iteration(context, *executer);
			}
		}

		struct worker_pool
		{
			fuzzing_context* context_{nullptr};
			std::vector<std::thread> workers_{};

			worker_pool(fuzzing_context& context, const size_t concurrency)
				: context_(&context)
			{
				this->workers_.reserve(concurrency);

				for (size_t i = 0; i < concurrency; ++i)
				{
					this->workers_.emplace_back([&context]
					{
						worker(context);
					});
				}
			}

			~worker_pool()
			{
				if (this->workers_.empty())
				{
					return;
				}

				this->context_->stop();

				for (auto& w : this->workers_)
				{
					w.join();
				}
			}
		};
	}

	void run(handler& handler, const size_t concurrency)
	{
		input_generator generator{};
		fuzzing_context context{generator, handler};
		worker_pool pool{context, concurrency};

		while (!context.should_stop())
		{
			std::this_thread::sleep_for(std::chrono::seconds{1});

			const auto executions = context.executions.exchange(0);
			const auto highest_scorer = context.generator.get_highest_scorer();
			const auto avg_score = context.generator.get_average_score();
			printf("Executions/s: %lld - Score: %llX - Avg: %.3f\n", executions, highest_scorer.score, avg_score);
		}
	}
}

```

`src/fuzzing-engine/fuzzer.hpp`:

```hpp
#pragma once
#include <span>
#include <memory>
#include <thread>
#include <cstdint>
#include <functional>

namespace fuzzer
{
	using coverage_functor = void(uint64_t address);

	enum class execution_result
	{
		success,
		error,
	};

	struct executer
	{
		virtual ~executer() = default;

		virtual execution_result execute(std::span<const uint8_t> data,
			const std::function<coverage_functor>& coverage_handler) = 0;
	};

	struct handler
	{
		virtual ~handler() = default;

		virtual std::unique_ptr<executer> make_executer() = 0;

		virtual bool stop()
		{
			return false;
		}
	};

	void run(handler& handler, size_t concurrency = std::thread::hardware_concurrency());
}

```

`src/fuzzing-engine/input_generator.cpp`:

```cpp
#include "input_generator.hpp"

#include <cassert>

namespace fuzzer
{
	namespace
	{
		constexpr size_t MAX_TOP_SCORER = 20;

		void mutate_input(random_generator& rng, std::vector<uint8_t>& input)
		{
			if (input.empty() || rng.get(3) == 0)
			{
				const auto new_bytes = rng.get_geometric<size_t>() + 1;
				input.resize(input.size() + new_bytes);
			}
			else if (rng.get(10) == 0)
			{
				const auto remove_bytes = rng.get_geometric<size_t>() % input.size();
				input.resize(input.size() - remove_bytes);
			}

			const auto mutations = (rng.get_geometric<size_t>() + 1) % input.size();


			for (size_t i = 0; i < mutations; ++i)
			{
				const auto index = rng.get<size_t>(input.size());
				input[index] = rng.get<uint8_t>();
			}
		}
	}

	input_generator::input_generator() = default;

	std::vector<uint8_t> input_generator::generate_next_input()
	{
		std::vector<uint8_t> input{};
		std::unique_lock lock{this->mutex_};

		if (!this->top_scorer_.empty())
		{
			const auto index = this->rng.get<size_t>() % this->top_scorer_.size();
			input = this->top_scorer_[index].data;
		}

		mutate_input(this->rng, input);

		return input;
	}

	void input_generator::access_input(const std::function<input_handler>& handler)
	{
		auto next_input = this->generate_next_input();
		const auto score = handler(next_input);

		input_entry e{};
		e.data = std::move(next_input);
		e.score = score;

		this->store_input_entry(std::move(e));
	}

	input_entry input_generator::get_highest_scorer()
	{
		std::unique_lock lock{this->mutex_};
		return this->highest_scorer_;
	}

	double input_generator::get_average_score()
	{
		std::unique_lock lock{this->mutex_};

		double score{0.0};
		for (const auto& e : this->top_scorer_)
		{
			score += static_cast<double>(e.score);
		}

		return score / static_cast<double>(this->top_scorer_.size());
	}

	void input_generator::store_input_entry(input_entry entry)
	{
		std::unique_lock lock{this->mutex_};

		if (entry.score < this->lowest_score && this->rng.get(40) != 0)
		{
			return;
		}

		if (entry.score > this->highest_scorer_.score)
		{
			this->highest_scorer_ = entry;
		}

		if (this->top_scorer_.size() < MAX_TOP_SCORER)
		{
			this->top_scorer_.emplace_back(std::move(entry));
			return;
		}

		const auto insert_at_random = this->rng.get(10) == 0;
		const auto index = insert_at_random
			                   ? (this->rng.get<size_t>() % this->top_scorer_.size())
			                   : this->lowest_scorer;

		this->top_scorer_[index] = std::move(entry);

		this->lowest_score = this->top_scorer_[0].score;
		this->lowest_scorer = 0;

		for (size_t i = 1; i < this->top_scorer_.size(); ++i)
		{
			if (this->top_scorer_[i].score < this->lowest_score)
			{
				this->lowest_score = this->top_scorer_[i].score;
				this->lowest_scorer = i;
			}
		}
	}
}

```

`src/fuzzing-engine/input_generator.hpp`:

```hpp
#pragma once
#include <mutex>
#include <vector>
#include <optional>
#include <functional>

#include "random_generator.hpp"

namespace fuzzer
{
	using input_score = uint64_t;
	using input_handler = input_score(std::span<const uint8_t>);

	struct input_entry
	{
		std::vector<uint8_t> data{};
		input_score score{};
	};

	class input_generator
	{
	public:
		input_generator();

		void access_input(const std::function<input_handler>& handler);

		input_entry get_highest_scorer();
		double get_average_score();

	private:
		std::mutex mutex_{};
		random_generator rng{};

		std::vector<input_entry> top_scorer_{};
		input_score lowest_score{0};
		size_t lowest_scorer{0};

		input_entry highest_scorer_{};

		std::vector<uint8_t> generate_next_input();

		void store_input_entry(input_entry entry);
	};
}

```

`src/fuzzing-engine/random_generator.cpp`:

```cpp
#include "random_generator.hpp"

namespace fuzzer
{
	random_generator::random_generator()
		: rng_(std::random_device()())
	{
	}

	std::mt19937::result_type random_generator::generate_number()
	{
		return this->distribution_(this->rng_);
	}

	void random_generator::fill(void* data, const size_t size)
	{
		this->fill(std::span(static_cast<uint8_t*>(data), size));
	}

	void random_generator::fill(std::span<uint8_t> data)
	{
		size_t i = 0;
		while (i < data.size())
		{
			const auto number = this->generate_number();

			const auto remaining_data = data.size() - i;
			const auto data_to_fill = std::min(remaining_data, sizeof(number));

			memcpy(data.data() + i, &number, data_to_fill);
			i += data_to_fill;
		}
	}
}

```

`src/fuzzing-engine/random_generator.hpp`:

```hpp
#pragma once
#include <span>
#include <random>
#include <cstdint>

namespace fuzzer
{
	class random_generator
	{
	public:
		random_generator();

		void fill(std::span<uint8_t> data);
		void fill(void* data, size_t size);

		template <typename T>
			requires(std::is_trivially_copyable_v<T>)
		T get()
		{
			T value{};
			this->fill(&value, sizeof(value));
			return value;
		}

		template <typename T>
		T get(const T& max)
		{
			return this->get<T>() % max;
		}

		template <typename T>
		T get(T min, T max)
		{
			if (max < min)
			{
				std::swap(max, min);
			}

			const auto diff = max - min;

			return (this->get<T>() % diff) + min;
		}

		template <typename T>
		T get_geometric()
		{
			T value{0};

			while (this->get<bool>())
			{
				++value;
			}

			return value;
		}

	private:
		std::mt19937 rng_;
		std::uniform_int_distribution<std::mt19937::result_type> distribution_{};

		std::mt19937::result_type generate_number();
	};

	template <>
	inline bool random_generator::get<bool>()
	{
		return (this->generate_number() & 1) != 0;
	}
}

```

`src/unicorn-emulator/CMakeLists.txt`:

```txt
file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  *.cpp
  *.hpp
  *.rc
)

list(SORT SRC_FILES)

add_library(unicorn-emulator SHARED ${SRC_FILES})

target_include_directories(unicorn-emulator INTERFACE
    "${CMAKE_CURRENT_LIST_DIR}"
)

target_link_libraries(unicorn-emulator PUBLIC emulator)
target_link_libraries(unicorn-emulator PRIVATE unicorn)

```

`src/unicorn-emulator/function_wrapper.hpp`:

```hpp
#pragma once

#include <memory>
#include <functional>

#include "object.hpp"

template <typename ReturnType, typename... Args>
class function_wrapper : public object
{
public:
	using user_data_pointer = void*;
	using c_function_type = ReturnType(Args..., user_data_pointer);
	using functor_type = std::function<ReturnType(Args...)>;

	function_wrapper(functor_type functor)
		: functor_(std::make_unique<functor_type>(std::move(functor)))
	{
	}

	c_function_type* get_c_function() const
	{
		return +[](Args... args, user_data_pointer user_data) -> ReturnType
		{
			return (*static_cast<functor_type*>(user_data))(std::forward<Args>(args)...);
		};
	}

	void* get_function() const
	{
		return reinterpret_cast<void*>(this->get_c_function());
	}

	user_data_pointer get_user_data() const
	{
		return this->functor_.get();
	}

private:
	std::unique_ptr<functor_type> functor_{};
};

```

`src/unicorn-emulator/object.hpp`:

```hpp
#pragma once

struct object
{
	object() = default;
	virtual ~object() = default;

	object(object&&) = default;
	object(const object&) = default;
	object& operator=(object&&) = default;
	object& operator=(const object&) = default;
};

```

`src/unicorn-emulator/unicorn.hpp`:

```hpp
#pragma once

#pragma warning(push)
#pragma warning(disable: 4505)

#ifdef __clang__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-function"
#endif

#define NOMINMAX
#include <unicorn/unicorn.h>

#ifdef __clang__
#pragma GCC diagnostic pop
#endif

#pragma warning(pop)

#include <stdexcept>

namespace unicorn
{
	struct unicorn_error : std::runtime_error
	{
		unicorn_error(const uc_err error_code)
			: std::runtime_error(uc_strerror(error_code))
			  , code(error_code)
		{
		}

		uc_err code{};
	};

	inline void throw_if_unicorn_error(const uc_err error_code)
	{
		if (error_code != UC_ERR_OK)
		{
			throw unicorn_error(error_code);
		}
	}

	inline void uce(const uc_err error_code)
	{
		throw_if_unicorn_error(error_code);
	}
}

```

`src/unicorn-emulator/unicorn_hook.hpp`:

```hpp
#pragma once

#include "unicorn.hpp"

namespace unicorn
{
	class unicorn_hook
	{
	public:
		unicorn_hook() = default;

		unicorn_hook(uc_engine* uc)
			: unicorn_hook(uc, {})
		{
		}

		unicorn_hook(uc_engine* uc, const uc_hook hook)
			: uc_(uc)
			  , hook_(hook)
		{
		}

		~unicorn_hook()
		{
			release();
		}

		unicorn_hook(const unicorn_hook&) = delete;
		unicorn_hook& operator=(const unicorn_hook&) = delete;


		unicorn_hook(unicorn_hook&& obj) noexcept
		{
			this->operator=(std::move(obj));
		}

		uc_hook* make_reference()
		{
			if (!this->uc_)
			{
				throw std::runtime_error("Cannot make reference on default constructed hook");
			}

			this->release();
			return &this->hook_;
		}

		unicorn_hook& operator=(unicorn_hook&& obj) noexcept
		{
			if (this != &obj)
			{
				this->release();

				this->uc_ = obj.uc_;
				this->hook_ = obj.hook_;

				obj.hook_ = {};
				obj.uc_ = {};
			}

			return *this;
		}

		void release()
		{
			if (this->hook_ && this->uc_)
			{
				uc_hook_del(this->uc_, this->hook_);
				this->hook_ = {};
			}
		}

	private:
		uc_engine* uc_{};
		uc_hook hook_{};
	};
}

```

`src/unicorn-emulator/unicorn_memory_regions.hpp`:

```hpp
#pragma once

#include <span>

#include "unicorn.hpp"

namespace unicorn
{
	class unicorn_memory_regions
	{
	public:
		unicorn_memory_regions(uc_engine* uc)
		{
			uce(uc_mem_regions(uc, &this->regions_, &this->count_));
		}


		~unicorn_memory_regions()
		{
			this->release();
		}

		unicorn_memory_regions(const unicorn_memory_regions&) = delete;
		unicorn_memory_regions& operator=(const unicorn_memory_regions&) = delete;

		unicorn_memory_regions(unicorn_memory_regions&& obj) noexcept
		{
			this->operator=(std::move(obj));
		}

		unicorn_memory_regions& operator=(unicorn_memory_regions&& obj) noexcept
		{
			if (this != &obj)
			{
				this->release();

				this->count_ = obj.count_;
				this->regions_ = obj.regions_;

				obj.count_ = {};
				obj.regions_ = nullptr;
			}

			return *this;
		}

		std::span<uc_mem_region> get_span() const
		{
			return {this->regions_, this->count_};
		}

	private:
		uint32_t count_{};
		uc_mem_region* regions_{};

		void release()
		{
			if (this->regions_)
			{
				uc_free(regions_);
			}

			this->count_ = {};
			this->regions_ = nullptr;
		}
	};
}

```

`src/unicorn-emulator/unicorn_x64_emulator.cpp`:

```cpp
#define UNICORN_EMULATOR_IMPL
#include "unicorn_x64_emulator.hpp"

#include "unicorn_memory_regions.hpp"
#include "unicorn_hook.hpp"

#include "function_wrapper.hpp"

namespace unicorn
{
	namespace
	{
		static_assert(static_cast<uint32_t>(memory_permission::none) == UC_PROT_NONE);
		static_assert(static_cast<uint32_t>(memory_permission::read) == UC_PROT_READ);
		static_assert(static_cast<uint32_t>(memory_permission::exec) == UC_PROT_EXEC);
		static_assert(static_cast<uint32_t>(memory_permission::all) == UC_PROT_ALL);

		static_assert(static_cast<uint32_t>(x64_register::end) == UC_X86_REG_ENDING);

		uc_x86_insn map_hookable_instruction(const x64_hookable_instructions instruction)
		{
			switch (instruction)
			{
			case x64_hookable_instructions::syscall:
				return UC_X86_INS_SYSCALL;
			case x64_hookable_instructions::cpuid:
				return UC_X86_INS_CPUID;
			case x64_hookable_instructions::rdtsc:
				return UC_X86_INS_RDTSC;
			case x64_hookable_instructions::rdtscp:
				return UC_X86_INS_RDTSCP;
			default:
				throw std::runtime_error("Bad instruction for mapping");
			}
		}

		memory_violation_type map_memory_violation_type(const uc_mem_type mem_type)
		{
			switch (mem_type)
			{
			case UC_MEM_READ_PROT:
			case UC_MEM_WRITE_PROT:
			case UC_MEM_FETCH_PROT:
				return memory_violation_type::protection;
			case UC_MEM_READ_UNMAPPED:
			case UC_MEM_WRITE_UNMAPPED:
			case UC_MEM_FETCH_UNMAPPED:
				return memory_violation_type::unmapped;
			default:
				throw std::runtime_error("Memory type does not constitute a violation");
			}
		}

		memory_operation map_memory_operation(const uc_mem_type mem_type)
		{
			switch (mem_type)
			{
			case UC_MEM_READ:
			case UC_MEM_READ_PROT:
			case UC_MEM_READ_UNMAPPED:
				return memory_operation::read;
			case UC_MEM_WRITE:
			case UC_MEM_WRITE_PROT:
			case UC_MEM_WRITE_UNMAPPED:
				return memory_operation::write;
			case UC_MEM_FETCH:
			case UC_MEM_FETCH_PROT:
			case UC_MEM_FETCH_UNMAPPED:
				return memory_operation::exec;
			default:
				return memory_operation::none;
			}
		}

		struct hook_object : object
		{
			emulator_hook* as_opaque_hook()
			{
				return reinterpret_cast<emulator_hook*>(this);
			}
		};

		class hook_container : public hook_object
		{
		public:
			template <typename T>
				requires(std::is_base_of_v<object, T>
					&& std::is_move_constructible_v<T>)
			void add(T data, unicorn_hook hook)
			{
				hook_entry entry{};

				entry.data = std::make_unique<T>(std::move(data));
				entry.hook = std::move(hook);

				this->hooks_.emplace_back(std::move(entry));
			}

		private:
			struct hook_entry
			{
				std::unique_ptr<object> data{};
				unicorn_hook hook{};
			};

			std::vector<hook_entry> hooks_;
		};

		class uc_context_serializer
		{
		public:
			uc_context_serializer(uc_engine* uc, const bool in_place)
				: uc_(uc)
			{
				uc_ctl_context_mode(uc, UC_CTL_CONTEXT_CPU | (in_place ? UC_CTL_CONTEXT_MEMORY : 0));

				this->size_ = uc_context_size(uc);
				uce(uc_context_alloc(uc, &this->context_));
			}

			~uc_context_serializer()
			{
				if (this->context_)
				{
					(void)uc_context_free(this->context_);
				}
			}

			void serialize(utils::buffer_serializer& buffer) const
			{
				uce(uc_context_save(this->uc_, this->context_));
				buffer.write(this->context_, this->size_);
			}

			void deserialize(utils::buffer_deserializer& buffer) const
			{
				buffer.read(this->context_, this->size_);
				uce(uc_context_restore(this->uc_, this->context_));
			}

			uc_context_serializer(uc_context_serializer&&) = delete;
			uc_context_serializer(const uc_context_serializer&) = delete;
			uc_context_serializer& operator=(uc_context_serializer&&) = delete;
			uc_context_serializer& operator=(const uc_context_serializer&) = delete;

		private:
			uc_engine* uc_{};
			uc_context* context_{};
			size_t size_{};
		};

		void add_read_hook(uc_engine* uc, const uint64_t address, const size_t size, hook_container& container,
		                   const std::shared_ptr<complex_memory_hook_callback>& callback)
		{
			function_wrapper<void, uc_engine*, uc_mem_type, uint64_t, int, int64_t> wrapper(
				[callback](uc_engine*, const uc_mem_type type, const uint64_t address, const int size,
				           const int64_t)
				{
					const auto operation = map_memory_operation(type);
					if (operation != memory_permission::none)
					{
						(*callback)(address, static_cast<uint64_t>(size), 0, operation);
					}
				});

			unicorn_hook hook{uc};

			uce(uc_hook_add(uc, hook.make_reference(), UC_HOOK_MEM_READ, wrapper.get_function(),
			                wrapper.get_user_data(), address, address + size));

			container.add(std::move(wrapper), std::move(hook));
		}

		void add_write_hook(uc_engine* uc, const uint64_t address, const size_t size, hook_container& container,
		                    const std::shared_ptr<complex_memory_hook_callback>& callback)
		{
			function_wrapper<void, uc_engine*, uc_mem_type, uint64_t, int, int64_t> wrapper(
				[callback](uc_engine*, const uc_mem_type type, const uint64_t address, const int size,
				           const uint64_t value)
				{
					const auto operation = map_memory_operation(type);
					if (operation != memory_permission::none)
					{
						(*callback)(address, static_cast<uint64_t>(size), value, operation);
					}
				});

			unicorn_hook hook{uc};

			uce(uc_hook_add(uc, hook.make_reference(), UC_HOOK_MEM_WRITE, wrapper.get_function(),
			                wrapper.get_user_data(), address, address + size));

			container.add(std::move(wrapper), std::move(hook));
		}

		void add_exec_hook(uc_engine* uc, const uint64_t address, const size_t size, hook_container& container,
		                   const std::shared_ptr<complex_memory_hook_callback>& callback)
		{
			function_wrapper<void, uc_engine*, uint64_t, uint32_t> wrapper(
				[callback](uc_engine*, const uint64_t address, const uint32_t size)
				{
					(*callback)(address, size, 0, memory_permission::exec);
				});

			unicorn_hook hook{uc};

			uce(uc_hook_add(uc, hook.make_reference(), UC_HOOK_CODE, wrapper.get_function(),
			                wrapper.get_user_data(), address, address + size));

			container.add(std::move(wrapper), std::move(hook));
		}

		basic_block map_block(const uc_tb& translation_block)
		{
			basic_block block{};

			block.address = translation_block.pc;
			block.instruction_count = translation_block.icount;
			block.size = translation_block.size;

			return block;
		}

		class unicorn_x64_emulator : public x64_emulator
		{
		public:
			unicorn_x64_emulator()
			{
				uce(uc_open(UC_ARCH_X86, UC_MODE_64, &this->uc_));
			}

			~unicorn_x64_emulator() override
			{
				this->hooks_.clear();
				uc_close(this->uc_);
			}

			void start(uint64_t start, const uint64_t end, std::chrono::microseconds timeout,
			           const size_t count) override
			{
				while (true)
				{
					if (timeout.count() < 0)
					{
						timeout = {};
					}

					this->retry_after_violation_ = false;
					const auto res = uc_emu_start(*this, start, end, static_cast<uint64_t>(timeout.count()), count);
					if (res == UC_ERR_OK)
					{
						return;
					}

					const auto is_violation = res == UC_ERR_READ_UNMAPPED || //
						res == UC_ERR_WRITE_UNMAPPED || //
						res == UC_ERR_FETCH_UNMAPPED || //
						res == UC_ERR_READ_PROT || //
						res == UC_ERR_WRITE_PROT || //
						res == UC_ERR_FETCH_PROT;

					if (is_violation && this->retry_after_violation_)
					{
						start = this->read_instruction_pointer();
						continue;
					}

					uce(res);
				}
			}

			void stop() override
			{
				uce(uc_emu_stop(*this));
			}

			void write_raw_register(const int reg, const void* value, const size_t size) override
			{
				size_t result_size = size;
				uce(uc_reg_write2(*this, reg, value, &result_size));

				if (size < result_size)
				{
					throw std::runtime_error(
						"Register size mismatch: " + std::to_string(size) + " != " + std::to_string(result_size));
				}
			}

			void read_raw_register(const int reg, void* value, const size_t size) override
			{
				size_t result_size = size;
				memset(value, 0, size);
				uce(uc_reg_read2(*this, reg, value, &result_size));

				if (size < result_size)
				{
					throw std::runtime_error(
						"Register size mismatch: " + std::to_string(size) + " != " + std::to_string(result_size));
				}
			}

			void map_memory(const uint64_t address, const size_t size, memory_permission permissions) override
			{
				uce(uc_mem_map(*this, address, size, static_cast<uint32_t>(permissions)));
			}

			void unmap_memory(const uint64_t address, const size_t size) override
			{
				uce(uc_mem_unmap(*this, address, size));
			}

			bool try_read_memory(const uint64_t address, void* data, const size_t size) const override
			{
				return uc_mem_read(*this, address, data, size) == UC_ERR_OK;
			}

			void read_memory(const uint64_t address, void* data, const size_t size) const override
			{
				uce(uc_mem_read(*this, address, data, size));
			}

			void write_memory(const uint64_t address, const void* data, const size_t size) override
			{
				uce(uc_mem_write(*this, address, data, size));
			}

			void apply_memory_protection(const uint64_t address, const size_t size,
			                             memory_permission permissions) override
			{
				uce(uc_mem_protect(*this, address, size, static_cast<uint32_t>(permissions)));
			}

			/*std::vector<memory_region> get_memory_regions() override
			{
				const unicorn_memory_regions regions{*this};
				const auto region_span = regions.get_span();

				std::vector<memory_region> result{};
				result.reserve(region_span.size());

				for (const auto region : region_span)
				{
					memory_region reg{};
					reg.start = region.begin;
					reg.length = region.end - region.begin;
					reg.committed = true;
					reg.pemissions = static_cast<memory_permission>(region.perms) & memory_permission::all;

					result.push_back(reg);
				}

				return result;
			}*/

			emulator_hook* hook_instruction(int instruction_type,
			                                instruction_hook_callback callback) override
			{
				function_wrapper<int, uc_engine*> wrapper([c = std::move(callback)](uc_engine*)
				{
					return (c() == instruction_hook_continuation::skip_instruction)
						       ? 1
						       : 0;
				});

				unicorn_hook hook{*this};
				auto container = std::make_unique<hook_container>();

				const auto inst_type = static_cast<x64_hookable_instructions>(instruction_type);

				if (inst_type == x64_hookable_instructions::invalid)
				{
					uce(uc_hook_add(*this, hook.make_reference(), UC_HOOK_INSN_INVALID, wrapper.get_function(),
					                wrapper.get_user_data(), 0, std::numeric_limits<pointer_type>::max()));
				}
				else
				{
					const auto uc_instruction = map_hookable_instruction(inst_type);
					uce(uc_hook_add(*this, hook.make_reference(), UC_HOOK_INSN, wrapper.get_function(),
					                wrapper.get_user_data(), 0, std::numeric_limits<pointer_type>::max(),
					                uc_instruction));
				}

				container->add(std::move(wrapper), std::move(hook));

				auto* result = container->as_opaque_hook();

				this->hooks_.push_back(std::move(container));

				return result;
			}

			emulator_hook* hook_basic_block(basic_block_hook_callback callback) override
			{
				function_wrapper<void, uc_engine*, uint64_t, size_t> wrapper(
					[c = std::move(callback)](uc_engine*, const uint64_t address, const size_t size)
					{
						basic_block block{};
						block.address = address;
						block.size = size;

						c(block);
					});

				unicorn_hook hook{*this};
				auto container = std::make_unique<hook_container>();

				uce(uc_hook_add(*this, hook.make_reference(), UC_HOOK_BLOCK, wrapper.get_function(),
				                wrapper.get_user_data(), 0, std::numeric_limits<pointer_type>::max())
				);

				container->add(std::move(wrapper), std::move(hook));

				auto* result = container->as_opaque_hook();
				this->hooks_.push_back(std::move(container));
				return result;
			}

			emulator_hook* hook_edge_generation(edge_generation_hook_callback callback) override
			{
				function_wrapper<void, uc_engine*, uc_tb*, uc_tb*> wrapper(
					[c = std::move(callback)](uc_engine*, const uc_tb* cur_tb, const uc_tb* prev_tb)
					{
						const auto current_block = map_block(*cur_tb);
						const auto previous_block = map_block(*prev_tb);

						c(current_block, previous_block);
					});

				unicorn_hook hook{*this};
				auto container = std::make_unique<hook_container>();

				uce(uc_hook_add(*this, hook.make_reference(), UC_HOOK_EDGE_GENERATED, wrapper.get_function(),
				                wrapper.get_user_data(), 0, std::numeric_limits<pointer_type>::max())
				);

				container->add(std::move(wrapper), std::move(hook));

				auto* result = container->as_opaque_hook();
				this->hooks_.push_back(std::move(container));
				return result;
			}

			emulator_hook* hook_interrupt(interrupt_hook_callback callback) override
			{
				function_wrapper<void, uc_engine*, int> wrapper(
					[c = std::move(callback)](uc_engine*, const int interrupt_type)
					{
						c(interrupt_type);
					});

				unicorn_hook hook{*this};
				auto container = std::make_unique<hook_container>();

				uce(uc_hook_add(*this, hook.make_reference(), UC_HOOK_INTR, wrapper.get_function(),
				                wrapper.get_user_data(), 0, std::numeric_limits<pointer_type>::max())
				);

				container->add(std::move(wrapper), std::move(hook));

				auto* result = container->as_opaque_hook();
				this->hooks_.push_back(std::move(container));
				return result;
			}

			emulator_hook* hook_memory_violation(uint64_t address, size_t size,
			                                     memory_violation_hook_callback callback) override
			{
				function_wrapper<bool, uc_engine*, uc_mem_type, uint64_t, int, int64_t> wrapper(
					[c = std::move(callback), this](uc_engine*, const uc_mem_type type,
					                                const uint64_t address, const int size, const int64_t)
					{
						const auto ip = this->read_instruction_pointer();

						assert(size >= 0);
						const auto operation = map_memory_operation(type);
						const auto violation = map_memory_violation_type(type);

						const auto resume = c(address, static_cast<uint64_t>(size), operation, violation) ==
							memory_violation_continuation::resume;

						const auto has_ip_changed = ip != this->read_instruction_pointer();

						if (!resume)
						{
							return false;
						}

						this->retry_after_violation_ = resume && has_ip_changed;

						if (has_ip_changed)
						{
							return false;
						}

						return true;
					});

				unicorn_hook hook{*this};
				auto container = std::make_unique<hook_container>();

				uce(uc_hook_add(*this, hook.make_reference(), UC_HOOK_MEM_INVALID, wrapper.get_function(),
				                wrapper.get_user_data(), address, size));

				container->add(std::move(wrapper), std::move(hook));

				auto* result = container->as_opaque_hook();
				this->hooks_.push_back(std::move(container));
				return result;
			}

			emulator_hook* hook_memory_access(const uint64_t address, const size_t size, const memory_operation filter,
			                                  complex_memory_hook_callback callback) override
			{
				if (filter == memory_permission::none)
				{
					return nullptr;
				}

				const auto shared_callback = std::make_shared<complex_memory_hook_callback>(std::move(callback));

				auto container = std::make_unique<hook_container>();

				if ((filter & memory_operation::read) != memory_operation::none)
				{
					add_read_hook(*this, address, size, *container, shared_callback);
				}

				if ((filter & memory_operation::write) != memory_operation::none)
				{
					add_write_hook(*this, address, size, *container, shared_callback);
				}

				if ((filter & memory_operation::exec) != memory_operation::none)
				{
					add_exec_hook(*this, address, size, *container, shared_callback);
				}

				auto* result = container->as_opaque_hook();

				this->hooks_.push_back(std::move(container));

				return result;
			}

			void delete_hook(emulator_hook* hook) override
			{
				const auto entry = std::ranges::find_if(this->hooks_, [&](const std::unique_ptr<hook_object>& hook_ptr)
				{
					return hook_ptr->as_opaque_hook() == hook;
				});

				if (entry != this->hooks_.end())
				{
					this->hooks_.erase(entry);
				}
			}

			operator uc_engine*() const
			{
				return this->uc_;
			}

			void serialize_state(utils::buffer_serializer& buffer, const bool is_snapshot) const override
			{
				if (this->has_snapshots_ && !is_snapshot)
				{
					// TODO: Investigate if this is really necessary
					throw std::runtime_error("Unable to serialize after snapshot was taken!");
				}

				this->has_snapshots_ |= is_snapshot;

				const uc_context_serializer serializer(this->uc_, is_snapshot);
				serializer.serialize(buffer);
			}

			void deserialize_state(utils::buffer_deserializer& buffer, const bool is_snapshot) override
			{
				if (this->has_snapshots_ && !is_snapshot)
				{
					// TODO: Investigate if this is really necessary
					throw std::runtime_error("Unable to deserialize after snapshot was taken!");
				}

				const uc_context_serializer serializer(this->uc_, is_snapshot);
				serializer.deserialize(buffer);
			}

			std::vector<std::byte> save_registers() override
			{
				utils::buffer_serializer buffer{};
				const uc_context_serializer serializer(this->uc_, false);
				serializer.serialize(buffer);
				return buffer.move_buffer();
			}

			void restore_registers(const std::vector<std::byte>& register_data) override
			{
				utils::buffer_deserializer buffer{register_data};
				const uc_context_serializer serializer(this->uc_, false);
				serializer.deserialize(buffer);
			}

		private:
			mutable bool has_snapshots_{false};
			uc_engine* uc_{};
			bool retry_after_violation_{false};
			std::vector<std::unique_ptr<hook_object>> hooks_{};
		};
	}

	std::unique_ptr<x64_emulator> create_x64_emulator()
	{
		return std::make_unique<unicorn_x64_emulator>();
	}
}

```

`src/unicorn-emulator/unicorn_x64_emulator.hpp`:

```hpp
#pragma once

#include <memory>
#include <x64_emulator.hpp>

#ifdef UNICORN_EMULATOR_IMPL
#define UNICORN_EMULATOR_DLL_STORAGE __declspec(dllexport)
#else
#define UNICORN_EMULATOR_DLL_STORAGE __declspec(dllimport)
#endif

namespace unicorn
{
	UNICORN_EMULATOR_DLL_STORAGE
	std::unique_ptr<x64_emulator> create_x64_emulator();
}

```

`src/windows-emulator/CMakeLists.txt`:

```txt
file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  *.cpp
  *.hpp
  *.rc
)

list(SORT SRC_FILES)

add_library(windows-emulator ${SRC_FILES})

momo_assign_source_group(${SRC_FILES})

target_precompile_headers(windows-emulator PRIVATE std_include.hpp)

target_link_libraries(windows-emulator PRIVATE
  common
  unicorn-emulator
  mini-gdbstub
)

target_link_libraries(windows-emulator PUBLIC
  emulator
  phnt::phnt
)

target_include_directories(windows-emulator INTERFACE
    "${CMAKE_CURRENT_LIST_DIR}"
)

momo_strip_target(windows-emulator)

```

`src/windows-emulator/context_frame.cpp`:

```cpp
#include "std_include.hpp"
#include "context_frame.hpp"

namespace context_frame
{
	void restore(x64_emulator& emu, const CONTEXT& context)
	{
		if (context.ContextFlags & CONTEXT_DEBUG_REGISTERS)
		{
			emu.reg(x64_register::dr0, context.Dr0);
			emu.reg(x64_register::dr1, context.Dr1);
			emu.reg(x64_register::dr2, context.Dr2);
			emu.reg(x64_register::dr3, context.Dr3);
			emu.reg(x64_register::dr6, context.Dr6);
			emu.reg(x64_register::dr7, context.Dr7);
		}

		if (context.ContextFlags & CONTEXT_CONTROL)
		{
			emu.reg<uint16_t>(x64_register::ss, context.SegSs);
			emu.reg<uint16_t>(x64_register::cs, context.SegCs);

			emu.reg(x64_register::rip, context.Rip);
			emu.reg(x64_register::rsp, context.Rsp);

			emu.reg<uint32_t>(x64_register::eflags, context.EFlags);
		}

		if (context.ContextFlags & CONTEXT_INTEGER)
		{
			emu.reg(x64_register::rax, context.Rax);
			emu.reg(x64_register::rbx, context.Rbx);
			emu.reg(x64_register::rcx, context.Rcx);
			emu.reg(x64_register::rdx, context.Rdx);
			emu.reg(x64_register::rbp, context.Rbp);
			emu.reg(x64_register::rsi, context.Rsi);
			emu.reg(x64_register::rdi, context.Rdi);
			emu.reg(x64_register::r8, context.R8);
			emu.reg(x64_register::r9, context.R9);
			emu.reg(x64_register::r10, context.R10);
			emu.reg(x64_register::r11, context.R11);
			emu.reg(x64_register::r12, context.R12);
			emu.reg(x64_register::r13, context.R13);
			emu.reg(x64_register::r14, context.R14);
			emu.reg(x64_register::r15, context.R15);
		}

		/*if (context.ContextFlags & CONTEXT_SEGMENTS)
		{
			emu.reg<uint16_t>(x64_register::ds, context.SegDs);
			emu.reg<uint16_t>(x64_register::es, context.SegEs);
			emu.reg<uint16_t>(x64_register::fs, context.SegFs);
			emu.reg<uint16_t>(x64_register::gs, context.SegGs);
		}*/

		if (context.ContextFlags & CONTEXT_FLOATING_POINT)
		{
			emu.reg<uint16_t>(x64_register::fpcw, context.FltSave.ControlWord);
			emu.reg<uint16_t>(x64_register::fpsw, context.FltSave.StatusWord);
			emu.reg<uint16_t>(x64_register::fptag, context.FltSave.TagWord);

			for (int i = 0; i < 8; i++)
			{
				const auto reg = static_cast<x64_register>(static_cast<int>(x64_register::st0) + i);
				emu.reg<M128A>(reg, context.FltSave.FloatRegisters[i]);
			}
		}

		if (context.ContextFlags & CONTEXT_XSTATE)
		{
			emu.reg<uint32_t>(x64_register::mxcsr, context.MxCsr);

			for (int i = 0; i < 16; i++)
			{
				const auto reg = static_cast<x64_register>(static_cast<int>(x64_register::xmm0) + i);
				emu.reg<M128A>(reg, (&context.Xmm0)[i]);
			}
		}
	}

	void save(x64_emulator& emu, CONTEXT& context)
	{
		if (context.ContextFlags & CONTEXT_DEBUG_REGISTERS)
		{
			context.Dr0 = emu.reg(x64_register::dr0);
			context.Dr1 = emu.reg(x64_register::dr1);
			context.Dr2 = emu.reg(x64_register::dr2);
			context.Dr3 = emu.reg(x64_register::dr3);
			context.Dr6 = emu.reg(x64_register::dr6);
			context.Dr7 = emu.reg(x64_register::dr7);
		}

		if (context.ContextFlags & CONTEXT_CONTROL)
		{
			context.SegSs = emu.reg<uint16_t>(x64_register::ss);
			context.SegCs = emu.reg<uint16_t>(x64_register::cs);
			context.Rip = emu.reg(x64_register::rip);
			context.Rsp = emu.reg(x64_register::rsp);
			context.EFlags = emu.reg<uint32_t>(x64_register::eflags);
		}

		if (context.ContextFlags & CONTEXT_INTEGER)
		{
			context.Rax = emu.reg(x64_register::rax);
			context.Rbx = emu.reg(x64_register::rbx);
			context.Rcx = emu.reg(x64_register::rcx);
			context.Rdx = emu.reg(x64_register::rdx);
			context.Rbp = emu.reg(x64_register::rbp);
			context.Rsi = emu.reg(x64_register::rsi);
			context.Rdi = emu.reg(x64_register::rdi);
			context.R8 = emu.reg(x64_register::r8);
			context.R9 = emu.reg(x64_register::r9);
			context.R10 = emu.reg(x64_register::r10);
			context.R11 = emu.reg(x64_register::r11);
			context.R12 = emu.reg(x64_register::r12);
			context.R13 = emu.reg(x64_register::r13);
			context.R14 = emu.reg(x64_register::r14);
			context.R15 = emu.reg(x64_register::r15);
		}

		if (context.ContextFlags & CONTEXT_SEGMENTS)
		{
			context.SegDs = emu.reg<uint16_t>(x64_register::ds);
			context.SegEs = emu.reg<uint16_t>(x64_register::es);
			context.SegFs = emu.reg<uint16_t>(x64_register::fs);
			context.SegGs = emu.reg<uint16_t>(x64_register::gs);
		}

		if (context.ContextFlags & CONTEXT_FLOATING_POINT)
		{
			context.FltSave.ControlWord = emu.reg<uint16_t>(x64_register::fpcw);
			context.FltSave.StatusWord = emu.reg<uint16_t>(x64_register::fpsw);
			context.FltSave.TagWord = static_cast<BYTE>(emu.reg<uint16_t>(x64_register::fptag));
			for (int i = 0; i < 8; i++)
			{
				const auto reg = static_cast<x64_register>(static_cast<int>(x64_register::st0) + i);
				context.FltSave.FloatRegisters[i] = emu.reg<M128A>(reg);
			}
		}

		if (context.ContextFlags & CONTEXT_XSTATE)
		{
			context.MxCsr = emu.reg<uint32_t>(x64_register::mxcsr);
			for (int i = 0; i < 16; i++)
			{
				const auto reg = static_cast<x64_register>(static_cast<int>(x64_register::xmm0) + i);
				(&context.Xmm0)[i] = emu.reg<M128A>(reg);
			}
		}
	}
}

```

`src/windows-emulator/context_frame.hpp`:

```hpp
#pragma once
#include "x64_emulator.hpp"

namespace context_frame
{
	void save(x64_emulator& emu, CONTEXT& context);
	void restore(x64_emulator& emu, const CONTEXT& context);
}

```

`src/windows-emulator/debugging/gdb_stub.cpp`:

```cpp
#include "../std_include.hpp"
#include "gdb_stub.hpp"

#include <utils/finally.hpp>

extern "C" {
#include <gdbstub.h>
}

namespace
{
	gdb_action_t map_gdb_action(const gdb_action action)
	{
		switch (action)
		{
		case gdb_action::none:
			return ACT_NONE;
		case gdb_action::resume:
			return ACT_RESUME;
		case gdb_action::shutdown:
			return ACT_SHUTDOWN;
		}

		throw std::runtime_error("Bad action");
	}

	breakpoint_type map_breakpoint_type(const bp_type_t type)
	{
		switch (type)
		{
		case BP_SOFTWARE:
			return breakpoint_type::software;
		case BP_HARDWARE_EXEC:
			return breakpoint_type::hardware_exec;
		case BP_HARDWARE_WRITE:
			return breakpoint_type::hardware_write;
		case BP_HARDWARE_READ:
			return breakpoint_type::hardware_read;
		case BP_HARDWARE_READ_WRITE:
			return breakpoint_type::hardware_read_write;
		}

		throw std::runtime_error("Bad breakpoint type");
	}

	gdb_stub_handler& get_handler(void* args)
	{
		return *static_cast<gdb_stub_handler*>(args);
	}

	gdb_action_t cont(void* args)
	{
		return map_gdb_action(get_handler(args).cont());
	}

	gdb_action_t stepi(void* args)
	{
		return map_gdb_action(get_handler(args).stepi());
	}

	int read_reg(void* args, const int regno, size_t* value)
	{
		return get_handler(args).read_reg(regno, value) ? 0 : 1;
	}

	int write_reg(void* args, const int regno, const size_t value)
	{
		return get_handler(args).write_reg(regno, value) ? 0 : 1;
	}

	int read_mem(void* args, const size_t addr, const size_t len, void* val)
	{
		return get_handler(args).read_mem(addr, len, val) ? 0 : 1;
	}

	int write_mem(void* args, const size_t addr, const size_t len, void* val)
	{
		return get_handler(args).write_mem(addr, len, val) ? 0 : 1;
	}

	bool set_bp(void* args, const size_t addr, const bp_type_t type, const size_t size)
	{
		return get_handler(args).set_bp(map_breakpoint_type(type), addr, size);
	}

	bool del_bp(void* args, const size_t addr, const bp_type_t type, const size_t size)
	{
		return get_handler(args).del_bp(map_breakpoint_type(type), addr, size);
	}

	void on_interrupt(void* args)
	{
		get_handler(args).on_interrupt();
	}

	target_ops get_target_ops()
	{
		target_ops ops{};

		ops.cont = cont;
		ops.stepi = stepi;
		ops.read_reg = read_reg;
		ops.write_reg = write_reg;
		ops.read_mem = read_mem;
		ops.write_mem = write_mem;
		ops.set_bp = set_bp;
		ops.del_bp = del_bp;
		ops.on_interrupt = on_interrupt;

		return ops;
	}
}

bool run_gdb_stub(gdb_stub_handler& handler, std::string target_description, const size_t register_count,
                  std::string bind_address)
{
	const arch_info_t info
	{
		target_description.data(),
		static_cast<int>(register_count),
		sizeof(uint64_t),
	};

	auto ops = get_target_ops();

	gdbstub_t stub{};

	if (!gdbstub_init(&stub, &ops, info, bind_address.data()))
	{
		return false;
	}

	const auto _ = utils::finally([&]
	{
		gdbstub_close(&stub);
	});

	return gdbstub_run(&stub, &handler);
}

```

`src/windows-emulator/debugging/gdb_stub.hpp`:

```hpp
#pragma once

enum class gdb_action : uint8_t
{
	none,
	resume,
	shutdown,
};

enum class breakpoint_type : uint8_t
{
	software,
	hardware_exec,
	hardware_write,
	hardware_read,
	hardware_read_write,
};

struct gdb_stub_handler
{
	virtual ~gdb_stub_handler() = default;

	virtual gdb_action cont() = 0;
	virtual gdb_action stepi() = 0;

	virtual bool read_reg(int regno, size_t* value) = 0;
	virtual bool write_reg(int regno, size_t value) = 0;

	virtual bool read_mem(size_t addr, size_t len, void* val) = 0;
	virtual bool write_mem(size_t addr, size_t len, void* val) = 0;

	virtual bool set_bp(breakpoint_type type, size_t addr, size_t size) = 0;
	virtual bool del_bp(breakpoint_type type, size_t addr, size_t size) = 0;

	virtual void on_interrupt() = 0;
};

bool run_gdb_stub(gdb_stub_handler& handler, std::string target_description, size_t register_count, std::string bind_address);

```

`src/windows-emulator/debugging/x64_gdb_stub_handler.hpp`:

```hpp
#pragma once
#include <x64_emulator.hpp>
#include "gdb_stub.hpp"
#include "scoped_hook.hpp"

inline std::vector gdb_registers{
	x64_register::rax,
	x64_register::rbx,
	x64_register::rcx,
	x64_register::rdx,
	x64_register::rsi,
	x64_register::rdi,
	x64_register::rbp,
	x64_register::rsp,
	x64_register::r8,
	x64_register::r9,
	x64_register::r10,
	x64_register::r11,
	x64_register::r12,
	x64_register::r13,
	x64_register::r14,
	x64_register::r15,
	x64_register::rip,
	x64_register::rflags,
	/*x64_register::cs,
	x64_register::ss,
	x64_register::ds,
	x64_register::es,
	x64_register::fs,
	x64_register::gs,*/
};

inline memory_operation map_breakpoint_type(const breakpoint_type type)
{
	switch (type)
	{
	case breakpoint_type::software:
	case breakpoint_type::hardware_exec:
		return memory_operation::exec;
	case breakpoint_type::hardware_read:
		return memory_permission::read;
	case breakpoint_type::hardware_write:
		return memory_permission::write;
	case breakpoint_type::hardware_read_write:
		return memory_permission::read_write;
	default:
		throw std::runtime_error("Bad bp type");
	}
}

struct breakpoint_key
{
	size_t addr{};
	size_t size{};
	breakpoint_type type{};

	bool operator==(const breakpoint_key& other) const
	{
		return this->addr == other.addr && this->size == other.size && this->type == other.type;
	}
};

template <>
struct std::hash<breakpoint_key>
{
	std::size_t operator()(const breakpoint_key& k) const noexcept
	{
		return ((std::hash<size_t>()(k.addr)
				^ (std::hash<size_t>()(k.size) << 1)) >> 1)
			^ (std::hash<size_t>()(static_cast<size_t>(k.type)) << 1);
	}
};

class x64_gdb_stub_handler : public gdb_stub_handler
{
public:
	x64_gdb_stub_handler(x64_emulator& emu)
		: emu_(&emu)
	{
	}

	~x64_gdb_stub_handler() override = default;

	gdb_action cont() override
	{
		try
		{
			this->emu_->start_from_ip();
		}
		catch (const std::exception& e)
		{
			puts(e.what());
		}

		return gdb_action::resume;
	}

	gdb_action stepi() override
	{
		try
		{
			this->emu_->start_from_ip({}, 1);
		}
		catch (const std::exception& e)
		{
			puts(e.what());
		}

		return gdb_action::resume;
	}

	bool read_reg(const int regno, size_t* value) override
	{
		*value = 0;

		try
		{
			if (static_cast<size_t>(regno) >= gdb_registers.size())
			{
				return true;
			}

			this->emu_->read_register(gdb_registers[regno], value, sizeof(*value));
			return true;
		}
		catch (...)
		{
			return true;
		}
	}

	bool write_reg(const int regno, const size_t value) override
	{
		try
		{
			if (static_cast<size_t>(regno) >= gdb_registers.size())
			{
				return true;
			}

			this->emu_->write_register(gdb_registers[regno], &value, sizeof(value));
			return true;
		}
		catch (...)
		{
			return false;
		}
	}

	bool read_mem(const size_t addr, const size_t len, void* val) override
	{
		return this->emu_->try_read_memory(addr, val, len);
	}

	bool write_mem(const size_t addr, const size_t len, void* val) override
	{
		try
		{
			this->emu_->write_memory(addr, val, len);
			return true;
		}
		catch (...)
		{
			return false;
		}
	}

	bool set_bp(const breakpoint_type type, const size_t addr, const size_t size) override
	{
		try
		{
			this->hooks_[{addr, size, type}] = scoped_hook(*this->emu_, this->emu_->hook_memory_access(
				                                               addr, size, map_breakpoint_type(type),
				                                               [this](uint64_t, size_t, uint64_t, memory_operation)
				                                               {
					                                               this->on_interrupt();
				                                               }));

			return true;
		}
		catch (...)
		{
			return false;
		}
	}

	bool del_bp(const breakpoint_type type, const size_t addr, const size_t size) override
	{
		try
		{
			const auto entry = this->hooks_.find({addr, size, type});
			if (entry == this->hooks_.end())
			{
				return false;
			}

			this->hooks_.erase(entry);

			return true;
		}
		catch (...)
		{
			return false;
		}
	}

	void on_interrupt() override
	{
		this->emu_->stop();
	}

private:
	x64_emulator* emu_{};
	std::unordered_map<breakpoint_key, scoped_hook> hooks_{};
};

```

`src/windows-emulator/emulator_utils.hpp`:

```hpp
#pragma once
#include "memory_utils.hpp"

template <typename T>
class emulator_object
{
public:
	using value_type = T;

	emulator_object() = default;

	emulator_object(emulator& emu, const uint64_t address = 0)
		: emu_(&emu)
		  , address_(address)
	{
	}

	emulator_object(emulator& emu, const void* address)
		: emulator_object(emu, reinterpret_cast<uint64_t>(address))
	{
	}

	uint64_t value() const
	{
		return this->address_;
	}

	uint64_t size() const
	{
		return sizeof(T);
	}

	uint64_t end() const
	{
		return this->value() + this->size();
	}

	T* ptr() const
	{
		return reinterpret_cast<T*>(this->address_);
	}

	operator bool() const
	{
		return this->address_ != 0;
	}

	T read(const size_t index = 0) const
	{
		T obj{};
		this->emu_->read_memory(this->address_ + index * this->size(), &obj, sizeof(obj));
		return obj;
	}

	void write(const T& value, const size_t index = 0) const
	{
		this->emu_->write_memory(this->address_ + index * this->size(), &value, sizeof(value));
	}

	template <typename F>
	void access(const F& accessor, const size_t index = 0) const
	{
		T obj{};
		this->emu_->read_memory(this->address_ + index * this->size(), &obj, sizeof(obj));

		accessor(obj);

		this->write(obj, index);
	}

	void serialize(utils::buffer_serializer& buffer) const
	{
		buffer.write(this->address_);
	}

	void deserialize(utils::buffer_deserializer& buffer)
	{
		buffer.read(this->address_);
	}

private:
	emulator* emu_{};
	uint64_t address_{};
};

class emulator_allocator
{
public:
	emulator_allocator(emulator& emu)
		: emu_(&emu)
	{
	}

	emulator_allocator(emulator& emu, const uint64_t address, const uint64_t size)
		: emu_(&emu)
		  , address_(address)
		  , size_(size)
		  , active_address_(address)
	{
	}

	uint64_t reserve(const uint64_t count, const uint64_t alignment = 1)
	{
		const auto potential_start = align_up(this->active_address_, alignment);
		const auto potential_end = potential_start + count;
		const auto total_end = this->address_ + this->size_;

		if (potential_end > total_end)
		{
			throw std::runtime_error("Out of memory");
		}

		this->active_address_ = potential_end;

		return potential_start;
	}

	template <typename T>
	emulator_object<T> reserve(const size_t count = 1)
	{
		const auto potential_start = this->reserve(sizeof(T) * count, alignof(T));
		return emulator_object<T>(*this->emu_, potential_start);
	}

	void make_unicode_string(UNICODE_STRING& result, const std::wstring_view str)
	{
		constexpr auto element_size = sizeof(str[0]);
		constexpr auto required_alignment = alignof(decltype(str[0]));
		const auto total_length = str.size() * element_size;

		const auto string_buffer = this->reserve(total_length + element_size, required_alignment);

		this->emu_->write_memory(string_buffer, str.data(), total_length);

		constexpr std::array<char, element_size> nullbyte{};
		this->emu_->write_memory(string_buffer + total_length, nullbyte.data(), nullbyte.size());

		result.Buffer = reinterpret_cast<PWCH>(string_buffer);
		result.Length = static_cast<USHORT>(total_length);
		result.MaximumLength = result.Length;
	}

	emulator_object<UNICODE_STRING> make_unicode_string(const std::wstring_view str)
	{
		const auto unicode_string = this->reserve<UNICODE_STRING>();

		unicode_string.access([&](UNICODE_STRING& unicode_str)
		{
			this->make_unicode_string(unicode_str, str);
		});

		return unicode_string;
	}

	uint64_t get_base() const
	{
		return this->address_;
	}

	uint64_t get_size() const
	{
		return this->size_;
	}

	uint64_t get_next_address() const
	{
		return this->active_address_;
	}

	void serialize(utils::buffer_serializer& buffer) const
	{
		buffer.write(this->address_);
		buffer.write(this->size_);
		buffer.write(this->active_address_);
	}

	void deserialize(utils::buffer_deserializer& buffer)
	{
		buffer.read(this->address_);
		buffer.read(this->size_);
		buffer.read(this->active_address_);
	}

	void release()
	{
		if (this->emu_ && this->address_ && this->size_)
		{
			this->emu_->release_memory(this->address_, this->size_);
			this->address_ = 0;
			this->size_ = 0;
		}
	}

private:
	emulator* emu_{};
	uint64_t address_{};
	uint64_t size_{};
	uint64_t active_address_{0};
};

inline std::wstring read_unicode_string(const emulator& emu, const UNICODE_STRING ucs)
{
	static_assert(offsetof(UNICODE_STRING, Length) == 0);
	static_assert(offsetof(UNICODE_STRING, MaximumLength) == 2);
	static_assert(offsetof(UNICODE_STRING, Buffer) == 8);
	static_assert(sizeof(UNICODE_STRING) == 16);

	std::wstring result{};
	result.resize(ucs.Length / 2);

	emu.read_memory(reinterpret_cast<uint64_t>(ucs.Buffer), result.data(), ucs.Length);

	return result;
}


inline std::wstring read_unicode_string(const emulator& emu, const emulator_object<UNICODE_STRING> uc_string)
{
	const auto ucs = uc_string.read();
	return read_unicode_string(emu, ucs);
}

inline std::wstring read_unicode_string(emulator& emu, const UNICODE_STRING* uc_string)
{
	return read_unicode_string(emu, emulator_object<UNICODE_STRING>{emu, uc_string});
}

```

`src/windows-emulator/handles.hpp`:

```hpp
#pragma once

struct handle_types
{
	enum type : uint16_t
	{
		file,
		event,
		section,
		symlink,
		directory,
		semaphore,
		port,
		thread,
	};
};

#pragma pack(push)
#pragma pack(1)
struct handle_value
{
	uint64_t id : 32;
	uint64_t type : 16;
	uint64_t padding : 15;
	uint64_t is_pseudo : 1;
};
#pragma pack(pop)

static_assert(sizeof(handle_value) == 8);

union handle
{
	handle_value value;
	uint64_t bits;
	HANDLE h;
};

inline bool operator==(const handle& h1, const handle& h2)
{
	return h1.bits == h2.bits;
}

inline bool operator==(const handle& h1, const uint64_t& h2)
{
	return h1.bits == h2;
}

inline handle_value get_handle_value(const uint64_t h)
{
	handle hh{};
	hh.bits = h;
	return hh.value;
}

constexpr handle make_handle(const uint32_t id, const handle_types::type type, const bool is_pseudo)
{
	handle_value value{};

	value.padding = 0;
	value.id = id;
	value.type = type;
	value.is_pseudo = is_pseudo;

	return {value};
}

constexpr handle make_pseudo_handle(const uint32_t id, const handle_types::type type)
{
	return make_handle(id, type, true);
}

namespace handle_detail
{
	template <typename, typename = void>
	struct has_deleter_function : std::false_type
	{
	};

	template <typename T>
	struct has_deleter_function<T, std::void_t<decltype(T::deleter(std::declval<T&>()))>>
		: std::is_same<decltype(T::deleter(std::declval<T&>())), bool>
	{
	};
}

template <handle_types::type Type, typename T>
	requires(utils::Serializable<T>)
class handle_store
{
public:
	using value_map = std::map<uint32_t, T>;

	handle store(T value)
	{
		auto index = this->find_free_index();
		this->store_[index] = std::move(value);

		return make_handle(index);
	}

	handle make_handle(const uint32_t index)
	{
		handle h{};
		h.bits = 0;
		h.value.is_pseudo = false;
		h.value.type = Type;
		h.value.id = index;

		return h;
	}

	T* get(const handle_value h)
	{
		const auto entry = this->get_iterator(h);
		if (entry == this->store_.end())
		{
			return nullptr;
		}

		return &entry->second;
	}

	T* get(const handle h)
	{
		return this->get(h.value);
	}

	T* get(const uint64_t h)
	{
		handle hh{};
		hh.bits = h;

		return this->get(hh);
	}

	size_t size() const
	{
		return this->store_.size();
	}

	bool erase(const typename value_map::iterator& entry)
	{
		if (entry == this->store_.end())
		{
			return false;
		}

		if constexpr (handle_detail::has_deleter_function<T>())
		{
			if (!T::deleter(entry->second))
			{
				return false;
			}
		}

		this->store_.erase(entry);
		return true;
	}

	bool erase(const handle_value h)
	{
		const auto entry = this->get_iterator(h);
		return this->erase(entry);
	}

	bool erase(const handle h)
	{
		return this->erase(h.value);
	}

	bool erase(const uint64_t h)
	{
		handle hh{};
		hh.bits = h;

		return this->erase(hh);
	}

	bool erase(const T& value)
	{
		const auto entry = this->find(value);
		return this->erase(entry);
	}

	void serialize(utils::buffer_serializer& buffer) const
	{
		buffer.write_map(this->store_);
	}

	void deserialize(utils::buffer_deserializer& buffer)
	{
		buffer.read_map(this->store_);
	}

	typename value_map::iterator find(const T& value)
	{
		auto i = this->store_.begin();
		for (; i != this->store_.end(); ++i)
		{
			if (&i->second == &value)
			{
				break;
			}
		}

		return i;
	}

	typename value_map::const_iterator find(const T& value) const
	{
		auto i = this->store_.begin();
		for (; i != this->store_.end(); ++i)
		{
			if (&i->second == &value)
			{
				break;
			}
		}

		return i;
	}

	typename value_map::iterator begin()
	{
		return this->store_.begin();
	}

	typename value_map::const_iterator begin() const
	{
		return this->store_.begin();
	}

	typename value_map::iterator end()
	{
		return this->store_.end();
	}

	typename value_map::const_iterator end() const
	{
		return this->store_.end();
	}

private:
	typename value_map::iterator get_iterator(const handle_value h)
	{
		if (h.type != Type || h.is_pseudo)
		{
			return this->store_.end();
		}

		return this->store_.find(h.id);
	}

	uint32_t find_free_index()
	{
		uint32_t index = 1;
		for (; index > 0; ++index)
		{
			if (!this->store_.contains(index))
			{
				break;
			}
		}

		return index;
	}


	value_map store_{};
};

constexpr auto KNOWN_DLLS_DIRECTORY = make_pseudo_handle(0x1337, handle_types::directory);
constexpr auto KNOWN_DLLS_SYMLINK = make_pseudo_handle(0x1337, handle_types::symlink);
constexpr auto SHARED_SECTION = make_pseudo_handle(0x1337, handle_types::section);
constexpr auto CONSOLE_SERVER = make_pseudo_handle(0x1338, handle_types::section);
constexpr auto CM_API = make_pseudo_handle(0x1338, handle_types::file);

constexpr auto CONSOLE_HANDLE = make_pseudo_handle(0x1, handle_types::file);
constexpr auto STDOUT_HANDLE = make_pseudo_handle(0x2, handle_types::file);
constexpr auto STDIN_HANDLE = make_pseudo_handle(0x3, handle_types::file);

```

`src/windows-emulator/logger.cpp`:

```cpp
#include "std_include.hpp"
#include "logger.hpp"

#include <utils/finally.hpp>

namespace
{
#ifdef _WIN32
#define COLOR(win, posix) win
	using color_type = WORD;
#else
#define COLOR(win, posix) posix
	using color_type = const char*;
#endif

	color_type get_reset_color()
	{
		return COLOR(7, "\033[0m");
	}

	color_type get_color_type(const color c)
	{
		using enum color;

		switch (c)
		{
		case black: return COLOR(0x8, "\033[0;90m");
		case red: return COLOR(0xC, "\033[0;91m");
		case green: return COLOR(0xA, "\033[0;92m");
		case yellow: return COLOR(0xE, "\033[0;93m");
		case blue: return COLOR(0x9, "\033[0;94m");
		case cyan: return COLOR(0xB, "\033[0;96m");
		case pink: return COLOR(0xD, "\033[0;95m");
		case white: return COLOR(0xF, "\033[0;97m");
		case dark_gray: return COLOR(0x8, "\033[0;97m");
		case gray:
		default: return get_reset_color();
		}
	}

#ifdef _WIN32
	HANDLE get_console_handle()
	{
		return GetStdHandle(STD_OUTPUT_HANDLE);
	}
#endif

	void set_color(const color_type color)
	{
#ifdef _WIN32
		SetConsoleTextAttribute(get_console_handle(), color);
#else
		printf("%s", color);
#endif
	}

	void reset_color()
	{
		(void)fflush(stdout);
		set_color(get_reset_color());
		(void)fflush(stdout);
	}

	std::string_view format(va_list* ap, const char* message)
	{
		thread_local char buffer[0x1000];

#ifdef _WIN32
		const int count = _vsnprintf_s(buffer, sizeof(buffer), sizeof(buffer), message, *ap);
#else
		const int count = vsnprintf(buffer, sizeof(buffer), message, *ap);
#endif

		if (count < 0) return {};
		return {buffer, static_cast<size_t>(count)};
	}

	void print_colored(const std::string_view& line, const color_type base_color)
	{
		const auto _ = utils::finally(&reset_color);
		set_color(base_color);
		(void)fwrite(line.data(), 1, line.size(), stdout);
	}
}

void logger::print(const color c, const char* message, ...) const
{
	if (this->disable_output_)
	{
		return;
	}

	va_list ap;
	va_start(ap, message);

	const auto data = format(&ap, message);
	print_colored(data, get_color_type(c));

	va_end(ap);
}

```

`src/windows-emulator/logger.hpp`:

```hpp
#pragma once

enum class color
{
	black,
	red,
	green,
	yellow,
	blue,
	cyan,
	pink,
	white,
	gray,
	dark_gray,
};

class logger
{
public:
	void print(color c, const char* message, ...) const;

	template <typename... Args>
	void info(const char* message, Args... args)
	{
		this->print(color::cyan, message, args...);
	}

	template <typename... Args>
	void warn(const char* message, Args... args)
	{
		this->print(color::yellow, message, args...);
	}

	template <typename... Args>
	void error(const char* message, Args... args)
	{
		this->print(color::red, message, args...);
	}

	template <typename... Args>
	void success(const char* message, Args... args)
	{
		this->print(color::green, message, args...);
	}

	template <typename... Args>
	void log(const char* message, Args... args)
	{
		this->print(color::gray, message, args...);
	}

	void disable_output(const bool value)
	{
		this->disable_output_ = value;
	}

private:
	bool disable_output_{false};
};

```

`src/windows-emulator/memory_utils.hpp`:

```hpp
#pragma once
#include <cstdint>
#include <string>
#include <emulator.hpp>

inline std::string get_permission_string(const memory_permission permission)
{
	const bool has_exec = (permission & memory_permission::exec) != memory_permission::none;
	const bool has_read = (permission & memory_permission::read) != memory_permission::none;
	const bool has_write = (permission & memory_permission::write) != memory_permission::none;

	std::string res = {};
	res.reserve(3);

	res.push_back(has_read ? 'r' : '-');
	res.push_back(has_write ? 'w' : '-');
	res.push_back(has_exec ? 'x' : '-');

	return res;
}

inline memory_permission map_nt_to_emulator_protection(const uint32_t nt_protection)
{
	switch (nt_protection)
	{
	case PAGE_NOACCESS:
		return memory_permission::none;
	case PAGE_READONLY:
		return memory_permission::read;
	case PAGE_READWRITE:
	case PAGE_WRITECOPY:
		return memory_permission::read | memory_permission::write;
	case PAGE_EXECUTE:
	case PAGE_EXECUTE_READ:
		return memory_permission::read | memory_permission::exec;
	case PAGE_EXECUTE_READWRITE:
	case PAGE_EXECUTE_WRITECOPY:
	default:
		throw std::runtime_error("Failed to map protection");
	//return memory_permission::all;
	}
}

inline uint32_t map_emulator_to_nt_protection(const memory_permission permission)
{
	const bool has_exec = (permission & memory_permission::exec) != memory_permission::none;
	const bool has_read = (permission & memory_permission::read) != memory_permission::none;
	const bool has_write = (permission & memory_permission::write) != memory_permission::none;

	if (!has_read)
	{
		return PAGE_NOACCESS;
	}

	if (has_exec && has_write)
	{
		return PAGE_EXECUTE_READWRITE;
	}

	if (has_exec)
	{
		return PAGE_EXECUTE_READ;
	}

	if (has_write)
	{
		return PAGE_READWRITE;
	}

	return PAGE_READONLY;
}

```

`src/windows-emulator/module/mapped_module.hpp`:

```hpp
#pragma once

struct exported_symbol
{
	std::string name{};
	uint64_t ordinal{};
	uint64_t rva{};
	uint64_t address{};
};

using exported_symbols = std::vector<exported_symbol>;
using address_name_mapping = std::unordered_map<uint64_t, std::string>;

struct mapped_module
{
	std::string name{};
	std::filesystem::path path{};

	uint64_t image_base{};
	uint64_t size_of_image{};
	uint64_t entry_point{};

	exported_symbols exports{};
	address_name_mapping address_names{};

	bool is_within(const uint64_t address) const
	{
		return address >= this->image_base && address < (this->image_base + this->size_of_image);
	}

	uint64_t find_export(const std::string_view export_name) const
	{
		for (auto& symbol : this->exports)
		{
			if (symbol.name == export_name)
			{
				return symbol.address;
			}
		}

		return 0;
	}
};

```

`src/windows-emulator/module/module_manager.cpp`:

```cpp
#include "../std_include.hpp"
#include "module_manager.hpp"
#include "module_mapping.hpp"
#include "windows-emulator/logger.hpp"

static void serialize(utils::buffer_serializer& buffer, const exported_symbol& sym)
{
	buffer.write(sym.name);
	buffer.write(sym.ordinal);
	buffer.write(sym.rva);
	buffer.write(sym.address);
}

static void deserialize(utils::buffer_deserializer& buffer, exported_symbol& sym)
{
	buffer.read(sym.name);
	buffer.read(sym.ordinal);
	buffer.read(sym.rva);
	buffer.read(sym.address);
}

static void serialize(utils::buffer_serializer& buffer, const mapped_module& mod)
{
	buffer.write_string(mod.name);
	buffer.write_string(mod.path.wstring());

	buffer.write(mod.image_base);
	buffer.write(mod.size_of_image);
	buffer.write(mod.entry_point);

	buffer.write_vector(mod.exports);
	buffer.write_map(mod.address_names);
}

static void deserialize(utils::buffer_deserializer& buffer, mapped_module& mod)
{
	mod.name = buffer.read_string();
	mod.path = buffer.read_string<wchar_t>();

	buffer.read(mod.image_base);
	buffer.read(mod.size_of_image);
	buffer.read(mod.entry_point);

	buffer.read_vector(mod.exports);
	buffer.read_map(mod.address_names);
}

module_manager::module_manager(emulator& emu)
	: emu_(&emu)
{
}

mapped_module* module_manager::map_module(const std::filesystem::path& file, logger& logger)
{
	const auto canonical_file = canonical(absolute(file));

	for (auto& mod : this->modules_)
	{
		if (mod.second.path == canonical_file)
		{
			return &mod.second;
		}
	}

	auto mod = map_module_from_file(*this->emu_, std::move(canonical_file));
	if (!mod)
	{
		logger.error("Failed to map %s\n", file.generic_string().c_str());
		return nullptr;
	}

	logger.log("Mapped %s at 0x%llX\n", mod->path.generic_string().c_str(), mod->image_base);

	const auto image_base = mod->image_base;
	const auto entry = this->modules_.try_emplace(image_base, std::move(*mod));
	return &entry.first->second;
}

void module_manager::serialize(utils::buffer_serializer& buffer) const
{
	buffer.write_map(this->modules_);
}

void module_manager::deserialize(utils::buffer_deserializer& buffer)
{
	buffer.read_map(this->modules_);
}

```

`src/windows-emulator/module/module_manager.hpp`:

```hpp
#pragma once
#include "mapped_module.hpp"
#include <emulator.hpp>

class logger;

class module_manager
{
public:
	module_manager(emulator& emu);

	mapped_module* map_module(const std::filesystem::path& file, logger& logger);

	mapped_module* find_by_address(const uint64_t address)
	{
		const auto entry = this->get_module(address);
		if (entry != this->modules_.end())
		{
			return &entry->second;
		}

		return nullptr;
	}

	const char* find_name(const uint64_t address)
	{
		const auto* mod = this->find_by_address(address);
		if (!mod)
		{
			return "<N/A>";
		}

		return mod->name.c_str();
	}

	void serialize(utils::buffer_serializer& buffer) const;
	void deserialize(utils::buffer_deserializer& buffer);

private:
	emulator* emu_{};

	using module_map = std::map<uint64_t, mapped_module>;
	module_map modules_{};

	module_map::iterator get_module(const uint64_t address)
	{
		if (this->modules_.empty())
		{
			return this->modules_.end();
		}

		auto upper_bound = this->modules_.upper_bound(address);
		if (upper_bound == this->modules_.begin())
		{
			return this->modules_.end();
		}

		std::advance(upper_bound, -1);
		return upper_bound;
	}
};

```

`src/windows-emulator/module/module_mapping.cpp`:

```cpp
#include "../std_include.hpp"
#include "module_mapping.hpp"
#include <address_utils.hpp>

#include <utils/io.hpp>
#include <utils/buffer_accessor.hpp>

namespace
{
	uint64_t get_first_section_offset(const IMAGE_NT_HEADERS& nt_headers, const uint64_t nt_headers_offset)
	{
		const auto first_section_absolute = reinterpret_cast<uint64_t>(IMAGE_FIRST_SECTION(&nt_headers));
		const auto absolute_base = reinterpret_cast<uint64_t>(&nt_headers);
		return nt_headers_offset + (first_section_absolute - absolute_base);
	}

	std::vector<uint8_t> read_mapped_memory(emulator& emu, const mapped_module& binary)
	{
		std::vector<uint8_t> memory{};
		memory.resize(binary.size_of_image);
		emu.read_memory(binary.image_base, memory.data(), memory.size());

		return memory;
	}

	void collect_exports(mapped_module& binary, const utils::safe_buffer_accessor<const uint8_t> buffer,
	                     const IMAGE_OPTIONAL_HEADER& optional_header)
	{
		auto& export_directory_entry = optional_header.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
		if (export_directory_entry.VirtualAddress == 0 || export_directory_entry.Size == 0)
		{
			return;
		}

		const auto export_directory = buffer.as<IMAGE_EXPORT_DIRECTORY>(export_directory_entry.
			VirtualAddress).get();

		//const auto function_count = export_directory->NumberOfFunctions;
		const auto names_count = export_directory.NumberOfNames;

		const auto names = buffer.as<DWORD>(export_directory.AddressOfNames);
		const auto ordinals = buffer.as<WORD>(export_directory.AddressOfNameOrdinals);
		const auto functions = buffer.as<DWORD>(export_directory.AddressOfFunctions);

		for (DWORD i = 0; i < names_count; i++)
		{
			exported_symbol symbol{};
			symbol.ordinal = ordinals.get(i);
			symbol.name = buffer.as_string(names.get(i));
			symbol.rva = functions.get(symbol.ordinal);
			symbol.address = binary.image_base + symbol.rva;

			binary.exports.push_back(std::move(symbol));
		}

		for (const auto& symbol : binary.exports)
		{
			binary.address_names.try_emplace(symbol.address, symbol.name);
		}
	}

	template <typename T>
		requires(std::is_integral_v<T>)
	void apply_relocation(const utils::safe_buffer_accessor<uint8_t> buffer, const uint64_t offset,
	                      const uint64_t delta)
	{
		const auto obj = buffer.as<T>(offset);
		const auto value = obj.get();
		const auto new_value = value + static_cast<T>(delta);
		obj.set(new_value);
	}

	void apply_relocations(const mapped_module& binary, const utils::safe_buffer_accessor<uint8_t> buffer,
	                       const IMAGE_OPTIONAL_HEADER& optional_header)
	{
		const auto delta = binary.image_base - optional_header.ImageBase;
		if (delta == 0)
		{
			return;
		}

		const auto directory = &optional_header.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
		if (directory->Size == 0)
		{
			return;
		}

		auto relocation_offset = directory->VirtualAddress;
		const auto relocation_end = relocation_offset + directory->Size;

		while (relocation_offset < relocation_end)
		{
			const auto relocation = buffer.as<IMAGE_BASE_RELOCATION>(relocation_offset).get();

			if (relocation.VirtualAddress <= 0 || relocation.SizeOfBlock <= sizeof(IMAGE_BASE_RELOCATION))
			{
				break;
			}

			const auto data_size = relocation.SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION);
			const auto entry_count = data_size / sizeof(uint16_t);

			const auto entries = buffer.as<uint16_t>(relocation_offset + sizeof(IMAGE_BASE_RELOCATION));

			relocation_offset += relocation.SizeOfBlock;

			for (size_t i = 0; i < entry_count; ++i)
			{
				const auto entry = entries.get(i);

				const int type = entry >> 12;
				const int offset = entry & 0xfff;
				const auto total_offset = relocation.VirtualAddress + offset;

				switch (type)
				{
				case IMAGE_REL_BASED_ABSOLUTE:
					break;

				case IMAGE_REL_BASED_HIGHLOW:
					apply_relocation<DWORD>(buffer, total_offset, delta);
					break;

				case IMAGE_REL_BASED_DIR64:
					apply_relocation<ULONGLONG>(buffer, total_offset, delta);
					break;

				default:
					throw std::runtime_error("Unknown relocation type: " + std::to_string(type));
				}
			}
		}
	}

	void map_sections(emulator& emu, const mapped_module& binary,
	                  const utils::safe_buffer_accessor<const uint8_t> buffer,
	                  const IMAGE_NT_HEADERS& nt_headers, const uint64_t nt_headers_offset)
	{
		const auto first_section_offset = get_first_section_offset(nt_headers, nt_headers_offset);
		const auto sections = buffer.as<IMAGE_SECTION_HEADER>(first_section_offset);

		for (size_t i = 0; i < nt_headers.FileHeader.NumberOfSections; ++i)
		{
			const auto section = sections.get(i);
			const auto target_ptr = binary.image_base + section.VirtualAddress;

			if (section.SizeOfRawData > 0)
			{
				const auto size_of_data = std::min(section.SizeOfRawData, section.Misc.VirtualSize);
				const auto* source_ptr = buffer.get_pointer_for_range(section.PointerToRawData, size_of_data);
				emu.write_memory(target_ptr, source_ptr, size_of_data);
			}

			auto permissions = memory_permission::none;

			if (section.Characteristics & IMAGE_SCN_MEM_EXECUTE)
			{
				permissions |= memory_permission::exec;
			}

			if (section.Characteristics & IMAGE_SCN_MEM_READ)
			{
				permissions |= memory_permission::read;
			}

			if (section.Characteristics & IMAGE_SCN_MEM_WRITE)
			{
				permissions |= memory_permission::write;
			}

			const auto size_of_section = page_align_up(std::max(section.SizeOfRawData, section.Misc.VirtualSize));

			emu.protect_memory(target_ptr, size_of_section, permissions, nullptr);
		}
	}

	std::optional<mapped_module> map_module(emulator& emu, const std::span<const uint8_t> data,
	                                        std::filesystem::path file)
	{
		mapped_module binary{};
		binary.path = std::move(file);
		binary.name = binary.path.filename().string();

		utils::safe_buffer_accessor buffer{data};

		const auto dos_header = buffer.as<IMAGE_DOS_HEADER>(0).get();
		const auto nt_headers_offset = dos_header.e_lfanew;

		const auto nt_headers = buffer.as<IMAGE_NT_HEADERS>(nt_headers_offset).get();
		auto& optional_header = nt_headers.OptionalHeader;

		binary.image_base = optional_header.ImageBase;
		binary.size_of_image = optional_header.SizeOfImage; // TODO: Sanitize

		if (!emu.allocate_memory(binary.image_base, binary.size_of_image, memory_permission::read))
		{
			binary.image_base = emu.find_free_allocation_base(binary.size_of_image);
			const auto is_dll = nt_headers.FileHeader.Characteristics & IMAGE_FILE_DLL;
			const auto has_dynamic_base =
				optional_header.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE;
			const auto is_relocatable = is_dll || has_dynamic_base;

			if (!is_relocatable || !emu.allocate_memory(binary.image_base, binary.size_of_image,
			                                            memory_permission::read))
			{
				return {};
			}
		}

		binary.entry_point = binary.image_base + optional_header.AddressOfEntryPoint;

		const auto* header_buffer = buffer.get_pointer_for_range(0, optional_header.SizeOfHeaders);
		emu.write_memory(binary.image_base, header_buffer,
		                 optional_header.SizeOfHeaders);

		map_sections(emu, binary, buffer, nt_headers, nt_headers_offset);

		auto mapped_memory = read_mapped_memory(emu, binary);
		utils::safe_buffer_accessor<uint8_t> mapped_buffer{mapped_memory};

		apply_relocations(binary, mapped_buffer, optional_header);
		collect_exports(binary, mapped_buffer, optional_header);

		emu.write_memory(binary.image_base, mapped_memory.data(), mapped_memory.size());

		return binary;
	}
}

std::optional<mapped_module> map_module_from_data(emulator& emu, const std::span<const uint8_t> data,
                                                  std::filesystem::path file)
{
	try
	{
		return map_module(emu, data, std::move(file));
	}
	catch (...)
	{
		return {};
	}
}

std::optional<mapped_module> map_module_from_file(emulator& emu, std::filesystem::path file)
{
	const auto data = utils::io::read_file(file);
	if (data.empty())
	{
		return {};
	}

	return map_module_from_data(emu, data, std::move(file));
}

bool unmap_module(emulator& emu, const mapped_module& mod)
{
	return emu.release_memory(mod.image_base, mod.size_of_image);
}

```

`src/windows-emulator/module/module_mapping.hpp`:

```hpp
#pragma once

#include <x64_emulator.hpp>
#include "mapped_module.hpp"

std::optional<mapped_module> map_module_from_data(emulator& emu, std::span<const uint8_t> data,
                                                  std::filesystem::path file);
std::optional<mapped_module> map_module_from_file(emulator& emu, std::filesystem::path file);

bool unmap_module(emulator& emu, const mapped_module& mod);

```

`src/windows-emulator/process_context.hpp`:

```hpp
#pragma once

#include "emulator_utils.hpp"
#include "handles.hpp"

#include "module/module_manager.hpp"
#include <utils/nt_handle.hpp>

#include <x64_emulator.hpp>

#define PEB_SEGMENT_SIZE (1 << 20) // 1 MB
#define GS_SEGMENT_SIZE (1 << 20) // 1 MB

#define IA32_GS_BASE_MSR 0xC0000101

#define KUSD_ADDRESS 0x7ffe0000

#define STACK_SIZE 0x40000ULL

#define GDT_ADDR 0x30000
#define GDT_LIMIT 0x1000
#define GDT_ENTRY_SIZE 0x8

struct ref_counted_object
{
	uint32_t ref_count{1};

	void serialize(utils::buffer_serializer& buffer) const
	{
		buffer.write(this->ref_count);
	}

	void deserialize(utils::buffer_deserializer& buffer)
	{
		buffer.read(this->ref_count);
	}

	static bool deleter(ref_counted_object& e)
	{
		return --e.ref_count == 0;
	}
};

struct event : ref_counted_object
{
	bool signaled{};
	EVENT_TYPE type{};
	std::wstring name{};

	bool is_signaled()
	{
		const auto res = this->signaled;

		if (this->type == SynchronizationEvent)
		{
			this->signaled = false;
		}

		return res;
	}

	void serialize(utils::buffer_serializer& buffer) const
	{
		buffer.write(this->signaled);
		buffer.write(this->type);
		buffer.write(this->name);

		ref_counted_object::serialize(buffer);
	}

	void deserialize(utils::buffer_deserializer& buffer)
	{
		buffer.read(this->signaled);
		buffer.read(this->type);
		buffer.read(this->name);

		ref_counted_object::deserialize(buffer);
	}
};

struct file
{
	utils::nt::handle<utils::nt::invalid_handle> handle{};
	std::wstring name{};

	void serialize(utils::buffer_serializer& buffer) const
	{
		buffer.write(this->name);
		// TODO: Serialize handle
	}

	void deserialize(utils::buffer_deserializer& buffer)
	{
		buffer.read(this->name);
		this->handle = INVALID_HANDLE_VALUE;
	}
};

struct semaphore
{
	std::wstring name{};
	volatile uint32_t current_count{};
	uint32_t max_count{};

	void serialize(utils::buffer_serializer& buffer) const
	{
		buffer.write(this->name);
		buffer.write(this->current_count);
		buffer.write(this->max_count);
	}

	void deserialize(utils::buffer_deserializer& buffer)
	{
		buffer.read(this->name);
		buffer.read(this->current_count);
		buffer.read(this->max_count);
	}
};

struct port
{
	std::wstring name{};
	uint64_t view_base{};

	void serialize(utils::buffer_serializer& buffer) const
	{
		buffer.write(this->name);
		buffer.write(this->view_base);
	}

	void deserialize(utils::buffer_deserializer& buffer)
	{
		buffer.read(this->name);
		buffer.read(this->view_base);
	}
};

struct process_context;

class moved_marker
{
public:
	moved_marker() = default;

	moved_marker(const moved_marker& copy) = default;
	moved_marker& operator=(const moved_marker&) = default;

	moved_marker(moved_marker&& obj) noexcept
		: moved_marker()
	{
		this->operator=(std::move(obj));
	}

	moved_marker& operator=(moved_marker&& obj) noexcept
	{
		if (this != &obj)
		{
			this->was_moved_ = obj.was_moved_;
			obj.was_moved_ = true;
		}

		return *this;
	}

	~moved_marker() = default;

	bool was_moved() const
	{
		return this->was_moved_;
	}

private:
	bool was_moved_{false};
};

class emulator_thread : ref_counted_object
{
public:
	emulator_thread() = default;

	emulator_thread(x64_emulator& emu, const process_context& context, uint64_t start_address, uint64_t argument,
	                uint64_t stack_size, uint32_t id);

	emulator_thread(const emulator_thread&) = delete;
	emulator_thread& operator=(const emulator_thread&) = delete;

	emulator_thread(emulator_thread&& obj) noexcept = default;
	emulator_thread& operator=(emulator_thread&& obj) noexcept = default;

	~emulator_thread()
	{
		if (marker.was_moved())
		{
			return;
		}

		if (this->stack_base)
		{
			this->emu_ptr->release_memory(this->stack_base, this->stack_size);
		}

		if (this->gs_segment)
		{
			this->gs_segment->release();
		}
	}

	moved_marker marker{};

	x64_emulator* emu_ptr{};

	uint64_t stack_base{};
	uint64_t stack_size{};
	uint64_t start_address{};
	uint64_t argument{};
	uint64_t executed_instructions{0};

	uint32_t id{};

	std::optional<uint32_t> exit_status{};
	std::optional<handle> await_object{};

	std::optional<emulator_allocator> gs_segment;
	std::optional<emulator_object<TEB>> teb;

	std::vector<std::byte> last_registers{};

	void save(x64_emulator& emu)
	{
		this->last_registers = emu.save_registers();
	}

	void restore(x64_emulator& emu) const
	{
		emu.restore_registers(this->last_registers);
	}

	void setup_if_necessary(x64_emulator& emu, const process_context& context) const
	{
		if (!this->executed_instructions)
		{
			this->setup_registers(emu, context);
		}
	}

	void serialize(utils::buffer_serializer&) const
	{
		// TODO
	}

	void deserialize(utils::buffer_deserializer&)
	{
		// TODO
	}

private:
	void setup_registers(x64_emulator& emu, const process_context& context) const;
};

struct process_context
{
	process_context(x64_emulator& emu)
		: base_allocator(emu)
		  , peb(emu)
		  , process_params(emu)
		  , kusd(emu)
		  , module_manager(emu)
	{
	}

	uint64_t executed_instructions{0};
	uint64_t current_ip{0};
	uint64_t previous_ip{0};

	std::optional<uint64_t> exception_rip{};

	emulator_allocator base_allocator;

	emulator_object<PEB> peb;
	emulator_object<RTL_USER_PROCESS_PARAMETERS> process_params;
	emulator_object<KUSER_SHARED_DATA> kusd;

	module_manager module_manager;

	mapped_module* executable{};
	mapped_module* ntdll{};
	mapped_module* win32u{};

	uint64_t ldr_initialize_thunk{};
	uint64_t rtl_user_thread_start{};
	uint64_t ki_user_exception_dispatcher{};

	uint64_t shared_section_size{};

	handle_store<handle_types::event, event> events{};
	handle_store<handle_types::file, file> files{};
	handle_store<handle_types::semaphore, semaphore> semaphores{};
	handle_store<handle_types::port, port> ports{};
	std::map<uint16_t, std::wstring> atoms{};

	std::vector<std::byte> default_register_set{};

	uint32_t current_thread_id{0};
	handle_store<handle_types::thread, emulator_thread> threads{};
	emulator_thread* active_thread{nullptr};

	void serialize(utils::buffer_serializer& buffer) const
	{
		buffer.write(this->executed_instructions);
		buffer.write(this->current_ip);
		buffer.write(this->previous_ip);
		buffer.write_optional(this->exception_rip);
		buffer.write(this->peb);
		buffer.write(this->process_params);
		buffer.write(this->kusd);
		buffer.write(this->module_manager);

		buffer.write(this->executable->image_base);
		buffer.write(this->ntdll->image_base);
		buffer.write(this->win32u->image_base);

		buffer.write(this->ki_user_exception_dispatcher);

		buffer.write(this->shared_section_size);
		buffer.write(this->events);
		buffer.write(this->files);
		buffer.write(this->semaphores);
		buffer.write(this->ports);
		buffer.write_map(this->atoms);

		// TODO: Serialize/deserialize threads
	}

	void deserialize(utils::buffer_deserializer& buffer)
	{
		buffer.read(this->executed_instructions);
		buffer.read(this->current_ip);
		buffer.read(this->previous_ip);
		buffer.read_optional(this->exception_rip);
		buffer.read(this->peb);
		buffer.read(this->process_params);
		buffer.read(this->kusd);
		buffer.read(this->module_manager);

		const auto executable_base = buffer.read<uint64_t>();
		const auto ntdll_base = buffer.read<uint64_t>();
		const auto win32u_base = buffer.read<uint64_t>();

		this->executable = this->module_manager.find_by_address(executable_base);
		this->ntdll = this->module_manager.find_by_address(ntdll_base);
		this->win32u = this->module_manager.find_by_address(win32u_base);

		buffer.read(this->ki_user_exception_dispatcher);

		buffer.read(this->shared_section_size);
		buffer.read(this->events);
		buffer.read(this->files);
		buffer.read(this->semaphores);
		buffer.read(this->ports);
		buffer.read_map(this->atoms);
	}

	handle create_thread(x64_emulator& emu, const uint64_t start_address, const uint64_t argument,
	                     const uint64_t stack_size)
	{
		emulator_thread t{emu, *this, start_address, argument, stack_size, ++this->current_thread_id};
		return this->threads.store(std::move(t));
	}
};

```

`src/windows-emulator/std_include.hpp`:

```hpp
#pragma once

#ifdef _WIN32
#pragma warning(push)
#pragma warning(disable: 4005)
#pragma warning(disable: 4127)
#pragma warning(disable: 4201)
#pragma warning(disable: 4244)
#pragma warning(disable: 4245)
#pragma warning(disable: 4324)
#pragma warning(disable: 4458)
#pragma warning(disable: 4471)
#pragma warning(disable: 4505)
#pragma warning(disable: 4702)
#pragma warning(disable: 4996)
#pragma warning(disable: 5054)
#pragma warning(disable: 6011)
#pragma warning(disable: 6297)
#pragma warning(disable: 6385)
#pragma warning(disable: 6386)
#pragma warning(disable: 6387)
#pragma warning(disable: 26110)
#pragma warning(disable: 26451)
#pragma warning(disable: 26444)
#pragma warning(disable: 26451)
#pragma warning(disable: 26489)
#pragma warning(disable: 26495)
#pragma warning(disable: 26498)
#pragma warning(disable: 26812)
#pragma warning(disable: 28020)

#define WIN32_LEAN_AND_MEAN
#define NOMINMAX

#include <map>
#include <set>
#include <list>
#include <array>
#include <deque>
#include <queue>
#include <thread>
#include <ranges>
#include <atomic>
#include <vector>
#include <mutex>
#include <string>
#include <chrono>
#include <memory>
#include <fstream>
#include <functional>
#include <filesystem>
#include <optional>
#include <stdexcept>
#include <string_view>
#include <unordered_set>
#include <condition_variable>

#include <cassert>

#define NTDDI_WIN11_GE 0
#define PHNT_VERSION PHNT_WIN11
#include <phnt_windows.h>
#include <phnt.h>
#include <ntgdi.h>

#ifdef _WIN32
#pragma warning(pop)
#endif

#ifdef max
#undef max
#endif

#ifdef min
#undef min
#endif
#endif

using namespace std::literals;

```

`src/windows-emulator/syscalls.cpp`:

```cpp
#include "std_include.hpp"
#include "syscalls.hpp"

#include <numeric>

#include "context_frame.hpp"
#include "emulator_utils.hpp"
#include "windows_emulator.hpp"

#include <utils/io.hpp>


struct syscall_context
{
	windows_emulator& win_emu;
	x64_emulator& emu;
	process_context& proc;
	mutable bool write_status{true};
	mutable bool retrigger_syscall{false};
};

namespace
{
	uint64_t get_syscall_argument(x64_emulator& emu, const size_t index)
	{
		switch (index)
		{
		case 0:
			return emu.reg(x64_register::r10);
		case 1:
			return emu.reg(x64_register::rdx);
		case 2:
			return emu.reg(x64_register::r8);
		case 3:
			return emu.reg(x64_register::r9);
		default:
			return emu.read_stack(index + 1);
		}
	}

	bool is_uppercase(const char character)
	{
		return toupper(character) == character;
	}

	bool is_syscall(const std::string_view name)
	{
		return name.starts_with("Nt") && name.size() > 3 && is_uppercase(name[2]);
	}

	std::vector<std::string> find_syscalls(const exported_symbols& exports)
	{
		// Makes use of the fact that order of Nt* function addresses
		// is equal to the order of syscall IDs.
		// So first Nt* function is the first syscall with ID 0

		std::map<uint64_t, size_t> reference_count{};
		std::map<uint64_t, std::string> ordered_syscalls{};

		for (const auto& symbol : exports)
		{
			if (is_syscall(symbol.name))
			{
				++reference_count[symbol.address];
				ordered_syscalls[symbol.address] = symbol.name;
			}
		}

		std::vector<std::string> syscalls{};
		syscalls.reserve(ordered_syscalls.size());

		for (auto& syscall : ordered_syscalls)
		{
			if (reference_count[syscall.first] == 1)
			{
				syscalls.push_back(std::move(syscall.second));
			}
		}

		return syscalls;
	}

	void map_syscalls(std::unordered_map<uint64_t, syscall_handler_entry>& handlers,
	                  const std::vector<std::string>& syscalls, const uint64_t base_index)
	{
		for (size_t i = 0; i < syscalls.size(); ++i)
		{
			const auto& syscall = syscalls[i];

			auto& entry = handlers[base_index + i];
			entry.name = syscall;
			entry.handler = nullptr;
		}
	}

	template <typename T>
		requires(std::is_integral_v<T> || std::is_enum_v<T>)
	T resolve_argument(x64_emulator& emu, const size_t index)
	{
		const auto arg = get_syscall_argument(emu, index);
		return static_cast<T>(arg);
	}

	template <typename T>
		requires(std::is_same_v<T, emulator_object<typename T::value_type>>)
	T resolve_argument(x64_emulator& emu, const size_t index)
	{
		const auto arg = get_syscall_argument(emu, index);
		return T(emu, arg);
	}

	template <typename T>
	T resolve_indexed_argument(x64_emulator& emu, size_t& index)
	{
		return resolve_argument<T>(emu, index++);
	}

	void write_status(const syscall_context& c, const NTSTATUS status, const uint64_t initial_ip)
	{
		if (c.write_status)
		{
			c.emu.reg<uint64_t>(x64_register::rax, static_cast<uint64_t>(status));
		}

		const auto new_ip = c.emu.read_instruction_pointer();
		if (initial_ip != new_ip || c.retrigger_syscall)
		{
			c.emu.reg(x64_register::rip, new_ip - 2);
		}
	}

	void forward_syscall(const syscall_context& c, NTSTATUS (*handler)())
	{
		const auto ip = c.emu.read_instruction_pointer();

		const auto ret = handler();
		write_status(c, ret, ip);
	}

	template <typename... Args>
	void forward_syscall(const syscall_context& c, NTSTATUS (*handler)(const syscall_context&, Args...))
	{
		const auto ip = c.emu.read_instruction_pointer();

		size_t index = 0;
		std::tuple<const syscall_context&, Args...> func_args
		{
			c,
			resolve_indexed_argument<std::remove_cv_t<std::remove_reference_t<Args>>>(c.emu, index)...
		};

		const auto ret = std::apply(handler, std::move(func_args));
		write_status(c, ret, ip);
	}

	template <auto Handler>
	syscall_handler make_syscall_handler()
	{
		return +[](const syscall_context& c)
		{
			forward_syscall(c, Handler);
		};
	}

	template <typename T>
	void write_attribute(emulator& emu, const PS_ATTRIBUTE& attribute, const T& value)
	{
		if (attribute.ReturnLength)
		{
			emulator_object<SIZE_T>{emu, attribute.ReturnLength}.write(sizeof(T));
		}

		if (attribute.Size >= sizeof(T))
		{
			emulator_object<T>{emu, attribute.Value}.write(value);
		}
	}

	bool is_object_signaled(process_context& c, const handle h)
	{
		const auto type = h.value.type;

		switch (type)
		{
		case handle_types::event:
			{
				const auto* e = c.events.get(h);
				if (e)
				{
					return e->signaled;
				}

				break;
			}

		case handle_types::thread:
			{
				const auto* t = c.threads.get(h);
				if (t)
				{
					return t->exit_status.has_value();
				}

				break;
			}
		}
		throw std::runtime_error("Bad object");
	}

	NTSTATUS handle_NtQueryPerformanceCounter(const syscall_context&,
	                                          const emulator_object<LARGE_INTEGER> performance_counter,
	                                          const emulator_object<LARGE_INTEGER> performance_frequency)
	{
		try
		{
			if (performance_counter)
			{
				performance_counter.access([](LARGE_INTEGER& value)
				{
					QueryPerformanceCounter(&value);
				});
			}

			if (performance_frequency)
			{
				performance_frequency.access([](LARGE_INTEGER& value)
				{
					QueryPerformanceFrequency(&value);
				});
			}

			return STATUS_SUCCESS;
		}
		catch (...)
		{
			return STATUS_ACCESS_VIOLATION;
		}
	}

	NTSTATUS handle_NtManageHotPatch()
	{
		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtCreateWorkerFactory()
	{
		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtOpenKey(const syscall_context& c, const emulator_object<uint64_t> /*key_handle*/,
	                          const ACCESS_MASK /*desired_access*/,
	                          const emulator_object<OBJECT_ATTRIBUTES> object_attributes)
	{
		const auto attributes = object_attributes.read();
		const auto key = read_unicode_string(c.emu, attributes.ObjectName);

		c.win_emu.logger.print(color::dark_gray, "--> Registry key: %S\n", key.c_str());

		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtOpenKeyEx()
	{
		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtSetInformationThread(const syscall_context& c, const uint64_t /*thread_handle*/,
	                                       const THREADINFOCLASS info_class,
	                                       const uint64_t /*thread_information*/,
	                                       const uint32_t /*thread_information_length*/)
	{
		if (info_class == ThreadSchedulerSharedDataSlot)
		{
			return STATUS_SUCCESS;
		}

		printf("Unsupported thread info class: %X\n", info_class);
		c.emu.stop();
		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtSetEvent(const syscall_context& c, const uint64_t handle,
	                           const emulator_object<LONG> previous_state)
	{
		const auto entry = c.proc.events.get(handle);
		if (!entry)
		{
			return STATUS_INVALID_HANDLE;
		}

		if (previous_state.value())
		{
			previous_state.write(entry->signaled ? 1ULL : 0ULL);
		}

		entry->signaled = true;
		return STATUS_SUCCESS;
	}

	NTSTATUS handle_NtClose(const syscall_context& c, const uint64_t handle)
	{
		const auto value = get_handle_value(handle);
		if (value.is_pseudo)
		{
			return STATUS_SUCCESS;
		}

		if (value.type == handle_types::thread && c.proc.threads.erase(handle))
		{
			return STATUS_SUCCESS;
		}

		if (value.type == handle_types::event && c.proc.events.erase(handle))
		{
			return STATUS_SUCCESS;
		}

		if (value.type == handle_types::file && c.proc.files.erase(handle))
		{
			return STATUS_SUCCESS;
		}

		if (value.type == handle_types::semaphore && c.proc.semaphores.erase(handle))
		{
			return STATUS_SUCCESS;
		}

		return STATUS_INVALID_HANDLE;
	}

	NTSTATUS handle_NtTraceEvent()
	{
		return STATUS_SUCCESS;
	}

	NTSTATUS handle_NtOpenThreadToken()
	{
		return STATUS_NO_TOKEN;
	}

	NTSTATUS handle_NtCreateEvent(const syscall_context& c, const emulator_object<uint64_t> event_handle,
	                              const ACCESS_MASK /*desired_access*/,
	                              const emulator_object<OBJECT_ATTRIBUTES> object_attributes,
	                              const EVENT_TYPE event_type, const BOOLEAN initial_state)
	{
		std::wstring name{};
		if (object_attributes)
		{
			const auto attributes = object_attributes.read();
			if (attributes.ObjectName)
			{
				name = read_unicode_string(c.emu, attributes.ObjectName);
			}
		}

		event e{};
		e.type = event_type;
		e.signaled = initial_state != FALSE;
		e.name = std::move(name);

		const auto handle = c.proc.events.store(std::move(e));
		event_handle.write(handle.bits);

		static_assert(sizeof(EVENT_TYPE) == sizeof(uint32_t));
		static_assert(sizeof(ACCESS_MASK) == sizeof(uint32_t));

		return STATUS_SUCCESS;
	}

	NTSTATUS handle_NtOpenEvent(const syscall_context& c, const emulator_object<uint64_t> event_handle,
	                            const ACCESS_MASK /*desired_access*/,
	                            const emulator_object<OBJECT_ATTRIBUTES> object_attributes)
	{
		const auto attributes = object_attributes.read();
		const auto name = read_unicode_string(c.emu, attributes.ObjectName);

		for (auto& entry : c.proc.events)
		{
			if (entry.second.name == name)
			{
				++entry.second.ref_count;
				event_handle.write(c.proc.events.make_handle(entry.first).bits);
				return STATUS_SUCCESS;
			}
		}

		return STATUS_NOT_FOUND;
	}

	NTSTATUS handle_NtQueryVolumeInformationFile(const syscall_context& c, uint64_t file_handle,
	                                             uint64_t /*io_status_block*/, uint64_t fs_information,
	                                             ULONG /*length*/,
	                                             FS_INFORMATION_CLASS fs_information_class)
	{
		if (fs_information_class != FileFsDeviceInformation)
		{
			printf("Unsupported fs info class: %X\n", fs_information_class);
			c.emu.stop();
			return STATUS_NOT_SUPPORTED;
		}

		const emulator_object<FILE_FS_DEVICE_INFORMATION> info_obj{c.emu, fs_information};
		info_obj.access([&](FILE_FS_DEVICE_INFORMATION& info)
		{
			if (file_handle == STDOUT_HANDLE.bits && !c.win_emu.buffer_stdout)
			{
				info.DeviceType = FILE_DEVICE_CONSOLE;
				info.Characteristics = 0x20000;
			}
			else
			{
				info.DeviceType = FILE_DEVICE_DISK;
				info.Characteristics = 0x20020;
			}
		});

		return STATUS_SUCCESS;
	}

	NTSTATUS handle_NtOpenFile(const syscall_context& c,
	                           const emulator_object<uint64_t> file_handle,
	                           const ACCESS_MASK desired_access,
	                           const emulator_object<OBJECT_ATTRIBUTES> object_attributes,
	                           const emulator_object<IO_STATUS_BLOCK> /*io_status_block*/,
	                           const ULONG share_access,
	                           const ULONG open_options)
	{
		file f{};
		const auto attributes = object_attributes.read();
		f.name = read_unicode_string(c.emu, attributes.ObjectName);

		UNICODE_STRING string{};
		string.Buffer = f.name.data();
		string.Length = static_cast<uint16_t>(f.name.size() * 2);
		string.MaximumLength = string.Length;

		OBJECT_ATTRIBUTES new_attributes{};
		new_attributes.ObjectName = &string;
		new_attributes.Length = sizeof(new_attributes);

		HANDLE h{};
		IO_STATUS_BLOCK status_block{};

		const auto res = NtOpenFile(&h, desired_access, &new_attributes, &status_block, share_access, open_options);
		if (res != STATUS_SUCCESS)
		{
			return res;
		}

		f.handle = h;

		const auto handle = c.proc.files.store(std::move(f));
		file_handle.write(handle.bits);

		return STATUS_SUCCESS;
	}

	NTSTATUS handle_NtOpenSection(const syscall_context& c, const emulator_object<uint64_t> section_handle,
	                              const ACCESS_MASK /*desired_access*/,
	                              const emulator_object<OBJECT_ATTRIBUTES> object_attributes)
	{
		const auto attributes = object_attributes.read();

		auto filename = read_unicode_string(c.emu, attributes.ObjectName);
		c.win_emu.logger.print(color::gray, "Opening section: %S\n", filename.c_str());

		if (filename == L"\\Windows\\SharedSection")
		{
			section_handle.write(SHARED_SECTION.bits);
			return STATUS_SUCCESS;
		}

		if (reinterpret_cast<uint64_t>(attributes.RootDirectory) != KNOWN_DLLS_DIRECTORY)
		{
			puts("Unsupported section");
			c.emu.stop();
			return STATUS_NOT_SUPPORTED;
		}

		if (filename.starts_with(L"api-ms-"))
		{
			filename = L"C:\\WINDOWS\\System32\\downlevel\\" + filename;
		}
		else
		{
			filename = L"C:\\WINDOWS\\System32\\" + filename;
		}

		if (!std::filesystem::exists(filename))
		{
			return STATUS_FILE_INVALID;
		}

		file f{};
		f.name = std::move(filename);

		const auto handle = c.proc.files.store(std::move(f));
		section_handle.write(handle.bits);

		return STATUS_SUCCESS;
	}

	auto handle_NtMapViewOfSection(const syscall_context& c, uint64_t section_handle, uint64_t process_handle,
	                               emulator_object<uint64_t> base_address, ULONG_PTR /*zero_bits*/,
	                               SIZE_T /*commit_size*/,
	                               const emulator_object<LARGE_INTEGER> /*section_offset*/,
	                               const emulator_object<SIZE_T> view_size, SECTION_INHERIT /*inherit_disposition*/,
	                               ULONG /*allocation_type*/, ULONG /*win32_protect*/) -> NTSTATUS
	{
		if (process_handle != ~0ULL)
		{
			return STATUS_INVALID_HANDLE;
		}

		if (section_handle == SHARED_SECTION)
		{
			const auto address = c.emu.find_free_allocation_base(c.proc.shared_section_size);
			c.emu.allocate_memory(address,
			                      c.proc.shared_section_size, memory_permission::read_write);

			size_t windows_dir_size{};
			c.proc.kusd.access([&](const KUSER_SHARED_DATA& kusd)
			{
				const std::wstring_view windows_dir = kusd.NtSystemRoot.arr;
				windows_dir_size = windows_dir.size() * 2;
			});

			constexpr auto windows_dir_offset = 0x10;
			c.emu.write_memory(address + 8, windows_dir_offset);

			const auto obj_address = address + windows_dir_offset;

			const emulator_object<UNICODE_STRING> windir_obj{c.emu, obj_address};
			windir_obj.access([&](UNICODE_STRING& ucs)
			{
				const auto dir_address = c.proc.kusd.value() + offsetof(KUSER_SHARED_DATA, NtSystemRoot);

				ucs.Buffer = reinterpret_cast<wchar_t*>(dir_address - obj_address);
				ucs.Length = static_cast<uint16_t>(windows_dir_size);
				ucs.MaximumLength = ucs.Length;
			});


			const emulator_object<UNICODE_STRING> sysdir_obj{c.emu, obj_address + windir_obj.size()};
			sysdir_obj.access([&](UNICODE_STRING& ucs)
			{
				c.proc.base_allocator.make_unicode_string(ucs, L"C:\\WINDOWS\\System32");
				ucs.Buffer = reinterpret_cast<wchar_t*>(reinterpret_cast<uint64_t>(ucs.Buffer) - obj_address);
			});

			if (view_size.value())
			{
				view_size.write(c.proc.shared_section_size);
			}

			base_address.write(address);

			return STATUS_SUCCESS;
		}

		const auto section_entry = c.proc.files.get(section_handle);
		if (!section_entry)
		{
			return STATUS_INVALID_HANDLE;
		}

		const auto binary = c.proc.module_manager.map_module(section_entry->name, c.win_emu.logger);
		if (!binary)
		{
			return STATUS_FILE_INVALID;
		}

		if (view_size.value())
		{
			view_size.write(binary->size_of_image);
		}

		base_address.write(binary->image_base);

		return STATUS_SUCCESS;
	}


	NTSTATUS handle_NtCreateIoCompletion(const syscall_context& c, const emulator_object<uint64_t> event_handle,
	                                     const ACCESS_MASK desired_access,
	                                     const emulator_object<OBJECT_ATTRIBUTES> object_attributes,
	                                     uint32_t /*number_of_concurrent_threads*/)
	{
		return handle_NtCreateEvent(c, event_handle, desired_access, object_attributes, NotificationEvent, FALSE);
	}

	NTSTATUS handle_NtCreateWaitCompletionPacket(const syscall_context& c, const emulator_object<uint64_t> event_handle,
	                                             const ACCESS_MASK desired_access,
	                                             const emulator_object<OBJECT_ATTRIBUTES> object_attributes)
	{
		return handle_NtCreateEvent(c, event_handle, desired_access, object_attributes, NotificationEvent, FALSE);
	}

	NTSTATUS handle_NtQueryVirtualMemory(const syscall_context& c, const uint64_t process_handle,
	                                     const uint64_t base_address, const uint32_t info_class,
	                                     const uint64_t memory_information, const uint32_t memory_information_length,
	                                     const emulator_object<uint32_t> return_length)
	{
		if (process_handle != ~0ULL)
		{
			return STATUS_NOT_SUPPORTED;
		}

		if (info_class == MemoryWorkingSetExInformation
			|| info_class == MemoryImageExtensionInformation)
		{
			return STATUS_NOT_SUPPORTED;
		}

		if (info_class == MemoryBasicInformation)
		{
			if (return_length)
			{
				return_length.write(sizeof(MEMORY_BASIC_INFORMATION));
			}

			if (memory_information_length != sizeof(MEMORY_BASIC_INFORMATION))
			{
				return STATUS_BUFFER_OVERFLOW;
			}

			const emulator_object<MEMORY_BASIC_INFORMATION> info{c.emu, memory_information};

			info.access([&](MEMORY_BASIC_INFORMATION& image_info)
			{
				const auto region_info = c.emu.get_region_info(base_address);

				assert(!region_info.is_committed || region_info.is_reserved);

				image_info.BaseAddress = reinterpret_cast<void*>(region_info.start);
				image_info.AllocationBase = reinterpret_cast<void*>(region_info.allocation_base);
				image_info.AllocationProtect = 0;
				image_info.PartitionId = 0;
				image_info.RegionSize = region_info.length;
				image_info.State = region_info.is_committed
					                   ? MEM_COMMIT
					                   : (region_info.is_reserved
						                      ? MEM_RESERVE
						                      : MEM_FREE);
				image_info.Protect = map_emulator_to_nt_protection(region_info.pemissions);
				image_info.Type = MEM_PRIVATE;
			});

			return STATUS_SUCCESS;
		}

		if (info_class == MemoryImageInformation)
		{
			if (return_length)
			{
				return_length.write(sizeof(MEMORY_IMAGE_INFORMATION));
			}

			if (memory_information_length != sizeof(MEMORY_IMAGE_INFORMATION))
			{
				return STATUS_BUFFER_OVERFLOW;
			}

			const auto mod = c.proc.module_manager.find_by_address(base_address);
			if (!mod)
			{
				printf("Bad address for memory image request: 0x%llX\n", base_address);
				return STATUS_INVALID_ADDRESS;
			}

			const emulator_object<MEMORY_IMAGE_INFORMATION> info{c.emu, memory_information};

			info.access([&](MEMORY_IMAGE_INFORMATION& image_info)
			{
				image_info.ImageBase = reinterpret_cast<void*>(mod->image_base);
				image_info.SizeOfImage = mod->size_of_image;
			});

			return STATUS_SUCCESS;
		}

		if (info_class == MemoryRegionInformation)
		{
			if (return_length)
			{
				return_length.write(sizeof(MEMORY_REGION_INFORMATION));
			}

			if (memory_information_length != sizeof(MEMORY_REGION_INFORMATION))
			{
				return STATUS_BUFFER_OVERFLOW;
			}

			const auto region_info = c.emu.get_region_info(base_address);
			if (!region_info.is_reserved)
			{
				return STATUS_INVALID_ADDRESS;
			}

			const emulator_object<MEMORY_REGION_INFORMATION> info{c.emu, memory_information};

			info.access([&](MEMORY_REGION_INFORMATION& image_info)
			{
				memset(&image_info, 0, sizeof(image_info));

				image_info.AllocationBase = reinterpret_cast<void*>(region_info.allocation_base);
				image_info.AllocationProtect = 0;
				image_info.PartitionId = 0;
				image_info.RegionSize = region_info.allocation_length;
				image_info.Reserved = 0x10;
			});

			return STATUS_SUCCESS;
		}

		printf("Unsupported memory info class: %X\n", info_class);
		c.emu.stop();
		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtQuerySystemInformation(const syscall_context& c, const uint32_t info_class,
	                                         const uint64_t system_information,
	                                         const uint32_t system_information_length,
	                                         const emulator_object<uint32_t> return_length)
	{
		if (info_class == SystemFlushInformation
			|| info_class == SystemHypervisorSharedPageInformation
		)
		{
			return STATUS_NOT_SUPPORTED;
		}

		if (info_class == SystemTimeOfDayInformation)
		{
			if (return_length)
			{
				return_length.write(sizeof(SYSTEM_TIMEOFDAY_INFORMATION));
			}

			if (system_information_length != sizeof(SYSTEM_TIMEOFDAY_INFORMATION))
			{
				return STATUS_BUFFER_TOO_SMALL;
			}

			const emulator_object<SYSTEM_TIMEOFDAY_INFORMATION> info_obj{c.emu, system_information};

			info_obj.access([&](SYSTEM_TIMEOFDAY_INFORMATION& info)
			{
				info.BootTime.QuadPart = 0;
				// TODO: Fill
			});

			return STATUS_SUCCESS;
		}

		if (info_class == SystemRangeStartInformation)
		{
			if (return_length)
			{
				return_length.write(sizeof(SYSTEM_RANGE_START_INFORMATION));
			}

			if (system_information_length != sizeof(SYSTEM_RANGE_START_INFORMATION))
			{
				return STATUS_BUFFER_TOO_SMALL;
			}

			const emulator_object<SYSTEM_RANGE_START_INFORMATION> info_obj{c.emu, system_information};

			info_obj.access([&](SYSTEM_RANGE_START_INFORMATION& info)
			{
				info.SystemRangeStart = 0xFFFF800000000000;
			});

			return STATUS_SUCCESS;
		}

		if (info_class == SystemProcessorInformation)
		{
			if (return_length)
			{
				return_length.write(sizeof(SYSTEM_PROCESSOR_INFORMATION));
			}

			if (system_information_length != sizeof(SYSTEM_PROCESSOR_INFORMATION))
			{
				return STATUS_BUFFER_TOO_SMALL;
			}

			const emulator_object<SYSTEM_PROCESSOR_INFORMATION> info_obj{c.emu, system_information};

			info_obj.access([&](SYSTEM_PROCESSOR_INFORMATION& info)
			{
				memset(&info, 0, sizeof(info));
				info.MaximumProcessors = 2;
				info.ProcessorArchitecture = PROCESSOR_ARCHITECTURE_AMD64;
			});

			return STATUS_SUCCESS;
		}

		if (info_class == SystemNumaProcessorMap)
		{
			if (return_length)
			{
				return_length.write(sizeof(SYSTEM_NUMA_INFORMATION));
			}

			if (system_information_length != sizeof(SYSTEM_NUMA_INFORMATION))
			{
				return STATUS_BUFFER_TOO_SMALL;
			}

			const emulator_object<SYSTEM_NUMA_INFORMATION> info_obj{c.emu, system_information};

			info_obj.access([&](SYSTEM_NUMA_INFORMATION& info)
			{
				memset(&info, 0, sizeof(info));
				info.ActiveProcessorsGroupAffinity->Mask = 0xFFF;
				info.AvailableMemory[0] = 0xFFF;
				info.Pad[0] = 0xFFF;
			});

			return STATUS_SUCCESS;
		}

		if (info_class == SystemErrorPortTimeouts)
		{
			if (return_length)
			{
				return_length.write(sizeof(SYSTEM_ERROR_PORT_TIMEOUTS));
			}

			if (system_information_length != sizeof(SYSTEM_ERROR_PORT_TIMEOUTS))
			{
				return STATUS_BUFFER_TOO_SMALL;
			}

			const emulator_object<SYSTEM_ERROR_PORT_TIMEOUTS> info_obj{c.emu, system_information};

			info_obj.access([&](SYSTEM_ERROR_PORT_TIMEOUTS& info)
			{
				info.StartTimeout = 0;
				info.CommTimeout = 0;
			});

			return STATUS_SUCCESS;
		}

		if (info_class != SystemBasicInformation && info_class != SystemEmulationBasicInformation)
		{
			printf("Unsupported system info class: %X\n", info_class);
			c.emu.stop();
			return STATUS_NOT_SUPPORTED;
		}

		if (return_length)
		{
			return_length.write(sizeof(SYSTEM_BASIC_INFORMATION));
		}

		if (system_information_length != sizeof(SYSTEM_BASIC_INFORMATION))
		{
			return STATUS_BUFFER_TOO_SMALL;
		}

		const emulator_object<SYSTEM_BASIC_INFORMATION> info{c.emu, system_information};

		info.access([&](SYSTEM_BASIC_INFORMATION& basic_info)
		{
			basic_info.Reserved = 0;
			basic_info.TimerResolution = 0x0002625a;
			basic_info.PageSize = 0x1000;
			basic_info.LowestPhysicalPageNumber = 0x00000001;
			basic_info.HighestPhysicalPageNumber = 0x00c9c7ff;
			basic_info.AllocationGranularity = 0x10000;
			basic_info.MinimumUserModeAddress = 0x0000000000010000;
			basic_info.MaximumUserModeAddress = 0x00007ffffffeffff;
			basic_info.ActiveProcessorsAffinityMask = 0x0000000000000fff;
			basic_info.NumberOfProcessors = 1;
		});

		return STATUS_SUCCESS;
	}

	NTSTATUS handle_NtDuplicateObject(const syscall_context& /*c*/, uint64_t source_process_handle,
	                                  uint64_t source_handle, uint64_t target_process_handle,
	                                  const emulator_object<handle> target_handle,
	                                  const ACCESS_MASK /*desired_access*/, const ULONG /*handle_attributes*/,
	                                  const ULONG /*options*/)
	{
		if (source_process_handle != ~0ULL || target_process_handle != ~0ULL)
		{
			return STATUS_NOT_SUPPORTED;
		}

		handle source{};

		source.bits = source_handle;
		if (source.value.is_pseudo)
		{
			target_handle.write(source);
			return STATUS_SUCCESS;
		}

		puts("Duplicating non-pseudo object not supported yet!");
		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtQuerySystemInformationEx(const syscall_context& c, const uint32_t info_class,
	                                           const uint64_t input_buffer,
	                                           const uint32_t input_buffer_length,
	                                           const uint64_t system_information,
	                                           const uint32_t system_information_length,
	                                           const emulator_object<uint32_t> return_length)
	{
		if (info_class == SystemFlushInformation
			|| info_class == SystemFeatureConfigurationInformation
			|| info_class == SystemSupportedProcessorArchitectures2
			|| info_class == SystemFeatureConfigurationSectionInformation)
		{
			//printf("Unsupported, but allowed system info class: %X\n", info_class);
			return STATUS_NOT_SUPPORTED;
		}

		if (info_class == SystemLogicalProcessorAndGroupInformation)
		{
			void* buffer = calloc(1, input_buffer_length);
			void* res_buff = calloc(1, system_information_length);
			c.emu.read_memory(input_buffer, buffer, input_buffer_length);

			NTSTATUS code = STATUS_SUCCESS;

			return_length.access([&](uint32_t& len)
			{
				code = NtQuerySystemInformationEx(static_cast<SYSTEM_INFORMATION_CLASS>(info_class), buffer,
				                                  input_buffer_length,
				                                  res_buff,
				                                  system_information_length, reinterpret_cast<ULONG*>(&len));
			});

			if (code == 0)
			{
				c.emu.write_memory(system_information, res_buff, return_length.read());
			}

			free(buffer);
			free(res_buff);

			return code;
		}

		if (info_class != SystemBasicInformation && info_class != SystemEmulationBasicInformation)
		{
			printf("Unsupported system info ex class: %X\n", info_class);
			c.emu.stop();
			return STATUS_NOT_SUPPORTED;
		}

		if (return_length)
		{
			return_length.write(sizeof(SYSTEM_BASIC_INFORMATION));
		}

		if (system_information_length != sizeof(SYSTEM_BASIC_INFORMATION))
		{
			return STATUS_BUFFER_TOO_SMALL;
		}

		const emulator_object<SYSTEM_BASIC_INFORMATION> info{c.emu, system_information};

		info.access([&](SYSTEM_BASIC_INFORMATION& basic_info)
		{
			basic_info.Reserved = 0;
			basic_info.TimerResolution = 0x0002625a;
			basic_info.PageSize = 0x1000;
			basic_info.LowestPhysicalPageNumber = 0x00000001;
			basic_info.HighestPhysicalPageNumber = 0x00c9c7ff;
			basic_info.AllocationGranularity = 0x10000;
			basic_info.MinimumUserModeAddress = 0x0000000000010000;
			basic_info.MaximumUserModeAddress = 0x00007ffffffeffff;
			basic_info.ActiveProcessorsAffinityMask = 0x0000000000000fff;
			basic_info.NumberOfProcessors = 1;
		});

		return STATUS_SUCCESS;
	}

	NTSTATUS handle_NtQueryInformationProcess(const syscall_context& c, const uint64_t process_handle,
	                                          const uint32_t info_class, const uint64_t process_information,
	                                          const uint32_t process_information_length,
	                                          const emulator_object<uint32_t> return_length)
	{
		if (process_handle != ~0ULL)
		{
			return STATUS_NOT_SUPPORTED;
		}

		if (info_class == ProcessImageInformation)
		{
			if (return_length)
			{
				return_length.write(sizeof(SECTION_IMAGE_INFORMATION));
			}

			if (process_information_length != sizeof(SECTION_IMAGE_INFORMATION))
			{
				return STATUS_BUFFER_OVERFLOW;
			}

			const emulator_object<SECTION_IMAGE_INFORMATION> info{c.emu, process_information};
			info.access([&](SECTION_IMAGE_INFORMATION& i)
			{
				const auto& mod = *c.proc.executable;

				const emulator_object<IMAGE_DOS_HEADER> dos_header_obj{c.emu, mod.image_base};
				const auto dos_header = dos_header_obj.read();

				const emulator_object<IMAGE_NT_HEADERS> nt_headers_obj{c.emu, mod.image_base + dos_header.e_lfanew};
				const auto nt_headers = nt_headers_obj.read();

				const auto& file_header = nt_headers.FileHeader;
				const auto& optional_header = nt_headers.OptionalHeader;

				i.TransferAddress = nullptr;
				i.MaximumStackSize = optional_header.SizeOfStackReserve;
				i.CommittedStackSize = optional_header.SizeOfStackCommit;
				i.SubSystemType = optional_header.Subsystem;
				i.SubSystemMajorVersion = optional_header.MajorSubsystemVersion;
				i.SubSystemMinorVersion = optional_header.MinorSubsystemVersion;
				i.MajorOperatingSystemVersion = optional_header.MajorOperatingSystemVersion;
				i.MinorOperatingSystemVersion = optional_header.MinorOperatingSystemVersion;
				i.ImageCharacteristics = file_header.Characteristics;
				i.DllCharacteristics = optional_header.DllCharacteristics;
				i.Machine = file_header.Machine;
				i.ImageContainsCode = TRUE;
				i.ImageFlags = 0; // TODO
				i.ImageFileSize = optional_header.SizeOfImage;
				i.LoaderFlags = optional_header.LoaderFlags;
				i.CheckSum = optional_header.CheckSum;
			});

			return STATUS_SUCCESS;
		}

		if (info_class == ProcessCookie)
		{
			if (return_length)
			{
				return_length.write(sizeof(uint32_t));
			}

			if (process_information_length != sizeof(uint32_t))
			{
				return STATUS_BUFFER_OVERFLOW;
			}

			const emulator_object<uint32_t> info{c.emu, process_information};
			info.write(0x01234567);

			return STATUS_SUCCESS;
		}

		if (info_class == ProcessDebugPort)
		{
			if (return_length)
			{
				return_length.write(sizeof(DWORD_PTR));
			}

			if (process_information_length != sizeof(DWORD_PTR))
			{
				return STATUS_BUFFER_OVERFLOW;
			}

			const emulator_object<DWORD_PTR> info{c.emu, process_information};
			info.write(0);

			return STATUS_SUCCESS;
		}

		if (info_class == ProcessDefaultHardErrorMode)
		{
			if (return_length)
			{
				return_length.write(sizeof(ULONG));
			}

			if (process_information_length != sizeof(ULONG))
			{
				return STATUS_BUFFER_OVERFLOW;
			}

			const emulator_object<ULONG> info{c.emu, process_information};
			info.write(0);

			return STATUS_SUCCESS;
		}

		if (info_class == ProcessEnclaveInformation
			|| info_class == ProcessMitigationPolicy)
		{
			return STATUS_NOT_SUPPORTED;
		}

		if (info_class == ProcessBasicInformation)
		{
			if (return_length)
			{
				return_length.write(sizeof(PROCESS_BASIC_INFORMATION));
			}

			if (process_information_length != sizeof(PROCESS_BASIC_INFORMATION))
			{
				return STATUS_BUFFER_OVERFLOW;
			}

			const emulator_object<PROCESS_BASIC_INFORMATION> info{c.emu, process_information};
			info.access([&](PROCESS_BASIC_INFORMATION& basic_info)
			{
				basic_info.PebBaseAddress = c.proc.peb.ptr();
				basic_info.UniqueProcessId = reinterpret_cast<HANDLE>(1);
			});

			return STATUS_SUCCESS;
		}

		if (info_class == ProcessImageFileNameWin32)
		{
			const auto peb = c.proc.peb.read();
			emulator_object<RTL_USER_PROCESS_PARAMETERS> proc_params{c.emu, peb.ProcessParameters};
			const auto params = proc_params.read();
			const auto length = params.ImagePathName.Length + sizeof(UNICODE_STRING) + 2;

			if (return_length)
			{
				return_length.write(static_cast<uint32_t>(length));
			}

			if (process_information_length < length)
			{
				return STATUS_BUFFER_OVERFLOW;
			}

			const emulator_object<UNICODE_STRING> info{c.emu, process_information};
			info.access([&](UNICODE_STRING& str)
			{
				const auto buffer_start = static_cast<uint64_t>(process_information) + sizeof(UNICODE_STRING);
				const auto string = read_unicode_string(c.emu, params.ImagePathName);
				c.emu.write_memory(buffer_start, string.c_str(), (string.size() + 1) * 2);
				str.Length = params.ImagePathName.Length;
				str.MaximumLength = str.Length;
				str.Buffer = reinterpret_cast<wchar_t*>(buffer_start);
			});

			return STATUS_SUCCESS;
		}

		printf("Unsupported process info class: %X\n", info_class);
		c.emu.stop();

		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtQueryInformationThread(const syscall_context& c, const uint64_t thread_handle,
	                                         const uint32_t info_class, const uint64_t thread_information,
	                                         const uint32_t thread_information_length,
	                                         const emulator_object<uint32_t> return_length)
	{
		if (thread_handle != ~1ULL)
		{
			return STATUS_NOT_SUPPORTED;
		}

		if (info_class == ThreadBasicInformation)
		{
			if (return_length)
			{
				return_length.write(sizeof(THREAD_BASIC_INFORMATION));
			}

			if (thread_information_length != sizeof(THREAD_BASIC_INFORMATION))
			{
				return STATUS_BUFFER_OVERFLOW;
			}

			const emulator_object<THREAD_BASIC_INFORMATION> info{c.emu, thread_information};
			info.access([&](THREAD_BASIC_INFORMATION& i)
			{
				i.TebBaseAddress = c.win_emu.current_thread().teb->ptr();
				i.ClientId = c.win_emu.current_thread().teb->read().ClientId;
			});

			return STATUS_SUCCESS;
		}

		if (info_class == ThreadAmILastThread)
		{
			if (return_length)
			{
				return_length.write(sizeof(ULONG));
			}

			if (thread_information_length != sizeof(ULONG))
			{
				return STATUS_BUFFER_OVERFLOW;
			}

			const emulator_object<ULONG> info{c.emu, thread_information};
			info.write(c.proc.threads.size() <= 1);

			return STATUS_SUCCESS;
		}

		printf("Unsupported thread info class: %X\n", info_class);
		c.emu.stop();

		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtQueryInformationFile(const syscall_context& c, uint64_t /*file_handle*/,
	                                       const emulator_object<ULONG_PTR> io_status_block,
	                                       const uint64_t file_information,
	                                       const uint32_t length,
	                                       const uint32_t info_class)
	{
		if (info_class == FileStandardInformation)
		{
			if (io_status_block)
			{
				io_status_block.write(sizeof(FILE_STANDARD_INFORMATION));
			}

			if (length != sizeof(FILE_STANDARD_INFORMATION))
			{
				return STATUS_BUFFER_OVERFLOW;
			}

			const emulator_object<FILE_STANDARD_INFORMATION> info{c.emu, file_information};
			info.access([&](FILE_STANDARD_INFORMATION& i)
			{
				memset(&i, 0, sizeof(i));
			});

			return STATUS_SUCCESS;
		}

		printf("Unsupported file info class: %X\n", info_class);
		c.emu.stop();

		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtSetInformationProcess(const syscall_context& c, const uint64_t process_handle,
	                                        const uint32_t info_class, const uint64_t /*process_information*/,
	                                        const uint32_t /*process_information_length*/)
	{
		if (process_handle != ~0ULL)
		{
			return STATUS_NOT_SUPPORTED;
		}

		if (info_class == ProcessSchedulerSharedData
			|| info_class == ProcessTlsInformation
			|| info_class == ProcessConsoleHostProcess
			|| info_class == ProcessFaultInformation
			|| info_class == ProcessDefaultHardErrorMode
			|| info_class == ProcessRaiseUMExceptionOnInvalidHandleClose)
		{
			return STATUS_SUCCESS;
		}

		printf("Unsupported info process class: %X\n", info_class);
		c.emu.stop();

		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtApphelpCacheControl()
	{
		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtProtectVirtualMemory(const syscall_context& c, const uint64_t process_handle,
	                                       const emulator_object<uint64_t> base_address,
	                                       const emulator_object<uint32_t> bytes_to_protect,
	                                       const uint32_t protection,
	                                       const emulator_object<uint32_t> old_protection)
	{
		if (process_handle != ~0ULL)
		{
			return STATUS_NOT_SUPPORTED;
		}

		const auto orig_start = base_address.read();
		const auto orig_length = bytes_to_protect.read();

		const auto aligned_start = page_align_down(orig_start);
		const auto aligned_length = page_align_up(orig_start + orig_length) - aligned_start;

		base_address.write(aligned_start);
		bytes_to_protect.write(static_cast<uint32_t>(aligned_length));

		const auto requested_protection = map_nt_to_emulator_protection(protection);

		c.win_emu.logger.print(color::dark_gray, "--> Changing protection at 0x%llX-0x%llX to %s\n", aligned_start,
		                       aligned_start + aligned_length, get_permission_string(requested_protection).c_str());

		memory_permission old_protection_value{};

		try
		{
			c.emu.protect_memory(aligned_start, aligned_length, requested_protection, &old_protection_value);
		}
		catch (...)
		{
			return STATUS_INVALID_ADDRESS;
		}

		const auto current_protection = map_emulator_to_nt_protection(old_protection_value);
		old_protection.write(current_protection);

		return STATUS_SUCCESS;
	}

	NTSTATUS handle_NtOpenDirectoryObject(const syscall_context& c,
	                                      const emulator_object<uint64_t> directory_handle,
	                                      const ACCESS_MASK /*desired_access*/,
	                                      const emulator_object<OBJECT_ATTRIBUTES> object_attributes)
	{
		const auto attributes = object_attributes.read();
		const auto object_name = read_unicode_string(c.emu, attributes.ObjectName);

		if (object_name == L"\\KnownDlls")
		{
			directory_handle.write(KNOWN_DLLS_DIRECTORY.bits);
			return STATUS_SUCCESS;
		}

		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtOpenSymbolicLinkObject(const syscall_context& c, const emulator_object<uint64_t> link_handle,
	                                         ACCESS_MASK /*desired_access*/,
	                                         const emulator_object<OBJECT_ATTRIBUTES> object_attributes)
	{
		const auto attributes = object_attributes.read();
		const auto object_name = read_unicode_string(c.emu, attributes.ObjectName);

		if (object_name == L"KnownDllPath")
		{
			link_handle.write(KNOWN_DLLS_SYMLINK.bits);
			return STATUS_SUCCESS;
		}

		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS WINAPI handle_NtQuerySymbolicLinkObject(const syscall_context& c, const uint64_t link_handle,
	                                                 const emulator_object<UNICODE_STRING> link_target,
	                                                 const emulator_object<ULONG> returned_length)
	{
		if (link_handle == KNOWN_DLLS_SYMLINK)
		{
			constexpr std::wstring_view system32 = L"C:\\WINDOWS\\System32";
			constexpr auto str_length = system32.size() * 2;
			constexpr auto max_length = str_length + 2;

			returned_length.write(max_length);

			bool too_small = false;
			link_target.access([&](UNICODE_STRING& str)
			{
				if (str.MaximumLength < max_length)
				{
					too_small = true;
					return;
				}

				str.Length = str_length;
				c.emu.write_memory(reinterpret_cast<uint64_t>(str.Buffer), system32.data(), max_length);
			});

			return too_small
				       ? STATUS_BUFFER_TOO_SMALL
				       : STATUS_SUCCESS;
		}

		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtAllocateVirtualMemoryEx(const syscall_context& c, const uint64_t process_handle,
	                                          const emulator_object<uint64_t> base_address,
	                                          const emulator_object<uint64_t> bytes_to_allocate,
	                                          const uint32_t allocation_type,
	                                          const uint32_t page_protection)
	{
		if (process_handle != ~0ULL)
		{
			return STATUS_NOT_SUPPORTED;
		}

		const auto allocation_bytes = bytes_to_allocate.read();

		const auto protection = map_nt_to_emulator_protection(page_protection);

		auto potential_base = base_address.read();
		if (!potential_base)
		{
			potential_base = c.emu.find_free_allocation_base(allocation_bytes);
		}

		if (!potential_base)
		{
			return STATUS_MEMORY_NOT_ALLOCATED;
		}

		base_address.write(potential_base);

		const bool reserve = allocation_type & MEM_RESERVE;
		const bool commit = allocation_type & MEM_COMMIT;

		if ((allocation_type & ~(MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN)) || (!commit && !reserve))
		{
			throw std::runtime_error("Unsupported allocation type!");
		}

		if (commit && !reserve)
		{
			return c.emu.commit_memory(potential_base, allocation_bytes, protection)
				       ? STATUS_SUCCESS
				       : STATUS_MEMORY_NOT_ALLOCATED;
		}

		return c.emu.allocate_memory(potential_base, allocation_bytes, protection, !commit)
			       ? STATUS_SUCCESS
			       : STATUS_MEMORY_NOT_ALLOCATED;
	}

	NTSTATUS handle_NtAllocateVirtualMemory(const syscall_context& c, const uint64_t process_handle,
	                                        const emulator_object<uint64_t> base_address,
	                                        uint64_t /*zero_bits*/,
	                                        const emulator_object<uint64_t> bytes_to_allocate,
	                                        const uint32_t allocation_type, const uint32_t page_protection)
	{
		return handle_NtAllocateVirtualMemoryEx(c, process_handle, base_address, bytes_to_allocate, allocation_type,
		                                        page_protection);
	}

	NTSTATUS handle_NtFreeVirtualMemory(const syscall_context& c, const uint64_t process_handle,
	                                    const emulator_object<uint64_t> base_address,
	                                    const emulator_object<uint64_t> bytes_to_allocate, uint32_t free_type)
	{
		if (process_handle != ~0ULL)
		{
			return STATUS_NOT_SUPPORTED;
		}

		const auto allocation_base = base_address.read();
		const auto allocation_size = bytes_to_allocate.read();

		if (free_type & MEM_RELEASE)
		{
			return c.emu.release_memory(allocation_base, allocation_size)
				       ? STATUS_SUCCESS
				       : STATUS_MEMORY_NOT_ALLOCATED;
		}

		if (free_type & MEM_DECOMMIT)
		{
			return c.emu.decommit_memory(allocation_base, allocation_size)
				       ? STATUS_SUCCESS
				       : STATUS_MEMORY_NOT_ALLOCATED;
		}

		throw std::runtime_error("Bad free type");
	}

	NTSTATUS handle_NtCreateSection(const syscall_context& c, const emulator_object<uint64_t> section_handle,
	                                const ACCESS_MASK /*desired_access*/,
	                                const emulator_object<OBJECT_ATTRIBUTES> /*object_attributes*/,
	                                const emulator_object<ULARGE_INTEGER> maximum_size,
	                                const ULONG /*section_page_protection*/, const ULONG /*allocation_attributes*/,
	                                const uint64_t /*file_handle*/)
	{
		//puts("NtCreateSection not supported");
		section_handle.write(SHARED_SECTION.bits);

		maximum_size.access([&c](ULARGE_INTEGER& large_int)
		{
			large_int.QuadPart = page_align_up(large_int.QuadPart);
			c.proc.shared_section_size = large_int.QuadPart;
		});

		return STATUS_SUCCESS;
	}

	NTSTATUS handle_NtConnectPort(const syscall_context& c, const emulator_object<uint64_t> client_port_handle,
	                              const emulator_object<UNICODE_STRING> server_port_name,
	                              const emulator_object<SECURITY_QUALITY_OF_SERVICE> /*security_qos*/,
	                              const emulator_object<PORT_VIEW> client_shared_memory,
	                              const emulator_object<REMOTE_PORT_VIEW> /*server_shared_memory*/,
	                              const emulator_object<ULONG> /*maximum_message_length*/,
	                              uint64_t connection_info,
	                              const emulator_object<ULONG> connection_info_length)
	{
		auto port_name = read_unicode_string(c.emu, server_port_name);
		c.win_emu.logger.print(color::dark_gray, "NtConnectPort: %S\n", port_name.c_str());

		port p{};
		p.name = std::move(port_name);

		if (connection_info)
		{
			std::vector<uint8_t> zero_mem{};
			zero_mem.resize(connection_info_length.read(), 0);
			c.emu.write_memory(connection_info, zero_mem.data(), zero_mem.size());
		}

		client_shared_memory.access([&](PORT_VIEW& view)
		{
			p.view_base = c.emu.allocate_memory(view.ViewSize, memory_permission::read_write);
			view.ViewBase = reinterpret_cast<void*>(p.view_base);
			view.ViewRemoteBase = view.ViewBase;
		});

		const auto handle = c.proc.ports.store(std::move(p));
		client_port_handle.write(handle.bits);

		return STATUS_SUCCESS;
	}

	NTSTATUS handle_NtReadVirtualMemory(const syscall_context& c, uint64_t process_handle, uint64_t base_address,
	                                    uint64_t buffer, ULONG number_of_bytes_to_read,
	                                    const emulator_object<ULONG> number_of_bytes_read)
	{
		number_of_bytes_read.write(0);

		if (process_handle != ~0ULL)
		{
			return STATUS_NOT_SUPPORTED;
		}

		std::vector<uint8_t> memory{};
		memory.resize(number_of_bytes_read);

		if (!c.emu.try_read_memory(base_address, memory.data(), memory.size()))
		{
			return STATUS_INVALID_ADDRESS;
		}

		c.emu.write_memory(buffer, memory.data(), memory.size());
		number_of_bytes_read.write(number_of_bytes_to_read);
		return STATUS_SUCCESS;
	}

	NTSTATUS handle_NtDeviceIoControlFile()
	{
		//puts("NtDeviceIoControlFile not supported");
		return STATUS_SUCCESS;
	}

	NTSTATUS handle_NtQueryWnfStateData()
	{
		//puts("NtQueryWnfStateData not supported");
		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtQueryWnfStateNameInformation()
	{
		//puts("NtQueryWnfStateNameInformation not supported");
		//return STATUS_NOT_SUPPORTED;
		return STATUS_SUCCESS;
	}

	NTSTATUS handle_NtOpenProcessToken()
	{
		//puts("NtOpenProcessToken not supported");
		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtQuerySecurityAttributesToken()
	{
		//puts("NtQuerySecurityAttributesToken not supported");
		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtQueryLicenseValue()
	{
		//puts("NtQueryLicenseValue not supported");
		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtTestAlert()
	{
		//puts("NtTestAlert not supported");
		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtQueryInformationToken()
	{
		//puts("NtQueryInformationToken not supported");
		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtDxgkIsFeatureEnabled()
	{
		//puts("NtDxgkIsFeatureEnabled not supported");
		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtQueryInstallUILanguage()
	{
		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtUserDisplayConfigGetDeviceInfo()
	{
		//puts("NtUserDisplayConfigGetDeviceInfo not supported");
		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtGdiInit2(const syscall_context& c)
	{
		c.proc.peb.access([&](PEB& peb)
		{
			if (!peb.GdiSharedHandleTable)
			{
				peb.GdiSharedHandleTable = c.proc.base_allocator.reserve<GDI_SHARED_MEMORY>().ptr();
			}
		});

		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtGetMUIRegistryInfo()
	{
		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtUserGetThreadState()
	{
		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtIsUILanguageComitted()
	{
		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtUpdateWnfStateData()
	{
		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtAlpcSendWaitReceivePort(const syscall_context& c, const uint64_t port_handle,
	                                          const ULONG /*flags*/,
	                                          const emulator_object<PORT_MESSAGE> /*send_message*/,
	                                          const emulator_object<ALPC_MESSAGE_ATTRIBUTES>
	                                          /*send_message_attributes*/
	                                          ,
	                                          const emulator_object<PORT_MESSAGE> receive_message,
	                                          const emulator_object<SIZE_T> /*buffer_length*/,
	                                          const emulator_object<ALPC_MESSAGE_ATTRIBUTES>
	                                          /*receive_message_attributes*/,
	                                          const emulator_object<LARGE_INTEGER> /*timeout*/)
	{
		const auto* port = c.proc.ports.get(port_handle);
		if (!port)
		{
			return STATUS_INVALID_HANDLE;
		}

		if (port->name != L"\\Windows\\ApiPort")
		{
			puts("!!! BAD PORT");
			return STATUS_NOT_SUPPORTED;
		}

		const emulator_object<PORT_DATA_ENTRY> data{c.emu, receive_message.value() + 0x48};
		const auto dest = data.read();
		const auto base = reinterpret_cast<uint64_t>(dest.Base);

		const auto value = base + 0x10;
		c.emu.write_memory(base + 8, &value, sizeof(value));

		return STATUS_SUCCESS;
	}

	NTSTATUS handle_NtInitializeNlsFiles(const syscall_context& c, const emulator_object<uint64_t> base_address,
	                                     const emulator_object<LCID> default_locale_id,
	                                     const emulator_object<LARGE_INTEGER> /*default_casing_table_size*/)
	{
		const auto locale_file = utils::io::read_file(R"(C:\Windows\System32\locale.nls)");
		if (locale_file.empty())
		{
			return STATUS_FILE_INVALID;
		}

		const auto size = page_align_up(locale_file.size());
		const auto base = c.emu.allocate_memory(size, memory_permission::read);
		c.emu.write_memory(base, locale_file.data(), locale_file.size());

		base_address.write(base);
		default_locale_id.write(0x407);

		return STATUS_SUCCESS;
	}

	NTSTATUS handle_NtContinue(const syscall_context& c, const emulator_object<CONTEXT> thread_context,
	                           const BOOLEAN /*raise_alert*/)
	{
		c.write_status = false;

		const auto context = thread_context.read();
		context_frame::restore(c.emu, context);

		return STATUS_SUCCESS;
	}

	NTSTATUS handle_NtTerminateProcess(const syscall_context& c, const uint64_t process_handle,
	                                   NTSTATUS /*exit_status*/)
	{
		if (process_handle == 0)
		{
			return STATUS_SUCCESS;
		}

		if (process_handle == ~0ULL)
		{
			c.emu.stop();
			return STATUS_SUCCESS;
		}

		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtWriteFile(const syscall_context& c, const uint64_t file_handle, const uint64_t /*event*/,
	                            const uint64_t /*apc_routine*/,
	                            const uint64_t /*apc_context*/,
	                            const emulator_object<IO_STATUS_BLOCK> /*io_status_block*/,
	                            uint64_t buffer, const ULONG length,
	                            const emulator_object<LARGE_INTEGER> /*byte_offset*/,
	                            const emulator_object<ULONG> /*key*/)
	{
		if (file_handle == STDOUT_HANDLE)
		{
			std::string temp_buffer{};
			temp_buffer.resize(length);
			c.emu.read_memory(buffer, temp_buffer.data(), temp_buffer.size());

			c.win_emu.logger.info("%.*s", static_cast<int>(temp_buffer.size()), temp_buffer.data());

			return STATUS_SUCCESS;
		}

		//puts("NtWriteFile not supported");
		c.emu.stop();
		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtCreateFile(const syscall_context& c, const emulator_object<uint64_t> file_handle,
	                             ACCESS_MASK desired_access,
	                             const emulator_object<OBJECT_ATTRIBUTES> object_attributes,
	                             const emulator_object<IO_STATUS_BLOCK> io_status_block,
	                             const emulator_object<LARGE_INTEGER> /*allocation_size*/, ULONG file_attributes,
	                             ULONG share_access, ULONG create_disposition, ULONG create_options,
	                             uint64_t /*ea_buffer*/,
	                             ULONG /*ea_length*/)
	{
		const auto attributes = object_attributes.read();
		auto filename = read_unicode_string(c.emu, attributes.ObjectName);

		if (filename == L"\\Device\\ConDrv\\Server")
		{
			file_handle.write(CONSOLE_SERVER.bits);
			return STATUS_SUCCESS;
		}

		if (filename == L"\\Device\\DeviceApi\\CMApi")
		{
			file_handle.write(CM_API.bits);
			return STATUS_SUCCESS;
		}

		handle root_handle{};
		root_handle.bits = reinterpret_cast<uint64_t>(attributes.RootDirectory);
		if (root_handle.value.is_pseudo && (filename == L"\\Reference" || filename == L"\\Connect"))
		{
			file_handle.write(root_handle.bits);
			return STATUS_SUCCESS;
		}

		file f{};
		f.name = std::move(filename);

		UNICODE_STRING string{};
		string.Buffer = f.name.data();
		string.Length = static_cast<uint16_t>(f.name.size() * 2);
		string.MaximumLength = string.Length;

		OBJECT_ATTRIBUTES new_attributes{};
		new_attributes.ObjectName = &string;
		new_attributes.Length = sizeof(new_attributes);

		HANDLE h{};

		NTSTATUS res{STATUS_SUCCESS};
		io_status_block.access([&](IO_STATUS_BLOCK& block)
		{
			res = NtCreateFile(&h, desired_access, &new_attributes, &block, nullptr, file_attributes, share_access,
			                   create_disposition, create_options, nullptr, 0);
		});

		if (res != STATUS_SUCCESS)
		{
			return res;
		}

		f.handle = h;

		const auto handle = c.proc.files.store(std::move(f));
		file_handle.write(handle.bits);

		return res;


		//printf("Unsupported file: %S\n", filename.c_str());
		//return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtQueryInformationJobObject()
	{
		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtSetSystemInformation()
	{
		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtRaiseHardError(const syscall_context& c, const NTSTATUS error_status,
	                                 const ULONG /*number_of_parameters*/,
	                                 const emulator_object<UNICODE_STRING> /*unicode_string_parameter_mask*/,
	                                 const emulator_object<DWORD> /*parameters*/,
	                                 const HARDERROR_RESPONSE_OPTION /*valid_response_option*/,
	                                 const emulator_object<HARDERROR_RESPONSE> response)
	{
		if (response)
		{
			response.write(ResponseAbort);
		}

		printf("Hard error: %X\n", static_cast<uint32_t>(error_status));
		c.proc.exception_rip = c.emu.read_instruction_pointer();
		c.emu.stop();

		return STATUS_SUCCESS;
	}

	NTSTATUS handle_NtRaiseException(const syscall_context& c,
	                                 const emulator_object<EXCEPTION_RECORD> /*exception_record*/,
	                                 const emulator_object<CONTEXT> thread_context, BOOLEAN handle_exception)
	{
		if (handle_exception)
		{
			puts("Unhandled exceptions not supported yet!");
			c.emu.stop();
			return STATUS_NOT_SUPPORTED;
		}

		c.proc.exception_rip = thread_context.read().Rip;
		c.emu.stop();

		return STATUS_SUCCESS;
	}

	NTSTATUS handle_NtCreateSemaphore(const syscall_context& c, const emulator_object<uint64_t> semaphore_handle,
	                                  const ACCESS_MASK /*desired_access*/,
	                                  const emulator_object<OBJECT_ATTRIBUTES> object_attributes,
	                                  const ULONG initial_count, const ULONG maximum_count)
	{
		semaphore s{};
		s.current_count = initial_count;
		s.max_count = maximum_count;

		if (object_attributes)
		{
			const auto attributes = object_attributes.read();
			if (attributes.ObjectName)
			{
				s.name = read_unicode_string(c.emu, attributes.ObjectName);
			}
		}

		const auto handle = c.proc.semaphores.store(std::move(s));
		semaphore_handle.write(handle.bits);

		return STATUS_SUCCESS;
	}

	NTSTATUS handle_NtAddAtomEx(const syscall_context& c, const uint64_t atom_name, const ULONG length,
	                            const emulator_object<RTL_ATOM> atom, const ULONG /*flags*/)
	{
		std::wstring name{};
		name.resize(length / 2);

		c.emu.read_memory(atom_name, name.data(), length);

		uint16_t index = 0;
		if (!c.proc.atoms.empty())
		{
			auto i = c.proc.atoms.end();
			--i;
			index = i->first + 1;
		}

		std::optional<uint16_t> last_entry{};
		for (auto& entry : c.proc.atoms)
		{
			if (entry.second == name)
			{
				if (atom)
				{
					atom.write(entry.first);
					return STATUS_SUCCESS;
				}
			}

			if (entry.first > 0)
			{
				if (!last_entry)
				{
					index = 0;
				}
				else
				{
					const auto diff = entry.first - *last_entry;
					if (diff > 1)
					{
						index = *last_entry + 1;
					}
				}
			}

			last_entry = entry.first;
		}

		c.proc.atoms[index] = std::move(name);
		atom.write(index);
		return STATUS_SUCCESS;
	}

	NTSTATUS handle_NtUnmapViewOfSection(const syscall_context& c, const uint64_t process_handle,
	                                     const uint64_t base_address)
	{
		if (process_handle != ~0ULL)
		{
			return STATUS_NOT_SUPPORTED;
		}

		const auto* mod = c.proc.module_manager.find_by_address(base_address);
		if (!mod)
		{
			puts("Unmapping non-module section not supported!");
		}
		else
		{
			printf("Unmapping section %s not supported!\n", mod->name.c_str());
		}

		c.emu.stop();
		return STATUS_NOT_SUPPORTED;
	}

	NTSTATUS handle_NtCreateThreadEx(const syscall_context& c, const emulator_object<uint64_t> thread_handle,
	                                 const ACCESS_MASK /*desired_access*/,
	                                 const emulator_object<OBJECT_ATTRIBUTES> /*object_attributes*/,
	                                 const uint64_t process_handle, const uint64_t start_routine,
	                                 const uint64_t argument, const ULONG /*create_flags*/, const SIZE_T /*zero_bits*/,
	                                 const SIZE_T stack_size, const SIZE_T /*maximum_stack_size*/,
	                                 const emulator_object<PS_ATTRIBUTE_LIST> attribute_list)
	{
		if (process_handle != ~0ULL)
		{
			return STATUS_NOT_SUPPORTED;
		}

		const auto h = c.proc.create_thread(c.emu, start_routine, argument, stack_size);
		thread_handle.write(h.bits);

		if (!attribute_list)
		{
			return STATUS_SUCCESS;
		}

		const auto* thread = c.proc.threads.get(h);

		const emulator_object<PS_ATTRIBUTE> attributes{
			c.emu, attribute_list.value() + offsetof(PS_ATTRIBUTE_LIST, Attributes)
		};

		const auto total_length = attribute_list.read().TotalLength;

		constexpr auto entry_size = sizeof(PS_ATTRIBUTE);
		constexpr auto header_size = sizeof(PS_ATTRIBUTE_LIST) - entry_size;
		const auto attribute_count = (total_length - header_size) / entry_size;

		for (size_t i = 0; i < attribute_count; ++i)
		{
			attributes.access([&](const PS_ATTRIBUTE& attribute)
			{
				const auto type = attribute.Attribute & ~PS_ATTRIBUTE_THREAD;

				if (type == PsAttributeClientId)
				{
					const auto client_id = thread->teb->read().ClientId;
					write_attribute(c.emu, attribute, client_id);
				}
				else if (type == PsAttributeTebAddress)
				{
					write_attribute(c.emu, attribute, thread->teb->ptr());
				}
				else
				{
					printf("Unsupported thread attribute type: %llX\n", type);
				}
			}, i);
		}

		return STATUS_SUCCESS;
	}

	NTSTATUS handle_NtQueryDebugFilterState()
	{
		return FALSE;
	}

	NTSTATUS handle_NtWaitForSingleObject(const syscall_context& c, const uint64_t handle_value,
	                                      const BOOLEAN alertable,
	                                      const emulator_object<LARGE_INTEGER> timeout)
	{
		if (timeout.value())
		{
			puts("NtWaitForSingleObject timeout not supported yet!");
			return STATUS_NOT_SUPPORTED;
		}

		if (alertable)
		{
			puts("Alertable NtWaitForSingleObject not supported yet!");
			return STATUS_NOT_SUPPORTED;
		}

		handle h{};
		h.bits = handle_value;

		if (h.value.type != handle_types::thread)
		{
			puts("NtWaitForSingleObject only supported with thread handles yet!");
			return STATUS_NOT_SUPPORTED;
		}

		if (is_object_signaled(c.proc, h))
		{
			return STATUS_WAIT_0;
		}

		c.write_status = false;
		c.retrigger_syscall = true;

		c.win_emu.current_thread().await_object = h;
		c.win_emu.switch_thread = true;
		c.emu.stop();

		return STATUS_SUCCESS;
	}

	NTSTATUS handle_NtTerminateThread(const syscall_context& c, uint64_t thread_handle,
	                                  const NTSTATUS exit_status)
	{
		auto* thread = !thread_handle
			               ? c.proc.active_thread
			               : c.proc.threads.get(thread_handle);

		if (!thread)
		{
			return STATUS_INVALID_HANDLE;
		}

		thread->exit_status = exit_status;
		if (thread == c.proc.active_thread)
		{
			c.win_emu.switch_thread = true;
			c.emu.stop();
		}

		return STATUS_SUCCESS;
	}
}

void syscall_dispatcher::setup(const exported_symbols& ntdll_exports, const exported_symbols& win32u_exports)
{
	this->handlers_ = {};

	const auto ntdll_syscalls = find_syscalls(ntdll_exports);
	const auto win32u_syscalls = find_syscalls(win32u_exports);

	map_syscalls(this->handlers_, ntdll_syscalls, 0);
	map_syscalls(this->handlers_, win32u_syscalls, 0x1000);

	this->add_handlers();
}

syscall_dispatcher::syscall_dispatcher(const exported_symbols& ntdll_exports,
                                       const exported_symbols& win32u_exports)
{
	this->setup(ntdll_exports, win32u_exports);
}

void syscall_dispatcher::add_handlers()
{
	std::unordered_map<std::string, syscall_handler> handler_mapping{};
	handler_mapping.reserve(this->handlers_.size());

#define add_handler(syscall)                                                  \
	do                                                                        \
	{                                                                         \
		handler_mapping[#syscall] = make_syscall_handler<handle_##syscall>(); \
	} while(0)

	add_handler(NtSetInformationThread) ;
	add_handler(NtSetEvent);
	add_handler(NtClose);
	add_handler(NtOpenKey);
	add_handler(NtAllocateVirtualMemory);
	add_handler(NtQueryInformationProcess);
	add_handler(NtSetInformationProcess);
	add_handler(NtFreeVirtualMemory);
	add_handler(NtQueryVirtualMemory);
	add_handler(NtOpenThreadToken);
	add_handler(NtQueryPerformanceCounter);
	add_handler(NtQuerySystemInformation);
	add_handler(NtCreateEvent);
	add_handler(NtProtectVirtualMemory);
	add_handler(NtOpenDirectoryObject);
	add_handler(NtTraceEvent);
	add_handler(NtAllocateVirtualMemoryEx);
	add_handler(NtCreateIoCompletion);
	add_handler(NtCreateWaitCompletionPacket);
	add_handler(NtCreateWorkerFactory);
	add_handler(NtManageHotPatch);
	add_handler(NtOpenSection);
	add_handler(NtMapViewOfSection);
	add_handler(NtOpenSymbolicLinkObject);
	add_handler(NtQuerySymbolicLinkObject);
	add_handler(NtQuerySystemInformationEx);
	add_handler(NtOpenFile);
	add_handler(NtQueryVolumeInformationFile);
	add_handler(NtApphelpCacheControl);
	add_handler(NtCreateSection);
	add_handler(NtConnectPort);
	add_handler(NtCreateFile);
	add_handler(NtDeviceIoControlFile);
	add_handler(NtQueryWnfStateData);
	add_handler(NtOpenProcessToken);
	add_handler(NtQuerySecurityAttributesToken);
	add_handler(NtQueryLicenseValue);
	add_handler(NtTestAlert);
	add_handler(NtContinue);
	add_handler(NtTerminateProcess);
	add_handler(NtWriteFile);
	add_handler(NtRaiseHardError);
	add_handler(NtCreateSemaphore);
	add_handler(NtReadVirtualMemory);
	add_handler(NtQueryInformationToken);
	add_handler(NtDxgkIsFeatureEnabled);
	add_handler(NtAddAtomEx);
	add_handler(NtInitializeNlsFiles);
	add_handler(NtUnmapViewOfSection);
	add_handler(NtDuplicateObject);
	add_handler(NtQueryInformationThread);
	add_handler(NtQueryWnfStateNameInformation);
	add_handler(NtAlpcSendWaitReceivePort);
	add_handler(NtGdiInit2);
	add_handler(NtUserGetThreadState);
	add_handler(NtOpenKeyEx);
	add_handler(NtUserDisplayConfigGetDeviceInfo);
	add_handler(NtOpenEvent);
	add_handler(NtGetMUIRegistryInfo);
	add_handler(NtIsUILanguageComitted);
	add_handler(NtQueryInstallUILanguage);
	add_handler(NtUpdateWnfStateData);
	add_handler(NtRaiseException);
	add_handler(NtQueryInformationJobObject);
	add_handler(NtSetSystemInformation);
	add_handler(NtQueryInformationFile);
	add_handler(NtCreateThreadEx);
	add_handler(NtQueryDebugFilterState);
	add_handler(NtWaitForSingleObject);
	add_handler(NtTerminateThread);

#undef add_handler

	for (auto& entry : this->handlers_)
	{
		const auto handler = handler_mapping.find(entry.second.name);
		if (handler == handler_mapping.end())
		{
			continue;
		}

		entry.second.handler = handler->second;

#ifndef NDEBUG
		handler_mapping.erase(handler);
#endif
	}

#ifndef NDEBUG
	if (!handler_mapping.empty())
	{
		puts("Unmapped handlers:");
		for (const auto& h : handler_mapping)
		{
			printf("  %s\n", h.first.c_str());
		}
	}
#endif
}

static void serialize(utils::buffer_serializer& buffer, const syscall_handler_entry& obj)
{
	buffer.write(obj.name);
}

static void deserialize(utils::buffer_deserializer& buffer, syscall_handler_entry& obj)
{
	buffer.read(obj.name);
	obj.handler = nullptr;
}

void syscall_dispatcher::serialize(utils::buffer_serializer& buffer) const
{
	buffer.write_map(this->handlers_);
}

void syscall_dispatcher::deserialize(utils::buffer_deserializer& buffer)
{
	buffer.read_map(this->handlers_);
	this->add_handlers();
}

void syscall_dispatcher::dispatch(windows_emulator& win_emu)
{
	auto& emu = win_emu.emu();
	auto& context = win_emu.process();

	const auto address = emu.read_instruction_pointer();
	const auto syscall_id = emu.reg<uint32_t>(x64_register::eax);


	const syscall_context c{win_emu, emu, context, true};

	try
	{
		const auto entry = this->handlers_.find(syscall_id);
		if (entry == this->handlers_.end())
		{
			printf("Unknown syscall: 0x%X\n", syscall_id);
			c.emu.reg<uint64_t>(x64_register::rax, STATUS_NOT_SUPPORTED);
			c.emu.stop();
			return;
		}

		if (!entry->second.handler)
		{
			printf("Unimplemented syscall: %s - 0x%X\n", entry->second.name.c_str(), syscall_id);
			c.emu.reg<uint64_t>(x64_register::rax, STATUS_NOT_SUPPORTED);
			c.emu.stop();
			return;
		}

		const auto* mod = context.module_manager.find_by_address(address);
		if (mod != context.ntdll && mod != context.win32u)
		{
			win_emu.logger.print(color::blue, "Executing inline syscall: %s (0x%X) at 0x%llX (%s)\n",
			                     entry->second.name.c_str(),
			                     syscall_id,
			                     address, mod ? mod->name.c_str() : "<N/A>");
		}
		else
		{
			win_emu.logger.print(color::dark_gray, "Executing syscall: %s (0x%X) at 0x%llX\n",
			                     entry->second.name.c_str(),
			                     syscall_id,
			                     address);
		}

		entry->second.handler(c);
	}
	catch (std::exception& e)
	{
		printf("Syscall threw an exception: %X (0x%llX) - %s\n", syscall_id, address, e.what());
		emu.reg<uint64_t>(x64_register::rax, STATUS_UNSUCCESSFUL);
		emu.stop();
	}
	catch (...)
	{
		printf("Syscall threw an unknown exception: %X (0x%llX)\n", syscall_id, address);
		emu.reg<uint64_t>(x64_register::rax, STATUS_UNSUCCESSFUL);
		emu.stop();
	}
}

```

`src/windows-emulator/syscalls.hpp`:

```hpp
#pragma once

#include "process_context.hpp"

struct syscall_context;
using syscall_handler = void(*)(const syscall_context& c);

struct syscall_handler_entry
{
	syscall_handler handler{};
	std::string name{};
};

class windows_emulator;

class syscall_dispatcher
{
public:
	syscall_dispatcher() = default;
	syscall_dispatcher(const exported_symbols& ntdll_exports, const exported_symbols& win32u_exports);

	void dispatch(windows_emulator& win_emu);

	void serialize(utils::buffer_serializer& buffer) const;
	void deserialize(utils::buffer_deserializer& buffer);

	void setup(const exported_symbols& ntdll_exports, const exported_symbols& win32u_exports);

	std::string get_syscall_name(const uint64_t id)
	{
		return this->handlers_.at(id).name;
	}

private:
	std::unordered_map<uint64_t, syscall_handler_entry> handlers_{};

	void add_handlers();
};

```

`src/windows-emulator/windows_emulator.cpp`:

```cpp
#include "std_include.hpp"
#include "windows_emulator.hpp"
#include "context_frame.hpp"

#include <unicorn_x64_emulator.hpp>

constexpr auto MAX_INSTRUCTIONS_PER_TIME_SLICE = 100;

namespace
{
	template <typename T>
	emulator_object<T> allocate_object_on_stack(x64_emulator& emu)
	{
		const auto old_sp = emu.reg(x64_register::rsp);
		const auto new_sp = align_down(old_sp - sizeof(CONTEXT),
		                               std::max(alignof(CONTEXT), alignof(x64_emulator::pointer_type)));
		emu.reg(x64_register::rsp, new_sp);

		return {emu, new_sp};
	}

	void unalign_stack(x64_emulator& emu)
	{
		auto sp = emu.reg(x64_register::rsp);
		sp = align_down(sp - 0x10, 0x10) + 8;
		emu.reg(x64_register::rsp, sp);
	}

	void setup_stack(x64_emulator& emu, const uint64_t stack_base, const size_t stack_size)
	{
		const uint64_t stack_end = stack_base + stack_size;
		emu.reg(x64_register::rsp, stack_end);
	}

	void setup_gs_segment(x64_emulator& emu, const emulator_allocator& allocator)
	{
		struct msr_value
		{
			uint32_t id;
			uint64_t value;
		};

		const msr_value value{
			IA32_GS_BASE_MSR,
			allocator.get_base()
		};

		emu.write_register(x64_register::msr, &value, sizeof(value));
	}

	emulator_object<KUSER_SHARED_DATA> setup_kusd(x64_emulator& emu)
	{
		emu.allocate_memory(KUSD_ADDRESS, page_align_up(sizeof(KUSER_SHARED_DATA)), memory_permission::read);

		const emulator_object<KUSER_SHARED_DATA> kusd_object{emu, KUSD_ADDRESS};
		kusd_object.access([](KUSER_SHARED_DATA& kusd)
		{
			const auto& real_kusd = *reinterpret_cast<KUSER_SHARED_DATA*>(KUSD_ADDRESS);

			memcpy(&kusd, &real_kusd, sizeof(kusd));

			kusd.ImageNumberLow = IMAGE_FILE_MACHINE_I386;
			kusd.ImageNumberHigh = IMAGE_FILE_MACHINE_AMD64;

			memset(&kusd.ProcessorFeatures, 0, sizeof(kusd.ProcessorFeatures));

			// ...
		});

		return kusd_object;
	}

	uint64_t copy_string(x64_emulator& emu, emulator_allocator& allocator, const void* base_ptr, const uint64_t offset,
	                     const size_t length)
	{
		if (!length)
		{
			return 0;
		}

		const auto length_to_allocate = length + 2;
		const auto str_obj = allocator.reserve(length_to_allocate);
		emu.write_memory(str_obj, static_cast<const uint8_t*>(base_ptr) + offset, length);

		return str_obj;
	}

	ULONG copy_string_as_relative(x64_emulator& emu, emulator_allocator& allocator, const uint64_t result_base,
	                              const void* base_ptr, const uint64_t offset,
	                              const size_t length)
	{
		const auto address = copy_string(emu, allocator, base_ptr, offset, length);
		if (!address)
		{
			return 0;
		}

		assert(address > result_base);
		return static_cast<ULONG>(address - result_base);
	}

	emulator_object<API_SET_NAMESPACE> clone_api_set_map(x64_emulator& emu, emulator_allocator& allocator,
	                                                     const API_SET_NAMESPACE& orig_api_set_map)
	{
		const auto api_set_map_obj = allocator.reserve<API_SET_NAMESPACE>();
		const auto ns_entries_obj = allocator.reserve<API_SET_NAMESPACE_ENTRY>(orig_api_set_map.Count);
		const auto hash_entries_obj = allocator.reserve<API_SET_HASH_ENTRY>(orig_api_set_map.Count);

		api_set_map_obj.access([&](API_SET_NAMESPACE& api_set)
		{
			api_set = orig_api_set_map;
			api_set.EntryOffset = static_cast<ULONG>(ns_entries_obj.value() - api_set_map_obj.value());
			api_set.HashOffset = static_cast<ULONG>(hash_entries_obj.value() - api_set_map_obj.value());
		});

		const auto orig_ns_entries = offset_pointer<API_SET_NAMESPACE_ENTRY>(&orig_api_set_map,
		                                                                     orig_api_set_map.EntryOffset);
		const auto orig_hash_entries = offset_pointer<API_SET_HASH_ENTRY>(&orig_api_set_map,
		                                                                  orig_api_set_map.HashOffset);

		for (ULONG i = 0; i < orig_api_set_map.Count; ++i)
		{
			auto ns_entry = orig_ns_entries[i];
			const auto hash_entry = orig_hash_entries[i];

			ns_entry.NameOffset = copy_string_as_relative(emu, allocator, api_set_map_obj.value(), &orig_api_set_map,
			                                              ns_entry.NameOffset, ns_entry.NameLength);

			if (!ns_entry.ValueCount)
			{
				continue;
			}

			const auto values_obj = allocator.reserve<API_SET_VALUE_ENTRY>(ns_entry.ValueCount);
			const auto orig_values = offset_pointer<API_SET_VALUE_ENTRY>(&orig_api_set_map,
			                                                             ns_entry.ValueOffset);

			ns_entry.ValueOffset = static_cast<ULONG>(values_obj.value() - api_set_map_obj.value());

			for (ULONG j = 0; j < ns_entry.ValueCount; ++j)
			{
				auto value = orig_values[j];

				value.ValueOffset = copy_string_as_relative(emu, allocator, api_set_map_obj.value(), &orig_api_set_map,
				                                            value.ValueOffset, value.ValueLength);

				if (value.NameLength)
				{
					value.NameOffset = copy_string_as_relative(emu, allocator, api_set_map_obj.value(),
					                                           &orig_api_set_map,
					                                           value.NameOffset, value.NameLength);
				}

				values_obj.write(value, j);
			}

			ns_entries_obj.write(ns_entry, i);
			hash_entries_obj.write(hash_entry, i);
		}

		return api_set_map_obj;
	}

	emulator_object<API_SET_NAMESPACE> build_api_set_map(x64_emulator& emu, emulator_allocator& allocator)
	{
		const auto& orig_api_set_map = *NtCurrentTeb()->ProcessEnvironmentBlock->ApiSetMap;
		return clone_api_set_map(emu, allocator, orig_api_set_map);
	}

	emulator_allocator create_allocator(emulator& emu, const size_t size)
	{
		const auto base = emu.find_free_allocation_base(size);
		emu.allocate_memory(base, size, memory_permission::read_write);

		return emulator_allocator{emu, base, size};
	}

	void setup_gdt(x64_emulator& emu)
	{
		constexpr uint64_t gdtr[4] = {0, GDT_ADDR, GDT_LIMIT, 0};
		emu.write_register(x64_register::gdtr, &gdtr, sizeof(gdtr));
		emu.allocate_memory(GDT_ADDR, GDT_LIMIT, memory_permission::read);

		emu.write_memory<uint64_t>(GDT_ADDR + 6 * (sizeof(uint64_t)), 0xEFFE000000FFFF);
		emu.reg<uint16_t>(x64_register::cs, 0x33);

		emu.write_memory<uint64_t>(GDT_ADDR + 5 * (sizeof(uint64_t)), 0xEFF6000000FFFF);
		emu.reg<uint16_t>(x64_register::ss, 0x2B);
	}

	void setup_context(process_context& context, x64_emulator& emu, const std::filesystem::path& file,
	                   const std::vector<std::wstring>& arguments)
	{
		setup_gdt(emu);

		context.kusd = setup_kusd(emu);

		context.base_allocator = create_allocator(emu, PEB_SEGMENT_SIZE);
		auto& allocator = context.base_allocator;

		context.peb = allocator.reserve<PEB>();

		/* Values of the following fields must be
		 * allocated relative to the process_params themselves
		 * and included in the length:
		 *
		 * CurrentDirectory
		 * DllPath
		 * ImagePathName
		 * CommandLine
		 * WindowTitle
		 * DesktopInfo
		 * ShellInfo
		 * RuntimeData
		 * RedirectionDllName
		 */

		context.process_params = allocator.reserve<RTL_USER_PROCESS_PARAMETERS>();

		context.process_params.access([&](RTL_USER_PROCESS_PARAMETERS& proc_params)
		{
			proc_params.Flags = 0x6001; //| 0x80000000; // Prevent CsrClientConnectToServer

			proc_params.ConsoleHandle = CONSOLE_HANDLE.h;
			proc_params.StandardOutput = STDOUT_HANDLE.h;
			proc_params.StandardInput = STDIN_HANDLE.h;
			proc_params.StandardError = proc_params.StandardOutput;


			std::wstring command_line = L"\"" + file.wstring() + L"\"";

			for (const auto& arg : arguments)
			{
				command_line.push_back(L' ');
				command_line.append(arg);
			}

			allocator.make_unicode_string(proc_params.CommandLine, command_line);
			//gs.make_unicode_string(proc_params.CurrentDirectory.DosPath, file.parent_path().wstring());
			allocator.make_unicode_string(proc_params.ImagePathName, file.wstring());

			const auto total_length = allocator.get_next_address() - context.process_params.value();

			proc_params.Length = static_cast<uint32_t>(std::max(sizeof(proc_params), total_length));
			proc_params.MaximumLength = proc_params.Length;
		});

		context.peb.access([&](PEB& peb)
		{
			peb.ImageBaseAddress = nullptr;
			peb.ProcessParameters = context.process_params.ptr();
			peb.ApiSetMap = build_api_set_map(emu, allocator).ptr();

			peb.ProcessHeap = nullptr;
			peb.ProcessHeaps = nullptr;
			peb.HeapSegmentReserve = 0x0000000000100000; // TODO: Read from executable
			peb.HeapSegmentCommit = 0x0000000000002000;
			peb.HeapDeCommitTotalFreeThreshold = 0x0000000000010000;
			peb.HeapDeCommitFreeBlockThreshold = 0x0000000000001000;
			peb.NumberOfHeaps = 0x00000000;
			peb.MaximumNumberOfHeaps = 0x00000010;
		});
	}

	using exception_record_map = std::unordered_map<const EXCEPTION_RECORD*, emulator_object<EXCEPTION_RECORD>>;

	emulator_object<EXCEPTION_RECORD> save_exception_record(emulator_allocator& allocator,
	                                                        const EXCEPTION_RECORD& record,
	                                                        exception_record_map& record_mapping)
	{
		const auto record_obj = allocator.reserve<EXCEPTION_RECORD>();
		record_obj.write(record);

		if (record.ExceptionRecord)
		{
			record_mapping[&record] = record_obj;

			emulator_object<EXCEPTION_RECORD> nested_record_obj{};
			const auto nested_record = record_mapping.find(record.ExceptionRecord);

			if (nested_record != record_mapping.end())
			{
				nested_record_obj = nested_record->second;
			}
			else
			{
				nested_record_obj = save_exception_record(allocator, *record.ExceptionRecord,
				                                          record_mapping);
			}

			record_obj.access([&](EXCEPTION_RECORD& r)
			{
				r.ExceptionRecord = nested_record_obj.ptr();
			});
		}

		return record_obj;
	}

	emulator_object<EXCEPTION_RECORD> save_exception_record(emulator_allocator& allocator,
	                                                        const EXCEPTION_RECORD& record)
	{
		exception_record_map record_mapping{};
		return save_exception_record(allocator, record, record_mapping);
	}

	uint32_t map_violation_operation_to_parameter(const memory_operation operation)
	{
		switch (operation)
		{
		default:
		case memory_operation::read:
			return 0;
		case memory_operation::write:
		case memory_operation::exec:
			return 1;
		}
	}

	size_t calculate_exception_record_size(const EXCEPTION_RECORD& record)
	{
		std::unordered_set<const EXCEPTION_RECORD*> records{};
		size_t total_size = 0;

		const EXCEPTION_RECORD* current_record = &record;
		while (current_record)
		{
			if (!records.insert(current_record).second)
			{
				break;
			}

			total_size += sizeof(*current_record);
			current_record = record.ExceptionRecord;
		}

		return total_size;
	}

	struct machine_frame
	{
		uint64_t rip;
		uint64_t cs;
		uint64_t eflags;
		uint64_t rsp;
		uint64_t ss;
	};

	void dispatch_exception_pointers(x64_emulator& emu, const uint64_t dispatcher, const EXCEPTION_POINTERS pointers)
	{
		constexpr auto mach_frame_size = 0x40;
		constexpr auto context_record_size = 0x4F0;
		const auto exception_record_size = calculate_exception_record_size(*pointers.ExceptionRecord);
		const auto combined_size = align_up(exception_record_size + context_record_size, 0x10);

		assert(combined_size == 0x590);

		const auto allocation_size = combined_size + mach_frame_size;

		const auto initial_sp = emu.reg(x64_register::rsp);
		const auto new_sp = align_down(initial_sp - allocation_size, 0x100);

		const auto total_size = initial_sp - new_sp;
		assert(total_size >= allocation_size);

		std::vector<uint8_t> zero_memory{};
		zero_memory.resize(total_size, 0);

		emu.write_memory(new_sp, zero_memory.data(), zero_memory.size());

		emu.reg(x64_register::rsp, new_sp);
		emu.reg(x64_register::rip, dispatcher);

		const emulator_object<CONTEXT> context_record_obj{emu, new_sp};
		context_record_obj.write(*pointers.ContextRecord);

		emulator_allocator allocator{emu, new_sp + context_record_size, exception_record_size};
		const auto exception_record_obj = save_exception_record(allocator, *pointers.ExceptionRecord);

		if (exception_record_obj.value() != allocator.get_base())
		{
			throw std::runtime_error("Bad exception record position on stack");
		}

		const emulator_object<machine_frame> machine_frame_obj{emu, new_sp + combined_size};
		machine_frame_obj.access([&](machine_frame& frame)
		{
			frame.rip = pointers.ContextRecord->Rip;
			frame.rsp = pointers.ContextRecord->Rsp;
			frame.ss = pointers.ContextRecord->SegSs;
			frame.cs = pointers.ContextRecord->SegCs;
			frame.eflags = pointers.ContextRecord->EFlags;
		});
	}

	void dispatch_access_violation(x64_emulator& emu, const uint64_t dispatcher, const uint64_t address,
	                               const memory_operation operation)
	{
		CONTEXT ctx{};
		ctx.ContextFlags = CONTEXT_ALL;
		context_frame::save(emu, ctx);

		EXCEPTION_RECORD record{};
		memset(&record, 0, sizeof(record));
		record.ExceptionCode = static_cast<DWORD>(STATUS_ACCESS_VIOLATION);
		record.ExceptionFlags = 0;
		record.ExceptionRecord = nullptr;
		record.ExceptionAddress = reinterpret_cast<void*>(emu.read_instruction_pointer());
		record.NumberParameters = 2;
		record.ExceptionInformation[0] = map_violation_operation_to_parameter(operation);
		record.ExceptionInformation[1] = address;

		EXCEPTION_POINTERS pointers{};
		pointers.ContextRecord = &ctx;
		pointers.ExceptionRecord = &record;

		dispatch_exception_pointers(emu, dispatcher, pointers);
	}

	void switch_to_thread(x64_emulator& emu, process_context& context, emulator_thread& thread)
	{
		auto* active_thread = context.active_thread;
		if (active_thread)
		{
			active_thread->save(emu);
		}

		context.active_thread = &thread;
		thread.restore(emu);
		thread.setup_if_necessary(emu, context);
	}

	void cleanup_threads(process_context& context)
	{
		while (true)
		{
			bool has_changed = false;
			for (auto i = context.threads.begin(); i != context.threads.end(); ++i)
			{
				if (i->second.exit_status.has_value())
				{
					if (&i->second == context.active_thread)
					{
						context.active_thread = nullptr;
					}

					context.threads.erase(i);
					has_changed = true;
					break;
				}
			}

			if (!has_changed)
			{
				break;
			}
		}
	}

	void switch_to_thread(x64_emulator& emu, process_context& context, const handle thread_handle)
	{
		auto* thread = context.threads.get(thread_handle);
		if (!thread)
		{
			throw std::runtime_error("Bad thread handle");
		}

		switch_to_thread(emu, context, *thread);
	}

	void switch_to_next_thread(x64_emulator& emu, process_context& context)
	{
		//cleanup_threads(context);

		bool next_thread = false;

		for (auto& thread : context.threads)
		{
			if (next_thread)
			{
				if (thread.second.exit_status.has_value())
				{
					continue;
				}

				switch_to_thread(emu, context, thread.second);
				return;
			}

			if (&thread.second == context.active_thread)
			{
				next_thread = true;
			}
		}

		switch_to_thread(emu, context, context.threads.begin()->second);
	}
}

emulator_thread::emulator_thread(x64_emulator& emu, const process_context& context,
                                 const uint64_t start_address,
                                 const uint64_t argument,
                                 const uint64_t stack_size, const uint32_t id)
	: emu_ptr(&emu)
	  , stack_size(page_align_up(std::max(stack_size, STACK_SIZE)))
	  , start_address(start_address)
	  , argument(argument)
	  , id(id)
	  , last_registers(context.default_register_set)
{
	this->stack_base = emu.allocate_memory(this->stack_size, memory_permission::read_write);

	this->gs_segment = emulator_allocator{
		emu,
		emu.allocate_memory(GS_SEGMENT_SIZE, memory_permission::read_write),
		GS_SEGMENT_SIZE,
	};

	this->teb = this->gs_segment->reserve<TEB>();

	this->teb->access([&](TEB& teb_obj)
	{
		teb_obj.ClientId.UniqueProcess = reinterpret_cast<HANDLE>(1);
		teb_obj.ClientId.UniqueThread = reinterpret_cast<HANDLE>(static_cast<uint64_t>(this->id));
		teb_obj.NtTib.StackLimit = reinterpret_cast<void*>(this->stack_base);
		teb_obj.NtTib.StackBase = reinterpret_cast<void*>(this->stack_base + this->stack_size);
		teb_obj.NtTib.Self = &this->teb->ptr()->NtTib;
		teb_obj.ProcessEnvironmentBlock = context.peb.ptr();
	});
}

void emulator_thread::setup_registers(x64_emulator& emu, const process_context& context) const
{
	setup_stack(emu, this->stack_base, this->stack_size);
	setup_gs_segment(emu, *this->gs_segment);

	CONTEXT ctx{};
	ctx.ContextFlags = CONTEXT_ALL;

	unalign_stack(emu);
	context_frame::save(emu, ctx);

	ctx.Rip = context.rtl_user_thread_start;
	ctx.Rcx = this->start_address;
	ctx.Rdx = this->argument;

	const auto ctx_obj = allocate_object_on_stack<CONTEXT>(emu);
	ctx_obj.write(ctx);

	unalign_stack(emu);

	emu.reg(x64_register::rcx, ctx_obj.value());
	emu.reg(x64_register::rdx, context.ntdll->image_base);
	emu.reg(x64_register::rip, context.ldr_initialize_thunk);
}

std::unique_ptr<x64_emulator> create_default_x64_emulator()
{
	return unicorn::create_x64_emulator();
}

windows_emulator::windows_emulator(const std::filesystem::path& application, const std::vector<std::wstring>& arguments,
                                   std::unique_ptr<x64_emulator> emu)
	: windows_emulator(std::move(emu))
{
	this->setup_process(application, arguments);
}

windows_emulator::windows_emulator(std::unique_ptr<x64_emulator> emu)
	: emu_(std::move(emu))
	  , process_(*emu_)
{
	this->setup_hooks();
}

void windows_emulator::setup_process(const std::filesystem::path& application,
                                     const std::vector<std::wstring>& arguments)
{
	auto& emu = this->emu();

	auto& context = this->process();
	context.module_manager = module_manager(emu); // TODO: Cleanup module manager

	setup_context(context, emu, application, arguments);

	context.executable = context.module_manager.map_module(application, this->logger);

	context.peb.access([&](PEB& peb)
	{
		peb.ImageBaseAddress = reinterpret_cast<void*>(context.executable->image_base);
	});

	context.ntdll = context.module_manager.map_module(R"(C:\Windows\System32\ntdll.dll)", this->logger);
	context.win32u = context.module_manager.map_module(R"(C:\Windows\System32\win32u.dll)", this->logger);

	this->dispatcher_.setup(context.ntdll->exports, context.win32u->exports);

	context.ldr_initialize_thunk = context.ntdll->find_export("LdrInitializeThunk");
	context.rtl_user_thread_start = context.ntdll->find_export("RtlUserThreadStart");
	context.ki_user_exception_dispatcher = context.ntdll->find_export("KiUserExceptionDispatcher");

	context.default_register_set = emu.save_registers();

	const auto main_thread_id = context.create_thread(emu, context.executable->entry_point, 0, 0);
	switch_to_thread(emu, context, main_thread_id);
}

void windows_emulator::perform_thread_switch()
{
	this->logger.print(color::green, "Performing thread switch...\n");
	switch_to_next_thread(this->emu(), this->process());
	this->switch_thread = false;
}

void windows_emulator::setup_hooks()
{
	this->emu().hook_instruction(x64_hookable_instructions::syscall, [&]
	{
		for (const auto& hook : this->syscall_hooks_)
		{
			if (hook() == instruction_hook_continuation::skip_instruction)
			{
				return instruction_hook_continuation::skip_instruction;
			}
		}

		this->dispatcher_.dispatch(*this);
		return instruction_hook_continuation::skip_instruction;
	});

	this->emu().hook_instruction(x64_hookable_instructions::invalid, [&]
	{
		const auto ip = this->emu().read_instruction_pointer();
		printf("Invalid instruction at: 0x%llX\n", ip);
		return instruction_hook_continuation::skip_instruction;
	});

	this->emu().hook_interrupt([&](const int interrupt)
	{
		const auto rip = this->emu().read_instruction_pointer();
		printf("Interrupt: %i 0x%llX\n", interrupt, rip);

		if (this->fuzzing)
		{
			this->process().exception_rip = rip;
			this->emu().stop();
		}
	});

	this->emu().hook_memory_violation([&](const uint64_t address, const size_t size, const memory_operation operation,
	                                      const memory_violation_type type)
	{
		const auto permission = get_permission_string(operation);
		const auto ip = this->emu().read_instruction_pointer();
		const char* name = this->process().module_manager.find_name(ip);

		if (type == memory_violation_type::protection)
		{
			printf("Protection violation: 0x%llX (%zX) - %s at 0x%llX (%s)\n", address, size, permission.c_str(), ip,
			       name);
		}
		else if (type == memory_violation_type::unmapped)
		{
			printf("Mapping violation: 0x%llX (%zX) - %s at 0x%llX (%s)\n", address, size, permission.c_str(), ip,
			       name);
		}

		if (this->fuzzing)
		{
			this->process().exception_rip = ip;
			this->emu().stop();
			return memory_violation_continuation::stop;
		}

		dispatch_access_violation(this->emu(), this->process().ki_user_exception_dispatcher, address, operation);
		return memory_violation_continuation::resume;
	});

	this->emu().hook_memory_execution(0, std::numeric_limits<size_t>::max(),
	                                  [&](const uint64_t address, const size_t, const uint64_t)
	                                  {
		                                  auto& process = this->process();

		                                  ++process.executed_instructions;

		                                  auto& thread = this->current_thread();
		                                  if (thread.executed_instructions == MAX_INSTRUCTIONS_PER_TIME_SLICE)
		                                  {
			                                  this->switch_thread = true;
			                                  this->emu().stop();
		                                  }

		                                  ++thread.executed_instructions;
		                                  thread.executed_instructions %= MAX_INSTRUCTIONS_PER_TIME_SLICE;

		                                  process.previous_ip = process.current_ip;
		                                  process.current_ip = this->emu().read_instruction_pointer();

		                                  const auto is_interesting_call = process.executable->is_within(
			                                  process.previous_ip) || process.executable->is_within(address);

		                                  /*if (address == 0x180038B65)
		                                  {
			                                  puts("!!! DLL init failed");
		                                  }
		                                  if (address == 0x180038A20)
		                                  {
			                                  const auto* name = this->process().module_manager.find_name(
				                                  this->emu().reg(x64_register::rcx));
			                                  printf("!!! DLL init: %s\n", name);
		                                  }*/

		                                  if (!this->verbose && !this->verbose_calls && !is_interesting_call)
		                                  {
			                                  return;
		                                  }

		                                  const auto* binary = this->process().module_manager.find_by_address(address);

		                                  if (binary)
		                                  {
			                                  const auto export_entry = binary->address_names.find(address);
			                                  if (export_entry != binary->address_names.end())
			                                  {
				                                  logger.print(is_interesting_call ? color::yellow : color::dark_gray,
				                                               "Executing function: %s - %s (0x%llX)\n",
				                                               binary->name.c_str(),
				                                               export_entry->second.c_str(), address);
			                                  }
			                                  else if (address == binary->entry_point)
			                                  {
				                                  logger.print(is_interesting_call ? color::yellow : color::gray,
				                                               "Executing entry point: %s (0x%llX)\n",
				                                               binary->name.c_str(),
				                                               address);
			                                  }
		                                  }

		                                  if (!this->verbose)
		                                  {
			                                  return;
		                                  }

		                                  auto& emu = this->emu();

		                                  printf(
			                                  "Inst: %16llX - RAX: %16llX - RBX: %16llX - RCX: %16llX - RDX: %16llX - R8: %16llX - R9: %16llX - RDI: %16llX - RSI: %16llX - %s\n",
			                                  address,
			                                  emu.reg(x64_register::rax), emu.reg(x64_register::rbx),
			                                  emu.reg(x64_register::rcx),
			                                  emu.reg(x64_register::rdx), emu.reg(x64_register::r8),
			                                  emu.reg(x64_register::r9),
			                                  emu.reg(x64_register::rdi), emu.reg(x64_register::rsi),
			                                  binary ? binary->name.c_str() : "<N/A>");
	                                  });
}

void windows_emulator::serialize(utils::buffer_serializer& buffer) const
{
	this->emu().serialize(buffer);
	this->process_.serialize(buffer);
	this->dispatcher_.serialize(buffer);
}

void windows_emulator::deserialize(utils::buffer_deserializer& buffer)
{
	this->emu().deserialize(buffer);
	this->process_.deserialize(buffer);
	this->dispatcher_.deserialize(buffer);
}

void windows_emulator::save_snapshot()
{
	this->emu().save_snapshot();

	utils::buffer_serializer serializer{};
	this->process_.serialize(serializer);

	this->process_snapshot_ = serializer.move_buffer();

	// TODO: Make process copyable
	//this->process_snapshot_ = this->process();
}

void windows_emulator::restore_snapshot()
{
	if (this->process_snapshot_.empty())
	{
		assert(false);
		return;
	}

	this->emu().restore_snapshot();

	utils::buffer_deserializer deserializer{this->process_snapshot_};
	this->process_.deserialize(deserializer);
	//this->process_ = *this->process_snapshot_;
}

```

`src/windows-emulator/windows_emulator.hpp`:

```hpp
#pragma once
#include <x64_emulator.hpp>

#include "syscalls.hpp"
#include "process_context.hpp"
#include "logger.hpp"

std::unique_ptr<x64_emulator> create_default_x64_emulator();

class windows_emulator
{
public:
	windows_emulator(std::unique_ptr<x64_emulator> emu = create_default_x64_emulator());
	windows_emulator(const std::filesystem::path& application, const std::vector<std::wstring>& arguments = {},
	                 std::unique_ptr<x64_emulator> emu = create_default_x64_emulator());

	windows_emulator(windows_emulator&&) = delete;
	windows_emulator(const windows_emulator&) = delete;
	windows_emulator& operator=(windows_emulator&&) = delete;
	windows_emulator& operator=(const windows_emulator&) = delete;

	~windows_emulator() = default;

	x64_emulator& emu()
	{
		return *this->emu_;
	}

	const x64_emulator& emu() const
	{
		return *this->emu_;
	}

	process_context& process()
	{
		return this->process_;
	}

	const process_context& process() const
	{
		return this->process_;
	}

	syscall_dispatcher& dispatcher()
	{
		return this->dispatcher_;
	}

	const syscall_dispatcher& dispatcher() const
	{
		return this->dispatcher_;
	}

	emulator_thread& current_thread() const
	{
		if (!this->process_.active_thread)
		{
			throw std::runtime_error("No active thread!");
		}

		return *this->process_.active_thread;
	}

	void serialize(utils::buffer_serializer& buffer) const;
	void deserialize(utils::buffer_deserializer& buffer);

	void save_snapshot();
	void restore_snapshot();

	void add_syscall_hook(instruction_hook_callback callback)
	{
		this->syscall_hooks_.push_back(std::move(callback));
	}

	logger logger{};
	bool verbose{false};
	bool verbose_calls{false};
	bool buffer_stdout{false};
	bool fuzzing{false};
	bool switch_thread{false};

	void perform_thread_switch();

private:
	std::unique_ptr<x64_emulator> emu_{};

	std::vector<instruction_hook_callback> syscall_hooks_{};

	process_context process_;
	syscall_dispatcher dispatcher_;

	std::vector<std::byte> process_snapshot_{};
	//std::optional<process_context> process_snapshot_{};

	void setup_hooks();
	void setup_process(const std::filesystem::path& application, const std::vector<std::wstring>& arguments);
};

```