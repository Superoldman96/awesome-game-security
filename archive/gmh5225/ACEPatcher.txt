Project Path: arc_gmh5225_ACEPatcher_lyrzldtq

Source Tree:

```txt
arc_gmh5225_ACEPatcher_lyrzldtq
├── ACEPatcher
│   ├── ACEFiles.Designer.cs
│   ├── ACEFiles.resx
│   ├── ACEPatcher.csproj
│   ├── App.config
│   ├── ConfigManager.cs
│   ├── Controls
│   │   └── DarkToolStripRenderer.cs
│   ├── DotNetUtils.cs
│   ├── Icons.Designer.cs
│   ├── Icons.resx
│   ├── MainFRM.Designer.cs
│   ├── MainFRM.cs
│   ├── MainFRM.resx
│   ├── ModuleLoader
│   │   └── DotNetModuleLoader.cs
│   ├── PatchDialog.Designer.cs
│   ├── PatchDialog.cs
│   ├── PatchDialog.resx
│   ├── Patcher.cs
│   ├── Program.cs
│   ├── Properties
│   │   ├── AssemblyInfo.cs
│   │   ├── Resources.Designer.cs
│   │   ├── Resources.resx
│   │   ├── Settings.Designer.cs
│   │   └── Settings.settings
│   ├── Resources
│   │   ├── 0Harmony.dll
│   │   ├── ACEx32.dll
│   │   ├── ACEx64.dll
│   │   ├── Assembly_16x.png
│   │   ├── ClassFriend_16x.png
│   │   ├── ClassPrivate_16x.png
│   │   ├── ClassProtected_16x.png
│   │   ├── Class_16x.png
│   │   ├── DllInjector.exe
│   │   ├── DllInjector64.exe
│   │   ├── ExtensionMethod_16x.png
│   │   ├── MethodFriend_16x.png
│   │   ├── MethodPrivate_16x.png
│   │   ├── MethodProtect_16x.png
│   │   ├── Method_16x.png
│   │   ├── Module_16x.png
│   │   ├── Namespace_16x.png
│   │   ├── Property_16x.png
│   │   ├── patch.ico
│   │   └── placeholder.txt
│   ├── TreeViewLoader.cs
│   ├── packages.config
│   └── patch.ico
├── ACEPatcher.sln
├── AceTest
│   ├── AceTest.csproj
│   ├── Class1.cs
│   └── Properties
│       └── AssemblyInfo.cs
└── README.md

```

`ACEPatcher.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31729.503
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ACEPatcher", "ACEPatcher\ACEPatcher.csproj", "{F7F4A377-F96F-4CB6-91F1-BCEE82A8DE63}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AceTest", "AceTest\AceTest.csproj", "{6699F677-F1B1-49EB-BB34-509714188027}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F7F4A377-F96F-4CB6-91F1-BCEE82A8DE63}.Debug|Any CPU.ActiveCfg = Debug|x64
		{F7F4A377-F96F-4CB6-91F1-BCEE82A8DE63}.Debug|Any CPU.Build.0 = Debug|x64
		{F7F4A377-F96F-4CB6-91F1-BCEE82A8DE63}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{F7F4A377-F96F-4CB6-91F1-BCEE82A8DE63}.Release|Any CPU.Build.0 = Release|Any CPU
		{6699F677-F1B1-49EB-BB34-509714188027}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{6699F677-F1B1-49EB-BB34-509714188027}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{6699F677-F1B1-49EB-BB34-509714188027}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{6699F677-F1B1-49EB-BB34-509714188027}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {0208B823-B731-4D3C-96B0-FCCE4E00F5B2}
	EndGlobalSection
EndGlobal

```

`ACEPatcher/ACEFiles.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace ACEPatcher {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class ACEFiles {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal ACEFiles() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("ACEPatcher.ACEFiles", typeof(ACEFiles).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        internal static byte[] _0Harmony {
            get {
                object obj = ResourceManager.GetObject("_0Harmony", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        internal static byte[] ACEx32 {
            get {
                object obj = ResourceManager.GetObject("ACEx32", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        internal static byte[] ACEx64 {
            get {
                object obj = ResourceManager.GetObject("ACEx64", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        internal static byte[] DllInjector {
            get {
                object obj = ResourceManager.GetObject("DllInjector", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        internal static byte[] DllInjector64 {
            get {
                object obj = ResourceManager.GetObject("DllInjector64", resourceCulture);
                return ((byte[])(obj));
            }
        }
    }
}

```

`ACEPatcher/ACEFiles.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="ACEx32" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>Resources\ACEx32.dll;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="ACEx64" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>Resources\ACEx64.dll;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="DllInjector" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>Resources\DllInjector.exe;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="DllInjector64" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>Resources\DllInjector64.exe;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="_0Harmony" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>Resources\0Harmony.dll;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
</root>
```

`ACEPatcher/ACEPatcher.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{F7F4A377-F96F-4CB6-91F1-BCEE82A8DE63}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <RootNamespace>ACEPatcher</RootNamespace>
    <AssemblyName>ACEPatcher</AssemblyName>
    <TargetFrameworkVersion>v4.8</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <Deterministic>true</Deterministic>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\x64\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\x64\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationIcon>patch.ico</ApplicationIcon>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="dnlib, Version=3.5.0.0, Culture=neutral, PublicKeyToken=50e96378b6e77999, processorArchitecture=MSIL">
      <HintPath>..\packages\dnlib.3.5.0\lib\net45\dnlib.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Numerics" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Deployment" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="ACEFiles.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>ACEFiles.resx</DependentUpon>
    </Compile>
    <Compile Include="ConfigManager.cs" />
    <Compile Include="Controls\DarkToolStripRenderer.cs" />
    <Compile Include="DotNetUtils.cs" />
    <Compile Include="MainFRM.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="MainFRM.Designer.cs">
      <DependentUpon>MainFRM.cs</DependentUpon>
    </Compile>
    <Compile Include="Icons.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Icons.resx</DependentUpon>
    </Compile>
    <Compile Include="ModuleLoader\DotNetModuleLoader.cs" />
    <Compile Include="PatchDialog.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="PatchDialog.Designer.cs">
      <DependentUpon>PatchDialog.cs</DependentUpon>
    </Compile>
    <Compile Include="Patcher.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="TreeViewLoader.cs" />
    <EmbeddedResource Include="ACEFiles.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>ACEFiles.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <EmbeddedResource Include="MainFRM.resx">
      <DependentUpon>MainFRM.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Icons.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Icons.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <EmbeddedResource Include="PatchDialog.resx">
      <DependentUpon>PatchDialog.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
      <SubType>Designer</SubType>
    </EmbeddedResource>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <None Include="packages.config" />
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Assembly_16x.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Class_16x.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\ClassFriend_16x.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\ClassPrivate_16x.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Method_16x.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\MethodFriend_16x.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\MethodPrivate_16x.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\MethodProtect_16x.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Module_16x.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Namespace_16x.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\ClassProtected_16x.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Property_16x.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\ExtensionMethod_16x.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\0Harmony.dll" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\ACEx32.dll" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\DllInjector.exe" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\ACEx64.dll" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\DllInjector64.exe" />
  </ItemGroup>
  <ItemGroup>
    <Content Include="patch.ico" />
    <None Include="Resources\patch.ico" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>

```

`ACEPatcher/App.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.8" />
    </startup>
  <runtime>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
      </dependentAssembly>
    </assemblyBinding>
  </runtime>
</configuration>
```

`ACEPatcher/ConfigManager.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using dnlib.DotNet;
using System.Windows.Forms;
using dnlib.PE;

namespace ACEPatcher
{
    class ConfigManager
    {

        public static void ExportConfig(ModuleDefMD mainAssembly,string path,bool Secure,string password = null)
        {
            foreach(KeyValuePair<IMethod,IMethod> patch in Patcher.patchList) 
            {
                if(((MethodDef)patch.Key).Module.Assembly.FullName == mainAssembly.Assembly.FullName) 
                {
                    MessageBox.Show("These patches are only applicable to the assembly in question and thus cannot be exported","Error",MessageBoxButtons.OK,MessageBoxIcon.Error);
                    return;
                }
            }
            byte[] content;
            using(MemoryStream stream = new MemoryStream()) 
            {
                using(BinaryWriter writer = new BinaryWriter(stream)) 
                {
                    writer.Write((ushort)Patcher.patchList.Count);
                    foreach(KeyValuePair<IMethod, IMethod> patch in Patcher.patchList) 
                    {
                        writer.Write(patch.Key.DeclaringType.DefinitionAssembly.FullName);
                        writer.Write('\0');
                        writer.Write(patch.Key.FullName);
                        writer.Write('\0');
                        writer.Write(patch.Value.DeclaringType.DefinitionAssembly.FullName);
                        writer.Write('\0');
                        writer.Write(patch.Value.FullName);
                        writer.Write('\0');
                    }
                    writer.Write(DotNetUtils.ReadAssembly(Patcher.patchAssembly));
                }
                content = Compress(stream.ToArray());
                if (Secure)
                {
                    content = Encrypt(content, password);
                }
            }
            File.WriteAllBytes(path,content.Prepend<byte>(Secure ? (byte)1 : (byte)0).ToArray());
        }


        public static void ImportConfig(ModuleDefMD[] dependancies,string path) 
        {
            byte[] config = File.ReadAllBytes(path);
            byte magic = config[0];
            config = config.Skip(1).ToArray();
            if(magic == 1) 
            {
                string password = null;
                if (MainFRM.InputBox("Password", "Type in password:", ref password) == DialogResult.OK)
                {
                    try 
                    {
                        config = Decrypt(config, password);
                    }
                    catch 
                    {
                        MessageBox.Show("Invalid password", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return;
                    }
                }
                else
                    return;
            }
            try 
            {
                config = Decompress(config);
            }
            catch 
            {
                MessageBox.Show("Invalid patch", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }
            using (MemoryStream stream = new MemoryStream(config))
            {
                using (BinaryReader reader = new BinaryReader(stream))
                {
                    ushort patchNo = reader.ReadUInt16();
                    KeyValuePair<string, string>[] pairs = new KeyValuePair<string, string>[patchNo*2];
                    for(int i = 0; i < patchNo * 2; i+=2) 
                    {
                        string _1 = reader.ReadString();
                        reader.ReadByte();
                        string _2 = reader.ReadString();
                        reader.ReadByte();
                        pairs[i] = new KeyValuePair<string, string>(_1, _2);
                        _1 = reader.ReadString();
                        reader.ReadByte();
                        _2 = reader.ReadString();
                        reader.ReadByte();
                        pairs[i+1] = new KeyValuePair<string, string>(_1, _2);
                    }
                    for(int i = 0;i<pairs.Length;i+=2)
                    {
                        if(dependancies.Where(x => x.Assembly.FullName == pairs[i].Key).Count() == 0) 
                        {
                            MessageBox.Show("Assembly " + pairs[i].Key + " is missing", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                            return;
                        }
                    }
                    byte[] PatchAssembly = new byte[stream.Length - stream.Position];
                    reader.Read(PatchAssembly, 0, (int)(stream.Length - stream.Position));
                    Patcher.patchAssembly = ModuleDefMD.Load(PatchAssembly);
                    for(int i = 0; i < pairs.Length; i += 2) 
                    {
                        Patcher.patchList.Add(DotNetUtils.findMethodByName(dependancies,pairs[i].Key,pairs[i].Value), DotNetUtils.findMethodByName(dependancies.Prepend(Patcher.patchAssembly).ToArray(), pairs[i+1].Key, pairs[i+1].Value));
                    }
                }
            }
            MessageBox.Show("Config succesfully imported", "Information", MessageBoxButtons.OK, MessageBoxIcon.Information);
        
        }

        
        static byte[] Compress(byte[] data)
        {
            byte[] compressArray = null;
            using (MemoryStream memoryStream = new MemoryStream())
            {
                using (GZipStream deflateStream = new GZipStream(memoryStream, CompressionMode.Compress))
                {
                    deflateStream.Write(data, 0, data.Length);
                }
                compressArray = memoryStream.ToArray();
            }
            return compressArray;
        }

        static byte[] Decompress(byte[] data)
        {
            using (GZipStream stream = new GZipStream(new MemoryStream(data), CompressionMode.Decompress))
            {
                byte[] buffer = new byte[4096];
                using (MemoryStream memory = new MemoryStream())
                {
                    int count = 0;
                    do
                    {
                        count = stream.Read(buffer, 0, 4096);
                        if (count > 0)
                        {
                            memory.Write(buffer, 0, count);
                        }
                    }
                    while (count > 0);
                    return memory.ToArray();
                }
            }
        }

        static byte[] Encrypt(byte[] data,string password) 
        {
            byte[] result;
            SHA256Managed sha256 = new SHA256Managed();
            byte[] hash = sha256.ComputeHash(Encoding.UTF8.GetBytes(password));
            AesManaged aes = new AesManaged();
            ICryptoTransform encryptor = aes.CreateEncryptor(hash.Take(16).ToArray(), hash.Skip(16).Take(16).ToArray());
            using (MemoryStream ms = new MemoryStream())
            {
                using (CryptoStream cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))
                {
                    using (BinaryWriter sw = new BinaryWriter(cs))
                        sw.Write(data);
                    result = ms.ToArray();
                }
            }
            return result;
        }

        static byte[] Decrypt(byte[] data, string password)
        {
            byte[] result;
            SHA256Managed sha256 = new SHA256Managed();
            byte[] hash = sha256.ComputeHash(Encoding.UTF8.GetBytes(password));
            AesManaged aes = new AesManaged();
            ICryptoTransform decryptor = aes.CreateDecryptor(hash.Take(16).ToArray(), hash.Skip(16).Take(16).ToArray());
            using (MemoryStream ms = new MemoryStream())
            {
                using (CryptoStream cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Write))
                {
                    using (BinaryWriter sw = new BinaryWriter(cs))
                        sw.Write(data);
                    result = ms.ToArray();
                }
            }
            return result;
        }

    }
}

```

`ACEPatcher/Controls/DarkToolStripRenderer.cs`:

```cs
using System;
using System.Drawing;
using System.Windows.Forms;

namespace ACEPatcher.Controls
{
    public class DarkMenuRenderer : ToolStripRenderer
    {
        #region Initialisation Region

        protected override void Initialize(ToolStrip toolStrip)
        {
            base.Initialize(toolStrip);

            toolStrip.BackColor = Color.FromArgb(27, 27, 28);
            toolStrip.ForeColor = Color.FromArgb(220, 220, 220);
        }

        protected override void InitializeItem(ToolStripItem item)
        {
            base.InitializeItem(item);

            item.BackColor = Color.FromArgb(27, 27, 28);
            item.ForeColor = Color.FromArgb(220, 220, 220);

            if (item.GetType() == typeof(ToolStripSeparator))
            {
                item.Margin = new Padding(0, 0, 0, 0);
            }
        }

        #endregion

        #region Render Region

        protected override void OnRenderToolStripBackground(ToolStripRenderEventArgs e)
        {
            var g = e.Graphics;
            using (var b = new SolidBrush(Color.FromArgb(27, 27, 28)))
            {
                g.FillRectangle(b, e.AffectedBounds);
            }
        }

        protected override void OnRenderImageMargin(ToolStripRenderEventArgs e)
        {
            var g = e.Graphics;

            var rect = new Rectangle(0, 0, e.ToolStrip.Width - 1, e.ToolStrip.Height - 1);

            using (var p = new Pen(Color.FromArgb(51, 51, 51)))
            {
                g.DrawRectangle(p, rect);
            }
        }

        protected override void OnRenderItemCheck(ToolStripItemImageRenderEventArgs e)
        {
            var g = e.Graphics;

            var rect = new Rectangle(e.ImageRectangle.Left - 2, e.ImageRectangle.Top + 2,
                                         e.ImageRectangle.Width + 4, e.ImageRectangle.Height + 4);

            using (var b = new SolidBrush(Color.FromArgb(62, 62, 64)))
            {
                g.FillRectangle(b, rect);
            }

            using (var p = new Pen(Color.FromArgb(0, 0, 56)))
            {
                var modRect = new Rectangle(rect.Left, rect.Top, rect.Width - 1, rect.Height - 1);
                g.DrawRectangle(p, modRect);
            }

        }

        protected override void OnRenderSeparator(ToolStripSeparatorRenderEventArgs e)
        {
            /*var g = e.Graphics;

            var rect = new Rectangle(1, 3, e.Item.Width, 1);

            using (var b = new SolidBrush(Color.FromArgb(81, 81, 81)))
            {
                g.FillRectangle(b, rect);
            }*/
        }

        protected override void OnRenderArrow(ToolStripArrowRenderEventArgs e)
        {
            e.ArrowColor = Color.FromArgb(220, 220, 220);
            e.ArrowRectangle = new Rectangle(new Point(e.ArrowRectangle.Left, e.ArrowRectangle.Top - 1), e.ArrowRectangle.Size);

            base.OnRenderArrow(e);
        }

        protected override void OnRenderMenuItemBackground(ToolStripItemRenderEventArgs e)
        {
            var g = e.Graphics;

            e.Item.ForeColor = e.Item.Enabled ? Color.FromArgb(220, 220, 220) : Color.FromArgb(153, 153, 153);

            if (e.Item.Enabled)
            {

                var bgColor = e.Item.Selected ? Color.FromArgb(62, 62, 64) : e.Item.BackColor;

                // Normal item
                var rect = new Rectangle(0, 0, e.Item.Width, e.Item.Height);

                using (var b = new SolidBrush(bgColor))
                {
                    g.FillRectangle(b, rect);
                }

                // Header item on open menu
                if (e.Item.GetType() == typeof(ToolStripMenuItem))
                {
                    if (((ToolStripMenuItem)e.Item).DropDown.Visible && e.Item.IsOnDropDown == false)
                    {
                        using (var b = new SolidBrush(Color.FromArgb(27, 27, 28)))
                        {
                            g.FillRectangle(b, rect);
                        }
                    }
                }
            }
        }

        #endregion
    }
}

```

`ACEPatcher/DotNetUtils.cs`:

```cs
using System;
using System.Linq;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.PE;

namespace ACEPatcher
{

	public static class DotNetUtils
	{

		public static IDictionary<T, int> CreateObjectToIndexDictionary<T>(IList<T> objs)
		{
			var dict = new Dictionary<T, int>();
			for (int i = 0; i < objs.Count; i++)
				dict[objs[i]] = i;
			return dict;
		}
		public static void CopyBody(MethodDef method, out IList<Instruction> instructions, out IList<ExceptionHandler> exceptionHandlers)
		{
			if (method == null || !method.HasBody)
			{
				instructions = new List<Instruction>();
				exceptionHandlers = new List<ExceptionHandler>();
				return;
			}

			var oldInstrs = method.Body.Instructions;
			var oldExHandlers = method.Body.ExceptionHandlers;
			instructions = new List<Instruction>(oldInstrs.Count);
			exceptionHandlers = new List<ExceptionHandler>(oldExHandlers.Count);
			var oldToIndex = CreateObjectToIndexDictionary(oldInstrs);

			foreach (var oldInstr in oldInstrs)
				instructions.Add(oldInstr.Clone());

			foreach (var newInstr in instructions)
			{
				var operand = newInstr.Operand;
				if (operand is Instruction)
					newInstr.Operand = instructions[oldToIndex[(Instruction)operand]];
				else if (operand is IList<Instruction> oldArray)
				{
					var newArray = new Instruction[oldArray.Count];
					for (int i = 0; i < oldArray.Count; i++)
						newArray[i] = instructions[oldToIndex[oldArray[i]]];
					newInstr.Operand = newArray;
				}
			}

			foreach (var oldEx in oldExHandlers)
			{
				var newEx = new ExceptionHandler(oldEx.HandlerType)
				{
					TryStart = GetInstruction(instructions, oldToIndex, oldEx.TryStart),
					TryEnd = GetInstruction(instructions, oldToIndex, oldEx.TryEnd),
					FilterStart = GetInstruction(instructions, oldToIndex, oldEx.FilterStart),
					HandlerStart = GetInstruction(instructions, oldToIndex, oldEx.HandlerStart),
					HandlerEnd = GetInstruction(instructions, oldToIndex, oldEx.HandlerEnd),
					CatchType = oldEx.CatchType,
				};
				exceptionHandlers.Add(newEx);
			}
		}

		static Instruction GetInstruction(IList<Instruction> instructions, IDictionary<Instruction, int> instructionToIndex, Instruction instruction)
		{
			if (instruction == null)
				return null;
			return instructions[instructionToIndex[instruction]];
		}

		public static void RestoreBody(MethodDef method, IEnumerable<Instruction> instructions, IEnumerable<ExceptionHandler> exceptionHandlers)
		{
			if (method == null || method.Body == null)
				return;

			var bodyInstrs = method.Body.Instructions;
			bodyInstrs.Clear();
			foreach (var instr in instructions)
				bodyInstrs.Add(instr);

			var bodyExceptionHandlers = method.Body.ExceptionHandlers;
			bodyExceptionHandlers.Clear();
			foreach (var eh in exceptionHandlers)
				bodyExceptionHandlers.Add(eh);
		}

		public static void CopyBodyFromTo(MethodDef fromMethod, MethodDef toMethod)
		{
			if (fromMethod == toMethod)
				return;

			CopyBody(fromMethod, out var instructions, out var exceptionHandlers);
			RestoreBody(toMethod, instructions, exceptionHandlers);
			CopyLocalsFromTo(fromMethod, toMethod);
			UpdateInstructionOperands(fromMethod, toMethod);
		}

		static void CopyLocalsFromTo(MethodDef fromMethod, MethodDef toMethod)
		{
			var fromBody = fromMethod.Body;
			var toBody = toMethod.Body;

			toBody.Variables.Clear();
			foreach (var local in fromBody.Variables)
				toBody.Variables.Add(new Local(local.Type));
		}

		static void UpdateInstructionOperands(MethodDef fromMethod, MethodDef toMethod)
		{
			var fromBody = fromMethod.Body;
			var toBody = toMethod.Body;

			toBody.InitLocals = fromBody.InitLocals;
			toBody.MaxStack = fromBody.MaxStack;

			var newOperands = new Dictionary<object, object>();
			var fromParams = fromMethod.Parameters;
			var toParams = toMethod.Parameters;
			for (int i = 0; i < fromParams.Count; i++)
				newOperands[fromParams[i]] = toParams[i];
			for (int i = 0; i < fromBody.Variables.Count; i++)
				newOperands[fromBody.Variables[i]] = toBody.Variables[i];

			foreach (var instr in toBody.Instructions)
			{
				if (instr.Operand == null)
					continue;
				if (newOperands.TryGetValue(instr.Operand, out object newOperand))
					instr.Operand = newOperand;
			}
		}

		public static int ReplaceInstruction(IList<Instruction> instructions, Instruction instruction,params Instruction[] replacement) 
		{
			int index = instructions.IndexOf(instruction);
			if (replacement.Length == 0)
				return 0;
			else if(replacement.Length == 1) 
			{
				instructions[index].OpCode = replacement[0].OpCode;
				instructions[index].Operand = replacement[0].Operand;
				return 1;
			}
            else 
			{
				instructions[index].OpCode = replacement[0].OpCode;
				instructions[index].Operand = replacement[0].Operand;
				((List<Instruction>)instructions).InsertRange(index+1, replacement.Skip(1).ToArray());
				return replacement.Length;
			}
		}

		public static MethodDef findMethodByName(ModuleDefMD[] dependancies,string moduleName,string methodName) 
		{
			ModuleDefMD module = dependancies.Where(x => x.Assembly.FullName == moduleName).First();
			foreach(TypeDef type in module.Types) 
			{
				foreach(MethodDef method in type.Methods) 
				{
					if (method.FullName == methodName)
						return method;
				}
			}
			throw new KeyNotFoundException();
		}

		public static byte[] ReadAssembly(ModuleDefMD module)
		{
			IPEImage image = module.Metadata.PEImage;
			var Reader = image.CreateReader();
			return Reader.ReadBytes((int)Reader.Length);
		}

	}
}
```

`ACEPatcher/Icons.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace ACEPatcher {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Icons {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Icons() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("ACEPatcher.Icons", typeof(Icons).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap Assembly_16x {
            get {
                object obj = ResourceManager.GetObject("Assembly_16x", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap Class_16x {
            get {
                object obj = ResourceManager.GetObject("Class_16x", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap ClassFriend_16x {
            get {
                object obj = ResourceManager.GetObject("ClassFriend_16x", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap ClassPrivate_16x {
            get {
                object obj = ResourceManager.GetObject("ClassPrivate_16x", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap ClassProtected_16x {
            get {
                object obj = ResourceManager.GetObject("ClassProtected_16x", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap ExtensionMethod_16x {
            get {
                object obj = ResourceManager.GetObject("ExtensionMethod_16x", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap Method_16x {
            get {
                object obj = ResourceManager.GetObject("Method_16x", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap MethodFriend_16x {
            get {
                object obj = ResourceManager.GetObject("MethodFriend_16x", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap MethodPrivate_16x {
            get {
                object obj = ResourceManager.GetObject("MethodPrivate_16x", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap MethodProtect_16x {
            get {
                object obj = ResourceManager.GetObject("MethodProtect_16x", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap Module_16x {
            get {
                object obj = ResourceManager.GetObject("Module_16x", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap Namespace_16x {
            get {
                object obj = ResourceManager.GetObject("Namespace_16x", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Icon similar to (Icon).
        /// </summary>
        internal static System.Drawing.Icon patch {
            get {
                object obj = ResourceManager.GetObject("patch", resourceCulture);
                return ((System.Drawing.Icon)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap Property_16x {
            get {
                object obj = ResourceManager.GetObject("Property_16x", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
    }
}

```

`ACEPatcher/Icons.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="Assembly_16x" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>Resources\Assembly_16x.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="ClassFriend_16x" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>Resources\ClassFriend_16x.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="ClassPrivate_16x" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>Resources\ClassPrivate_16x.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="ClassProtected_16x" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>Resources\ClassProtected_16x.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="Class_16x" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>Resources\Class_16x.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="ExtensionMethod_16x" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>Resources\ExtensionMethod_16x.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="MethodFriend_16x" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>Resources\MethodFriend_16x.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="MethodPrivate_16x" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>Resources\MethodPrivate_16x.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="MethodProtect_16x" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>Resources\MethodProtect_16x.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="Method_16x" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>Resources\Method_16x.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="Module_16x" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>Resources\Module_16x.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="Namespace_16x" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>Resources\Namespace_16x.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="patch" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>Resources\patch.ico;System.Drawing.Icon, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="Property_16x" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>Resources\Property_16x.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
</root>
```

`ACEPatcher/MainFRM.Designer.cs`:

```cs

namespace ACEPatcher
{
    partial class MainFRM
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.menuStrip1 = new System.Windows.Forms.MenuStrip();
            this.fileToolStripMenuItem1 = new System.Windows.Forms.ToolStripMenuItem();
            this.openToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.importToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.exportToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.secureExportToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.treeView1 = new System.Windows.Forms.TreeView();
            this.label1 = new System.Windows.Forms.Label();
            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();
            this.button1 = new System.Windows.Forms.Button();
            this.label2 = new System.Windows.Forms.Label();
            this.richTextBox1 = new System.Windows.Forms.RichTextBox();
            this.menuStrip1.SuspendLayout();
            this.tableLayoutPanel1.SuspendLayout();
            this.SuspendLayout();
            // 
            // menuStrip1
            // 
            this.menuStrip1.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(60)))), ((int)(((byte)(63)))), ((int)(((byte)(65)))));
            this.menuStrip1.ForeColor = System.Drawing.Color.FromArgb(((int)(((byte)(220)))), ((int)(((byte)(220)))), ((int)(((byte)(220)))));
            this.menuStrip1.GripMargin = new System.Windows.Forms.Padding(3);
            this.menuStrip1.ImageScalingSize = new System.Drawing.Size(20, 20);
            this.menuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.fileToolStripMenuItem1});
            this.menuStrip1.Location = new System.Drawing.Point(0, 0);
            this.menuStrip1.Name = "menuStrip1";
            this.menuStrip1.Padding = new System.Windows.Forms.Padding(2, 0, 0, 0);
            this.menuStrip1.Size = new System.Drawing.Size(844, 30);
            this.menuStrip1.TabIndex = 0;
            this.menuStrip1.Text = "menuStrip1";
            // 
            // fileToolStripMenuItem1
            // 
            this.fileToolStripMenuItem1.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(60)))), ((int)(((byte)(63)))), ((int)(((byte)(65)))));
            this.fileToolStripMenuItem1.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Text;
            this.fileToolStripMenuItem1.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.openToolStripMenuItem,
            this.importToolStripMenuItem,
            this.exportToolStripMenuItem,
            this.secureExportToolStripMenuItem});
            this.fileToolStripMenuItem1.ForeColor = System.Drawing.Color.FromArgb(((int)(((byte)(220)))), ((int)(((byte)(220)))), ((int)(((byte)(220)))));
            this.fileToolStripMenuItem1.Name = "fileToolStripMenuItem1";
            this.fileToolStripMenuItem1.Padding = new System.Windows.Forms.Padding(0);
            this.fileToolStripMenuItem1.Size = new System.Drawing.Size(38, 30);
            this.fileToolStripMenuItem1.Text = "File";
            // 
            // openToolStripMenuItem
            // 
            this.openToolStripMenuItem.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(27)))), ((int)(((byte)(27)))), ((int)(((byte)(28)))));
            this.openToolStripMenuItem.ForeColor = System.Drawing.Color.FromArgb(((int)(((byte)(220)))), ((int)(((byte)(220)))), ((int)(((byte)(220)))));
            this.openToolStripMenuItem.Name = "openToolStripMenuItem";
            this.openToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.O)));
            this.openToolStripMenuItem.Size = new System.Drawing.Size(287, 28);
            this.openToolStripMenuItem.Text = "Open";
            this.openToolStripMenuItem.Click += new System.EventHandler(this.openToolStripMenuItem_Click);
            // 
            // importToolStripMenuItem
            // 
            this.importToolStripMenuItem.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(27)))), ((int)(((byte)(27)))), ((int)(((byte)(28)))));
            this.importToolStripMenuItem.ForeColor = System.Drawing.Color.FromArgb(((int)(((byte)(220)))), ((int)(((byte)(220)))), ((int)(((byte)(220)))));
            this.importToolStripMenuItem.Name = "importToolStripMenuItem";
            this.importToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.I)));
            this.importToolStripMenuItem.Size = new System.Drawing.Size(287, 28);
            this.importToolStripMenuItem.Text = "Import";
            this.importToolStripMenuItem.Click += new System.EventHandler(this.importToolStripMenuItem_Click);
            // 
            // exportToolStripMenuItem
            // 
            this.exportToolStripMenuItem.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(27)))), ((int)(((byte)(27)))), ((int)(((byte)(28)))));
            this.exportToolStripMenuItem.ForeColor = System.Drawing.Color.FromArgb(((int)(((byte)(220)))), ((int)(((byte)(220)))), ((int)(((byte)(220)))));
            this.exportToolStripMenuItem.Name = "exportToolStripMenuItem";
            this.exportToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.E)));
            this.exportToolStripMenuItem.Size = new System.Drawing.Size(287, 28);
            this.exportToolStripMenuItem.Text = "Export";
            this.exportToolStripMenuItem.Click += new System.EventHandler(this.exportToolStripMenuItem_Click);
            // 
            // secureExportToolStripMenuItem
            // 
            this.secureExportToolStripMenuItem.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(27)))), ((int)(((byte)(27)))), ((int)(((byte)(28)))));
            this.secureExportToolStripMenuItem.ForeColor = System.Drawing.Color.FromArgb(((int)(((byte)(220)))), ((int)(((byte)(220)))), ((int)(((byte)(220)))));
            this.secureExportToolStripMenuItem.Name = "secureExportToolStripMenuItem";
            this.secureExportToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)(((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.Shift) 
            | System.Windows.Forms.Keys.E)));
            this.secureExportToolStripMenuItem.Size = new System.Drawing.Size(287, 28);
            this.secureExportToolStripMenuItem.Text = "Secure Export";
            this.secureExportToolStripMenuItem.Click += new System.EventHandler(this.secureExportToolStripMenuItem_Click);
            // 
            // treeView1
            // 
            this.treeView1.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(37)))), ((int)(((byte)(37)))), ((int)(((byte)(38)))));
            this.treeView1.Dock = System.Windows.Forms.DockStyle.Fill;
            this.treeView1.Location = new System.Drawing.Point(3, 25);
            this.treeView1.Name = "treeView1";
            this.treeView1.Size = new System.Drawing.Size(389, 382);
            this.treeView1.TabIndex = 0;
            this.treeView1.NodeMouseDoubleClick += new System.Windows.Forms.TreeNodeMouseClickEventHandler(this.treeView1_NodeMouseDoubleClick);
            // 
            // label1
            // 
            this.label1.Anchor = System.Windows.Forms.AnchorStyles.None;
            this.label1.AutoSize = true;
            this.label1.ForeColor = System.Drawing.Color.White;
            this.label1.Location = new System.Drawing.Point(146, 3);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(103, 16);
            this.label1.TabIndex = 2;
            this.label1.Text = "Assembly Tree:";
            // 
            // tableLayoutPanel1
            // 
            this.tableLayoutPanel1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
            | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
            this.tableLayoutPanel1.AutoSize = true;
            this.tableLayoutPanel1.ColumnCount = 2;
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel1.Controls.Add(this.button1, 1, 2);
            this.tableLayoutPanel1.Controls.Add(this.label2, 1, 0);
            this.tableLayoutPanel1.Controls.Add(this.treeView1, 0, 1);
            this.tableLayoutPanel1.Controls.Add(this.label1, 0, 0);
            this.tableLayoutPanel1.Controls.Add(this.richTextBox1, 1, 1);
            this.tableLayoutPanel1.Location = new System.Drawing.Point(22, 41);
            this.tableLayoutPanel1.Name = "tableLayoutPanel1";
            this.tableLayoutPanel1.RowCount = 3;
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 5F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 85F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 10F));
            this.tableLayoutPanel1.Size = new System.Drawing.Size(791, 457);
            this.tableLayoutPanel1.TabIndex = 3;
            // 
            // button1
            // 
            this.button1.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(63)))), ((int)(((byte)(63)))), ((int)(((byte)(70)))));
            this.button1.Cursor = System.Windows.Forms.Cursors.Hand;
            this.button1.Dock = System.Windows.Forms.DockStyle.Right;
            this.button1.FlatAppearance.BorderColor = System.Drawing.Color.FromArgb(((int)(((byte)(85)))), ((int)(((byte)(85)))), ((int)(((byte)(85)))));
            this.button1.FlatAppearance.BorderSize = 2;
            this.button1.FlatAppearance.MouseDownBackColor = System.Drawing.Color.FromArgb(((int)(((byte)(0)))), ((int)(((byte)(122)))), ((int)(((byte)(204)))));
            this.button1.FlatAppearance.MouseOverBackColor = System.Drawing.Color.FromArgb(((int)(((byte)(0)))), ((int)(((byte)(102)))), ((int)(((byte)(204)))));
            this.button1.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.button1.ForeColor = System.Drawing.SystemColors.ButtonHighlight;
            this.button1.Location = new System.Drawing.Point(629, 413);
            this.button1.Name = "button1";
            this.button1.Size = new System.Drawing.Size(159, 41);
            this.button1.TabIndex = 4;
            this.button1.Text = "Apply Patches";
            this.button1.UseVisualStyleBackColor = false;
            this.button1.Click += new System.EventHandler(this.button1_Click);
            // 
            // label2
            // 
            this.label2.Anchor = System.Windows.Forms.AnchorStyles.None;
            this.label2.AutoSize = true;
            this.label2.ForeColor = System.Drawing.Color.White;
            this.label2.Location = new System.Drawing.Point(559, 3);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(68, 16);
            this.label2.TabIndex = 3;
            this.label2.Text = "Patch List:";
            // 
            // richTextBox1
            // 
            this.richTextBox1.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(37)))), ((int)(((byte)(37)))), ((int)(((byte)(38)))));
            this.richTextBox1.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.richTextBox1.Cursor = System.Windows.Forms.Cursors.Default;
            this.richTextBox1.DetectUrls = false;
            this.richTextBox1.Dock = System.Windows.Forms.DockStyle.Fill;
            this.richTextBox1.ForeColor = System.Drawing.SystemColors.Window;
            this.richTextBox1.Location = new System.Drawing.Point(398, 25);
            this.richTextBox1.Name = "richTextBox1";
            this.richTextBox1.ReadOnly = true;
            this.richTextBox1.ShortcutsEnabled = false;
            this.richTextBox1.Size = new System.Drawing.Size(390, 382);
            this.richTextBox1.TabIndex = 5;
            this.richTextBox1.Text = "";
            this.richTextBox1.WordWrap = false;
            // 
            // Form1
            // 
            this.AllowDrop = true;
            this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 16F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(45)))), ((int)(((byte)(45)))), ((int)(((byte)(48)))));
            this.ClientSize = new System.Drawing.Size(844, 522);
            this.Controls.Add(this.tableLayoutPanel1);
            this.Controls.Add(this.menuStrip1);
            this.Name = "Form1";
            this.Text = "ACEPatcher";
            this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.Form1_FormClosing);
            this.DragDrop += new System.Windows.Forms.DragEventHandler(this.Form1_DragDrop);
            this.DragEnter += new System.Windows.Forms.DragEventHandler(this.Form1_DragEnter);
            this.menuStrip1.ResumeLayout(false);
            this.menuStrip1.PerformLayout();
            this.tableLayoutPanel1.ResumeLayout(false);
            this.tableLayoutPanel1.PerformLayout();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.MenuStrip menuStrip1;
        private System.Windows.Forms.ToolStripMenuItem fileToolStripMenuItem1;
        private System.Windows.Forms.ToolStripMenuItem openToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem importToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem exportToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem secureExportToolStripMenuItem;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.TreeView treeView1;
        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.Button button1;
        private System.Windows.Forms.RichTextBox richTextBox1;
    }
}


```

`ACEPatcher/MainFRM.cs`:

```cs
using ACEPatcher.Controls;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using dnlib.DotNet;
using System.IO;
using ACEPatcher.ModuleLoader;
using System.Resources;
using System.Globalization;
using System.Collections;

namespace ACEPatcher
{
    public partial class MainFRM : Form
    {
        ModuleDefMD AssemblyToPatch;
        ModuleDefMD[] Dependancies;
        string AssemblyPath;

        private void PrepareMenuStrip() 
        {
            menuStrip1.Renderer = new DarkMenuRenderer();
            foreach (ToolStripMenuItem menuItem in menuStrip1.Items)
            {
                ((ToolStripDropDownMenu)menuItem.DropDown).ShowImageMargin = false;
            }
            
        }

        private void PrepareTreeListView() 
        {
            ResourceManager resourceManager = Icons.ResourceManager;
            ResourceSet resourceSet = resourceManager.GetResourceSet(CultureInfo.CurrentUICulture, true, true);
            TreeViewLoader.Images = new ImageList();
            TreeViewLoader.ResourceMap = new Dictionary<string, int>();
            foreach(DictionaryEntry resource in resourceSet) 
            {
                if (resource.Value.GetType() != typeof(Icon))
                {
                    TreeViewLoader.ResourceMap.Add(resource.Key.ToString().Replace("_16x", ""), TreeViewLoader.Images.Images.Count);
                    TreeViewLoader.Images.Images.Add((Bitmap)resource.Value);
                }
            }
            treeView1.ImageList = TreeViewLoader.Images;
        }

        public MainFRM()
        {
            InitializeComponent();
            PrepareMenuStrip();
            PrepareTreeListView();
            this.Icon = Icons.patch;
        }

        private void Form1_DragDrop(object sender, DragEventArgs e)
        {
            string[] files = (string[])e.Data.GetData(DataFormats.FileDrop);
            if (File.Exists(files[0])) 
            {
                string[] failed;
                AssemblyToPatch = DotNetModuleLoader.LoadModule(files[0],out Dependancies,out failed);
                if(AssemblyToPatch == null) 
                {
                    MessageBox.Show("Invalid Assembly");
                    return;
                } 
                AssemblyPath = files[0];
                TreeViewLoader.FillTreeView(AssemblyToPatch,Dependancies,treeView1,true);
                if (failed.Length > 0)
                {
                    MessageBox.Show("Failed to load: \r\n" + string.Join("\r\n", failed) + "\r\nSome references might be missing", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                }
            }
            else 
            {
                MessageBox.Show("Invalid file");
            }
        }

        private void Form1_DragEnter(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent(DataFormats.FileDrop))
                e.Effect = DragDropEffects.Copy;
            else
                e.Effect = DragDropEffects.None;
        }

        private void openToolStripMenuItem_Click(object sender, EventArgs e)
        {
            OpenFileDialog dialog = new OpenFileDialog() 
            {
                Title = "Load assembly",
                Filter = "Executable|*.exe|Dynamic Link Library|*.dll",
                CheckFileExists = true
            };
            if(dialog.ShowDialog() == DialogResult.OK) 
            {
                string[] failed;
                AssemblyToPatch = DotNetModuleLoader.LoadModule(dialog.FileName,out Dependancies,out failed);
                if (AssemblyToPatch == null)
                {
                    MessageBox.Show("Invalid Assembly");
                    return;
                }
                AssemblyPath = dialog.FileName;
                TreeViewLoader.FillTreeView(AssemblyToPatch,Dependancies, treeView1,true);
                if (failed.Length > 0) 
                {
                    MessageBox.Show("Failed to load: \r\n" + string.Join("\r\n", failed) + "\r\nSome references might be missing", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                }
            }
        }

        private void treeView1_NodeMouseDoubleClick(object sender, TreeNodeMouseClickEventArgs e)
        {
            if(e.Node.Tag != null && e.Node.Tag.GetType().GetInterfaces().Contains(typeof(IMethodDefOrRef))) 
            {
                Patcher.AddPatchToList((IMethod)e.Node.Tag);
                string[] vs = new string[Patcher.patchList.Count];
                for(int i = 0; i < Patcher.patchList.Count; i++) 
                {
                    vs[i] = Patcher.patchList.ElementAt(i).Key.DeclaringType.Name + "." + Patcher.patchList.ElementAt(i).Key.Name + "->" + Patcher.patchList.ElementAt(i).Value.DeclaringType.Name + "." + Patcher.patchList.ElementAt(i).Value.Name;
                }
                richTextBox1.Lines = vs;
            } 
        }

        

        private void button1_Click(object sender, EventArgs e)
        {
            if(richTextBox1.Text.Length == 0) 
                MessageBox.Show("No patches made", "Information", MessageBoxButtons.OK, MessageBoxIcon.Information);
            else
                Patcher.ApplyPatches(AssemblyPath);
        }

        private void Form1_FormClosing(object sender, FormClosingEventArgs e)
        {
            Environment.Exit(0);
        }

        private void exportToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if(Patcher.patchAssembly == null || Patcher.patchList.Count == 0) 
            {
                MessageBox.Show("No patches to export", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
            SaveFileDialog dialog = new SaveFileDialog()
            {
                Title = "Export patch...",
                Filter = "AcePatcher Patch(*.btb)|*.btb",
            };
            if(dialog.ShowDialog() == DialogResult.OK) 
            {
                ConfigManager.ExportConfig(AssemblyToPatch,dialog.FileName,false);
                MessageBox.Show("File successfully exported", "Information", MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
        }

        private void secureExportToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (Patcher.patchAssembly == null || Patcher.patchList.Count == 0)
            {
                MessageBox.Show("No patches to export", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
            SaveFileDialog dialog = new SaveFileDialog()
            {
                Title = "Export patch",
                Filter = "AcePatcher Patch(*.btb)|*.btb",
            };
            if (dialog.ShowDialog() == DialogResult.OK)
            {
                string password = "";
                if(InputBox("Password","Type in password:",ref password) == DialogResult.OK)
                ConfigManager.ExportConfig(AssemblyToPatch, dialog.FileName, true,password);
                MessageBox.Show("File successfully exported", "Information", MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
        }

        public static DialogResult InputBox(string title, string promptText, ref string value)
        {
            Form form = new Form();
            Label label = new Label();
            TextBox textBox = new TextBox();
            Button buttonOk = new Button();
            Button buttonCancel = new Button();

            form.Text = title;
            label.Text = promptText;
            textBox.Text = value;

            buttonOk.Text = "OK";
            buttonCancel.Text = "Cancel";
            buttonOk.DialogResult = DialogResult.OK;
            buttonCancel.DialogResult = DialogResult.Cancel;

            label.SetBounds(9, 20, 372, 13);
            textBox.SetBounds(12, 36, 372, 20);
            buttonOk.SetBounds(228, 72, 75, 23);
            buttonCancel.SetBounds(309, 72, 75, 23);

            label.AutoSize = true;
            textBox.Anchor = textBox.Anchor | AnchorStyles.Right;
            buttonOk.Anchor = AnchorStyles.Bottom | AnchorStyles.Right;
            buttonCancel.Anchor = AnchorStyles.Bottom | AnchorStyles.Right;

            form.ClientSize = new Size(396, 107);
            form.Controls.AddRange(new Control[] { label, textBox, buttonOk, buttonCancel });
            form.ClientSize = new Size(Math.Max(300, label.Right + 10), form.ClientSize.Height);
            form.FormBorderStyle = FormBorderStyle.FixedDialog;
            form.StartPosition = FormStartPosition.CenterScreen;
            form.MinimizeBox = false;
            form.MaximizeBox = false;
            form.AcceptButton = buttonOk;
            form.CancelButton = buttonCancel;

            DialogResult dialogResult = form.ShowDialog();
            value = textBox.Text;
            return dialogResult;
        }

        private void importToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if(AssemblyToPatch != null) 
            {
                OpenFileDialog dialog = new OpenFileDialog()
                {
                    Title = "Import Patch",
                    Filter = "AcePatcher Patch(*.btb)|*.btb",
                    CheckFileExists = true
                };
                if(dialog.ShowDialog() == DialogResult.OK) 
                {
                    ConfigManager.ImportConfig(Dependancies,dialog.FileName);
                    string[] vs = new string[Patcher.patchList.Count];
                    for (int i = 0; i < Patcher.patchList.Count; i++)
                    {
                        vs[i] = Patcher.patchList.ElementAt(i).Key.DeclaringType.Name + "." + Patcher.patchList.ElementAt(i).Key.Name + "->" + Patcher.patchList.ElementAt(i).Value.DeclaringType.Name + "." + Patcher.patchList.ElementAt(i).Value.Name;
                    }
                    richTextBox1.Lines = vs;
                }
            }
            else 
            {
                MessageBox.Show("Please load the assembly first", "Information", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
            }
        }
    }
}

```

`ACEPatcher/MainFRM.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="menuStrip1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
</root>
```

`ACEPatcher/ModuleLoader/DotNetModuleLoader.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using dnlib.DotNet;
using dnlib.DotNet.MD;
using dnlib.PE;
using System.Windows.Forms;
using System.ComponentModel;
using System.Threading;
using dnlib.DotNet.Writer;

namespace ACEPatcher.ModuleLoader
{
    class DotNetModuleLoader
    {
        [DllImport("kernel32.dll")]
        private static extern IntPtr OpenThread(int dwDesiredAccess, bool bInheritHandle, uint dwThreadId);

        [DllImport("kernel32.dll")]
        private static extern uint SuspendThread(IntPtr hThread);

        [DllImport("kernel32", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern bool CloseHandle(IntPtr handle);

        [DllImport("dbghelp.dll",SetLastError = true)]
        public static extern bool MiniDumpWriteDump(IntPtr hProcess,uint processId,SafeHandle hFile,int dumpType,IntPtr expParam,IntPtr userStreamParam,IntPtr callbackParam);

        static int BitNessConstant = IntPtr.Size == 4 ? 0x010B : 0x020B;

        static bool IsDotNetAssembly(string path)
        {
            PEImage image = new PEImage(path);
            return image.ImageNTHeaders.OptionalHeader.DataDirectories[14].VirtualAddress != 0;
        }

        static bool DoesBitnessMatch(string path)
        {
            PEImage image = new PEImage(path);
            return image.ImageNTHeaders.OptionalHeader.Magic == BitNessConstant;
        }

        public static ModuleDefMD LoadModule(string path,out ModuleDefMD[] dependancies,out string[] failed) 
        {
            failed = null;
            if (IsDotNetAssembly(path)) 
            {
                ModuleDefMD m = ModuleDefMD.Load(path);
                if (m != null)
                    dependancies = LoadDependancies(m, path, out failed);
                else
                    dependancies = null;
                return m;
            }
            else 
            {
                ModuleDefMD m = TryLoadPackedDotNetAssembly(path);
                if (m != null)
                    dependancies = LoadDependancies(m, path, out failed);
                else
                    dependancies = null;
                return m;
            }
        } 

        static ModuleDefMD TryLoadPackedDotNetAssembly(string path) 
        {
            if (!DoesBitnessMatch(path)) 
            {
                MessageBox.Show("Please use " + (BitNessConstant == 0x010B ? "64bit" : "32bit") + " version of ACEPatcher on this assembly");
                return null;
            }
            Process process;
            if((process = Freeze(path)) != null) 
            {
                string dumpFile = DumpProccess(process);
                process.Kill();
                ModuleDefMD moduleDef = dumpMainModule(dumpFile);
                GC.Collect();
                GC.WaitForPendingFinalizers();
                File.Delete(dumpFile);
                return moduleDef;
            }
            else 
            {
                return null;
            }
        }

        static Process Freeze(string path) 
        {
            Process process = new Process();
            process.StartInfo.FileName = path;
            process.StartInfo.CreateNoWindow = true;
            process.StartInfo.UseShellExecute = false;
            Stopwatch stopwatch = new Stopwatch();
            stopwatch.Start();
            process.Start();
            while (true) 
            {
                if (GetCLRModule(process.Id)) 
                {
                    SuspendThreads(process.Id);
                    return process;
                }
                if(stopwatch.ElapsedMilliseconds >= 10000) 
                {
                    process.Close();
                    return null;
                }
            }
        }

        static bool GetCLRModule(int pID)
        {
            ProcessModuleCollection modules = Process.GetProcessById(pID).Modules;
            for (int i = 0; i < modules.Count; i++)
            {
                if (modules[i].ModuleName.ToLower() == "clr.dll")
                {
                    return true;
                }
            }
            return false;
        }

        static void SuspendThreads(int pid)
        {
            Process processById = Process.GetProcessById(pid);
            if (string.IsNullOrEmpty(processById.ProcessName))
            {
                return;
            }
            foreach (object obj in processById.Threads)
            {
                ProcessThread processThread = (ProcessThread)obj;
                IntPtr intPtr = OpenThread(2, false, (uint)processThread.Id);
                if (!(intPtr == IntPtr.Zero))
                {
                    SuspendThread(intPtr);
                    CloseHandle(intPtr);
                }
            }
        }

        static string DumpProccess(Process process) 
        {
            string result = Path.GetTempFileName();
            using (var fs = new FileStream(result, FileMode.Create, FileAccess.ReadWrite, FileShare.None))
            {
                if (!MiniDumpWriteDump(process.Handle, (uint)process.Id, fs.SafeFileHandle, 2, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero))
                {
                    throw new Win32Exception(Marshal.GetLastWin32Error());
                }
            }
            return result;
        }

        static unsafe ModuleDefMD dumpMainModule(string fileName)
        {
            byte[] dumpData = File.ReadAllBytes(fileName);
            fixed (byte* dump = dumpData)
            {
                for (int i = 0; i < dumpData.Length; i++)
                {
                    if (dump[i] == 0x4D && dump[i + 1] == 0x5A)
                    {
                        int NTHeaderOffset = *(int*)(dump + i + 0x3C);

                        if (*(int*)(dump + i + NTHeaderOffset) == 0x00004550)
                        {
                            if (*(short*)(dump + i + NTHeaderOffset + 0x18) == 0x010B || *(short*)(dump + i + NTHeaderOffset + 0x18) == 0x020B)
                            {
                                PEImage image = new PEImage((IntPtr)(dump + i), false);
                                uint alignment = image.ImageNTHeaders.OptionalHeader.FileAlignment;
                                uint imageSize = image.ImageSectionHeaders.Last().PointerToRawData + image.ImageSectionHeaders.Last().SizeOfRawData;
                                if (imageSize % alignment != 0)
                                    imageSize = imageSize - (imageSize % alignment) + alignment;
                                byte[] AssemblyData = new byte[imageSize];
                                Marshal.Copy((IntPtr)(dump + i), AssemblyData, 0, (int)imageSize);
                                if (image.ImageNTHeaders.OptionalHeader.DataDirectories[14].VirtualAddress != 0)
                                {
                                    ModuleDefMD moduleDef = ModuleDefMD.Load(AssemblyData);
                                    if (moduleDef.Name.EndsWith(".exe")) 
                                    {
                                        return moduleDef;
                                    }
                                    else
                                        moduleDef.Dispose();
                                }

                            }
                        }
                    }

                }
            }
            return null;
        }

        public static ModuleDefMD[] LoadDependancies(ModuleDefMD md, string path, out string[] failed)
        {
            List<string> f = new List<string>();
            List<ModuleDefMD> result = new List<ModuleDefMD>();
            List<AssemblyRef> refs = md.GetAssemblyRefs().ToList();
            List<AssemblyRef> backup = new List<AssemblyRef>(refs);
            string[] files = Directory.GetFiles(Path.GetDirectoryName(path)).Where(x => x.ToLower().EndsWith(".dll") || x.ToLower().EndsWith(".exe")).ToArray();
            foreach (string file in files)
            {
                try
                {
                    using (PEImage image = new PEImage(file))
                    {
                        if (IsDotNetAssembly(file))
                        {
                            AssemblyName name = AssemblyName.GetAssemblyName(file);
                            if (refs.Any(x => x.FullName == name.FullName))
                            {
                                result.Add(ModuleDefMD.Load(file));
                                refs.Remove(refs.Where(x => x.FullName == name.FullName).First());
                                backup.Remove(backup.Where(x => x.FullName == name.FullName).First());
                            }
                        }
                    }
                }
                catch
                {

                }
            }
            foreach (AssemblyRef r in refs)
            {
                try
                {
                    AssemblyName name = new AssemblyName(r.FullName);
                    result.Add(ModuleDefMD.Load(Assembly.Load(name).ManifestModule));
                    backup.Remove(r);
                }
                catch
                {

                }
            }
            foreach (AssemblyRef r in backup)
                f.Add(r.FullName);
            failed = f.ToArray();
            return result.ToArray();
        }


    }

    class NoErrorLoggin : ILogger
    {
        public bool IgnoresEvent(LoggerEvent loggerEvent)
        {
            return true;
        }

        public void Log(object sender, LoggerEvent loggerEvent, string format, params object[] args)
        {
            
        }
    }
}

```

`ACEPatcher/PatchDialog.Designer.cs`:

```cs

namespace ACEPatcher
{
    partial class PatchDialog
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.label1 = new System.Windows.Forms.Label();
            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();
            this.treeView1 = new System.Windows.Forms.TreeView();
            this.button1 = new System.Windows.Forms.Button();
            this.tableLayoutPanel1.SuspendLayout();
            this.SuspendLayout();
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Dock = System.Windows.Forms.DockStyle.Left;
            this.label1.Font = new System.Drawing.Font("Arial", 11.90083F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label1.ForeColor = System.Drawing.Color.White;
            this.label1.Location = new System.Drawing.Point(3, 0);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(220, 45);
            this.label1.TabIndex = 0;
            this.label1.Text = "Choose patch method:";
            this.label1.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // tableLayoutPanel1
            // 
            this.tableLayoutPanel1.ColumnCount = 1;
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 100F));
            this.tableLayoutPanel1.Controls.Add(this.label1, 0, 0);
            this.tableLayoutPanel1.Controls.Add(this.treeView1, 0, 1);
            this.tableLayoutPanel1.Controls.Add(this.button1, 0, 2);
            this.tableLayoutPanel1.Dock = System.Windows.Forms.DockStyle.Fill;
            this.tableLayoutPanel1.Location = new System.Drawing.Point(0, 0);
            this.tableLayoutPanel1.Name = "tableLayoutPanel1";
            this.tableLayoutPanel1.RowCount = 3;
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 10F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 80F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 10F));
            this.tableLayoutPanel1.Size = new System.Drawing.Size(800, 450);
            this.tableLayoutPanel1.TabIndex = 1;
            // 
            // treeView1
            // 
            this.treeView1.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(37)))), ((int)(((byte)(37)))), ((int)(((byte)(38)))));
            this.treeView1.Dock = System.Windows.Forms.DockStyle.Fill;
            this.treeView1.Location = new System.Drawing.Point(3, 48);
            this.treeView1.Name = "treeView1";
            this.treeView1.Size = new System.Drawing.Size(794, 354);
            this.treeView1.TabIndex = 1;
            // 
            // button1
            // 
            this.button1.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(63)))), ((int)(((byte)(63)))), ((int)(((byte)(70)))));
            this.button1.Cursor = System.Windows.Forms.Cursors.Hand;
            this.button1.Dock = System.Windows.Forms.DockStyle.Right;
            this.button1.FlatAppearance.BorderColor = System.Drawing.Color.FromArgb(((int)(((byte)(85)))), ((int)(((byte)(85)))), ((int)(((byte)(85)))));
            this.button1.FlatAppearance.BorderSize = 2;
            this.button1.FlatAppearance.MouseDownBackColor = System.Drawing.Color.FromArgb(((int)(((byte)(0)))), ((int)(((byte)(122)))), ((int)(((byte)(204)))));
            this.button1.FlatAppearance.MouseOverBackColor = System.Drawing.Color.FromArgb(((int)(((byte)(0)))), ((int)(((byte)(102)))), ((int)(((byte)(204)))));
            this.button1.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.button1.ForeColor = System.Drawing.SystemColors.ButtonHighlight;
            this.button1.Location = new System.Drawing.Point(638, 408);
            this.button1.Name = "button1";
            this.button1.Size = new System.Drawing.Size(159, 39);
            this.button1.TabIndex = 2;
            this.button1.Text = "Add Patch";
            this.button1.UseVisualStyleBackColor = false;
            this.button1.Click += new System.EventHandler(this.button1_Click);
            // 
            // PatchDialog
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 16F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(45)))), ((int)(((byte)(45)))), ((int)(((byte)(48)))));
            this.ClientSize = new System.Drawing.Size(800, 450);
            this.Controls.Add(this.tableLayoutPanel1);
            this.Name = "PatchDialog";
            this.Text = "PatchDialog";
            this.tableLayoutPanel1.ResumeLayout(false);
            this.tableLayoutPanel1.PerformLayout();
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;
        private System.Windows.Forms.TreeView treeView1;
        private System.Windows.Forms.Button button1;
    }
}
```

`ACEPatcher/PatchDialog.cs`:

```cs
using dnlib.DotNet;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace ACEPatcher
{
    public partial class PatchDialog : Form
    {
        public IMethod SelectedMethod;

        public PatchDialog()
        {
            InitializeComponent();
            treeView1.ImageList = TreeViewLoader.Images;
            TreeViewLoader.FillTreeView(Patcher.patchAssembly,null, treeView1);
            this.Icon = Icons.patch;
        }

        private void button1_Click(object sender, EventArgs e)
        {
            if(treeView1.SelectedNode == null) 
            {
                MessageBox.Show("Please select a patch method", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Warning);
            }
            else 
            {
                if (treeView1.SelectedNode.Tag.GetType().GetInterfaces().Contains(typeof(IMethodDefOrRef))) 
                {
                    SelectedMethod = (IMethod)treeView1.SelectedNode.Tag;
                    DialogResult = DialogResult.OK;
                    Close();
                }
                else 
                {
                    MessageBox.Show("Please select a valid method", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                }
            }
        }
    }
}

```

`ACEPatcher/PatchDialog.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`ACEPatcher/Patcher.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Windows.Forms;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.PE;


namespace ACEPatcher
{
    class Patcher
    {
        public static ModuleDefMD patchAssembly;
        public static ModuleDefMD _0harmony = ModuleDefMD.Load(ACEFiles._0Harmony);
        public static string patchAssemblyPath;
        public static Dictionary<IMethod, IMethod> patchList = new Dictionary<IMethod, IMethod>();
        
        private static bool CompareSignature(IMethod method1,IMethod method2) 
        {
            if (method1.MethodSig.RetType.FullName != method2.MethodSig.RetType.FullName)
                return false;
            if (((MethodDef)method1).HasThis)
            {
                if (method1.MethodSig.Params.Count+1 != method2.MethodSig.Params.Count)
                    return false;
                if (method1.DeclaringType.FullName != method2.GetParam(0).FullName)
                    return false;
                int i = 0;
                for(int j = 0; j < method1.MethodSig.Params.Count; j++) 
                {
                    if (method1.MethodSig.Params[j].FullName == method2.MethodSig.Params[j+1].FullName)
                        i++;
                }
                return method1.MethodSig.Params.Count == i;
            }
            else
            {
                if (method1.MethodSig.Params.Count != method2.MethodSig.Params.Count)
                    return false;
                int i = 0;
                for (int j = 0; j < method1.MethodSig.Params.Count; j++)
                {
                    if (method1.MethodSig.Params[j].FullName == method2.MethodSig.Params[j].FullName)
                        i++;
                }
                return i == method1.MethodSig.Params.Count;
            }
        }

        private static OpCode DetermineStindType(TypeSig sig) 
        {
            if (sig == patchAssembly.CorLibTypes.IntPtr)
                return OpCodes.Stind_I;
            else if (sig == patchAssembly.CorLibTypes.SByte || sig == patchAssembly.CorLibTypes.Byte || sig == patchAssembly.CorLibTypes.Boolean)
                return OpCodes.Stind_I1;
            else if (sig == patchAssembly.CorLibTypes.Int16 || sig == patchAssembly.CorLibTypes.UInt16 || sig == patchAssembly.CorLibTypes.Char)
                return OpCodes.Stind_I2;
            else if (sig == patchAssembly.CorLibTypes.Int32 || sig == patchAssembly.CorLibTypes.UInt32)
                return OpCodes.Stind_I4;
            else if (sig == patchAssembly.CorLibTypes.Int64 || sig == patchAssembly.CorLibTypes.UInt64)
                return OpCodes.Stind_I8;
            else if (sig == patchAssembly.CorLibTypes.Single)
                return OpCodes.Stind_R4;
            else if (sig == patchAssembly.CorLibTypes.Double)
                return OpCodes.Stind_R8;
            else
                return OpCodes.Stind_Ref;
        }

        private static OpCode DetermineLdindType(TypeSig sig)
        {
            if (sig == patchAssembly.CorLibTypes.IntPtr)
                return OpCodes.Ldind_I;
            else if (sig == patchAssembly.CorLibTypes.SByte || sig == patchAssembly.CorLibTypes.Byte || sig == patchAssembly.CorLibTypes.Boolean)
                return OpCodes.Ldind_I1;
            else if (sig == patchAssembly.CorLibTypes.Int16 || sig == patchAssembly.CorLibTypes.UInt16 || sig == patchAssembly.CorLibTypes.Char)
                return OpCodes.Ldind_I2;
            else if (sig == patchAssembly.CorLibTypes.Int32 || sig == patchAssembly.CorLibTypes.UInt32)
                return OpCodes.Ldind_I4;
            else if (sig == patchAssembly.CorLibTypes.Int64 || sig == patchAssembly.CorLibTypes.UInt64)
                return OpCodes.Ldind_I8;
            else if (sig == patchAssembly.CorLibTypes.Single)
                return OpCodes.Ldind_R4;
            else if (sig == patchAssembly.CorLibTypes.Double)
                return OpCodes.Ldind_R8;
            else
                return OpCodes.Ldind_Ref;
        }

        public static void AddPatchToList(IMethod method) 
        {
            if(patchAssembly == null) 
            {
                OpenFileDialog dialog = new OpenFileDialog()
                {
                    Title = "Load assembly",
                    Filter = "Executable|*.exe|Dynamic Link Library|*.dll",
                    CheckFileExists = true
                };
                if (dialog.ShowDialog() == DialogResult.OK)
                {
                    try
                    {
                        patchAssembly = ModuleDefMD.Load(dialog.FileName);
                        patchAssemblyPath = dialog.FileName;
                    }
                    catch 
                    {
                        MessageBox.Show("Invalid Assembly", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                }
                else
                    return;
            }
            PatchDialog patchDialog = new PatchDialog();
            if(patchDialog.ShowDialog() == DialogResult.OK) 
            {
                if (((MethodDef)patchDialog.SelectedMethod).HasThis) 
                {
                    MessageBox.Show("The chosen method must be static", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }
                if (CompareSignature(method, patchDialog.SelectedMethod)) 
                {
                    if (!patchList.ContainsKey(method))
                        patchList.Add(method, patchDialog.SelectedMethod);
                    else
                        MessageBox.Show("Method already patched", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                }
                else 
                {
                    MessageBox.Show("Method signature mismatch","Error",MessageBoxButtons.OK,MessageBoxIcon.Error);
                }
            }
        }

        private static MethodDefUser GenerateMethod(IMethod method,Importer importer) 
        {
            MethodDefUser resultMethod = new MethodDefUser("ACE" + Guid.NewGuid().ToString("N"), new MethodSig(CallingConvention.Default, 0, importer.Import(typeof(System.Reflection.MethodBase)).ToTypeSig()), MethodAttributes.Public | MethodAttributes.Static);
            resultMethod.Body = new CilBody();
            resultMethod.Body.Instructions.Add(new Instruction(OpCodes.Ldtoken, method.DeclaringType.DefinitionAssembly.FullName == patchAssembly.Assembly.FullName ? ((MethodDef)method) : importer.Import((MethodDef)method)));
            resultMethod.Body.Instructions.Add(new Instruction(OpCodes.Call, importer.Import(typeof(System.Reflection.MethodBase).GetMethod("GetMethodFromHandle", new Type[] { typeof(RuntimeMethodHandle) }))));
            resultMethod.Body.Instructions.Add(new Instruction(OpCodes.Ret));
            return resultMethod;
        }

        public static void ApplyPatches(string MainAssemblyPath) 
        {
            byte[] backup = DotNetUtils.ReadAssembly(patchAssembly);
            Dictionary<MethodDef, IMethod> patchList2 = new Dictionary<MethodDef, IMethod>();
            foreach (KeyValuePair<IMethod,IMethod> patch in patchList) 
            {
                MethodSig sig = new MethodSig();
                sig.CallingConvention = CallingConvention.Default;
                sig.RetType = patchAssembly.CorLibTypes.Boolean;
                foreach(TypeSig typeSig in patch.Value.MethodSig.Params) 
                    sig.Params.Add(new ByRefSig( typeSig));
                    sig.Params.Add(new ByRefSig(patch.Value.MethodSig.RetType)); 
                MethodDefUser method = new MethodDefUser("Prefix" + DateTimeOffset.UtcNow.ToUnixTimeMilliseconds(),sig,MethodAttributes.Public| MethodAttributes.Static);
                List<ParamDef> paramds = ((MethodDef)patch.Value).ParamDefs.ToList();
                if (((MethodDef)patch.Key).HasThis)
                {
                    method.ParamDefs.Add(new ParamDefUser("__instance", 1));
                    paramds.RemoveAt(0);
                }
                foreach (ParamDef pdef in paramds)
                    method.ParamDefs.Add(new ParamDefUser(pdef.Name, (ushort)(method.ParamDefs.Count + 1)));
                method.ParamDefs.Add(new ParamDefUser("__result",(ushort)(method.ParamDefs.Count+1) ));
                method.Body = new CilBody();
                DotNetUtils.CopyBodyFromTo((MethodDef)patch.Value, method);
                if(((MethodDef)patch.Value).HasReturnType)
                method.Body.Variables.Add(new Local(patch.Value.MethodSig.RetType));
                int stack = 0;
                int LastStackZero = 0;
                method.Body.Instructions.SimplifyMacros(method.Body.Variables, method.Parameters);
                for(int i = 0; i < method.Body.Instructions.Count; i++) 
                {
                    if (stack == 0)
                        LastStackZero = i;
                    if(method.Body.Instructions[i].OpCode == OpCodes.Ret) 
                    {
                        if(((MethodDef)patch.Value).HasReturnType)
                            i += DotNetUtils.ReplaceInstruction(method.Body.Instructions, method.Body.Instructions[i], Instruction.Create(OpCodes.Stloc_S, method.Body.Variables.Last()), Instruction.Create(OpCodes.Ldarg_S, method.Parameters.Last()), Instruction.Create(OpCodes.Ldloc_S, method.Body.Variables.Last()), Instruction.Create(DetermineStindType(patch.Value.MethodSig.RetType)), Instruction.Create(OpCodes.Ldc_I4_0),Instruction.Create(OpCodes.Ret));
                        else
                            i += DotNetUtils.ReplaceInstruction(method.Body.Instructions, method.Body.Instructions[i],Instruction.Create(OpCodes.Ldc_I4_0), Instruction.Create(OpCodes.Ret));
                        LastStackZero = i;
                        stack = 0;
                    }
                    else if(method.Body.Instructions[i].Operand != null && method.Body.Instructions[i].Operand.GetType().GetInterfaces().Contains(typeof(IMethodDefOrRef)) && ((IMDTokenProvider)method.Body.Instructions[i].Operand).MDToken == patch.Value.MDToken) 
                    {
                        if(method.Body.Instructions[i + 1].OpCode != OpCodes.Ret) 
                        {
                            MessageBox.Show("Invalid call to continue", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Error);
                            return;
                        }
                        for(int j = LastStackZero; j < i; j++) 
                        {
                            method.Body.Instructions[j].OpCode = OpCodes.Nop;
                            method.Body.Instructions[j].Operand = null;
                        }
                        i += DotNetUtils.ReplaceInstruction(method.Body.Instructions, method.Body.Instructions[i],new Instruction(OpCodes.Ldc_I4_1));
                        LastStackZero = i;
                        stack = 0;
                    }
                    else if (method.Body.Instructions[i].OpCode.ToString().ToLower().Contains("ldarg")) 
                    {
                        method.Body.Instructions.Insert(i + 1, new Instruction(DetermineLdindType(((Parameter)method.Body.Instructions[i].Operand).Type)));
                    }
                    else if (method.Body.Instructions[i].OpCode.ToString().ToLower().Contains("starg")) 
                    {
                        stack++;
                        method.Body.Instructions.Insert(LastStackZero, new Instruction(OpCodes.Ldarg, method.Body.Instructions[i++].Operand));
                        method.Body.Instructions[i].OpCode = DetermineStindType(((Parameter)method.Body.Instructions[i].Operand).Type);
                        method.Body.Instructions[i].Operand = null;
                    }
                    try
                    {
                        method.Body.Instructions[i].UpdateStack(ref stack);
                    }
                    catch 
                    {
                        break;
                    }
                }
                method.Body.Instructions.UpdateInstructionOffsets();
                method.Body.Instructions.OptimizeMacros();
                ((TypeDef)patch.Value.DeclaringType).Methods.Add(method);
                patchList2.Add(method, patch.Key);
            }
            TypeDefUser patchType = new TypeDefUser("ACE", patchAssembly.CorLibTypes.Object.ToTypeDefOrRef());
            MethodDefUser patchMethod = new MethodDefUser("ACE" + DateTimeOffset.UtcNow.ToUnixTimeMilliseconds(), new MethodSig(CallingConvention.Default, 0, patchAssembly.CorLibTypes.Int32, patchAssembly.CorLibTypes.String), MethodAttributes.Public | MethodAttributes.Static);
            patchAssembly.Types.Add(patchType);
            patchType.Methods.Add(patchMethod);
            patchMethod.Body = new CilBody();
            Importer importer = new Importer(patchAssembly);
            var guid = importer.Import(typeof(Guid));
            patchMethod.Body.Variables.Add(new Local(new ValueTypeSig(guid)));
            foreach (KeyValuePair<MethodDef,IMethod> patch in patchList2) 
            {
                patchMethod.Body.Instructions.Add(new Instruction(OpCodes.Call,importer.Import(typeof(Guid).GetMethod("NewGuid"))));
                patchMethod.Body.Instructions.Add(new Instruction(OpCodes.Stloc_0));
                patchMethod.Body.Instructions.Add(new Instruction(OpCodes.Ldloca_S,patchMethod.Body.Variables[0]));
                patchMethod.Body.Instructions.Add(new Instruction(OpCodes.Ldstr,"N"));
                patchMethod.Body.Instructions.Add(new Instruction(OpCodes.Call, importer.Import(typeof(Guid).GetMethod("ToString",new Type[] { typeof(string)}))));
                patchMethod.Body.Instructions.Add(new Instruction(OpCodes.Newobj, importer.Import(_0harmony.ResolveMethod(438))));
                MethodDef method1 = GenerateMethod(patch.Value, importer);
                patchType.Methods.Add(method1);
                patchMethod.Body.Instructions.Add(new Instruction(OpCodes.Call,method1));
                method1 = GenerateMethod(patch.Key, importer);
                patchType.Methods.Add(method1);
                patchMethod.Body.Instructions.Add(new Instruction(OpCodes.Call, method1));
                patchMethod.Body.Instructions.Add(new Instruction(OpCodes.Castclass, importer.Import(typeof(System.Reflection.MethodInfo))));
                patchMethod.Body.Instructions.Add(new Instruction(OpCodes.Newobj, importer.Import(_0harmony.ResolveMethod(488))));
                patchMethod.Body.Instructions.Add(new Instruction(OpCodes.Ldnull));
                patchMethod.Body.Instructions.Add(new Instruction(OpCodes.Ldnull));
                patchMethod.Body.Instructions.Add(new Instruction(OpCodes.Ldnull));
                patchMethod.Body.Instructions.Add(new Instruction(OpCodes.Call, importer.Import(_0harmony.ResolveMethod(444))));
                patchMethod.Body.Instructions.Add(new Instruction(OpCodes.Pop));
            }
            patchMethod.Body.Instructions.Add(new Instruction(OpCodes.Ldc_I4_1));
            patchMethod.Body.Instructions.Add(new Instruction(OpCodes.Ret));
            MemoryStream stream = new MemoryStream();
            patchAssembly.Write(stream);
            byte[] patchedAssembly = stream.ToArray();
            string path = Path.GetFileNameWithoutExtension(MainAssemblyPath) + "_patch_" + DateTimeOffset.Now.ToUnixTimeSeconds();
            Directory.CreateDirectory(path);
            File.Copy(MainAssemblyPath, path + "/" + Path.GetFileName(MainAssemblyPath));
            File.WriteAllBytes(path + "/0harmony.dll", ACEFiles._0Harmony);
            if(new PEImage(MainAssemblyPath).ImageNTHeaders.OptionalHeader.Magic == 0x010B) 
            {
                File.WriteAllBytes(path + "/DllInjector.exe",ACEFiles.DllInjector);
                File.WriteAllBytes(path + "/ACE.dll",ACEFiles.ACEx32);
            }
            else 
            {
                File.WriteAllBytes(path + "/DllInjector.exe", ACEFiles.DllInjector64);
                File.WriteAllBytes(path + "/ACE.dll", ACEFiles.ACEx64);
            }
            File.WriteAllBytes(path + "/patch", patchedAssembly);
            string command = "DllInjector.exe " + Path.GetFileName(MainAssemblyPath) + " ACE.dll patch " + patchType.Name + "." + patchMethod.Name;
            File.WriteAllText(path + "/Execute.bat", command);
            ModuleDefMD backup2 = ModuleDefMD.Load(backup);
            Dictionary<IMethod, IMethod> newDict = new Dictionary<IMethod, IMethod>();
            foreach(KeyValuePair<IMethod,IMethod> pair in patchList) 
            {
                newDict.Add(pair.Key, (IMethod)backup2.ResolveToken(pair.Value.MDToken));
            }
            patchList = newDict;
            patchAssembly = backup2;
            MessageBox.Show("Assembly succcessfully patched, please move all dependancies into the folder with patched executable","Success",MessageBoxButtons.OK,MessageBoxIcon.Information);
        }


    }
}

```

`ACEPatcher/Program.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace ACEPatcher
{
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new MainFRM());
        }
    }
}

```

`ACEPatcher/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ACEPatcher")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("ACEPatcher")]
[assembly: AssemblyCopyright("Copyright ©  2022")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("f7f4a377-f96f-4cb6-91f1-bcee82a8de63")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`ACEPatcher/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


namespace ACEPatcher.Properties
{
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("ACEPatcher.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}

```

`ACEPatcher/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`ACEPatcher/Properties/Settings.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


namespace ACEPatcher.Properties
{
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "11.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}

```

`ACEPatcher/Properties/Settings.settings`:

```settings
<?xml version='1.0' encoding='utf-8'?>
<SettingsFile xmlns="http://schemas.microsoft.com/VisualStudio/2004/01/settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
  <Settings />
</SettingsFile>

```

`ACEPatcher/TreeViewLoader.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using dnlib.DotNet;
using System.Windows.Forms;
using System.Drawing;

namespace ACEPatcher
{
    class TreeViewLoader
    {
        public static Dictionary<string, int> ResourceMap;
        public static ImageList Images;
        private static TreeNode[] ListNamespaces(ModuleDef module)
        {
            List<TreeNode> namespaces = new List<TreeNode>();
            namespaces.Add(new TreeNode("", ResourceMap["Namespace"], ResourceMap["Namespace"]) { ForeColor = Color.FromArgb(255, 215, 15) });
            foreach (TypeDef def in module.Types)
            {
                string ns = def.Namespace.String;
                if (namespaces.Where(x => x.Text == ns).Count() == 0)
                    namespaces.Add(new TreeNode(ns,ResourceMap["Namespace"], ResourceMap["Namespace"]) { ForeColor = Color.FromArgb(255, 215, 15) });
            }
            return namespaces.ToArray();
        }

        public static void FillTreeView(ModuleDefMD module,ModuleDefMD[] dependancies,TreeView treeView,bool AddDependancies = false) 
        {
            AddThisAssemblyToTree(module, treeView);
            if (AddDependancies)
            {
                foreach(ModuleDefMD dependancy in dependancies) 
                {
                    AddThisAssemblyToTree(dependancy, treeView);
                }
            }
        }


        private static void AddThisAssemblyToTree(ModuleDefMD module, TreeView treeView) 
        {
            TreeNode root = new TreeNode(module.Assembly.Name, ResourceMap["Assembly"], ResourceMap["Assembly"]) { ForeColor = Color.FromArgb(219, 179, 126), Tag = module.Assembly };
            foreach (ModuleDef AssemblyModule in module.Assembly.Modules)
            {
                TreeNode moduleNode = new TreeNode(AssemblyModule.Name, ResourceMap["Module"], ResourceMap["Module"]) { ForeColor = Color.FromArgb(177, 127, 216), Tag = AssemblyModule };
                TreeNode[] namespaces = ListNamespaces(AssemblyModule);
                namespaces = namespaces.OrderBy(x => x.Text).ToArray();
                List<TypeDef> types = AssemblyModule.Types.ToList();
                types.Sort((x, y) => { return x.Name.CompareTo(y.Name); });
                foreach (TypeDef type in types)
                {
                    ProcessType(namespaces.Where(x => x.Text == type.Namespace.String).First(), type);
                }
                namespaces[0].Name = "-";
                foreach (TreeNode ns in namespaces)
                    moduleNode.Nodes.Add(ns);
                root.Nodes.Add(moduleNode);
            }
            treeView.Nodes.Add(root);
        }

        private static void ProcessType(TreeNode ParentNode,TypeDef type) 
        {
            if (type.HasGenericParameters || type.IsInterface || type.IsEnum || type.IsDelegate)
                return;
            TreeNode node = new TreeNode(type.Name) {Tag = type };
            if (type.IsNestedPrivate)
            {
                node.ImageIndex = ResourceMap["ClassPrivate"];
                node.SelectedImageIndex = ResourceMap["ClassPrivate"];
            }
            else if (type.IsNestedFamily) 
            {
                node.ImageIndex = ResourceMap["ClassProtected"];
                node.SelectedImageIndex = ResourceMap["ClassProtected"];
            }
            else if (type.Visibility == TypeAttributes.NotPublic || type.IsNestedAssembly || type.IsNestedFamilyAndAssembly || type.IsNestedFamilyOrAssembly) 
            {
                node.ImageIndex = ResourceMap["ClassFriend"];
                node.SelectedImageIndex = ResourceMap["ClassFriend"];
            }
            else 
            {
                node.ImageIndex = ResourceMap["Class"];
                node.SelectedImageIndex = ResourceMap["Class"];
            }
            if (type.IsAbstract)
                node.ForeColor = Color.FromArgb(55, 141, 108);
            else
                node.ForeColor = Color.FromArgb(78,201,176);
            
            foreach(MethodDef m in type.FindConstructors()) 
            {
                ProccessMethod(node, m);
            }
            List<MethodDef> methods = type.Methods.ToList();
            methods.Sort((x,y) => { return FormatMethod(x).CompareTo(FormatMethod(y)); });
            foreach(MethodDef method in methods) 
            {
                if(!(method.IsGetter || method.IsSetter) && !method.IsConstructor)
                ProccessMethod(node, method);
            }
            List<PropertyDef> properties = type.Properties.ToList();
            properties.Sort((x, y) => { return x.Name.CompareTo(y.Name); });
            foreach (PropertyDef property in properties)
            {
                ProccessProperty(node, property);
            }
            List<TypeDef> NestedTypes = type.NestedTypes.ToList();
            NestedTypes.Sort((x, y) => { return x.Name.CompareTo(y.Name); });
            foreach (TypeDef NestedType in NestedTypes)
            {
                ProcessType(node, NestedType);
            }
            ParentNode.Nodes.Add(node);
        }
        
        private static void ProccessProperty(TreeNode ParentNode,PropertyDef property) 
        {
            TreeNode node = new TreeNode(property.Name, ResourceMap["Property"], ResourceMap["Property"]) {Tag = property };
            node.ForeColor = Color.FromArgb(36,143,143);
            if (property.GetMethod != null)
                ProccessMethod(node, property.GetMethod);
            if(property.SetMethod != null)
                ProccessMethod(node, property.SetMethod);
            ParentNode.Nodes.Add(node);
        }

        private static void ProccessMethod(TreeNode ParentNode,MethodDef method) 
        {
            if (method.IsAbstract || method.HasGenericParameters)
                return;
            TreeNode node = new TreeNode(FormatMethod(method)) {Tag = method };
            if (method.IsInternalCall) 
            {
                node.ImageIndex = ResourceMap["MethodFriend"];
                node.SelectedImageIndex = ResourceMap["MethodFriend"];
            }
            else if (method.IsPrivate) 
            {
                node.ImageIndex = ResourceMap["MethodPrivate"];
                node.SelectedImageIndex = ResourceMap["MethodPrivate"];
            }
            else if (method.IsPublic) 
            {
                node.ImageIndex = ResourceMap["Method"];
                node.SelectedImageIndex = ResourceMap["Method"];
            }
            if (method.IsConstructor) 
            {
                node.ForeColor = ParentNode.ForeColor;
            }
            else 
            {
                node.ForeColor = Color.FromArgb(230,155,0);
            }
            ParentNode.Nodes.Add(node);
        }

        private static string FormatMethod(MethodDef method)
        {
            string name = (method.IsInstanceConstructor ? method.DeclaringType.Name : method.Name) + "(";
            List<string> parameters = new List<string>();
            List<Parameter> parameters1 = method.Parameters.ToList();
            if (method.HasThis) 
            {
                parameters1.RemoveAt(0);
            }
            foreach(Parameter param in parameters1) 
            {
                parameters.Add(param.Type.TypeName);
            }
            name += string.Join(",", parameters) + ") : " + method.ReturnType.TypeName;
            return name;
        }

        private static string FormatMethod(MemberRef method)
        {
            string name = (method.Name == ".ctor" ? method.DeclaringType.Name : method.Name) + "(";
            List<string> parameters = new List<string>();
            foreach (TypeSig param in method.MethodSig.GetParams())
            {
                parameters.Add(param.TypeName);
            }
            name += string.Join(",", parameters) + ") : " + method.ReturnType.TypeName;
            return name;
        }
    }
}

```

`ACEPatcher/packages.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="dnlib" version="3.5.0" targetFramework="net48" />
</packages>
```

`AceTest/AceTest.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{6699F677-F1B1-49EB-BB34-509714188027}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>AceTest</RootNamespace>
    <AssemblyName>AceTest</AssemblyName>
    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <Deterministic>true</Deterministic>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Class1.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>

```

`AceTest/Class1.cs`:

```cs
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Linq;
using System.Net;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading.Tasks;

namespace AceTest
{
    public class Program
	{
		
	}
}

```

`AceTest/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("AceTest")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("AceTest")]
[assembly: AssemblyCopyright("Copyright ©  2022")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("6699f677-f1b1-49eb-bb34-509714188027")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`README.md`:

```md
# ACEPatcher
A simple to use, gui based program for patching .NET assemblies

![ACE patcher](https://i.ibb.co/wCB6pvx/Ace-Patcher.png)

## Features

* Patches a wide range of methods(static methods, instance methods, constructors, getters, setters, etc.)
* Works on packed assemblies
* Works on a majority of obfuscators(including but not limited to:DnGuard,Eazfuscator,VMProtect,.NET reactor,Babel,Crypto Obfuscator and many more)
* Easy and intuative GUI
* Exports patches
* Exports patches with password
* Imports patches

## How to write patch methods

Firstly you have to analyze the target assembly and see which methods do you want to patch, once you found the methods you want to patch open a new visual studio c# project and write patch methods after you have written patch methods compile the assembly with Release build.

Patch method must be static and public.

If the target method is static, the signature of the patch method must match the signature of target method:

```cs
//Target method
private static bool TargetMethod(string text,byte[] array)
{
//...
}

//Patch method
public static bool PatchMethod(string something,byte[] somethingelse)
{
//...
}
```

If the target method is not static, patch method must return the same type, first argument of the patch method must be type target method belongs to and the rest of the arguments are copied from the target method:

```cs
//Target method
class A
{
  private int TargetMethod(string text)
  {
  //...
  }
}

//Patch method
public static int PatchMethod(A instance,string text)
{
//...
}
```

Within the patch method you can modify the return value of the TargetMethod:

```cs
//Target method
private static bool TargetMethod(string text)
{
//...
}

//Patch method
public static bool PatchMethod(string text)
{
  return true;
}
```

You can execute the original method by calling the patch method from within itself, the values of passed parameters will be ignored to change parameters modify the values of parameters passed to patch method:

```cs
//Target method
private static bool TargetMethod(string text)
{
//...
}

//Patch method
public static bool PatchMethod(string text)
{
  //This will change the text parameter in the original method
  text = "Something else";
  //This will return the execution to the original method
  return PatchMethod(text);
}
```

Or you could do both:

```cs
//Target method
private static bool TargetMethod(string text)
{
//...
}

//Patch method
public static bool PatchMethod(string text)
{
  if(text.Contains("Invalid password"))
    return true;
  else
    return PatchMethod(text);
}
```

If the method is not static you can also edit the values of fields and properties on the object associated with target method.

## How to patch assembly

Once you wrote the patch methods and compiled them into a .NET assembly open ACE patcher

Go to file -> open or click ctrl+o or drag n' drop target assembly onto ACE patcher.
Note: if you are loading in a packed assembly you must use 32 bit ACE patcher for 32 bit assembly and 64 bit ACE patcher for 64 bit assembly.
After the assembly is imported you will see it and it's dependancies in the 'Assembly Tree' panel, this panel has an interface similar to that of DnSpy.
Navigate to the methods you want to patch and double click them, if this is the first patch you are making the program will ask you to load the patch assembly.
A new window will appear that will list all the methods in the patch assembly, choose the one that patches the target method and then click on Add patch button.
Repeat that for all the methods you want to patch and after you've patched all the methods click on the apply patches button.
Then, in the result folder, move all of the files associated with the main assembly(resources ,configurations ,dll dependancies , misc files) and then click on Execute.bat to run patched version of the assembly.

## Export patch

Let's say you have 5 assemblies that use the same auth provider, it would be tedious to manually patch every single one, so that is why export functionality exists to use it first patch one of the assemblies manually then go to file -> Export or click ctrl+E and the patch will be saved as file then load in the seconds assembly go to file -> Import or clicl ctrl+I to import all of the patches, these exports can also be distributed.

ACE patcher also allows you to password protect patches to export password protected patch go to File -> Secure Export or click ctrl+shift+E, when you try to import password protected patch you will be asked to provide the password and you won't be able to load the patch without the correct password.

## Credits
* [dnlib](https://github.com/0xd4d/dnlib) - This is used for .net assembly manipulation
* [Harmony](https://github.com/pardeike/Harmony)  - This is used for patching the assemblies
* [JitFreezer](https://github.com/okieeee/JIT-Freezer) - This is used to deal with anti-dump when loading packed files
* [DarkUI](https://github.com/RobinPerris/DarkUI) - This is used for the dark theme

```