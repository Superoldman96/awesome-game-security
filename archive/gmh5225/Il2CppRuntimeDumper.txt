Project Path: arc_gmh5225_Il2CppRuntimeDumper_f2jbd773

Source Tree:

```txt
arc_gmh5225_Il2CppRuntimeDumper_f2jbd773
├── Il2CppRuntime
│   ├── Dumper
│   │   ├── Dumper.cs
│   │   └── Il2Cpp
│   │       ├── Il2Cpp.cs
│   │       ├── Il2CppAssembly.cs
│   │       ├── Il2CppBase.cs
│   │       ├── Il2CppClass.cs
│   │       ├── Il2CppDummyDll.cs
│   │       ├── Il2CppField.cs
│   │       ├── Il2CppGenericContainer.cs
│   │       ├── Il2CppMethod.cs
│   │       ├── Il2CppObject.cs
│   │       ├── Il2CppProperty.cs
│   │       └── Il2CppType.cs
│   ├── FodyWeavers.xml
│   ├── FodyWeavers.xsd
│   ├── Il2CppRuntime.csproj
│   ├── NativeNetSharp.cs
│   ├── Program.cs
│   ├── Properties
│   │   └── AssemblyInfo.cs
│   └── packages.config
├── Il2CppRuntimeDumper.sln
├── LICENSE
└── README.md

```

`Il2CppRuntime/Dumper/Dumper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Mono;
using Mono.Cecil;
using System.IO;
using System.Runtime.InteropServices;

namespace Il2CppRuntime.Il2Cpp
{
    public unsafe static class Dumper
    {
        public static void Dump()
        {
            Directory.CreateDirectory("DummyDlls");
            var il2CppDummyDll = Il2CppDummyDll.Create();
            var addressAttribute = il2CppDummyDll.MainModule.Types.First(x => x.Name == "AddressAttribute").Methods[0];
            FieldOffsetAttribute = il2CppDummyDll.MainModule.Types.First(x => x.Name == "FieldOffsetAttribute").Methods[0];
            var attributeAttribute = il2CppDummyDll.MainModule.Types.First(x => x.Name == "AttributeAttribute").Methods[0];
            var metadataOffsetAttribute = il2CppDummyDll.MainModule.Types.First(x => x.Name == "MetadataOffsetAttribute").Methods[0];
            var tokenAttribute = il2CppDummyDll.MainModule.Types.First(x => x.Name == "TokenAttribute").Methods[0];
            StringReference = il2CppDummyDll.MainModule.TypeSystem.String;

            var resolver = new AssemblyResolver();
            var moduleParameters = new ModuleParameters { Kind = ModuleKind.Dll, AssemblyResolver = resolver };
            resolver.Register(il2CppDummyDll);
            var assemblyDefs = new Dictionary<IntPtr, AssemblyDefinition>();
            foreach (var assembly in Il2Cpp.Assemblies)
            {
                var assemblyDefinition = AssemblyDefinition.CreateAssembly(new AssemblyNameDefinition(assembly.Value.Name.Replace(".dll", ""), new Version("4.0.0.0")), assembly.Value.Name, moduleParameters);
                resolver.Register(assemblyDefinition);

                var moduleDefinition = assemblyDefinition.MainModule;
                moduleDefinition.Types.Clear();
                //if (assembly.Value.Name == "System.dll") moduleDefinition.Types.Add(new TypeDefinition("System", "String", Mono.Cecil.TypeAttributes.Public));

                var cachedClasses = Il2CppClass.CachedClasses.Where(cl => cl.Value.Image == assembly.Key).Select(cl => cl.Value);
                var baseClasses = cachedClasses.Where(cl => cl.DeclaringTypePtr == IntPtr.Zero);
                var declaredClasses = cachedClasses.Where(cl => cl.DeclaringTypePtr != IntPtr.Zero);
                //foreach (var c in baseClasses)
                foreach (var c in assembly.Value.Classes.Where(cl => cl.DeclaringTypePtr == IntPtr.Zero))
                //foreach (var ckvp in Il2CppClass.CachedClasses.Where(cl=>cl.Value.Image == assembly.Key &&  cl.DeclaringTypePtr == IntPtr.Zero).Select(cl => cl.Value))
                {
                    var typeDefinition = new TypeDefinition(c.Namespace, c.Name, c.Flags);
                    //Console.WriteLine("init : " + c.Namespace + " : " + c.Name);
                    //if (c.Name == "<>f__AnonymousType0`1") continue;
                    //if (c.Name.Contains("$ArrayType$")) continue;
                    typeDict.Add(c.Type.Ptr, typeDefinition);
                    foreach (var t in c.NestedTypePtrs)
                    {
                        if (typeDict.ContainsKey(t)) continue;
                        var nestedClass = Il2CppClass.Generate(t);
                        var nestedTypeDef = new TypeDefinition(nestedClass.Namespace, nestedClass.Name, nestedClass.Flags);
                        typeDefinition.NestedTypes.Add(nestedTypeDef);
                        typeDict.Add(t, nestedTypeDef);
                    }
                    moduleDefinition.Types.Add(typeDefinition);
                }
                //foreach (var c in declaredClasses)
                foreach (var c in assembly.Value.Classes.Where(cl => cl.DeclaringTypePtr != IntPtr.Zero))
                //    foreach (var c in assembly.Value.Classes.Where(cl => cl.DeclaringTypePtr != IntPtr.Zero))
                //foreach(var c in assembly.Value.Classes)
                //foreach (var ckvp in Il2CppClass.CachedClasses.Where(cl=>cl.Value.Image == assembly.Key))
                {
                    var typeDefinition = new TypeDefinition(c.Namespace, c.Name, c.Flags);
                    typeDict.Add(c.Type.Ptr, typeDefinition);
                    foreach (var t in c.NestedTypePtrs)
                    {
                        if (typeDict.ContainsKey(t)) continue;
                        var nestedClass = Il2CppClass.Generate(t);
                        var nestedTypeDef = new TypeDefinition(nestedClass.Namespace, nestedClass.Name, nestedClass.Flags);
                        typeDefinition.NestedTypes.Add(nestedTypeDef);
                        typeDict.Add(t, nestedTypeDef);
                    }
                    typeDict[c.DeclaringType.Type.Ptr].NestedTypes.Add(typeDefinition);
                }
                assemblyDefs.Add(assembly.Value.Ptr, assemblyDefinition);
            }
            foreach (var assembly in Il2Cpp.Assemblies)
            {
                var assemblyDefinition = assemblyDefs[assembly.Value.Ptr];
                var moduleDefinition = assemblyDefinition.MainModule;
                //foreach (var c in Il2CppClass.CachedClasses.Where(cl => cl.Value.Image == assembly.Key).Select(cl => cl.Value))
                foreach (var c in assembly.Value.Classes)
                {
                    DumpClass(c, moduleDefinition);
                }
                Console.WriteLine("saving " + assembly.Value.Name);
                assemblyDefinition.Write(@"DummyDlls\" + assembly.Value.Name);
            }
            //File.WriteAllText(@"methodLocs.txt", MethodLocs.ToString());
            Console.WriteLine("dumped");
        }
        public class AssemblyResolver : DefaultAssemblyResolver
        {
            public void Register(AssemblyDefinition assembly)
            {
                RegisterAssembly(assembly);
            }
        }

        public static Dictionary<Int32, GenericParameter> genericParameters = new Dictionary<Int32, GenericParameter>();
        public static GenericParameter CreateGenericParameter(Int32 genericParameterIndex, IGenericParameterProvider iGenericParameterProvider)
        {
            if (!genericParameters.TryGetValue(genericParameterIndex, out var genericParameter))
            {
                genericParameter = new GenericParameter("T", iGenericParameterProvider);
                //genericParameter.Attributes = (Mono.Cecil.GenericParameterAttributes)Mono.Cecil.GenericParameterAttributes.NonVariant;
                genericParameters.Add(genericParameterIndex, genericParameter);
                //for (int i = 0; i < param.constraintsCount; ++i)
                {
                    //var il2CppType = il2Cpp.types[metadata.constraintIndices[param.constraintsStart + i]];
                    // genericParameter.Constraints.Add(new GenericParameterConstraint(GetTypeReference((MemberReference)iGenericParameterProvider, il2CppType)));
                }
            }
            else
            {
                //Console.WriteLine("getting 2nd : " + genericParameterIndex);
            }
            return genericParameter;
        }
        public static Dictionary<IntPtr, MethodDefinition> methodDefs = new Dictionary<IntPtr, MethodDefinition>();
        static StringBuilder MethodLocs = new StringBuilder();
        static List<String> MethodLocsAdded = new List<String>();
        static StringBuilder ClassLocs = new StringBuilder();
        static IntPtr BaseAddr = IntPtr.Zero;
        public static MethodDefinition DumpMethod(Il2CppMethod m, TypeDefinition typeDefinition, Boolean dump)
        {
            //var methodDefinition = new MethodDefinition(m.Name, m.Flags, moduleDefinition.ImportReference(m.ReturnType.ByRef ? (TypeReference)new ByReferenceType(typeDict[m.ReturnClass.Ptr]) : typeDict[m.ReturnClass.Ptr]));
            var methodDefinition = new MethodDefinition(m.Name, m.Flags, typeDefinition.Module.ImportReference(typeof(void)));
            methodDefinition.ImplAttributes = m.ImplFlags;
            typeDefinition.Methods.Add(methodDefinition);
            /*var line = typeDefinition.Namespace + "." + typeDefinition.Name + "." + m.Name;
            var mName = line.Replace(".", "_").Replace(" ", "_");
            MethodLocsAdded.Add(mName);
            var count = MethodLocsAdded.Count(l => l == mName);
            if (count > 1) mName += "_" + (count);
            line = mName + " " + ((UInt64)(*(IntPtr*)m.Ptr) - (UInt64)BaseAddr).ToString("X");
            MethodLocs.AppendLine(line);*/
            //Console.WriteLine("fin");
            //var methodDefinition = new MethodDefinition(m.Name, m.Flags, moduleDefinition.ImportReference(typeDict[m.ReturnClassPtr]));
            //var methodDefinition = new MethodDefinition(m.Name, m.Flags, moduleDefinition.ImportReference(typeDict.First().Value));
            //methodDefinition.DeclaringType = typeDefinition;
            // if (methodDefinition.ReturnType.Name.StartsWith("!!"))
            if (m.IsGeneric)
            {
                //Console.WriteLine(typeDefinition.Name + " : " + typeDefinition.Namespace + " : " + m.Name + " : " + m.Ptr.ToString("X") + " : " + m.GenericContainer.Count + " : " + m.GenericContainer.ParamStart);
                for (var i = 0; i < m.GenericContainer.Count; i++)
                {
                    var genericParameter = CreateGenericParameter(m.GenericContainer.ParamStart + i, methodDefinition);
                    methodDefinition.GenericParameters.Add(genericParameter);
                }
                // if (m.Name == "Instantiate" && m.Parameters.Count == 2)
            }
            methodDefinition.ReturnType = GetTypeReferenceWithByRef(methodDefinition, m.ReturnClass.Type);
            foreach (var p in m.Parameters)
            {
                var pType = Il2CppType.GenerateType(p.Class.Type.Ptr);
                var pType2 = Il2CppType.GenerateType(p.Ptr);
                //Console.WriteLine(typeDefinition.Namespace + " : " + typeDefinition.Name + " : " + m.Name + " | " + p.Name + " : " + p.Class.Type.Name + " : " + p.Class.Type.Type + " : " + pType.Name + " : " + pType2.Name + " : " + pType2.Type);
                methodDefinition.Parameters.Add(new ParameterDefinition(p.Name, (Mono.Cecil.ParameterAttributes)pType.Attributes, GetTypeReferenceWithByRef(methodDefinition, p.Class.Type)));
                //Console.WriteLine("done");
                // methodDefinition.Parameters.Add(new ParameterDefinition(p.Name, Mono.Cecil.ParameterAttributes.None, GetTypeReferenceWithByRef(methodDefinition, pType2)));
                continue;
                //Console.WriteLine(typeDefinition.Name + " : " + typeDefinition.Namespace + " : " + m.Name + " : " + p.Name + " : " + m.Ptr.ToString("X"));

                //Console.WriteLine(p.Name + " : " + p.Class.Name);
                // var pType = Il2CppType.GenerateType(p.Class.Type.Ptr);
                var c = typeDict.Count(t => (t.Value.Namespace + "." + t.Value.Name) == pType.Name);
                if (c > 0) methodDefinition.Parameters.Add(new ParameterDefinition(p.Name, Mono.Cecil.ParameterAttributes.None, new ByReferenceType(typeDict.First(t => (t.Value.Namespace + "." + t.Value.Name) == pType.Name).Value)));
                else
                {
                    Console.WriteLine(typeDefinition.Namespace + " : " + typeDefinition.Name + " : " + m.Name + " : " + p.Name + " : " + pType.Name + " : " + pType.Type + " : " + c);
                    if (!typeDict.ContainsKey(pType.Ptr) && (pType.Type == Il2CppTypeEnum.IL2CPP_TYPE_CLASS || pType.Type == Il2CppTypeEnum.IL2CPP_TYPE_VALUETYPE))
                    {
                        //Console.WriteLine(typeDefinition.Namespace + " : " + typeDefinition.Name + " : " + m.Name + " : " + p.Name + " : " + pType.Name + " : " + pType.Type);
                        // methodDefinition.Parameters.Add(new ParameterDefinition(p.Name, Mono.Cecil.ParameterAttributes.None, typeDefinition.Module.ImportReference(typeof(Single))));
                    }
                    if (!typeDict.ContainsKey(pType.Ptr))
                    {
                        Console.WriteLine(typeDefinition.Namespace + " : " + typeDefinition.Name + " : " + m.Name + " : " + p.Name + " : " + pType.Name + " : " + pType.Type);
                        // methodDefinition.Parameters.Add(new ParameterDefinition(p.Name, Mono.Cecil.ParameterAttributes.None, typeDefinition.Module.ImportReference(typeof(Single))));
                    }
                    //else
                    // Console.WriteLine(p.Name + " : " + p.Class.Type.Name + " : " + (Mono.Cecil.ParameterAttributes)p.Class.Type.Attributes + " : " + pType.Name + " : " + (Mono.Cecil.ParameterAttributes)pType.Attributes);
                    //methodDefinition.Parameters.Add(new ParameterDefinition(p.Name, (Mono.Cecil.ParameterAttributes)pType.Attributes, GetTypeReferenceWithByRef(methodDefinition, p.Class.Type)));
                    //methodDefinition.Parameters.Add(new ParameterDefinition(p.Name, Mono.Cecil.ParameterAttributes.None, GetTypeReferenceWithByRef(methodDefinition, p.Class.Type)));
                    //methodDefinition.Parameters.Add(new ParameterDefinition(p.Name, Mono.Cecil.ParameterAttributes.None, GetTypeReferenceWithByRef(methodDefinition, pType)));
                    methodDefinition.Parameters.Add(new ParameterDefinition(pType.Name + "_" + p.Name, Mono.Cecil.ParameterAttributes.None, typeDefinition.Module.ImportReference(typeof(Single))));
                }
                if (pType.Name.EndsWith("&"))
                {
                    // var newPType = typeDict.First(t => t.Value.Name == pType.Name.Replace("&", "")).Value;
                    // methodDefinition.Parameters.Add(new ParameterDefinition(p.Name, Mono.Cecil.ParameterAttributes.None, newPType));
                }

            }//if (methodDefinition.HasBody && dump) InitMethodBody(methodDefinition, typeDict[m.ReturnClass.Ptr]);
            methodDefs.Add(m.Ptr, methodDefinition);
            return methodDefinition;
        }
        public static void DumpClass(Il2CppClass c, ModuleDefinition moduleDefinition)
        {
            if (c.Name == "<>f__AnonymousType0`1") return;
            if (c.Name.Contains("$ArrayType$")) return;
            var typeDefinition = typeDict[c.Type.Ptr];
            if (c.BaseClassPtr != IntPtr.Zero)
            {
                //var newBase = typeDict.First(t => t.Value.Name == c.BaseClass.Name && t.Value.Namespace == c.BaseClass.Namespace);
                typeDefinition.BaseType = GetTypeReference(typeDefinition, c.BaseClass.Type);
                //Console.WriteLine(c.Namespace + " :: " + c.Name + " : " + " : " + c.BaseClass.Type.Name);
            }
            if (c.GenericIndex != Int32.MaxValue)
            {
                var genericContainer = Il2CppGenericContainer.Generics[c.GenericIndex];
                //Console.WriteLine("dump class generic : " + c.Namespace + " :: " + c.Name + " : " + " : " + genericContainer.Count + " : " + genericContainer.ParamStart);
                for (var i = 0; i < genericContainer.Count; i++)
                    typeDefinition.GenericParameters.Add(CreateGenericParameter(genericContainer.ParamStart + i, typeDefinition));
            }
            //if (c.DeclaringTypePtr != IntPtr.Zero) typeDefinition.DeclaringType = typeDict[c.DeclaringTypePtr];
            foreach (var f in c.Fields)
            {
                if (c.Name == "ILFixDynamicMethodWrapper" && f.Name.Contains("Gen")) continue;
                //if (c.Name.Contains("TestReporter"))
                //    Console.WriteLine("ptr : " + c.Namespace + " :: " + c.Name + " . " + f.Name + " : " + f.Ptr.ToString("X"));
                var field = new FieldDefinition(f.Name, f.Flags, GetTypeReference(typeDefinition, f.Class.Type));
                if (typeDefinition.IsEnum && field.IsStatic)
                {
                    int result = 0;
                    Il2Cpp.il2cpp_field_static_get_value(f.Ptr, (void*)(&result));
                    //Il2Cpp.Il2Cpp.il2cpp_field_get_value(IntPtr.Zero, f.Ptr, (void*)(&result));
                    //field.Constant = result;
                }
                if (!field.IsLiteral)
                {
                    if (f.Offset >= 0)
                    {
                        var customAttribute = new CustomAttribute(typeDefinition.Module.ImportReference(FieldOffsetAttribute));
                        if (c.Name == "RuntimeTypeHandle" && f.Name == "value") f.Offset = 0;
                        var offset = new Mono.Cecil.CustomAttributeNamedArgument("Offset", new CustomAttributeArgument(StringReference, $"0x{f.Offset:X}"));
                        customAttribute.Fields.Add(offset);
                        field.CustomAttributes.Add(customAttribute);
                    }
                }
                typeDefinition.Fields.Add(field);
            }
            foreach (var m in c.Methods)
            {
                if (c.Name == "ILFixDynamicMethodWrapper" && m.Name.Contains("Gen")) continue;
                var methodDefinition = DumpMethod(m, typeDefinition, typeDefinition.BaseType?.FullName != "System.MulticastDelegate");
            }
            foreach (var p in c.Properties)
            {
                //Console.WriteLine(c.Name + " : " +p.Name);
                var propDefinition = new PropertyDefinition(p.Name, p.Flags, GetTypeReferenceWithByRef(typeDefinition, p.Class.Type));
                if (p.getMethod != null) propDefinition.GetMethod = methodDefs[p.getMethod.Ptr];
                if (p.setMethod != null) propDefinition.SetMethod = methodDefs[p.setMethod.Ptr];
                typeDefinition.Properties.Add(propDefinition);
            }
            foreach (var i in c.InterfacePtrs)
            {
                var inter = Il2CppClass.Generate(i);
                var interfaceTypeRef = GetTypeReference(typeDefinition, inter.Type);
                typeDefinition.Interfaces.Add(new InterfaceImplementation(interfaceTypeRef));
                //var nestedClass = Il2CppClass.Generate(t);
                //DumpClass(nestedClass, moduleDefinition);
            }
            foreach (var t in c.NestedTypePtrs)
            {
                //var nestedClass = Il2CppClass.Generate(t);
                //DumpClass(nestedClass, moduleDefinition);
            }
        }
        public static void DumpStrings()
        {
            //var dataOffset = BaseAddr + 0x5D94000;
            var dataOffset = 0x27300000000u;// BaseAddr + 0x6141400;
            var size = 0x00080000000u;
            var offset = 0u;
            var added = new List<String>();
            //while(offset < 0x3AA400)
            //while(offset < 0x5E08FF)
            while (offset < (dataOffset + size))
            {
                try
                {
                    var ptr = *(UInt64*)(dataOffset + offset);
                    //if (Il2CppClass.CachedClasses.ContainsKey(ptr))
                    if (ptr > dataOffset && ptr < dataOffset + size)
                    {
                        //Console.WriteLine("p : " + ptr.ToString("X"));
                        var namePtr = *(UInt64*)(ptr + 2 * 8);
                        var nameSpacePtr = *(UInt64*)(ptr + 3 * 8);
                        var selfPtr = *(UInt64*)(ptr + 6 * 8);
                        //Console.WriteLine(namePtr.ToString("X"));
                        //Console.WriteLine(nameSpacePtr.ToString("X"));
                        //Console.WriteLine(selfPtr.ToString("X"));
                        if (namePtr > dataOffset && namePtr < dataOffset && nameSpacePtr > dataOffset + size && nameSpacePtr < dataOffset + size && selfPtr == ptr)
                        {
                            var cName = Marshal.PtrToStringAnsi((IntPtr)namePtr);
                            var cNamespace = Marshal.PtrToStringAnsi((IntPtr)nameSpacePtr);
                            var line = cNamespace + "_" + cName;
                            //if (c.Name == "Enumerator") line = c.DeclaringType.Name + "Enumerator";
                            line = line.Replace(".", "_").Replace("*", "Ptr").Replace(" ", "").Replace("`", "").Replace("<", "").Replace(">", "").Replace("[", "Arr").Replace("]", "").Replace(",", "");
                            added.Add(line);
                            var count = added.Count(l => l == line);

                            if (count > 1) line += "_" + (count);
                            ClassLocs.AppendLine(line + " " + ((UInt64)(dataOffset + offset) - (UInt64)BaseAddr).ToString("X"));
                        }
                    }
                }
                catch { }
                offset += 8;
            }
            File.WriteAllText(@"classLocs.txt", ClassLocs.ToString());
        }
        //public static GameObject BaseObject;
        public static Dictionary<IntPtr, TypeDefinition> typeDict = new Dictionary<IntPtr, TypeDefinition>();
        static MethodDefinition FieldOffsetAttribute;
        static TypeReference StringReference;

        public static TypeReference GetTypeReferenceWithByRef(MemberReference memberRef, Il2CppType il2CppType)
        {
            var typeReference = GetTypeReference(memberRef, il2CppType);
            return il2CppType.ByRef ? new ByReferenceType(typeReference) : typeReference;
        }
        public static TypeReference GetTypeReference(MemberReference memberRef, Il2CppType il2CppType)
        {
            var moduleDefinition = memberRef.Module;
            var il2CppClass = il2CppType.GetClass();
            //if (loggin)
            //Console.WriteLine("GetTypeReference : " + il2CppClass.Namespace + " : " + il2CppClass.Name + " : " + il2CppType.Type + " : " + il2CppClass.Ptr.ToString("X") + " : " + il2CppType.Ptr.ToString("X") + " : " + moduleDefinition);
            // Console.WriteLine("GetTypeReference : " + il2CppType.Type + " : " + il2CppType.Name);
            //
            switch (il2CppType.Type)
            {
                case Il2CppTypeEnum.IL2CPP_TYPE_OBJECT:
                    return moduleDefinition.ImportReference(typeof(object));
                case Il2CppTypeEnum.IL2CPP_TYPE_VOID:
                    return moduleDefinition.ImportReference(typeof(void));
                case Il2CppTypeEnum.IL2CPP_TYPE_BOOLEAN:
                    return moduleDefinition.ImportReference(typeof(bool));
                case Il2CppTypeEnum.IL2CPP_TYPE_CHAR:
                    return moduleDefinition.ImportReference(typeof(char));
                case Il2CppTypeEnum.IL2CPP_TYPE_I1:
                    return moduleDefinition.ImportReference(typeof(sbyte));
                case Il2CppTypeEnum.IL2CPP_TYPE_U1:
                    return moduleDefinition.ImportReference(typeof(byte));
                case Il2CppTypeEnum.IL2CPP_TYPE_I2:
                    return moduleDefinition.ImportReference(typeof(short));
                case Il2CppTypeEnum.IL2CPP_TYPE_U2:
                    return moduleDefinition.ImportReference(typeof(ushort));
                case Il2CppTypeEnum.IL2CPP_TYPE_I4:
                    return moduleDefinition.ImportReference(typeof(int));
                case Il2CppTypeEnum.IL2CPP_TYPE_U4:
                    return moduleDefinition.ImportReference(typeof(uint));
                case Il2CppTypeEnum.IL2CPP_TYPE_I:
                    return moduleDefinition.ImportReference(typeof(IntPtr));
                case Il2CppTypeEnum.IL2CPP_TYPE_U:
                    return moduleDefinition.ImportReference(typeof(UIntPtr));
                case Il2CppTypeEnum.IL2CPP_TYPE_I8:
                    return moduleDefinition.ImportReference(typeof(long));
                case Il2CppTypeEnum.IL2CPP_TYPE_U8:
                    return moduleDefinition.ImportReference(typeof(ulong));
                case Il2CppTypeEnum.IL2CPP_TYPE_R4:
                    return moduleDefinition.ImportReference(typeof(float));
                case Il2CppTypeEnum.IL2CPP_TYPE_R8:
                    return moduleDefinition.ImportReference(typeof(double));
                case Il2CppTypeEnum.IL2CPP_TYPE_STRING:
                    return moduleDefinition.ImportReference(typeof(string));
                case Il2CppTypeEnum.IL2CPP_TYPE_TYPEDBYREF:
                    return moduleDefinition.ImportReference(typeof(TypedReference));
                case Il2CppTypeEnum.IL2CPP_TYPE_CLASS:
                case Il2CppTypeEnum.IL2CPP_TYPE_VALUETYPE:
                    {
                        return moduleDefinition.ImportReference(typeDict[il2CppType.Ptr]);
                    }
                case Il2CppTypeEnum.IL2CPP_TYPE_ARRAY:
                    {
                        var etype = *(IntPtr*)((*(IntPtr*)il2CppType.Ptr) + 0);
                        var rank = *(Byte*)((*(IntPtr*)il2CppType.Ptr) + 8);
                        return new ArrayType(GetTypeReference(memberRef, Il2CppType.GenerateType(etype)), rank);
                    }
                case Il2CppTypeEnum.IL2CPP_TYPE_GENERICINST:
                    {
                        //var genericClass = il2CppType.PtrVal;
                        // var il2CppClass = il2CppType.GetClass();
                        var newBase = typeDict.First(t => t.Value.Name == il2CppClass.Name && t.Value.Namespace == il2CppClass.Namespace);
                        var genericInstanceType = new GenericInstanceType(moduleDefinition.ImportReference(newBase.Value));
                        var genClass = *(IntPtr*)il2CppType.Ptr;
                        var genClassInst = *(IntPtr*)(genClass + 8);
                        var argc = *(IntPtr*)genClassInst;
                        var argv = *(IntPtr*)(genClassInst + 8);
                        //Console.WriteLine(il2CppType.Name + " : " + argv.ToString("X") + " : " + argc);
                        for (var i = 0; i < (Int64)argc; i++)
                        {
                            var argTypeTemp = Il2CppType.GenerateType(*(IntPtr*)(argv + i * 8));
                            var argClass = argTypeTemp.GetClass();
                            genericInstanceType.GenericArguments.Add(GetTypeReference(memberRef, argClass.Type));
                        }
                        //var genericContainer = Il2CppGenericContainer.Generics[*(Int32*)il2CppType.Ptr];
                        //var pointers = il2Cpp.MapVATR<ulong>(genericInst.type_argv, genericInst.type_argc);
                        //foreach (var pointer in genericContainer.) genericInstanceType.GenericArguments.Add(GetTypeReference(memberReference, oriType));
                        return genericInstanceType;
                    }
                case Il2CppTypeEnum.IL2CPP_TYPE_SZARRAY:
                    {
                        var il2CppTypeInner = new Il2CppType(*(IntPtr*)il2CppType.Ptr);
                        //Console.WriteLine(il2CppTypeInner.Name);
                        return new ArrayType(GetTypeReference(memberRef, il2CppTypeInner));
                    }
                case Il2CppTypeEnum.IL2CPP_TYPE_VAR:
                    {
                        //Console.WriteLine("fail IL2CPP_TYPE_VAR");
                        //Console.WriteLine("GetTypeReference : " + il2CppClass.Namespace + " : " + il2CppClass.Name + " : " + il2CppType.Type + " : " + il2CppClass.Ptr.ToString("X") + " : " + il2CppType.Ptr.ToString("X") + " : " + (*(Int32*)il2CppType.Ptr).ToString("X"));
                        var q = CreateGenericParameter(*(Int32*)il2CppType.Ptr, memberRef is MethodDefinition ? ((MethodDefinition)memberRef).DeclaringType : (TypeDefinition)memberRef);
                        return CreateGenericParameter(*(Int32*)il2CppType.Ptr, memberRef is MethodDefinition ? ((MethodDefinition)memberRef).DeclaringType : (TypeDefinition)memberRef);
                    }
                case Il2CppTypeEnum.IL2CPP_TYPE_MVAR:
                    {
                        return CreateGenericParameter(*(Int32*)il2CppType.Ptr, (MethodDefinition)memberRef);
                    }
                case Il2CppTypeEnum.IL2CPP_TYPE_PTR:
                    {
                        //return moduleDefinition.ImportReference(typeof(Single));
                        var newBase = typeDict.First(t => t.Value.Name == il2CppClass.Name.Replace("*", "") && t.Value.Namespace == il2CppClass.Namespace);
                        //Console.WriteLine("fail IL2CPP_TYPE_PTR" + " : " + il2CppType.Ptr.ToString("X"));
                        return new PointerType(moduleDefinition.ImportReference(newBase.Value));
                    }
                default:
                    {
                        Console.WriteLine("fail def : " + il2CppType.Type);
                        return moduleDefinition.ImportReference(typeof(Single));
                        //var methodDefinition = (MethodDefinition)memberReference;
                        //return CreateGenericParameter(executor.GetGenericParameteFromIl2CppType(il2CppType), methodDefinition);
                        //return moduleDefinition.ImportReference(typeDict[il2CppClass.Ptr]);
                    }
            }
        }
    }
}

```

`Il2CppRuntime/Dumper/Il2Cpp/Il2Cpp.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Runtime.InteropServices;

namespace Il2CppRuntime.Il2Cpp
{
    public unsafe static class Il2Cpp
    {
        //public const String UnityDllName = "UserAssembly";
        public const String UnityDllName = "GameAssembly";
        public static IntPtr Domain = IntPtr.Zero;
        public static IntPtr corlib = IntPtr.Zero;
        public static IntPtr ContainersPtrGuess = IntPtr.Zero;
        public static IntPtr AssemblyGetTypesPtr = IntPtr.Zero;
        public static Dictionary<IntPtr, Il2CppAssembly> Assemblies = new Dictionary<IntPtr, Il2CppAssembly>();
        public static void InitAssemblies()
        {
            Domain = il2cpp_domain_get();
            //il2cpp_thread_attach(Domain);
            corlib = il2cpp_get_corlib();
            IntPtr* param = null;
            var returnedException = IntPtr.Zero;
            var ac = il2cpp_class_from_name(corlib, "System", "AppDomain");
            Console.WriteLine(ac.ToString("X"));
            var getAssemblies = il2cpp_class_get_method_from_name(ac, "GetAssemblies", 0);
            var getCurDomain = il2cpp_class_get_method_from_name(ac, "getCurDomain", 0);
            var currentDomain = il2cpp_runtime_invoke(getCurDomain, IntPtr.Zero, (void**)param, ref returnedException);
            var gotAssemblies = il2cpp_runtime_invoke(getAssemblies, currentDomain, (void**)param, ref returnedException);

            var size = 0u;
            var assemblies = il2cpp_domain_get_assemblies(Domain, ref size);

            var assemblyClass = Il2Cpp.il2cpp_class_from_name(corlib, "System.Reflection", "Assembly");
            var assemblyLoad = Il2Cpp.il2cpp_class_get_method_from_name(assemblyClass, "Load", 1);
            AssemblyGetTypesPtr = Il2Cpp.il2cpp_class_get_method_from_name(assemblyClass, "GetTypes", 0);
            for (var i = 0u; i < size; i++)
            {
                var image = il2cpp_assembly_get_image(assemblies[i]);
                var dll = Marshal.PtrToStringAnsi(il2cpp_image_get_name(image));
                var assembly = *(IntPtr*)((UInt64)gotAssemblies + 32 + i * 8);
                Assemblies.Add(image, new Il2CppAssembly(assembly, assemblies[i]));
            }
            while (Il2CppClass.ClassesToAdd.Count > 0)
            {
                var toAdd = Il2CppClass.ClassesToAdd.ToList();
                Il2CppClass.ClassesToAdd.Clear();
                foreach (var c in toAdd) Il2CppClass.Generate(c);
            }
            if (ContainersPtrGuess != IntPtr.Zero)
            {
                var prevContainer = new Il2CppGenericContainer(ContainersPtrGuess);
                Il2CppGenericContainer.Generics.Add(prevContainer);
                var containerOffset = ContainersPtrGuess + 0x10;
                while (true)
                {
                    var container = new Il2CppGenericContainer(containerOffset);
                    containerOffset += 0x10;
                    if (container.IsMethod >= 2) break;
                    if (container.ParamStart != prevContainer.ParamStart + prevContainer.Count) break;
                    Il2CppGenericContainer.Generics.Add(container);
                    prevContainer = container;
                }
            }
            // Console.WriteLine("generics : " + Il2CppGenericContainer.Generics.Count.ToString("X"));
        }
        public static Dictionary<String, IntPtr> CachedAssemblies = new Dictionary<String, IntPtr>();
        public static IntPtr GetImage(String dllName)
        {
            if (CachedAssemblies.ContainsKey(dllName)) return CachedAssemblies[dllName];
            var domain = il2cpp_domain_get();
            var size = 0u;
            var assemblies = il2cpp_domain_get_assemblies(domain, ref size);
            for (var i = 0u; i < size; i++)
            {
                var image = il2cpp_assembly_get_image(assemblies[i]);
                var dll = Marshal.PtrToStringAnsi(il2cpp_image_get_name(image));
                if (dll == dllName)
                {
                    CachedAssemblies.Add(dllName, image);
                    return image;
                }

            }
            return IntPtr.Zero;
        }
        public static Dictionary<String, IntPtr> CachedMethod = new Dictionary<String, IntPtr>();
        public static IntPtr GetIl2CppMethod(IntPtr clazz, string methodName)
        {
            var cacheName = clazz.ToString("X") + "," + methodName;
            if (CachedMethod.ContainsKey(cacheName)) return CachedMethod[cacheName];
            var iter = IntPtr.Zero;
            IntPtr method;
            while ((method = il2cpp_class_get_methods(clazz, ref iter)) != IntPtr.Zero)
            {
                if (Marshal.PtrToStringAnsi(il2cpp_method_get_name(method)) != methodName) continue;
                CachedMethod.Add(cacheName, method);
                return method;
            }
            CachedMethod.Add(cacheName, IntPtr.Zero);
            //Console.WriteLine("throw exception");
            return IntPtr.Zero;
        }
        public static IntPtr GetIl2CppMethod(IntPtr clazz, bool isGeneric, string methodName, string returnTypeName, params string[] argTypes)
        {
            var cacheName = clazz.ToString("X") + "," + methodName + "," + returnTypeName + String.Join(",", argTypes);
            if (CachedMethod.ContainsKey(cacheName)) return CachedMethod[cacheName];
            var methodsSeen = 0;
            var lastMethod = IntPtr.Zero;
            var iter = IntPtr.Zero;
            IntPtr method;
            while ((method = il2cpp_class_get_methods(clazz, ref iter)) != IntPtr.Zero)
            {
                if (Marshal.PtrToStringAnsi(il2cpp_method_get_name(method)) != methodName) continue;
                if (il2cpp_method_get_param_count(method) != argTypes.Length) continue;
                if (il2cpp_method_is_generic(method) != isGeneric) continue;
                var returnType = il2cpp_method_get_return_type(method);
                var returnTypeNameActual = Marshal.PtrToStringAnsi(il2cpp_type_get_name(returnType));
                if (returnTypeNameActual != returnTypeName) continue;
                methodsSeen++;
                lastMethod = method;
                var badType = false;
                for (var i = 0; i < argTypes.Length; i++)
                {
                    var paramType = il2cpp_method_get_param(method, (uint)i);
                    var typeName = Marshal.PtrToStringAnsi(il2cpp_type_get_name(paramType));
                    if (typeName != argTypes[i])
                    {
                        badType = true;
                        break;
                    }
                }
                if (badType) continue;
                CachedMethod.Add(cacheName, method);
                return method;
            }
            Console.WriteLine("guessing method : " + methodName);
            if (methodsSeen > 0) return lastMethod;
            Console.WriteLine("throw exception");
            return IntPtr.Zero;
        }
        public static Dictionary<String, IntPtr> CachedClasses = new Dictionary<String, IntPtr>();
        public static IntPtr GetIl2CpClass(String dll, String namespaze, String clazz)
        {
            var cacheName = dll + "," + namespaze + "," + clazz;
            if (CachedClasses.ContainsKey(cacheName)) return CachedClasses[cacheName];
            var val = Il2Cpp.il2cpp_class_from_name(Il2Cpp.GetImage(dll), namespaze, clazz);
            CachedClasses.Add(cacheName, val);
            return IntPtr.Zero;
        }


        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_init(IntPtr domain_name);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_init_utf16(IntPtr domain_name);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_shutdown();
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_set_config_dir(IntPtr config_path);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_set_data_dir(IntPtr data_path);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_set_temp_dir(IntPtr temp_path);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_set_commandline_arguments(int argc, IntPtr argv, IntPtr basedir);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_set_commandline_arguments_utf16(int argc, IntPtr argv, IntPtr basedir);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_set_config_utf16(IntPtr executablePath);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_set_config(IntPtr executablePath);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_set_memory_callbacks(IntPtr callbacks);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_get_corlib();
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_add_internal_call(IntPtr name, IntPtr method);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_resolve_icall([MarshalAs(UnmanagedType.LPStr)] string name);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_alloc(uint size);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_free(IntPtr ptr);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_array_class_get(IntPtr element_class, uint rank);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern uint il2cpp_array_length(IntPtr array);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern uint il2cpp_array_get_byte_length(IntPtr array);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_array_new(IntPtr elementTypeInfo, ulong length);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_array_new_specific(IntPtr arrayTypeInfo, ulong length);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_array_new_full(IntPtr array_class, ref ulong lengths, ref ulong lower_bounds);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_bounded_array_class_get(IntPtr element_class, uint rank, bool bounded);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern int il2cpp_array_element_size(IntPtr array_class);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_assembly_get_image(IntPtr assembly);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_class_enum_basetype(IntPtr klass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_class_is_generic(IntPtr klass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_class_is_inflated(IntPtr klass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_class_is_assignable_from(IntPtr klass, IntPtr oklass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_class_is_subclass_of(IntPtr klass, IntPtr klassc, bool check_interfaces);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_class_has_parent(IntPtr klass, IntPtr klassc);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_class_from_il2cpp_type(IntPtr type);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_class_from_name(IntPtr image, [MarshalAs(UnmanagedType.LPStr)] string namespaze, [MarshalAs(UnmanagedType.LPStr)] string name);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_class_from_system_type(IntPtr type);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_class_get_element_class(IntPtr klass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_class_get_events(IntPtr klass, ref IntPtr iter);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_class_get_fields(IntPtr klass, ref IntPtr iter);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_class_get_nested_types(IntPtr klass, ref IntPtr iter);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_class_get_interfaces(IntPtr klass, ref IntPtr iter);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_class_get_properties(IntPtr klass, ref IntPtr iter);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_class_get_property_from_name(IntPtr klass, IntPtr name);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_class_get_field_from_name(IntPtr klass, [MarshalAs(UnmanagedType.LPStr)] string name);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_class_get_methods(IntPtr klass, ref IntPtr iter);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_class_get_method_from_name(IntPtr klass, [MarshalAs(UnmanagedType.LPStr)] string name, int argsCount);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_class_get_name(IntPtr klass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_class_get_namespace(IntPtr klass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_class_get_parent(IntPtr klass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_class_get_declaring_type(IntPtr klass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern int il2cpp_class_instance_size(IntPtr klass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern uint il2cpp_class_num_fields(IntPtr enumKlass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_class_is_valuetype(IntPtr klass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern int il2cpp_class_value_size(IntPtr klass, ref uint align);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_class_is_blittable(IntPtr klass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern int il2cpp_class_get_flags(IntPtr klass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_class_is_abstract(IntPtr klass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_class_is_interface(IntPtr klass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern int il2cpp_class_array_element_size(IntPtr klass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_class_from_type(IntPtr type);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_class_get_type(IntPtr klass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern uint il2cpp_class_get_type_token(IntPtr klass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_class_has_attribute(IntPtr klass, IntPtr attr_class);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_class_has_references(IntPtr klass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_class_is_enum(IntPtr klass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_class_get_image(IntPtr klass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_class_get_assemblyname(IntPtr klass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern int il2cpp_class_get_rank(IntPtr klass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern uint il2cpp_class_get_bitmap_size(IntPtr klass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_class_get_bitmap(IntPtr klass, ref uint bitmap);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_get_meta_data_pool_memory();
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_stats_dump_to_file(IntPtr path);
        //[DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public extern static ulong il2cpp_stats_get_value(IL2CPP_Stat stat);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_domain_get();
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_domain_assembly_open(IntPtr domain, IntPtr name);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr* il2cpp_domain_get_assemblies(IntPtr domain, ref uint size);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_exception_from_name_msg(IntPtr image, IntPtr name_space, IntPtr name, IntPtr msg);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_get_exception_argument_null(IntPtr arg);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_format_exception(IntPtr ex, void* message, int message_size);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_format_stack_trace(IntPtr ex, void* output, int output_size);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_unhandled_exception(IntPtr ex);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern int il2cpp_field_get_flags(IntPtr field);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_field_get_name(IntPtr field);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_field_get_parent(IntPtr field);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern uint il2cpp_field_get_offset(IntPtr field);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_field_get_type(IntPtr field);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_field_get_value(IntPtr obj, IntPtr field, void* value);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_field_get_value_object(IntPtr field, IntPtr obj);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_field_has_attribute(IntPtr field, IntPtr attr_class);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_field_set_value(IntPtr obj, IntPtr field, void* value);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_field_static_get_value(IntPtr field, void* value);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_field_static_set_value(IntPtr field, void* value);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_field_set_value_object(IntPtr instance, IntPtr field, IntPtr value);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_gc_collect(int maxGenerations);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern int il2cpp_gc_collect_a_little();
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_gc_disable();
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_gc_enable();
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_gc_is_disabled();
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern long il2cpp_gc_get_used_size();
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern long il2cpp_gc_get_heap_size();
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_gc_wbarrier_set_field(IntPtr obj, out IntPtr targetAddress, IntPtr gcObj);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern uint il2cpp_gchandle_new(IntPtr obj, bool pinned);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern uint il2cpp_gchandle_new_weakref(IntPtr obj, bool track_resurrection);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_gchandle_get_target(uint gchandle);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_gchandle_free(uint gchandle);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_unity_liveness_calculation_begin(IntPtr filter, int max_object_count, IntPtr callback, IntPtr userdata, IntPtr onWorldStarted, IntPtr onWorldStopped);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_unity_liveness_calculation_end(IntPtr state);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_unity_liveness_calculation_from_root(IntPtr root, IntPtr state);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_unity_liveness_calculation_from_statics(IntPtr state);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_method_get_return_type(IntPtr method);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_method_get_declaring_type(IntPtr method);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_method_get_name(IntPtr method);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_method_get_from_reflection(IntPtr method);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_method_get_object(IntPtr method, IntPtr refclass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_method_is_generic(IntPtr method);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_method_is_inflated(IntPtr method);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_method_is_instance(IntPtr method);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern uint il2cpp_method_get_param_count(IntPtr method);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_method_get_param(IntPtr method, uint index);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_method_get_class(IntPtr method);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_method_has_attribute(IntPtr method, IntPtr attr_class);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern uint il2cpp_method_get_flags(IntPtr method, ref uint iflags);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern uint il2cpp_method_get_token(IntPtr method);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_method_get_param_name(IntPtr method, uint index);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_profiler_install(IntPtr prof, IntPtr shutdown_callback);
        // [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public extern static void il2cpp_profiler_set_events(IL2CPP_ProfileFlags events);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_profiler_install_enter_leave(IntPtr enter, IntPtr fleave);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_profiler_install_allocation(IntPtr callback);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_profiler_install_gc(IntPtr callback, IntPtr heap_resize_callback);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_profiler_install_fileio(IntPtr callback);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_profiler_install_thread(IntPtr start, IntPtr end);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern uint il2cpp_property_get_flags(IntPtr prop);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_property_get_get_method(IntPtr prop);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_property_get_set_method(IntPtr prop);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_property_get_name(IntPtr prop);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_property_get_parent(IntPtr prop);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_object_get_class(IntPtr obj);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern uint il2cpp_object_get_size(IntPtr obj);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_object_get_virtual_method(IntPtr obj, IntPtr method);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_object_new(IntPtr klass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_object_unbox(IntPtr obj);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_value_box(IntPtr klass, IntPtr data);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_monitor_enter(IntPtr obj);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_monitor_try_enter(IntPtr obj, uint timeout);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_monitor_exit(IntPtr obj);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_monitor_pulse(IntPtr obj);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_monitor_pulse_all(IntPtr obj);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_monitor_wait(IntPtr obj);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_monitor_try_wait(IntPtr obj, uint timeout);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern unsafe IntPtr il2cpp_runtime_invoke(IntPtr method, IntPtr obj, void** param, ref IntPtr exc);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        // param can be of Il2CppObject*
        public static extern unsafe IntPtr il2cpp_runtime_invoke_convert_args(IntPtr method, IntPtr obj, void** param, int paramCount, ref IntPtr exc);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_runtime_class_init(IntPtr klass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_runtime_object_init(IntPtr obj);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_runtime_object_init_exception(IntPtr obj, ref IntPtr exc);
        // [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public extern static void il2cpp_runtime_unhandled_exception_policy_set(IL2CPP_RuntimeUnhandledExceptionPolicy value);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern int il2cpp_string_length(IntPtr str);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern unsafe char* il2cpp_string_chars(IntPtr str);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_string_new(string str);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_string_new_len(string str, uint length);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_string_new_utf16(char* text, int len);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_string_new_wrapper(string str);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_string_intern(string str);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_string_is_interned(string str);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_thread_current();
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_thread_attach(IntPtr domain);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_thread_detach(IntPtr thread);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern unsafe void** il2cpp_thread_get_all_attached_threads(ref uint size);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_is_vm_thread(IntPtr thread);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_current_thread_walk_frame_stack(IntPtr func, IntPtr user_data);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_thread_walk_frame_stack(IntPtr thread, IntPtr func, IntPtr user_data);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_current_thread_get_top_frame(IntPtr frame);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_thread_get_top_frame(IntPtr thread, IntPtr frame);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_current_thread_get_frame_at(int offset, IntPtr frame);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_thread_get_frame_at(IntPtr thread, int offset, IntPtr frame);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern int il2cpp_current_thread_get_stack_depth();
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern int il2cpp_thread_get_stack_depth(IntPtr thread);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_type_get_object(IntPtr type);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern int il2cpp_type_get_type(IntPtr type);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_type_get_class_or_element_class(IntPtr type);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_type_get_name(IntPtr type);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_type_is_byref(IntPtr type);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern uint il2cpp_type_get_attrs(IntPtr type);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_type_equals(IntPtr type, IntPtr otherType);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_type_get_assembly_qualified_name(IntPtr type);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_image_get_assembly(IntPtr image);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_image_get_name(IntPtr image);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_image_get_filename(IntPtr image);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_image_get_entry_point(IntPtr image);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern uint il2cpp_image_get_class_count(IntPtr image);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_image_get_class(IntPtr image, uint index);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_capture_memory_snapshot();
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_free_captured_memory_snapshot(IntPtr snapshot);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_set_find_plugin_callback(IntPtr method);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_register_log_callback(IntPtr method);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_debugger_set_agent_options(IntPtr options);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_is_debugger_attached();
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern unsafe void il2cpp_unity_install_unitytls_interface(void* unitytlsInterfaceStruct);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_custom_attrs_from_class(IntPtr klass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_custom_attrs_from_method(IntPtr method);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_custom_attrs_get_attr(IntPtr ainfo, IntPtr attr_klass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern bool il2cpp_custom_attrs_has_attr(IntPtr ainfo, IntPtr attr_klass);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern IntPtr il2cpp_custom_attrs_construct(IntPtr cinfo);
        [DllImport(UnityDllName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern void il2cpp_custom_attrs_free(IntPtr ainfo);
    }
}

```

`Il2CppRuntime/Dumper/Il2Cpp/Il2CppAssembly.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
namespace Il2CppRuntime.Il2Cpp
{
    public unsafe class Il2CppAssembly : Il2CppBase
    {
        public String Name;
        public List<Il2CppClass> Classes = new List<Il2CppClass>();

        public static IntPtr AssemblyGetTypesPtr = IntPtr.Zero;
        public Il2CppAssembly(IntPtr ptr, IntPtr assemblyPtr) : base(ptr)
        {
            Ptr = ptr;
            var imagePtr = Il2Cpp.il2cpp_assembly_get_image(assemblyPtr);
            Name = Marshal.PtrToStringAnsi(Il2Cpp.il2cpp_image_get_name(imagePtr));

            IntPtr* param = null;
            var returnedException = IntPtr.Zero;
            var assemblyTypesPtr = Il2Cpp.il2cpp_runtime_invoke(Il2Cpp.AssemblyGetTypesPtr, ptr, (void**)param, ref returnedException);
            var numTypes = (Int32)Il2Cpp.il2cpp_array_length(assemblyTypesPtr);
            for (var j = 0u; j < numTypes; j++)
            {
                var classPtr = Il2Cpp.il2cpp_class_from_system_type(*(IntPtr*)((UInt64)assemblyTypesPtr + 32 + j * 8));
                Classes.Add(Il2CppClass.Generate(classPtr));
            }
        }
    }
}

```

`Il2CppRuntime/Dumper/Il2Cpp/Il2CppBase.cs`:

```cs
using System;
namespace Il2CppRuntime.Il2Cpp
{
    public class Il2CppBase
    {
        public IntPtr Ptr { get; set; }
        public Il2CppBase(IntPtr ptr) => Ptr = ptr;
    }
}

```

`Il2CppRuntime/Dumper/Il2Cpp/Il2CppClass.cs`:

```cs
using System;
using System.Collections.Generic;
using Mono.Cecil;
using System.Runtime.InteropServices;

namespace Il2CppRuntime.Il2Cpp
{
    public unsafe class Il2CppClass : Il2CppBase
    {
        public IntPtr NamePtr;
        public String Name;
        public String Namespace;
        public TypeAttributes Flags;
        public List<Il2CppMethod> Methods = new List<Il2CppMethod>();
        public List<Il2CppField> Fields = new List<Il2CppField>();
        public List<Il2CppBase> Events = new List<Il2CppBase>();
        public List<Il2CppProperty> Properties = new List<Il2CppProperty>();
        public List<IntPtr> InterfacePtrs = new List<IntPtr>();
        public List<IntPtr> NestedTypePtrs = new List<IntPtr>();
        public IntPtr Image;
        public IntPtr BaseClassPtr = IntPtr.Zero;
        public Il2CppClass BaseClass { get { return Il2CppClass.Generate(BaseClassPtr); } }
        public IntPtr DeclaringTypePtr = IntPtr.Zero;
        public Il2CppClass DeclaringType { get { return Il2CppClass.Generate(DeclaringTypePtr); } }
        public Il2CppType Type;
        public Int32 GenericIndex = 0;
        //public IntPtr GenericClassPtr = IntPtr.Zero;
        //public Il2CppClass GenericClass { get { return Il2CppClass.Generate(GenericClassPtr); } }

        public static List<IntPtr> ClassesToAdd = new List<IntPtr>();
        public static Dictionary<IntPtr, Il2CppClass> CachedClasses = new Dictionary<IntPtr, Il2CppClass>();
        public static Int32 GenericOffset = Int32.MaxValue;
        public static Boolean NotFirstGeneric = false;
        public Il2CppClass(IntPtr ptr) : base(ptr)
        {
            Ptr = ptr;
            NamePtr = Il2Cpp.il2cpp_class_get_name(ptr);
            Name = Marshal.PtrToStringAnsi(Il2Cpp.il2cpp_class_get_name(ptr));
            Namespace = Marshal.PtrToStringAnsi(Il2Cpp.il2cpp_class_get_namespace(ptr));
            Flags = (TypeAttributes)Il2Cpp.il2cpp_class_get_flags(ptr);
            Image = Il2Cpp.il2cpp_class_get_image(ptr);
            Type = new Il2CppType(Il2Cpp.il2cpp_class_get_type(ptr));
            DeclaringTypePtr = Il2Cpp.il2cpp_class_get_declaring_type(ptr);
            if (DeclaringTypePtr != IntPtr.Zero && !Il2CppClass.CachedClasses.ContainsKey(DeclaringTypePtr)) Il2CppClass.ClassesToAdd.Add(DeclaringTypePtr);
            BaseClassPtr = Il2Cpp.il2cpp_class_get_parent(ptr);
            if (BaseClassPtr != IntPtr.Zero && !Il2CppClass.CachedClasses.ContainsKey(BaseClassPtr)) Il2CppClass.ClassesToAdd.Add(BaseClassPtr);
            var isGeneric = Il2Cpp.il2cpp_class_is_generic(ptr);
            if (isGeneric)
            {
                if (NotFirstGeneric)
                {
                    if (GenericOffset == Int32.MaxValue)
                    {
                        for (var i = 0x80; i < 0x100; i += 8)
                        {
                            var qq = *(Int32*)(ptr + i);
                            if (*(Int32*)(ptr + i) == 1)
                            {
                                GenericOffset = i;
                                break;
                            }
                        }
                    }
                    if (GenericOffset == Int32.MaxValue) throw new Exception("can't find generic");
                    GenericIndex = *(Int32*)(ptr + GenericOffset); // e8 for gunfire, //c8 for genshin // f0 for naraka
                }
                NotFirstGeneric = true;
               // Console.WriteLine(Namespace + " : " + Name + " : " + GenericIndex + " : " + Ptr.ToString("X"));
            //    GenericClassPtr = BaseClassPtr;
            }
            var classChildPtr = IntPtr.Zero;
            var iter = IntPtr.Zero;
            //while ((classChildPtr = Il2Cpp.il2cpp_class_get_nested_types(ptr, ref iter)) != IntPtr.Zero)
            {
                //NestedTypePtrs.Add(classChildPtr);
                //if (!Il2Cpp_Class.CachedClasses.ContainsKey(classChildPtr)) Il2Cpp_Class.ClassesToAdd.Add(classChildPtr);
            }
            iter = IntPtr.Zero;
            while ((classChildPtr = Il2Cpp.il2cpp_class_get_methods(ptr, ref iter)) != IntPtr.Zero) Methods.Add(new Il2CppMethod(classChildPtr));
            iter = IntPtr.Zero;
            while ((classChildPtr = Il2Cpp.il2cpp_class_get_fields(ptr, ref iter)) != IntPtr.Zero) Fields.Add(new Il2CppField(classChildPtr));
            iter = IntPtr.Zero;
            while ((classChildPtr = Il2Cpp.il2cpp_class_get_properties(ptr, ref iter)) != IntPtr.Zero) Properties.Add(new Il2CppProperty(classChildPtr));
            iter = IntPtr.Zero;
            while ((classChildPtr = Il2Cpp.il2cpp_class_get_interfaces(ptr, ref iter)) != IntPtr.Zero) InterfacePtrs.Add(classChildPtr);
            iter = IntPtr.Zero;
            //while ((classChildPtr = Il2Cpp.il2cpp_class_get_events(ptr, ref iter)) != IntPtr.Zero) Events.Add(new Il2Cpp_Base(classChildPtr));
        }
        public static Il2CppClass Generate(IntPtr ptr)
        {
            if (CachedClasses.ContainsKey(ptr)) return CachedClasses[ptr];
            var c = new Il2CppClass(ptr);
            CachedClasses.Add(ptr, c);
            return c;
        }

        public static IntPtr CreateInstance(Il2CppClass il2CppClass, Il2CppMethod constructor = null, IntPtr[] contructorParams = null)
        {
            int paramCount = contructorParams?.Length ?? 0;
            if (constructor == null && paramCount > 0)
                return IntPtr.Zero;
            IntPtr instance = Il2Cpp.il2cpp_object_new(il2CppClass.Ptr);
            if (constructor == null)
            {
                Il2Cpp.il2cpp_runtime_object_init(instance);
                return instance;
            }
            else
            {
                //constructor.Invoke(instance, contructorParams);
            }
            return instance;
        }
    }
}

```

`Il2CppRuntime/Dumper/Il2Cpp/Il2CppDummyDll.cs`:

```cs
using System;
using System.Reflection;
using Mono.Cecil;
using Mono.Cecil.Cil;
using FieldAttributes = Mono.Cecil.FieldAttributes;
using MethodAttributes = Mono.Cecil.MethodAttributes;
using TypeAttributes = Mono.Cecil.TypeAttributes;

namespace Il2CppRuntime.Il2Cpp
{
    public static class Il2CppDummyDll
    {
        private static Type attributeType;
        private static ConstructorInfo attributeConstructor;

        static Il2CppDummyDll()
        {
            attributeType = typeof(Attribute);
            attributeConstructor = attributeType.GetConstructors(BindingFlags.NonPublic | BindingFlags.Instance)[0];
        }

        public static AssemblyDefinition Create()
        {
            var assemblyName = new AssemblyNameDefinition("Il2CppDummyDll", new Version("1.0.0.0"));
            var assemblyDefinition = AssemblyDefinition.CreateAssembly(assemblyName, "Il2CppDummyDll.dll", ModuleKind.Dll);
            var stringTypeReference = assemblyDefinition.MainModule.TypeSystem.String;
            var attributeTypeReference = assemblyDefinition.MainModule.ImportReference(attributeType);
            var types = assemblyDefinition.MainModule.Types;
            var namespaceName = "Il2CppDummyDll";
            var addressAttribute = new TypeDefinition(namespaceName, "AddressAttribute", (TypeAttributes)0x100001, attributeTypeReference);
            addressAttribute.Fields.Add(new FieldDefinition("RVA", FieldAttributes.Public, stringTypeReference));
            addressAttribute.Fields.Add(new FieldDefinition("Offset", FieldAttributes.Public, stringTypeReference));
            addressAttribute.Fields.Add(new FieldDefinition("VA", FieldAttributes.Public, stringTypeReference));
            addressAttribute.Fields.Add(new FieldDefinition("Slot", FieldAttributes.Public, stringTypeReference));
            types.Add(addressAttribute);
            CreateDefaultConstructor(addressAttribute);
            var fieldOffsetAttribute = new TypeDefinition(namespaceName, "FieldOffsetAttribute", (TypeAttributes)0x100001, attributeTypeReference);
            fieldOffsetAttribute.Fields.Add(new FieldDefinition("Offset", FieldAttributes.Public, stringTypeReference));
            types.Add(fieldOffsetAttribute);
            CreateDefaultConstructor(fieldOffsetAttribute);
            var attributeAttribute = new TypeDefinition(namespaceName, "AttributeAttribute", (TypeAttributes)0x100001, attributeTypeReference);
            attributeAttribute.Fields.Add(new FieldDefinition("Name", FieldAttributes.Public, stringTypeReference));
            attributeAttribute.Fields.Add(new FieldDefinition("RVA", FieldAttributes.Public, stringTypeReference));
            attributeAttribute.Fields.Add(new FieldDefinition("Offset", FieldAttributes.Public, stringTypeReference));
            types.Add(attributeAttribute);
            CreateDefaultConstructor(attributeAttribute);
            var metadataOffsetAttribute = new TypeDefinition(namespaceName, "MetadataOffsetAttribute", (TypeAttributes)0x100001, attributeTypeReference);
            metadataOffsetAttribute.Fields.Add(new FieldDefinition("Offset", FieldAttributes.Public, stringTypeReference));
            types.Add(metadataOffsetAttribute);
            CreateDefaultConstructor(metadataOffsetAttribute);
            var tokenAttribute = new TypeDefinition(namespaceName, "TokenAttribute", (TypeAttributes)0x100001, attributeTypeReference);
            tokenAttribute.Fields.Add(new FieldDefinition("Token", FieldAttributes.Public, stringTypeReference));
            types.Add(tokenAttribute);
            CreateDefaultConstructor(tokenAttribute);
            return assemblyDefinition;
        }

        private static void CreateDefaultConstructor(TypeDefinition typeDefinition)
        {
            var module = typeDefinition.Module;
            var defaultConstructor = new MethodDefinition(".ctor",
                MethodAttributes.Public | MethodAttributes.HideBySig |
                MethodAttributes.SpecialName | MethodAttributes.RTSpecialName,
                module.ImportReference(typeof(void)));
            var processor = defaultConstructor.Body.GetILProcessor();
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Call, module.ImportReference(attributeConstructor));
            processor.Emit(OpCodes.Ret);
            typeDefinition.Methods.Add(defaultConstructor);
        }
    }
}

```

`Il2CppRuntime/Dumper/Il2Cpp/Il2CppField.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using Mono.Cecil;

namespace Il2CppRuntime.Il2Cpp
{
    public unsafe class Il2CppField : Il2CppBase
    {
        public String Name;
        public FieldAttributes Flags;
        public UInt32 Offset;
        public Il2CppType Type;
        public IntPtr ClassPtr { get; set; }
        public Il2CppClass Class { get { return Il2CppClass.Generate(ClassPtr); } }
        public Il2CppField(IntPtr ptr) : base(ptr)
        {
            Ptr = ptr;
            Name = Marshal.PtrToStringAnsi(Il2Cpp.il2cpp_field_get_name(Ptr));
            Flags = (FieldAttributes)Il2Cpp.il2cpp_field_get_flags(Ptr);
            Type = new Il2CppType(Il2Cpp.il2cpp_field_get_type(Ptr));
            ClassPtr = Il2Cpp.il2cpp_class_from_type(Type.Ptr);
            Offset = Il2Cpp.il2cpp_field_get_offset(Ptr);
            if (!Il2CppClass.CachedClasses.ContainsKey(ClassPtr)) Il2CppClass.ClassesToAdd.Add(ClassPtr);
        }
        /*
        unsafe public Il2Cpp_Object GetValue() => GetValue(IntPtr.Zero);
        unsafe public Il2Cpp_Object GetValue(IntPtr obj)
        {
            IntPtr returnval;
            if (HasFlag(Il2Cpp_BindingFlags.FIELD_STATIC))
                returnval = Il2Cpp.il2cpp_field_get_value_object(Ptr, IntPtr.Zero);
            else
                returnval = Il2Cpp.il2cpp_field_get_value_object(Ptr, obj);
            if (returnval != IntPtr.Zero)
                return new Il2Cpp_Object(returnval, GetReturnType());
            return null;
        }

        unsafe public void SetValue(IntPtr value) => SetValue(IntPtr.Zero, value);
        unsafe public void SetValue(IntPtr obj, IntPtr value)
        {
            if (HasFlag(Il2Cpp_BindingFlags.FIELD_STATIC))
                Il2Cpp.il2cpp_field_static_set_value(Ptr, value);
            else
                Il2Cpp.il2cpp_field_set_value(obj, Ptr, value);
        }*/
    }
}

```

`Il2CppRuntime/Dumper/Il2Cpp/Il2CppGenericContainer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Il2CppRuntime.Il2Cpp
{
    public unsafe class Il2CppGenericContainer : Il2CppBase
    {
        public Int32 OwnerIndex;
        public Int32 Count;
        public Int32 IsMethod;
        public Int32 ParamStart;
        public static List<Il2CppGenericContainer> Generics = new List<Il2CppGenericContainer>();
        public Il2CppGenericContainer(IntPtr ptr) : base(ptr)
        {
            Ptr = ptr;
            OwnerIndex = *(Int32*)Ptr;
            Count = *(Int32*)(Ptr + 4);
            IsMethod = *(Int32*)(Ptr + 8);
            ParamStart = *(Int32*)(Ptr + 12);
        }
    }
}

```

`Il2CppRuntime/Dumper/Il2Cpp/Il2CppMethod.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using Mono.Cecil;

namespace Il2CppRuntime.Il2Cpp
{
    public unsafe class Il2CppMethod : Il2CppBase
    {
        public String Name;
        public MethodAttributes Flags;
        public MethodImplAttributes ImplFlags;
        public Il2CppType ReturnType;
        public IntPtr ReturnClassPtr;
        public Il2CppClass ReturnClass { get { return Il2CppClass.Generate(ReturnClassPtr); } }
        public Boolean IsGeneric;
        public Il2CppGenericContainer GenericContainer;
        public List<Il2Cpp_Method_Parameter> Parameters = new List<Il2Cpp_Method_Parameter>();
        public Il2CppMethod(IntPtr ptr) : base(ptr)
        {
            Ptr = ptr;
            Name = Marshal.PtrToStringAnsi(Il2Cpp.il2cpp_method_get_name(Ptr));
            ReturnType = new Il2CppType(Il2Cpp.il2cpp_method_get_return_type(Ptr));
            ReturnClassPtr = Il2Cpp.il2cpp_class_from_type(ReturnType.Ptr);
            if (!Il2CppClass.CachedClasses.ContainsKey(ReturnClassPtr)) Il2CppClass.ClassesToAdd.Add(ReturnClassPtr);
            var flags = 0u;
            Flags = (MethodAttributes)Il2Cpp.il2cpp_method_get_flags(Ptr, ref flags);
            ImplFlags = (MethodImplAttributes)flags;
            IsGeneric = Il2Cpp.il2cpp_method_is_generic(ptr);
            var param_count = Il2Cpp.il2cpp_method_get_param_count(Ptr);
            for (var i = 0u; i < param_count; i++) Parameters.Add(new Il2Cpp_Method_Parameter(Il2Cpp.il2cpp_method_get_param(Ptr, i), Marshal.PtrToStringAnsi(Il2Cpp.il2cpp_method_get_param_name(Ptr, i))));

            if (IsGeneric)
            {
                GenericContainer = new Il2CppGenericContainer(*(IntPtr*)(Ptr + 7 * 8));
                //Console.WriteLine(genBase.ToString("X"));
                var container = new Il2CppGenericContainer(GenericContainer.Ptr);
                while (Il2Cpp.ContainersPtrGuess == IntPtr.Zero)
                {
                    var prevContainer = new Il2CppGenericContainer(container.Ptr - 0x10);
                    if (prevContainer.ParamStart + prevContainer.Count != container.ParamStart) throw new ArithmeticException();
                    if (prevContainer.ParamStart == 0) Il2Cpp.ContainersPtrGuess = prevContainer.Ptr;
                    container = prevContainer;
                }
                // if (m.Name == "Instantiate" && m.Parameters.Count == 2)
            }
        }
    }
    public class Il2Cpp_Method_Parameter : Il2CppBase
    {
        public string Name { get; set; }
        public IntPtr ClassPtr { get; set; }
        public Il2CppClass Class { get { return Il2CppClass.Generate(ClassPtr); } }
        internal Il2Cpp_Method_Parameter(IntPtr ptr, string name) : base(ptr)
        {
            Ptr = ptr;
            Name = name;
            ClassPtr = Il2Cpp.il2cpp_class_from_type(Ptr);
            if (!Il2CppClass.CachedClasses.ContainsKey(ClassPtr)) Il2CppClass.ClassesToAdd.Add(ClassPtr);
        }
    }
}

```

`Il2CppRuntime/Dumper/Il2Cpp/Il2CppObject.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Il2CppRuntime.Il2Cpp
{
    public unsafe class Il2CppObject : Il2CppBase
    {
        public Il2CppType ReturnType;
        public Il2CppObject(IntPtr ptr, Il2CppType returntype) : base(ptr)
        {
            Ptr = ptr;
            ReturnType = returntype;
        }

        public Il2CppType GetReturnType() => ReturnType;

        public IntPtr UnboxIntPtr() => Il2Cpp.il2cpp_object_unbox(Ptr);
        public void* Unbox() => UnboxIntPtr().ToPointer();
        public T UnboxValue<T>() where T : unmanaged => *(T*)Unbox();
        //public string UnboxString() => Il2Cpp.IntPtrToString(Ptr);
    }
}

```

`Il2CppRuntime/Dumper/Il2Cpp/Il2CppProperty.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using Mono.Cecil;
namespace Il2CppRuntime.Il2Cpp
{
    public class Il2CppProperty : Il2CppBase
    {
        public String Name;
        public PropertyAttributes Flags;
        public Il2CppMethod getMethod;
        public Il2CppMethod setMethod;
        public IntPtr ClassPtr;
        public Il2CppClass Class { get { return Il2CppClass.Generate(ClassPtr); } }
        public Il2CppProperty(IntPtr ptr) : base(ptr)
        {
            Ptr = ptr;
            Name = Marshal.PtrToStringAnsi(Il2Cpp.il2cpp_property_get_name(Ptr));
            Flags = (PropertyAttributes)Il2Cpp.il2cpp_property_get_flags(Ptr);
            var getMethodPtr = Il2Cpp.il2cpp_property_get_get_method(Ptr);
            if (getMethodPtr != IntPtr.Zero)
            {
                getMethod = new Il2CppMethod(getMethodPtr);
                ClassPtr = Il2Cpp.il2cpp_class_from_type(getMethod.ReturnType.Ptr);
            }
            var setMethodPtr = Il2Cpp.il2cpp_property_get_set_method(Ptr);
            if (setMethodPtr != IntPtr.Zero)
            {
                setMethod = new Il2CppMethod(setMethodPtr);
                ClassPtr = setMethod.Parameters[0].ClassPtr;
            }
        }
    }
}

```

`Il2CppRuntime/Dumper/Il2Cpp/Il2CppType.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
namespace Il2CppRuntime.Il2Cpp
{
    public unsafe class Il2CppType : Il2CppBase
    {
        public UInt64 Value;
        public String Name;
        public Byte Rank;
        public Boolean ByRef;
        public Il2CppTypeEnum Type;
        public UInt16 Attributes;
        public static Dictionary<IntPtr, Il2CppType> CachedTypes = new Dictionary<IntPtr, Il2CppType>();
        public Il2CppType(IntPtr ptr) : base(ptr)
        {
            Ptr = ptr;
            Name = Marshal.PtrToStringAnsi(Il2Cpp.il2cpp_type_get_name(Ptr));
            ByRef = ((*(Byte*)(ptr + 0xA)) & 0x80) == 0x80;
            Rank = *(Byte*)(ptr + 0x8);
            Attributes = *(UInt16*)(ptr + 8);
            Type = (Il2CppTypeEnum)(*(Byte*)(ptr + 0xA));
            if (!CachedTypes.ContainsKey(Ptr)) CachedTypes.Add(Ptr, this);
        }
        public IntPtr PtrVal => *(IntPtr*)Ptr;
        public Il2CppClass GetClass()
        {
            return Il2CppClass.Generate(Il2Cpp.il2cpp_class_from_type(Ptr));
        }
        public static Il2CppType GenerateType(IntPtr Ptr)
        {
            if (CachedTypes.ContainsKey(Ptr)) return CachedTypes[Ptr];
            return new Il2CppType(Ptr);
        }
    }
    public enum Il2CppTypeEnum : Byte
    {
        IL2CPP_TYPE_END = 0x00,
        IL2CPP_TYPE_VOID = 0x01,
        IL2CPP_TYPE_BOOLEAN = 0x02,
        IL2CPP_TYPE_CHAR = 0x03,
        IL2CPP_TYPE_I1 = 0x04,
        IL2CPP_TYPE_U1 = 0x05,
        IL2CPP_TYPE_I2 = 0x06,
        IL2CPP_TYPE_U2 = 0x07,
        IL2CPP_TYPE_I4 = 0x08,
        IL2CPP_TYPE_U4 = 0x09,
        IL2CPP_TYPE_I8 = 0x0a,
        IL2CPP_TYPE_U8 = 0x0b,
        IL2CPP_TYPE_R4 = 0x0c,
        IL2CPP_TYPE_R8 = 0x0d,
        IL2CPP_TYPE_STRING = 0x0e,
        IL2CPP_TYPE_PTR = 0x0f,
        IL2CPP_TYPE_BYREF = 0x10,
        IL2CPP_TYPE_VALUETYPE = 0x11,
        IL2CPP_TYPE_CLASS = 0x12,
        IL2CPP_TYPE_VAR = 0x13,
        IL2CPP_TYPE_ARRAY = 0x14,
        IL2CPP_TYPE_GENERICINST = 0x15,
        IL2CPP_TYPE_TYPEDBYREF = 0x16,
        IL2CPP_TYPE_I = 0x18,
        IL2CPP_TYPE_U = 0x19,
        IL2CPP_TYPE_FNPTR = 0x1b,
        IL2CPP_TYPE_OBJECT = 0x1c,
        IL2CPP_TYPE_SZARRAY = 0x1d,
        IL2CPP_TYPE_MVAR = 0x1e,
        IL2CPP_TYPE_CMOD_REQD = 0x1f,
        IL2CPP_TYPE_CMOD_OPT = 0x20,
        IL2CPP_TYPE_INTERNAL = 0x21,
        IL2CPP_TYPE_MODIFIER = 0x40,
        IL2CPP_TYPE_SENTINEL = 0x41,
        IL2CPP_TYPE_PINNED = 0x45,
        IL2CPP_TYPE_ENUM = 0x55
    }
}

```

`Il2CppRuntime/FodyWeavers.xml`:

```xml
<Weavers xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="FodyWeavers.xsd">
  <Costura />
</Weavers>
```

`Il2CppRuntime/FodyWeavers.xsd`:

```xsd
<?xml version="1.0" encoding="utf-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <!-- This file was generated by Fody. Manual changes to this file will be lost when your project is rebuilt. -->
  <xs:element name="Weavers">
    <xs:complexType>
      <xs:all>
        <xs:element name="Costura" minOccurs="0" maxOccurs="1">
          <xs:complexType>
            <xs:all>
              <xs:element minOccurs="0" maxOccurs="1" name="ExcludeAssemblies" type="xs:string">
                <xs:annotation>
                  <xs:documentation>A list of assembly names to exclude from the default action of "embed all Copy Local references", delimited with line breaks</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element minOccurs="0" maxOccurs="1" name="IncludeAssemblies" type="xs:string">
                <xs:annotation>
                  <xs:documentation>A list of assembly names to include from the default action of "embed all Copy Local references", delimited with line breaks.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element minOccurs="0" maxOccurs="1" name="ExcludeRuntimeAssemblies" type="xs:string">
                <xs:annotation>
                  <xs:documentation>A list of runtime assembly names to exclude from the default action of "embed all Copy Local references", delimited with line breaks</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element minOccurs="0" maxOccurs="1" name="IncludeRuntimeAssemblies" type="xs:string">
                <xs:annotation>
                  <xs:documentation>A list of runtime assembly names to include from the default action of "embed all Copy Local references", delimited with line breaks.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element minOccurs="0" maxOccurs="1" name="Unmanaged32Assemblies" type="xs:string">
                <xs:annotation>
                  <xs:documentation>A list of unmanaged 32 bit assembly names to include, delimited with line breaks.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element minOccurs="0" maxOccurs="1" name="Unmanaged64Assemblies" type="xs:string">
                <xs:annotation>
                  <xs:documentation>A list of unmanaged 64 bit assembly names to include, delimited with line breaks.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element minOccurs="0" maxOccurs="1" name="PreloadOrder" type="xs:string">
                <xs:annotation>
                  <xs:documentation>The order of preloaded assemblies, delimited with line breaks.</xs:documentation>
                </xs:annotation>
              </xs:element>
            </xs:all>
            <xs:attribute name="CreateTemporaryAssemblies" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>This will copy embedded files to disk before loading them into memory. This is helpful for some scenarios that expected an assembly to be loaded from a physical file.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="IncludeDebugSymbols" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>Controls if .pdbs for reference assemblies are also embedded.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="IncludeRuntimeReferences" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>Controls if runtime assemblies are also embedded.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="UseRuntimeReferencePaths" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>Controls whether the runtime assemblies are embedded with their full path or only with their assembly name.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="DisableCompression" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>Embedded assemblies are compressed by default, and uncompressed when they are loaded. You can turn compression off with this option.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="DisableCleanup" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>As part of Costura, embedded assemblies are no longer included as part of the build. This cleanup can be turned off.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="LoadAtModuleInit" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>Costura by default will load as part of the module initialization. This flag disables that behavior. Make sure you call CosturaUtility.Initialize() somewhere in your code.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="IgnoreSatelliteAssemblies" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>Costura will by default use assemblies with a name like 'resources.dll' as a satellite resource and prepend the output path. This flag disables that behavior.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="ExcludeAssemblies" type="xs:string">
              <xs:annotation>
                <xs:documentation>A list of assembly names to exclude from the default action of "embed all Copy Local references", delimited with |</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="IncludeAssemblies" type="xs:string">
              <xs:annotation>
                <xs:documentation>A list of assembly names to include from the default action of "embed all Copy Local references", delimited with |.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="ExcludeRuntimeAssemblies" type="xs:string">
              <xs:annotation>
                <xs:documentation>A list of runtime assembly names to exclude from the default action of "embed all Copy Local references", delimited with |</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="IncludeRuntimeAssemblies" type="xs:string">
              <xs:annotation>
                <xs:documentation>A list of runtime assembly names to include from the default action of "embed all Copy Local references", delimited with |.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="Unmanaged32Assemblies" type="xs:string">
              <xs:annotation>
                <xs:documentation>A list of unmanaged 32 bit assembly names to include, delimited with |.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="Unmanaged64Assemblies" type="xs:string">
              <xs:annotation>
                <xs:documentation>A list of unmanaged 64 bit assembly names to include, delimited with |.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="PreloadOrder" type="xs:string">
              <xs:annotation>
                <xs:documentation>The order of preloaded assemblies, delimited with |.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
      </xs:all>
      <xs:attribute name="VerifyAssembly" type="xs:boolean">
        <xs:annotation>
          <xs:documentation>'true' to run assembly verification (PEVerify) on the target assembly after all weavers have been executed.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="VerifyIgnoreCodes" type="xs:string">
        <xs:annotation>
          <xs:documentation>A comma-separated list of error codes that can be safely ignored in assembly verification.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="GenerateXsd" type="xs:boolean">
        <xs:annotation>
          <xs:documentation>'false' to turn off automatic generation of the XML Schema file.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
    </xs:complexType>
  </xs:element>
</xs:schema>
```

`Il2CppRuntime/Il2CppRuntime.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="..\packages\Costura.Fody.5.3.0\build\Costura.Fody.props" Condition="Exists('..\packages\Costura.Fody.5.3.0\build\Costura.Fody.props')" />
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{5891A02F-EA9A-4EFD-BE5A-184A15F0E8B0}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>Il2CppRuntime</RootNamespace>
    <AssemblyName>Il2CppRuntime</AssemblyName>
    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <Deterministic>true</Deterministic>
    <NuGetPackageImportStamp>
    </NuGetPackageImportStamp>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\x64\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\x64\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup>
    <StartupObject>Il2CppRuntime.Program</StartupObject>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Costura, Version=5.3.0.0, Culture=neutral, processorArchitecture=MSIL">
      <HintPath>..\packages\Costura.Fody.5.3.0\lib\netstandard1.0\Costura.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Win32.Primitives, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.Win32.Primitives.4.3.0\lib\net46\Microsoft.Win32.Primitives.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="Mono.Cecil, Version=0.11.4.0, Culture=neutral, PublicKeyToken=50cebf1cceb9d05e, processorArchitecture=MSIL">
      <HintPath>..\packages\Mono.Cecil.0.11.4\lib\net40\Mono.Cecil.dll</HintPath>
    </Reference>
    <Reference Include="Mono.Cecil.Mdb, Version=0.11.4.0, Culture=neutral, PublicKeyToken=50cebf1cceb9d05e, processorArchitecture=MSIL">
      <HintPath>..\packages\Mono.Cecil.0.11.4\lib\net40\Mono.Cecil.Mdb.dll</HintPath>
    </Reference>
    <Reference Include="Mono.Cecil.Pdb, Version=0.11.4.0, Culture=neutral, PublicKeyToken=50cebf1cceb9d05e, processorArchitecture=MSIL">
      <HintPath>..\packages\Mono.Cecil.0.11.4\lib\net40\Mono.Cecil.Pdb.dll</HintPath>
    </Reference>
    <Reference Include="Mono.Cecil.Rocks, Version=0.11.4.0, Culture=neutral, PublicKeyToken=50cebf1cceb9d05e, processorArchitecture=MSIL">
      <HintPath>..\packages\Mono.Cecil.0.11.4\lib\net40\Mono.Cecil.Rocks.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.AppContext, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.AppContext.4.3.0\lib\net463\System.AppContext.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.ComponentModel.Composition" />
    <Reference Include="System.Console, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Console.4.3.0\lib\net46\System.Console.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Core" />
    <Reference Include="System.Diagnostics.DiagnosticSource, Version=4.0.1.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Diagnostics.DiagnosticSource.4.3.0\lib\net46\System.Diagnostics.DiagnosticSource.dll</HintPath>
    </Reference>
    <Reference Include="System.Diagnostics.Tracing, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Diagnostics.Tracing.4.3.0\lib\net462\System.Diagnostics.Tracing.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Drawing" />
    <Reference Include="System.Globalization.Calendars, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Globalization.Calendars.4.3.0\lib\net46\System.Globalization.Calendars.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.IO, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.IO.4.3.0\lib\net462\System.IO.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.IO.Compression, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b77a5c561934e089, processorArchitecture=MSIL">
      <HintPath>..\packages\System.IO.Compression.4.3.0\lib\net46\System.IO.Compression.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.IO.Compression.FileSystem" />
    <Reference Include="System.IO.Compression.ZipFile, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b77a5c561934e089, processorArchitecture=MSIL">
      <HintPath>..\packages\System.IO.Compression.ZipFile.4.3.0\lib\net46\System.IO.Compression.ZipFile.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.IO.FileSystem, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.IO.FileSystem.4.3.0\lib\net46\System.IO.FileSystem.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.IO.FileSystem.Primitives, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.IO.FileSystem.Primitives.4.3.0\lib\net46\System.IO.FileSystem.Primitives.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Linq, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Linq.4.3.0\lib\net463\System.Linq.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Linq.Expressions, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Linq.Expressions.4.3.0\lib\net463\System.Linq.Expressions.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Net.Http, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Net.Http.4.3.0\lib\net46\System.Net.Http.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Net.Sockets.4.3.0\lib\net46\System.Net.Sockets.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Numerics" />
    <Reference Include="System.Reflection, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Reflection.4.3.0\lib\net462\System.Reflection.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Runtime, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Runtime.4.3.0\lib\net462\System.Runtime.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Runtime.Extensions, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Runtime.Extensions.4.3.0\lib\net462\System.Runtime.Extensions.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Runtime.InteropServices, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Runtime.InteropServices.4.3.0\lib\net463\System.Runtime.InteropServices.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Runtime.InteropServices.RuntimeInformation, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Runtime.InteropServices.RuntimeInformation.4.3.0\lib\net45\System.Runtime.InteropServices.RuntimeInformation.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Security.Cryptography.Algorithms, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Security.Cryptography.Algorithms.4.3.0\lib\net463\System.Security.Cryptography.Algorithms.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Security.Cryptography.Encoding, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Security.Cryptography.Encoding.4.3.0\lib\net46\System.Security.Cryptography.Encoding.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Security.Cryptography.Primitives, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Security.Cryptography.Primitives.4.3.0\lib\net46\System.Security.Cryptography.Primitives.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Security.Cryptography.X509Certificates, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Security.Cryptography.X509Certificates.4.3.0\lib\net461\System.Security.Cryptography.X509Certificates.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Text.RegularExpressions, Version=4.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Text.RegularExpressions.4.3.0\lib\net463\System.Text.RegularExpressions.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
    <Reference Include="System.Xml.ReaderWriter, Version=4.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Xml.ReaderWriter.4.3.0\lib\net46\System.Xml.ReaderWriter.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Dumper\Dumper.cs" />
    <Compile Include="Dumper\Il2Cpp\Il2Cpp.cs" />
    <Compile Include="Dumper\Il2Cpp\Il2CppAssembly.cs" />
    <Compile Include="Dumper\Il2Cpp\Il2CppBase.cs" />
    <Compile Include="Dumper\Il2Cpp\Il2CppClass.cs" />
    <Compile Include="Dumper\Il2Cpp\Il2CppDummyDll.cs" />
    <Compile Include="Dumper\Il2Cpp\Il2CppField.cs" />
    <Compile Include="Dumper\Il2Cpp\Il2CppGenericContainer.cs" />
    <Compile Include="Dumper\Il2Cpp\Il2CppMethod.cs" />
    <Compile Include="Dumper\Il2Cpp\Il2CppObject.cs" />
    <Compile Include="Dumper\Il2Cpp\Il2CppProperty.cs" />
    <Compile Include="Dumper\Il2Cpp\Il2CppType.cs" />
    <Compile Include="NativeNetSharp.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="packages.config" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <Import Project="..\packages\Fody.6.5.1\build\Fody.targets" Condition="Exists('..\packages\Fody.6.5.1\build\Fody.targets')" />
  <Target Name="EnsureNuGetPackageBuildImports" BeforeTargets="PrepareForBuild">
    <PropertyGroup>
      <ErrorText>This project references NuGet package(s) that are missing on this computer. Use NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.</ErrorText>
    </PropertyGroup>
    <Error Condition="!Exists('..\packages\Fody.6.5.1\build\Fody.targets')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\Fody.6.5.1\build\Fody.targets'))" />
    <Error Condition="!Exists('..\packages\Costura.Fody.5.3.0\build\Costura.Fody.props')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\Costura.Fody.5.3.0\build\Costura.Fody.props'))" />
    <Error Condition="!Exists('..\packages\Costura.Fody.5.3.0\build\Costura.Fody.targets')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\Costura.Fody.5.3.0\build\Costura.Fody.targets'))" />
  </Target>
  <Import Project="..\packages\Costura.Fody.5.3.0\build\Costura.Fody.targets" Condition="Exists('..\packages\Costura.Fody.5.3.0\build\Costura.Fody.targets')" />
</Project>
```

`Il2CppRuntime/NativeNetSharp.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;

using System.IO;
using Microsoft.Win32.SafeHandles;

namespace Il2CppRuntime
{
    public unsafe static class NativeNetSharp
    {
        public delegate dynamic DynamicDelegate(params dynamic[] args);
        static ModuleBuilder moduleBuilder;
        public static IntPtr GetFunctionPointerForNativeCode(Action a)
        {
            var methodInfo = a.Method;
            if (moduleBuilder == null) moduleBuilder = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName("JitDelegateTypes"), AssemblyBuilderAccess.Run).DefineDynamicModule("JitDelegateTypes");
            var parameters = methodInfo.GetParameters().Select(x => x.ParameterType).ToArray();
            var builder = moduleBuilder.DefineType(methodInfo.Name + "Delegate", TypeAttributes.Class | TypeAttributes.Public | TypeAttributes.Sealed | TypeAttributes.AnsiClass | TypeAttributes.AutoClass, typeof(MulticastDelegate));
            builder.DefineConstructor(MethodAttributes.RTSpecialName | MethodAttributes.HideBySig | MethodAttributes.Public, CallingConventions.Standard, new Type[] { typeof(Object), typeof(IntPtr) }).SetImplementationFlags(MethodImplAttributes.Runtime | MethodImplAttributes.Managed);
            builder.DefineMethod("Invoke", MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Virtual, methodInfo.ReturnType, parameters).SetImplementationFlags(MethodImplAttributes.Runtime | MethodImplAttributes.Managed);
            var delegateType = builder.CreateTypeInfo();
            var dlg = Delegate.CreateDelegate(delegateType, null, methodInfo);
            return Marshal.GetFunctionPointerForDelegate<Delegate>(dlg);
        }
        public static T FastCallDelegate<T>(IntPtr functionPtr)
        {
            var wrapper = new List<Byte>();
            wrapper.Add(0x58);          // pop eax  - store the return address
            wrapper.Add(0x59);          // pop ecx  - move the 1st argument to ecx
            wrapper.Add(0x5A);          // pop edx  - move the 2nd argument to edx
            wrapper.Add(0x50);          // push eax - restore the return address
            wrapper.Add(0x68);                                                  // push ...
            wrapper.AddRange(BitConverter.GetBytes(functionPtr.ToInt32()));     // the function address to call
            wrapper.Add(0xC3);                                                  // ret - and jump to
            var wrapperPtr = Marshal.AllocHGlobal(wrapper.Count);
            Marshal.Copy(wrapper.ToArray(), 0, wrapperPtr, wrapper.Count);
            return Marshal.GetDelegateForFunctionPointer<T>(wrapperPtr);
        }
        public static void JmpPatch(IntPtr originalPtr, IntPtr replacement)
        {
            // todo fix
            throw new Exception("JmpPatch not supported");
            var origCodeLoc = Marshal.ReadIntPtr(originalPtr);
            var jmpToNew = new List<Byte>();
            if (Environment.Is64BitProcess)
            {
                jmpToNew.AddRange(new Byte[] { 0x49, 0xBB }); // mov r11, replacement
                jmpToNew.AddRange(BitConverter.GetBytes(replacement.ToInt64()));
                jmpToNew.AddRange(new Byte[] { 0x41, 0xFF, 0xE3 }); // jmp r11
            }
            else
            {
                jmpToNew.Add(0xB8); // mov eax
                jmpToNew.AddRange(BitConverter.GetBytes(replacement.ToInt32()));
                jmpToNew.AddRange(new Byte[] { 0xFF, 0xE0 }); // jmp eax
            }
            var origCode = new byte[0x12];
            Marshal.Copy(origCodeLoc, origCode, 0, origCode.Length);
            var jmpToOrig = new List<Byte>();
            jmpToOrig.AddRange(origCode);
            if (Environment.Is64BitProcess)
            {
                jmpToOrig.AddRange(new Byte[] { 0x49, 0xBB }); // mov r11, replacement
                jmpToOrig.AddRange(BitConverter.GetBytes((origCodeLoc + origCode.Length).ToInt64()));
                jmpToOrig.AddRange(new Byte[] { 0x41, 0xFF, 0xE3 }); // jmp r11
            }
            else
            {

            }
            var newFuncLocation = VirtualAllocEx(GetCurrentProcess(), IntPtr.Zero, 0x100, 0x3000, 0x40);
            Marshal.Copy(jmpToOrig.ToArray(), 0, newFuncLocation, jmpToOrig.ToArray().Length);

            VirtualProtect(origCodeLoc, (UIntPtr)jmpToNew.ToArray().Length, (UInt32)0x40, out UInt32 old);
            Marshal.Copy(jmpToNew.ToArray(), 0, origCodeLoc, jmpToNew.ToArray().Length);
            FlushInstructionCache(GetCurrentProcess(), origCodeLoc, (UIntPtr)jmpToNew.ToArray().Length);
            VirtualProtect(origCodeLoc, (UIntPtr)jmpToNew.ToArray().Length, old, out UInt32 _);

            Marshal.WriteIntPtr(originalPtr, newFuncLocation);
        }
        public static IntPtr baseAddress;
        public static IntPtr procHandle;
        public static Boolean target32Bit = false;
        public static void Inject(String procName, Byte[] exeBytes)
        {
            var CLSID_CLRMetaHost = new Guid("9280188D-0E8E-4867-B30C-7FA83884E8DE").ToByteArray();
            var IID_ICLRMetaHost = new Guid("D332DB9E-B9B3-4125-8207-A14884F53216").ToByteArray();
            var IID_ICLRRuntimeInfo = new Guid("BD39D1D2-BA2F-486A-89B0-B4B0CB466891").ToByteArray();
            var CLSID_CorRuntimeHost = new Guid("CB2F6723-AB3A-11D2-9C40-00C04FA30A3E").ToByteArray();
            var IID_ICorRuntimeHost = new Guid("CB2F6722-AB3A-11D2-9C40-00C04FA30A3E").ToByteArray();
            var _AppDomain = new Guid("05F696DC-2B29-3663-AD8B-C4389CF2A713").ToByteArray();
            var CLSID_CLRRuntimeHost = new Guid("90F1A06E-7712-4762-86B5-7A5EBA6BDB02").ToByteArray();
            var IID_ICLRRuntimeHost = new Guid("90F1A06C-7712-4762-86B5-7A5EBA6BDB02").ToByteArray();

            while (Process.GetProcessesByName(procName).Length == 0) { System.Threading.Thread.Sleep(500); }
            var targetProcess = Process.GetProcessesByName(procName)[0];
            procHandle = OpenProcess(0x43a, false, targetProcess.Id);
            if (procHandle == IntPtr.Zero) throw new Exception("can't open target process. try run as admin");
            baseAddress = GetBaseAddress();
            if (!IsWow64Process(procHandle, out target32Bit)) target32Bit = IntPtr.Size == 4;
            RemoteLoadLibrary("mscoree.dll");
            var ptrSize = target32Bit ? 4 : 8;

            var CLRCreateInstance = GetProcAddress("mscoree.dll", "CLRCreateInstance");
            var safeArray = CreateSafeArray(exeBytes.ToList());
            var metaHost = ExecFunc(CLRCreateInstance, CLSID_CLRMetaHost, IID_ICLRMetaHost, new Byte[0]);
            var runtime = ExecVTable(metaHost, 3 * ptrSize, Encoding.Unicode.GetBytes("v4.0.30319"), IID_ICLRRuntimeInfo, new Byte[0]);
            var runtimeHost = ExecVTable(runtime, 9 * ptrSize, CLSID_CorRuntimeHost, IID_ICorRuntimeHost, new Byte[0]);
            var started = ExecVTable(runtimeHost, 0xA * ptrSize);
            var domain = ExecVTable(runtimeHost, 0xD * ptrSize, new Byte[0]);
            var appDomain = ExecVTable(domain, 0, _AppDomain, new Byte[0]);
            var assembly = ExecVTable(appDomain, 0x2D * ptrSize, BitConverter.GetBytes((UInt64)safeArray), new Byte[0]);
            var method = ExecVTable(assembly, 0x10 * ptrSize, new Byte[0]);
            var variant = new Byte[0x18]; variant[0] = 1;
            var mainReturnVal = new Byte[0x18];
            var methodResult = ExecVTable(method, 0x25 * ptrSize, variant, new Byte[8], new Byte[8], new Byte[8], new Byte[8], mainReturnVal); // todo fix parameters... x86 has more?
            var val = BitConverter.ToUInt64(mainReturnVal, 8);
            //var released = ExecVTable(method, 2 * ptrSize); // not sure how this works if the app is still running.
            //VirtualFreeEx(procHandle, safeArray - 0x10, 0, 0x8000);
            //var stopped = ExecVTable(runtimeHost, 0xB * ptrSize); // not sure how this works if the app is still running.
        }
        [DllImport("kernel32")] static extern IntPtr GetCurrentProcess();
        [DllImport("kernel32")] static extern IntPtr OpenProcess(Int32 dwDesiredAccess, Boolean bInheritHandle, Int32 dwProcessId);
        [DllImport("kernel32")] static extern IntPtr GetModuleHandle(String lpModuleName);
        //[DllImport("kernel32")] static extern IntPtr GetProcAddress(IntPtr hModule, String procName);
        [DllImport("kernel32")] static extern Boolean FlushInstructionCache(IntPtr hProcess, IntPtr lpBaseAddress, UIntPtr dwSize);
        [DllImport("kernel32")] public static extern Boolean VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, UInt32 flNewProtect, out UInt32 lpflOldProtect);
        [DllImport("kernel32")] static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, Int32 dwSize, UInt32 flAllocationType, UInt32 flProtect);
        [DllImport("kernel32")] static extern Int32 ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, [In, Out] Byte[] buffer, Int32 size, out Int32 lpNumberOfBytesRead);
        [DllImport("kernel32")] static extern Boolean WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, Byte[] lpBuffer, Int32 nSize, out Int32 lpNumberOfBytesWritten);
        [DllImport("kernel32")] static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, UInt32 dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, UInt32 dwCreationFlags, IntPtr lpThreadId);
        [DllImport("kernel32")] static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);
        [DllImport("kernel32")] static extern Int32 CloseHandle(IntPtr hObject);
        [DllImport("kernel32")] static extern Boolean VirtualProtectEx(IntPtr hProcess, IntPtr lpAddress, Int32 dwSize, UInt32 flNewProtect, out UInt32 lpflOldProtect);
        [DllImport("kernel32")] static extern Boolean VirtualFreeEx(IntPtr hProcess, IntPtr lpAddress, Int32 dwSize, Int32 dwFreeType);
        [DllImport("kernel32")] static extern Boolean IsWow64Process(IntPtr processHandle, out Boolean wow64Process);
        [DllImport("psapi")] static extern bool GetModuleInformation(IntPtr hProcess, IntPtr hModule, out MODULEINFO lpmodinfo, UInt32 cb);
        [DllImport("psapi")] static extern bool EnumProcessModulesEx(IntPtr hProcess, IntPtr[] lphModule, UInt32 cb, out UInt32 lpcbNeeded, UInt32 dwFilterFlag);
        [DllImport("psapi")] static extern uint GetModuleFileNameEx(IntPtr hProcess, IntPtr hModule, [Out] StringBuilder lpBaseName, UInt32 nSize);
        [DllImport("kernel32")] public static extern IntPtr GetStdHandle(Int32 nStdHandle);
        [DllImport("kernel32")] public static extern int AllocConsole();
        [DllImport("kernel32")] public static extern int FreeConsole();
        [StructLayout(LayoutKind.Sequential)]
        public struct MODULEINFO
        {
            public IntPtr lpBaseOfDll;
            public UInt32 SizeOfImage;
            public IntPtr EntryPoint;
        }
        public static IntPtr CreateSafeArray(List<Byte> bytes)
        {
            var safeArray = VirtualAllocEx(procHandle, IntPtr.Zero, bytes.Count + 0x30, 0x1000, 4);
            var safeArrayBytes = new List<Byte>();
            safeArrayBytes.AddRange(BitConverter.GetBytes((UInt32)0)); // ??
            safeArrayBytes.AddRange(BitConverter.GetBytes((UInt32)0)); // ??
            safeArrayBytes.AddRange(BitConverter.GetBytes((UInt32)0)); // ??
            safeArrayBytes.AddRange(BitConverter.GetBytes((UInt32)0x11)); // arrayType... weird
            safeArrayBytes.AddRange(BitConverter.GetBytes((UInt16)1)); // cDims
            safeArrayBytes.AddRange(BitConverter.GetBytes((UInt16)0x80)); // fFeatures
            safeArrayBytes.AddRange(BitConverter.GetBytes((UInt32)1)); // cbElements
            safeArrayBytes.AddRange(BitConverter.GetBytes((UInt32)0)); // cLocks
            if (!target32Bit) safeArrayBytes.AddRange(BitConverter.GetBytes((UInt32)0)); // ???
            safeArrayBytes.AddRange(target32Bit ? BitConverter.GetBytes((Int32)safeArray + 0x28) : BitConverter.GetBytes((UInt64)safeArray + 0x30)); // pvData
            safeArrayBytes.AddRange(BitConverter.GetBytes((UInt32)bytes.Count)); // rgsabound numElements
            safeArrayBytes.AddRange(BitConverter.GetBytes((UInt32)0)); // rgsabound min
            safeArrayBytes.AddRange(bytes);
            WriteProcessMemory(procHandle, safeArray, safeArrayBytes.ToArray(), safeArrayBytes.Count, out _);
            return safeArray + 0x10;
        }
        public static IntPtr ExecVTable(IntPtr obj, Int32 offset, params Byte[][] args)
        {
            var methodAddr = ReadIntPtr(ReadIntPtr(obj) + offset);
            args = args.Prepend(BitConverter.GetBytes((UInt64)obj)).ToArray();
            return ExecFunc(methodAddr, args);
        }
        public static IntPtr ExecFunc(IntPtr funcAddr, params Byte[][] args)
        {
            var newArgs = new List<IntPtr>();
            foreach (var arg in args)
            {
                if (arg.Length == 8) newArgs.Add((IntPtr)(target32Bit ? BitConverter.ToInt32(arg, 0) : BitConverter.ToInt64(arg, 0))); // todo fix hack for direct args
                else
                {
                    var argLength = arg.Length == 0 ? 0x8 : arg.Length;
                    var argVal = arg;
                    if (arg.Length == 0)
                    {
                        argLength = target32Bit ? 4 : 8;
                        argVal = new byte[argLength];
                    }
                    var temp = VirtualAllocEx(procHandle, IntPtr.Zero, argLength, 0x3000, 0x40);
                    WriteProcessMemory(procHandle, temp, argVal, argLength, out _);
                    newArgs.Add(temp);
                }
            }
            var retVal = ExecFunc(funcAddr, newArgs.ToArray());
            for (var i = 0; i < args.Length; i++)
            {
                var arg = args[i];
                var argLength = arg.Length == 0 ? (target32Bit ? 4 : 8) : arg.Length;
                var buf = new Byte[argLength];
                if (args[i].Length == 8u) { }
                else
                {
                    ReadProcessMemory(procHandle, newArgs[i], buf, buf.Length, out _);
                    if (args[i].Length != argLength) Array.Resize(ref args[i], argLength);
                    Array.Copy(buf, args[i], argLength);
                    VirtualFreeEx(procHandle, newArgs[i], 0, 0x8000);
                }
            }
            if (retVal == IntPtr.Zero && args.ToList().Last().Length == (target32Bit ? 4u : 8u)) return (IntPtr)(target32Bit ? BitConverter.ToInt32(args.ToList().Last(), 0) : BitConverter.ToInt64(args.ToList().Last(), 0)); // todo fix hack for arg refs
            else return retVal;
        }
        public static IntPtr ExecFunc(IntPtr funcAddr, params IntPtr[] args)
        {
            var asm = new List<Byte>();
            var retVal = VirtualAllocEx(procHandle, IntPtr.Zero, 8, 0x3000, 4);
            WriteProcessMemory(procHandle, retVal, BitConverter.GetBytes(0xdeadbeefcafef00d), 8, out _);
            if (target32Bit)
            {
                for (var i = args.Length - 1; i >= 0; i--)
                {
                    asm.Add(0x68); // push
                    asm.AddRange(BitConverter.GetBytes((UInt32)args[i]));
                }
                asm.Add(0xB8); // mov eax
                asm.AddRange(BitConverter.GetBytes((UInt32)funcAddr));
                asm.AddRange(new Byte[] { 0xFF, 0xD0 }); // call eax
                // todo fix this?
                //asm.AddRange(new Byte[] { 0x83, 0xC4 }); // add esp
                //asm.Add((Byte)(args.Length * 4));
                asm.Add(0xA3); // mov eax to
                asm.AddRange(BitConverter.GetBytes((UInt32)retVal));
            }
            else
            {
                asm.AddRange(new Byte[] { 0x48, 0x83, 0xEC, 0x38 }); // sub rsp 0x38
                for (var i = 0; i < args.Length && i < 4; i++)
                {
                    if (i == 0) asm.AddRange(new Byte[] { 0x48, 0xB9 }); // mov rcx
                    if (i == 1) asm.AddRange(new Byte[] { 0x48, 0xBA }); // mov rdx
                    if (i == 2) asm.AddRange(new Byte[] { 0x49, 0xB8 }); // mov r8
                    if (i == 3) asm.AddRange(new Byte[] { 0x49, 0xB9 }); // mov r9
                    asm.AddRange(BitConverter.GetBytes((UInt64)args[i]));
                }
                for (var i = 4; i < args.Length; i++) // broke need to fix
                {
                    /*asm.Add(0x68);
                    asm.AddRange(BitConverter.GetBytes((UInt32)(UInt64)args[i]));
                    asm.Add(0x68);
                    asm.AddRange(BitConverter.GetBytes(((UInt64)args[i]) >> 32));*/
                }
                asm.AddRange(new Byte[] { 0x48, 0xB8 }); // mov rax
                asm.AddRange(BitConverter.GetBytes((UInt64)funcAddr));

                asm.AddRange(new Byte[] { 0xFF, 0xD0 }); // call rax
                asm.AddRange(new Byte[] { 0x48, 0x83, 0xC4, 0x38 }); // add rsp 0x38

                asm.AddRange(new Byte[] { 0x48, 0xA3 }); // mov rax to retval
                asm.AddRange(BitConverter.GetBytes((UInt64)retVal));
            }
            asm.AddRange(Enumerable.Range(0, 0x20).Select(a => (byte)0x90));
            asm.Add(0xC3); // ret
            var codePtr = VirtualAllocEx(procHandle, IntPtr.Zero, asm.Count, 0x3000, 0x40);
            WriteProcessMemory(procHandle, codePtr, asm.ToArray(), asm.Count, out _);
            var qq = BitConverter.ToString(asm.ToArray()).Replace("-", " ");
            var thread = CreateRemoteThread(procHandle, IntPtr.Zero, 0, codePtr, IntPtr.Zero, 0, IntPtr.Zero);
            WaitForSingleObject(thread, 10000);
            var buf = new Byte[target32Bit ? 4u : 8u];
            ReadProcessMemory(procHandle, retVal, buf, buf.Length, out _);
            VirtualFreeEx(procHandle, retVal, 0, 0x8000);
            VirtualFreeEx(procHandle, codePtr, 0, 0x8000);
            CloseHandle(thread);
            return (IntPtr)(target32Bit ? BitConverter.ToInt32(buf, 0) : BitConverter.ToInt64(buf, 0));
        }
        public static IntPtr ReadIntPtr(IntPtr addr)
        {
            var buf = new Byte[8];
            ReadProcessMemory(procHandle, addr, buf, buf.Length, out _);
            return (IntPtr)(target32Bit ? BitConverter.ToInt32(buf, 0) : BitConverter.ToInt64(buf, 0));
        }
        public static Int32 ReadInt32(IntPtr addr)
        {
            var temp = new Byte[4];
            ReadProcessMemory(procHandle, addr, temp, temp.Length, out _);
            return BitConverter.ToInt32(temp, 0);
        }
        public static IntPtr LoadLibraryA = IntPtr.Zero;
        public static void RemoteLoadLibrary(String dllName)
        {
            if (LoadLibraryA == IntPtr.Zero) LoadLibraryA = GetProcAddress("kernel32.dll", "LoadLibraryA");
            var allocMemAddress = VirtualAllocEx(procHandle, IntPtr.Zero, ((dllName.Length + 1) * Marshal.SizeOf(typeof(char))), 0x3000, 4);
            WriteProcessMemory(procHandle, allocMemAddress, Encoding.Default.GetBytes(dllName), ((dllName.Length + 1) * Marshal.SizeOf(typeof(char))), out _);
            var thread = CreateRemoteThread(procHandle, IntPtr.Zero, 0, LoadLibraryA, allocMemAddress, 0, IntPtr.Zero); WaitForSingleObject(thread, 10000);
            VirtualFreeEx(procHandle, allocMemAddress, 0, 0x8000);
        }
        public static IntPtr GetBaseAddress()
        {
            var ptrs = new IntPtr[1];
            EnumProcessModulesEx(procHandle, ptrs, target32Bit ? 4u : 8u, out _, 3);
            return ptrs[0];
        }
        public static IntPtr GetProcAddress(String dll, String procName)
        {
            var ptrs = new IntPtr[0];
            var q = EnumProcessModulesEx(procHandle, ptrs, 0, out UInt32 bytesNeeded, 3);
            var size = target32Bit ? 4 : 8;
            var moduleCount = bytesNeeded / size;
            ptrs = new IntPtr[moduleCount];
            EnumProcessModulesEx(procHandle, ptrs, bytesNeeded, out _, 3);
            for (var i = 0; i < moduleCount; i++)
            {
                var path = new StringBuilder(260);
                GetModuleFileNameEx(procHandle, ptrs[i], path, 260);

                if (path.ToString().ToLower().Contains(dll.ToLower()))
                {
                    GetModuleInformation(procHandle, ptrs[i], out MODULEINFO info, (uint)(size * ptrs.Length));
                    var e_lfanew = ReadInt32(info.lpBaseOfDll + 0x3C);
                    var ntHeaders = info.lpBaseOfDll + e_lfanew;
                    var optionalHeader = ntHeaders + 0x18;
                    var dataDirectory = optionalHeader + (target32Bit ? 0x60 : 0x70);
                    var exportDirectory = info.lpBaseOfDll + ReadInt32(dataDirectory);
                    var names = info.lpBaseOfDll + ReadInt32(exportDirectory + 0x20);
                    var ordinals = info.lpBaseOfDll + ReadInt32(exportDirectory + 0x24);
                    var functions = info.lpBaseOfDll + ReadInt32(exportDirectory + 0x1C);
                    var numFuncs = ReadInt32(exportDirectory + 0x18);

                    for (var j = 0; j < numFuncs; j++)
                    {
                        var offset = ReadInt32(names + j * 4);
                        var buffer = new Byte[32];
                        ReadProcessMemory(procHandle, info.lpBaseOfDll + offset, buffer, 32, out _);
                        var name = Encoding.UTF8.GetString(buffer);
                        if (name.Contains("\0")) name = name.Substring(0, name.IndexOf("\0"));
                        var ordinal = ReadInt32(ordinals + j * 2) & 0xFFFF;
                        var address = info.lpBaseOfDll + ReadInt32(functions + ordinal * 4);
                        if (name == procName) return address;
                    }
                }
            }
            return IntPtr.Zero;
        }
    }
}
```

`Il2CppRuntime/Program.cs`:

```cs
using System.Text;
using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using Microsoft.Win32.SafeHandles;
using Mono.Cecil;

namespace Il2CppRuntime
{
    public unsafe static class Program
    {
        static void Main()
        {
            if (Process.GetCurrentProcess().ProcessName == typeof(Program).Namespace)
            {
                var dll = AssemblyDefinition.ReadAssembly(Assembly.GetEntryAssembly().Location);
                var rand = Guid.NewGuid().ToString().Replace("-", "");
                dll.Name.Name += rand;
                dll.MainModule.Name += rand;
                dll.MainModule.Types.ToList().ForEach(t => t.Namespace += rand);
                var dllBytes = new Byte[0];
                using (var newDll = new MemoryStream())
                {
                    dll.Write(newDll);
                    dllBytes = newDll.ToArray();
                }
                NativeNetSharp.Inject("gameprocname", dllBytes);
            }
            else
            {
                try
                {
                    NativeNetSharp.AllocConsole();
                    var standardOutput = new StreamWriter(new FileStream(new SafeFileHandle(NativeNetSharp.GetStdHandle(-11), true), FileAccess.Write), Encoding.GetEncoding(437)) { AutoFlush = true };
                    Console.SetOut(standardOutput);
                    Console.WriteLine("C# DLL loaded");
                    Il2Cpp.Il2Cpp.il2cpp_thread_attach(Il2Cpp.Il2Cpp.il2cpp_domain_get());
                    Il2Cpp.Il2Cpp.InitAssemblies();
                    Il2Cpp.Dumper.Dump();
                }
                catch (Exception e)
                {
                    Console.WriteLine(e.Message.ToString());
                }
            }
        }
        [DllImport("kernel32")] static extern IntPtr LoadLibrary([MarshalAs(UnmanagedType.LPStr)] string lpFileName);
        [DllImport("kernel32")] static extern bool FlushInstructionCache(IntPtr hProcess, IntPtr lpBaseAddress, UIntPtr dwSize);
        [DllImport("kernel32")] static extern IntPtr GetCurrentProcess();
        [DllImport("kernel32")] static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);
        [DllImport("kernel32")] static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, Int32 dwSize, Int32 flAllocationType, Int32 flProtect);
        [DllImport("kernel32")] static extern IntPtr GetModuleHandle(string lpModuleName);
        public static void JmpPatch(IntPtr originalPtr, IntPtr replacement)
        {
            var origCodeLoc = Marshal.ReadIntPtr(originalPtr);
            var jmpToNew = new List<Byte>();
            jmpToNew.AddRange(new Byte[] { 0x49, 0xBB }); // mov r11, replacement
            jmpToNew.AddRange(BitConverter.GetBytes(replacement.ToInt64()));
            jmpToNew.AddRange(new Byte[] { 0x41, 0xFF, 0xE3 }); // jmp r11
            var origCode = new byte[0x12];
            Marshal.Copy(origCodeLoc, origCode, 0, origCode.Length);
            var jmpToOrig = new List<Byte>();
            jmpToOrig.AddRange(origCode);
            jmpToOrig.AddRange(new Byte[] { 0x49, 0xBB }); // mov r11, replacement
            jmpToOrig.AddRange(BitConverter.GetBytes((origCodeLoc + origCode.Length).ToInt64()));
            jmpToOrig.AddRange(new Byte[] { 0x41, 0xFF, 0xE3 }); // jmp r11
            var newFuncLocation = VirtualAllocEx(GetCurrentProcess(), IntPtr.Zero, 0x100, 0x3000, 0x40); // Marshal.Alloc doesn't work here?
            Marshal.Copy(jmpToOrig.ToArray(), 0, newFuncLocation, jmpToOrig.ToArray().Length);

            VirtualProtect(origCodeLoc, (UIntPtr)jmpToNew.ToArray().Length, (UInt32)0x40, out UInt32 old);
            Marshal.Copy(jmpToNew.ToArray(), 0, origCodeLoc, jmpToNew.ToArray().Length);
            FlushInstructionCache(GetCurrentProcess(), origCodeLoc, (UIntPtr)jmpToNew.ToArray().Length);
            VirtualProtect(origCodeLoc, (UIntPtr)jmpToNew.ToArray().Length, old, out UInt32 _);

            Marshal.WriteIntPtr(originalPtr, newFuncLocation);
        }
        public static void JmpUnPatch(IntPtr originalPtr, IntPtr replacement)
        {
            // todo
        }
        unsafe public static void Hook(IntPtr original, IntPtr target)
        {
            IntPtr originalPtr = original;
            IntPtr* targetVarPointer = &originalPtr;
            JmpPatch((IntPtr)targetVarPointer, target);
        }
    }
}

```

`Il2CppRuntime/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Il2CppRuntime")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("Il2CppRuntime")]
[assembly: AssemblyCopyright("Copyright ©  2020")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("5891a02f-ea9a-4efd-be5a-184a15f0e8b0")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`Il2CppRuntime/packages.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="Costura.Fody" version="5.3.0" targetFramework="net472" developmentDependency="true" />
  <package id="Fody" version="6.5.1" targetFramework="net472" developmentDependency="true" />
  <package id="Microsoft.NETCore.Platforms" version="1.1.0" targetFramework="net472" />
  <package id="Microsoft.Win32.Primitives" version="4.3.0" targetFramework="net472" />
  <package id="Mono.Cecil" version="0.11.4" targetFramework="net472" />
  <package id="NETStandard.Library" version="1.6.1" targetFramework="net472" />
  <package id="System.AppContext" version="4.3.0" targetFramework="net472" />
  <package id="System.Collections" version="4.3.0" targetFramework="net472" />
  <package id="System.Collections.Concurrent" version="4.3.0" targetFramework="net472" />
  <package id="System.Console" version="4.3.0" targetFramework="net472" />
  <package id="System.Diagnostics.Debug" version="4.3.0" targetFramework="net472" />
  <package id="System.Diagnostics.DiagnosticSource" version="4.3.0" targetFramework="net472" />
  <package id="System.Diagnostics.Tools" version="4.3.0" targetFramework="net472" />
  <package id="System.Diagnostics.Tracing" version="4.3.0" targetFramework="net472" />
  <package id="System.Globalization" version="4.3.0" targetFramework="net472" />
  <package id="System.Globalization.Calendars" version="4.3.0" targetFramework="net472" />
  <package id="System.IO" version="4.3.0" targetFramework="net472" />
  <package id="System.IO.Compression" version="4.3.0" targetFramework="net472" />
  <package id="System.IO.Compression.ZipFile" version="4.3.0" targetFramework="net472" />
  <package id="System.IO.FileSystem" version="4.3.0" targetFramework="net472" />
  <package id="System.IO.FileSystem.Primitives" version="4.3.0" targetFramework="net472" />
  <package id="System.Linq" version="4.3.0" targetFramework="net472" />
  <package id="System.Linq.Expressions" version="4.3.0" targetFramework="net472" />
  <package id="System.Net.Http" version="4.3.0" targetFramework="net472" />
  <package id="System.Net.Primitives" version="4.3.0" targetFramework="net472" />
  <package id="System.Net.Sockets" version="4.3.0" targetFramework="net472" />
  <package id="System.ObjectModel" version="4.3.0" targetFramework="net472" />
  <package id="System.Reflection" version="4.3.0" targetFramework="net472" />
  <package id="System.Reflection.Extensions" version="4.3.0" targetFramework="net472" />
  <package id="System.Reflection.Primitives" version="4.3.0" targetFramework="net472" />
  <package id="System.Resources.ResourceManager" version="4.3.0" targetFramework="net472" />
  <package id="System.Runtime" version="4.3.0" targetFramework="net472" />
  <package id="System.Runtime.Extensions" version="4.3.0" targetFramework="net472" />
  <package id="System.Runtime.Handles" version="4.3.0" targetFramework="net472" />
  <package id="System.Runtime.InteropServices" version="4.3.0" targetFramework="net472" />
  <package id="System.Runtime.InteropServices.RuntimeInformation" version="4.3.0" targetFramework="net472" />
  <package id="System.Runtime.Numerics" version="4.3.0" targetFramework="net472" />
  <package id="System.Security.Cryptography.Algorithms" version="4.3.0" targetFramework="net472" />
  <package id="System.Security.Cryptography.Encoding" version="4.3.0" targetFramework="net472" />
  <package id="System.Security.Cryptography.Primitives" version="4.3.0" targetFramework="net472" />
  <package id="System.Security.Cryptography.X509Certificates" version="4.3.0" targetFramework="net472" />
  <package id="System.Text.Encoding" version="4.3.0" targetFramework="net472" />
  <package id="System.Text.Encoding.Extensions" version="4.3.0" targetFramework="net472" />
  <package id="System.Text.RegularExpressions" version="4.3.0" targetFramework="net472" />
  <package id="System.Threading" version="4.3.0" targetFramework="net472" />
  <package id="System.Threading.Tasks" version="4.3.0" targetFramework="net472" />
  <package id="System.Threading.Timer" version="4.3.0" targetFramework="net472" />
  <package id="System.Xml.ReaderWriter" version="4.3.0" targetFramework="net472" />
  <package id="System.Xml.XDocument" version="4.3.0" targetFramework="net472" />
</packages>
```

`Il2CppRuntimeDumper.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30320.27
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Il2CppRuntime", "Il2CppRuntime\Il2CppRuntime.csproj", "{5891A02F-EA9A-4EFD-BE5A-184A15F0E8B0}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{5891A02F-EA9A-4EFD-BE5A-184A15F0E8B0}.Debug|x64.ActiveCfg = Debug|x64
		{5891A02F-EA9A-4EFD-BE5A-184A15F0E8B0}.Debug|x64.Build.0 = Debug|x64
		{5891A02F-EA9A-4EFD-BE5A-184A15F0E8B0}.Release|x64.ActiveCfg = Release|x64
		{5891A02F-EA9A-4EFD-BE5A-184A15F0E8B0}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {0CA56BAB-F351-47D7-8E62-F315B1A732A5}
	EndGlobalSection
EndGlobal

```

`LICENSE`:

```
MIT License

Copyright (c) 2021 shalzuth

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Il2CppRuntimeDumper
 This project shows example code of how to dump out il2cpp assemblies from memory. This is useful for apps where the metadata is encrypted.
 
# How does this work
 The method heavily relies on the il2cpp reflection system, and uses il2cpp calls to reconstruct the dll's
 
# Known issues
 Game crashes - hopefully only after it dumps the game
 
 Invalid DLLs - it's still not perfect, feel free to drop a PR
 
 Can't compile - restore nuget packages with "dotnet restore"

# Todo
 Add memory location scripts for inclusion into IDA (like il2cppdumper has)
 
 Fix DLL generation to be 1:1 with il2cppdumper
 
 Remove lots of bad debug code

# Credits
 knah - AssemblyUnhollower (which this can be used with) & other help
 
 perfare / Jumboperson - for the original il2cppdumper
 
```