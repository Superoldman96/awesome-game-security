Project Path: arc_gmh5225_oxide_7u1l9or_

Source Tree:

```txt
arc_gmh5225_oxide_7u1l9or_
├── Cargo.lock
├── Cargo.toml
├── config
│   ├── oxide.toml
│   └── worlds.toml
├── sql
│   ├── accounts.sql
│   └── characters.sql
└── src
    ├── character
    │   ├── mod.rs
    │   └── pet.rs
    ├── client.rs
    ├── config.rs
    ├── crypto
    │   ├── cipher.rs
    │   ├── mod.rs
    │   └── shanda.rs
    ├── db.rs
    ├── handler
    │   ├── after_login.rs
    │   ├── character_list.rs
    │   ├── login.rs
    │   ├── mod.rs
    │   ├── register_pin.rs
    │   ├── unknown.rs
    │   ├── world_list.rs
    │   └── world_status.rs
    ├── login
    │   ├── handlers.rs
    │   ├── mod.rs
    │   ├── packets.rs
    │   ├── queries.rs
    │   └── server.rs
    ├── main.rs
    ├── net
    │   ├── codec.rs
    │   ├── connection.rs
    │   ├── mod.rs
    │   └── packet.rs
    ├── shutdown.rs
    └── world.rs

```

`Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "aes"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bfe0133578c0986e1fe3dfcd4af1cc5b2dd6c3dbf534d69916ce16a2701d40ba"
dependencies = [
 "cfg-if",
 "cipher",
 "cpufeatures",
]

[[package]]
name = "ahash"
version = "0.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fcb51a0695d8f838b1ee009b3fbf66bda078cd64590202a864a8f3e8c4315c47"
dependencies = [
 "getrandom",
 "once_cell",
 "version_check",
]

[[package]]
name = "atoi"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "616896e05fc0e2649463a93a15183c6a16bf03413a7af88ef1285ddedfa9cda5"
dependencies = [
 "num-traits",
]

[[package]]
name = "atty"
version = "0.2.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8"
dependencies = [
 "hermit-abi",
 "libc",
 "winapi",
]

[[package]]
name = "autocfg"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa"

[[package]]
name = "base64"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "904dfeac50f3cdaba28fc6f57fdcddb75f49ed61346676a78c4ffe55877802fd"

[[package]]
name = "base64ct"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a32fd6af2b5827bce66c29053ba0e7c42b9dcab01835835058558c10851a46b"

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "block-buffer"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4152116fd6e9dadb291ae18fc1ec3575ed6d84c29642d97890f4b4a3417297e4"
dependencies = [
 "generic-array",
]

[[package]]
name = "block-buffer"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "03588e54c62ae6d763e2a80090d50353b785795361b4ff5b3bf0a5097fc31c0b"
dependencies = [
 "generic-array",
]

[[package]]
name = "bumpalo"
version = "3.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4a45a46ab1f2412e53d3a0ade76ffad2025804294569aae387231a0cd6e0899"

[[package]]
name = "byteorder"
version = "1.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "14c189c53d098945499cdfa7ecc63567cf3886b3332b312a5b4585d8d3a6a610"

[[package]]
name = "bytes"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c4872d67bab6358e59559027aa3b9157c53d9358c51423c17554809a8858e0f8"

[[package]]
name = "cc"
version = "1.0.72"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22a9137b95ea06864e018375b72adfb7db6e6f68cfc8df5a04d00288050485ee"

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "cipher"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d1873270f8f7942c191139cb8a40fd228da6c3fd2fc376d7e92d47aa14aeb59e"
dependencies = [
 "crypto-common",
 "inout",
]

[[package]]
name = "colored"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b3616f750b84d8f0de8a58bda93e08e2a81ad3f523089b05f1dffecab48c6cbd"
dependencies = [
 "atty",
 "lazy_static",
 "winapi",
]

[[package]]
name = "core-foundation"
version = "0.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "194a7a9e6de53fa55116934067c844d9d749312f75c6f6d0980e8c252f8c2146"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "core-foundation-sys"
version = "0.8.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5827cebf4670468b8772dd191856768aedcb1b0278a04f989f7766351917b9dc"

[[package]]
name = "cpufeatures"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "95059428f66df56b63431fdb4e1947ed2190586af5c5a8a8b71122bdf5a7f469"
dependencies = [
 "libc",
]

[[package]]
name = "crc"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49fc9a695bca7f35f5f4c15cddc84415f66a74ea78eef08e90c5024f2b540e23"
dependencies = [
 "crc-catalog",
]

[[package]]
name = "crc-catalog"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ccaeedb56da03b09f598226e25e80088cb4cd25f316e6e4df7d695f0feeb1403"

[[package]]
name = "crossbeam-queue"
version = "0.3.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4dd435b205a4842da59efd07628f921c096bc1cc0a156835b4fa0bcb9a19bcce"
dependencies = [
 "cfg-if",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-utils"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b5e5bed1f1c269533fa816a0a5492b3545209a205ca1a54842be180eb63a16a6"
dependencies = [
 "cfg-if",
 "lazy_static",
]

[[package]]
name = "crypto-common"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "57952ca27b5e3606ff4dd79b0020231aaf9d6aa76dc05fd30137538c50bd3ce8"
dependencies = [
 "generic-array",
 "typenum",
]

[[package]]
name = "crypto-mac"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b1d1a86f49236c215f271d40892d5fc950490551400b02ef360692c29815c714"
dependencies = [
 "generic-array",
 "subtle",
]

[[package]]
name = "digest"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3dd60d1080a57a05ab032377049e0591415d2b31afd7028356dbf3cc6dcb066"
dependencies = [
 "generic-array",
]

[[package]]
name = "digest"
version = "0.10.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2fb860ca6fafa5552fb6d0e816a69c8e49f0908bf524e30a90d97c85892d506"
dependencies = [
 "block-buffer 0.10.1",
 "crypto-common",
 "subtle",
]

[[package]]
name = "dirs"
version = "4.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ca3aa72a6f96ea37bbc5aa912f6788242832f75369bdfdadcb0e38423f100059"
dependencies = [
 "dirs-sys",
]

[[package]]
name = "dirs-sys"
version = "0.3.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "03d86534ed367a67548dc68113a0f5db55432fdfbb6e6f9d77704397d95d5780"
dependencies = [
 "libc",
 "redox_users",
 "winapi",
]

[[package]]
name = "dotenv"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77c90badedccf4105eca100756a0b1289e191f6fcbdadd3cee1d2f614f97da8f"

[[package]]
name = "either"
version = "1.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e78d4f1cc4ae33bbfc157ed5d5a5ef3bc29227303d595861deb238fcec4e9457"

[[package]]
name = "fastrand"
version = "1.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3fcf0cee53519c866c09b5de1f6c56ff9d647101f81c1964fa632e148896cdf"
dependencies = [
 "instant",
]

[[package]]
name = "foreign-types"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6f339eb8adc052cd2ca78910fda869aefa38d22d5cb648e6485e4d3fc06f3b1"
dependencies = [
 "foreign-types-shared",
]

[[package]]
name = "foreign-types-shared"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00b0228411908ca8685dba7fc2cdd70ec9990a6e753e89b6ac91a84c40fbaf4b"

[[package]]
name = "form_urlencoded"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5fc25a87fa4fd2094bffb06925852034d90a17f0d1e05197d4956d3555752191"
dependencies = [
 "matches",
 "percent-encoding",
]

[[package]]
name = "futures"
version = "0.3.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f73fe65f54d1e12b726f517d3e2135ca3125a437b6d998caf1962961f7172d9e"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-executor",
 "futures-io",
 "futures-sink",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-channel"
version = "0.3.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3083ce4b914124575708913bca19bfe887522d6e2e6d0952943f5eac4a74010"
dependencies = [
 "futures-core",
 "futures-sink",
]

[[package]]
name = "futures-core"
version = "0.3.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0c09fd04b7e4073ac7156a9539b57a484a8ea920f79c7c675d05d289ab6110d3"

[[package]]
name = "futures-executor"
version = "0.3.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9420b90cfa29e327d0429f19be13e7ddb68fa1cccb09d65e5706b8c7a749b8a6"
dependencies = [
 "futures-core",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-intrusive"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62007592ac46aa7c2b6416f7deb9a8a8f63a01e0f1d6e1787d5630170db2b63e"
dependencies = [
 "futures-core",
 "lock_api",
 "parking_lot 0.11.2",
]

[[package]]
name = "futures-io"
version = "0.3.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc4045962a5a5e935ee2fdedaa4e08284547402885ab326734432bed5d12966b"

[[package]]
name = "futures-macro"
version = "0.3.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33c1e13800337f4d4d7a316bf45a567dbcb6ffe087f16424852d97e97a91f512"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "futures-sink"
version = "0.3.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "21163e139fa306126e6eedaf49ecdb4588f939600f0b1e770f4205ee4b7fa868"

[[package]]
name = "futures-task"
version = "0.3.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "57c66a976bf5909d801bbef33416c41372779507e7a6b3a5e25e4749c58f776a"

[[package]]
name = "futures-util"
version = "0.3.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d8b7abd5d659d9b90c8cba917f6ec750a74e2dc23902ef9cd4cc8c8b22e6036a"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-io",
 "futures-macro",
 "futures-sink",
 "futures-task",
 "memchr",
 "pin-project-lite",
 "pin-utils",
 "slab",
]

[[package]]
name = "generic-array"
version = "0.14.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fd48d33ec7f05fbfa152300fdad764757cbded343c1aa1cff2fbaf4134851803"
dependencies = [
 "typenum",
 "version_check",
]

[[package]]
name = "getrandom"
version = "0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "418d37c8b1d42553c93648be529cb70f920d3baf8ef469b74b9638df426e0b4c"
dependencies = [
 "cfg-if",
 "libc",
 "wasi",
]

[[package]]
name = "hashbrown"
version = "0.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ab5ef0d4909ef3724cc8cce6ccc8572c5c817592e9285f5464f8e86f8bd3726e"
dependencies = [
 "ahash",
]

[[package]]
name = "hashlink"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7249a3129cbc1ffccd74857f81464a323a152173cdb134e0fd81bc803b29facf"
dependencies = [
 "hashbrown",
]

[[package]]
name = "heck"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6d621efb26863f0e9924c6ac577e8275e5e6b77455db64ffa6c65c904e9e132c"
dependencies = [
 "unicode-segmentation",
]

[[package]]
name = "hermit-abi"
version = "0.1.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62b467343b94ba476dcb2500d242dadbb39557df889310ac77c5d99100aaac33"
dependencies = [
 "libc",
]

[[package]]
name = "hex"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"

[[package]]
name = "hmac"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2a2a2320eb7ec0ebe8da8f744d7812d9fc4cb4d09344ac01898dbcb6a20ae69b"
dependencies = [
 "crypto-mac",
 "digest 0.9.0",
]

[[package]]
name = "hmac"
version = "0.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ddca131f3e7f2ce2df364b57949a9d47915cfbd35e46cfee355ccebbf794d6a2"
dependencies = [
 "digest 0.10.3",
]

[[package]]
name = "idna"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "418a0a6fab821475f634efe3ccc45c013f742efe03d853e8d3355d5cb850ecf8"
dependencies = [
 "matches",
 "unicode-bidi",
 "unicode-normalization",
]

[[package]]
name = "indexmap"
version = "1.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282a6247722caba404c065016bbfa522806e51714c34f5dfc3e4a3a46fcb4223"
dependencies = [
 "autocfg",
 "hashbrown",
]

[[package]]
name = "inout"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e1f03d4ab4d5dc9ec2d219f86c15d2a15fc08239d1cd3b2d6a19717c0a2f443"
dependencies = [
 "generic-array",
]

[[package]]
name = "instant"
version = "0.1.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a5bbe824c507c5da5956355e86a746d82e0e1464f65d862cc5e71da70e94b2c"
dependencies = [
 "cfg-if",
]

[[package]]
name = "itertools"
version = "0.10.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a9a9d19fa1e79b6215ff29b9d6880b706147f16e9b1dbb1e4e5947b5b02bc5e3"
dependencies = [
 "either",
]

[[package]]
name = "itoa"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1aab8fc367588b89dcee83ab0fd66b72b50b72fa1904d7095045ace2b0c81c35"

[[package]]
name = "js-sys"
version = "0.3.56"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a38fc24e30fd564ce974c02bf1d337caddff65be6cc4735a1f7eab22a7440f04"
dependencies = [
 "wasm-bindgen",
]

[[package]]
name = "lazy_static"
version = "1.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646"

[[package]]
name = "libc"
version = "0.2.117"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e74d72e0f9b65b5b4ca49a346af3976df0f9c61d550727f349ecd559f251a26c"

[[package]]
name = "lock_api"
version = "0.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "88943dd7ef4a2e5a4bfa2753aaab3013e34ce2533d1996fb18ef591e315e2b3b"
dependencies = [
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "51b9bbe6c47d51fc3e1a9b945965946b4c44142ab8792c50835a980d362c2710"
dependencies = [
 "cfg-if",
]

[[package]]
name = "matches"
version = "0.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a3e378b66a060d48947b590737b30a1be76706c8dd7b8ba0f2fe3989c68a853f"

[[package]]
name = "md-5"
version = "0.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7b5a279bb9607f9f53c22d496eade00d138d1bdcccd07d74650387cf94942a15"
dependencies = [
 "block-buffer 0.9.0",
 "digest 0.9.0",
 "opaque-debug",
]

[[package]]
name = "memchr"
version = "2.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "308cc39be01b73d0d18f82a0e7b2a3df85245f84af96fdddc5d202d27e47b86a"

[[package]]
name = "minimal-lexical"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"

[[package]]
name = "mio"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba272f85fa0b41fc91872be579b3bbe0f56b792aa361a380eb669469f68dafb2"
dependencies = [
 "libc",
 "log",
 "miow",
 "ntapi",
 "winapi",
]

[[package]]
name = "miow"
version = "0.3.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9f1c5b025cda876f66ef43a113f91ebc9f4ccef34843000e0adf6ebbab84e21"
dependencies = [
 "winapi",
]

[[package]]
name = "native-tls"
version = "0.2.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48ba9f7719b5a0f42f338907614285fb5fd70e53858141f69898a1fb7203b24d"
dependencies = [
 "lazy_static",
 "libc",
 "log",
 "openssl",
 "openssl-probe",
 "openssl-sys",
 "schannel",
 "security-framework",
 "security-framework-sys",
 "tempfile",
]

[[package]]
name = "nom"
version = "7.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b1d11e1ef389c76fe5b81bcaf2ea32cf88b62bc494e19f493d0b30e7a930109"
dependencies = [
 "memchr",
 "minimal-lexical",
 "version_check",
]

[[package]]
name = "ntapi"
version = "0.3.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f6bb902e437b6d86e03cce10a7e2af662292c5dfef23b65899ea3ac9354ad44"
dependencies = [
 "winapi",
]

[[package]]
name = "num-traits"
version = "0.2.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a64b1ec5cda2586e284722486d802acf1f7dbdc623e2bfc57e65ca1cd099290"
dependencies = [
 "autocfg",
]

[[package]]
name = "num_cpus"
version = "1.13.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "19e64526ebdee182341572e50e9ad03965aa510cd94427a4549448f285e957a1"
dependencies = [
 "hermit-abi",
 "libc",
]

[[package]]
name = "num_threads"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97ba99ba6393e2c3734791401b66902d981cb03bf190af674ca69949b6d5fb15"
dependencies = [
 "libc",
]

[[package]]
name = "once_cell"
version = "1.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "da32515d9f6e6e489d7bc9d84c71b060db7247dc035bbe44eac88cf87486d8d5"

[[package]]
name = "opaque-debug"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "624a8340c38c1b80fd549087862da4ba43e08858af025b236e509b6649fc13d5"

[[package]]
name = "openssl"
version = "0.10.38"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0c7ae222234c30df141154f159066c5093ff73b63204dcda7121eb082fc56a95"
dependencies = [
 "bitflags",
 "cfg-if",
 "foreign-types",
 "libc",
 "once_cell",
 "openssl-sys",
]

[[package]]
name = "openssl-probe"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ff011a302c396a5197692431fc1948019154afc178baf7d8e37367442a4601cf"

[[package]]
name = "openssl-sys"
version = "0.9.72"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7e46109c383602735fa0a2e48dd2b7c892b048e1bf69e5c3b1d804b7d9c203cb"
dependencies = [
 "autocfg",
 "cc",
 "libc",
 "pkg-config",
 "vcpkg",
]

[[package]]
name = "oxide"
version = "0.1.0"
dependencies = [
 "aes",
 "bytes",
 "dotenv",
 "futures",
 "lazy_static",
 "log",
 "pbkdf2",
 "rand",
 "serde",
 "simple_logger",
 "sqlx",
 "tokio",
 "tokio-stream",
 "tokio-util",
 "toml",
]

[[package]]
name = "parking_lot"
version = "0.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7d17b78036a60663b797adeaee46f5c9dfebb86948d1255007a1d6be0271ff99"
dependencies = [
 "instant",
 "lock_api",
 "parking_lot_core 0.8.5",
]

[[package]]
name = "parking_lot"
version = "0.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87f5ec2493a61ac0506c0f4199f99070cbe83857b0337006a30f3e6719b8ef58"
dependencies = [
 "lock_api",
 "parking_lot_core 0.9.1",
]

[[package]]
name = "parking_lot_core"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d76e8e1493bcac0d2766c42737f34458f1c8c50c0d23bcb24ea953affb273216"
dependencies = [
 "cfg-if",
 "instant",
 "libc",
 "redox_syscall",
 "smallvec",
 "winapi",
]

[[package]]
name = "parking_lot_core"
version = "0.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "28141e0cc4143da2443301914478dc976a61ffdb3f043058310c70df2fed8954"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall",
 "smallvec",
 "windows-sys",
]

[[package]]
name = "password-hash"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1d791538a6dcc1e7cb7fe6f6b58aca40e7f79403c45b2bc274008b5e647af1d8"
dependencies = [
 "base64ct",
 "rand_core",
 "subtle",
]

[[package]]
name = "paste"
version = "1.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0744126afe1a6dd7f394cb50a716dbe086cb06e255e53d8d0185d82828358fb5"

[[package]]
name = "pbkdf2"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "271779f35b581956db91a3e55737327a03aa051e90b1c47aeb189508533adfd7"
dependencies = [
 "digest 0.10.3",
 "hmac 0.12.0",
 "password-hash",
 "sha2 0.10.1",
]

[[package]]
name = "percent-encoding"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d4fd5641d01c8f18a23da7b6fe29298ff4b55afcccdf78973b24cf3175fee32e"

[[package]]
name = "pin-project-lite"
version = "0.2.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e280fbe77cc62c91527259e9442153f4688736748d24660126286329742b4c6c"

[[package]]
name = "pin-utils"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"

[[package]]
name = "pkg-config"
version = "0.3.24"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "58893f751c9b0412871a09abd62ecd2a00298c6c83befa223ef98c52aef40cbe"

[[package]]
name = "ppv-lite86"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eb9f9e6e233e5c4a35559a617bf40a4ec447db2e84c20b55a6f83167b7e57872"

[[package]]
name = "proc-macro2"
version = "1.0.36"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c7342d5883fbccae1cc37a2353b09c87c9b0f3afd73f5fb9bba687a1f733b029"
dependencies = [
 "unicode-xid",
]

[[package]]
name = "quote"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "864d3e96a899863136fc6e99f3d7cae289dafe43bf2c5ac19b70df7210c0a145"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "libc",
 "rand_chacha",
 "rand_core",
]

[[package]]
name = "rand_chacha"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
dependencies = [
 "ppv-lite86",
 "rand_core",
]

[[package]]
name = "rand_core"
version = "0.6.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d34f1408f55294453790c48b2f1ebbb1c5b4b7563eb1f418bcfcfdbb06ebb4e7"
dependencies = [
 "getrandom",
]

[[package]]
name = "redox_syscall"
version = "0.2.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8383f39639269cde97d255a32bdb68c047337295414940c68bdd30c2e13203ff"
dependencies = [
 "bitflags",
]

[[package]]
name = "redox_users"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "528532f3d801c87aec9def2add9ca802fe569e44a544afe633765267840abe64"
dependencies = [
 "getrandom",
 "redox_syscall",
]

[[package]]
name = "remove_dir_all"
version = "0.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3acd125665422973a33ac9d3dd2df85edad0f4ae9b00dafb1a05e43a9f5ef8e7"
dependencies = [
 "winapi",
]

[[package]]
name = "ryu"
version = "1.0.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "73b4b750c782965c211b42f022f59af1fbceabdd026623714f104152f1ec149f"

[[package]]
name = "schannel"
version = "0.1.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f05ba609c234e60bee0d547fe94a4c7e9da733d1c962cf6e59efa4cd9c8bc75"
dependencies = [
 "lazy_static",
 "winapi",
]

[[package]]
name = "scopeguard"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd"

[[package]]
name = "security-framework"
version = "2.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2dc14f172faf8a0194a3aded622712b0de276821addc574fa54fc0a1167e10dc"
dependencies = [
 "bitflags",
 "core-foundation",
 "core-foundation-sys",
 "libc",
 "security-framework-sys",
]

[[package]]
name = "security-framework-sys"
version = "2.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0160a13a177a45bfb43ce71c01580998474f556ad854dcbca936dd2841a5c556"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "serde"
version = "1.0.136"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ce31e24b01e1e524df96f1c2fdd054405f8d7376249a5110886fb4b658484789"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.136"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08597e7152fcd306f41838ed3e37be9eaeed2b61c42e2117266a554fab4662f9"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "serde_json"
version = "1.0.79"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e8d9fa5c3b304765ce1fd9c4c8a3de2c8db365a5b91be52f186efc675681d95"
dependencies = [
 "itoa",
 "ryu",
 "serde",
]

[[package]]
name = "sha-1"
version = "0.9.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "99cd6713db3cf16b6c84e06321e049a9b9f699826e16096d23bbcc44d15d51a6"
dependencies = [
 "block-buffer 0.9.0",
 "cfg-if",
 "cpufeatures",
 "digest 0.9.0",
 "opaque-debug",
]

[[package]]
name = "sha2"
version = "0.9.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4d58a1e1bf39749807d89cf2d98ac2dfa0ff1cb3faa38fbb64dd88ac8013d800"
dependencies = [
 "block-buffer 0.9.0",
 "cfg-if",
 "cpufeatures",
 "digest 0.9.0",
 "opaque-debug",
]

[[package]]
name = "sha2"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "99c3bd8169c58782adad9290a9af5939994036b76187f7b4f0e6de91dbbfc0ec"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest 0.10.3",
]

[[package]]
name = "signal-hook-registry"
version = "1.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e51e73328dc4ac0c7ccbda3a494dfa03df1de2f46018127f60c693f2648455b0"
dependencies = [
 "libc",
]

[[package]]
name = "simple_logger"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c75a9723083573ace81ad0cdfc50b858aa3c366c48636edb4109d73122a0c0ea"
dependencies = [
 "atty",
 "colored",
 "log",
 "time",
 "winapi",
]

[[package]]
name = "slab"
version = "0.4.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9def91fd1e018fe007022791f865d0ccc9b3a0d5001e01aabb8b40e46000afb5"

[[package]]
name = "smallvec"
version = "1.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2dd574626839106c320a323308629dcb1acfc96e32a8cba364ddc61ac23ee83"

[[package]]
name = "socket2"
version = "0.4.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "66d72b759436ae32898a2af0a14218dbf55efde3feeb170eb623637db85ee1e0"
dependencies = [
 "libc",
 "winapi",
]

[[package]]
name = "sqlformat"
version = "0.1.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b4b7922be017ee70900be125523f38bdd644f4f06a1b16e8fa5a8ee8c34bffd4"
dependencies = [
 "itertools",
 "nom",
 "unicode_categories",
]

[[package]]
name = "sqlx"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc15591eb44ffb5816a4a70a7efd5dd87bfd3aa84c4c200401c4396140525826"
dependencies = [
 "sqlx-core",
 "sqlx-macros",
]

[[package]]
name = "sqlx-core"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "195183bf6ff8328bb82c0511a83faf60aacf75840103388851db61d7a9854ae3"
dependencies = [
 "ahash",
 "atoi",
 "base64",
 "bitflags",
 "byteorder",
 "bytes",
 "crc",
 "crossbeam-queue",
 "dirs",
 "either",
 "futures-channel",
 "futures-core",
 "futures-intrusive",
 "futures-util",
 "hashlink",
 "hex",
 "hmac 0.11.0",
 "indexmap",
 "itoa",
 "libc",
 "log",
 "md-5",
 "memchr",
 "once_cell",
 "paste",
 "percent-encoding",
 "rand",
 "serde",
 "serde_json",
 "sha-1",
 "sha2 0.9.9",
 "smallvec",
 "sqlformat",
 "sqlx-rt",
 "stringprep",
 "thiserror",
 "tokio-stream",
 "url",
 "whoami",
]

[[package]]
name = "sqlx-macros"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eee35713129561f5e55c554bba1c378e2a7e67f81257b7311183de98c50e6f94"
dependencies = [
 "dotenv",
 "either",
 "heck",
 "once_cell",
 "proc-macro2",
 "quote",
 "sha2 0.9.9",
 "sqlx-core",
 "sqlx-rt",
 "syn",
 "url",
]

[[package]]
name = "sqlx-rt"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b555e70fbbf84e269ec3858b7a6515bcfe7a166a7cc9c636dd6efd20431678b6"
dependencies = [
 "native-tls",
 "once_cell",
 "tokio",
 "tokio-native-tls",
]

[[package]]
name = "stringprep"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ee348cb74b87454fff4b551cbf727025810a004f88aeacae7f85b87f4e9a1c1"
dependencies = [
 "unicode-bidi",
 "unicode-normalization",
]

[[package]]
name = "subtle"
version = "2.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6bdef32e8150c2a081110b42772ffe7d7c9032b606bc226c8260fd97e0976601"

[[package]]
name = "syn"
version = "1.0.86"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a65b3f4ffa0092e9887669db0eae07941f023991ab58ea44da8fe8e2d511c6b"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-xid",
]

[[package]]
name = "tempfile"
version = "3.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5cdb1ef4eaeeaddc8fbd371e5017057064af0911902ef36b39801f67cc6d79e4"
dependencies = [
 "cfg-if",
 "fastrand",
 "libc",
 "redox_syscall",
 "remove_dir_all",
 "winapi",
]

[[package]]
name = "thiserror"
version = "1.0.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "854babe52e4df1653706b98fcfc05843010039b406875930a70e4d9644e5c417"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "1.0.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aa32fd3f627f367fe16f893e2597ae3c05020f8bba2666a4e6ea73d377e5714b"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "time"
version = "0.3.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "004cbc98f30fa233c61a38bc77e96a9106e65c88f2d3bef182ae952027e5753d"
dependencies = [
 "itoa",
 "libc",
 "num_threads",
 "time-macros",
]

[[package]]
name = "time-macros"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "25eb0ca3468fc0acc11828786797f6ef9aa1555e4a211a60d64cc8e4d1be47d6"

[[package]]
name = "tinyvec"
version = "1.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2c1c1d5a42b6245520c249549ec267180beaffcc0615401ac8e31853d4b6d8d2"
dependencies = [
 "tinyvec_macros",
]

[[package]]
name = "tinyvec_macros"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cda74da7e1a664f795bb1f8a87ec406fb89a02522cf6e50620d016add6dbbf5c"

[[package]]
name = "tokio"
version = "1.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2af73ac49756f3f7c01172e34a23e5d0216f6c32333757c2c61feb2bbff5a5ee"
dependencies = [
 "bytes",
 "libc",
 "memchr",
 "mio",
 "num_cpus",
 "once_cell",
 "parking_lot 0.12.0",
 "pin-project-lite",
 "signal-hook-registry",
 "socket2",
 "tokio-macros",
 "winapi",
]

[[package]]
name = "tokio-macros"
version = "1.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b557f72f448c511a979e2564e55d74e6c4432fc96ff4f6241bc6bded342643b7"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tokio-native-tls"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f7d995660bd2b7f8c1568414c1126076c13fbb725c40112dc0120b78eb9b717b"
dependencies = [
 "native-tls",
 "tokio",
]

[[package]]
name = "tokio-stream"
version = "0.1.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "50145484efff8818b5ccd256697f36863f587da82cf8b409c53adf1e840798e3"
dependencies = [
 "futures-core",
 "pin-project-lite",
 "tokio",
]

[[package]]
name = "tokio-util"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "64910e1b9c1901aaf5375561e35b9c057d95ff41a44ede043a03e09279eabaf1"
dependencies = [
 "bytes",
 "futures-core",
 "futures-io",
 "futures-sink",
 "futures-util",
 "log",
 "pin-project-lite",
 "slab",
 "tokio",
]

[[package]]
name = "toml"
version = "0.5.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a31142970826733df8241ef35dc040ef98c679ab14d7c3e54d827099b3acecaa"
dependencies = [
 "serde",
]

[[package]]
name = "typenum"
version = "1.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dcf81ac59edc17cc8697ff311e8f5ef2d99fcbd9817b34cec66f90b6c3dfd987"

[[package]]
name = "unicode-bidi"
version = "0.3.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a01404663e3db436ed2746d9fefef640d868edae3cceb81c3b8d5732fda678f"

[[package]]
name = "unicode-normalization"
version = "0.1.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d54590932941a9e9266f0832deed84ebe1bf2e4c9e4a3554d393d18f5e854bf9"
dependencies = [
 "tinyvec",
]

[[package]]
name = "unicode-segmentation"
version = "1.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7e8820f5d777f6224dc4be3632222971ac30164d4a258d595640799554ebfd99"

[[package]]
name = "unicode-xid"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ccb82d61f80a663efe1f787a51b16b5a51e3314d6ac365b08639f52387b33f3"

[[package]]
name = "unicode_categories"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "39ec24b3121d976906ece63c9daad25b85969647682eee313cb5779fdd69e14e"

[[package]]
name = "url"
version = "2.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a507c383b2d33b5fc35d1861e77e6b383d158b2da5e14fe51b83dfedf6fd578c"
dependencies = [
 "form_urlencoded",
 "idna",
 "matches",
 "percent-encoding",
]

[[package]]
name = "vcpkg"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "accd4ea62f7bb7a82fe23066fb0957d48ef677f6eeb8215f372f52e48bb32426"

[[package]]
name = "version_check"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f"

[[package]]
name = "wasi"
version = "0.10.2+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fd6fbd9a79829dd1ad0cc20627bf1ed606756a7f77edff7b66b7064f9cb327c6"

[[package]]
name = "wasm-bindgen"
version = "0.2.79"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "25f1af7423d8588a3d840681122e72e6a24ddbcb3f0ec385cac0d12d24256c06"
dependencies = [
 "cfg-if",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.79"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b21c0df030f5a177f3cba22e9bc4322695ec43e7257d865302900290bcdedca"
dependencies = [
 "bumpalo",
 "lazy_static",
 "log",
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.79"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2f4203d69e40a52ee523b2529a773d5ffc1dc0071801c87b3d270b471b80ed01"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.79"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bfa8a30d46208db204854cadbb5d4baf5fcf8071ba5bf48190c3e59937962ebc"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.79"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3d958d035c4438e28c70e4321a2911302f10135ce78a9c7834c0cab4123d06a2"

[[package]]
name = "web-sys"
version = "0.3.56"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c060b319f29dd25724f09a2ba1418f142f539b2be99fbf4d2d5a8f7330afb8eb"
dependencies = [
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "whoami"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "524b58fa5a20a2fb3014dd6358b70e6579692a56ef6fce928834e488f42f65e8"
dependencies = [
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows-sys"
version = "0.32.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3df6e476185f92a12c072be4a189a0210dcdcf512a1891d6dff9edb874deadc6"
dependencies = [
 "windows_aarch64_msvc",
 "windows_i686_gnu",
 "windows_i686_msvc",
 "windows_x86_64_gnu",
 "windows_x86_64_msvc",
]

[[package]]
name = "windows_aarch64_msvc"
version = "0.32.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d8e92753b1c443191654ec532f14c199742964a061be25d77d7a96f09db20bf5"

[[package]]
name = "windows_i686_gnu"
version = "0.32.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a711c68811799e017b6038e0922cb27a5e2f43a2ddb609fe0b6f3eeda9de615"

[[package]]
name = "windows_i686_msvc"
version = "0.32.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "146c11bb1a02615db74680b32a68e2d61f553cc24c4eb5b4ca10311740e44172"

[[package]]
name = "windows_x86_64_gnu"
version = "0.32.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c912b12f7454c6620635bbff3450962753834be2a594819bd5e945af18ec64bc"

[[package]]
name = "windows_x86_64_msvc"
version = "0.32.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "504a2476202769977a040c6364301a3f65d0cc9e3fb08600b2bda150a0488316"

```

`Cargo.toml`:

```toml
[package]
name = "oxide"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1.17.0", features = ["full"] }
tokio-util = { version = "0.7.0", features = ["full"] }
tokio-stream = "0.1.8"
futures = "0.3.21"
bytes = "1.1.0"

# database
sqlx = { version = "0.5", features = [ "runtime-tokio-native-tls" , "postgres" ] }

# crypto
aes = "0.8.1"
rand = "0.8.5"
pbkdf2 = "0.10.1"

# logging
log = "0.4.14"
simple_logger = "2.1.0"

# misc
dotenv = "0.15.0"
toml = "0.5.8"
serde = { version = "1.0.136", features = ["derive"] }
lazy_static = "1.4.0"
```

`config/oxide.toml`:

```toml
enable_pin = false
enable_pic = false
```

`config/worlds.toml`:

```toml
[[worlds]]
id = 0
name = "Scania"
channels = 1
flag = 0
event_message = "Scania!"
recommended = "Welcome to Scania!"
exp_rate = 10
meso_rate = 10
drop_rate = 10
boss_drop_rate = 10
quest_rate = 5
fishing_rate = 10
travel_rate = 10

[[worlds]]
id = 1
name = "Bera"
channels = 1
flag = 0
event_message = "Bera!"
recommended = "Welcome to Bera!"
exp_rate = 10
meso_rate = 10
drop_rate = 10
boss_drop_rate = 10
quest_rate = 5
fishing_rate = 10
travel_rate = 10
```

`sql/accounts.sql`:

```sql
create table accounts
(
    id              serial
        constraint accounts_pk
            primary key,
    name            varchar(13)  default ''::character varying                              not null,
    password        varchar(128) default ''::character varying                              not null,
    pin             varchar(10)  default ''::character varying                              not null,
    pic             varchar(26)  default ''::character varying                              not null,
    login_state     smallint     default 0                                                  not null,
    last_login      timestamp,
    create_date     timestamp    default CURRENT_TIMESTAMP                                  not null,
    birthday        date         default '2015-01-01'::date                                 not null,
    banned          boolean      default false                                              not null,
    ban_reason      text,
    macs            text,
    nx_credit       integer,
    maple_points    integer,
    nx_prepaid      integer,
    character_slots smallint     default 3                                                  not null,
    gender          smallint     default 0                                                  not null,
    temp_ban        timestamp    default '2015-01-01 05:00:00'::timestamp without time zone not null,
    greason         smallint     default 0                                                  not null,
    accepted_tos    boolean      default false                                              not null,
    site_logged     text,
    web_admin       boolean      default false,
    nick            varchar(20)  default NULL::character varying,
    mute            boolean      default false,
    email           varchar(45)  default NULL::character varying,
    ip              text,
    reward_points   integer      default 0                                                  not null,
    vote_points     integer      default 0                                                  not null,
    hwid            varchar(12)  default ''::character varying                              not null,
    language        smallint     default 2                                                  not null,
    constraint accounts_ranking1
        unique (id, banned)
);

create index accounts_id_name_index
    on accounts (id, name);

create index accounts_id_nx_credit_maple_points_nx_prepaid_index
    on accounts (id, nx_credit, maple_points, nx_prepaid);

create unique index accounts_name_uindex
    on accounts (name);

```

`sql/characters.sql`:

```sql
-- auto-generated definition
create table characters
(
    id                     serial
        constraint characters_pk
            primary key,
    account_id             integer      default 0                                                  not null
        constraint characters_account_id
            unique,
    world_id               integer      default 0                                                  not null,
    name                   varchar(13)  default ''::character varying                              not null,
    level                  smallint     default 1                                                  not null,
    exp                    integer      default 0                                                  not null,
    gacha_exp              integer      default 0                                                  not null,
    str                    integer      default 12                                                 not null,
    dex                    integer      default 5                                                  not null,
    luk                    integer      default 4                                                  not null,
    int                    integer      default 4                                                  not null,
    hp                     integer      default 50                                                 not null,
    mp                     integer      default 5                                                  not null,
    max_hp                 integer      default 50                                                 not null,
    max_mp                 integer      default 5                                                  not null,
    mesos                  integer      default 0                                                  not null,
    hp_mp_used             integer      default 0                                                  not null,
    job                    integer      default 0                                                  not null,
    skin_colour            integer      default 0                                                  not null,
    gender                 smallint     default 0                                                  not null,
    fame                   integer      default 0                                                  not null,
    quest_fame             integer      default 0                                                  not null,
    hair                   integer      default 0                                                  not null,
    face                   integer      default 0                                                  not null,
    ap                     integer      default 0                                                  not null,
    sp                     varchar(128) default '0,0,0,0,0,0,0,0,0,0'::character varying           not null,
    map                    integer      default 0                                                  not null,
    spawn_point            integer      default 0                                                  not null,
    gm                     smallint     default 0                                                  not null,
    party                  integer      default 0                                                  not null
        constraint characters_party
            unique,
    buddy_capacity         integer      default 25                                                 not null,
    create_date            timestamp    default CURRENT_TIMESTAMP                                  not null,
    rank                   integer      default 1                                                  not null,
    rank_move              integer      default 0                                                  not null,
    job_rank               integer      default 1                                                  not null,
    job_rank_move          integer      default 0                                                  not null,
    guild_id               integer      default 0                                                  not null,
    guild_rank             integer      default 5                                                  not null,
    messenger_id           integer      default 0                                                  not null,
    messenger_position     integer      default 4                                                  not null,
    mount_level            integer      default 1                                                  not null,
    mount_exp              integer      default 0                                                  not null,
    mount_tiredness        integer      default 0                                                  not null,
    omok_wins              integer      default 0                                                  not null,
    omok_losses            integer      default 0                                                  not null,
    omok_ties              integer      default 0                                                  not null,
    match_card_wins        integer      default 0                                                  not null,
    match_card_losses      integer      default 0                                                  not null,
    match_card_ties        integer      default 0                                                  not null,
    merchant_mesos         integer      default 0,
    has_merchant           boolean      default false,
    equip_slots            integer      default 24                                                 not null,
    use_slots              integer      default 24                                                 not null,
    setup_slots            integer      default 24                                                 not null,
    etc_slots              integer      default 24                                                 not null,
    family_id              integer      default '-1'::integer                                      not null,
    monster_book_cover     integer      default 0                                                  not null,
    alliance_rank          integer      default 5                                                  not null,
    vanquisher_stage       integer      default 0                                                  not null,
    ariant_points          integer      default 0                                                  not null,
    dojo_points            integer      default 0                                                  not null,
    last_dojo_stage        integer      default 0                                                  not null,
    finished_dojo_tutorial boolean      default false                                              not null,
    vanquisher_kills       integer      default 0                                                  not null,
    summon_value           integer      default 0                                                  not null,
    partner_id             integer      default 0                                                  not null,
    marriage_item_id       integer      default 0                                                  not null,
    rebirths               integer      default 0                                                  not null,
    pq_points              integer      default 0                                                  not null,
    data_string            varchar(64)  default ''::character varying                              not null,
    last_logout_time       timestamp    default '2015-01-01 05:00:00'::timestamp without time zone not null,
    last_exp_gain_time     timestamp    default '2015-01-01 05:00:00'::timestamp without time zone not null,
    party_search           boolean      default true                                               not null,
    jail_expire            integer      default 0                                                  not null,
    constraint characters_ranking1
        unique (level, exp),
    constraint characters_ranking2
        unique (gm, job)
);

create index characters_id_account_id_name_index
    on characters (id, account_id, name);

create index characters_id_account_id_world_index
    on characters (id, account_id, world_id);


```

`src/character/mod.rs`:

```rs
use sqlx::{postgres::PgRow, Row};

use self::pet::Pet;

mod pet;

#[derive(Debug)]
pub struct Character {
    pub id: i32,
    pub account_id: i32,
    pub world_id: i32,
    pub name: String,
    pub stats: Stats,
    pub job: i32,
    pub style: Style,
    pub map: i32,
    pub spawn_point: i32,
    pub gm: u8,
    pub rank: Rank,

    pub pets: Vec<Pet>,
}

#[derive(Debug)]
pub struct Stats {
    pub exp: i32,
    pub gacha_exp: i32,
    pub level: i16,
    pub str: i32,
    pub dex: i32,
    pub luk: i32,
    pub int: i32,
    pub hp: i32,
    pub mp: i32,
    pub max_hp: i32,
    pub max_mp: i32,
    pub mesos: i32,
    pub fame: i32,
    pub ap: i32,
    pub sp: String,
}

#[derive(Debug)]
pub struct Style {
    pub skin_colour: i32,
    pub gender: u8,
    pub hair: i32,
    pub face: i32,
}

#[derive(Default, Debug)]
pub struct Rank {
    pub rank: i32,
    pub rank_move: i32,
    pub job_rank: i32,
    pub job_rank_move: i32,
}

impl Character {
    pub fn new(account_id: i32, world_id: i32, name: String, style: Style) -> Self {
        // TODO pass in job, call default function for each job

        Self {
            id: 0, // FIXME
            account_id,
            world_id,
            name,
            stats: Default::default(),
            job: 0, // TODO different for explorer, cygnus, aran, etc.
            style,
            map: 10000,     // FIXME default for beginnner (mushroom town)
            spawn_point: 0, // FIXME
            gm: 0,
            rank: Default::default(),
            pets: Vec::new(),
        }
    }

    // TODO should probably change this to load() in the future, character data spans
    // across several tables/queries
    pub fn from_row(row: &PgRow) -> Self {
        Self {
            id: row.get::<i32, _>("id"),
            account_id: row.get::<i32, _>("account_id"),
            world_id: row.get::<i32, _>("world_id"),
            name: row.get::<String, _>("name"),
            stats: Stats::from_row(row),
            job: row.get::<i32, _>("job"),
            style: Style::from_row(row),
            map: row.get::<i32, _>("map"),
            spawn_point: row.get::<i32, _>("spawn_point"),
            gm: row.get::<i16, _>("gm") as u8,
            rank: Rank::from_row(row),
            // TODO load from pets table
            pets: Vec::new(),
        }
    }

    // TODO new_explorer, new_cygnus, new_aran, etc.
}

impl Stats {
    fn from_row(row: &PgRow) -> Self {
        Stats {
            exp: row.get::<i32, _>("exp"),
            gacha_exp: row.get::<i32, _>("gacha_exp"),
            level: row.get::<i16, _>("level"),
            str: row.get::<i32, _>("str"),
            dex: row.get::<i32, _>("dex"),
            luk: row.get::<i32, _>("luk"),
            int: row.get::<i32, _>("int"),
            hp: row.get::<i32, _>("hp"),
            mp: row.get::<i32, _>("mp"),
            max_hp: row.get::<i32, _>("max_hp"),
            max_mp: row.get::<i32, _>("max_mp"),
            mesos: row.get::<i32, _>("mesos"),
            fame: row.get::<i32, _>("fame"),
            ap: row.get::<i32, _>("ap"),
            sp: row.get::<String, _>("sp"),
        }
    }
}

impl Default for Stats {
    fn default() -> Stats {
        Stats {
            exp: 0,
            gacha_exp: 0,
            level: 1,
            str: 12,
            dex: 5,
            luk: 4,
            int: 4,
            hp: 50,
            mp: 5,
            max_hp: 50,
            max_mp: 50,
            mesos: 0,
            fame: 0,
            ap: 0,
            sp: "0,0,0,0,0,0,0,0,0,0".to_string(),
        }
    }
}

impl Style {
    fn from_row(row: &PgRow) -> Self {
        Self {
            skin_colour: row.get::<i32, _>("skin_colour"),
            gender: row.get::<i16, _>("gender") as u8,
            hair: row.get::<i32, _>("hair"),
            face: row.get::<i32, _>("face"),
        }
    }
}

impl Rank {
    fn from_row(row: &PgRow) -> Self {
        Self {
            rank: row.get::<i32, _>("rank"),
            rank_move: row.get::<i32, _>("rank_move"),
            job_rank: row.get::<i32, _>("job_rank"),
            job_rank_move: row.get::<i32, _>("job_rank_move"),
        }
    }
}

```

`src/character/pet.rs`:

```rs
#[derive(Debug)]
pub struct Pet {
    pub id: i32,
    pub item_id: i32,
}

```

`src/client.rs`:

```rs
use crate::{
    db::Db, handler::Handler, login::queries, net::connection::Connection, shutdown::Shutdown,
    Result, Shared,
};

use std::sync::Arc;

pub struct Client {
    pub session_id: usize,
    pub db: Db,
    pub connection: Connection,
    pub shutdown: Shutdown,
    pub shared: Arc<Shared>,
    pub login_attempts: u8,
    pub pin_attempts: u8,
    pub id: Option<i32>,
    pub pin: Option<String>,
    pub world_id: Option<i32>,
    pub channel_id: Option<i32>,
}

impl Client {
    pub async fn connect(&mut self) -> Result<()> {
        log::info!("Client connected to server (session: {})", self.session_id);

        while !self.shutdown.is_shutdown() {
            let maybe_packet = tokio::select! {
                res = self.connection.read_packet() => res?,
                // shutdown signal was receieved, return and terminate the task
                _ = self.shutdown.recv() => {
                    return Ok(())
                }
            };

            // None => client disconnected
            let packet = match maybe_packet {
                Some(packet) => packet,
                None => return Ok(()),
            };

            log::debug!("Received packet: {}", packet);

            let handler = match Handler::get(packet) {
                Some(handler) => handler,
                None => return Ok(()),
            };

            handler.handle(self).await?;
        }

        Ok(())
    }

    pub async fn disconnect(&mut self) -> Result<()> {
        log::info!("Client disconnecting (session: {})", self.session_id);
        self.connection.disconnect().await?;
        Ok(())
    }

    pub async fn on_disconnect(&mut self) -> Result<()> {
        if let Some(id) = self.id {
            queries::update_login_state(id, 0, &self.db).await?;
        }

        Ok(())
    }
}

```

`src/config.rs`:

```rs
use lazy_static::lazy_static;
use serde::Deserialize;

lazy_static! {
    pub static ref CONFIG: OxideConfig = load_oxide_config();
}

#[derive(Debug, Deserialize)]
pub struct OxideConfig {
    pub enable_pin: bool,
    pub enable_pic: bool,
}

fn load_oxide_config() -> OxideConfig {
    let toml = std::fs::read_to_string("config/oxide.toml").unwrap();
    toml::from_str(&toml).unwrap()
}

```

`src/crypto/cipher.rs`:

```rs
use aes::{
    cipher::{generic_array::GenericArray, BlockEncrypt, KeyInit},
    Aes256,
};
use bytes::BytesMut;
use rand::random;

const KEY: [u8; 32] = [
    0x13, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0xB4, 0x00, 0x00, 0x00,
    0x1B, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x52, 0x00, 0x00, 0x00,
];

const SHIFT_KEY: [u8; 256] = [
    0xEC, 0x3F, 0x77, 0xA4, 0x45, 0xD0, 0x71, 0xBF, 0xB7, 0x98, 0x20, 0xFC, 0x4B, 0xE9, 0xB3, 0xE1,
    0x5C, 0x22, 0xF7, 0x0C, 0x44, 0x1B, 0x81, 0xBD, 0x63, 0x8D, 0xD4, 0xC3, 0xF2, 0x10, 0x19, 0xE0,
    0xFB, 0xA1, 0x6E, 0x66, 0xEA, 0xAE, 0xD6, 0xCE, 0x06, 0x18, 0x4E, 0xEB, 0x78, 0x95, 0xDB, 0xBA,
    0xB6, 0x42, 0x7A, 0x2A, 0x83, 0x0B, 0x54, 0x67, 0x6D, 0xE8, 0x65, 0xE7, 0x2F, 0x07, 0xF3, 0xAA,
    0x27, 0x7B, 0x85, 0xB0, 0x26, 0xFD, 0x8B, 0xA9, 0xFA, 0xBE, 0xA8, 0xD7, 0xCB, 0xCC, 0x92, 0xDA,
    0xF9, 0x93, 0x60, 0x2D, 0xDD, 0xD2, 0xA2, 0x9B, 0x39, 0x5F, 0x82, 0x21, 0x4C, 0x69, 0xF8, 0x31,
    0x87, 0xEE, 0x8E, 0xAD, 0x8C, 0x6A, 0xBC, 0xB5, 0x6B, 0x59, 0x13, 0xF1, 0x04, 0x00, 0xF6, 0x5A,
    0x35, 0x79, 0x48, 0x8F, 0x15, 0xCD, 0x97, 0x57, 0x12, 0x3E, 0x37, 0xFF, 0x9D, 0x4F, 0x51, 0xF5,
    0xA3, 0x70, 0xBB, 0x14, 0x75, 0xC2, 0xB8, 0x72, 0xC0, 0xED, 0x7D, 0x68, 0xC9, 0x2E, 0x0D, 0x62,
    0x46, 0x17, 0x11, 0x4D, 0x6C, 0xC4, 0x7E, 0x53, 0xC1, 0x25, 0xC7, 0x9A, 0x1C, 0x88, 0x58, 0x2C,
    0x89, 0xDC, 0x02, 0x64, 0x40, 0x01, 0x5D, 0x38, 0xA5, 0xE2, 0xAF, 0x55, 0xD5, 0xEF, 0x1A, 0x7C,
    0xA7, 0x5B, 0xA6, 0x6F, 0x86, 0x9F, 0x73, 0xE6, 0x0A, 0xDE, 0x2B, 0x99, 0x4A, 0x47, 0x9C, 0xDF,
    0x09, 0x76, 0x9E, 0x30, 0x0E, 0xE4, 0xB2, 0x94, 0xA0, 0x3B, 0x34, 0x1D, 0x28, 0x0F, 0x36, 0xE3,
    0x23, 0xB4, 0x03, 0xD8, 0x90, 0xC8, 0x3C, 0xFE, 0x5E, 0x32, 0x24, 0x50, 0x1F, 0x3A, 0x43, 0x8A,
    0x96, 0x41, 0x74, 0xAC, 0x52, 0x33, 0xF0, 0xD9, 0x29, 0x80, 0xB1, 0x16, 0xD3, 0xAB, 0x91, 0xB9,
    0x84, 0x7F, 0x61, 0x1E, 0xCF, 0xC5, 0xD1, 0x56, 0x3D, 0xCA, 0xF4, 0x05, 0xC6, 0xE5, 0x08, 0x49,
];

pub enum CipherType {
    Send,
    Receive,
}

#[derive(Debug)]
pub struct Cipher {
    pub cipher: Aes256,
    pub iv: [u8; 4],
    pub version: u16,
}

impl Cipher {
    pub fn new(cipher_type: CipherType) -> Self {
        Self {
            cipher: Aes256::new(&GenericArray::from(KEY)),
            iv: Self::generate_iv(&cipher_type),
            version: Self::generate_version(&cipher_type),
        }
    }

    pub fn transform(&mut self, mut data: BytesMut) -> BytesMut {
        // maplestory's 1460 byte block - 4 header bytes = 1456 bytes for body
        let mut current_block_length = 1460 - 4;

        let iv_copy = [
            self.iv[0], self.iv[1], self.iv[2], self.iv[3], self.iv[0], self.iv[1], self.iv[2],
            self.iv[3], self.iv[0], self.iv[1], self.iv[2], self.iv[3], self.iv[0], self.iv[1],
            self.iv[2], self.iv[3],
        ];

        let mut i = 0;

        while i < data.len() {
            let block = std::cmp::min(data.len() - i, current_block_length);
            let mut xor_key = GenericArray::from(iv_copy);

            for j in 0..block {
                if j % 16 == 0 {
                    self.cipher.encrypt_block(&mut xor_key);
                }

                data[i + j] ^= xor_key[j % 16];
            }

            i += block;
            current_block_length = 1460;
        }

        // after each transform operation update the initialization vector
        self.iv = self.morph_iv();

        data
    }

    fn morph_iv(&self) -> [u8; 4] {
        let mut new_sequence: [u8; 4] = [0xf2, 0x53, 0x50, 0xc6];

        for i in 0..4 {
            let table_input = SHIFT_KEY[self.iv[i] as usize];

            // need to use wrapping add/sub as all of these operations will overflow
            new_sequence[0] = new_sequence[0]
                .wrapping_add(SHIFT_KEY[new_sequence[1] as usize].wrapping_sub(self.iv[i]));
            new_sequence[1] = new_sequence[1].wrapping_sub(new_sequence[2] ^ table_input);
            new_sequence[2] ^= SHIFT_KEY[new_sequence[3] as usize].wrapping_add(self.iv[i]);
            new_sequence[3] =
                new_sequence[3].wrapping_sub(new_sequence[0].wrapping_sub(table_input));

            let x = i32::from(new_sequence[1] & 0xff) << 8;
            let y = i32::from(new_sequence[2] & 0xff) << 16;
            let z = i32::from(new_sequence[3] & 0xff) << 24;
            // "as u32" is effectively an unsigned/zero-fill right shift by 0
            let mut val = (i32::from(new_sequence[0]) | x | y | z) as u32;
            let mut val2 = val >> 0x1d;

            // "as u32" is effectively an unsigned/zero-fill right shift by 0
            val = (val << 0x03) as u32;
            val2 |= val;

            // the below computations will always result in a value that fits in a byte
            // so downcasting as u8 should be fine here
            new_sequence[0] = (val2 & 0xff) as u8;
            new_sequence[1] = ((val2 >> 8) & 0xff) as u8;
            new_sequence[2] = ((val2 >> 16) & 0xff) as u8;
            new_sequence[3] = ((val2 >> 24) & 0xff) as u8;
        }

        new_sequence
    }

    fn generate_iv(cipher_type: &CipherType) -> [u8; 4] {
        match cipher_type {
            CipherType::Send => return [0x52, 0x30, 0x78, 0x61],
            CipherType::Receive => return [0x46, 0x72, random::<u8>(), 0x52],
        }
    }

    fn generate_version(cipher_type: &CipherType) -> u16 {
        let version: u16 = match cipher_type {
            CipherType::Send => 0xffff - 83,
            CipherType::Receive => 83,
        };

        ((version >> 8) & 0xff) | ((version << 8) & 0xff00)
    }
}

```

`src/crypto/mod.rs`:

```rs
pub mod cipher;
pub mod shanda;

```

`src/crypto/shanda.rs`:

```rs
use bytes::BytesMut;

pub fn encrypt(mut data: BytesMut) -> BytesMut {
    let length = data.len();

    for _ in 0..3 {
        let mut a = 0;

        for j in (1..=length).rev() {
            let mut c = i32::from(data[length - j]);
            c = roll_left(c, 3);
            c += j as i32;
            c &= 0xff;
            c ^= a;
            a = c;
            c = roll_right(a, j as i32);
            c ^= 0xff;
            c += 0x48;
            c &= 0xff;
            data[length - j] = c as u8;
        }

        a = 0;

        for j in (1..=length).rev() {
            let mut c = i32::from(data[j - 1]);
            c = roll_left(c, 4);
            c += j as i32;
            c &= 0xff;
            c ^= a;
            a = c;
            c ^= 0x13;
            c = roll_right(c, 3);
            data[j - 1] = c as u8;
        }
    }

    data
}

pub fn decrypt(mut data: BytesMut) -> BytesMut {
    let length = data.len();

    for _ in 0..3 {
        let mut a: i32;
        let mut b = 0;

        for j in (1..=length).rev() {
            let mut c = i32::from(data[j - 1]);
            c = roll_left(c, 3);
            c ^= 0x13;
            a = c;
            c ^= b;
            c -= j as i32;
            c &= 0xff;
            c = roll_right(c, 4);
            b = a;
            data[j - 1] = c as u8;
        }

        b = 0;

        for j in (1..=length).rev() {
            let mut c = i32::from(data[length - j]);
            c -= 0x48;
            c &= 0xff;
            c ^= 0xff;
            c = roll_left(c, j as i32);
            a = c;
            c ^= b;
            c -= j as i32;
            c &= 0xff;
            c = roll_right(c, 3);
            b = a;
            data[length - j] = c as u8;
        }
    }

    data
}

fn roll_left(value: i32, shift: i32) -> i32 {
    let overflow = ((value >> 0) << shift % 8) >> 0;
    ((overflow & 0xff) | (overflow >> 8)) & 0xff
}

fn roll_right(value: i32, shift: i32) -> i32 {
    let overflow = ((value >> 0) << 8) >> shift % 8;
    ((overflow & 0xff) | (overflow >> 8)) & 0xff
}

```

`src/db.rs`:

```rs
use crate::Result;

use sqlx::{
    postgres::{PgConnectOptions, PgPoolOptions},
    Pool, Postgres,
};
use std::env;

pub type Db = Pool<Postgres>;

pub async fn new() -> Result<Db> {
    let options = PgConnectOptions::new()
        .host(&env::var("DATABASE_HOST").unwrap())
        .database(&env::var("DATABASE_NAME").unwrap())
        .username(&env::var("DATABASE_USER").unwrap())
        .password(&env::var("DATABASE_PASSWORD").unwrap());

    let pool = PgPoolOptions::new()
        .max_connections(10)
        .connect_with(options)
        .await?;

    Ok(pool)
}

```

`src/handler/after_login.rs`:

```rs
use crate::{
    client::Client,
    login::{
        packets::{self, PinOperation},
        queries,
    },
    net::packet::Packet,
    Result,
};

#[derive(Debug)]
pub struct AfterLogin {
    a: u8,
    b: u8,
    packet: Packet,
}

impl AfterLogin {
    pub fn new(mut packet: Packet) -> Self {
        let a = packet.read_byte();

        let b = match packet.remaining() {
            0 => 5,
            _ => packet.read_byte(),
        };

        Self { a, b, packet }
    }

    pub async fn handle(mut self, client: &mut Client) -> Result<()> {
        let db = &client.db;

        let op = match (self.a, self.b) {
            (1, 1) => match client.pin {
                None => Some(PinOperation::Register),
                Some(_) => Some(PinOperation::Request),
            },
            (1, 0) => {
                let pin = self.packet.read_string();
                Self::validate_pin(client, pin, 1).await?
            }
            (2, 0) => {
                let pin = self.packet.read_string();
                Self::validate_pin(client, pin, 2).await?
            }
            _ => {
                // TODO can possibly send PinOperation::ConnectionFailed here?
                queries::update_login_state(client.id.unwrap(), 0, db).await?;
                None
            }
        };

        if op.is_some() {
            client
                .connection
                .write_packet(packets::pin_operation(op.unwrap()))
                .await?;
        }

        Ok(())
    }

    async fn validate_pin(
        client: &mut Client,
        pin: String,
        flag: u8,
    ) -> Result<Option<PinOperation>> {
        client.pin_attempts += 1;

        if client.pin_attempts >= 6 {
            client.disconnect().await?;
            return Ok(None);
        }

        if client.pin.is_some() && &pin == client.pin.as_ref().unwrap() {
            client.pin_attempts = 0;

            if flag == 1 {
                return Ok(Some(PinOperation::Accepted));
            } else {
                return Ok(Some(PinOperation::Register));
            }
        }

        Ok(Some(PinOperation::RequestAfterFailure))
    }
}

```

`src/handler/character_list.rs`:

```rs
use crate::{
    character::Character,
    client::Client,
    login::{packets, queries},
    net::packet::Packet,
    world::CapacityStatus,
    Result,
};

#[derive(Debug)]
pub struct CharacterList {
    world_id: u8,
    channel_id: u8,
}

impl CharacterList {
    pub fn new(mut packet: Packet) -> Self {
        packet.skip(1);

        let world_id = packet.read_byte();
        let channel_id = packet.read_byte();

        Self {
            world_id,
            channel_id,
        }
    }

    pub async fn handle(mut self, client: &mut Client) -> Result<()> {
        let shared = &client.shared;
        let db = &client.db;
        let connection = &mut client.connection;

        let world = match shared.worlds.get(self.world_id as usize) {
            Some(world) => world,
            None => {
                connection
                    .write_packet(packets::world_status(CapacityStatus::Full))
                    .await?;
                return Ok(());
            }
        };

        if world.get_capacity_status() == CapacityStatus::Full {
            connection
                .write_packet(packets::world_status(CapacityStatus::Full))
                .await?;
            return Ok(());
        }

        let channel = match world.channels.get(self.channel_id as usize) {
            Some(channel) => channel,
            None => {
                connection
                    .write_packet(packets::world_status(CapacityStatus::Full))
                    .await?;
                return Ok(());
            }
        };

        client.world_id = Some(world.config.id);
        client.channel_id = Some(channel.id);

        let rows = match queries::get_characters(client.id.unwrap(), world.config.id, db).await {
            Ok(characters) => characters,
            Err(_) => Vec::new(),
        };

        let mut characters: Vec<Character> = Vec::new();

        for row in rows.iter() {
            characters.push(Character::from_row(row));
        }

        connection
            .write_packet(packets::character_list(&characters))
            .await?;

        Ok(())
    }
}

```

`src/handler/login.rs`:

```rs
use crate::{
    client::Client,
    login::{packets, queries},
    net::packet::Packet,
    Result,
};

use bytes::Bytes;
use pbkdf2::{
    password_hash::{PasswordHash, PasswordVerifier},
    Pbkdf2,
};
use sqlx::{postgres::PgRow, Row};

#[derive(Debug)]
pub struct Login {
    name: String,
    password: String,
    hwid: Bytes,
}

#[derive(Debug)]
enum LoginError {
    InvalidPassword = 0,
    Banned = 3,
    NotFound = 5,
    TooManyAttempts = 6,
    InUse = 7,
    AcceptTOS = 23,
}

impl Login {
    pub fn new(mut packet: Packet) -> Self {
        let name = packet.read_string();
        let password = packet.read_string();
        packet.skip(6);
        let hwid = packet.read_bytes(4);

        Self {
            name,
            password,
            hwid,
        }
    }

    pub async fn handle(self, client: &mut Client) -> Result<()> {
        let db = &client.db;
        let connection = &mut client.connection;

        client.login_attempts += 1;

        if client.login_attempts >= 5 {
            let packet = packets::login_failed(LoginError::TooManyAttempts as i32);
            connection.write_packet(packet).await?;
            client.disconnect().await?;
            return Ok(());
        }

        let account = match queries::get_account(&self.name, db).await {
            Ok(account) => account,
            Err(_) => {
                let packet = packets::login_failed(LoginError::NotFound as i32);
                connection.write_packet(packet).await?;
                return Ok(());
            }
        };

        if let Some(e) = self.validate_account(&account).await {
            let packet = packets::login_failed(e as i32);
            connection.write_packet(packet).await?;
        } else {
            let id = account.get::<i32, _>("id");
            let pin = account.get::<String, _>("pin");

            client.id = Some(id);

            if !pin.is_empty() {
                client.pin = Some(pin);
            }

            queries::update_login_state(id, 2, db).await?;

            let packet = packets::login_success(id, &self.name);
            connection.write_packet(packet).await?;
        }

        Ok(())
    }

    async fn validate_account(&self, account: &PgRow) -> Option<LoginError> {
        if account.get::<bool, _>("banned") {
            return Some(LoginError::Banned);
        }

        // 0 => logged out, 1 => transitioning, 2 => logged in
        if account.get::<i16, _>("login_state") != 0 {
            return Some(LoginError::InUse);
        }

        if !account.get::<bool, _>("accepted_tos") {
            return Some(LoginError::AcceptTOS);
        }

        // password entered in the client
        let password = self.password.as_bytes();
        // parse the hash stored in db
        let hash: String = account.get("password");
        let hash = PasswordHash::new(&hash).unwrap();

        // check the entered password against the hash
        if Pbkdf2.verify_password(password, &hash).is_err() {
            return Some(LoginError::InvalidPassword);
        }

        None
    }
}

```

`src/handler/mod.rs`:

```rs
use crate::client::Client;
use crate::net::packet::Packet;
use crate::Result;

mod login;
use self::login::Login;

mod character_list;
use self::character_list::CharacterList;

mod world_status;
use self::world_status::WorldStatus;

mod after_login;
use self::after_login::AfterLogin;

mod register_pin;
use self::register_pin::RegisterPin;

mod world_list;
use self::world_list::WorldList;

mod unknown;
use self::unknown::Unknown;

pub enum Handler {
    Login(Login),
    CharacterList(CharacterList),
    WorldStatus(WorldStatus),
    AfterLogin(AfterLogin),
    RegisterPin(RegisterPin),
    WorldList(WorldList),
    Unknown(Unknown),
}

impl Handler {
    pub fn get(mut packet: Packet) -> Option<Self> {
        let op_code = packet.read_short();

        let handler = match op_code {
            0x01 => Handler::Login(Login::new(packet)),
            0x05 => Handler::CharacterList(CharacterList::new(packet)),
            0x06 => Handler::WorldStatus(WorldStatus::new(packet)),
            0x09 => Handler::AfterLogin(AfterLogin::new(packet)),
            0x0A => Handler::RegisterPin(RegisterPin::new(packet)),
            0x0B => Handler::WorldList(WorldList::new()),
            _ => {
                if op_code >= 0x200 {
                    log::warn!("Potential malicious packet: {}", op_code);
                    return None;
                }

                Handler::Unknown(Unknown::new(op_code))
            }
        };

        Some(handler)
    }

    pub async fn handle(self, client: &mut Client) -> Result<()> {
        use Handler::*;

        match self {
            Login(handler) => handler.handle(client).await,
            CharacterList(handler) => handler.handle(client).await,
            WorldStatus(handler) => handler.handle(client).await,
            AfterLogin(handler) => handler.handle(client).await,
            RegisterPin(handler) => handler.handle(client).await,
            WorldList(handler) => handler.handle(client).await,
            Unknown(handler) => handler.handle(),
        }
    }
}

```

`src/handler/register_pin.rs`:

```rs
use crate::{
    client::Client,
    login::{packets, queries},
    net::packet::Packet,
    Result,
};

#[derive(Debug)]
pub struct RegisterPin {
    flag: u8,
    packet: Packet,
}

impl RegisterPin {
    pub fn new(mut packet: Packet) -> Self {
        let flag = packet.read_byte();

        Self { flag, packet }
    }

    pub async fn handle(mut self, client: &mut Client) -> Result<()> {
        let db = &client.db;
        let connection = &mut client.connection;

        if self.flag == 0 {
            queries::update_login_state(client.id.unwrap(), 0, db).await?;
            return Ok(());
        }

        let pin = self.packet.read_string();
        client.pin = Some(pin.clone());
        queries::update_pin(client.id.unwrap(), &pin, db).await?;

        connection.write_packet(packets::pin_registered()).await?;
        queries::update_login_state(client.id.unwrap(), 0, db).await?;

        Ok(())
    }
}

```

`src/handler/unknown.rs`:

```rs
use crate::Result;

#[derive(Debug)]
pub struct Unknown {
    op_code: i16,
}

impl Unknown {
    pub fn new(op_code: i16) -> Self {
        Self { op_code }
    }

    pub fn handle(self) -> Result<()> {
        log::debug!("Unknown packet: {}", self.op_code);
        Ok(())
    }
}

```

`src/handler/world_list.rs`:

```rs
use crate::{client::Client, login::packets, Result};

#[derive(Debug)]
pub struct WorldList;

impl WorldList {
    pub fn new() -> Self {
        Self
    }

    pub async fn handle(self, client: &mut Client) -> Result<()> {
        let shared = &client.shared;
        let connection = &mut client.connection;

        for world in shared.worlds.iter() {
            connection
                .write_packet(packets::world_details(&world))
                .await?;
        }

        // tell the client that we have sent details for all available worlds
        connection.write_packet(packets::world_list_end()).await?;

        // pre-select world with id "0" for the client
        // TODO this should be the most active world, not really a priority to fix
        connection.write_packet(packets::world_select(0)).await?;

        // add the recommended world text for each world
        connection
            .write_packet(packets::view_recommended(&shared.worlds))
            .await?;

        Ok(())
    }
}

```

`src/handler/world_status.rs`:

```rs
use crate::{client::Client, login::packets, net::packet::Packet, world::CapacityStatus, Result};

#[derive(Debug)]
pub struct WorldStatus {
    world_id: i16,
}

impl WorldStatus {
    pub fn new(mut packet: Packet) -> Self {
        let world_id = packet.read_short();

        Self { world_id }
    }

    pub async fn handle(self, client: &mut Client) -> Result<()> {
        let shared = &client.shared;
        let connection = &mut client.connection;

        let world = shared.worlds.get(self.world_id as usize);

        let capacity_status = match world {
            Some(world) => world.get_capacity_status(),
            None => CapacityStatus::Full,
        };

        connection
            .write_packet(packets::world_status(capacity_status))
            .await?;

        Ok(())
    }
}

```

`src/login/handlers.rs`:

```rs
use crate::{
    character::{self, Character},
    client::{Client, LoginState},
    login::packets,
    net::packet::Packet,
    world::CapacityStatus,
};

pub async fn character_list(mut packet: Packet, client: &mut Client) {
    // not sure what this byte is for
    packet.advance(1);

    let world_id = packet.read_byte();

    let server = client.server.clone();
    let server = server.lock().await;
    let world = server.worlds.get(world_id as usize);

    // TODO add check to see if world.capacity_status is Full
    if world.is_none() {
        client
            .send_packet(packets::world_status(CapacityStatus::Full))
            .await;

        return;
    }

    let world = world.unwrap();

    let channel_id = packet.read_byte();
    let channel = world.channels.get(channel_id as usize);

    if channel.is_none() {
        client
            .send_packet(packets::world_status(CapacityStatus::Full))
            .await;

        return;
    }

    // TODO client.set_world(world)
    // TODO client.set_channel(channel)
    client.send_packet(packets::character_list()).await;
}

pub async fn accept_tos(mut packet: Packet, client: &mut Client) {
    // Ok => 0x01, Cancel => 0x00
    let accepted = packet.read_byte();

    if accepted != 0x01 {
        log::info!("TOS was declined");
        return;
    }

    if client.account.is_none() {
        log::error!("Client's account is None");
        return;
    }

    let db = &client.pool.get().await.unwrap();

    if let Err(e) = db
        .query(
            "UPDATE accounts SET accepted_tos = true WHERE id = $1",
            &[&client.account.as_ref().unwrap().id],
        )
        .await
    {
        log::debug!("An error occurred while accepting tos: {}", e);
    }

    login_success(client).await;
}

pub async fn validate_character_name(mut packet: Packet, client: &mut Client) {
    let name = packet.read_maple_string();

    // looks like the client has it's own "banned name" list, so we can skip implementing that for now
    let valid = !is_name_taken(&name, &client.pool).await;

    client
        .send_packet(packets::character_name(&name, valid))
        .await;
}

pub async fn create_character(mut packet: Packet, client: &mut Client) {
    let name = packet.read_maple_string();
    let job = packet.read_int();

    let face = packet.read_int();
    let hair = packet.read_int();
    let hair_colour = packet.read_int();
    let skin_colour = packet.read_int();

    let top = packet.read_int();
    let bottom = packet.read_int();
    let shoes = packet.read_int();
    let weapon = packet.read_int();
    let gender = packet.read_byte();

    // TODO check if face, hair, top, bottom, shoes, weapon are valid => match the correct ids for starter gear
    // this is done to prevent packet editing during character creation
    // if invalid, disconnect the client

    // TODO check clients available character slots
    let style = character::Style::new(skin_colour, gender, hair + hair_colour, face);
    let mut character = Character::new(0, 0, name, style);
    log::debug!("character: {:?}", character);

    let id = save_new_character(&character, &client.pool).await;

    if id.is_none() {
        return;
    }

    // update the character id to what is returned by db
    character.id = id.unwrap();

    client
        .send_packet(packets::create_character(&character))
        .await;
}

async fn is_name_taken(name: &str, pool: &Pool) -> bool {
    let db = pool.get().await.unwrap();

    let query = db
        .query("SELECT id FROM characters WHERE name = $1", &[&name])
        .await;

    if query.is_err() {
        return true;
    }

    // no rows found => name isn't taken
    let rows = query.unwrap();
    rows.len() > 0
}

// TODO look into creating a queries.rs or something to clean up this file
async fn save_new_character(character: &Character, pool: &Pool) -> Option<i32> {
    let db = pool.get().await.unwrap();

    match db.query("INSERT INTO characters (account_id, world_id, name, level, str, dex, luk, int, hp, mp, max_hp, max_mp, mesos, job, skin_colour, gender, hair, face, ap, sp, map, spawn_point, gm) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23) RETURNING id", &[&character.account_id, &character.world_id, &character.name, &(character.stats.level as i16), &character.stats.str, &character.stats.dex, &character.stats.luk, &character.stats.int, &character.stats.hp, &character.stats.mp, &character.stats.max_hp, &character.stats.max_mp, &character.stats.mesos, &character.job, &character.style.skin_colour, &(character.style.gender as i16), &character.style.hair, &character.style.face, &character.stats.ap, &character.stats.sp, &character.map, &character.spawn_point, &(character.gm as i16)]).await {
        Ok(rows) => {
            if rows.len() == 0 {
                return None;
            }

            return Some(rows[0].get(0))
        }
        Err(e) => {
            log::error!("An error occurred while saving character to db: {}", e);
            return None;
        }
    };
}

```

`src/login/mod.rs`:

```rs
pub mod packets;
pub mod queries;
pub mod server;

```

`src/login/packets.rs`:

```rs
use std::slice::SliceIndex;

use crate::{
    character::{self, Character},
    config::CONFIG,
    crypto::cipher::Cipher,
    net::packet::Packet,
    world::{CapacityStatus, World},
};

pub enum PinOperation {
    Accepted,
    Register,
    RequestAfterFailure,
    ConnectionFailed,
    Request,
}

// handshake packet sent immediately after a client establishes a connection with the login server
// sets up client <-> server encryption via the passed initialization vectors and maple version
pub fn handshake(send: &Cipher, recv: &Cipher) -> Packet {
    let mut packet = Packet::new();
    // packet length (0x0E)
    packet.write_short(0x0E);
    // maple version
    packet.write_short(83);
    // maple patch version
    packet.write_string("1");
    // initialization vector for receive cipher
    packet.write_bytes(&recv.iv);
    // initialization vector for send cipher
    packet.write_bytes(&send.iv);
    // locale
    packet.write_byte(8);
    packet
}

// login success packet
pub fn login_success(id: i32, name: &String) -> Packet {
    let mut packet = Packet::new();
    packet.write_short(0x00);
    packet.write_int(0);
    packet.write_short(0);
    // account id
    packet.write_int(id);
    // FIXME: gender byte => not sure if this matters, hardcoding for now
    packet.write_byte(0);
    // FIXME: gm byte (0 / 1)
    packet.write_byte(0);
    // FIXME: admin bytes (0 / 0x80)
    packet.write_byte(0);
    // country code
    packet.write_byte(0);
    packet.write_string(name);
    packet.write_byte(0);
    // is quiet banned
    packet.write_byte(0);
    // quiet ban timestamp
    packet.write_long(0);
    // creation timestamp
    packet.write_long(0);
    // remove the "select the world you want to play in"
    packet.write_int(1);
    // 0 => pin enabled, 1 => pin disabled
    packet.write_byte(!CONFIG.enable_pin as u8);
    // FIXME: 0 => register PIC, 1 => ask for PIC, 2 => disabled
    packet.write_byte(2);
    packet
}

// login failed packet containing the reason why the login failed
pub fn login_failed(reason: i32) -> Packet {
    let mut packet = Packet::new();
    packet.write_short(0x00);
    // reason code
    packet.write_int(reason);
    packet.write_short(0);
    packet
}

// packet for various PIN operations
// 0 => PIN was accepted
// 1 => register a new PIN
// 2 => invalid PIN / re-enter
// 3 => connection failed due to system error
// 4 => enter pin
pub fn pin_operation(op: PinOperation) -> Packet {
    let mut packet = Packet::new();
    packet.write_short(0x06);
    packet.write_byte(op as u8);
    packet
}

//
pub fn pin_registered() -> Packet {
    let mut packet = Packet::new();
    packet.write_short(0x07);
    packet.write_byte(0);
    packet
}

// contains info for the given world displayed to the client in the world/server list
pub fn world_details(world: &World) -> Packet {
    let mut packet = Packet::new();
    packet.write_short(0x0A);
    packet.write_byte(world.config.id as u8);
    packet.write_string(&world.config.name);
    packet.write_byte(world.config.flag as u8);
    packet.write_string(&world.config.event_message);
    packet.write_byte(100);
    packet.write_byte(0);
    packet.write_byte(100);
    packet.write_byte(0);
    packet.write_byte(0);
    packet.write_byte(world.channels.len() as u8);

    for channel in world.channels.iter() {
        let channel_name = &(world.config.name.to_owned() + &(channel.id + 1).to_string());
        packet.write_string(channel_name);
        // TODO channel capacity, not sure if this is max allowed or currently connected?
        packet.write_int(100);
        // TODO world id? not sure what this is
        packet.write_byte(1);
        packet.write_byte(channel.id as u8);
        // is adult channel
        packet.write_byte(0);
    }

    packet.write_short(0);
    packet
}

// packet indicating that we have sent details for all available worlds
pub fn world_list_end() -> Packet {
    let mut packet = Packet::new();
    packet.write_short(0x0A);
    packet.write_byte(0xFF);
    packet
}

// pre-selects a world for the client after loading the world/server list
// TODO according to GMS, this should be the "most active" world
pub fn world_select(world_id: i32) -> Packet {
    let mut packet = Packet::new();
    packet.write_short(0x1A);
    packet.write_int(world_id);
    packet
}

// displays the "Recommended World" text for each world when the client selects "View Recommended"
pub fn view_recommended(worlds: &Vec<World>) -> Packet {
    let mut packet = Packet::new();
    packet.write_short(0x1B);
    packet.write_byte(worlds.len() as u8);

    for world in worlds.iter() {
        packet.write_int(world.config.id);
        packet.write_string(&world.config.recommended);
    }

    packet
}

// packet contatining the capacity status (# of connected players) for a world
pub fn world_status(status: CapacityStatus) -> Packet {
    let mut packet = Packet::new();
    packet.write_short(0x03);
    packet.write_short(status as i16);
    packet
}

pub fn character_list(characters: &Vec<Character>) -> Packet {
    let mut packet = Packet::new();
    packet.write_short(0x0B);
    // status code
    packet.write_byte(0);
    // number of characters
    packet.write_byte(characters.len() as u8);

    for character in characters.iter() {
        write_character(character, &mut packet, false);
    }

    // FIXME: 0 => register PIC, 1 => ask for PIC, 2 => disabled
    packet.write_byte(2);
    // number of character slots
    // TODO should be configurable via config/oxide.toml
    packet.write_int(3);
    packet
}

fn write_character(character: &Character, packet: &mut Packet, view_all: bool) {
    write_character_stats(character, packet);
    write_character_style(character, packet);
    write_character_equipment(character, packet);

    if !view_all {
        packet.write_byte(0);
    }

    // TODO check for gm job as well?
    if character.gm > 1 {
        packet.write_byte(0);
        return;
    }

    // TODO load from oxide.toml?
    let enable_rankings = true;
    packet.write_byte(enable_rankings as u8);

    if enable_rankings {
        packet.write_int(character.rank.rank);
        // positive/negative indicate direction of move
        packet.write_int(character.rank.rank_move);
        packet.write_int(character.rank.job_rank);
        // positive/negative indicate direction of move
        packet.write_int(character.rank.job_rank_move);
    }
}

fn write_character_stats(character: &Character, packet: &mut Packet) {
    packet.write_int(character.id);

    let mut padded_name = String::from(character.name.clone());

    for _ in padded_name.len()..13 {
        padded_name.push('\0');
    }

    packet.write_fixed_string(&padded_name);

    // style
    packet.write_byte(character.style.gender as u8);
    packet.write_byte(character.style.skin_colour as u8);
    packet.write_int(character.style.face);
    packet.write_int(character.style.hair);

    // pets
    for i in 0..3 {
        match character.pets.get(i) {
            Some(pet) => packet.write_long(pet.id.into()),
            None => packet.write_long(0),
        }
    }

    // stats
    packet.write_byte(character.stats.level as u8);
    packet.write_short(character.job as i16);
    packet.write_short(character.stats.str as i16);
    packet.write_short(character.stats.dex as i16);
    packet.write_short(character.stats.int as i16);
    packet.write_short(character.stats.luk as i16);
    packet.write_short(character.stats.hp as i16);
    packet.write_short(character.stats.max_hp as i16);
    packet.write_short(character.stats.mp as i16);
    packet.write_short(character.stats.max_mp as i16);
    packet.write_short(character.stats.ap as i16);
    // TODO can add remaining skill info here for evan
    // TODO get characters remaining sp for job
    packet.write_short(0);
    packet.write_int(character.stats.exp);
    packet.write_short(character.stats.fame as i16);
    packet.write_int(character.stats.gacha_exp);
    packet.write_int(character.map);
    packet.write_byte(character.spawn_point as u8);
    packet.write_int(0);
}

fn write_character_style(character: &Character, packet: &mut Packet) {
    packet.write_byte(character.style.gender);
    packet.write_byte(character.style.skin_colour as u8);
    packet.write_int(character.style.face);
    // TODO add mega parameter => I think for diplaying char in megaphone message?
    packet.write_byte(1);
    packet.write_int(character.style.hair);
}

fn write_character_equipment(character: &Character, packet: &mut Packet) {
    packet.write_byte(0x05); // 5
    packet.write_int(1040010);

    packet.write_byte(0x06); // 6
    packet.write_int(1060006);

    packet.write_byte(0x07); // 7
    packet.write_int(1072038);

    packet.write_byte(0x0B); // 11
    packet.write_int(1322005);

    packet.write_byte(0xFF);

    // TODO masked equips
    packet.write_byte(0xFF);

    // FIXME
    // Item cWeapon = equip.getItem((short) -111);
    // p.writeInt(cWeapon != null ? cWeapon.getItemId() : 0);
    packet.write_int(0);

    // pets
    for i in 0..3 {
        match character.pets.get(i) {
            Some(pet) => packet.write_int(pet.item_id),
            None => packet.write_int(0),
        }
    }
}

/*
pub fn character_name(name: &str, valid: bool) -> Packet {
    let mut packet = Packet::new(name.len() + 5);
    packet.write_short(0x0D);
    packet.write_maple_string(name);
    packet.write_byte(!valid as u8); // name is taken => !valid
    packet
}

pub fn create_character(character: &Character) -> Packet {
    let mut packet = Packet::new(256);
    packet.write_short(0x0E);
    packet.write_byte(0);

    add_character_stats(&mut packet, character);
    add_character_style(&mut packet, character);
    add_character_equipment(&mut packet, character);

    packet.write_byte(0); // view all

    // TODO if gm or gm job, write_byte(0) and return;

    packet.write_byte(1); // world rank enabled
    packet.write_int(character.rank.rank);
    packet.write_int(character.rank.rank_move); // positive => upwards, negative => downwards
    packet.write_int(character.rank.job_rank);
    packet.write_int(character.rank.job_rank_move); // positive => upwards, negative => downwards

    log::debug!("create_character packet size: {}", packet.data.len());
    packet
}
*/

```

`src/login/queries.rs`:

```rs
use crate::{character::Character, client, db::Db, Result};

use sqlx::{postgres::PgRow, Executor, Statement};

pub async fn get_account(name: &String, db: &Db) -> Result<PgRow> {
    let res = sqlx::query(
        "SELECT id, name, password, pin, pic, login_state, last_login, banned, accepted_tos \
        FROM accounts \
        WHERE name = $1",
    )
    .bind(name)
    .fetch_one(db)
    .await?;

    Ok(res)
}

pub async fn update_login_state(id: i32, login_state: i16, db: &Db) -> Result<()> {
    sqlx::query(
        "UPDATE accounts \
        SET login_state = $1, last_login = CURRENT_TIMESTAMP \
        WHERE id = $2",
    )
    .bind(login_state)
    .bind(id)
    .execute(db)
    .await?;

    Ok(())
}

pub async fn update_pin(id: i32, pin: &String, db: &Db) -> Result<()> {
    sqlx::query(
        "UPDATE accounts \
        SET pin = $1 \
        WHERE id = $2",
    )
    .bind(pin)
    .bind(id)
    .execute(db)
    .await?;

    Ok(())
}

pub async fn get_characters(client_id: i32, world_id: i32, db: &Db) -> Result<Vec<PgRow>> {
    let res = sqlx::query(
        "SELECT * \
        FROM characters \
        WHERE account_id = $1 AND world_id = $2",
    )
    .bind(client_id)
    .bind(world_id)
    .fetch_all(db)
    .await?;

    Ok(res)
}

```

`src/login/server.rs`:

```rs
use crate::{client::Client, db, net::connection::Connection, shutdown::Shutdown, Result, Shared};

use std::{
    future::Future,
    sync::{
        atomic::{AtomicUsize, Ordering},
        Arc,
    },
};
use tokio::{
    net::TcpListener,
    sync::{broadcast, mpsc},
};

#[derive(Debug)]
struct Listener {
    listener: TcpListener,
    notify_shutdown: broadcast::Sender<()>,
    shutdown_complete_rx: mpsc::Receiver<()>,
    shutdown_complete_tx: mpsc::Sender<()>,
    shared: Arc<Shared>,
}

pub async fn start(listener: TcpListener, shutdown: impl Future, shared: &Arc<Shared>) {
    let (notify_shutdown, _) = broadcast::channel(1);
    let (shutdown_complete_tx, shutdown_complete_rx) = mpsc::channel(1);

    let mut server = Listener {
        listener,
        notify_shutdown,
        shutdown_complete_tx,
        shutdown_complete_rx,
        shared: Arc::clone(shared),
    };

    tokio::select! {
        res = server.start() => {
            if let Err(e) = res {
                log::error!("Login server failed to accept connection: {}", e);
            }
        }
        _ = shutdown => {
            log::info!("Login server shutting down");
        }
    }

    // extract the shutdown_complete receiver and sender, explicitly drop shutdown_transmitter
    let Listener {
        mut shutdown_complete_rx,
        shutdown_complete_tx,
        notify_shutdown,
        ..
    } = server;

    // send the shutdown signal to all subscribed tasks
    drop(notify_shutdown);

    // drop the final sender to the below receiver can complete
    drop(shutdown_complete_tx);

    // wait for all active connections to finish processing
    let _ = shutdown_complete_rx.recv().await;
}

impl Listener {
    async fn start(&mut self) -> Result<()> {
        log::info!("Login server started on port 8484");

        let session_id = AtomicUsize::new(0);
        let db = db::new().await?;

        loop {
            // accept() returns a (TcpStream, SockAddr), ignore the SockAddr for now
            let socket = self.listener.accept().await?.0;

            let mut client = Client {
                session_id: session_id.fetch_add(1, Ordering::SeqCst),
                db: db.clone(),
                connection: Connection::new(socket).await?,
                shutdown: Shutdown::new(self.notify_shutdown.subscribe()),
                shared: Arc::clone(&self.shared),
                login_attempts: 0,
                pin_attempts: 0,
                id: None,
                pin: None,
                world_id: None,
                channel_id: None,
            };

            tokio::spawn(async move {
                if let Err(e) = client.connect().await {
                    log::error!("Client connection error: {}", e);
                }

                if let Err(e) = client.on_disconnect().await {
                    log::error!("Client on_disconnect() hook failed: {}", e);
                }

                log::info!("Client disconnected from login server");
            });
        }
    }
}

```

`src/main.rs`:

```rs
mod character;
mod client;
mod config;
mod crypto;
mod db;
mod handler;
mod login;
mod net;
mod shutdown;
mod world;

use log::LevelFilter;
use simple_logger::SimpleLogger;
use std::sync::Arc;
use tokio::{net::TcpListener, signal};
use world::World;

pub type Error = Box<dyn std::error::Error + Send + Sync>;
pub type Result<T> = std::result::Result<T, Error>;

#[derive(Debug)]
pub struct Shared {
    worlds: Vec<World>,
}

#[tokio::main]
async fn main() -> Result<()> {
    dotenv::dotenv().ok();

    SimpleLogger::new()
        .with_module_level("tokio_util", LevelFilter::Debug)
        .with_module_level("mio", LevelFilter::Debug)
        .with_module_level("tokio_postgres", LevelFilter::Debug)
        .env()
        .init()
        .unwrap();

    let shared = Arc::new(Shared {
        worlds: world::load_worlds(),
    });

    let listener = TcpListener::bind("127.0.0.1:8484").await?;
    login::server::start(listener, signal::ctrl_c(), &shared).await;

    Ok(())
}

```

`src/net/codec.rs`:

```rs
use super::packet::Packet;
use crate::{
    crypto::{cipher::Cipher, shanda},
    Error, Result,
};

use bytes::{BufMut, BytesMut};
use tokio_util::codec::{Decoder, Encoder};

#[derive(Debug)]
pub struct MapleCodec {
    send: Cipher,
    recv: Cipher,
}

impl MapleCodec {
    pub fn new(send: Cipher, recv: Cipher) -> Self {
        Self { send, recv }
    }

    fn create_packet_header(&self, len: usize) -> [u8; 4] {
        let len = len as u32;
        let mut a = u32::from(self.send.iv[3] & 0xff);
        a |= (u32::from(self.send.iv[2]) << 8) & 0xff00;
        a ^= u32::from(self.send.version);

        let b = a ^ (((len << 8) & 0xff00) | len >> 8);

        [
            ((a >> 8) & 0xff) as u8,
            (a & 0xff) as u8,
            ((b >> 8) & 0xff) as u8,
            (b & 0xff) as u8,
        ]
    }

    fn is_valid_header(&self, header: &BytesMut) -> bool {
        ((header[0] ^ self.recv.iv[2]) & 0xff) == ((self.recv.version >> 8) as u8 & 0xff)
            && (((header[1] ^ self.recv.iv[3]) & 0xff) == (self.recv.version & 0xff) as u8)
    }
}

impl Encoder<Packet> for MapleCodec {
    type Error = Error;

    fn encode(&mut self, packet: Packet, buf: &mut BytesMut) -> Result<()> {
        // create the packet header
        let header = self.create_packet_header(packet.len());
        // encrypt the packet body
        let encrypted = self.send.transform(shanda::encrypt(packet.bytes));

        buf.reserve(header.len() + encrypted.len());
        buf.put_slice(&header);
        buf.put(encrypted);

        Ok(())
    }
}

impl Decoder for MapleCodec {
    type Item = Packet;
    type Error = Error;

    fn decode(&mut self, buf: &mut BytesMut) -> Result<Option<Packet>> {
        if buf.is_empty() {
            return Ok(None);
        }

        // first 4 bytes of packet contain the header, remaining contain the body
        let mut bytes = buf.split_to(buf.len());
        // after split_off(), bytes will contain the first 4 bytes/header
        let body = bytes.split_off(4);

        // validate the packet header
        if !self.is_valid_header(&bytes) {
            log::error!("Packet contains an invalid header: {:?}", bytes);
            return Ok(None);
        }

        // decrypt the packet body
        let decrypted = shanda::decrypt(self.recv.transform(body));
        let packet = Packet::from_bytes(decrypted);

        Ok(Some(packet))
    }
}

```

`src/net/connection.rs`:

```rs
use super::{codec::MapleCodec, packet::Packet};
use crate::{
    crypto::cipher::{Cipher, CipherType},
    login::packets,
    Result,
};

use futures::SinkExt;
use tokio::{io::AsyncWriteExt, net::TcpStream};
use tokio_stream::StreamExt;
use tokio_util::codec::{Decoder, Framed};

#[derive(Debug)]
pub struct Connection {
    stream: Framed<TcpStream, MapleCodec>,
}

impl Connection {
    pub async fn new(mut socket: TcpStream) -> Result<Self> {
        let send = Cipher::new(CipherType::Send);
        let recv = Cipher::new(CipherType::Receive);

        Self::handshake(&mut socket, &send, &recv).await?;

        Ok(Self {
            stream: MapleCodec::new(send, recv).framed(socket),
        })
    }

    pub async fn read_packet(&mut self) -> Result<Option<Packet>> {
        loop {
            return Ok(self.stream.try_next().await?);
        }
    }

    pub async fn write_packet(&mut self, packet: Packet) -> Result<()> {
        self.stream.send(packet).await?;
        self.stream.flush().await?;
        Ok(())
    }

    pub async fn disconnect(&mut self) -> Result<()> {
        Ok(self.stream.close().await?)
    }

    // write the login server handshake packet directly to the TcpStream
    // we can't use write_packet() here since that will automatically encrypt the packet, and the
    // handshake is required to be unencrypted to setup client <-> server encryption
    async fn handshake(socket: &mut TcpStream, send: &Cipher, recv: &Cipher) -> Result<()> {
        let handshake = packets::handshake(&send, &recv);
        socket.write_all(&handshake.bytes).await?;
        socket.flush().await?;
        Ok(())
    }
}

```

`src/net/mod.rs`:

```rs
pub mod codec;
pub mod connection;
pub mod packet;

```

`src/net/packet.rs`:

```rs
use bytes::{Buf, BufMut, Bytes, BytesMut};
use std::fmt::{Display, Formatter};

#[derive(Debug)]
pub struct Packet {
    pub bytes: BytesMut,
}

impl Packet {
    pub fn new() -> Self {
        Self {
            // TODO: 1024 bytes should be fine for now, can increase to 2048 if there are some
            // larger packets. I believe the max maplestory packet size is 1460 bytes?
            // "It is important to note that this function does not specify the length of the
            // returned BytesMut, but only the capacity"
            bytes: BytesMut::with_capacity(1024),
        }
    }

    pub fn from_bytes(bytes: BytesMut) -> Self {
        Self { bytes }
    }

    pub fn write_byte(&mut self, byte: u8) {
        self.bytes.put_u8(byte);
    }

    pub fn write_bytes(&mut self, bytes: &[u8]) {
        self.bytes.put_slice(bytes);
    }

    pub fn write_short(&mut self, short: i16) {
        self.bytes.put_i16_le(short);
    }

    pub fn write_int(&mut self, int: i32) {
        self.bytes.put_i32_le(int);
    }

    pub fn write_long(&mut self, long: i64) {
        self.bytes.put_i64_le(long);
    }

    pub fn write_string(&mut self, string: &str) {
        self.write_short(string.len() as i16);
        self.write_bytes(string.as_bytes());
    }

    pub fn write_fixed_string(&mut self, string: &str) {
        self.write_bytes(string.as_bytes());
    }

    pub fn read_byte(&mut self) -> u8 {
        self.bytes.get_u8()
    }

    pub fn read_bytes(&mut self, len: usize) -> Bytes {
        self.bytes.split_to(len).freeze()
    }

    pub fn read_short(&mut self) -> i16 {
        self.bytes.get_i16_le()
    }

    pub fn read_string(&mut self) -> String {
        let len = self.read_short() as usize;
        let bytes = self.bytes.split_to(len);
        std::str::from_utf8(&bytes).unwrap().into()
    }

    pub fn skip(&mut self, num: usize) {
        self.bytes.advance(num)
    }

    pub fn len(&self) -> usize {
        self.bytes.len()
    }

    pub fn remaining(&self) -> usize {
        self.bytes.remaining()
    }
}

impl Display for Packet {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "[")?;

        let len = self.bytes.len();

        for i in 0..len {
            write!(f, "{:02X}", self.bytes[i])?;

            if i != len - 1 {
                write!(f, ", ")?;
            }
        }

        write!(f, "]")?;
        Ok(())
    }
}

```

`src/shutdown.rs`:

```rs
use tokio::sync::broadcast;

#[derive(Debug)]
pub struct Shutdown {
    // flag indicating whether the shutdown signal has been received
    shutdown: bool,

    // receive half of channel to listen for shutdown
    notify: broadcast::Receiver<()>,
}

impl Shutdown {
    pub fn new(notify: broadcast::Receiver<()>) -> Self {
        Self {
            shutdown: false,
            notify,
        }
    }

    pub fn is_shutdown(&self) -> bool {
        self.shutdown
    }

    pub async fn recv(&mut self) {
        // shutdown signal has already been received
        if self.shutdown {
            return;
        }

        // receive the shutdown signal
        let _ = self.notify.recv().await;
        self.shutdown = true;
    }
}

```

`src/world.rs`:

```rs
use crate::character::Character;

use serde::Deserialize;
use std::collections::HashMap;

#[derive(Debug)]
pub struct World {
    pub config: WorldConfig,
    pub channels: Vec<Channel>,
    pub players: HashMap<i32, Character>,
}

#[derive(Debug, Deserialize)]
pub struct Config {
    pub worlds: Vec<WorldConfig>,
}

#[derive(Debug, Deserialize)]
pub struct WorldConfig {
    pub id: i32,
    pub name: String,
    pub channels: i32,
    // 0 => nothing, 1 => event, 2 => new, 3 => hot
    pub flag: i32,
    pub event_message: String,
    pub recommended: String,
    exp_rate: i32,
    drop_rate: i32,
    boss_drop_rate: i32,
    meso_rate: i32,
    quest_rate: i32,
    travel_rate: i32,
    fishing_rate: i32,
}

#[derive(Debug)]
pub struct Channel {
    pub id: i32,
    world_id: i32,
}

#[derive(Debug, PartialEq)]
pub enum CapacityStatus {
    Normal,
    HighlyPopulated,
    Full,
}

pub fn load_worlds() -> Vec<World> {
    let mut worlds = Vec::new();
    let toml = std::fs::read_to_string("config/worlds.toml").unwrap();
    let config: Config = toml::from_str(&toml).unwrap();

    for w in config.worlds.into_iter() {
        let world = World::from_config(w);
        worlds.push(world);
    }

    worlds
}

impl World {
    pub fn from_config(config: WorldConfig) -> Self {
        let channels = Self::load_channels(&config);

        World {
            config,
            channels,
            players: HashMap::new(),
        }
    }

    pub fn load_channels(config: &WorldConfig) -> Vec<Channel> {
        let mut channels = Vec::new();

        for i in 0..config.channels {
            let channel = Channel::new(i, config.id);
            channels.push(channel);
        }

        channels
    }

    pub fn get_capacity_status(&self) -> CapacityStatus {
        let max_capacity = self.channels.len() * 100;
        let connected_players = self.players.len();

        if connected_players >= max_capacity {
            return CapacityStatus::Full;
        } else if connected_players >= (max_capacity as f32 * 0.8) as usize {
            return CapacityStatus::HighlyPopulated;
        }

        return CapacityStatus::Normal;
    }
}

impl Channel {
    pub fn new(id: i32, world_id: i32) -> Self {
        Channel { id, world_id }
    }
}

```