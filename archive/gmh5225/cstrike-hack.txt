Project Path: arc_gmh5225_cstrike-hack_8g3mtq6h

Source Tree:

```txt
arc_gmh5225_cstrike-hack_8g3mtq6h
├── README.md
├── cstrike
│   ├── config.h
│   ├── cstrike.cpp
│   ├── cstrike.h
│   ├── dllmain.cpp
│   ├── features
│   │   ├── features.h
│   │   └── visuals
│   │       ├── visuals.cpp
│   │       └── visuals.h
│   ├── hooked
│   │   ├── functions
│   │   │   ├── cdll_client.cpp
│   │   │   ├── cl_main.cpp
│   │   │   ├── client_input.cpp
│   │   │   ├── client_mode_shared.cpp
│   │   │   ├── cs_player.cpp
│   │   │   ├── csgo_player_anim_state.cpp
│   │   │   ├── mat_system_surface.cpp
│   │   │   ├── prediction.cpp
│   │   │   ├── scheme_manager.cpp
│   │   │   ├── studio_render.cpp
│   │   │   ├── vgui_baseui.cpp
│   │   │   └── weapon_cs_base.cpp
│   │   ├── hooked.cpp
│   │   └── hooked.h
│   ├── input
│   │   ├── input.cpp
│   │   └── input.h
│   ├── menu
│   │   ├── menu.cpp
│   │   ├── menu.h
│   │   └── objects
│   │       ├── checkbox
│   │       │   ├── checkbox.cpp
│   │       │   └── checkbox.h
│   │       ├── group
│   │       │   ├── group.cpp
│   │       │   └── group.h
│   │       ├── key
│   │       │   ├── key.cpp
│   │       │   └── key.h
│   │       ├── object.cpp
│   │       ├── object.h
│   │       ├── objects.h
│   │       ├── slider
│   │       │   ├── slider.cpp
│   │       │   └── slider.h
│   │       └── tab
│   │           ├── tab.cpp
│   │           └── tab.h
│   └── render
│       ├── render.cpp
│       └── render.h
├── cstrike-hack.vcxproj
├── cstrike-hack.vcxproj.filters
├── other
│   ├── color
│   │   └── color.h
│   ├── console
│   │   ├── console.cpp
│   │   └── console.h
│   ├── easing
│   │   └── easing.h
│   ├── hash
│   │   ├── hash.cpp
│   │   └── hash.h
│   ├── math
│   │   ├── q_angle.h
│   │   └── vector_3d.h
│   ├── memory
│   │   ├── address.h
│   │   └── stack.h
│   ├── module
│   │   ├── module.cpp
│   │   └── module.h
│   ├── other.h
│   ├── pe
│   │   ├── pe.cpp
│   │   └── pe.h
│   └── utils
│       ├── utils.cpp
│       └── utils.h
└── valve
    ├── cdll_int.h
    ├── client
    │   ├── animation_layer.h
    │   ├── base_animating.h
    │   ├── base_combat_character.h
    │   ├── base_entity.h
    │   ├── base_player.h
    │   ├── client.h
    │   ├── client_input.h
    │   ├── cs_player.h
    │   ├── net_graph_panel.h
    │   ├── prediction.h
    │   └── weapon_cs_base.h
    ├── client_class.h
    ├── client_entity_list.h
    ├── client_networkable.h
    ├── client_renderable.h
    ├── data_cache
    │   ├── data_cache.h
    │   └── mdl_cache.h
    ├── dt_common.h
    ├── dt_recv.h
    ├── engine
    │   ├── client.h
    │   ├── debug_overlay.h
    │   ├── engine.h
    │   └── vgui_baseui.h
    ├── engine_vgui.h
    ├── global_vars_base.h
    ├── interfaces
    │   ├── interfaces.cpp
    │   └── interfaces.h
    ├── material_system
    │   ├── material.h
    │   └── material_system.h
    ├── mathlib
    │   ├── mathlib.h
    │   └── mathlib_base.h
    ├── modules
    │   ├── modules.cpp
    │   └── modules.h
    ├── net_channel.h
    ├── netvars
    │   ├── netvars.cpp
    │   └── netvars.h
    ├── shared
    │   ├── base_view_model.h
    │   ├── csgo_player_anim_state.h
    │   ├── game_movement.h
    │   ├── in_buttons.h
    │   ├── move_helper.h
    │   ├── shared.h
    │   └── user_cmd.h
    ├── studio.h
    ├── studio_render
    │   ├── studio_render.h
    │   └── studio_render_context.h
    ├── tier0
    │   ├── mem_alloc.h
    │   └── tier0.h
    ├── tier1
    │   ├── bitbuf.h
    │   ├── interface.h
    │   ├── localize.h
    │   └── tier1.h
    ├── valve.h
    └── vgui
        ├── surface.h
        └── vgui.h

```

`README.md`:

```md
# cstrike-hack

A C++ hack for the video game: Counter-Strike Global Offensive

```

`cstrike-hack.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{b479c0f2-2a5a-400a-90be-d2a1f8e9341b}</ProjectGuid>
    <RootNamespace>cstrikehack</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="cstrike\cstrike.cpp" />
    <ClCompile Include="cstrike\dllmain.cpp" />
    <ClCompile Include="cstrike\features\visuals\visuals.cpp" />
    <ClCompile Include="cstrike\hooked\functions\cdll_client.cpp" />
    <ClCompile Include="cstrike\hooked\functions\client_input.cpp" />
    <ClCompile Include="cstrike\hooked\functions\client_mode_shared.cpp" />
    <ClCompile Include="cstrike\hooked\functions\cl_main.cpp" />
    <ClCompile Include="cstrike\hooked\functions\csgo_player_anim_state.cpp" />
    <ClCompile Include="cstrike\hooked\functions\cs_player.cpp" />
    <ClCompile Include="cstrike\hooked\functions\mat_system_surface.cpp" />
    <ClCompile Include="cstrike\hooked\functions\prediction.cpp" />
    <ClCompile Include="cstrike\hooked\functions\vgui_baseui.cpp" />
    <ClCompile Include="cstrike\hooked\functions\scheme_manager.cpp" />
    <ClCompile Include="cstrike\hooked\functions\studio_render.cpp" />
    <ClCompile Include="cstrike\hooked\functions\weapon_cs_base.cpp" />
    <ClCompile Include="cstrike\hooked\hooked.cpp" />
    <ClCompile Include="cstrike\input\input.cpp" />
    <ClCompile Include="cstrike\menu\menu.cpp" />
    <ClCompile Include="cstrike\menu\objects\checkbox\checkbox.cpp" />
    <ClCompile Include="cstrike\menu\objects\group\group.cpp" />
    <ClCompile Include="cstrike\menu\objects\key\key.cpp" />
    <ClCompile Include="cstrike\menu\objects\object.cpp" />
    <ClCompile Include="cstrike\menu\objects\slider\slider.cpp" />
    <ClCompile Include="cstrike\menu\objects\tab\tab.cpp" />
    <ClCompile Include="cstrike\render\render.cpp" />
    <ClCompile Include="other\console\console.cpp" />
    <ClCompile Include="other\hash\hash.cpp" />
    <ClCompile Include="other\module\module.cpp" />
    <ClCompile Include="other\pe\pe.cpp" />
    <ClCompile Include="other\utils\utils.cpp" />
    <ClCompile Include="valve\interfaces\interfaces.cpp" />
    <ClCompile Include="valve\modules\modules.cpp" />
    <ClCompile Include="valve\netvars\netvars.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="cstrike\features\features.h" />
    <ClInclude Include="cstrike\features\visuals\visuals.h" />
    <ClInclude Include="cstrike\input\input.h" />
    <ClInclude Include="cstrike\menu\menu.h" />
    <ClInclude Include="cstrike\menu\objects\objects.h" />
    <ClInclude Include="cstrike\menu\objects\checkbox\checkbox.h" />
    <ClInclude Include="cstrike\menu\objects\group\group.h" />
    <ClInclude Include="cstrike\menu\objects\key\key.h" />
    <ClInclude Include="cstrike\menu\objects\object.h" />
    <ClInclude Include="cstrike\menu\objects\slider\slider.h" />
    <ClInclude Include="cstrike\menu\objects\tab\tab.h" />
    <ClInclude Include="cstrike\render\render.h" />
    <ClInclude Include="cstrike\config.h" />
    <ClInclude Include="other\color\color.h" />
    <ClInclude Include="other\easing\easing.h" />
    <ClInclude Include="other\math\q_angle.h" />
    <ClInclude Include="other\math\vector_3d.h" />
    <ClInclude Include="other\hash\hash.h" />
    <ClInclude Include="other\memory\stack.h" />
    <ClInclude Include="other\module\module.h" />
    <ClInclude Include="other\pe\pe.h" />
    <ClInclude Include="valve\cdll_int.h" />
    <ClInclude Include="valve\client\animation_layer.h" />
    <ClInclude Include="valve\client\base_animating.h" />
    <ClInclude Include="valve\client\base_combat_character.h" />
    <ClInclude Include="valve\client\client_input.h" />
    <ClInclude Include="valve\client\net_graph_panel.h" />
    <ClInclude Include="valve\client\prediction.h" />
    <ClInclude Include="valve\client\weapon_cs_base.h" />
    <ClInclude Include="valve\client\base_entity.h" />
    <ClInclude Include="valve\client\base_player.h" />
    <ClInclude Include="valve\client\client.h" />
    <ClInclude Include="valve\client\cs_player.h" />
    <ClInclude Include="cstrike\cstrike.h" />
    <ClInclude Include="cstrike\hooked\hooked.h" />
    <ClInclude Include="other\console\console.h" />
    <ClInclude Include="other\memory\address.h" />
    <ClInclude Include="other\other.h" />
    <ClInclude Include="other\utils\utils.h" />
    <ClInclude Include="valve\client_class.h" />
    <ClInclude Include="valve\client_entity_list.h" />
    <ClInclude Include="valve\client_networkable.h" />
    <ClInclude Include="valve\client_renderable.h" />
    <ClInclude Include="valve\data_cache\data_cache.h" />
    <ClInclude Include="valve\data_cache\mdl_cache.h" />
    <ClInclude Include="valve\dt_common.h" />
    <ClInclude Include="valve\dt_recv.h" />
    <ClInclude Include="valve\engine\client.h" />
    <ClInclude Include="valve\engine\debug_overlay.h" />
    <ClInclude Include="valve\engine\engine.h" />
    <ClInclude Include="valve\engine\vgui_baseui.h" />
    <ClInclude Include="valve\engine_vgui.h" />
    <ClInclude Include="valve\global_vars_base.h" />
    <ClInclude Include="valve\interfaces\interfaces.h" />
    <ClInclude Include="valve\material_system\material.h" />
    <ClInclude Include="valve\material_system\material_system.h" />
    <ClInclude Include="valve\mathlib\mathlib.h" />
    <ClInclude Include="valve\mathlib\mathlib_base.h" />
    <ClInclude Include="valve\modules\modules.h" />
    <ClInclude Include="valve\netvars\netvars.h" />
    <ClInclude Include="valve\net_channel.h" />
    <ClInclude Include="valve\shared\base_view_model.h" />
    <ClInclude Include="valve\shared\csgo_player_anim_state.h" />
    <ClInclude Include="valve\shared\game_movement.h" />
    <ClInclude Include="valve\shared\in_buttons.h" />
    <ClInclude Include="valve\shared\move_helper.h" />
    <ClInclude Include="valve\shared\shared.h" />
    <ClInclude Include="valve\shared\user_cmd.h" />
    <ClInclude Include="valve\studio.h" />
    <ClInclude Include="valve\studio_render\studio_render.h" />
    <ClInclude Include="valve\studio_render\studio_render_context.h" />
    <ClInclude Include="valve\tier0\mem_alloc.h" />
    <ClInclude Include="valve\tier0\tier0.h" />
    <ClInclude Include="valve\tier1\bitbuf.h" />
    <ClInclude Include="valve\tier1\interface.h" />
    <ClInclude Include="valve\tier1\localize.h" />
    <ClInclude Include="valve\tier1\tier1.h" />
    <ClInclude Include="valve\valve.h" />
    <ClInclude Include="valve\vgui\surface.h" />
    <ClInclude Include="valve\vgui\vgui.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`cstrike-hack.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="cstrike\dllmain.cpp" />
    <ClCompile Include="cstrike\cstrike.cpp" />
    <ClCompile Include="other\utils\utils.cpp" />
    <ClCompile Include="other\console\console.cpp" />
    <ClCompile Include="cstrike\hooked\hooked.cpp" />
    <ClCompile Include="valve\netvars\netvars.cpp" />
    <ClCompile Include="valve\interfaces\interfaces.cpp" />
    <ClCompile Include="other\hash\hash.cpp" />
    <ClCompile Include="cstrike\render\render.cpp" />
    <ClCompile Include="cstrike\features\visuals\visuals.cpp" />
    <ClCompile Include="cstrike\hooked\functions\client_mode_shared.cpp" />
    <ClCompile Include="cstrike\hooked\functions\weapon_cs_base.cpp" />
    <ClCompile Include="cstrike\hooked\functions\csgo_player_anim_state.cpp" />
    <ClCompile Include="cstrike\input\input.cpp" />
    <ClCompile Include="cstrike\hooked\functions\client_input.cpp" />
    <ClCompile Include="cstrike\hooked\functions\scheme_manager.cpp" />
    <ClCompile Include="cstrike\hooked\functions\studio_render.cpp" />
    <ClCompile Include="cstrike\hooked\functions\cdll_client.cpp" />
    <ClCompile Include="other\pe\pe.cpp" />
    <ClCompile Include="cstrike\hooked\functions\vgui_baseui.cpp" />
    <ClCompile Include="cstrike\menu\menu.cpp" />
    <ClCompile Include="cstrike\menu\objects\group\group.cpp" />
    <ClCompile Include="cstrike\menu\objects\tab\tab.cpp" />
    <ClCompile Include="cstrike\menu\objects\object.cpp" />
    <ClCompile Include="cstrike\menu\objects\checkbox\checkbox.cpp" />
    <ClCompile Include="cstrike\hooked\functions\mat_system_surface.cpp" />
    <ClCompile Include="cstrike\menu\objects\slider\slider.cpp" />
    <ClCompile Include="cstrike\menu\objects\key\key.cpp" />
    <ClCompile Include="other\module\module.cpp" />
    <ClCompile Include="cstrike\hooked\functions\cl_main.cpp" />
    <ClCompile Include="cstrike\hooked\functions\cs_player.cpp" />
    <ClCompile Include="valve\modules\modules.cpp" />
    <ClCompile Include="cstrike\hooked\functions\prediction.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="cstrike\cstrike.h" />
    <ClInclude Include="other\utils\utils.h" />
    <ClInclude Include="other\other.h" />
    <ClInclude Include="other\console\console.h" />
    <ClInclude Include="other\memory\address.h" />
    <ClInclude Include="valve\valve.h" />
    <ClInclude Include="cstrike\hooked\hooked.h" />
    <ClInclude Include="valve\client\base_animating.h" />
    <ClInclude Include="valve\client\base_combat_character.h" />
    <ClInclude Include="valve\client\base_entity.h" />
    <ClInclude Include="valve\client\base_player.h" />
    <ClInclude Include="valve\client\cs_player.h" />
    <ClInclude Include="valve\client\client.h" />
    <ClInclude Include="other\math\q_angle.h" />
    <ClInclude Include="other\math\vector_3d.h" />
    <ClInclude Include="valve\shared\shared.h" />
    <ClInclude Include="valve\shared\user_cmd.h" />
    <ClInclude Include="valve\shared\in_buttons.h" />
    <ClInclude Include="valve\netvars\netvars.h" />
    <ClInclude Include="valve\dt_recv.h" />
    <ClInclude Include="valve\dt_common.h" />
    <ClInclude Include="valve\client_class.h" />
    <ClInclude Include="valve\interfaces\interfaces.h" />
    <ClInclude Include="valve\cdll_int.h" />
    <ClInclude Include="other\hash\hash.h" />
    <ClInclude Include="valve\vgui\surface.h" />
    <ClInclude Include="valve\vgui\vgui.h" />
    <ClInclude Include="cstrike\render\render.h" />
    <ClInclude Include="other\color\color.h" />
    <ClInclude Include="cstrike\features\visuals\visuals.h" />
    <ClInclude Include="cstrike\features\features.h" />
    <ClInclude Include="valve\client_entity_list.h" />
    <ClInclude Include="valve\client_renderable.h" />
    <ClInclude Include="valve\client_networkable.h" />
    <ClInclude Include="valve\engine\debug_overlay.h" />
    <ClInclude Include="valve\engine\engine.h" />
    <ClInclude Include="valve\global_vars_base.h" />
    <ClInclude Include="valve\tier1\localize.h" />
    <ClInclude Include="valve\tier1\tier1.h" />
    <ClInclude Include="other\easing\easing.h" />
    <ClInclude Include="other\memory\stack.h" />
    <ClInclude Include="valve\client\weapon_cs_base.h" />
    <ClInclude Include="valve\shared\csgo_player_anim_state.h" />
    <ClInclude Include="valve\mathlib\mathlib.h" />
    <ClInclude Include="valve\mathlib\mathlib_base.h" />
    <ClInclude Include="valve\client\animation_layer.h" />
    <ClInclude Include="valve\data_cache\mdl_cache.h" />
    <ClInclude Include="valve\data_cache\data_cache.h" />
    <ClInclude Include="valve\studio.h" />
    <ClInclude Include="cstrike\input\input.h" />
    <ClInclude Include="valve\client\client_input.h" />
    <ClInclude Include="cstrike\config.h" />
    <ClInclude Include="valve\studio_render\studio_render.h" />
    <ClInclude Include="valve\studio_render\studio_render_context.h" />
    <ClInclude Include="valve\tier1\interface.h" />
    <ClInclude Include="valve\client\net_graph_panel.h" />
    <ClInclude Include="valve\material_system\material.h" />
    <ClInclude Include="valve\material_system\material_system.h" />
    <ClInclude Include="other\pe\pe.h" />
    <ClInclude Include="valve\engine_vgui.h" />
    <ClInclude Include="valve\engine\vgui_baseui.h" />
    <ClInclude Include="cstrike\menu\menu.h" />
    <ClInclude Include="cstrike\menu\objects\object.h" />
    <ClInclude Include="cstrike\menu\objects\group\group.h" />
    <ClInclude Include="cstrike\menu\objects\tab\tab.h" />
    <ClInclude Include="cstrike\menu\objects\checkbox\checkbox.h" />
    <ClInclude Include="cstrike\menu\objects\slider\slider.h" />
    <ClInclude Include="cstrike\menu\objects\key\key.h" />
    <ClInclude Include="cstrike\menu\objects\objects.h" />
    <ClInclude Include="other\module\module.h" />
    <ClInclude Include="valve\engine\client.h" />
    <ClInclude Include="valve\tier1\bitbuf.h" />
    <ClInclude Include="valve\net_channel.h" />
    <ClInclude Include="valve\tier0\tier0.h" />
    <ClInclude Include="valve\tier0\mem_alloc.h" />
    <ClInclude Include="valve\shared\base_view_model.h" />
    <ClInclude Include="valve\modules\modules.h" />
    <ClInclude Include="valve\client\prediction.h" />
    <ClInclude Include="valve\shared\move_helper.h" />
    <ClInclude Include="valve\shared\game_movement.h" />
  </ItemGroup>
</Project>
```

`cstrike/config.h`:

```h
#pragma once

struct config {

	bool m_menu_open = true;

	struct {



	} m_legit;

	struct {



	} m_hvh;

	struct {

		bool active = true;
		bool player_box = true;
		bool player_health = true;
		bool player_name = true;
		bool player_weapon = true;
		bool player_ammo = true;

		bool chams = true;
		bool third_person = false;
		int thirdperson_key = 0x56;
		int thirdperson_distance = 150;

	} m_esp;

	struct {

		int viewmodel_fov = 90;

		bool server_hitboxes = false;

	} m_misc;

};

inline config m_config;
```

`cstrike/cstrike.cpp`:

```cpp
#include "cstrike.h"

#include "hooked/hooked.h"
#include "render/render.h"
#include "menu/menu.h"

DWORD WINAPI cstrike::setup( void* parameter ) {

	HMODULE handle = static_cast< HMODULE >( parameter );

	m_console.setup( "cstrike-hack" );

	while ( !( m_cstrike.m_window = FindWindowA( "Valve001", nullptr ) ) )
		m_utils.sleep( 100 );

	if ( !m_pe.setup( ) || !m_modules.setup( ) || !m_interfaces.setup( ) || !m_netvars.setup( ) 
		|| !m_input.setup( ) || !m_render.setup( ) || !m_hooked.setup( ) || !m_menu.setup( ) ) {

		FreeLibraryAndExitThread( handle , EXIT_FAILURE );

		return EXIT_FAILURE;

	}

	while ( !m_input.is_key_down( VK_DELETE ) )
		m_utils.sleep( 100 );

	FreeLibraryAndExitThread( handle, EXIT_SUCCESS );

	return EXIT_SUCCESS;

}

void cstrike::unload( ) {

	m_input.unload( );

	m_hooked.unload( );

	m_console.unload( );

	Beep( 400, 400 );

}

void cstrike::iterate_players( std::function< void( cs_player* ) > function, int flags ) {

	if ( !m_local_player )
		return;

	for ( int i = 1; i <= m_interfaces.m_globals->m_max_clients; i++ ) {

		cs_player* player = m_interfaces.m_entity_list->get< cs_player* >( i );
		if ( !player )
			continue;

		if ( !( flags & iterate_dead ) )
			if ( !player->is_alive( ) )
				continue;

		if ( !( flags & iterate_dormant ) )
			if ( player->get_client_networkable( )->is_dormant( ) )
				continue;

		if ( !( flags & iterate_teammates ) )
			if ( player->get_team( ) == m_local_player->get_team( ) )
				continue;

		function( player );

	}

}
```

`cstrike/cstrike.h`:

```h
#pragma once

#include <functional>

#include "config.h"

#include "../other/other.h"
#include "../valve/valve.h"

enum iterate_player_flags {

	iterate_dead = 1,
	iterate_dormant = 1 << 1,
	iterate_teammates = 1 << 2,

};

struct cstrike {

	static DWORD WINAPI setup( void* parameter );

	void unload( );

	void iterate_players( std::function< void( cs_player* ) > function, int flags = { } );

	HWND m_window;

	cs_player* m_local_player;

};

inline cstrike m_cstrike;
```

`cstrike/dllmain.cpp`:

```cpp
#include "cstrike.h"

BOOL APIENTRY DllMain( HMODULE module_handle, DWORD call_reason, LPVOID reserved ) {

	if ( call_reason == DLL_PROCESS_ATTACH ) {

		DisableThreadLibraryCalls( module_handle );

		return m_utils.create_thread( m_cstrike.setup, module_handle );

	} else if ( call_reason == DLL_PROCESS_DETACH ) {

		m_cstrike.unload( );

		return TRUE;

	}

	return FALSE;

}
```

`cstrike/features/features.h`:

```h
#pragma once

#include "visuals/visuals.h"
```

`cstrike/features/visuals/visuals.cpp`:

```cpp
#include "visuals.h"

#include <algorithm>

#include "../../render/render.h"

void visuals::paint( ) {

	draw_watermark( );

	draw_local_info( );

	if ( !m_config.m_esp.active )
		return;

	m_cstrike.iterate_players( [ this ]( cs_player* player ) -> void {

		m_player = {

			player,
			player->get_client_networkable( )->get_index( ),
			player->get_client_networkable( )->is_dormant( ),

		};

		if ( !calculate_box( ) )
			return;

		m_weapon.pointer = m_interfaces.m_entity_list->get< weapon_cs_base* >( m_player.pointer->get_active_weapon( ) );
		if ( m_weapon.pointer )
			m_weapon.info = m_weapon.pointer->get_cs_wpn_data( );

		calculate_alpha( );

		m_player.m_colors.dark = color( 0, 0, 0, m_alpha[ m_player.index - 1 ] );
		m_player.m_colors.light = color( 255, 255, 255, m_alpha[ m_player.index - 1 ] );

		draw_box( );

		draw_health( );

		draw_name( );

		draw_weapon( );

		draw_ammo( );

		}, { iterate_dormant } );

}

void visuals::draw_watermark( ) {

	int fps = static_cast< int >( 1.f / m_interfaces.m_net_graph_panel->m_frame_rate );

	m_render.draw_text( m_render.m_fonts.main,
		m_render.m_screen.w - 5, 5,
		m_render.format_text( "%s | local: 0x%x | fps: %d", "cstrike-hack", m_cstrike.m_local_player, fps ),
		m_colors.light,
		x_right );

}

void visuals::draw_local_info( ) {

	if ( !m_cstrike.m_local_player )
		return;

	csgo_player_anim_state* anim_state = m_cstrike.m_local_player->get_player_anim_state_csgo( );
	if ( !anim_state )
		return;

	float lower_body_realign_time_remaining = std::fmaxf( 0.f, anim_state->m_lower_body_realign_timer - m_interfaces.m_globals->m_curtime );

	m_render.draw_text( m_render.m_fonts.main,
		5, m_render.m_screen.h / 2,
		m_render.format_text( "lby update in: %g", lower_body_realign_time_remaining ),
		m_colors.light );

}

void visuals::draw_box( ) {

	if ( !m_config.m_esp.player_box )
		return;

	m_render.draw_outlined_rect( m_box.x - 1, m_box.y - 1, 
		m_box.width + 2, m_box.height + 2, 
		m_player.m_colors.dark );

	m_render.draw_outlined_rect( m_box.x + 1, m_box.y + 1, 
		m_box.width - 2, m_box.height - 2, 
		m_player.m_colors.dark );

	m_render.draw_outlined_rect( m_box.x, m_box.y,
		m_box.width, m_box.height, 
		m_player.m_colors.light );

}

void visuals::draw_health( ) {

	if ( !m_config.m_esp.player_health )
		return;

	int health = m_player.pointer->get_health( ), 
		scaler = static_cast< int >( 2.55 * health );

	m_render.draw_filled_rect( m_box.x - 2, m_box.y - 1, 
		4, m_box.height + 2, 
		m_player.m_colors.dark,
		x_right );

	m_render.draw_filled_rect( m_box.x - 3, m_box.y, 
		2, health * m_box.height / 100, 
		color( 255 - scaler, scaler, 0, m_alpha[ m_player.index - 1 ] ),
		x_right );

	if ( health == 100 )
		return;

	m_render.draw_text( m_render.m_fonts.main, 
		m_box.x - 7, m_box.y + health * m_box.height / 100, 
		m_render.format_text( "%d", health ),
		m_player.m_colors.light,
		x_right | y_centre );

}

void visuals::draw_name( ) {

	if ( !m_config.m_esp.player_name )
		return;

	player_info info;
	if ( !m_interfaces.m_engine->get_player_info( m_player.index, &info ) )
		return;

	std::string name = info.m_name;
	std::transform( name.begin( ), name.end( ), name.begin( ), std::tolower );

	if ( !info.m_xuid_low )
		name.append( " - bot" );

	m_render.draw_text( m_render.m_fonts.main,
		m_box.x + m_box.width / 2, m_box.y - 1, 
		name, 
		m_player.m_colors.light,
		x_centre | y_bottom );

}

void visuals::draw_weapon( ) {

	if ( !m_config.m_esp.player_weapon )
		return;

	if ( !m_weapon.pointer )
		return;

	int gap = m_config.m_esp.player_ammo ? 5 : 0;

	std::wstring weapon_name = m_interfaces.m_localize->find( m_weapon.info->m_hud_name );
	std::transform( weapon_name.begin( ), weapon_name.end( ), weapon_name.begin( ), std::toupper );

	m_render.draw_text( m_render.m_fonts.main,
		m_box.x + m_box.width / 2, m_box.y + m_box.height + gap,
		weapon_name,
		m_player.m_colors.light,
		x_centre );

}

void visuals::draw_ammo( ) {

	if ( !m_config.m_esp.player_ammo )
		return;

	if ( !m_weapon.pointer )
		return;

	float scaler = static_cast< float >( m_weapon.pointer->get_ammo( ) ) / static_cast< float >( m_weapon.info->m_max_clip1 );

	animation_layer* animation_layer_weapon_action = m_player.pointer->get_anim_overlay( 1 );
	if ( animation_layer_weapon_action ) {

		int activity = m_player.pointer->get_sequence_activity( animation_layer_weapon_action->m_sequence );
		if ( activity == 967 && animation_layer_weapon_action->m_weight != 0.f )
			scaler = animation_layer_weapon_action->m_cycle;

	}

	m_render.draw_filled_rect( m_box.x - 1, m_box.y + m_box.height + 2,
		m_box.width + 2, 4,
		m_player.m_colors.dark );

	m_render.draw_filled_rect( m_box.x, m_box.y + m_box.height + 3,
		static_cast< int >( m_box.width * scaler ), 2,
		color( 0, 128, 255, m_alpha[ m_player.index - 1 ] ) );

}

void visuals::calculate_alpha( ) {

	float delta_time = m_interfaces.m_globals->m_curtime - m_player.pointer->get_simulation_time( );

	double opacity = m_player.is_dormant ? m_easing.in_cubic( 1.0 - std::clamp( delta_time, 0.f, 1.f ) ) : 1.0;

	m_alpha[ m_player.index - 1 ] = static_cast< int >( 255 * opacity );

}

bool visuals::calculate_box( ) {

	vector_3d mins, maxs;
	m_player.pointer->get_client_renderable( )->get_render_bounds( mins, maxs );

	vector_3d origin = m_player.pointer->get_origin( ), screen_origin;
	origin.z -= 5.f;

	vector_3d top = m_player.pointer->get_origin( ), screen_top;
	top.z += maxs.z;

	if ( m_interfaces.m_debug_overlay->screen_position( origin, screen_origin ) == -1
		|| m_interfaces.m_debug_overlay->screen_position( top, screen_top ) == -1 )
		return false;

	float height = screen_origin.y - screen_top.y;
	float width = height / 2;

	m_box = {

		static_cast< int >( screen_origin.x - width / 2 ),
		static_cast< int >( screen_top.y ),
		static_cast< int >( width ),
		static_cast< int >( height )

	};

	return true;

}
```

`cstrike/features/visuals/visuals.h`:

```h
#pragma once

#include <array>

#include "../../cstrike.h"

struct visuals {

	void paint( );

private:

	void draw_watermark( );

	void draw_local_info( );

	void draw_box( );

	void draw_health( );

	void draw_name( );

	void draw_weapon( );

	void draw_ammo( );

	void calculate_alpha( );

	bool calculate_box( );

	struct {

		int x, y, width, height;

	} m_box;

	struct {

		cs_player* pointer;
		
		int index;

		bool is_dormant;

		struct {

			color dark, light;

		} m_colors;

	} m_player;

	struct {

		weapon_cs_base* pointer;

		cs_weapon_info* info;

	} m_weapon;

	struct {

		color light = color( 255, 255, 255 );

	} m_colors;

	std::array< int, 64 > m_alpha;

};

inline visuals m_visuals;
```

`cstrike/hooked/functions/cdll_client.cpp`:

```cpp
#include "../hooked.h"

void __fastcall hooked::cdll_client_fn::level_shutdown( void* ecx, void* edx ) {

	static auto o_level_shutdown = m_modules.m_client_dll.get< decltype( &level_shutdown ) >( "CHLClient::LevelShutdown" );

	m_cstrike.m_local_player = nullptr;

	return o_level_shutdown( ecx, edx );

}

```

`cstrike/hooked/functions/cl_main.cpp`:

```cpp
#include "../hooked.h"

struct cl_msg_move {

	cl_msg_move( ) {

		m_net_message_vtable = m_modules.m_engine_dll.get_address( "CL_SendMove" ).add( 0x76 ).to< std::size_t >( );
		m_cl_msg_move_vtable = m_modules.m_engine_dll.get_address( "CL_SendMove" ).add( 0x82 ).to< std::size_t >( );
		m_allocated_memory = m_modules.m_engine_dll.get_address( "CL_SendMove" ).add( 0x7b ).to< void* >( );

		m_unknown = 15;

		m_flags = 3;

		m_unknown1 = 0;
		m_unknown2 = 0;
		m_unknown3 = 0;
		m_unknown4 = 0;
		m_unknown5 = 0;

	}

	~cl_msg_move( ) {

		static auto function = m_modules.m_engine_dll.get_address( "CCLCMsg_Move::Deconstuctor" ).as< void( __thiscall* )( void* ) >( );

		function( this );

	}

	inline auto set_num_backup_commands( int backup_commands ) {

		m_backup_commands = backup_commands;

	}

	inline auto set_num_new_commands( int new_commands ) {

		m_new_commands = new_commands;

	}

	inline auto set_data( unsigned char* data, int num_bytes_written ) {

		m_flags |= 4;

		if ( m_allocated_memory == m_modules.m_engine_dll.get_address( "CL_SendMove" ).add( 0x7b ).to< void* >( ) ) {

			address new_memory = address( m_interfaces.m_mem_alloc->alloc( 24 ) );
			if ( new_memory ) {

				new_memory.add( 0x14 ).set( 15 );
				new_memory.add( 0x10 ).set( 0 );
				new_memory.set< unsigned char >( 0 );

			}

			m_allocated_memory = new_memory;

		}

		static auto function = m_modules.m_engine_dll.get_address( "CCLCMsg_Move::set_data" ).as< void* ( __thiscall* )( void*, unsigned char*, std::size_t ) >( );

		return function( m_allocated_memory, data, num_bytes_written );

	}

	int m_net_message_vtable; // 0x58
	int m_cl_msg_move_vtable; // 0x54
	int m_unknown1; // 0x4c
	int m_backup_commands; // 0x4c
	int m_new_commands; // 0x48
	void* m_allocated_memory; // 0x44
	int m_unknown2; // 0x40
	int m_flags; // 0x3c
	char m_unknown3; // 0x38
	char _pad0[ 0x3 ]; // 0x37
	char m_unknown4; // 0x34
	char _pad1[ 0xf ]; // 0x33
	int m_unknown5; // 0x24
	int m_unknown; // 0x20
	bf_write m_data_out; // 0x1c

};

void __cdecl hooked::cl_main_fn::cl_send_move( ) {

	// gtfo with the split screen bullshit

	int nextcommandnr = m_interfaces.m_client_state->m_lastoutgoingcommand + m_interfaces.m_client_state->m_chokedcommands + 1;
	int choked_commands = m_interfaces.m_client_state->m_chokedcommands;

	byte data[ 4000 /* MAX_CMD_BUFFER */ ];
	cl_msg_move move_msg;

	move_msg.m_data_out.start_writing( data, sizeof( data ) );

	int cl_cmdbackup = 2;
	int backup_commands = std::clamp( cl_cmdbackup, 0, 7 /* MAX_BACKUP_COMMANDS */ );

	int new_commands = std::clamp( choked_commands + 1, 0, 15 /* MAX_NEW_COMMANDS */ );

	move_msg.set_num_backup_commands( backup_commands );
	move_msg.set_num_new_commands( new_commands );

	int numcmds = new_commands + backup_commands;
	int from = -1;
	bool ok = true;

	for ( int to = nextcommandnr - numcmds + 1; to <= nextcommandnr; ++to ) {

		bool isnewcmd = to >= ( nextcommandnr - new_commands + 1 );

		ok = ok && m_interfaces.m_client->write_usercmd_delta_to_buffer( 0, &move_msg.m_data_out, from, to, isnewcmd );
		from = to;

	}

	if ( ok ) {

		move_msg.set_data( move_msg.m_data_out.get_data( ), move_msg.m_data_out.get_num_bytes_written( ) );

		m_interfaces.m_client_state->m_net_channel->send_net_msg( &move_msg );

	}

}
```

`cstrike/hooked/functions/client_input.cpp`:

```cpp
#include "../hooked.h"

void __fastcall hooked::client_input_fn::cam_think( client_input* ecx, void* edx ) {

	static auto o_cam_think = m_modules.m_client_dll.get< decltype( &cam_think ) >( "CInput::CAM_Think" );

	ecx->m_camera_in_third_person = !m_input.is_key_toggled( m_config.m_esp.thirdperson_key, m_config.m_esp.third_person );

	ecx->m_cam_command = 1;

	return o_cam_think( ecx, edx );

}

void __fastcall hooked::client_input_fn::cam_to_third_person( client_input* ecx, void* edx ) {

	static auto o_cam_to_third_person = m_modules.m_client_dll.get< decltype( &cam_to_third_person ) >( "CInput::CAM_ToThirdPerson" );

	o_cam_to_third_person( ecx, edx );

	ecx->m_camera_offset.z = m_config.m_esp.thirdperson_distance;

}
```

`cstrike/hooked/functions/client_mode_shared.cpp`:

```cpp
#include "../hooked.h"

bool __fastcall hooked::client_mode_shared_fn::create_move( void* ecx, void* edx, float input_sample_time, user_cmd* cmd ) {

	m_cstrike.m_local_player = m_interfaces.m_entity_list->get< cs_player* >( m_interfaces.m_engine->get_local_player( ) );
	if ( !m_cstrike.m_local_player )
		return true;

	cmd->m_buttons |= in_bull_rush;

	return m_cstrike.m_local_player->create_move( input_sample_time, cmd );

}

float __fastcall hooked::client_mode_shared_fn::get_view_model_fov( void* ecx, void* edx ) {

	return m_config.m_misc.viewmodel_fov;

}
```

`cstrike/hooked/functions/cs_player.cpp`:

```cpp
#include "../hooked.h"

void __fastcall hooked::cs_player_fn::update_client_side_animation( cs_player* ecx, void* edx ) {

	if ( ecx->get_use_new_animstate( ) ) {

		ecx->get_player_anim_state_csgo( )->update( ecx->eye_angles( ).y, ecx->eye_angles( ).x );

	} else {

		if ( ecx->get_sequence( ) != -1 )
			ecx->frame_advance( 0.f );

		if ( ecx->is_local_player( ) )
			ecx->get_player_anim_state_csgo( )->update( ecx->eye_angles( ).y, ecx->eye_angles( ).x );
		else
			ecx->get_player_anim_state_csgo( )->update( ecx->get_eye_angles( ).y, ecx->get_eye_angles( ).x );

	}

	if ( ecx->get_sequence( ) != -1 )
		ecx->on_latch_interpolated_variables( 1 /* LATCH_ANIMATION_VAR */ );

	if ( ecx->get_killed_by_taser( ) )
		ecx->handle_taser_animation( );

	if ( ecx->is_local_player( ) ) {

		weapon_cs_base* weapon = m_interfaces.m_entity_list->get< weapon_cs_base* >( ecx->get_active_weapon( ) );
		if ( weapon ) {

			base_view_model* view_model = ecx->get_view_model( weapon->get_view_model_index( ) );
			if ( view_model )
				view_model->update_all_viewmodel_addons( );

		} else {

			for ( int i = 0; i < 3 /* MAX_VIEWMODELS */; i++ ) {

				base_view_model* view_model = ecx->get_view_model( i );
				if ( view_model ) {

					view_model->remove_viewmodel_arm_models( );
					view_model->remove_viewmodel_label( );
					view_model->remove_viewmodel_stat_track( );
					view_model->remove_viewmodel_stickers( );

				}

			}

		}

	}

}
```

`cstrike/hooked/functions/csgo_player_anim_state.cpp`:

```cpp
#include "../hooked.h"

void __vectorcall hooked::csgo_player_anim_state_fn::update( csgo_player_anim_state* ecx, void* unk0, float z, float y, float x, void* unk1 ) {

	cs_player* player = ecx->m_player;
	if ( !player || ( !player->is_alive( ) && !player->is_player_ghost( ) ) || !ecx->cache_sequences( ) )
		return;

	x = m_mathlib_base.angle_normalize( x + player->get_third_person_recoil( ) );

	if ( ecx->m_last_update_time == m_interfaces.m_globals->m_curtime || ecx->m_last_update_frame == m_interfaces.m_globals->m_framecount )
		return;

	ecx->m_last_update_increment = std::fmaxf( 0.f, m_interfaces.m_globals->m_curtime - ecx->m_last_update_time );

	ecx->m_eye_yaw = m_mathlib_base.angle_normalize( y );
	ecx->m_eye_pitch = m_mathlib_base.angle_normalize( x );
	ecx->m_position_current = player->get_origin( );
	ecx->m_weapon = m_interfaces.m_entity_list->get< weapon_cs_base* >( player->get_active_weapon( ) );

	if ( ecx->m_weapon != ecx->m_weapon_last || ecx->m_first_run_since_init ) {

		for ( int i = 0; i < 13; i++ ) {

			animation_layer* layer = player->get_anim_overlay( i );
			if ( layer ) {

				layer->m_dispatched_studio_hdr = 0;
				layer->m_dispatched_src = -1;
				layer->m_dispatched_dst = -1;

			}

		}

	}

	ecx->m_anim_duck_amount = std::clamp( 
		m_mathlib.approach(
			std::clamp( player->get_duck_amount( ) + ecx->m_duck_additional, 0.f, 1.f ),
			ecx->m_anim_duck_amount,
			ecx->m_last_update_increment * 6.f ),
		0.f, 
		1.f );

	m_interfaces.m_mdl_cache->begin_lock( );

	player->set_sequence( 0 );
	player->get_playback_rate( ) = 0.f;

	if ( player->get_cycle( ) != 0.f ) {

		player->get_cycle( ) = 0.f;
		player->invalidate_physics_recursive( 8 );

	}

	m_interfaces.m_mdl_cache->end_lock( );

	ecx->set_up_velocity( );
	ecx->set_up_aim_matrix( );
	ecx->set_up_weapon_action( );
	ecx->set_up_movement( );
	ecx->set_up_alive_loop( );
	ecx->set_up_whole_body_action( );
	ecx->set_up_flashed_reaction( );
	ecx->set_up_flinch( );
	ecx->set_up_lean( );

	player->set_abs_angles( { 0.f, ecx->m_foot_yaw, 0.f } );

	ecx->m_weapon_last = ecx->m_weapon;
	ecx->m_position_last = ecx->m_position_current;
	ecx->m_first_run_since_init = false;
	ecx->m_last_update_time = m_interfaces.m_globals->m_curtime;
	ecx->m_last_update_frame = m_interfaces.m_globals->m_framecount;

	// compare to server hitboxes - only compare to some players to not tank fps
	if ( m_config.m_misc.server_hitboxes )
		if ( player == m_cstrike.m_local_player )
			player->draw_server_hitboxes( );

}

void __fastcall hooked::csgo_player_anim_state_fn::modify_eye_position( csgo_player_anim_state* ecx, void* edx, vector_3d& input_eye_pos ) {

	cs_player* player = ecx->m_player;
	if ( !player )
		return;

	if ( !ecx->m_landing || ecx->m_anim_duck_amount == 0.f || !player->get_ground_entity( ) )
		return;

	int head_bone = player->lookup_bone( "head_0" );
	if ( !head_bone )
		return;

	vector_3d head_pos;
	player->get_bone_position( head_bone, head_pos );

	if ( head_pos.z < input_eye_pos.z ) {

		float lerp = m_mathlib.simple_spline_remap_val_clamped( std::fabs( input_eye_pos.z - head_pos.z ), 4.f, 10.f, 0.f, 1.f );

		input_eye_pos.z = m_mathlib.lerp( lerp, input_eye_pos.z, head_pos.z );

	}

}

void __fastcall hooked::csgo_player_anim_state_fn::do_procedural_foot_plant( csgo_player_anim_state* ecx, void* edx, void* bone_to_world, void* left_foot_chain, void* right_foot_chain, void* pos ) {

	return;

}

void __fastcall hooked::csgo_player_anim_state_fn::set_up_velocity( csgo_player_anim_state* ecx, void* edx ) {

	m_interfaces.m_mdl_cache->begin_lock( );

	cs_player* player = ecx->m_player;

	vector_3d abs_velocity = player->get_abs_velocity( );

	if ( abs_velocity.length_sqr( ) > std::powf( 312.f, 2 ) )
		abs_velocity = abs_velocity.normalized( ) * 312.f;

	ecx->m_velocity_length_z = abs_velocity.z;

	abs_velocity.z = 0.f;

	ecx->m_player_is_accelerating = ( ecx->m_velocity_last.length_sqr( ) < abs_velocity.length_sqr( ) );

	ecx->m_velocity = m_mathlib.approach( abs_velocity, ecx->m_velocity, ecx->m_last_update_increment * 2000.f );
	ecx->m_velocity_normalized = ecx->m_velocity.normalized( );

	ecx->m_velocity_length_xy = std::fminf( ecx->m_velocity.length( ), 260.f );

	if ( ecx->m_velocity_length_xy > 0.f )
		ecx->m_velocity_normalized_non_zero = ecx->m_velocity_normalized;

	ecx->m_weapon = m_interfaces.m_entity_list->get< weapon_cs_base* >( player->get_active_weapon( ) );

	float max_speed_run = ecx->m_weapon ? std::fmaxf( ecx->m_weapon->get_max_speed( ), 0.001f ) : 260.f;

	ecx->m_speed_as_portion_of_run_top_speed = std::clamp( ecx->m_velocity_length_xy / max_speed_run, 0.f, 1.f );
	ecx->m_speed_as_portion_of_walk_top_speed = ecx->m_velocity_length_xy / ( max_speed_run * 0.52f );
	ecx->m_speed_as_portion_of_crouch_top_speed = ecx->m_velocity_length_xy / ( max_speed_run * 0.34f );

	if ( ecx->m_speed_as_portion_of_walk_top_speed >= 1.f )												
		ecx->m_static_approach_speed = ecx->m_velocity_length_xy;
	else if ( ecx->m_speed_as_portion_of_walk_top_speed < 0.5f )
		ecx->m_static_approach_speed = m_mathlib.approach( 80.f, ecx->m_static_approach_speed, ecx->m_last_update_increment * 60.f );

	bool started_moving_this_frame = false;
	bool stopped_moving_this_frame = false;

	if ( ecx->m_velocity_length_xy > 0.f ) {

		started_moving_this_frame = ( ecx->m_duration_moving <= 0.f );
		ecx->m_duration_still = 0.f;
		ecx->m_duration_moving += ecx->m_last_update_increment;

	} else {

		stopped_moving_this_frame = ( ecx->m_duration_still <= 0.f );
		ecx->m_duration_moving = 0.f;
		ecx->m_duration_still += ecx->m_last_update_increment;

	}

	// add server code

	ecx->m_foot_yaw_last = ecx->m_foot_yaw;
	ecx->m_foot_yaw = std::clamp( ecx->m_foot_yaw, -360.f, 360.f );

	float eye_foot_delta = m_mathlib_base.angle_diff( ecx->m_eye_yaw, ecx->m_foot_yaw );

	float aim_matrix_width_range = m_mathlib.lerp( 
		std::clamp( ecx->m_speed_as_portion_of_walk_top_speed, 0.f, 1.f ), 
		1.f,
		m_mathlib.lerp( ecx->m_walk_to_run_transition, 0.8f, 0.5f ) );

	if ( ecx->m_anim_duck_amount > 0.f )
		aim_matrix_width_range = m_mathlib.lerp( 
			ecx->m_anim_duck_amount * std::clamp( ecx->m_speed_as_portion_of_crouch_top_speed, 0.f, 1.f ), 
			aim_matrix_width_range, 
			0.5f );

	float temp_yaw_max = ecx->m_aim_yaw_max * aim_matrix_width_range;
	float temp_yaw_min = ecx->m_aim_yaw_min * aim_matrix_width_range;

	if ( eye_foot_delta > temp_yaw_max )
		ecx->m_foot_yaw = ecx->m_eye_yaw - std::fabs( temp_yaw_max );
	else if ( eye_foot_delta < temp_yaw_min )
		ecx->m_foot_yaw = ecx->m_eye_yaw + std::fabs( temp_yaw_min );

	ecx->m_foot_yaw = m_mathlib_base.angle_normalize( ecx->m_foot_yaw );

	if ( ecx->m_velocity_length_xy > 0.1f || std::fabs( ecx->m_velocity_length_z ) > 100.f ) {

		ecx->m_foot_yaw = m_mathlib_base.approach_angle( ecx->m_eye_yaw, ecx->m_foot_yaw, ecx->m_last_update_increment * ( 30.f + 20.f * ecx->m_walk_to_run_transition ) );

		ecx->m_lower_body_realign_timer = ecx->m_last_update_time + ( 1.1f * 0.2f );
		player->get_lower_body_yaw_target( ) = ecx->m_eye_yaw;

	} else {

		ecx->m_foot_yaw = m_mathlib_base.approach_angle( player->get_lower_body_yaw_target( ), ecx->m_foot_yaw, ecx->m_last_update_increment * 100.f );

		if ( ecx->m_last_update_time > ecx->m_lower_body_realign_timer
			&& std::fabsf( m_mathlib_base.angle_diff( ecx->m_foot_yaw, ecx->m_eye_yaw ) ) > 35.f ) {

			ecx->m_lower_body_realign_timer = ecx->m_last_update_time + 1.1f;
			player->get_lower_body_yaw_target( ) = ecx->m_eye_yaw;

		}

	}

	animation_layer* animation_layer_adjust = player->get_anim_overlay( 3 );
	if ( animation_layer_adjust && animation_layer_adjust->m_weight > 0.f ) {

		ecx->increment_layer_cycle( 3, false );
		ecx->increment_layer_weight( 3 );

	}

	if ( ecx->m_velocity_length_xy > 0.f ) {

		float raw_yaw_ideal = ( std::atan2( -ecx->m_velocity.y, -ecx->m_velocity.x ) * 180 / 3.141592654f );
		if ( raw_yaw_ideal < 0.f )
			raw_yaw_ideal += 360.f;

		ecx->m_move_yaw_ideal = m_mathlib_base.angle_normalize( m_mathlib_base.angle_diff( raw_yaw_ideal, ecx->m_foot_yaw ) );

	}

	ecx->m_move_yaw_current_to_ideal = m_mathlib_base.angle_normalize( m_mathlib_base.angle_diff( ecx->m_move_yaw_ideal, ecx->m_move_yaw ) );

	if ( started_moving_this_frame && ecx->m_move_weight <= 0.f ) {

		ecx->m_move_yaw = ecx->m_move_yaw_ideal;

		animation_layer* animation_layer_movement_move = player->get_anim_overlay( 6 );
		if ( animation_layer_movement_move && animation_layer_movement_move->m_sequence != -1.f ) {

			int move_sequence = animation_layer_movement_move->m_sequence;

			studio_hdr* studio_hdr = player->get_model_ptr( );
			if ( studio_hdr && studio_hdr->seqdesc( move_sequence ).numanimtags > 0 ) {

				if ( std::fabsf( m_mathlib_base.angle_diff( ecx->m_move_yaw, 180.f ) ) <= 22.5f )
					ecx->m_primary_cycle = player->get_first_sequence_anim_tag( move_sequence, 1 );
				else if ( std::fabsf( m_mathlib_base.angle_diff( ecx->m_move_yaw, 135.f ) ) <= 22.5f )
					ecx->m_primary_cycle = player->get_first_sequence_anim_tag( move_sequence, 2 );
				else if ( std::fabsf( m_mathlib_base.angle_diff( ecx->m_move_yaw, 90.f ) ) <= 22.5f )
					ecx->m_primary_cycle = player->get_first_sequence_anim_tag( move_sequence, 3 );
				else if ( std::fabsf( m_mathlib_base.angle_diff( ecx->m_move_yaw, 45.f ) ) <= 22.5f )
					ecx->m_primary_cycle = player->get_first_sequence_anim_tag( move_sequence, 4 );
				else if ( std::fabsf( m_mathlib_base.angle_diff( ecx->m_move_yaw, 0.f ) ) <= 22.5f )
					ecx->m_primary_cycle = player->get_first_sequence_anim_tag( move_sequence, 5 );
				else if ( std::fabsf( m_mathlib_base.angle_diff( ecx->m_move_yaw, -45.f ) ) <= 22.5f )
					ecx->m_primary_cycle = player->get_first_sequence_anim_tag( move_sequence, 6 );
				else if ( std::fabsf( m_mathlib_base.angle_diff( ecx->m_move_yaw, -90.f ) ) <= 22.5f )
					ecx->m_primary_cycle = player->get_first_sequence_anim_tag( move_sequence, 7 );
				else if ( std::fabsf( m_mathlib_base.angle_diff( ecx->m_move_yaw, -135.f ) ) <= 22.5f )
					ecx->m_primary_cycle = player->get_first_sequence_anim_tag( move_sequence, 8 );

			}

		}

	} else {

		animation_layer* animation_layer_movement_strafechange = player->get_anim_overlay( 7 );
		if ( animation_layer_movement_strafechange && animation_layer_movement_strafechange->m_weight >= 1.f ) {

			ecx->m_move_yaw = ecx->m_move_yaw_ideal;

		} else {

			float move_weight = m_mathlib.lerp( 
				ecx->m_anim_duck_amount,
				std::clamp( ecx->m_speed_as_portion_of_walk_top_speed, 0.f, 1.f ), 
				std::clamp( ecx->m_speed_as_portion_of_crouch_top_speed, 0.f, 1.f ) );

			float ratio = m_mathlib_base.bias( move_weight, 0.18f ) + 0.1f;

			ecx->m_move_yaw = m_mathlib_base.angle_normalize( ecx->m_move_yaw + ( ecx->m_move_yaw_current_to_ideal * ratio ) );

		}

	}

	ecx->m_pose_param_mappings[ 4 ].set_value( player, ecx->m_move_yaw );

	float aim_yaw = m_mathlib_base.angle_diff( ecx->m_eye_yaw, ecx->m_foot_yaw );
	if ( aim_yaw >= 0.f && ecx->m_aim_yaw_max != 0.f )
		aim_yaw = ( aim_yaw / ecx->m_aim_yaw_max ) * 60.f;
	else if ( ecx->m_aim_yaw_min != 0.f )
		aim_yaw = ( aim_yaw / ecx->m_aim_yaw_min ) * -60.f;

	ecx->m_pose_param_mappings[ 6 ].set_value( player, aim_yaw );

	float pitch = m_mathlib_base.angle_diff( ecx->m_eye_pitch, 0.f );
	if ( pitch > 0.f )
		pitch = ( pitch / ecx->m_aim_pitch_max ) * 90.f;
	else
		pitch = ( pitch / ecx->m_aim_pitch_min ) * -90.f;

	ecx->m_pose_param_mappings[ 7 ].set_value( player, pitch );
	ecx->m_pose_param_mappings[ 1 ].set_value( player, ecx->m_speed_as_portion_of_walk_top_speed );
	ecx->m_pose_param_mappings[ 9 ].set_value( player, 1.f - ( ecx->m_anim_duck_amount * ecx->m_in_air_smooth_value ) );

	m_interfaces.m_mdl_cache->end_lock( );

}

void __fastcall hooked::csgo_player_anim_state_fn::set_up_movement( csgo_player_anim_state* ecx, void* edx ) {

	static auto o_set_up_movement = m_modules.m_client_dll.get< decltype( &set_up_movement ) >( "CCSGOPlayerAnimState::SetUpMovement" );

	// to do

	return o_set_up_movement( ecx, edx );
}

```

`cstrike/hooked/functions/mat_system_surface.cpp`:

```cpp
#include "../hooked.h"

void __fastcall hooked::mat_system_surface_fn::lock_cursor( surface* ecx, void* edx ) {

	static auto o_lock_cursor = m_modules.m_vguimatsurface_dll.get< decltype( &lock_cursor ) >( "CMatSystemSurface::LockCursor" );

	if ( !m_config.m_menu_open )
		return o_lock_cursor( ecx, edx );

	ecx->unlock_cursor( );

}
```

`cstrike/hooked/functions/prediction.cpp`:

```cpp
#include "../hooked.h"

void __fastcall hooked::prediction_fn::run_command( prediction* ecx, void* edx, base_player* player, user_cmd* cmd, move_helper* move_helper ) {

	ecx->start_command( player, cmd );

	m_interfaces.m_globals->m_curtime = player->get_tick_base( ) * m_interfaces.m_globals->m_interval_per_tick;
	m_interfaces.m_globals->m_frametime = ecx->m_engine_paused ? 0.f : m_interfaces.m_globals->m_interval_per_tick;

	cmd->m_buttons |= player->get_button_forced( );
	cmd->m_buttons &= ~player->get_button_disabled( );

	m_interfaces.m_game_movement->start_track_prediction_errors( player );

	if ( cmd->m_weapon_select != 0 ) {

		weapon_cs_base* weapon = m_interfaces.m_entity_list->get< weapon_cs_base* >( cmd->m_weapon_select );
		if ( weapon ) {

			cs_weapon_info* weapon_info = weapon->get_cs_wpn_data( );
			if ( weapon_info )
				player->select_item( weapon_info->m_weapon_name, cmd->m_weapon_sub_type );

		}

	}

	// no vehicles around here
	
	if ( cmd->m_impulse )
		player->get_impulse( ) = cmd->m_impulse;

	player->update_button_state( cmd->m_buttons );

	ecx->check_moving_ground( player, m_interfaces.m_globals->m_frametime );

	player->set_local_view_angles( cmd->m_view_angles );

	ecx->run_pre_think( player );

	ecx->run_think( player, m_interfaces.m_globals->m_interval_per_tick );

	ecx->setup_move( player, cmd, move_helper, m_interfaces.m_move_data );

	// still no vehicles ;?

	m_interfaces.m_game_movement->process_movement( player, m_interfaces.m_move_data );

	ecx->finish_move( player, cmd, m_interfaces.m_move_data );

	move_helper->process_impacts( );

	ecx->run_post_think( player );

	m_interfaces.m_game_movement->finish_track_prediction_errors( player );

	ecx->finish_command( player );

	m_interfaces.m_game_movement->reset( );

	if ( !ecx->m_engine_paused && m_interfaces.m_globals->m_frametime > 0.f )
		player->get_tick_base( )++;

}

```

`cstrike/hooked/functions/scheme_manager.cpp`:

```cpp
#include "../hooked.h"

#include "../../render/render.h"

void __fastcall hooked::scheme_manager_fn::reload_schemes( void* ecx, void* edx ) {

	static auto o_reload_schemes = m_modules.m_vgui2_dll.get< decltype( &reload_schemes ) >( "CSchemeManager::ReloadSchemes" );

	o_reload_schemes( ecx, edx );

	m_render.setup( );

}
```

`cstrike/hooked/functions/studio_render.cpp`:

```cpp
#include "../hooked.h"

void __fastcall hooked::studio_render_fn::draw_model( studio_render_context* ecx, void* edx, void* results, const draw_model_info& info, void* bone_to_world, float* flex_weights, float* flex_delayed_rates, const vector_3d& origin, int flags ) {

	static auto o_draw_model = m_modules.m_studiorender_dll.get< decltype( &draw_model ) >( "CStudioRenderContext::DrawModel" );

	if ( !m_config.m_esp.chams || !m_cstrike.m_local_player || !info.m_client_entity )
		return o_draw_model( ecx, edx, results, info, bone_to_world, flex_weights, flex_delayed_rates, origin, flags );

	base_entity* entity = reinterpret_cast< base_entity* >( info.m_client_entity - 0x4 );
	if ( entity
		&& entity->is_player( )
		&& entity->get_team( ) != m_cstrike.m_local_player->get_team( ) ) {

		ecx->set_color( color( 109, 114, 195 ) );

		// ecx->set_alpha( 1.f );

		static auto material = m_interfaces.m_material_system->find_material( "debug/debugdrawflat", "Model textures" );
		ecx->set_material( material );

		o_draw_model( ecx, edx, results, info, bone_to_world, flex_weights, flex_delayed_rates, origin, flags );

		ecx->set_color( color( 221, 115, 115 ) );

		ecx->set_material( material, false );

		o_draw_model( ecx, edx, results, info, bone_to_world, flex_weights, flex_delayed_rates, origin, flags );

		ecx->set_material( nullptr );

		return;

	}

	return o_draw_model( ecx, edx, results, info, bone_to_world, flex_weights, flex_delayed_rates, origin, flags );

}
```

`cstrike/hooked/functions/vgui_baseui.cpp`:

```cpp
#include "../hooked.h"

#include "../../menu/menu.h"

void __fastcall hooked::vgui_baseui_fn::paint( engine_vgui* ecx, void* edx, paint_mode mode ) {

	static auto o_paint = m_modules.m_engine_dll.get< decltype( &paint ) >( "CEngineVGui::Paint" );

	if ( ecx->m_static_transition_panel && ( mode & paint_uipanels ) ) {

		m_interfaces.m_surface->start_drawing( );

		m_visuals.paint( );

		m_menu.paint( );

		m_interfaces.m_surface->finish_drawing( );

	}

	return o_paint( ecx, edx, mode );

}

```

`cstrike/hooked/functions/weapon_cs_base.cpp`:

```cpp
#include "../hooked.h"

void __fastcall hooked::weapon_cs_base_fn::draw_crosshair( weapon_cs_base* ecx, void* edx ) {

	static auto o_draw_crosshair = m_modules.m_client_dll.get< decltype( &draw_crosshair ) >( "C_WeaponCSBase::DrawCrosshair" );

	cs_weapon_info* weapon_info = ecx->get_cs_wpn_data( );
	if ( !weapon_info )
		return;

	int old_weapon_type = weapon_info->m_weapon_type;

	weapon_info->m_weapon_type = 0xff;

	o_draw_crosshair( ecx, edx );

	weapon_info->m_weapon_type = old_weapon_type;

}
```

`cstrike/hooked/hooked.cpp`:

```cpp
#include "hooked.h"

bool hooked::setup( ) {

	// cdll_client_fn
	if ( !m_modules.m_client_dll.hook_function( "CHLClient::LevelShutdown", &cdll_client_fn::level_shutdown ) )
		return false;

	// cl_main_fn
	if ( !m_modules.m_engine_dll.hook_function( "CL_SendMove", &cl_main_fn::cl_send_move ) )
		return false;

	// client_input_fn
	if ( !m_modules.m_client_dll.hook_function( "CInput::CAM_Think", &client_input_fn::cam_think ) )
		return false;

	if ( !m_modules.m_client_dll.hook_function( "CInput::CAM_ToThirdPerson", &client_input_fn::cam_to_third_person ) )
		return false;

	// client_mode_shared_fn
	if ( !m_modules.m_client_dll.hook_function( "ClientModeShared::CreateMove", &client_mode_shared_fn::create_move ) )
		return false;

	if ( !m_modules.m_client_dll.hook_function( "ClientModeShared::GetViewModelFOV", &client_mode_shared_fn::get_view_model_fov ) )
		return false;

	// cs_player_fn
	if ( !m_modules.m_client_dll.hook_function( "C_CSPlayer::UpdateClientSideAnimation", &cs_player_fn::update_client_side_animation ) )
		return false;

	// csgo_player_anim_state_fn
	if ( !m_modules.m_client_dll.hook_function( "CCSGOPlayerAnimState::Update", &csgo_player_anim_state_fn::update ) )
		return false;

	if ( !m_modules.m_client_dll.hook_function( "CCSGOPlayerAnimState::ModifyEyePosition", &csgo_player_anim_state_fn::modify_eye_position ) )
		return false;

	if ( !m_modules.m_client_dll.hook_function( "CCSGOPlayerAnimState::DoProceduralFootPlant", &csgo_player_anim_state_fn::do_procedural_foot_plant ) )
		return false;

	if ( !m_modules.m_client_dll.hook_function( "CCSGOPlayerAnimState::SetUpVelocity", &csgo_player_anim_state_fn::set_up_velocity ) )
		return false;

	if ( !m_modules.m_client_dll.hook_function( "CCSGOPlayerAnimState::SetUpMovement", &csgo_player_anim_state_fn::set_up_movement ) )
		return false;

	// mat_system_surface_fn
	if ( !m_modules.m_vguimatsurface_dll.hook_function( "CMatSystemSurface::LockCursor", &mat_system_surface_fn::lock_cursor ) )
		return false;

	// prediction_fn
	if ( !m_modules.m_client_dll.hook_function( "CPrediction::RunCommand", &prediction_fn::run_command ) )
		return false;

	// scheme_manager_fn
	if ( !m_modules.m_vgui2_dll.hook_function( "CSchemeManager::ReloadSchemes", &scheme_manager_fn::reload_schemes ) )
		return false;

	// studio_render_fn
	if ( !m_modules.m_studiorender_dll.hook_function( "CStudioRenderContext::DrawModel", &studio_render_fn::draw_model ) )
		return false;

	// vgui_baseui_fn
	if ( !m_modules.m_engine_dll.hook_function( "CEngineVGui::Paint", &vgui_baseui_fn::paint ) )
		return false;

	// weapon_cs_base_fn
	if ( !m_modules.m_client_dll.hook_function( "C_WeaponCSBase::DrawCrosshair", &weapon_cs_base_fn::draw_crosshair ) )
		return false;

	return true;

}

void hooked::unload( ) {

	m_modules.m_client_dll.unload_functions( );
	m_modules.m_engine_dll.unload_functions( );
	m_modules.m_server_dll.unload_functions( );
	m_modules.m_gameoverlayrenderer_dll.unload_functions( );
	m_modules.m_vgui2_dll.unload_functions( );
	m_modules.m_vguimatsurface_dll.unload_functions( );
	m_modules.m_studiorender_dll.unload_functions( );
	m_modules.m_localize_dll.unload_functions( );
	m_modules.m_datacache_dll.unload_functions( );
	m_modules.m_materialsystem_dll.unload_functions( );
	m_modules.m_tier0.unload_functions( );

}
```

`cstrike/hooked/hooked.h`:

```h
#pragma once

#include "../cstrike.h"

#include "../features/features.h"
#include "../input/input.h"

struct hooked {

	bool setup( );

	void unload( );

private:

	struct cdll_client_fn {

		static void __fastcall level_shutdown( void* ecx, void* edx );

	};

	struct cl_main_fn {

		static void __cdecl cl_send_move( );

	};

	struct client_input_fn {

		static void __fastcall cam_think( client_input* ecx, void* edx );
		static void __fastcall cam_to_third_person( client_input* ecx, void* edx );

	};

	struct client_mode_shared_fn {

		static bool __fastcall create_move( void* ecx, void* edx, float input_sample_time, user_cmd* cmd );
		static float __fastcall get_view_model_fov( void* ecx, void* edx );

	};

	struct cs_player_fn {

		static void __fastcall update_client_side_animation( cs_player* ecx, void* edx );

	};

	struct csgo_player_anim_state_fn {

		static void __vectorcall update( csgo_player_anim_state* ecx, void* unk0, float z, float y, float x, void* unk1 );
		static void __fastcall modify_eye_position( csgo_player_anim_state* ecx, void* edx, vector_3d& input_eye_pos );
		static void __fastcall do_procedural_foot_plant( csgo_player_anim_state* ecx, void* edx, void* bone_to_world, void* left_foot_chain, void* right_foot_chain, void* pos );
		static void __fastcall set_up_movement( csgo_player_anim_state* ecx, void* edx );
		static void __fastcall set_up_velocity( csgo_player_anim_state* ecx, void* edx );

	};

	struct mat_system_surface_fn {

		static void __fastcall lock_cursor( surface* ecx, void* edx );

	};

	struct prediction_fn {

		static void __fastcall run_command( prediction* ecx, void* edx, base_player* player, user_cmd* cmd, move_helper* move_helper );

	};

	struct scheme_manager_fn {

		static void __fastcall reload_schemes( void* ecx, void* edx );

	};

	struct studio_render_fn {

		static void __fastcall draw_model( studio_render_context* ecx, void* edx, void* results, const draw_model_info& info, void* bone_to_world, float* flex_weights, float* flex_delayed_rates, const vector_3d& origin, int flags );

	};

	struct vgui_baseui_fn {

		static void __fastcall paint( engine_vgui* ecx, void* edx, paint_mode mode );

	};

	struct weapon_cs_base_fn {

		static void __fastcall draw_crosshair( weapon_cs_base* ecx, void* edx );

	};

};

inline hooked m_hooked;
```

`cstrike/input/input.cpp`:

```cpp
#include "input.h"

#include <windowsx.h>

bool input::setup( ) {

	m_original_wnd_proc = reinterpret_cast< WNDPROC >( SetWindowLongPtr( m_cstrike.m_window, GWLP_WNDPROC, reinterpret_cast< LONG_PTR >( wnd_proc ) ) );
	if ( !m_original_wnd_proc )
		return false;

	return true;

}

void input::unload( ) {

	if ( !m_original_wnd_proc )
		return;

	SetWindowLongPtr( m_cstrike.m_window, GWLP_WNDPROC, reinterpret_cast< LONG_PTR >( m_original_wnd_proc ) );

}

void input::think( UINT message, WPARAM w_param, LPARAM l_param ) {

	if ( message == WM_MOUSEMOVE )
		m_mouse = { GET_X_LPARAM( l_param ), GET_Y_LPARAM( l_param ) };

	std::size_t key;
	key_state state;

	switch ( message ) {
		case WM_KEYDOWN:
		case WM_SYSKEYDOWN:
			key = w_param;
			state = down;
			break;
		case WM_KEYUP:
		case WM_SYSKEYUP:
			key = w_param;
			state = up;
			break;
		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_LBUTTONDBLCLK:
			key = VK_LBUTTON;
			state = message == WM_LBUTTONUP ? up : down;
			break;
		case WM_RBUTTONDOWN:
		case WM_RBUTTONUP:
		case WM_RBUTTONDBLCLK:
			key = VK_RBUTTON;
			state = message == WM_RBUTTONUP ? up : down;
			break;
		default:
			return;
	}

	if ( m_key_states[ key ].m_state == up && state == down ) {

		m_key_states[ key ].m_framecount = m_interfaces.m_globals->m_framecount + 1;
		m_key_states[ key ].m_state = toggled;

		m_last_key = key;

	} else {

		m_key_states[ key ].m_state = state;

	}

}

long __stdcall input::wnd_proc( HWND window, UINT message, WPARAM w_param, LPARAM l_param ) {

	m_input.think( message, w_param, l_param );

	if ( m_config.m_menu_open )
		return 1l;

	return CallWindowProcW( m_input.m_original_wnd_proc, window, message, w_param, l_param );

}
```

`cstrike/input/input.h`:

```h
#pragma once

#include <array>

#include "../cstrike.h"

enum key_state {

	up,
	toggled,
	down

};

struct input {

	bool setup( );

	void unload( );

	void think( UINT message, WPARAM w_param, LPARAM l_param );

	inline bool is_key_toggled( std::size_t code ) {

		if ( m_key_states[ code ].m_state != toggled )
			return false;

		return m_key_states[ code ].m_framecount == m_interfaces.m_globals->m_framecount;

	}

	inline bool is_key_toggled( std::size_t code, bool& item ) {

		if ( is_key_toggled( code ) )
			item = !item;

		return item;

	}

	inline bool is_key_down( std::size_t code ) {

		return m_key_states[ code ].m_state == down;

	}

	inline bool is_mouse_down( std::size_t code ) {

		return m_key_states[ code ].m_state == toggled;

	}

	inline bool is_mouse_in_bounds( int x, int y, int width, int height ) {

		return m_mouse.x >= x && m_mouse.y >= y && m_mouse.x <= x + width && m_mouse.y <= y + height;

	}

	inline int get_last_key( ) {  return m_last_key; };
	inline void set_last_key( int key = -1 ) { m_last_key = key; };
	inline int get_mouse_x( ) { return m_mouse.x; }
	inline int get_mouse_y( ) { return m_mouse.y; }

private:

	static long __stdcall wnd_proc( HWND window, UINT message, WPARAM w_param, LPARAM l_param );

	WNDPROC m_original_wnd_proc;

	int m_last_key;

	struct {

		int x, y;

	} m_mouse;

	struct key_states {

		key_state m_state;
		int m_framecount;

	};

	std::array< key_states, 256 > m_key_states = { up };

};

inline input m_input;
```

`cstrike/menu/menu.cpp`:

```cpp
#include "menu.h"

#include "../input/input.h"
#include "../render/render.h"

bool menu::setup( ) {

	m_size.x = 100;
	m_size.y = 100;
	m_size.width = 700;
	m_size.height = 400;
	m_size.gap = 25;

	m_colors.dark = color( 20, 20, 20 );
	m_colors.light = color( 255, 255, 255 );
	m_colors.vibrant = color( 255, 255, 0 );

	m_selected_tab = 0;

	setup_tab( "legit", [ ]( tab* tab ) -> void {

		tab->setup_group( 25, 50, 320, 325, [ ]( group* group ) -> void {

			} );

		tab->setup_group( 355, 50, 320, 325, [ ]( group* group ) -> void {

			} );

		} );

	setup_tab( "hvh", [ ]( tab* tab ) -> void {

		tab->setup_group( 25, 50, 320, 325, [ ]( group* group ) -> void {

			} );

		tab->setup_group( 355, 50, 320, 325, [ ]( group* group ) -> void {

			} );

		} );

	setup_tab( "esp", [ ]( tab* tab ) -> void {

		tab->setup_group( 25, 50, 320, 325, [ ]( group* group ) -> void {

			group->setup_checkbox( "enable", &m_config.m_esp.active );
			group->setup_checkbox( "player box", &m_config.m_esp.player_box );
			group->setup_checkbox( "player health", &m_config.m_esp.player_health );
			group->setup_checkbox( "player name", &m_config.m_esp.player_name );
			group->setup_checkbox( "player weapon", &m_config.m_esp.player_weapon );
			group->setup_checkbox( "player weapon ammo", &m_config.m_esp.player_ammo );

			} );

		tab->setup_group( 355, 50, 320, 325, [ ]( group* group ) -> void {

			group->setup_checkbox( "chams", &m_config.m_esp.chams );
			group->setup_key( "thirdperson key", &m_config.m_esp.thirdperson_key );
			group->setup_slider( "thirdperson distance", &m_config.m_esp.thirdperson_distance, 30, 170 );

			} );

		} );

	setup_tab( "misc", [ ]( tab* tab ) -> void {

		tab->setup_group( 25, 50, 320, 325, [ ]( group* group ) -> void {

			group->setup_slider( "viewmodel fov", &m_config.m_misc.viewmodel_fov, 60, 120 );

			} );

		tab->setup_group( 355, 50, 320, 325, [ ]( group* group ) -> void {

			group->setup_checkbox( "server hitboxes", &m_config.m_misc.server_hitboxes );

			} );

		} );

	return true;

}

void menu::paint( ) {

	if ( !m_input.is_key_toggled( VK_INSERT, m_config.m_menu_open ) )
		return;

	handle_movement( );

	draw_backplate( );

	process_tabs( );

}

void menu::setup_tab( std::string_view name, std::function< void( tab* ) > function ) {

	tab tab( name );

	function( &tab );

	m_tabs.push_back( tab );

}

void menu::handle_movement( ) {

	if ( m_drag.active ) {

		m_size.x += m_input.get_mouse_x( ) - m_drag.x;
		m_size.y += m_input.get_mouse_y( ) - m_drag.y;

	} 

	if ( ( !m_drag.active ? m_input.is_key_toggled( VK_LBUTTON ) : m_input.is_mouse_down( VK_LBUTTON ) )
		&& ( m_input.is_mouse_in_bounds( m_size.x - 3, m_size.y - 3, m_size.width + 6, 3 )
		|| m_input.is_mouse_in_bounds( m_size.x - 3, m_size.y - 3, 3, m_size.height + 6 )
		|| m_input.is_mouse_in_bounds( m_size.x + m_size.width, m_size.y - 3, 3, m_size.height + 6 ) 
		|| m_input.is_mouse_in_bounds( m_size.x - 3, m_size.y + m_size.height, m_size.width + 6, 3 ) ) ) {

		m_drag.active = true;
		m_drag.x = m_input.get_mouse_x( );
		m_drag.y = m_input.get_mouse_y( );

	} else {

		m_drag.active = false;

	}

}

void menu::draw_backplate( ) {

	color low_alpha_main = m_colors.dark;
	low_alpha_main.a = 60;

	m_render.draw_outlined_rect( m_size.x - 3, m_size.y - 3,
		m_size.width + 6, m_size.height + 6,
		low_alpha_main );

	m_render.draw_outlined_rect( m_size.x - 2, m_size.y - 2,
		m_size.width + 4, m_size.height + 4,
		m_colors.dark );

	m_render.draw_outlined_rect( m_size.x - 1, m_size.y - 1,
		m_size.width + 2, m_size.height + 2,
		low_alpha_main );

	m_render.draw_filled_rect( m_size.x, m_size.y,
		m_size.width, m_size.height,
		m_colors.dark );

}

void menu::process_tabs( ) {

	int	start_x = m_size.x + m_size.gap,
		start_y = m_size.y + m_size.gap,
		end_x = m_size.x + m_size.width - m_size.gap;

	int total_width = end_x - start_x,
		width = ( total_width / ( m_tabs.size( ) + 1 ) );

	m_render.draw_line( start_x + width - width / 2, start_y - 5,
		start_x + width - width / 2, start_y + 5,
		m_colors.light );

	for ( std::size_t i = 0; i < m_tabs.size( ); i++ ) {

		int x = start_x + width * ( i + 1 );

		m_render.draw_line( x + width / 2, start_y - 5,
			x + width / 2, start_y + 5,
			m_colors.light );

		if ( m_input.is_key_toggled( VK_LBUTTON )
			&& m_input.is_mouse_in_bounds( x - width / 2, start_y - 5, width, 10 ) )
			m_selected_tab = i;

		m_tabs[ i ].draw( x, start_y, i == m_selected_tab );

	}
		
}
```

`cstrike/menu/menu.h`:

```h
#pragma once

#include "../cstrike.h"

#include "objects/objects.h"

struct menu {

	bool setup( );

	void paint( );

	struct {

		int x, y, width, height;

		int gap;

	} m_size;

	struct {

		color dark, light, vibrant;

	} m_colors;

private:

	void setup_tab( std::string_view name, std::function< void( tab* ) > function );

	void handle_movement( );

	void draw_backplate( );

	void process_tabs( );

	struct {

		bool active;
		int x, y;

	} m_drag;

	int m_selected_tab;

	std::vector< tab > m_tabs;

};

inline menu m_menu;
```

`cstrike/menu/objects/checkbox/checkbox.cpp`:

```cpp
#include "checkbox.h"

#include "../../menu.h"

checkbox::checkbox( std::string_view name, int x, int y ) : object( name, x, y ) {

	set_size( 0 );
	set_item( nullptr );

}

void checkbox::set_size( int size ) {

	m_height = size;

}

void checkbox::set_item( bool* item ) {

	m_item = item;

}

void checkbox::draw( ) {

	int x = m_menu.m_size.x + m_size.x,
		y = m_menu.m_size.y + m_size.y;

	m_render.draw_outlined_rect( x, y,
		m_height, m_height,
		m_menu.m_colors.light );

	m_render.draw_filled_rect( x + 1, y + 1, 
		m_height - 2, m_height - 2, 
		*m_item ? m_menu.m_colors.vibrant : m_menu.m_colors.light );

	m_render.draw_text( m_render.m_fonts.main,
		x + m_height + m_gap, y,
		m_name,
		color( 255, 255, 255 ) );

}

void checkbox::think( ) {

	int x = m_menu.m_size.x + m_size.x,
		y = m_menu.m_size.y + m_size.y;

	if ( !m_input.is_key_toggled( VK_LBUTTON )
		|| !m_input.is_mouse_in_bounds( x, y, m_height, m_height ) )
		return;

	*m_item = !*m_item;

}
```

`cstrike/menu/objects/checkbox/checkbox.h`:

```h
#pragma once

#include "../object.h"

struct checkbox : public object {

	checkbox( std::string_view name, int x, int y );

	void set_size( int size );
	void set_item( bool* item );

	void draw( );

	void think( );

	int get_height( ) {

		return m_height + m_gap;

	}

private:

	int m_height;

	bool* m_item;

};
```

`cstrike/menu/objects/group/group.cpp`:

```cpp
#include "group.h"

#include "../../menu.h"

group::group( int x, int y, int width, int height ) {

	m_size = {

		x,
		y,
		width,
		height

	};

}

void group::draw( ) {

	m_render.draw_outlined_rect( m_menu.m_size.x + m_size.x, m_menu.m_size.y + m_size.y, 
		m_size.width, m_size.height, 
		m_menu.m_colors.light );

	for ( auto obj : m_objects ) {

		obj->draw( );

		obj->think( );

	}

}

void group::setup_checkbox( std::string_view name, bool* item ) {

	int x = m_size.x + m_gap,
		y = m_size.y + get_height( ) + m_gap;

	auto obj = std::make_shared< checkbox >( name, x, y );

	obj->set_size( 13 );
	obj->set_item( item );

	m_objects.push_back( std::move( obj ) );

}

void group::setup_slider( std::string_view name, int* item, int min, int max ) {

	int x = m_size.x + m_gap,
		y = m_size.y + get_height( ) + m_gap;

	auto obj = std::make_shared< slider >( name, x, y );

	obj->set_size( 100, 13 );
	obj->set_item( item );
	obj->set_range( min, max );

	m_objects.push_back( std::move( obj ) );

}

void group::setup_key( std::string_view name, int* item ) {

	int x = m_size.x + m_gap,
		y = m_size.y + get_height( ) + m_gap;

	auto obj = std::make_shared< key >(  name, x, y );

	obj->set_size( 50, 13 );
	obj->set_item( item );

	m_objects.push_back( std::move( obj ) );

}

int group::get_height( ) {

	int height = 0;

	for ( auto obj : m_objects )
		height += obj->get_height( );

	return height;

}
```

`cstrike/menu/objects/group/group.h`:

```h
#pragma once

#include "../object.h"

struct group {

	group( int x, int y, int width, int height );

	void draw( );

	void setup_checkbox( std::string_view name, bool* item );

	void setup_slider( std::string_view name, int* item, int min, int max );

	void setup_key( std::string_view name, int* item );

private:

	int get_height( );

	int m_gap = 5;

	struct {

		int x, y, width, height;

	} m_size;

	std::vector< std::shared_ptr< object > > m_objects;

};
```

`cstrike/menu/objects/key/key.cpp`:

```cpp
#include "key.h"

#include "../../menu.h"

key::key( std::string_view name, int x, int y ) : object( name, x, y ) {

	set_size( 0, 0 );
	set_item( nullptr );

}

void key::set_size( int width, int height ) {

	m_width = width;
	m_height = height;

}

void key::set_item( int* item ) {

	m_item = item;

}

void key::draw( ) {

	int x = m_menu.m_size.x + m_size.x,
		y = m_menu.m_size.y + m_size.y;

	m_render.draw_outlined_rect( x, y,
		m_width, m_height,
		m_menu.m_colors.light );

	m_render.draw_text( m_render.m_fonts.main,
		x + m_width / 2, y,
		m_render.format_text( "%d", *m_item ),
		m_menu.m_colors.light,
		x_centre );

	m_render.draw_text( m_render.m_fonts.main,
		x + m_width + m_gap, y,
		m_name,
		m_menu.m_colors.light );

}

void key::think( ) {

	int x = m_menu.m_size.x + m_size.x,
		y = m_menu.m_size.y + m_size.y;

	if ( m_input.is_key_toggled( VK_LBUTTON )
		&& m_input.is_mouse_in_bounds( x, y, m_width, m_height ) ) {

		m_active = true;
		m_input.set_last_key( );

	}
	
	if ( !m_active )
		return;

	int key = m_input.get_last_key( );
	if ( key == -1 )
		return;

	if ( key != VK_ESCAPE )
		*m_item = key;

	m_active = false;

}
```

`cstrike/menu/objects/key/key.h`:

```h
#pragma once

#include "../object.h"

struct key : public object {

	key( std::string_view name, int x, int y );

	void set_size( int width, int height );
	void set_item( int* item );

	void draw( );

	void think( );

	int get_height( ) {

		return m_height + m_gap;

	}

private:

	int m_width;
	int m_height;

	int* m_item;

	bool m_active = false;

};
```

`cstrike/menu/objects/object.cpp`:

```cpp
#include "object.h"

#include "../menu.h"

object::object( std::string_view name, int x, int y ) {

	m_name = name;

	m_size.x = x;
	m_size.y = y;

}
```

`cstrike/menu/objects/object.h`:

```h
#pragma once

#include "../../input/input.h"
#include "../../render/render.h"

struct object {

	object( std::string_view name, int x, int y );

	virtual void draw( ) = 0;

	virtual void think( ) = 0;

	virtual int get_height( ) = 0;

protected:

	std::string m_name;

	int m_gap = 5;

	struct {

		int x, y;

	} m_size;

};
```

`cstrike/menu/objects/objects.h`:

```h
#pragma once

#include "tab/tab.h"
#include "group/group.h"
#include "checkbox/checkbox.h"
#include "slider/slider.h"
#include "key/key.h"
```

`cstrike/menu/objects/slider/slider.cpp`:

```cpp
#include "slider.h"

#include "../../menu.h"

slider::slider( std::string_view name, int x, int y ) : object( name, x, y ) { 

	set_size( 0, 0 );
	set_item( nullptr );
	set_range( 0, 0 );

}

void slider::set_size( int width, int height ) {

	m_width = width;
	m_height = height;

}

void slider::set_item( int* item ) {

	m_item = item;

}

void slider::set_range( int min, int max ) {

	m_min = min;
	m_max = max;

}

void slider::draw( ) {

	int x = m_menu.m_size.x + m_size.x,
		y = m_menu.m_size.y + m_size.y;

	m_render.draw_outlined_rect( x, y,
		m_width, m_height,
		m_menu.m_colors.light );

	int width = ( *m_item - m_min ) * m_width / ( m_max - m_min );

	m_render.draw_filled_rect( x + 1, y + 1,
		width - 2, m_height - 2,
		*m_item ? m_menu.m_colors.vibrant : m_menu.m_colors.light );

	m_render.draw_text( m_render.m_fonts.main,
		x + m_width + m_gap, y,
		m_render.format_text( "%s - %d", m_name.data( ), *m_item ),
		m_menu.m_colors.light );

}

void slider::think( ) {

	int x = m_menu.m_size.x + m_size.x,
		y = m_menu.m_size.y + m_size.y;

	if ( ( !m_active ? m_input.is_key_toggled( VK_LBUTTON ) : m_input.is_mouse_down( VK_LBUTTON ) )
		&& m_input.is_mouse_in_bounds( x, y, m_width, m_height ) )
		m_active = true;

	if ( !m_active )
		return;

	if ( !m_input.is_mouse_down( VK_LBUTTON ) )
		m_active = false;

	*m_item = std::clamp( m_min + ( m_max - m_min ) * ( m_input.get_mouse_x( ) - x ) / m_width, m_min, m_max );

}
```

`cstrike/menu/objects/slider/slider.h`:

```h
#pragma once

#include "../object.h"

struct slider : public object {

	slider( std::string_view name, int x, int y );

	void set_size( int width, int height );
	void set_item( int* item );
	void set_range( int min, int max );

	void draw( );

	void think( );

	int get_height( ) {

		return m_height + m_gap;

	}

private:

	int m_width;
	int m_height;

	int* m_item;

	int m_min;
	int m_max;

	bool m_active = false;

};
```

`cstrike/menu/objects/tab/tab.cpp`:

```cpp
#include "tab.h"

#include "../../menu.h"

tab::tab( std::string_view name ) {

	m_name = name;

}

void tab::draw( int x, int y, bool is_selected ) {

	m_render.draw_text( m_render.m_fonts.main, x, y, 
		m_name, 
		is_selected ? m_menu.m_colors.vibrant : m_menu.m_colors.light,
		x_centre | y_centre );

	if ( !is_selected )
		return;

	for ( auto group : m_groups )
		group.draw( );

}

void tab::setup_group( int x, int y, int width, int height, std::function< void( group* ) > function ) {

	group group( x, y, width, height );

	function( &group );

	m_groups.push_back( group );

}
```

`cstrike/menu/objects/tab/tab.h`:

```h
#pragma once

#include "../object.h"

#include "../group/group.h"

struct tab {

	tab( std::string_view name );

	void draw( int x, int y, bool is_selected );

	void setup_group( int x, int y, int width, int height, std::function< void( group* ) > function );

private:

	std::string m_name;

	std::vector< group > m_groups;

};
```

`cstrike/render/render.cpp`:

```cpp
#include "render.h"

bool render::setup( ) {

	create_font( m_fonts.main, "Tahoma", 12, 350, fontflag_outline );

	m_interfaces.m_surface->get_screen_size( m_screen.w, m_screen.h );

	return true;

}

void render::draw_line( int x0, int y0, int x1, int y1, const color& color ) {

	m_interfaces.m_surface->draw_set_color( color.r, color.g, color.b, color.a );

	m_interfaces.m_surface->draw_line( x0, y0, x1, y1 );

}

void render::draw_filled_rect( int x, int y, int width, int height, const color& color, int flags ) {

	m_interfaces.m_surface->draw_set_color( color.r, color.g, color.b, color.a );

	handle_flags( x, y, width, height, flags );

	m_interfaces.m_surface->draw_filled_rect( x, y, x + width, y + height );

}

void render::draw_outlined_rect( int x, int y, int width, int height, const color& color, int flags ) {

	m_interfaces.m_surface->draw_set_color( color.r, color.g, color.b, color.a );

	handle_flags( x, y, width, height, flags );

	m_interfaces.m_surface->draw_outlined_rect( x, y, x + width, y + height );

}

void render::draw_text( h_font& font, int x, int y, std::wstring_view text, const color& color, int flags ) {

	if ( flags ) {
		
		int width, height;
		m_interfaces.m_surface->get_text_size( font, text.data( ), width, height );

		handle_flags( x, y, width, height, flags );
		
	}

	m_interfaces.m_surface->draw_set_text_color( color.r, color.g, color.b, color.a );
	m_interfaces.m_surface->draw_set_text_font( font );
	m_interfaces.m_surface->draw_set_text_pos( x, y );
	m_interfaces.m_surface->draw_print_text( text.data( ), text.size( ) );

}

void render::draw_text( h_font& font, int x, int y, std::string_view text, const color& color, int flags ) {

	draw_text( font, x, y, std::wstring( text.begin( ), text.end( ) ), color, flags );

}

std::string_view render::format_text( std::string_view format, ... ) {

	if ( std::strlen( format.data( ) ) >= sizeof( m_buffer ) )
		return std::string_view( );

	va_list arguments;

	va_start( arguments, format );

	std::memset( m_buffer, '\0', sizeof( m_buffer ) );
	vsprintf_s( m_buffer, format.data( ), arguments );

	std::string_view text = m_buffer;

	va_end( arguments );

	return text;

}

void render::create_font( h_font& font, std::string_view name, int tall, int weight, int flags ) {

	font = m_interfaces.m_surface->create_font( );
		
	m_interfaces.m_surface->set_font_glyph( font, name.data( ), tall, weight, 0, 0, flags );

}

void render::handle_flags( int& x, int& y, int width, int height, int flags ) {

	if ( !flags )
		return;

	if ( flags & x_right )
		x -= width;
	else if ( flags & x_centre )
		x -= width / 2;

	if ( flags & y_bottom )
		y -= height;
	else if ( flags & y_centre )
		y -= height / 2;

}

```

`cstrike/render/render.h`:

```h
#pragma once

#include "../cstrike.h"

enum render_flags {

	x_right = 1,
	x_centre = 1 << 1,
	
	y_bottom = 1 << 2,
	y_centre = 1 << 3,

};

struct render {

	bool setup( );

	void draw_line( int x0, int y0, int x1, int y1, const color& color );

	void draw_filled_rect( int x, int y, int width, int height, const color& color, int flags = { } );

	void draw_outlined_rect( int x, int y, int width, int height, const color& color, int flags = { } );

	void draw_text( h_font& font, int x, int y, std::wstring_view text, const color& color, int flags = { } );

	void draw_text( h_font& font, int x, int y, std::string_view text, const color& color, int flags = { } );

	std::string_view format_text( std::string_view format, ... );

	struct {

		h_font main;

	} m_fonts;

	struct {

		int w, h;

	} m_screen;

private:

	void create_font( h_font& font, std::string_view name, int tall, int weight, int flags = { } );

	void handle_flags( int& x, int& y, int width, int height, int flags );

	char m_buffer[ 256 ];

};

inline render m_render;
```

`other/color/color.h`:

```h
#pragma once

struct color {

	color( ) : r{ 0 }, g{ 0 }, b{ 0 }, a{ 255 } { };

	color( int r, int g, int b, int a = 255 ) : r{ r }, g{ g }, b{ b }, a{ a } { };

	int r, g, b, a;

};
```

`other/console/console.cpp`:

```cpp
#include "console.h"

#include <iostream>

bool console::setup( std::string_view name ) {

	if ( !AllocConsole( ) )
		return false;

	freopen_s( reinterpret_cast< _iobuf** >( stdin ), "CONIN$", "r", stdin );
	freopen_s( reinterpret_cast< _iobuf** >( stdout ), "CONOUT$", "w", stdout );
	freopen_s( reinterpret_cast< _iobuf** >( stderr ), "CONOUT$", "w", stderr );

	m_handle = GetStdHandle( STD_OUTPUT_HANDLE );

	return SetConsoleTitleA( name.data( ) );

}

void console::unload( ) {

	fclose( static_cast< _iobuf* >( stdin ) );
	fclose( static_cast< _iobuf* >( stdout ) );
	fclose( static_cast< _iobuf* >( stderr ) );

	FreeConsole( );

}

void console::log( std::string_view format, ... ) {

	if ( std::strlen( format.data( ) ) >= sizeof( m_buffer ) )
		return;

	va_list arguments;

	va_start( arguments, format );

	std::memset( m_buffer, '\0', sizeof( m_buffer ) );
	vsprintf_s( m_buffer, format.data( ), arguments );

	SetConsoleTextAttribute( m_handle, 7 );

	std::cout << m_buffer << std::endl;

	va_end( arguments );

}
```

`other/console/console.h`:

```h
#pragma once

#include <windows.h>
#include <string>

struct console {

	bool setup( std::string_view name );

	void unload( );

	void log( std::string_view format, ... );

private:

	HANDLE m_handle;

	char m_buffer[ 256 ];

};

inline console m_console;
```

`other/easing/easing.h`:

```h
#pragma once

struct easing {

	// https://github.com/nicolausYes/easing-functions

	inline double in_cubic( double x ) {

		return x * x * x;

	}

};

inline easing m_easing;
```

`other/hash/hash.cpp`:

```cpp
#include "hash.h"

std::size_t hash::get( std::string_view string ) {

    std::size_t ret = m_basis;

    std::size_t length = std::strlen( string.data( ) );
    for ( std::size_t i = 0; i < length; ++i ) {

        ret ^= string[ i ];
        ret *= m_prime;

    }

    return ret;

}
```

`other/hash/hash.h`:

```h
#pragma once

#include <cstddef>
#include <string>

struct hash {

	std::size_t get( std::string_view string );

private:

	std::size_t m_basis = 0x8adf9ed5;
	std::size_t m_prime = 0x60561129;

};

inline hash m_hash;
```

`other/math/q_angle.h`:

```h
#pragma once

struct q_angle {

	float x, y, z;

};
```

`other/math/vector_3d.h`:

```h
#pragma once

#include <cmath>

struct vector_3d {

	vector_3d( ) : x{ }, y{ }, z{ } { }

	vector_3d( float x, float y, float z ) : x{ x }, y{ y }, z{ z } { }

	inline vector_3d& operator+=( const vector_3d& v ) {

		x += v.x;
		y += v.y;
		z += v.z;

		return *this;

	}

	inline vector_3d& operator-=( const vector_3d& v ) {

		x -= v.x;
		y -= v.y;
		z -= v.z;

		return *this;

	}

	inline vector_3d& operator*=( const vector_3d& v ) {

		x *= v.x;
		y *= v.y;
		z *= v.z;

		return *this;

	}

	inline vector_3d& operator/=( const vector_3d& v ) {

		x /= v.x;
		y /= v.y;
		z /= v.z;

		return *this;

	}

	inline vector_3d& operator+=( float fl ) {

		x += fl;
		y += fl;
		z += fl;

		return *this;

	}

	inline vector_3d& operator-=( float fl ) {

		x -= fl;
		y -= fl;
		z -= fl;

		return *this;

	}


	inline vector_3d& operator*=( float fl ) {

		x *= fl;
		y *= fl;
		z *= fl;

		return *this;

	}

	inline vector_3d& operator/=( float fl ) {

		x /= fl;
		y /= fl;
		z /= fl;

		return *this;

	}

	inline vector_3d operator+( const vector_3d& v ) {

		vector_3d result;

		result.x = x + v.x;
		result.y = y + v.y;
		result.z = z + v.z;

		return result;

	}

	inline vector_3d operator-( const vector_3d& v ) {

		vector_3d delta;

		delta.x = x - v.x;
		delta.y = y - v.y;
		delta.z = z - v.z;

		return delta;

	}

	inline vector_3d operator*( const vector_3d& v ) {

		vector_3d result;

		result.x = x * v.x;
		result.y = y * v.y;
		result.z = z * v.z;

		return result;

	}

	inline vector_3d operator/( const vector_3d& v ) {

		vector_3d result;

		result.x = x / v.x;
		result.y = y / v.y;
		result.z = z / v.z;

		return result;

	}

	inline vector_3d operator+( float fl ) {

		return {

			x + fl,
			y + fl,
			z + fl

		};

	}

	inline vector_3d operator-( float fl ) {

		return {

			x - fl,
			y - fl,
			z - fl

		};

	}

	inline vector_3d operator*( float fl ) {

		return {

			x * fl,
			y * fl,
			z * fl

		};

	}

	inline vector_3d operator/( float fl ) {

		return {

			x / fl,
			y / fl,
			z / fl
		
		};

	}

	inline float length( ) {

		return std::sqrtf( std::powf( x, 2 ) + std::powf( y, 2 ) + std::powf( z, 2 ) );

	}

	inline float length_sqr( ) {

		return std::powf( x, 2 ) + std::powf( y, 2 ) + std::powf( z, 2 );

	}

	inline float vector_normalize( vector_3d& v ) {

		float radius = std::sqrtf( std::powf( x, 2 ) + std::powf( y, 2 ) + std::powf( z, 2 ) );
		radius = 1.f / ( radius + FLT_EPSILON );

		v *= radius;

		return radius;

	}

	inline vector_3d normalized( ) {

		vector_3d v = *this;
		vector_normalize( v );
		return v;

	}

	float x, y, z;

};
```

`other/memory/address.h`:

```h
#pragma once

#include <intrin.h>

struct address {

	address( ) : m_address{ } {



	}

	address( std::size_t address ) : m_address{ address } {



	}

	address( void* address ) : m_address{ reinterpret_cast< std::size_t >( address ) } {



	}

	inline operator std::size_t( ) {

		return m_address;

	}

	inline operator void* ( ) {

		return reinterpret_cast< void* >( m_address );

	}


	inline bool operator==( address address ) {

		return as< std::size_t >( ) == address.as< std::size_t >( );

	}

	inline bool operator!=( address address ) {

		return as< std::size_t >( ) != address.as< std::size_t >( );

	}

	template< typename t = address > inline t to( ) {

		return *( t* )m_address;

	}

	template< typename t = address > inline t as( ) {

		return m_address ? ( t )m_address : t( );

	}

	template< typename t = address > inline t at( std::size_t offset ) {

		return m_address ? *( t* )( m_address + offset ) : t( );

	}

	template< typename t = address > inline t add( std::size_t offset ) {

		return m_address ? ( t )( m_address + offset ) : t( );

	}

	template< typename t = address > inline t sub( std::size_t offset ) {

		return m_address ? ( t )( m_address - offset ) : t( );

	}

	template< typename t = address > inline t get( std::size_t dereferences = 1 ) {

		if ( !m_address )
			return t( );

		std::size_t object = m_address;

		while ( dereferences-- )
			if ( object )
				object = *reinterpret_cast< std::size_t* >( object );

		return ( t )object;

	}

	template< typename t = std::size_t > inline void set( const t& value ) {

		if ( !m_address )
			return;

		*( t* )m_address = value;

	}

	template< typename t = address > inline t relative( std::size_t offset = 0x1 ) {

		if ( !m_address )
			return t( );

		std::size_t new_address = m_address + offset;

		// boris will gutter stomp you

		std::int32_t relative_offset = *reinterpret_cast< std::int32_t* >( new_address );

		if ( !relative_offset )
			return t( );

		return ( t )( new_address + sizeof( std::size_t ) + relative_offset );

	}

protected:

	std::size_t m_address;

};
```

`other/memory/stack.h`:

```h
#pragma once

#include "address.h"

struct stack : address {

	stack( void* address_of_return_address ) : address( m_utils.get_ebp( address_of_return_address ) ) {



	}

	inline stack& next( ) {

		return *reinterpret_cast< stack* >( m_address );

	}

	template< typename t = address > inline t local( std::size_t offset ) {

		return ( t )( m_address - offset );

	}

	template< typename t = address > inline t argument( std::size_t offset ) {

		return ( t )( m_address + offset );

	}

	inline address return_address( ) {

		if ( !m_address )
			return address( );

		return *reinterpret_cast< std::size_t* >( m_address + sizeof( std::size_t ) );

	}

	inline address address_of_return_address( ) {

		if ( !m_address )
			return address( );

		return m_address + sizeof( std::size_t );

	}

};
```

`other/module/module.cpp`:

```cpp
#include "module.h"

#include "../console/console.h"
#include "../../valve/modules/modules.h"

module_info::module_info( std::size_t loaded_module ) {

	m_loaded_module = loaded_module;
	m_bitmap = reinterpret_cast< std::uint8_t* >( m_loaded_module );
	m_dos_header = reinterpret_cast< PIMAGE_DOS_HEADER >( m_loaded_module );
	m_base = m_dos_header->e_lfanew;
	m_nt_headers = reinterpret_cast< PIMAGE_NT_HEADERS >( m_loaded_module + m_base );
	m_size = m_nt_headers->OptionalHeader.SizeOfImage;

}

address pattern::find( std::string_view pattern ) {

	// returns: the address of the pattern in the module

	// size of byte array never exceeds n/2 
	// so n/2 can be used such that the array is never resized
	int* bytes = new int[ pattern.size( ) / 2 ];

	address result = search_byte_array( bytes, build_byte_array( pattern.data( ), bytes ) );

	delete[ ] bytes;

	if ( !result )
		m_console.log( "failed to find pattern: %s", pattern.data( ) );

	return result;

}

std::size_t pattern::build_byte_array( const char* pattern, int* bytes ) {

	// n: length of pattern
	// time: O(n) 
	// space: O(n) 
	// returns: size of the byte array

	std::size_t count = 0;

	auto char_to_int = [ ]( char input ) -> int {

		if ( input >= '0' && input <= '9' )
			return input - '0';

		if ( input >= 'A' && input <= 'F' )
			return input - 'A' + 10;

		return input - 'a' + 10;

	};

	while ( pattern[ 0 ] && pattern[ 1 ] ) {

		if ( pattern[ 0 ] == '?' || pattern[ 1 ] == '?' ) {

			bytes[ count++ ] = -1;
			pattern += 1;

		} else if ( pattern[ 0 ] != ' ' && pattern[ 1 ] != ' ' ) {

			bytes[ count++ ] = char_to_int( pattern[ 0 ] ) * 16 + char_to_int( pattern[ 1 ] );

		}

		pattern += 1;

	}

	return count;

}

address pattern::search_byte_array( int* bytes, std::size_t size ) {

	// returns: the address of the byte array in the module

	address result;

	for ( std::size_t i = 0; i < m_size - size; i++ ) {

		bool found = true;
		for ( std::size_t j = 0; j < size; j++ ) {

			found = m_bitmap[ i + j ] == bytes[ j ] || bytes[ j ] == -1;
			if ( !found )
				break;

		}

		if ( !found )
			continue;

		result = &m_bitmap[ i ];
		break;

	}

	return result;

}

bool loaded_module::add_address( std::string_view name, std::string_view pattern, bool relative ) {

	auto address = find( pattern );
	if ( !address )
		return false;

	if ( relative ) {

		address = address.relative( );
		if ( !address )
			return false;

	}

	m_addresses[ m_hash.get( name ) ] = address;

	return true;

}

bool loaded_module::hook_function( std::string_view name, void* custom_function ) {

	std::size_t hash = m_hash.get( name );

	void* function = m_addresses[ hash ];
	if ( !function )
		return false;

	static auto hook = m_modules.m_gameoverlayrenderer_dll.get_address( "GameOverlayRenderer::HookFunc" ).as< bool( __cdecl* )( void*, void*, void*, int ) >( );
	if ( !hook( function, custom_function, &m_originals[ hash ], 0 ) )
		return false;

	m_console.log( "hooked %s -> 0x%x", name.data( ), function );

	return true;
}

void loaded_module::unload_functions( ) {

	static auto unhook = m_modules.m_gameoverlayrenderer_dll.get_address( "GameOverlayRenderer::UnhookFunc" ).as< void( __cdecl* )( void*, bool ) >( );

	for ( auto& [k, v] : m_addresses )
		unhook( v, false );

}

bool loaded_module::valid_addresses( ) {

	for ( auto& [k, v] : m_addresses )
		if ( !v )
			return false;

	return true;

}
```

`other/module/module.h`:

```h
#pragma once

#include <windows.h>
#include <cstddef>
#include <cstdint>
#include <string>
#include <unordered_map>

#include "../memory/address.h"
#include "../hash/hash.h"

struct module_info {

	module_info( ) = default;

	module_info( std::size_t loaded_module );

	std::size_t get_module( ) { return m_loaded_module; }

protected:

	std::size_t m_loaded_module;
	std::uint8_t* m_bitmap;
	PIMAGE_DOS_HEADER m_dos_header;
	long m_base;
	PIMAGE_NT_HEADERS m_nt_headers;
	unsigned long m_size;

};

struct pattern : public module_info {

	pattern( ) = default;

	pattern( std::size_t loaded_module ) : module_info( loaded_module ) { };

	address find( std::string_view pattern );

private:

	std::size_t build_byte_array( const char* pattern, int* bytes );
	address search_byte_array( int* bytes, std::size_t size );

};

struct detour {

	virtual bool hook_function( std::string_view name, void* custom_function ) = 0;

	virtual void unload_functions( ) = 0;

	template< typename t > inline t get( std::string_view name ) { return ( t )m_originals[ m_hash.get( name ) ]; }

protected:

	std::unordered_map< std::size_t, void* > m_originals;

};

struct loaded_module : public pattern, detour {

	loaded_module( ) = default;

	loaded_module( std::size_t loaded_module ) : pattern( loaded_module ) { };

	bool add_address( std::string_view name, std::string_view pattern, bool relative = false );

	bool hook_function( std::string_view name, void* custom_function );

	void unload_functions( );

	address get_address( std::string_view name ) { return m_addresses[ m_hash.get( name ) ]; }

	bool valid_addresses( );

private:

	std::unordered_map< std::size_t, address > m_addresses;

};
```

`other/other.h`:

```h
#pragma once

#include "color/color.h"
#include "console/console.h"
#include "easing/easing.h"
#include "hash/hash.h"
#include "pe/pe.h"
#include "utils/utils.h"

#include "math/q_angle.h"
#include "math/vector_3d.h"

#include "memory/stack.h"
```

`other/pe/pe.cpp`:

```cpp
#include "pe.h"

#include <winternl.h>
#include <TlHelp32.h>

#include "../console/console.h"

bool pe::setup( ) {

	auto peb = reinterpret_cast< _PEB* >( __readfsdword( 0x30 ) );
	if ( !peb )
		return false;

	auto list = &peb->Ldr->InMemoryOrderModuleList;
	for ( auto it = list->Flink; it != list; it = it->Flink ) {

		auto ldr_entry = CONTAINING_RECORD( it, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks );
		if ( !ldr_entry )
			continue;

		auto base_dll_name = reinterpret_cast< UNICODE_STRING* >( &ldr_entry->Reserved4[ 0 ] );

		// not a good way to do this, causes a warning as well
		// but winapi is forcing my hand
		auto wide_name = std::wstring( base_dll_name->Buffer, base_dll_name->Length >> 1 );
		auto name = std::string( wide_name.begin( ), wide_name.end( ) );

		m_loaded_modules[ m_hash.get( name ) ] = reinterpret_cast< std::size_t >( ldr_entry->DllBase );

		m_console.log( "found module %s -> 0x%x", name.data( ), m_loaded_modules[ m_hash.get( name ) ] );

	}

	return true;

}

std::size_t pe::export_fn( std::size_t base, std::size_t fn_hash, bool in_memory ) {

	auto rva_2_offset = [ ]( std::uint32_t rva, PIMAGE_NT_HEADERS nt_headers, bool in_memory = false ) {

		if ( !rva || !in_memory )
			return static_cast< std::int32_t >( rva );

		auto sec = IMAGE_FIRST_SECTION( nt_headers );
		for ( size_t i = 0; i < nt_headers->FileHeader.NumberOfSections; i++ ) {
			if ( rva >= sec->VirtualAddress && rva < sec->VirtualAddress + sec->Misc.VirtualSize )
				break;
			sec++;
		}

		return static_cast< std::int32_t >( rva - sec->VirtualAddress + sec->PointerToRawData );

	};

	auto dos_headers = reinterpret_cast< PIMAGE_DOS_HEADER >( base );
	if ( dos_headers->e_magic != IMAGE_DOS_SIGNATURE )
		return 0;

	auto nt_headers = reinterpret_cast< PIMAGE_NT_HEADERS >( base + dos_headers->e_lfanew );
	if ( nt_headers->Signature != IMAGE_NT_SIGNATURE )
		return 0;

	auto exports = reinterpret_cast< IMAGE_EXPORT_DIRECTORY* >(
		rva_2_offset( base + nt_headers->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT ].VirtualAddress,
			nt_headers, in_memory ) );

	auto names = reinterpret_cast< std::uint32_t* >( base + rva_2_offset( exports->AddressOfNames, nt_headers, in_memory ) );

	auto ordinal_index = static_cast< std::uint32_t >( -1 );

	// go thru all exported functions until we find our export
	for ( std::uint32_t i = 0; i < exports->NumberOfFunctions; i++ ) {

		auto function_name = reinterpret_cast< const char* >( base + rva_2_offset( names[ i ], nt_headers, in_memory ) );

		// it is what it is
		if ( m_hash.get( function_name ) == fn_hash ) {

			ordinal_index = i;
			break;

		}
	}

	if ( ordinal_index > exports->NumberOfFunctions )
		return 0;

	auto ordinals = reinterpret_cast< std::uint16_t* >( base + rva_2_offset( exports->AddressOfNameOrdinals, nt_headers, in_memory ) );
	auto addresses = reinterpret_cast< std::uint32_t* >( base + rva_2_offset( exports->AddressOfFunctions, nt_headers, in_memory ) );

	return base + rva_2_offset( addresses[ ordinals[ ordinal_index ] ], nt_headers, in_memory );

}
```

`other/pe/pe.h`:

```h
#pragma once

#include <unordered_map>

#include "../hash/hash.h"
#include "../module/module.h"

// disable cringe warning
#pragma warning(disable : 4244)

struct pe {

	// dump all present modules in peb on construct 
	// NOTE: this could cause issues if dll is loaded too early, but this is how the rest of the sdk is written
	bool setup( );

	// get export address
	std::size_t export_fn( std::size_t base, std::size_t fn_hash, bool in_memory = false );

	// get module by name
	std::size_t get( std::string_view name ) { return m_loaded_modules[ m_hash.get( name ) ]; }

private:

	// store all modules
	std::unordered_map< std::size_t, std::size_t > m_loaded_modules;

};

inline pe m_pe;
```

`other/utils/utils.cpp`:

```cpp
#include "utils.h"

bool utils::create_thread( DWORD WINAPI function( void* ), void* parameter ) {

	HANDLE handle = CreateThread( NULL, 0, function, parameter, 0, NULL );

	if ( !handle )
		return false;

	CloseHandle( handle );

	return true;

}
```

`other/utils/utils.h`:

```h
#pragma once

#include <windows.h>
#include <thread>
#include <cstddef>

#include "../memory/address.h"

struct utils {

	bool create_thread( DWORD WINAPI function( void* ), void* parameter );

	inline void sleep( std::size_t milliseconds ) {

		std::this_thread::sleep_for( std::chrono::milliseconds( milliseconds ) );

	}

	inline std::size_t get_ebp( void* address_of_return_address ) {

		return reinterpret_cast< std::size_t >( address_of_return_address ) - sizeof( std::size_t );

	}

	template< typename t = address > inline t get_v_func( address pointer, std::size_t index ) {

		return ( t )( pointer.to< t* >( )[ index ] );

	}

};

inline utils m_utils;
```

`valve/cdll_int.h`:

```h
#pragma once

#include "../other/utils/utils.h"

struct client_class;
struct bf_write;

using player_info = struct {

	char _pad0[ 0x8 ];
	int m_xuid_low;
	char _pad1[ 0x4 ];
	char m_name[ 256 ];
	char _pad2[ 0x13c ];

};

struct engine_client {

	inline auto get_player_info( int ent_num, player_info* info ) {

		return m_utils.get_v_func< bool( __thiscall* )( void*, int, player_info* ) >( this, 8 )( this, ent_num, info );

	}

	inline auto get_local_player( ) {

		return m_utils.get_v_func< int( __thiscall* )( void* ) >( this, 12 )( this );

	}

};

struct base_client_dll {

	inline auto get_all_classes( ) {

		return m_utils.get_v_func< client_class* ( __thiscall* )( void* ) >( this, 8 )( this );

	}

	inline auto write_usercmd_delta_to_buffer( int slot, bf_write* buf, int from, int to, bool isnewcommand ) {

		return m_utils.get_v_func< bool( __thiscall* )( void*, int, void*, int, int, bool ) >( this, 24 )( this, slot, buf, from, to, isnewcommand );

	}

};
```

`valve/client/animation_layer.h`:

```h
#pragma once

#include "../studio.h"

struct animation_layer {

	char _pad0[ 0x8 ]; // 0
	studio_hdr* m_dispatched_studio_hdr; // 8
	int m_dispatched_src; // 12
	int m_dispatched_dst; // 16
	char _pad1[ 0x4 ]; // 20
	int m_sequence; // 24
	char _pad2[ 0x4 ]; // 28
	float m_weight; // 32
	char _pad3[ 0x4 ]; // 36
	float m_playback_rate; // 40
	float m_cycle; // 44

};
```

`valve/client/base_animating.h`:

```h
#pragma once

#include "base_player.h"

#include "../studio.h"

struct base_animating : base_player {

	inline auto set_sequence( int sequence ) {

		return m_utils.get_v_func< void( __thiscall* )( void*, int ) >( this, 218 )( this, sequence );

	}

	inline auto frame_advance( float interval ) {

		return m_utils.get_v_func< float( __thiscall* )( void*, float ) >( this, 220 )( this, interval );

	}

	inline auto lookup_bone( const char* name ) {

		static auto function = m_modules.m_client_dll.get_address( "C_BaseAnimating::LookupBone" ).as< int( __thiscall* )( void*, const char* ) >( );

		return function( this, name );

	}

	inline auto get_bone_position( int bone_id, vector_3d& origin ) {

		static auto function = m_modules.m_client_dll.get_address( "C_BaseAnimating::GetBonePosition" ).as< void( __thiscall* )( void*, int, vector_3d* ) >( );

		vector_3d vectors[ 4 ];
		function( this, bone_id, vectors );
		origin = { vectors[ 1 ].x, vectors[ 2 ].y, vectors[ 3 ].z };

	}

	inline auto get_model_ptr( ) {

		static auto function = m_modules.m_client_dll.get_address( "C_BaseAnimating::GetModelPtr" ).as< studio_hdr* ( __thiscall* )( void* ) >( );

		return function( this );

	}

	inline auto get_first_sequence_anim_tag( int sequence, int desired_tag ) {

		static auto function = m_modules.m_client_dll.get_address( "C_BaseAnimating::GetFirstSequenceAnimTag" ).as< float( __thiscall* )( void*, int, int, int ) >( );

		return function( this, sequence, desired_tag, 0 );

	}

	inline auto get_sequence_activity( int sequence ) {

		static auto function = m_modules.m_client_dll.get_address( "C_BaseAnimating::GetSequenceActivity" ).as< int( __thiscall* )( void*, int ) >( );

		return function( this, sequence );

	}

	inline auto lookup_pose_parameter( const char* name ) {

		static auto function = m_modules.m_client_dll.get_address( "C_BaseAnimating::LookupPoseParameter" ).as< int( __thiscall* )( void*, studio_hdr*, const char* name ) >( );

		return function( this, get_model_ptr( ), name );

	}

	inline auto set_pose_parameter( int parameter, float value ) {

		static auto address = m_modules.m_client_dll.get_address( "Studio_SetPoseParameter" );

		studio_hdr* studio_hdr = get_model_ptr( );
		if ( !studio_hdr )
			return value;

		if ( parameter >= 0.f ) {

			float new_value;
			
			__asm {

				pushad

				movss xmm2, [ value ]
				lea ecx, [ new_value ]
				push ecx
				mov edx, parameter
				mov ecx, studio_hdr
				call address
				pop ecx

				popad

			}

			get_pose_parameter( )[ parameter ] = new_value;

		}

		return value;

	}

	inline auto draw_server_hitboxes( float duration = 0.f, int /*bool*/ monocolor = 0 ) {

		static auto address = m_modules.m_server_dll.get_address( "CBaseAnimating::DrawServerHitboxes" );

		base_player* player = base_player::util_player_by_index( get_client_networkable( )->get_index( ) );
		if ( !player )
			return;

		__asm {

			pushad

			movss xmm1, duration
			push monocolor
			mov ecx, player
			call address

			popad
		}

	}

};
```

`valve/client/base_combat_character.h`:

```h
#pragma once

#include "base_entity.h"

struct base_combat_character : base_entity {

	inline auto& get_active_weapon( ) {

		static auto offset = m_netvars.m_offsets[ m_hash.get( "DT_BaseCombatCharacter->m_hActiveWeapon" ) ];

		return *reinterpret_cast< std::size_t* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

};
```

`valve/client/base_entity.h`:

```h
#pragma once

#include "../client_networkable.h"
#include "../client_renderable.h"

#include "../netvars/netvars.h"

#include "../shared/user_cmd.h"

struct base_player;

struct base_entity {

	inline client_renderable* get_client_renderable( ) {

		return reinterpret_cast< client_renderable* >( reinterpret_cast< std::size_t >( this ) + 0x4 );

	}

	inline client_networkable* get_client_networkable( ) {

		return reinterpret_cast< client_networkable* >( reinterpret_cast< std::size_t >( this ) + 0x8 );

	}

	inline auto on_latch_interpolated_variables( int flags ) {

		return m_utils.get_v_func< void( __thiscall* )( void*, int ) >( this, 107 )( this, flags );

	}

	inline auto think( ) {

		return m_utils.get_v_func< void( __thiscall* )( void* ) >( this, 138 )( this );

	}

	inline auto is_alive( ) {

		return m_utils.get_v_func< bool( __thiscall* )( void* ) >( this, 155 )( this );

	}

	inline auto is_player( ) {

		return m_utils.get_v_func< bool( __thiscall* )( void* ) >( this, 157 )( this );

	}

	inline auto& get_origin( ) {

		static auto offset = m_netvars.m_offsets[ m_hash.get( "DT_BaseEntity->m_vecOrigin" ) ];

		return *reinterpret_cast< vector_3d* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto& get_simulation_time( ) {

		static auto offset = m_netvars.m_offsets[ m_hash.get( "DT_BaseEntity->m_flSimulationTime" ) ];

		return *reinterpret_cast< float* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto& get_team( ) {

		static auto offset = m_netvars.m_offsets[ m_hash.get( "DT_BaseEntity->m_iTeamNum" ) ];

		return *reinterpret_cast< int* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto calc_absolute_velocity( ) { // grr

		static auto function = m_modules.m_client_dll.get_address( "C_BaseEntity::CalcAbsoluteVelocity" ).as< void( __thiscall* )( void* ) >( );

		return function( this );

	}

	inline auto& get_abs_velocity( ) {

		static auto offset = m_modules.m_client_dll.get_address( "C_BaseEntity->m_vecAbsVelocity" ).add( 0x4 ).to< std::size_t >( );

		calc_absolute_velocity( );

		return *reinterpret_cast< vector_3d* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	// note - seems to be crashing, but base version also crashes for me so i'll leave it to sean to fix
	// ...
	// sean: doesnt crash for me?
	inline auto get_anim_overlay( int i ) {

		static auto offset = m_modules.m_client_dll.get_address( "C_BaseEntity->m_nAnimOverlay" ).add( 0x2 ).to< std::size_t >( );

		return reinterpret_cast< animation_layer* >( i * 0x38 + *reinterpret_cast< std::size_t* >( reinterpret_cast< std::size_t >( this ) + offset ) );

	}

	inline auto get_ground_entity( ) {

		static auto function = m_modules.m_client_dll.get_address( "C_BaseEntity::GetGroundEntity" ).as< base_entity* ( __thiscall* )( void* ) >( );

		return function( this );

	}

	inline auto invalidate_physics_recursive( int change_flags ) {

		static auto function = m_modules.m_client_dll.get_address( "C_BaseEntity::InvalidatePhysicsRecursive" ).as< void( __thiscall* )( void*, int ) >( );

		return function( this, change_flags );

	}

	inline auto set_abs_angles( const q_angle& angles ) {

		static auto function = m_modules.m_client_dll.get_address( "C_BaseEntity::SetAbsAngles" ).as< void( __thiscall* )( void*, const q_angle& ) >( );

		return function( this, angles );

	}

	inline auto physics_run_think( int think_method = 0 ) {

		static auto function = m_modules.m_client_dll.get_address( "C_BaseEntity::PhysicsRunThink" ).as< bool( __thiscall* )( void*, int ) >( );

		return function( this, think_method );

	}

	inline auto check_has_think_function( bool is_thinking = false ) {

		static auto function = m_modules.m_client_dll.get_address( "C_BaseEntity::CheckHasThinkFunction" ).as< void( __thiscall* )( void*, bool ) >( );

		return function( this, is_thinking );

	}

	inline static auto set_prediction_random_seed( const user_cmd* cmd ) {

		static auto prediction_random_seed = m_modules.m_client_dll.get_address( "C_BaseEntity->m_nPredictionRandomSeed" ).add( 0x4 ).to< int* >( );

		if ( !cmd ) {

			*prediction_random_seed = -1;
			return;

		}

		*prediction_random_seed = cmd->m_random_seed;

	}

	inline static auto set_prediction_player( base_player* player ) {

		static auto prediction_player = m_modules.m_client_dll.get_address( "C_BaseEntity->m_pPredictionPlayer" ).add( 0x5 ).to< base_player* >( );

		prediction_player = player;

	}

};
```

`valve/client/base_player.h`:

```h
#pragma once

#include "base_combat_character.h"

struct base_view_model;

struct base_player : base_combat_character {

	inline auto& get_health( ) {

		static auto offset = m_netvars.m_offsets[ m_hash.get( "DT_BasePlayer->m_iHealth" ) ];

		return *reinterpret_cast< int* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto* get_pose_parameter( ) {

		static auto offset = m_netvars.m_offsets[ m_hash.get( "DT_CSPlayer->m_flPoseParameter" ) ];

		return reinterpret_cast< float* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto& get_sequence( ) {

		static auto offset = m_netvars.m_offsets[ m_hash.get( "DT_BasePlayer->m_nSequence" ) ];

		return *reinterpret_cast< int* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto& get_tick_base( ) {

		static auto offset = m_netvars.m_offsets[ m_hash.get( "DT_BasePlayer->m_nTickBase" ) ];

		return *reinterpret_cast< int* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto& get_next_think_tick( ) {

		static auto offset = m_netvars.m_offsets[ m_hash.get( "DT_BasePlayer->m_nNextThinkTick" ) ];

		return *reinterpret_cast< int* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto& get_current_command( ) {

		static auto offset = m_modules.m_client_dll.get_address( "C_BasePlayer->m_LastCmd" ).add( 0xc ).to< std::size_t >( );

		return *reinterpret_cast< user_cmd** >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto& get_last_command( ) {

		static auto offset = m_modules.m_client_dll.get_address( "C_BasePlayer->m_LastCmd" ).add( 0x2 ).to< std::size_t >( );

		return *reinterpret_cast< user_cmd* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto& get_button_forced( ) {

		static auto offset = m_modules.m_client_dll.get_address( "C_BasePlayer->m_afButtonForced" ).add( 0x2 ).to< std::size_t >( );

		return *reinterpret_cast< int* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto& get_button_disabled( ) {

		static auto offset = m_modules.m_client_dll.get_address( "C_BasePlayer->m_afButtonForced" ).add( 0x2 ).to( ).sub< std::size_t >( 0x4 );

		return *reinterpret_cast< int* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto& get_button_last( ) {

		static auto offset = m_modules.m_client_dll.get_address( "C_BasePlayer->m_afButtonLast" ).add( 0x4 ).to< std::size_t >( );

		return *reinterpret_cast< int* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto& get_button_pressed( ) {

		static auto offset = m_modules.m_client_dll.get_address( "C_BasePlayer->m_afButtonLast" ).add( 0x4 ).to( ).add< std::size_t >( 0x4 );

		return *reinterpret_cast< int* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto& get_button_released( ) {

		static auto offset = m_modules.m_client_dll.get_address( "C_BasePlayer->m_afButtonLast" ).add( 0x4 ).to( ).add< std::size_t >( 0x8 );

		return *reinterpret_cast< int* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto& get_buttons( ) {

		static auto offset = m_modules.m_client_dll.get_address( "C_BasePlayer->m_afButtonLast" ).add( 0x4 ).to( ).add< std::size_t >( 0xc );

		return *reinterpret_cast< int* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto& get_impulse( ) {

		static auto offset = m_modules.m_client_dll.get_address( "C_BasePlayer->m_afButtonLast" ).add( 0x4 ).to( ).add< std::size_t >( 0x10 );

		return *reinterpret_cast< int* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto create_move( float input_sample_time, user_cmd* cmd ) {

		return m_utils.get_v_func< bool( __thiscall* )( void*, float, user_cmd* ) >( this, 288 )( this, input_sample_time, cmd );

	}

	inline auto pre_think( ) {

		return m_utils.get_v_func< void( __thiscall* )( void* ) >( this, 317 )( this );

	}

	inline auto post_think( ) {

		return m_utils.get_v_func< void( __thiscall* )( void* ) >( this, 318 )( this );

	}

	inline auto select_item( const char* str, int sub_type ) {

		return m_utils.get_v_func< void( __thiscall* )( void*, const char*, int ) >( this, 329 )( this, str, sub_type );

	}

	inline auto set_local_view_angles( const q_angle& view_angles ) {

		return m_utils.get_v_func< void( __thiscall* )( void*, const q_angle& ) >( this, 372 )( this, view_angles );

	}

	inline auto is_local_player( ) {

		static auto function = m_modules.m_client_dll.get_address( "C_BasePlayer::IsLocalPlayer" ).as< bool( __thiscall* )( void* ) >( );

		return function( this );

	}

	inline auto get_view_model( int index ) {

		static auto function = m_modules.m_client_dll.get_address( "C_BasePlayer::GetViewModel" ).as< base_view_model* ( __thiscall* )( void*, int ) >( );

		return function( this, index );

	}

	inline auto util_player_by_index( int entindex ) {

		static auto function = m_modules.m_server_dll.get_address( "UTIL_PlayerByIndex" ).as< base_player* ( __thiscall* )( int ) >( );

		return function( entindex );

	}

	inline auto update_button_state( int user_cmd_button_mask ) {

		get_button_last( ) = get_buttons( );

		get_buttons( ) = user_cmd_button_mask;
		int buttons_changed = get_button_last( ) ^ get_buttons( );

		get_button_pressed( ) = buttons_changed & get_buttons( );
		get_button_released( ) = buttons_changed & ( ~get_buttons( ) );

	}

};
```

`valve/client/client.h`:

```h
#pragma once

#include "animation_layer.h"
#include "base_entity.h"
#include "base_combat_character.h"
#include "base_player.h"
#include "base_animating.h"
#include "client_input.h"
#include "cs_player.h"
#include "net_graph_panel.h"
#include "prediction.h"
#include "weapon_cs_base.h"
```

`valve/client/client_input.h`:

```h
#pragma once

struct client_input {

	char _pad0[ 0xad ];
	bool m_camera_in_third_person;
	char _pad1[ 0x2 ];
	vector_3d m_camera_offset;
	char _pad2[ 0x48 ];
	int m_cam_command;

};
```

`valve/client/cs_player.h`:

```h
#pragma once

#include "base_animating.h"

struct csgo_player_anim_state;

struct cs_player : base_animating {

	inline auto& is_player_ghost( ) {

		static auto offset = m_netvars.m_offsets[ m_hash.get( "DT_CSPlayer->m_bIsPlayerGhost" ) ];

		return *reinterpret_cast< bool* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto& get_third_person_recoil( ) {

		static auto offset = m_netvars.m_offsets[ m_hash.get( "DT_CSPlayer->m_flThirdpersonRecoil" ) ];

		return *reinterpret_cast< float* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto& get_duck_amount( ) {

		static auto offset = m_netvars.m_offsets[ m_hash.get( "DT_CSPlayer->m_flDuckAmount" ) ];

		return *reinterpret_cast< float* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto& get_playback_rate( ) {

		static auto offset = m_netvars.m_offsets[ m_hash.get( "DT_CSPlayer->m_flPlaybackRate" ) ];

		return *reinterpret_cast< float* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto& get_cycle( ) {

		static auto offset = m_netvars.m_offsets[ m_hash.get( "DT_CSPlayer->m_flCycle" ) ];

		return *reinterpret_cast< float* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto& get_lower_body_yaw_target( ) {

		static auto offset = m_netvars.m_offsets[ m_hash.get( "DT_CSPlayer->m_flLowerBodyYawTarget" ) ];

		return *reinterpret_cast< float* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto& get_eye_angles( ) {

		static auto offset = m_netvars.m_offsets[ m_hash.get( "DT_CSPlayer->m_angEyeAngles" ) ];

		return *reinterpret_cast< q_angle* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto& get_killed_by_taser( ) {

		static auto offset = m_netvars.m_offsets[ m_hash.get( "DT_CSPlayer->m_bKilledByTaser" ) ];

		return *reinterpret_cast< bool* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto get_player_anim_state_csgo( ) {

		static auto offset = m_modules.m_client_dll.get_address( "C_CSPlayer->m_PlayerAnimStateCSGO" ).add( 0x2 ).to< std::size_t >( );

		return *reinterpret_cast< csgo_player_anim_state** >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto& get_use_new_animstate( ) {

		static auto offset = m_modules.m_client_dll.get_address( "C_CSPlayer->m_bUseNewAnimstate" ).add( 0x2 ).to< std::size_t >( );

		return *reinterpret_cast< bool* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto eye_angles( ) {

		return m_utils.get_v_func< q_angle& ( __thiscall* )( void* ) >( this, 169 )( this );

	}

	inline auto handle_taser_animation( ) {

		static auto function = m_modules.m_client_dll.get_address( "C_CSPlayer::HandleTaserAnimation" ).as< void( __thiscall* )( void* ) >( );

		return function( this );

	}

};
```

`valve/client/net_graph_panel.h`:

```h
#pragma once

struct net_graph_panel {

	char _pad0[ 0x131b8 ];
	float m_frame_rate;

};
```

`valve/client/prediction.h`:

```h
#pragma once

#include "../shared/user_cmd.h"

struct base_player;
struct move_helper;
struct move_data;

struct prediction {

	inline auto check_moving_ground( base_player* player, double frametime ) {

		return m_utils.get_v_func< void( __thiscall* )( void*, base_player*, double ) >( this, 18 )( this, player, frametime );

	}

	inline auto setup_move( base_player* player, user_cmd* cmd, move_helper* helper, move_data* move ) {

		return m_utils.get_v_func< void( __thiscall* )( void*, base_player*, user_cmd*, move_helper*, move_data* ) >( this, 20 )( this, player, cmd, helper, move );

	}

	inline auto finish_move( base_player* player, user_cmd* cmd, move_data* move ) {

		return m_utils.get_v_func< void( __thiscall* )( void*, base_player*, user_cmd*, move_data* ) >( this, 21 )( this, player, cmd, move );

	}

	inline auto start_command( base_player* player, user_cmd* cmd ) {

		player->get_current_command( ) = cmd;
		player->get_last_command( ) = *cmd;
		base_entity::set_prediction_random_seed( cmd );
		base_entity::set_prediction_player( player );

	}

	inline auto run_pre_think( base_player* player ) {

		if ( !player->physics_run_think( ) )
			return;

		player->pre_think( );

	}

	inline auto run_think( base_player* player, double frametime ) {

		int thinktick = player->get_next_think_tick( );

		if ( thinktick <= 0 || thinktick > player->get_tick_base( ) )
			return;

		{ /* C_BaseEntity::SetNextThink */
			player->get_next_think_tick( ) = -1;

			player->check_has_think_function( false );
		}

		player->think( );

	}

	inline auto run_post_think( base_player* player ) {

		player->post_think( );

	}

	inline auto finish_command( base_player* player ) {

		player->get_current_command( ) = 0;
		base_entity::set_prediction_random_seed( 0 );
		base_entity::set_prediction_player( 0 );

	}

	char _pad0[ 0xa ]; // 0
	bool m_engine_paused; // 10

};
```

`valve/client/weapon_cs_base.h`:

```h
#pragma once

#include "base_entity.h"

struct cs_weapon_info {

	char _pad0[ 0x14 ]; // 0
	int m_max_clip1; // 20
	char _pad1[ 0x70 ]; // 24
	const char* m_hud_name; // 136
	const char* m_weapon_name; // 140
	char _pad2[ 0x38 ]; // 144
	int m_weapon_type; // 200

};

struct weapon_cs_base : base_entity {

	inline auto& get_ammo( ) {

		static auto offset = m_netvars.m_offsets[ m_hash.get( "DT_WeaponCSBase->m_iClip1" ) ];

		return *reinterpret_cast< int* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto& get_view_model_index( ) {

		static auto offset = m_netvars.m_offsets[ m_hash.get( "DT_WeaponCSBase->m_nViewModelIndex" ) ];

		return *reinterpret_cast< int* >( reinterpret_cast< std::size_t >( this ) + offset );

	}

	inline auto get_max_speed( ) {

		return m_utils.get_v_func< float( __thiscall* )( void* ) >( this, 441 )( this );

	}

	inline auto get_cs_wpn_data( ) {

		return m_utils.get_v_func< cs_weapon_info* ( __thiscall* )( void* ) >( this, 460 )( this ); // 8B 81 ? ? ? ? 85 C0 0F 84 ? ? ? ? C3

	}

};
```

`valve/client_class.h`:

```h
#pragma once

#include "dt_recv.h"

using create_client_class = void* ( __cdecl* )( int index, int serial );
using create_event = void* ( __cdecl* )( );

struct client_class {

	create_client_class m_create;
	create_event m_create_event;
	char* m_network_name;
	recv_table* m_recv_table;
	client_class* m_next;
	int m_class_id;

};
```

`valve/client_entity_list.h`:

```h
#pragma once

struct client_entity_list {

	inline auto get_client_entity( int entity_number ) {

		return m_utils.get_v_func< void* ( __thiscall* )( void*, int ) >( this, 3 )( this, entity_number );

	}

	inline auto get_client_entity_from_handle( std::size_t entity ) {

		return m_utils.get_v_func< void* ( __thiscall* )( void*, std::size_t ) >( this, 4 )( this, entity );

	}

	template< class t > inline t get( int entity_number ) {

		return ( t )get_client_entity( entity_number );

	}

	template< class t > inline t get( std::size_t entity ) {

		return ( t )get_client_entity_from_handle( entity );

	}

};
```

`valve/client_networkable.h`:

```h
#pragma once

struct client_networkable {

	inline auto is_dormant( ) {

		return m_utils.get_v_func< bool( __thiscall* )( void* ) >( this, 9 )( this );

	}

	inline auto get_index( ) {

		return m_utils.get_v_func< int( __thiscall* )( void* ) >( this, 10 )( this );

	}

};
```

`valve/client_renderable.h`:

```h
#pragma once

struct client_renderable {

	inline auto get_render_bounds( vector_3d& mins, vector_3d& maxs ) {

		return m_utils.get_v_func< void( __thiscall* )( void*, vector_3d&, vector_3d& ) >( this, 17 )( this, mins, maxs );

	}

};
```

`valve/data_cache/data_cache.h`:

```h
#pragma once

#include "mdl_cache.h"
```

`valve/data_cache/mdl_cache.h`:

```h
#pragma once

struct mdl_cache {

	inline auto begin_lock( ) {

		return m_utils.get_v_func< void( __thiscall* )( void* ) >( this, 33 )( this );

	}

	inline auto end_lock( ) {

		return m_utils.get_v_func< void( __thiscall* )( void* ) >( this, 34 )( this );

	}

};
```

`valve/dt_common.h`:

```h
#pragma once

enum send_prop_type {

	dpt_int = 0,
	dpt_float,
	dpt_vector,
	dpt_string,
	dpt_array,
	dpt_datatable

};

struct d_variant {

	union {

		float m_float;
		long m_int;
		char* m_string;
		void* m_data;
		float m_vector[ 3 ];
		long long m_int_64;

	};

	send_prop_type m_type;

};
```

`valve/dt_recv.h`:

```h
#pragma once

#include "dt_common.h"

struct recv_table;
struct recv_prop;

struct recv_proxy_data {

	const recv_prop* m_recv_prop;
	d_variant m_value;
	int m_element;
	int m_object_id;

};

using array_length_recv_proxy = void( __cdecl* )( void* ptr, int id, int len );
using recv_var_proxy = void( __cdecl* )( recv_proxy_data* data, void* struct_ptr, void* out );
using data_table_recv_var_proxy = void( __cdecl* )( recv_prop* prop, void** out, void* data, int id );

struct recv_prop {

	char* m_var_name;
	int m_recv_type;
	int m_flags;
	int m_string_buffer_size;
	bool m_inside_array;
	const void* m_extra_data;
	recv_prop* m_array_prop;
	array_length_recv_proxy m_array_length_proxy;
	recv_var_proxy m_proxy_function;
	data_table_recv_var_proxy m_data_table_proxy_function;
	recv_table* m_data_table;
	int m_offset;
	int m_element_stride;
	int m_elements;
	const char* m_parent_array_prop_name;

};

struct recv_table {

	recv_prop* m_props_pointer;
	int m_props;
	void* m_decoder;
	char* m_net_table_name;
	bool m_initialized;
	bool m_in_main_list;

};
```

`valve/engine/client.h`:

```h
#pragma once

struct net_channel;

struct client_state {

	char _pad0[ 0x9c ]; // 0
	net_channel* m_net_channel; // 156
	char _pad1[ 0x4c8c ]; // 160
	int m_lastoutgoingcommand; // 19756
	int m_chokedcommands; // 19760

};
```

`valve/engine/debug_overlay.h`:

```h
#pragma once

#include "../../other/math/vector_3d.h"

struct debug_overlay {

	inline auto screen_position( const vector_3d& point, vector_3d& screen ) {

		return m_utils.get_v_func< int( __thiscall* )( void*, const vector_3d&, vector_3d& ) >( this, 13 )( this, point, screen );

	}

};
```

`valve/engine/engine.h`:

```h
#pragma once

#include "client.h"
#include "debug_overlay.h"
#include "vgui_baseui.h"
```

`valve/engine/vgui_baseui.h`:

```h
#pragma once

struct engine_vgui {

	char _pad0[ 0x48 ];
	void* m_static_transition_panel;

};
```

`valve/engine_vgui.h`:

```h
#pragma once

enum paint_mode {

	paint_uipanels = ( 1 << 0 ),
	paint_ingamepanels = ( 1 << 1 ),

};
```

`valve/global_vars_base.h`:

```h
#pragma once

struct global_vars_base {

	float m_realtime; // 0
	int m_framecount; // 4
	float m_absoluteframetime; // 8
	float m_absoluteframestarttime; // 12
	float m_curtime; // 16
	float m_frametime; // 20
	int m_max_clients; // 24
	int m_tickcount; // 28
	float m_interval_per_tick; // 32
	float m_interpolation_amount; // 36
	int m_sim_ticks_this_frame; // 40
	int m_network_protocol; // 44
	void* m_save_data; // 48
	bool m_client; // 52
	bool m_remote_client; // 53
	int m_time_stamp_networking_base; // 54
	int m_time_stamp_randomize_window; // 58

};
```

`valve/interfaces/interfaces.cpp`:

```cpp
#include "interfaces.h"

bool interfaces::setup( ) {

	m_client = get< base_client_dll* >( m_modules.m_client_dll, "VClient" );
	if ( !m_client )
		return false;

	m_surface = get< surface* >( m_modules.m_vguimatsurface_dll, "VGUI_Surface" );
	if ( !m_surface )
		return false;

	m_entity_list = get< client_entity_list* >( m_modules.m_client_dll, "VClientEntityList" );
	if ( !m_entity_list )
		return false;

	m_debug_overlay = get< debug_overlay* >( m_modules.m_engine_dll, "VDebugOverlay" );
	if ( !m_debug_overlay )
		return false;

	m_globals = m_utils.get_v_func( m_client, 11 ).add( 0xa ).get< global_vars_base* >( 2 );
	if ( !m_globals )
		return false;

	m_console.log( "found pointer gpGlobals -> 0x%x", m_globals );

	m_engine = get< engine_client* >( m_modules.m_engine_dll, "VEngineClient" );
	if ( !m_engine )
		return false;

	m_localize = get< localize* >( m_modules.m_localize_dll, "Localize_" );
	if ( !m_localize )
		return false;

	m_mdl_cache = get< mdl_cache* >( m_modules.m_datacache_dll, "MDLCache" );
	if ( !m_mdl_cache )
		return false;

	m_material_system = get< material_system* >( m_modules.m_materialsystem_dll, "VMaterialSystem" );
	if ( !m_material_system )
		return false;

	m_net_graph_panel = m_modules.m_client_dll.get_address( "g_pNetGraphPanel" ).add( 0x2 ).get< net_graph_panel* >( 2 );
	if ( !m_net_graph_panel )
		return false;

	m_console.log( "found pointer g_pNetGraphPanel -> 0x%x", m_net_graph_panel );

	m_client_state = m_utils.get_v_func( m_engine, 12 ).add( 0x10 ).get< client_state* >( 2 );
	if ( !m_client_state )
		return false;

	m_console.log( "found reference to GetBaseLocalClient -> 0x%x", m_client_state );

	m_mem_alloc = *reinterpret_cast< mem_alloc** >( m_pe.export_fn( m_modules.m_tier0.get_module( ), m_hash.get( "g_pMemAlloc" ) ) );
	if ( !m_mem_alloc )
		return false;

	m_console.log( "found pointer g_pMemAlloc -> 0x%x", m_mem_alloc );

	m_game_movement = get< game_movement* >( m_modules.m_client_dll, "GameMovement" );
	if ( !m_game_movement )
		return false;

	m_move_data = m_modules.m_client_dll.get_address( "g_pMoveData" ).add( 0x2 ).get< move_data* >( 2 );
	if ( !m_move_data )
		return false;

	m_console.log( "found pointer g_pMoveData -> 0x%x", m_move_data );

	return true;

}
```

`valve/interfaces/interfaces.h`:

```h
#pragma once

#include <string>

#include "../cdll_int.h"
#include "../vgui/surface.h"
#include "../client_entity_list.h"
#include "../engine/debug_overlay.h"
#include "../global_vars_base.h"
#include "../tier1/interface.h"
#include "../tier1/localize.h"
#include "../data_cache/mdl_cache.h"
#include "../material_system/material_system.h"
#include "../client/net_graph_panel.h"
#include "../engine/client.h"
#include "../tier0/mem_alloc.h"
#include "../shared/game_movement.h"

#include "../../other/hash/hash.h"
#include "../../other/pe/pe.h"
#include "../../other/console/console.h"

struct interfaces {

	bool setup( );

	base_client_dll* m_client;
	surface* m_surface;
	client_entity_list* m_entity_list;
	debug_overlay* m_debug_overlay;
	global_vars_base* m_globals;
	engine_client* m_engine;
	localize* m_localize;
	mdl_cache* m_mdl_cache;
	material_system* m_material_system;
	net_graph_panel* m_net_graph_panel;
	client_state* m_client_state;
	mem_alloc* m_mem_alloc;
	game_movement* m_game_movement;
	move_data* m_move_data;

private:

	template< class t > inline t get( module_info the_module, std::string_view interface_name ) {

		static auto fn_hash = m_hash.get( "CreateInterface" );

		auto create_interface = m_pe.export_fn( the_module.get_module( ), fn_hash );
		if ( !create_interface )
			return t( );

		auto create_interface_fn = address( create_interface ).add( 0x4 ).relative( );
		if ( !create_interface_fn )
			return t( );

		auto interface_node = create_interface_fn.add( 0x6 ).get< interface_reg* >( 2 );

		while ( interface_node != nullptr ) {

			std::string name = interface_node->m_name;

			if ( !name.compare( 0u, interface_name.length( ), interface_name ) 
				&& std::atoi( interface_node->m_name + interface_name.length( ) ) > 0 ) {

				auto interface_address = interface_node->m_create_fn( );
				if ( !interface_address )
					return t( );

				m_console.log( "found interface %s -> 0x%x", interface_node->m_name, interface_address );

				return ( t )interface_address;

			}

			interface_node = interface_node->m_next;

		}

		return t( );

	}

};

inline interfaces m_interfaces;
```

`valve/material_system/material.h`:

```h
#pragma once

struct material {

	inline auto set_material_var_flag( int flag, bool on ) {

		return m_utils.get_v_func< void( __thiscall* )( void*, int, bool ) >( this, 29 )( this, flag, on );

	}

};
```

`valve/material_system/material_system.h`:

```h
#pragma once

#include "material.h"

struct material_system {

	inline auto find_material( char const* material_name, const char* texture_group_name, bool complain = true, const char* complain_prefix = 0 ) {

		return m_utils.get_v_func< material* ( __thiscall* )( void*, char const*, char const*, bool, char const* ) >( this, 84 )( this, material_name, texture_group_name, complain, complain_prefix );

	}

};
```

`valve/mathlib/mathlib.h`:

```h
#pragma once

#include "mathlib_base.h"

#include "../../other/math/vector_3d.h"

#include <algorithm>

struct mathlib {

	inline float simple_spline( float value ) {

		float squared_value = value * value;

		return ( 3 * squared_value - 2 * squared_value * value );

	}

	inline float simple_spline_remap_val_clamped( float val, float a, float b, float c, float d ) {

		if ( a == b )
			return val >= b ? d : c;

		float clamped_value = ( val - a ) / ( b - a );
		clamped_value = std::clamp( clamped_value, 0.f, 1.f );
		return c + ( d - c ) * simple_spline( clamped_value );

	}

	inline float lerp( float percent, float a, float b ) {

		return a + ( b - a ) * percent;

	};

	inline vector_3d approach( vector_3d target, vector_3d value, float speed ) {

		vector_3d diff = ( target - value );

		float delta = diff.length( );
		if ( delta > speed )
			value += diff.normalized( ) * speed;
		else if ( delta < -speed )
			value -= diff.normalized( ) * speed;
		else
			value = target;

		return value;

	}

	inline float approach( float target, float value, float speed ) {

		float delta = target - value;

		if ( delta > speed )
			value += speed;
		else if ( delta < -speed )
			value -= speed;
		else
			value = target;

		return value;

	}

};

inline mathlib m_mathlib;
```

`valve/mathlib/mathlib_base.h`:

```h
#pragma once

#include <corecrt_math.h>

struct mathlib_base {

	inline float anglemod( float a ) {

		// c casting :)
		a = ( 360.f / 65536 ) * ( ( int )( a * ( 65536.f / 360.f ) ) & 65535 );

		// references? lol cmon valve
		return a;

	}

	inline float angle_normalize( float angle ) {

		angle = std::fmodf( angle, 360.f );

		if ( angle > 180.f )
			angle -= 360.f;

		if ( angle < -180.f )
			angle += 360.f;

		return angle;

	}

	inline float approach_angle( float target, float value, float speed ) {

		target = anglemod( target );
		value = anglemod( value );

		float delta = target - value;

		if ( speed < 0 )
			speed = -speed;

		if ( delta < -180 )
			delta += 360;
		else if ( delta > 180 )
			delta -= 360;

		if ( delta > speed )
			value += speed;
		else if ( delta < -speed )
			value -= speed;
		else
			value = target;

		return value;
	}

	inline float angle_diff( float dest, float source ) {

		float delta = std::fmodf( dest - source, 360.f );

		if ( dest > source ) {

			if ( delta >= 180 )
				delta -= 360;

		} else {

			if ( delta <= -180 )
				delta += 360;

		}

		return delta;

	}

	inline float bias( float x, float bias_amt ) {

		static float last_amt = -1;
		static float last_exponent = 0;

		if ( last_amt != bias_amt ) 
			last_exponent = std::log( bias_amt ) * -1.4427f;

		return std::pow( x, last_exponent );

	}

};

inline mathlib_base m_mathlib_base;
```

`valve/modules/modules.cpp`:

```cpp
#include "modules.h"

bool modules::setup( ) {

	if ( !get( ) )
		return false;

	get_addresses( );

	if ( !got_addresses( ) )
		return false;

	return true;

}

bool modules::get( ) {

	m_client_dll = m_pe.get( "client.dll" );
	if ( !m_client_dll.get_module( ) )
		return false;

	m_engine_dll = m_pe.get( "engine.dll" );
	if ( !m_engine_dll.get_module( ) )
		return false;

	m_server_dll = m_pe.get( "server.dll" );
	if ( !m_server_dll.get_module( ) )
		return false;

	m_gameoverlayrenderer_dll = m_pe.get( "gameoverlayrenderer.dll" );
	if ( !m_gameoverlayrenderer_dll.get_module( ) )
		return false;

	m_vgui2_dll = m_pe.get( "vgui2.dll" );
	if ( !m_vgui2_dll.get_module( ) )
		return false;

	m_vguimatsurface_dll = m_pe.get( "vguimatsurface.dll" );
	if ( !m_vguimatsurface_dll.get_module( ) )
		return false;

	m_studiorender_dll = m_pe.get( "studiorender.dll" );
	if ( !m_studiorender_dll.get_module( ) )
		return false;

	m_localize_dll = m_pe.get( "localize.dll" );
	if ( !m_localize_dll.get_module( ) )
		return false;

	m_datacache_dll = m_pe.get( "datacache.dll" );
	if ( !m_datacache_dll.get_module( ) )
		return false;

	m_materialsystem_dll = m_pe.get( "materialsystem.dll" );
	if ( !m_materialsystem_dll.get_module( ) )
		return false;

	m_tier0 = m_pe.get( "tier0.dll" );
	if ( !m_tier0.get_module( ) )
		return false;

	return true;

}

void modules::get_addresses( ) {

	m_client_dll.add_address( "g_pNetGraphPanel", "89 1D ? ? ? ? 8B C3" );
	m_client_dll.add_address( "g_pMoveData", "FF 35 ? ? ? ? 56 85 DB" );

	m_client_dll.add_address( "C_BaseAnimating::LookupBone", "E8 ? ? ? ? 89 44 24 5C", true );
	m_client_dll.add_address( "C_BaseAnimating::GetBonePosition", "E8 ? ? ? ? 8D 14 24", true );
	m_client_dll.add_address( "C_BaseAnimating::GetModelPtr", "E8 ? ? ? ? 8B 55 38", true );
	m_client_dll.add_address( "C_BaseAnimating::GetFirstSequenceAnimTag", "E8 ? ? ? ? F3 0F 11 86 ? ? ? ? 0F 57 DB", true );
	m_client_dll.add_address( "C_BaseAnimating::LookupPoseParameter", "E8 ? ? ? ? 85 C0 79 08", true );
	m_client_dll.add_address( "C_BaseAnimating::GetSequenceActivity", "E8 ? ? ? ? 33 C9 3B F0", true );
	m_client_dll.add_address( "Studio_SetPoseParameter", "E8 ? ? ? ? 0F 28 D8 83 C4 04", true );

	m_client_dll.add_address( "C_BaseEntity->m_vecAbsVelocity", "F3 0F 10 A6 ? ? ? ? F3 0F 11 64 24 ?" );
	m_client_dll.add_address( "C_BaseEntity->m_nAnimOverlay", "8B 80 ? ? ? ? 03 C1 74 15" );
	m_client_dll.add_address( "C_BaseEntity->m_nPredictionRandomSeed", "8B 47 40 A3 ? ? ? ?" );
	m_client_dll.add_address( "C_BaseEntity->m_pPredictionPlayer", "0F 5B C0 89 35 ? ? ? ?" );
	m_client_dll.add_address( "C_BaseEntity::GetGroundEntity", "E8 ? ? ? ? 8B 4C 24 14 85 C0", true );
	m_client_dll.add_address( "C_BaseEntity::InvalidatePhysicsRecursive", "E8 ? ? ? ? 89 5E 18", true );
	m_client_dll.add_address( "C_BaseEntity::SetAbsAngles", "E8 ? ? ? ? 53 8D 45 F0", true );
	m_client_dll.add_address( "C_BaseEntity::CalcAbsoluteVelocity", "E8 ? ? ? ? 83 7B 30 00", true );
	m_client_dll.add_address( "C_BaseEntity::PhysicsRunThink", "E8 ? ? ? ? 84 C0 0F 84 ? ? ? ? F3 0F 10 86 ? ? ? ?", true );
	m_client_dll.add_address( "C_BaseEntity::CheckHasThinkFunction", "E8 ? ? ? ? EB 11 8B 86 ? ? ? ?", true );

	m_client_dll.add_address( "C_BasePlayer->m_LastCmd", "8D 8E ? ? ? ? 89 5C 24 3C" );
	m_client_dll.add_address( "C_BasePlayer->m_afButtonForced", "8B 86 ? ? ? ? 09 47 30" );
	m_client_dll.add_address( "C_BasePlayer->m_afButtonLast", "33 CA 89 86 ? ? ? ?" );
	m_client_dll.add_address( "C_BasePlayer::GetViewModel", "E8 ? ? ? ? 8B F8 8B 47 04", true );
	m_client_dll.add_address( "C_BasePlayer::IsLocalPlayer", "56 8B F1 85 F6 74 16" );

	m_client_dll.add_address( "C_CSPlayer->m_PlayerAnimStateCSGO", "8B 8E ? ? ? ? EB 39" );
	m_client_dll.add_address( "C_CSPlayer->m_bUseNewAnimstate", "80 BE ? ? ? ? ? 74 36 8B 06" );
	m_client_dll.add_address( "C_CSPlayer::UpdateClientSideAnimation", "55 8B EC 51 56 8B F1 80 BE ? ? ? ? ? 74 36" );
	m_client_dll.add_address( "C_CSPlayer::HandleTaserAnimation", "E8 ? ? ? ? 8B 06 8B CE 8B 80 ? ? ? ? FF D0 84 C0 0F 84 ? ? ? ?", true );

	m_client_dll.add_address( "CHLClient::LevelShutdown", "55 8B EC 83 E4 F8 83 EC 30 C6 05 ? ? ? ? ?" );

	m_client_dll.add_address( "ClientModeShared::CreateMove", "55 8B EC 8B 0D ? ? ? ? 85 C9 75 06" );
	m_client_dll.add_address( "ClientModeShared::GetViewModelFOV", "55 8B EC 8B 0D ? ? ? ? 83 EC 08 57" );

	m_client_dll.add_address( "C_WeaponCSBase::DrawCrosshair", "55 8B EC 83 E4 F0 83 EC 78 56 8B F1 8B 0D ? ? ? ?" );

	m_client_dll.add_address( "CCSGOPlayerAnimState::Update", "E8 ? ? ? ? E9 ? ? ? ? 83 BE ? ? ? ? ?", true );
	m_client_dll.add_address( "CCSGOPlayerAnimState::ModifyEyePosition", "E8 ? ? ? ? 8B 06 8B CE FF 90 ? ? ? ? 85 C0 74 50", true );
	m_client_dll.add_address( "CCSGOPlayerAnimState::DoProceduralFootPlant", "E8 ? ? ? ? F6 86 ? ? ? ? ? 0F 84 ? ? ? ?", true );
	m_client_dll.add_address( "CCSGOPlayerAnimState::SetUpVelocity", "55 8B EC 83 E4 F8 83 EC 30 56 57 8B 3D ? ? ? ?" );
	m_client_dll.add_address( "CCSGOPlayerAnimState::SetUpMovement", "E8 ? ? ? ? 8B CF E8 ? ? ? ? 8B CF E8 ? ? ? ? 8B 47 60", true );
	m_client_dll.add_address( "CCSGOPlayerAnimState::SetUpAimMatrix", "55 8B EC 81 EC ? ? ? ? 53 56 57 8B 3D ? ? ? ?" );
	m_client_dll.add_address( "CCSGOPlayerAnimState::SetUpWeaponAction", "55 8B EC 51 53 56 57 8B F9 8B 77 60" );
	m_client_dll.add_address( "CCSGOPlayerAnimState::SetUpMovement", "E8 ? ? ? ? 8B CF E8 ? ? ? ? 8B CF E8 ? ? ? ? 8B 47 60", true );
	m_client_dll.add_address( "CCSGOPlayerAnimState::SetUpAliveloop", "E8 ? ? ? ? 8B CF E8 ? ? ? ? 8B 47 60", true );
	m_client_dll.add_address( "CCSGOPlayerAnimState::SetUpWholeBodyAction", "E8 ? ? ? ? 8B 47 60 83 B8 ? ? ? ? ?", true );
	m_client_dll.add_address( "CCSGOPlayerAnimState::SetUpFlinch", "E8 ? ? ? ? 8B CF E8 ? ? ? ? 33 C0", true );
	m_client_dll.add_address( "CCSGOPlayerAnimState::SetUpLean", "E8 ? ? ? ? 33 C0 89 44 24 0C", true );
	m_client_dll.add_address( "CCSGOPlayerAnimState::CacheSequences", "E8 ? ? ? ? 84 C0 0F 84 ? ? ? ? 8B 77 60", true );
	m_client_dll.add_address( "CCSGOPlayerAnimState::IncrementLayerCycle", "E8 ? ? ? ? FF 76 60 F3 0F 10 54 24 ?", true );
	m_client_dll.add_address( "CCSGOPlayerAnimState::IncrementLayerWeight", "E8 ? ? ? ? 8B 5F 60 83 BB ? ? ? ? ?", true );

	m_client_dll.add_address( "CStudioHdr::pSeqdesc", "E8 ? ? ? ? 03 40 04", true );

	m_client_dll.add_address( "CInput::CAM_Think", "55 8B EC 83 E4 F8 81 EC ? ? ? ? 56 8B F1 8B 0D ? ? ? ? 57 85 C9" );
	m_client_dll.add_address( "CInput::CAM_ToThirdPerson", "55 8B EC 83 EC 0C 8D 55 F4" );

	m_client_dll.add_address( "C_BaseViewModel::UpdateAllViewmodelAddons", "E8 ? ? ? ? 8B 16 8B CE 6A 20", true );
	m_client_dll.add_address( "C_BaseViewModel::RemoveViewmodelArmModels", "E8 ? ? ? ? 46 83 FE 03 7C E7 85 DB", true );
	m_client_dll.add_address( "C_BaseViewModel::RemoveViewmodelLabel", "E8 ? ? ? ? 8B CB E8 ? ? ? ? 8B CB E8 ? ? ? ? 5F", true );
	m_client_dll.add_address( "C_BaseViewModel::RemoveViewmodelStatTrak", "E8 ? ? ? ? 56 FF 74 24 10", true );
	m_client_dll.add_address( "C_BaseViewModel::RemoveViewmodelStickers", "E8 ? ? ? ? 43 83 FB 03 7C CC", true );

	m_client_dll.add_address( "CPrediction::RunCommand", "55 8B EC 83 E4 C0 83 EC 34 53 56 8B 75 08" );

	m_engine_dll.add_address( "CEngineVGui::Paint", "55 8B EC 83 EC 40 53 8B D9 8B 0D ? ? ? ? 89 5D F8" );

	m_engine_dll.add_address( "CL_SendMove", "E8 ? ? ? ? 84 DB 0F 84 ? ? ? ? 8B 8F ? ? ? ?", true );

	m_engine_dll.add_address( "CCLCMsg_Move::set_data", "E8 ? ? ? ? 8D 7E 18", true );
	m_engine_dll.add_address( "CCLCMsg_Move::Deconstuctor", "E8 ? ? ? ? 5F 5E 5B 8B E5 5D C3 CC CC CC CC CC CC CC CC CC CC CC CC CC 55 8B EC 81 EC ? ? ? ?", true );

	m_vguimatsurface_dll.add_address( "CMatSystemSurface::StartDrawing", "55 8B EC 83 E4 C0 83 EC 38" );
	m_vguimatsurface_dll.add_address( "CMatSystemSurface::FinishDrawing", "8B 0D ? ? ? ? 56 C6 05 ? ? ? ? ?" );
	m_vguimatsurface_dll.add_address( "CMatSystemSurface::LockCursor", "80 3D ? ? ? ? ? 8B 91 ? ? ? ? 8B 0D ? ? ? ? C6 05 ? ? ? ? ? 8B 01 74 0B FF 35 ? ? ? ? 52 FF 50 34 C3 6A 00 52 FF 50 34 C3 55" );

	m_vgui2_dll.add_address( "CSchemeManager::ReloadSchemes", "55 8B EC 83 EC 08 53 56 8B F1 6A 00" );

	m_studiorender_dll.add_address( "CStudioRenderContext::DrawModel", "55 8B EC 83 E4 F8 83 EC 54" );

	m_gameoverlayrenderer_dll.add_address( "GameOverlayRenderer::HookFunc", "55 8B EC 51 8B 45 10 C7" );
	m_gameoverlayrenderer_dll.add_address( "GameOverlayRenderer::UnhookFunc", "E8 ? ? ? ? 83 C4 08 FF 15 ? ? ? ?", true );

	m_server_dll.add_address( "CBaseAnimating::DrawServerHitboxes", "E8 ? ? ? ? F6 83 ? ? ? ? ? 0F 84 ? ? ? ? 33 FF", true );
	m_server_dll.add_address( "UTIL_PlayerByIndex", "85 C9 7E 2A A1 ? ? ? ?" );
	m_server_dll.add_address( "CCSGOPlayerAnimState::SetUpVelocity", "55 8B EC 83 E4 F8 83 EC 28 56 57 8B 3D ? ? ? ? 8B F1 8B CF" );

}

bool modules::got_addresses( ) {

	if ( !m_client_dll.valid_addresses( ) )
		return false;

	if ( !m_engine_dll.valid_addresses( ) )
		return false;

	if ( !m_server_dll.valid_addresses( ) )
		return false;

	if ( !m_gameoverlayrenderer_dll.valid_addresses( ) )
		return false;

	if ( !m_vgui2_dll.valid_addresses( ) )
		return false;

	if ( !m_vguimatsurface_dll.valid_addresses( ) )
		return false;

	if ( !m_studiorender_dll.valid_addresses( ) )
		return false;

	if ( !m_localize_dll.valid_addresses( ) )
		return false;

	if ( !m_datacache_dll.valid_addresses( ) )
		return false;

	if ( !m_materialsystem_dll.valid_addresses( ) )
		return false;

	if ( !m_tier0.valid_addresses( ) )
		return false;

	return true;

}
```

`valve/modules/modules.h`:

```h
#pragma once

#include "../../other/pe/pe.h"

struct modules {

	bool setup( );

	loaded_module m_client_dll;
	loaded_module m_engine_dll;
	loaded_module m_server_dll;
	loaded_module m_gameoverlayrenderer_dll;
	loaded_module m_vgui2_dll;
	loaded_module m_vguimatsurface_dll;
	loaded_module m_studiorender_dll;
	loaded_module m_localize_dll;
	loaded_module m_datacache_dll;
	loaded_module m_materialsystem_dll;
	loaded_module m_tier0;

private:

	bool get( );

	void get_addresses( );

	bool got_addresses( );

};

inline modules m_modules;
```

`valve/net_channel.h`:

```h
#pragma once

struct net_channel {

	inline auto send_net_msg( void* msg, bool force_reliable = false, bool voice = false ) {

		return m_utils.get_v_func< bool( __thiscall* )( void*, void*, bool, bool ) >( this, 40 )( this, msg, force_reliable, voice );

	}

};
```

`valve/netvars/netvars.cpp`:

```cpp
#include "netvars.h"

#include "../interfaces/interfaces.h"

#include "../../other/console/console.h"
#include "../../other/hash/hash.h"

bool netvars::setup( ) {

	auto list = m_interfaces.m_client->get_all_classes( );

	if ( !list )
		return false;

	m_file.open( "netvars.txt", std::ios::out | std::ios::trunc );

	while ( list != nullptr ) {

		store( list->m_recv_table->m_net_table_name, list->m_recv_table );

		list = list->m_next;

	}

	m_file.close( );

	m_console.log( "dumped netvars in CSGO directory" );

	return true;

}

void netvars::store( std::string_view name, recv_table* table, std::size_t offset ) {

	for ( auto i = 0; i < table->m_props; ++i ) {

		recv_prop* prop = &table->m_props_pointer[ i ];
		recv_table* child = prop->m_data_table;

		if ( child && child->m_props > 0 )
			store( name, child, prop->m_offset + offset );

		auto variable = prop->m_var_name;

		std::string netvar = std::string( name.data( ) ) + "->" + variable;
		std::size_t hash = m_hash.get( netvar );

		if ( !m_offsets[ hash ] ) {

			m_offsets[ hash ] = prop->m_offset + offset;

			m_file << netvar << " = 0x" << std::hex << m_offsets[ hash ] << std::endl;

		}

	}

}
```

`valve/netvars/netvars.h`:

```h
#pragma once

#include <cstddef>
#include <string>
#include <unordered_map>
#include <fstream>

#include "../client_class.h"

struct netvars {

	bool setup( );

	void store( std::string_view name, recv_table* table, std::size_t offset = 0 );

	std::unordered_map< std::size_t, std::size_t > m_offsets;

private:

	std::ofstream m_file;

};

inline netvars m_netvars;
```

`valve/shared/base_view_model.h`:

```h
#pragma once

#include "../client/base_animating.h"

struct base_view_model : public base_animating {

	inline auto update_all_viewmodel_addons( ) {

		static auto function = m_modules.m_client_dll.get_address( "C_BaseViewModel::UpdateAllViewmodelAddons" ).as< void( __thiscall* )( void* ) >( );

		return function( this );

	}

	inline auto remove_viewmodel_arm_models( ) {

		static auto function = m_modules.m_client_dll.get_address( "C_BaseViewModel::RemoveViewmodelArmModels" ).as< void( __thiscall* )( void* ) >( );

		return function( this );

	}

	inline auto remove_viewmodel_label( ) {

		static auto function = m_modules.m_client_dll.get_address( "C_BaseViewModel::RemoveViewmodelLabel" ).as< void( __thiscall* )( void* ) >( );

		return function( this );

	}

	inline auto remove_viewmodel_stat_track( ) {

		static auto function = m_modules.m_client_dll.get_address( "C_BaseViewModel::RemoveViewmodelStatTrak" ).as< void( __thiscall* )( void* ) >( );

		return function( this );

	}

	inline auto remove_viewmodel_stickers( ) {

		static auto function = m_modules.m_client_dll.get_address( "C_BaseViewModel::RemoveViewmodelStickers" ).as< void( __thiscall* )( void* ) >( );

		return function( this );

	}

};
```

`valve/shared/csgo_player_anim_state.h`:

```h
#pragma once

struct animstate_pose_param_cache {

	bool m_initialized; // 0
	char _pad0[ 0x3 ]; // 1
	int m_index; // 4
	const char* m_name; // 8

	inline bool init( cs_player* player, const char* pose_param_name ) {

		m_interfaces.m_mdl_cache->begin_lock( );

		m_name = pose_param_name;
		m_index = player->lookup_pose_parameter( pose_param_name );

		if ( m_index != 1 )
			m_initialized = true;

		m_interfaces.m_mdl_cache->end_lock( );

		return m_initialized;

	}

	inline void set_value( cs_player* player, float value ) {

		if ( !m_initialized )
			init( player, m_name );

		if ( m_initialized && player ) {

			m_interfaces.m_mdl_cache->begin_lock( );

			player->set_pose_parameter( m_index, value );

			m_interfaces.m_mdl_cache->end_lock( );

		}

	}

}; // size: 12

struct csgo_player_anim_state {

	inline auto update( float y, float x ) {

		static auto function = m_modules.m_client_dll.get_address( "CCSGOPlayerAnimState::Update" ).as< void( __vectorcall* )( void*, void*, float, float, float, void* ) >( );

		return function( this, nullptr, 0.f, y, x, nullptr );

	}

	inline auto set_up_velocity( ) {

		static auto function = m_modules.m_client_dll.get_address( "CCSGOPlayerAnimState::SetUpVelocity" ).as< void( __thiscall* )( void* ) >( );

		return function( this );

	}

	inline auto set_up_aim_matrix( ) {

		static auto function = m_modules.m_client_dll.get_address( "CCSGOPlayerAnimState::SetUpAimMatrix" ).as< void( __thiscall* )( void* ) >( );

		return function( this );

	}

	inline auto set_up_weapon_action( ) {

		static auto function = m_modules.m_client_dll.get_address( "CCSGOPlayerAnimState::SetUpWeaponAction" ).as< void( __thiscall* )( void* ) >( );

		return function( this );

	}

	inline auto set_up_movement( ) {

		static auto function = m_modules.m_client_dll.get_address( "CCSGOPlayerAnimState::SetUpMovement" ).as< void( __thiscall* )( void* ) >( );

		return function( this );

	}

	inline auto set_up_alive_loop( ) {

		static auto function = m_modules.m_client_dll.get_address( "CCSGOPlayerAnimState::SetUpAliveloop" ).as< void( __thiscall* )( void* ) >( );

		return function( this );

	}

	inline auto set_up_whole_body_action( ) {

		static auto function = m_modules.m_client_dll.get_address( "CCSGOPlayerAnimState::SetUpWholeBodyAction" ).as< void( __thiscall* )( void* ) >( );

		return function( this );

	}

	inline auto set_up_flashed_reaction( ) {

		// to do

	}

	inline auto set_up_flinch( ) {

		static auto function = m_modules.m_client_dll.get_address( "CCSGOPlayerAnimState::SetUpFlinch" ).as< void( __thiscall* )( void* ) >( );

		return function( this );

	}

	inline auto set_up_lean( ) {

		static auto function = m_modules.m_client_dll.get_address( "CCSGOPlayerAnimState::SetUpLean" ).as< void( __thiscall* )( void* ) >( );

		return function( this );

	}

	inline auto cache_sequences( ) {

		static auto function = m_modules.m_client_dll.get_address( "CCSGOPlayerAnimState::CacheSequences" ).as< bool( __thiscall* )( void* ) >( );

		return function( this );

	}

	inline auto increment_layer_cycle( int layer_index, bool allow_loop ) {

		static auto function = m_modules.m_client_dll.get_address( "CCSGOPlayerAnimState::IncrementLayerCycle" ).as< void( __thiscall* )( void*, int, bool ) >( );

		return function( this, layer_index, allow_loop );

	}

	inline auto increment_layer_weight( int layer_index ) {

		static auto function = m_modules.m_client_dll.get_address( "CCSGOPlayerAnimState::IncrementLayerWeight" ).as< void( __thiscall* )( void*, int ) >( );

		return function( this, layer_index );

	}

	char _pad0[ 0x4 ]; // 0
	bool m_first_run_since_init; // 4
	char _pad1[ 0x5b ]; // 5
	cs_player* m_player; // 96
	weapon_cs_base* m_weapon; // 100
	weapon_cs_base* m_weapon_last; // 104
	float m_last_update_time; // 108
	int m_last_update_frame; // 112
	float m_last_update_increment; // 116
	float m_eye_yaw; // 120
	float m_eye_pitch; // 124
	float m_foot_yaw; // 128
	float m_foot_yaw_last; // 132
	float m_move_yaw; // 136
	float m_move_yaw_ideal; // 140
	float m_move_yaw_current_to_ideal; // 144
	float m_time_to_align_lower_body; // 148
	float m_primary_cycle; // 152
	float m_move_weight; // 156
	float m_move_weight_smoothed; // 160
	float m_anim_duck_amount; // 164
	float m_duck_additional; // 168
	float m_recrouch_weight; // 172
	vector_3d m_position_current; // 176
	vector_3d m_position_last; // 188
	vector_3d m_velocity; // 200
	vector_3d m_velocity_normalized; // 212
	vector_3d m_velocity_normalized_non_zero; // 224
	float m_velocity_length_xy; // 236
	float m_velocity_length_z; // 240
	float m_speed_as_portion_of_run_top_speed; // 244
	float m_speed_as_portion_of_walk_top_speed; // 248
	float m_speed_as_portion_of_crouch_top_speed; // 252
	float m_duration_moving; // 256
	float m_duration_still; // 260
	bool m_on_ground; // 264
	bool m_landing; // 265
	char _pad2[ 0x12 ]; // 266
	float m_walk_to_run_transition; // 284
	char _pad3[ 0x4 ]; // 288
	float m_in_air_smooth_value; // 292
	bool m_on_ladder; // 296
	char _pad4[ 0x3 ]; // 297
	float m_ladder_weight; // 300
	char _pad5[ 0x2c ]; // 304
	vector_3d m_velocity_last; // 348
	char _pad6[ 0x45 ]; // 360
	bool m_player_is_accelerating; // 429
	char _pad7[ 0x2 ]; // 430
	animstate_pose_param_cache m_pose_param_mappings[ 20 ]; // 432
	float m_duration_move_weight_is_too_high; // 672
	float m_static_approach_speed; // 676
	int m_previous_move_state; // 680
	float m_stutter_step; // 684
	char _pad8[ 0x80 ]; // 688
	float m_aim_yaw_min; // 816
	float m_aim_yaw_max; // 820
	float m_aim_pitch_min; // 824
	float m_aim_pitch_max; // 828
	int m_animstate_version; // 832

	// custom members
	float m_lower_body_realign_timer;

};
```

`valve/shared/game_movement.h`:

```h
#pragma once

struct base_player;

struct move_data {



};

struct game_movement {

	inline auto process_movement( base_player* player, move_data* move ) {

		return m_utils.get_v_func< void( __thiscall* )( void*, base_player*, move_data* ) >( this, 1 )( this, player, move );

	}

	inline auto reset( ) {

		return m_utils.get_v_func< void( __thiscall* )( void* ) >( this, 2 )( this );

	}

	inline auto start_track_prediction_errors( base_player* player ) {

		return m_utils.get_v_func< void( __thiscall* )( void*, base_player* ) >( this, 3 )( this, player );

	}

	inline auto finish_track_prediction_errors( base_player* player ) {

		return m_utils.get_v_func< void( __thiscall* )( void*, base_player* ) >( this, 4 )( this, player );

	}

};
```

`valve/shared/in_buttons.h`:

```h
#pragma once

#define in_attack ( 1 << 0 )
#define in_jump ( 1 << 1 )
#define in_duck ( 1 << 2 )
#define in_forward ( 1 << 3 )
#define in_back ( 1 << 4 )
#define in_use ( 1 << 5 )
#define in_cancel ( 1 << 6 )
#define in_left ( 1 << 7 )
#define in_right ( 1 << 8 )
#define in_move_left ( 1 << 9 )
#define in_move_right ( 1 << 10 )
#define in_attack2 ( 1 << 11 )
#define in_run ( 1 << 12 )
#define in_reload ( 1 << 13 )
#define in_alt1 ( 1 << 14 )
#define in_alt2 ( 1 << 15 )
#define in_score ( 1 << 16 )
#define in_speed ( 1 << 17 )
#define in_walk ( 1 << 18 )
#define in_zoom ( 1 << 19 )
#define in_weapon1 ( 1 << 20 )
#define in_weapon2 ( 1 << 21 )
#define in_bull_rush ( 1 << 22 )
#define in_grenade1 ( 1 << 23 )
#define in_grenade2 ( 1 << 24 )
#define in_attack3 ( 1 << 25 )
```

`valve/shared/move_helper.h`:

```h
#pragma once

struct move_helper {

	inline auto process_impacts( ) {

		return m_utils.get_v_func< void( __thiscall* )( void* ) >( this, 4 )( this );

	}

};
```

`valve/shared/shared.h`:

```h
#pragma once

#include "base_view_model.h"
#include "csgo_player_anim_state.h"
#include "game_movement.h"
#include "in_buttons.h"
#include "move_helper.h"
#include "user_cmd.h"
```

`valve/shared/user_cmd.h`:

```h
#pragma once

struct user_cmd {

    char _pad0[ 0x4 ]; // 0
    int m_command_number; // 4
    int m_tick_count; // 8
    q_angle m_view_angles; // 12
    vector_3d m_aim_direction; // 24
    float m_forward_move; // 36
    float m_side_move; // 40
    float m_up_move; // 44
    int	m_buttons; // 48
    int	m_impulse; // 52
    int	m_weapon_select; // 56
    int	m_weapon_sub_type; // 60
    int	m_random_seed; // 64
    short m_moused_x; // 68
    short m_moused_y; // 70
    bool m_has_been_predicted; // 72
    q_angle head_angles; // 73
    vector_3d head_offset; // 85

};
```

`valve/studio.h`:

```h
#pragma once

struct mstudioseqdesc {

	char _pad0[ 0xc4 ]; // 0
	int numanimtags; // 196

};

struct studio_hdr {

	inline auto seqdesc( int seq ) {

		static auto function = m_modules.m_client_dll.get_address( "CStudioHdr::pSeqdesc" ).as< mstudioseqdesc& ( __thiscall* )( void*, int ) >( );

		return function( this, seq );

	}

};
```

`valve/studio_render/studio_render.h`:

```h
#pragma once

#include "studio_render_context.h"

struct draw_model_info {

	char _pad0[ 0x18 ];
	std::size_t m_client_entity;

};
```

`valve/studio_render/studio_render_context.h`:

```h
#pragma once

struct studio_render_context {

	char _pad0[ 0x240 ]; // 0
	float m_color_mod[ 3 ]; // 576
	float m_alpha_mod; // 588
	material* m_forced_material[ 4 ]; // 592
	int m_forced_material_type; // 608
	int m_forced_material_index[ 4 ]; // 612
	int m_forced_material_index_count; // 628

	inline auto set_color( const color& color ) {

		m_color_mod[ 0 ] = static_cast< float >( color.r ) / 255.f;
		m_color_mod[ 1 ] = static_cast< float >( color.g ) / 255.f;
		m_color_mod[ 2 ] = static_cast< float >( color.b ) / 255.f;

	}

	inline auto set_alpha( float alpha ) {

		m_alpha_mod = alpha;

	}

	inline auto set_material( material* material, bool ignore_z = true ) {
		
		if ( material )
			material->set_material_var_flag( 1 << 15, ignore_z );

		m_forced_material_type = 0;
		m_forced_material[ 0 ] = material;
		m_forced_material_index[ 0 ] = -1;
		m_forced_material_index_count = 0;

	}

};
```

`valve/tier0/mem_alloc.h`:

```h
#pragma once

struct mem_alloc {

	inline auto alloc( std::size_t size ) {

		return m_utils.get_v_func< void* ( __thiscall* )( void*, std::size_t ) >( this, 1 )( this, size );

	}

};
```

`valve/tier0/tier0.h`:

```h
#pragma once

#include "mem_alloc.h"
```

`valve/tier1/bitbuf.h`:

```h
#pragma once

inline int bit_byte( int bits ) {

	return ( bits + 7 ) >> 3;

}

struct bf_write {

	void start_writing( void* data, int bytes, int start_bit = 0, int bits = -1 ) {

		bytes &= ~3;

		m_data = ( unsigned char* )data;
		m_data_bytes = bytes;

		if ( bits == -1 )
			m_data_bits = bytes << 3;
		else 
			m_data_bits = bits;

		m_cur_bit = start_bit;
		m_overflow = false;

	}

	inline unsigned char* get_data( ) { 
		
		return m_data;

	}

	inline int get_num_bytes_written( ) const {

		return bit_byte( m_cur_bit );

	}

	unsigned char* m_data;
	int m_data_bytes;
	int m_data_bits;
	int m_cur_bit;

private:

	bool m_overflow;
	bool m_assert_on_overflow;
	const char* m_debug_name;

};
```

`valve/tier1/interface.h`:

```h
#pragma once

using instantiate_interface_fn = void* ( __cdecl* )( );

struct interface_reg {
public:

	instantiate_interface_fn m_create_fn;
	const char* m_name;
	interface_reg* m_next;

};
```

`valve/tier1/localize.h`:

```h
#pragma once

struct localize {

	inline auto find( char const* token_name ) {

		return m_utils.get_v_func< wchar_t* ( __thiscall* )( void*, char const* ) >( this, 11 )( this, token_name );

	}

};
```

`valve/tier1/tier1.h`:

```h
#pragma once

#include "bitbuf.h"
#include "interface.h"
#include "localize.h"
```

`valve/valve.h`:

```h
#pragma once

#include "modules/modules.h"

#include "client/client.h"
#include "data_cache/data_cache.h"
#include "engine/engine.h"
#include "interfaces/interfaces.h"
#include "material_system/material_system.h"
#include "mathlib/mathlib.h"
#include "netvars/netvars.h"
#include "shared/shared.h"
#include "studio_render/studio_render.h"
#include "tier0/tier0.h"
#include "tier1/tier1.h"
#include "vgui/vgui.h"

#include "engine_vgui.h"
#include "net_channel.h"
```

`valve/vgui/surface.h`:

```h
#pragma once

#include "../modules/modules.h"

using h_font = unsigned long;

enum font_draw_type {

	font_draw_default = 0,
	font_draw_nonadditive,
	font_draw_additive,
	font_draw_type_count = 2,

};

enum font_flags {

	fontflag_none,
	fontflag_italic = 0x001,
	fontflag_underline = 0x002,
	fontflag_strikeout = 0x004,
	fontflag_symbol = 0x008,
	fontflag_antialias = 0x010,
	fontflag_gaussianblur = 0x020,
	fontflag_rotary = 0x040,
	fontflag_dropshadow = 0x080,
	fontflag_additive = 0x100,
	fontflag_outline = 0x200,
	fontflag_custom = 0x400,
	fontflag_bitmap = 0x800,

};

struct surface {

	inline auto draw_set_color( int r, int g, int b, int a ) {

		return m_utils.get_v_func< void( __thiscall* )( void*, int, int, int, int ) >( this, 15 )( this, r, g, b, a );

	}

	inline auto draw_filled_rect( int x0, int y0, int x1, int y1 ) {

		return m_utils.get_v_func< void( __thiscall* )( void*, int, int, int, int ) >( this, 16 )( this, x0, y0, x1, y1 );

	}

	inline auto draw_outlined_rect( int x0, int y0, int x1, int y1 ) {

		return m_utils.get_v_func< void( __thiscall* )( void*, int, int, int, int ) >( this, 18 )( this, x0, y0, x1, y1 );

	}

	inline auto draw_line( int x0, int y0, int x1, int y1 ) {

		return m_utils.get_v_func< void( __thiscall* )( void*, int, int, int, int ) >( this, 19 )( this, x0, y0, x1, y1 );

	}

	inline auto draw_set_text_font( h_font font ) {

		return m_utils.get_v_func< void( __thiscall* )( void*, h_font ) >( this, 23 )( this, font );

	}

	inline auto draw_set_text_color( int r, int g, int b, int a ) {

		return m_utils.get_v_func< void( __thiscall* )( void*, int, int, int, int ) >( this, 25 )( this, r, g, b, a );

	}

	inline auto draw_set_text_pos( int x, int y ) {

		return m_utils.get_v_func< void( __thiscall* )( void*, int, int ) >( this, 26 )( this, x, y );

	}

	inline auto draw_print_text( const wchar_t* text, int text_len, font_draw_type draw_type = font_draw_default ) {

		return m_utils.get_v_func< void( __thiscall* )( void*, const wchar_t*, int, font_draw_type ) >( this, 28 )( this, text, text_len, draw_type );

	}

	inline auto get_screen_size( int& wide, int& tall ) {

		return m_utils.get_v_func< void( __thiscall* )( void*, int&, int& ) >( this, 44 )( this, wide, tall );

	}

	inline auto unlock_cursor( ) {

		return m_utils.get_v_func< void( __thiscall* )( void* ) >( this, 66 )( this );

	}

	inline auto create_font( ) {

		return m_utils.get_v_func< h_font( __thiscall* )( void* ) >( this, 71 )( this );

	}

	inline auto set_font_glyph( h_font font, const char* windows_font_name, int tall, int weight, int blur, int scanlines, int flags, int range_min = 0, int range_max = 0 ) {

		return m_utils.get_v_func< void( __thiscall* )( void*, h_font, const char*, int, int, int, int, int, int, int ) >( this, 72 )( this, font, windows_font_name, tall, weight, blur, scanlines, flags, range_min, range_max  );

	}

	inline auto get_text_size( h_font font, const wchar_t* text, int& wide, int& tall ) {

		return m_utils.get_v_func< void( __thiscall* )( void*, h_font, const wchar_t*, int&, int& ) >( this, 79 )( this, font, text, wide, tall );

	}

	inline auto start_drawing( ) {

		static auto function = m_modules.m_vguimatsurface_dll.get_address( "CMatSystemSurface::StartDrawing" ).as< void( __thiscall* )( void* ) >( );

		return function( this );

	}

	inline auto finish_drawing( ) {

		static auto function = m_modules.m_vguimatsurface_dll.get_address( "CMatSystemSurface::FinishDrawing" ).as< void( __thiscall* )( void* ) >( );

		return function( this );

	}

};
```

`valve/vgui/vgui.h`:

```h
#pragma once

#include "surface.h"
```